;;; -*- Mode: LISP; Syntax: Common-Lisp; Package: CLtL-Internals; Base: 10 -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
;;;
;;; FUNCTION: Function definitions which try to match CLtL very closely.

;;;
;;;
;;; Notes:
;;;
;;;  * A number of things in here fix discrepancies between CLTL's functions
;;;    that take &KEY and ours. Mail has been sent about this problem 
;;;    from KMP to Bug-Lispm and Bug-Lmdoc.
;;;    References: <870422162158.9.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>,
;;;		   <870422015336.5.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>
;;;
;;;  * Things to do:
;;;    o Need to implement ARRAY-ELEMENT-TYPE, MAKE-ARRAY, etc. in portable fashion.


;;; Notes:
;;;
;;;  CLtL does not define a type STRUCTURE which Genera does.
;;;  It's shadowed it for now, so people don't do (TYPEP x 'STRUCTURE).
;;;  This means we have to make DOCUMENTATION know about a second arg of our 
;;;  symbol STRUCTURE, though.
;;;
;;;  In CLtL (p440), it says that both arguments to DOCUMENTATION must be symbols.
;;;  Due to a bug in Rel7 Genera, (DOCUMENTATION 'NIL) thinks that NIL is a NULL
;;;  rather than a SYMBOL. This will presumably be fixed in a later release, but
;;;  in the mean time we might want to think about fixing it.
;;;  It also says that both arguments are required.
;;;
;;;  This bug in System 349.263 was reported to Bug-Lispm by Kent M Pitman, 19 Feb 87.
;;;  References: <870219174124.8.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>
;;;
;;;  DOCUMENTATION also takes the wrong number of arguments in Genera. The second
;;;  argument claims to be optional, but CLtL doesn't let it be. We need to set up
;;;  DOCUMENTATION and SETF of DOCUMENTATION to fix this.


(DEFVAR *NIL-DOC* (MAKE-HASH-TABLE))

(DEFUN STANDARDIZE-DOC-TYPE (TYPE ALLOW-EXTENSIONS)
  (DECLARE (DBG:ERROR-REPORTER))
  (SETQ TYPE (OR (CDR (ASSOC TYPE '((CLTL:STRUCTURE . STRUCTURE)))) TYPE))
  (UNLESS ALLOW-EXTENSIONS
    (UNLESS (MEMBER TYPE '(VARIABLE FUNCTION STRUCTURE TYPE SETF))
      (ERROR "~S is not a Common Lisp documentation type." TYPE)))
  TYPE)

(DEFUN CLTL:DOCUMENTATION (SYMBOL TYPE)
  (SETQ TYPE (STANDARDIZE-DOC-TYPE TYPE NIL))
  (VALUES (IF (EQ SYMBOL 'NIL)
	      (GETHASH TYPE *NIL-DOC*)
	      (DOCUMENTATION SYMBOL TYPE))))

(DEFUN SET-DOCUMENTATION (SYMBOL TYPE VALUE)
  (SETQ TYPE (STANDARDIZE-DOC-TYPE TYPE NIL))
  (VALUES (IF (EQ SYMBOL 'NIL)
	      (SETF (GETHASH TYPE *NIL-DOC*) VALUE)
	      (SETF (DOCUMENTATION SYMBOL TYPE) VALUE))))

(DEFSETF CLTL:DOCUMENTATION (SYMBOL TYPE) (VALUE)
  `(SET-DOCUMENTATION ,SYMBOL ,TYPE ,VALUE))


;;; Notes:
;;;
;;;  CLtL (p76) says:
;;;
;;;   ``FUNCTIONP is true if its argument is suitable for applying to arguments, using
;;;     for example the FUNCALL or APPLY function. Otherwise, FUNCTIONP is false.
;;;     FUNCTIONP is always true of symbols, lists whose car is the symbol LAMBDA,
;;;     any value returned by the FUNCTION special form, and any values returned
;;;     by the function COMPILE when its first argument is NIL.''
;;;
;;;  The standard Genera definition of CL:FUNCTIONP yields true of symbols only if they
;;;  are also FBOUNDP, which is clearly in conflict with this definition.
;;;
;;;  The standard Genera definition of CL:FUNCTIONP also accepts an optional argument
;;;  which is not mentioned in CLtL.


(DEFSUBST CLTL:FUNCTIONP (THING)
  (OR (SYMBOLP THING) (FUNCTIONP THING)))


;;; Notes:
;;;
;;;  The standard Genera definition of CL:OPEN is in conflict with the definition of OPEN
;;;  in CLtL (p418-422) in a number of ways.
;;;
;;;   It uses a default :ELEMENT-TYPE of CHARACTER, not STRING-CHAR.
;;;   It accepts a :ELEMENT-TYPE of :IN and :OUT (for ZL/Maclisp compatibility).
;;;   It accepts additional ZL/Maclisp compatible keywords not defined in CLtL.
;;;
;;;  Since WITH-OPEN-FILE expands to use OPEN, we shadow CL:WITH-OPEN-FILE in order
;;;  to make a revised definition that will use our revised definition of OPEN.


(DEFSUBST CHECK-OPEN-ELEMENT-TYPE (X)
  (TYPECASE X
    (CONS      (MEMBER (CAR X) '(SIGNED-BYTE UNSIGNED-BYTE MOD)))
    (SYMBOL    (MEMBER X '(STRING-CHAR UNSIGNED-BYTE SIGNED-BYTE CHARACTER BIT :DEFAULT)))
    (OTHERWISE NIL)))

(DEFUN CLTL:OPEN (FILE &KEY (DIRECTION         ':INPUT)
		  	    (ELEMENT-TYPE      'STRING-CHAR)
			    (IF-EXISTS         NIL IF-EXISTS-P)
			    (IF-DOES-NOT-EXIST NIL IF-DOES-NOT-EXIST-P))
  (CHECK-TYPE DIRECTION    (MEMBER :INPUT :OUTPUT :IO :PROBE))
  (CHECK-TYPE ELEMENT-TYPE (SATISFIES CHECK-OPEN-ELEMENT-TYPE))
  (WHEN IF-EXISTS-P
    (CHECK-TYPE IF-EXISTS (MEMBER :ERROR :NEW-VERSION :RENAME :RENAME-AND-DELETE
				  :OVERWRITE :APPEND :SUPERSEDE NIL)))
  (WHEN IF-DOES-NOT-EXIST-P
    (CHECK-TYPE IF-DOES-NOT-EXIST (MEMBER :ERROR :CREATE NIL)))
  (APPLY #'OPEN
	 FILE
	 :DIRECTION DIRECTION
	 :ELEMENT-TYPE ELEMENT-TYPE
	 (APPEND (IF IF-EXISTS-P         `(:IF-EXISTS             ,IF-EXISTS)         '())
		 (IF IF-DOES-NOT-EXIST-P `(:IF-DOES-NOT-EXIST     ,IF-DOES-NOT-EXIST) '()))))

(DEFMACRO CLTL:WITH-OPEN-FILE ((VARIABLE FILE . OPEN-OPTIONS) &BODY FORMS)
  `(WITH-OPEN-STREAM (,VARIABLE (CLTL:OPEN ,FILE ,@OPEN-OPTIONS))
     ,@FORMS))


;;; Notes:
;;;
;;;  Functions which manipulate packages do not accept strings (names of packages)
;;;  in place of package objects in all implementations. Here we add the requisite
;;;  type-check.


(DEFUN CLTL:RENAME-PACKAGE (PACKAGE NEW-NAME &OPTIONAL (NEW-NICKNAMES '()))
  (CHECK-TYPE PACKAGE PACKAGE)
  (SI:RENAME-PACKAGE-FOR-SYNTAX-LOCALLY PACKAGE NEW-NAME NEW-NICKNAMES :CLTL)
  PACKAGE)

(DEFUN CLTL:INTERN (STRING &OPTIONAL (PACKAGE *PACKAGE*))
  (DECLARE (VALUES SYMBOL STATUS))
  (CHECK-TYPE PACKAGE PACKAGE)
  (INTERN STRING PACKAGE))

(DEFUN CLTL:FIND-SYMBOL (STRING &OPTIONAL (PACKAGE *PACKAGE*))
  (CHECK-TYPE PACKAGE PACKAGE)
  (FIND-SYMBOL STRING PACKAGE))

(DEFUN CLTL:UNINTERN (SYMBOL &OPTIONAL (PACKAGE *PACKAGE*))
  (CHECK-TYPE PACKAGE PACKAGE)
  (UNINTERN SYMBOL PACKAGE))


;;; Notes:
;;;
;;;  Functions which manipulate symbols in packages do not accept strings 
;;;  (names of packages) in place of symbols or in place of package objects
;;;  in all implementations. Here we add the requisite type-check.
;;;
;;;  Also, CLtL (p186) says that unexporting from the keyword package is an
;;;  error, so we'll signal an error when that happens.


(DEFMACRO CHECK-SYMBOL-OR-LIST-OF-SYMBOLS (VAR)
  `(SYS:CHECK-ARG ,VAR (TYPECASE ,VAR
			 (SYMBOL    T)
			 (CONS      (EVERY #'SYMBOLP ,VAR))
			 (OTHERWISE NIL))
		  "a symbol or list of symbols"))

(DEFUN CLTL:EXPORT (SYMBOL &OPTIONAL (PACKAGE *PACKAGE*))
  (CHECK-SYMBOL-OR-LIST-OF-SYMBOLS SYMBOL)
  (CHECK-TYPE PACKAGE PACKAGE)
  (EXPORT SYMBOL PACKAGE))

(DEFPROP CLTL:EXPORT CLI::IMPORT-EXPORT-COMPILER-TOP-LEVEL-FORM COMPILER:TOP-LEVEL-FORM)

(DEFUN CLTL:UNEXPORT (SYMBOL &OPTIONAL (PACKAGE *PACKAGE*))
  (CHECK-SYMBOL-OR-LIST-OF-SYMBOLS SYMBOL)
  (CHECK-TYPE PACKAGE PACKAGE)
  (IF (EQ PACKAGE *KEYWORD-PACKAGE*) (ERROR "You may not unexport ~S from ~S" SYMBOL PACKAGE))
  (UNEXPORT SYMBOL PACKAGE))

(SETF (GET 'CLTL:UNEXPORT 'COMPILER:TOP-LEVEL-FORM) 'CLI::EVAL-AT-COMPILE-TIME)

(DEFUN CLTL:IMPORT (SYMBOL &OPTIONAL (PACKAGE *PACKAGE*))
  (CHECK-SYMBOL-OR-LIST-OF-SYMBOLS SYMBOL)
  (CHECK-TYPE PACKAGE PACKAGE)
  (IMPORT SYMBOL PACKAGE))

(DEFUN CLTL:SHADOWING-IMPORT (SYMBOL &OPTIONAL (PACKAGE *PACKAGE*))
  (CHECK-SYMBOL-OR-LIST-OF-SYMBOLS SYMBOL)
  (CHECK-TYPE PACKAGE PACKAGE)
  (SHADOWING-IMPORT SYMBOL PACKAGE))

(DEFPROP CLTL:IMPORT CLI::IMPORT-EXPORT-COMPILER-TOP-LEVEL-FORM COMPILER:TOP-LEVEL-FORM)

(DEFPROP CLTL:SHADOWING-IMPORT
	 CLI::IMPORT-EXPORT-COMPILER-TOP-LEVEL-FORM
	 COMPILER:TOP-LEVEL-FORM)

(DEFUN CLTL:SHADOW (SYMBOL &OPTIONAL (PACKAGE *PACKAGE*))
  (CHECK-SYMBOL-OR-LIST-OF-SYMBOLS SYMBOL)
  (CHECK-TYPE PACKAGE PACKAGE)
  (SHADOW SYMBOL PACKAGE))

(DEFUN (CLTL:SHADOW COMPILER:TOP-LEVEL-FORM) (FORM)
  (EVAL FORM)
  (IF (COMPILER:CONSTANT-FORM-P (SECOND FORM))
      (LET ((SYMBOLS (COMPILER:CONSTANT-EVALUATOR (SECOND FORM))))
	`(LOAD-TIME-SHADOW ,(IF (ATOM SYMBOLS)
				(STRING SYMBOLS)
				`',(MAPCAR #'STRING SYMBOLS))
			   ,@(NTHCDR 2 FORM)))
      FORM))

(DEFUN LOAD-TIME-SHADOW (&REST ARGS) (APPLY #'SHADOW ARGS))


;;; Notes:
;;;
;;;  Functions which create packages accept only the keywords :NICKNAME and :USE.
;;;
;;;  These definitions are also necessary in order to assure that our new LISP package
;;;  gets used instead of the old system LISP package (now called just CL).


(DEFUN CLTL-SYNTAX ()
  (LET ((SYNTAX (SI:CURRENT-LISP-SYNTAX)))
    (IF (EQ (SI:LISP-SYNTAX-NAME-SYMBOL SYNTAX) :CLTL-ONLY)
	:CLTL-ONLY
	:CLTL)))

(DEFUN CLTL:FIND-PACKAGE (NAME)
  (DECLARE LT:(SIDE-EFFECTS READER))
  (SYS:FIND-PACKAGE-FOR-SYNTAX NAME (CLTL-SYNTAX) :FIND))

(DEFUN CLTL:MAKE-PACKAGE (NAME &KEY NICKNAMES (USE "LISP"))
  (SI:MAKE-PACKAGE-FOR-SYNTAX NAME :NICKNAMES NICKNAMES :USE USE :SYNTAX (CLTL-SYNTAX)))

 ;I'm not sure if this really should have this property, but SCL has it and I
 ;have no obvious reason not to give it to Cloe users, so for now we copy it. -kmp 30-Mar-87
(SETF (GET 'CLTL:MAKE-PACKAGE 'COMPILER:TOP-LEVEL-FORM)
      'CLI::EVAL-AT-COMPILE-TIME)

(DEFUN CLTL:IN-PACKAGE (NAME &KEY (NICKNAMES NIL NICKNAMES-P) (USE "LISP" USE-P))
  (DECLARE (ARGLIST NAME &KEY NICKNAMES USE))
  (LET* ((PACKAGE (CLTL:FIND-PACKAGE NAME))
	 (PACKAGES-TO-USE
	   (MAPCAR #'(LAMBDA (PACKAGE-NAME)
		       (OR (CLTL:FIND-PACKAGE PACKAGE-NAME)
			   (ERROR "There is no package named ~S." PACKAGE-NAME)))
		   (IF (LISTP USE) USE (LIST USE)))))
    (SETQ *PACKAGE*
	  (COND (PACKAGE
		 (LET ((OPTIONS '()))
		   (IF USE-P       (SETQ OPTIONS (LIST* :USE PACKAGES-TO-USE OPTIONS)))
		   (IF NICKNAMES-P (SETQ OPTIONS (LIST* :NICKNAMES NICKNAMES OPTIONS)))
		   (APPLY #'SI:MAKE-PACKAGE-MORE PACKAGE :SYNTAX :CLTL OPTIONS)))
		(T
		 (CLTL:MAKE-PACKAGE NAME
				    :NICKNAMES NICKNAMES
				    :USE PACKAGES-TO-USE))))))

(SETF (GET 'CLTL:IN-PACKAGE 'COMPILER:TOP-LEVEL-FORM)
      'CLI::EVAL-AT-COMPILE-TIME)

(DEFUN CLTL:PACKAGE-NAME (PKG)
  (DECLARE LT:(SIDE-EFFECTS READER))
  (SYS:PACKAGE-NAME-FOR-SYNTAX PKG (CLTL-SYNTAX)))

(DEFUN CLTL:PACKAGE-NICKNAMES (PKG)
  (DECLARE LT:(SIDE-EFFECTS READER))
  (CL:CHECK-TYPE PKG ZL:PACKAGE)
  (SI:PACKAGE-NICKNAMES-FOR-SYNTAX PKG (CLTL-SYNTAX)))


;;; Notes:
;;;
;;;  The functions USE-PACKAGE and UNUSE-PACKAGE don't need to insist on a package

(SETF (GET 'CLTL:USE-PACKAGE 'COMPILER:TOP-LEVEL-FORM) 'CLI::EVAL-AT-COMPILE-TIME)

(DEFUN CLTL:USE-PACKAGE (PACKAGES &OPTIONAL PKG)
  (SI:PACKAGE-PACKAGE-OPERATION PACKAGES PKG #'SI:USE-PACKAGE-INTERNAL (CLTL-SYNTAX))
  T)

(SETF (GET 'CLTL:UNUSE-PACKAGE 'COMPILER:TOP-LEVEL-FORM) 'CLI::EVAL-AT-COMPILE-TIME)

(DEFUN CLTL:UNUSE-PACKAGE (PACKAGES &OPTIONAL PKG)
  (SI:UNUSE-PACKAGE-FOR-SYNTAX PACKAGES PKG (CLTL-SYNTAX)))



;;; Notes:
;;;
;;;  There's really no reason for LIST-ALL-PACKAGES to return packages which have
;;;  no name in the current context. Likewise for DO-ALL-SYMBOLS mapping over symbols
;;;  in inaccessible packages. Fix that...

(DEFUN CLTL:LIST-ALL-PACKAGES ()
  (IF (EQ (CLTL-SYNTAX) :CLTL-ONLY)
      (DELETE-DUPLICATES
	(MAPCAR #'CDR (SI:LISP-SYNTAX-RELATIVE-NAMES (SI:FIND-LISP-SYNTAX :CLTL-ONLY))))
      (LIST-ALL-PACKAGES)))

(DEFMACRO CLTL:DO-ALL-SYMBOLS ((VAR &OPTIONAL RESULT-FORM) &BODY BODY)
  `(DO-ALL-SYMBOLS-INTERNAL #'(LAMBDA (,VAR) (DECLARE (SYS:DOWNWARD-FUNCTION)) ,@BODY)
			    #'(LAMBDA (,VAR) (DECLARE (SYS:DOWNWARD-FUNCTION)) ,RESULT-FORM)))

(DEFUN DO-ALL-SYMBOLS-INTERNAL (BODY-FN RESULT-FN)
  (IF (EQ (CLTL-SYNTAX) :CLTL-ONLY)
      (DOLIST (PKG (CLTL:LIST-ALL-PACKAGES) (FUNCALL RESULT-FN NIL))
	(DO-SYMBOLS (SYM PKG)
	  (FUNCALL BODY-FN SYM)))
      (DO-ALL-SYMBOLS (SYM (FUNCALL RESULT-FN NIL))
	(FUNCALL BODY-FN SYM))))


;;; Notes:
;;;
;;;  Common Lisp does not specify that it is legal to funcall non-functions.
;;;  In particular, arrays and instances are non-functions and should not 
;;;  be funcallable.

(DEFFLAVOR INVALID-CLTL-FUNCTION () (SYS:INVALID-FUNCTION))

(DEFMETHOD (DBG:REPORT INVALID-CLTL-FUNCTION) (STREAM)
  (FORMAT STREAM "The object ~S is not a valid Common Lisp function." (SEND SELF :FUNCTION)))

(PUSH 'CLTL:FUNCALL ZWEI:*IRRELEVANT-FUNCTIONS*)

(DEFUN CLTL:FUNCALL (FUNCTION &REST ARGUMENTS)
  (IF (CLTL:FUNCTIONP FUNCTION)
      (APPLY FUNCTION ARGUMENTS)
      (ERROR 'INVALID-CLTL-FUNCTION :FUNCTION FUNCTION)))

  ;This isn't right, but will suffice for now.
(DEFINE-SETF-METHOD CLTL:FUNCALL (FUNCTION &REST ARGUMENTS)
  (GET-SETF-METHOD-MULTIPLE-VALUE `(FUNCALL ,FUNCTION ,@ARGUMENTS)))

(PUSH 'CLTL:APPLY   ZWEI:*IRRELEVANT-FUNCTIONS*)

(DEFUN CLTL:APPLY (FUNCTION &REST ARGUMENTS)
  (IF (CLTL:FUNCTIONP FUNCTION)
      (APPLY #'APPLY FUNCTION ARGUMENTS)
      (ERROR 'INVALID-CLTL-FUNCTION :FUNCTION FUNCTION)))

  ;This isn't right, but will suffice for now.
(DEFINE-SETF-METHOD CLTL:APPLY (FUNCTION &REST ARGUMENTS)
  (GET-SETF-METHOD-MULTIPLE-VALUE `(APPLY ,FUNCTION ,@ARGUMENTS)))


;;; Notes:
;;;
;;;  PRIN1 should not have a global value.


(DEFF CLTL:PRIN1 #'PRIN1)


;;; Notes:
;;;
;;;  DELETE-DUPLICATES (p254) is not defined to take a :REPLACE keyword as offered
;;;  in Genera.
;;;
;;;  SLEEP (p447) is not defined to take a :SLEEP-REASON keyword as offered in Genera.


(DEFSUBST CLTL:DELETE-DUPLICATES (SEQUENCE
				  &REST KEYWORDS
				  &KEY FROM-END TEST TEST-NOT START END KEY)
  (DECLARE (ARGLIST SEQUENCE &KEY FROM-END (TEST #'EQL) TEST-NOT (START 0) END KEY)
	   (IGNORE FROM-END TEST TEST-NOT START END KEY))
  (APPLY #'DELETE-DUPLICATES SEQUENCE KEYWORDS))

(DEFSUBST CLTL:SLEEP (SECONDS) (SCL:SLEEP SECONDS))



;;; Notes:
;;;
;;;  CHAR-EQUAL is defined by CLtL (p239) to ignore bits.
;;;  In the default Genera environment, this isn't supported.
;;;  Surely this is a CL misfeature, but here we support that misfeature
;;;  in the name of cross-host compatibility.


(COMPILER:DEFINE-COMPARISON-OPERATION CLTL:CHAR-EQUAL
				      (LAMBDA (X Y)
					`(CHAR-EQUAL (CODE-CHAR (CHAR-CODE ,X))
						     (CODE-CHAR (CHAR-CODE ,Y))))
  :ARGLIST (CHAR &REST CHARS))

(COMPILER:DEFINE-COMPARISON-OPERATION CLTL:CHAR-NOT-EQUAL
				      (LAMBDA (X Y)
					`(CHAR-NOT-EQUAL (CODE-CHAR (CHAR-CODE ,X))
							 (CODE-CHAR (CHAR-CODE ,Y))))
  :ARGLIST (CHAR &REST CHARS))

(COMPILER:DEFINE-COMPARISON-OPERATION CLTL:CHAR-LESSP
				      (LAMBDA (X Y)
					`(CHAR-LESSP (CODE-CHAR (CHAR-CODE ,X))
						     (CODE-CHAR (CHAR-CODE ,Y))))
  :ARGLIST (CHAR &REST CHARS))

(COMPILER:DEFINE-COMPARISON-OPERATION CLTL:CHAR-GREATERP
				      (LAMBDA (X Y)
					`(CHAR-GREATERP (CODE-CHAR (CHAR-CODE ,X))
							(CODE-CHAR (CHAR-CODE ,Y))))
  :ARGLIST (CHAR &REST CHARS))

(COMPILER:DEFINE-COMPARISON-OPERATION CLTL:CHAR-NOT-LESSP
				      (LAMBDA (X Y)
					`(CHAR-NOT-LESSP (CODE-CHAR (CHAR-CODE ,X))
							 (CODE-CHAR (CHAR-CODE ,Y))))
  :ARGLIST (CHAR &REST CHARS))

(COMPILER:DEFINE-COMPARISON-OPERATION CLTL:CHAR-NOT-GREATERP
				      (LAMBDA (X Y)
					`(CHAR-NOT-GREATERP (CODE-CHAR (CHAR-CODE ,X))
							    (CODE-CHAR (CHAR-CODE ,Y))))
  :ARGLIST (CHAR &REST CHARS))


;;; Notes:
;;;
;;;  STRING= is defined by CLtL (p300) to take a string argument.
;;;  p299 expands on this by noting that a symbol may substitute for a string
;;;  in any string operation except one that modifies its argument.
;;;  In the default Symbolics implementation, characters are accepted, too.
;;;  These definitions fix that.


(DEFSUBST CLTL:STRING= (STRING1 STRING2 &KEY (START1 0) END1 (START2 0) END2)
  (CHECK-TYPE STRING1 (OR SYMBOL STRING))
  (CHECK-TYPE STRING2 (OR SYMBOL STRING))
  (STRING= STRING1 STRING2 :START1 START1 :END1 END1 :START2 START2 :END2 END2))

(DEFSUBST CLTL:STRING< (STRING1 STRING2 &KEY (START1 0) END1 (START2 0) END2)
  (CHECK-TYPE STRING1 (OR SYMBOL STRING))
  (CHECK-TYPE STRING2 (OR SYMBOL STRING))
  (STRING< STRING1 STRING2 :START1 START1 :END1 END1 :START2 START2 :END2 END2))

(DEFSUBST CLTL:STRING> (STRING1 STRING2 &KEY (START1 0) END1 (START2 0) END2)
  (CHECK-TYPE STRING1 (OR SYMBOL STRING))
  (CHECK-TYPE STRING2 (OR SYMBOL STRING))
  (STRING> STRING1 STRING2 :START1 START1 :END1 END1 :START2 START2 :END2 END2))

(DEFSUBST CLTL:STRING<= (STRING1 STRING2 &KEY (START1 0) END1 (START2 0) END2)
  (CHECK-TYPE STRING1 (OR SYMBOL STRING))
  (CHECK-TYPE STRING2 (OR SYMBOL STRING))
  (STRING<= STRING1 STRING2 :START1 START1 :END1 END1 :START2 START2 :END2 END2))

(DEFSUBST CLTL:STRING>= (STRING1 STRING2 &KEY (START1 0) END1 (START2 0) END2)
  (CHECK-TYPE STRING1 (OR SYMBOL STRING))
  (CHECK-TYPE STRING2 (OR SYMBOL STRING))
  (STRING>= STRING1 STRING2 :START1 START1 :END1 END1 :START2 START2 :END2 END2))

(DEFSUBST CLTL:STRING/= (STRING1 STRING2 &KEY (START1 0) END1 (START2 0) END2)
  (CHECK-TYPE STRING1 (OR SYMBOL STRING))
  (CHECK-TYPE STRING2 (OR SYMBOL STRING))
  (STRING/= STRING1 STRING2 :START1 START1 :END1 END1 :START2 START2 :END2 END2))


;;; Notes:
;;;
;;;  STRING-EQUAL is defined by CLtL (p301) to take a string argument.
;;;  p299 expands on this by noting that a symbol may substitute for a string
;;;  in any string operation except one that modifies its argument.
;;;  In the default Symbolics implementation, characters are accepted, too.
;;;  These definitions fix that.


(DEFSUBST CLTL:STRING-EQUAL (STRING1 STRING2 &KEY (START1 0) END1 (START2 0) END2)
  (CHECK-TYPE STRING1 (OR SYMBOL STRING))
  (CHECK-TYPE STRING2 (OR SYMBOL STRING))
  (STRING-EQUAL STRING1 STRING2 :START1 START1 :END1 END1 :START2 START2 :END2 END2))

(DEFSUBST CLTL:STRING-LESSP (STRING1 STRING2 &KEY (START1 0) END1 (START2 0) END2)
  (CHECK-TYPE STRING1 (OR SYMBOL STRING))
  (CHECK-TYPE STRING2 (OR SYMBOL STRING))
  (STRING-LESSP STRING1 STRING2 :START1 START1 :END1 END1 :START2 START2 :END2 END2))

(DEFSUBST CLTL:STRING-GREATERP (STRING1 STRING2 &KEY (START1 0) END1 (START2 0) END2)
  (CHECK-TYPE STRING1 (OR SYMBOL STRING))
  (CHECK-TYPE STRING2 (OR SYMBOL STRING))
  (STRING-GREATERP STRING1 STRING2 :START1 START1 :END1 END1 :START2 START2 :END2 END2))

(DEFSUBST CLTL:STRING-NOT-GREATERP (STRING1 STRING2 &KEY (START1 0) END1 (START2 0) END2)
  (CHECK-TYPE STRING1 (OR SYMBOL STRING))
  (CHECK-TYPE STRING2 (OR SYMBOL STRING))
  (STRING-NOT-GREATERP STRING1 STRING2 :START1 START1 :END1 END1 :START2 START2 :END2 END2))

(DEFSUBST CLTL:STRING-NOT-LESSP (STRING1 STRING2 &KEY (START1 0) END1 (START2 0) END2)
  (CHECK-TYPE STRING1 (OR SYMBOL STRING))
  (CHECK-TYPE STRING2 (OR SYMBOL STRING))
  (STRING-NOT-LESSP STRING1 STRING2 :START1 START1 :END1 END1 :START2 START2 :END2 END2))

(DEFSUBST CLTL:STRING-NOT-EQUAL (STRING1 STRING2 &KEY (START1 0) END1 (START2 0) END2)
  (CHECK-TYPE STRING1 (OR SYMBOL STRING))
  (CHECK-TYPE STRING2 (OR SYMBOL STRING))
  (STRING-NOT-EQUAL STRING1 STRING2 :START1 START1 :END1 END1 :START2 START2 :END2 END2))


;;; Notes:
;;;
;;;  CLtL (p302) defines STRING-TRIM as taking a string second argument.
;;;  p299 expands on this by noting that a symbol may substitute for a string
;;;  in any string operation except one that modifies its argument.
;;;  In the default Symbolics implementation, characters are accepted, too.
;;;  These definitions fix that.


(DEFSUBST CLTL:STRING-TRIM (SEQUENCE STRING)
  (CHECK-TYPE STRING (OR SYMBOL STRING))
  (STRING-TRIM SEQUENCE STRING))

(DEFSUBST CLTL:STRING-RIGHT-TRIM (SEQUENCE STRING)
  (CHECK-TYPE STRING (OR SYMBOL STRING))
  (STRING-RIGHT-TRIM SEQUENCE STRING))

(DEFSUBST CLTL:STRING-LEFT-TRIM (SEQUENCE STRING)
  (CHECK-TYPE STRING (OR SYMBOL STRING))
  (STRING-LEFT-TRIM SEQUENCE STRING))


;;; Notes:
;;;
;;;  CLtL (p303) defines STRING-UPCASE as taking a string second argument.
;;;  p299 expands on this by noting that a symbol may substitute for a string
;;;  in any string operation except one that modifies its argument.
;;;  In the default Symbolics implementation, characters are accepted, too.
;;;  These definitions fix that.


(DEFSUBST CLTL:STRING-UPCASE (STRING &KEY (START 0) END)
  (CHECK-TYPE STRING (OR SYMBOL STRING))
  (STRING-UPCASE STRING :START START :END END))

(DEFSUBST CLTL:STRING-DOWNCASE (STRING &KEY (START 0) END)
  (CHECK-TYPE STRING (OR SYMBOL STRING))
  (STRING-DOWNCASE STRING :START START :END END))

(DEFSUBST CLTL:STRING-CAPITALIZE (STRING &KEY (START 0) END)
  (CHECK-TYPE STRING (OR SYMBOL STRING))
  (STRING-CAPITALIZE STRING :START START :END END))


;;; Notes:
;;;
;;;  CLtL does not define the AREA argument allowed by a number of
;;;  Genera's CL functions.


(DEFSUBST CLTL:MAKE-LIST (SIZE &KEY INITIAL-ELEMENT)
  (MAKE-LIST SIZE :INITIAL-ELEMENT INITIAL-ELEMENT))

(DEFSUBST CLTL:MAKE-SEQUENCE (TYPE SIZE &KEY (INITIAL-ELEMENT NIL INITIAL-ELEMENT-P))
  (DECLARE (ARGLIST TYPE SIZE &KEY INITIAL-ELEMENT))
  (IF INITIAL-ELEMENT-P
      (MAKE-SEQUENCE TYPE SIZE :INITIAL-ELEMENT INITIAL-ELEMENT)
      (MAKE-SEQUENCE TYPE SIZE)))

(DEFSUBST CLTL:MAKE-STRING (SIZE &KEY (INITIAL-ELEMENT NIL INITIAL-ELEMENT-P))
  (DECLARE (ARGLIST SIZE &KEY INITIAL-ELEMENT))
  (IF INITIAL-ELEMENT-P
      (MAKE-STRING SIZE :INITIAL-ELEMENT INITIAL-ELEMENT)
      (MAKE-STRING SIZE)))


(DEFSUBST CLTL:COPY-LIST (LIST)			;CLtL, p268
  (COPY-LIST LIST))

(DEFSUBST CLTL:COPY-ALIST (ALIST)		;CLtL, p268
  (COPY-ALIST ALIST))

(DEFSUBST CLTL:COPY-SEQ (SEQUENCE)		;CLtL, p248
  (COPY-SEQ SEQUENCE))


;;; Notes:
;;;
;;;  CLtL (p323) defines APPLYHOOK and EVALHOOK as functions, but not as variables.
;;;  Since in ZL these are variables, and these symbols are shared, we get unwanted
;;;  variables.
;;;
;;;  Note that the definition of EVALHOOK in Genera allows arg3 (the applyhook)
;;;  to be optional. We should fix this sometime, but have to do it carefully since
;;;  we don't want to invoke the APPLYHOOK on the transition between our EVALHOOK
;;;  and Genera's. For now we've left this one alone.


(DEFF CLTL:APPLYHOOK #'SCL:APPLYHOOK)
(DEFF CLTL:EVALHOOK  #'SCL:EVALHOOK)


;;; Notes:
;;;
;;;  CLtL (p304) defines STRING-UPCASE as taking a string, a symbol, or a string-char.
;;;  The default Symbolics implementation also allows pathnames (and perhaps other junk).
;;;  This fixes that.

#||


(DEFUN CLTL:STRING (THING)
  (CHECK-TYPE THING (OR STRING SYMBOL STRING-CHAR))
  (STRING THING))

(DEFTYPE CLTL:STRING (&REST ARGUMENTS)
  `(STRING ,@ARGUMENTS))

;; This is not currently installed because it isn't complete enough. For example,
;; TYPE-OF will return CL:STRING, not CLTL:STRING. We'll have to think more about 
;; what to do here. Printing in the #S(..) notation has this same problem.


||#


;;; Notes:
;;;
;;;  CLtL (p385-407) defines lots of FORMAT ops, but not as many as SCL.  

#||



(DEFF CLTL:FORMAT #'FORMAT)

 ;Need to make compiler style checker. See (:PROPERTY FORMAT COMPILER:STYLE-CHECKER).
 ;Maybe also compiler optimizers. See (SYMBOL-PLIST 'FORMAT).

||#


;;; Notes:
;;;
;;;  The Genera implementation of WRITE and WRITE-TO-STRING do not use the &KEY
;;;  mechanism directly, which means that they risk blowing the keyword protocol,
;;;  as happened in 7.0 and 7.1. The patch below corrects the behavior.
;;;
;;;  Mail sent by KMP to Bug-Lispm, 22-Apr-87
;;;  References: <870422162158.9.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>


(DEFMACRO CHECK-KEYS (VAR &REST KEY-LIST)
  (SYS:CHECK-ARG VAR SYMBOLP "a symbol")
  (SYS:CHECK-ARG KEY-LIST (EVERY #'KEYWORDP KEY-LIST) "a list of keywords")
  (LET ((FLAG (GENSYM)) (FLAG-P (GENSYM)) (OLD-ARGS (GENSYM)) (NEW-ARGS (GENSYM)))
    `(MULTIPLE-VALUE-BIND (,FLAG-P ,FLAG)
	 (GET-PROPERTIES ,VAR '(:ALLOW-OTHER-KEYS))
       (WHEN ,FLAG-P
	      (DO ((,OLD-ARGS ,VAR (CDDR ,OLD-ARGS))
		   (,NEW-ARGS '()))
		  ((NULL ,OLD-ARGS) (SETQ ,VAR (NREVERSE ,NEW-ARGS)))
		(WHEN (OR (AND (NOT ,FLAG) (NEQ (FIRST ,OLD-ARGS) ':ALLOW-OTHER-KEYS))
			  (MEMBER (FIRST ,OLD-ARGS) ',KEY-LIST))
		  (PUSH (FIRST  ,OLD-ARGS) ,NEW-ARGS)
		  (PUSH (SECOND ,OLD-ARGS) ,NEW-ARGS))))
       (UNLESS (AND ,FLAG-P ,FLAG)
	 (SYS:CHECK-ARG ,VAR
			(DO ((,OLD-ARGS ,VAR (CDDR ,OLD-ARGS)))
			    ((NULL ,OLD-ARGS) T)
			  (UNLESS (MEMBER (FIRST ,OLD-ARGS) ',KEY-LIST)
			    (RETURN NIL)))
			"a list of valid keywords")))))

(DEFMACRO CHECK-WRITE-KEYS (VAR)
  `(CHECK-KEYS ,VAR :STREAM :ESCAPE :RADIX :BASE
	            :CIRCLE :PRETTY :LEVEL :LENGTH
	            :CASE   :GENSYM :ARRAY))

(DEFUN CLTL:WRITE (OBJECT &REST KEYWORD-ARGS)
  ;; This doesn't use &KEY in order to avoid binding special variables for
  ;; keyword arguments not supplied.
  (DECLARE (ARGLIST OBJECT &KEY STREAM ESCAPE RADIX BASE
		    	        CIRCLE PRETTY LEVEL LENGTH
				CASE GENSYM ARRAY))
  (CHECK-WRITE-KEYS KEYWORD-ARGS)
  (SYS:%WITH-BINDING-STACK-LEVEL
    (LET ((STREAM *STANDARD-OUTPUT*))
      (CLI::PROCESS-WRITE-ARGS KEYWORD-ARGS STREAM)
      (CLI::DEFAULT-WRITE-STREAM STREAM)
      (SI:WRITE-INTERNAL OBJECT STREAM))))

(DEFUN CLTL:WRITE-TO-STRING (OBJECT &REST KEYWORD-ARGS)
  ;; This doesn't use &KEY in order to avoid binding special variables for
  ;; keyword arguments not supplied.
  (DECLARE (ARGLIST OBJECT &KEY STREAM ESCAPE RADIX BASE
		    	        CIRCLE PRETTY LEVEL LENGTH
				CASE GENSYM ARRAY))
  (CHECK-WRITE-KEYS KEYWORD-ARGS)
  (SYS:%WITH-BINDING-STACK-LEVEL
    (CLI::PROCESS-WRITE-ARGS KEYWORD-ARGS)
    (WITH-OUTPUT-TO-STRING (STREAM)
      (SI:WRITE-INTERNAL OBJECT STREAM))))



;;; Notes:
;;;
;;;  My reading is that ASSOC-IF (p280), ASSOC-IF-NOT (p280), RASSOC-IF (p281), 
;;;  and RASSOC-IF-NOT (p281) don't necessarily allow :KEY keywords. We forbid
;;;  them for now.
;;;
;;;  Mail was sent from KMP to CL-Cleanup proposing that this be fixed.
;;;  The proposal was named ASSOC-RASSOC-IF-KEY.
;;;  References: <870422151450.7.KMP@RIO-DE-JANEIRO.SCRC.Symbolics.COM>


(DEFSUBST CLTL:ASSOC-IF (PREDICATE A-LIST)
  (ASSOC-IF PREDICATE A-LIST))

(DEFSUBST CLTL:ASSOC-IF-NOT (PREDICATE A-LIST)
  (ASSOC-IF-NOT PREDICATE A-LIST))

(DEFSUBST CLTL:RASSOC-IF (PREDICATE A-LIST)
  (RASSOC-IF PREDICATE A-LIST))

(DEFSUBST CLTL:RASSOC-IF-NOT (PREDICATE A-LIST)
  (RASSOC-IF-NOT PREDICATE A-LIST))



;;; Notes:
;;;
;;;  MAKE-HASH-TABLE (p283) is not defined to take all the keyword
;;;  options that Genera's MAKE-HASH-TABLE offers (:AREA, :HASH-FUNCTION, 
;;;  :REHASH-BEFORE-COLD, :REHASH-AFTER-FULL-GC, :ENTRY-SIZE, :MUTATING,
;;;  :INITIAL-CONTENTS, :OPTIMIZATIONS, :LOCKING, :IGNORE-GC, and :GROWTH-FACTOR).
;;;
;;;  Similarly, MAKE-ARRAY (p286) is not defined to take all the keyword options
;;;  that Genera's MAKE-ARRAY offers (:DISPLACED-CONFORMALLY, :AREA, :LEADER-LIST,
;;;  :LEADER-LENGTH, and :NAMED-STRUCTURE-SYMBOL).
;;;
;;;  Also, ADJUST-ARRAY (p297) does not take a :DISPLACED-CONFORMALLY keyword
;;;  as the Genera implementation offers.
;;;
;;;  Eventually, we're going to want to have MAKE-ARRAY, ADJUST-ARRAY, and
;;;  ADJUSTABLE-ARRAY-P conspire to get consistent behavior with the adjustability
;;;  stuff on the 386. For now, I've just made sure we shadow all three symbols
;;;  so we can make the change later as a patch. -kmp 8-Apr-88


(DEFSUBST CLTL:MAKE-HASH-TABLE (&REST KEYWORDS
			        &KEY TEST SIZE REHASH-SIZE REHASH-THRESHOLD)
  (DECLARE (ARGLIST &KEY TEST SIZE REHASH-SIZE REHASH-THRESHOLD)
	   (IGNORE TEST SIZE REHASH-SIZE REHASH-THRESHOLD))
  (APPLY #'MAKE-HASH-TABLE KEYWORDS))

(DEFVAR *ADJUSTABLE-ARRAYS-BEING-RECORDED* T)
(DEFVAR *ADJUSTABLE-ARRAY-CACHE* (MAKE-HASH-TABLE))

(DEFUN FLUSH-ADJUSTABLE-ARRAY-CACHE ()			;For debugging, etc.
  (SETQ *ADJUSTABLE-ARRAY-CACHE* (MAKE-HASH-TABLE)))

(DEFSUBST ARRAY-IS-ADJUSTABLE-P (ARRAY)
  (VALUES (GETHASH ARRAY *ADJUSTABLE-ARRAY-CACHE*)))

(DEFSUBST CAUSE-ARRAY-TO-BE-ADJUSTABLE (ARRAY)
  (WHEN *ADJUSTABLE-ARRAYS-BEING-RECORDED*
    (SETF (ARRAY-IS-ADJUSTABLE-P ARRAY) T))
  ARRAY)

(DEFSUBST UPGRADE-ELEMENT-TYPE (ELEMENT-TYPE)
  (IF (ATOM ELEMENT-TYPE)
      (IF (MEMBER ELEMENT-TYPE '(T CHARACTER STRING-CHAR FIXNUM BIT))
	  (VALUES ELEMENT-TYPE NIL)
	  (VALUES T T))
      (IF (MEMBER ELEMENT-TYPE '((UNSIGNED-BYTE 16)			;16-Bit
				 (INTEGER 0 (#.(- (EXPT 2 16) 1)))	;16-Bit
				 (INTEGER 0 (#.(EXPT 2 16)))		;16-Bit
				 (MOD #.(EXPT 2 16))			;16-Bit
				 (UNSIGNED-BYTE 1)			;BIT
				 (INTEGER 0 1)				;BIT
				 (INTEGER 0 (2))			;BIT
				 (MOD 2))				;BIT
		  :TEST #'EQUAL)
	  (VALUES ELEMENT-TYPE NIL)
	  (VALUES T T))))

(DEFUN MAKE-ARRAY-SAFELY (DIMENSIONS &REST KEYWORDS
			  &KEY ADJUSTABLE DISPLACED-TO ELEMENT-TYPE
			  &ALLOW-OTHER-KEYS)
  (WHEN ELEMENT-TYPE
    (MULTIPLE-VALUE-BIND (TYPE UPGRADED)
	(UPGRADE-ELEMENT-TYPE ELEMENT-TYPE)
      (WHEN UPGRADED
	(SETQ ELEMENT-TYPE TYPE)
	(SETQ KEYWORDS `(:ELEMENT-TYPE ,TYPE ,@KEYWORDS)))))
  (LET ((ARRAY (APPLY #'MAKE-ARRAY DIMENSIONS KEYWORDS)))
    (COND ((NOT ADJUSTABLE) ARRAY)
	  (T
	   (CAUSE-ARRAY-TO-BE-ADJUSTABLE ARRAY)))
    (WHEN DISPLACED-TO
      (LET ((TARGET-ELEMENT-TYPE (ARRAY-ELEMENT-TYPE DISPLACED-TO))
	    (SOURCE-ELEMENT-TYPE (ARRAY-ELEMENT-TYPE ARRAY)))
	(UNLESS (EQ SOURCE-ELEMENT-TYPE TARGET-ELEMENT-TYPE)
	  (ERROR "An array of type ~S may not be displaced to an array of type ~S."
		 (OR ELEMENT-TYPE SOURCE-ELEMENT-TYPE) TARGET-ELEMENT-TYPE))))
    ARRAY))

(DEFUN CLTL:MAKE-ARRAY (DIMENSIONS &REST KEYWORDS
			&KEY ELEMENT-TYPE INITIAL-ELEMENT
			INITIAL-CONTENTS ADJUSTABLE
			FILL-POINTER DISPLACED-TO
			DISPLACED-INDEX-OFFSET)
  (DECLARE (ARGLIST DIMENSIONS &KEY ELEMENT-TYPE INITIAL-ELEMENT
		    INITIAL-CONTENTS ADJUSTABLE
		    FILL-POINTER DISPLACED-TO
		    DISPLACED-INDEX-OFFSET)
	   (IGNORE ELEMENT-TYPE INITIAL-ELEMENT INITIAL-CONTENTS ADJUSTABLE
		   FILL-POINTER DISPLACED-TO DISPLACED-INDEX-OFFSET))
  (APPLY #'MAKE-ARRAY-SAFELY DIMENSIONS KEYWORDS))

(DEFINE-SIMPLE-OPTIMIZER CLTL:MAKE-ARRAY (DIMENSIONS &REST KEYWORDS
						     &KEY ELEMENT-TYPE INITIAL-ELEMENT
						     INITIAL-CONTENTS ADJUSTABLE
						     FILL-POINTER DISPLACED-TO
						     DISPLACED-INDEX-OFFSET)
  (DECLARE (ARGLIST DIMENSIONS &KEY ELEMENT-TYPE INITIAL-ELEMENT
		    INITIAL-CONTENTS ADJUSTABLE
		    FILL-POINTER DISPLACED-TO
		    DISPLACED-INDEX-OFFSET)
	   (IGNORE ELEMENT-TYPE INITIAL-ELEMENT INITIAL-CONTENTS ADJUSTABLE
		   FILL-POINTER DISPLACED-TO DISPLACED-INDEX-OFFSET))
  ;; Note that the KEYWORDS are not yet evaluated.
  ;; That means our test is a little on the conservative side, which is ok.
  ;; -kmp 16-May-88
  (IF (OR (GETF KEYWORDS :DISPLACED-TO)
	  (GETF KEYWORDS :ADJUSTABLE)
	  (GETF KEYWORDS :ELEMENT-TYPE))
      `(MAKE-ARRAY-SAFELY ,DIMENSIONS ,@KEYWORDS)
      `(MAKE-ARRAY ,DIMENSIONS ,@KEYWORDS)))

(DEFUN CLTL:VECTOR-PUSH-EXTEND (NEW-ELEMENT VECTOR &OPTIONAL (EXTENSION NIL EXTENSION-P))
  ;; This prohibits NIL as an explicit EXTENSION argument
  ;;  and requires the array to be adjustable. -kmp 30-Aug-88
  (DECLARE (ARGLIST NEW-ELEMENT VECTOR &OPTIONAL EXTENSION))
  (WHEN (AND *ADJUSTABLE-ARRAYS-BEING-RECORDED*
	     (ARRAY-HAS-FILL-POINTER-P VECTOR))
    (LET ((FILL-POINTER (FILL-POINTER VECTOR)))
      (WHEN (>= FILL-POINTER (ARRAY-DIMENSION VECTOR 0))
	(IF EXTENSION-P
	    (CHECK-TYPE EXTENSION (INTEGER 0) "a positive integer")
	    (SETQ EXTENSION (IF (< FILL-POINTER 40) 10 (ASH FILL-POINTER -2))))
	(UNLESS (ARRAY-IS-ADJUSTABLE-P VECTOR)
	  (CERROR "Adjust ~S anyway."
		  "~S was not created with :ADJUSTABLE T and implicit adjustment by~
	         ~%VECTOR-PUSH-EXTEND is not permitted."
		  VECTOR)))))
  (VECTOR-PUSH-EXTEND NEW-ELEMENT VECTOR EXTENSION))

(DEFUN CLTL:ADJUST-ARRAY (ARRAY NEW-DIMENSIONS
			  &REST KEYWORDS
			  &KEY ELEMENT-TYPE INITIAL-ELEMENT INITIAL-CONTENTS
			  FILL-POINTER DISPLACED-TO DISPLACED-INDEX-OFFSET)
  (DECLARE (ARGLIST ARRAY NEW-DIMENSIONS
		    &KEY ELEMENT-TYPE INITIAL-ELEMENT INITIAL-CONTENTS
		    FILL-POINTER DISPLACED-TO DISPLACED-INDEX-OFFSET)
	   (IGNORE ELEMENT-TYPE INITIAL-ELEMENT INITIAL-CONTENTS
		   FILL-POINTER DISPLACED-TO DISPLACED-INDEX-OFFSET))
  (WHEN (AND *ADJUSTABLE-ARRAYS-BEING-RECORDED*
	     (NOT (ARRAY-IS-ADJUSTABLE-P ARRAY)))
    (CERROR "Adjust ~S anyway."
	    "~S was not created with :ADJUSTABLE T and may not be adjusted."
	    ARRAY))
  (CAUSE-ARRAY-TO-BE-ADJUSTABLE
    (APPLY #'ADJUST-ARRAY ARRAY NEW-DIMENSIONS KEYWORDS)))

(DEFUN CLTL:ADJUSTABLE-ARRAY-P (ARRAY)		;Placeholder for now.
  (OR (NOT *ADJUSTABLE-ARRAYS-BEING-RECORDED*)	;Don't nag the guy if he's asked us not to...
      (ARRAY-IS-ADJUSTABLE-P ARRAY)))



;;; Notes:
;;;
;;;  The arglist information is wrong for SUBST (p273), SUBST-IF (p273), 
;;;  SUBST-IF-NOT (p273), NSUBST (p274), NSUBST-IF (p274), NSUBST-IF-NOT (p274),
;;;  SUBLIS (p274), and NSUBLIS (p275).
;;;
;;;  These definitions correct the arglist info for purely cosmetic reasons.
;;;  There is no (intended) functional impact of these definitions.





(DEFSUBST CLTL:SUBLIS (A-LIST TREE &REST KEYWORDS &KEY TEST TEST-NOT KEY)
  (DECLARE (ARGLIST A-LIST TREE &KEY TEST TEST-NOT KEY)
	   (IGNORE TEST TEST-NOT KEY))
  (APPLY #'SUBLIS A-LIST TREE KEYWORDS))

(DEFSUBST CLTL:NSUBLIS (A-LIST TREE &REST KEYWORDS &KEY TEST TEST-NOT KEY)
  (DECLARE (ARGLIST A-LIST TREE &KEY TEST TEST-NOT KEY)
	   (IGNORE TEST TEST-NOT KEY))
  (APPLY #'NSUBLIS A-LIST TREE KEYWORDS))

(DEFSUBST CLTL:SUBST (NEW OLD TREE &REST KEYWORDS &KEY TEST TEST-NOT KEY)
  (DECLARE (ARGLIST NEW OLD TREE &KEY TEST TEST-NOT KEY)
	   (IGNORE TEST TEST-NOT KEY))
  (APPLY #'SUBST NEW OLD TREE KEYWORDS))

(DEFSUBST CLTL:SUBST-IF (NEW PREDICATE TREE &REST KEYWORDS &KEY KEY)
  (DECLARE (ARGLIST NEW PREDICATE TREE &KEY KEY)
	   (IGNORE KEY))
  (APPLY #'SUBST-IF NEW PREDICATE TREE KEYWORDS))

(DEFSUBST CLTL:SUBST-IF-NOT (NEW PREDICATE TREE &REST KEYWORDS &KEY KEY)
  (DECLARE (ARGLIST NEW PREDICATE TREE &KEY KEY)
	   (IGNORE KEY))
  (APPLY #'SUBST-IF-NOT NEW PREDICATE TREE KEYWORDS))

(DEFSUBST CLTL:NSUBST (NEW OLD TREE &REST KEYWORDS &KEY TEST TEST-NOT KEY)
  (DECLARE (ARGLIST NEW OLD TREE &KEY TEST TEST-NOT KEY)
	   (IGNORE TEST TEST-NOT KEY))
  (APPLY #'NSUBST NEW OLD TREE KEYWORDS))

(DEFSUBST CLTL:NSUBST-IF (NEW PREDICATE TREE &REST KEYWORDS &KEY KEY)
  (DECLARE (ARGLIST NEW PREDICATE TREE &KEY KEY)
	   (IGNORE KEY))
  (APPLY #'NSUBST-IF NEW PREDICATE TREE KEYWORDS))

(DEFSUBST CLTL:NSUBST-IF-NOT (NEW PREDICATE TREE &REST KEYWORDS &KEY KEY)
  (DECLARE (ARGLIST NEW PREDICATE TREE &KEY KEY)
	   (IGNORE KEY))
  (APPLY #'NSUBST-IF-NOT NEW PREDICATE TREE KEYWORDS))


#|| ; Not needed? -kmp 9-Dec-87

;;; Notes: 
;;;
;;;  TERPRI (p384) and FORMAT (p385) both do abstract operations that must get a new
;;;  line upon seeing a Return. This interacts badly with terminal simulation without
;;;  the following patch.


(DEFUN CLTL:TERPRI (&OPTIONAL (OUTPUT-STREAM NIL OUTPUT-STREAM-P))
  (DECLARE (ARGLIST &OPTIONAL OUTPUT-STREAM))
  (LET ((*LINE-AFTER-RETURN* T))
    (IF OUTPUT-STREAM-P (TERPRI OUTPUT-STREAM) (TERPRI))))

(DEFUN CLTL:FORMAT (DESTINATION CONTROL-STRING &REST ARGUMENTS)
  (LET ((*LINE-AFTER-RETURN* T))
    (APPLY #'FORMAT DESTINATION CONTROL-STRING ARGUMENTS)))

||#




  ;We must do this since we have shadowed PATHNAME
  ;Do -not- make this expand to just PATHNAME or all kinds of confusion will result. -kmp
(DEFTYPE CLTL:PATHNAME () '(SATISFIES PATHNAMEP))

(DEFUN CLTL:PATHNAME (PATHNAME)
  (IF (SYMBOLP PATHNAME)
      (PATHNAME (STRING PATHNAME))
      (PATHNAME PATHNAME)))

(DEFUN CLTL:TRUENAME (PATHNAME)
  (TRUENAME (IF (STREAMP PATHNAME) 
		PATHNAME
	        (CLTL:PATHNAME PATHNAME))))

(DEFUN CLTL:MERGE-PATHNAMES (PATHNAME &OPTIONAL DEFAULTS DEFAULT-VERSION)
  (MERGE-PATHNAMES (CLTL:PATHNAME PATHNAME)
		   (IF DEFAULTS (CLTL:PATHNAME DEFAULTS))
		   DEFAULT-VERSION))


(DEFUN CLTL:PATHNAME-HOST      (PATHNAME) (PATHNAME-HOST      (CLTL:PATHNAME PATHNAME)))
(DEFUN CLTL:PATHNAME-DEVICE    (PATHNAME) (PATHNAME-DEVICE    (CLTL:PATHNAME PATHNAME)))
(DEFUN CLTL:PATHNAME-DIRECTORY (PATHNAME) (PATHNAME-DIRECTORY (CLTL:PATHNAME PATHNAME)))
(DEFUN CLTL:PATHNAME-NAME      (PATHNAME) (PATHNAME-NAME      (CLTL:PATHNAME PATHNAME)))
(DEFUN CLTL:PATHNAME-TYPE      (PATHNAME) (PATHNAME-TYPE      (CLTL:PATHNAME PATHNAME)))
(DEFUN CLTL:PATHNAME-VERSION   (PATHNAME) (PATHNAME-VERSION   (CLTL:PATHNAME PATHNAME)))


(DEFUN CLTL:NAMESTRING           (PATHNAME) (NAMESTRING           (CLTL:PATHNAME PATHNAME)))
(DEFUN CLTL:FILE-NAMESTRING      (PATHNAME) (FILE-NAMESTRING      (CLTL:PATHNAME PATHNAME)))
(DEFUN CLTL:DIRECTORY-NAMESTRING (PATHNAME)
  (LET ((P (CLTL:PATHNAME PATHNAME)))
    (IF (PATHNAME-DIRECTORY P)
	(DIRECTORY-NAMESTRING P)		;SCL's loses if no directory! -kmp 9-Jun-88
	"")))
(DEFUN CLTL:HOST-NAMESTRING      (PATHNAME) (HOST-NAMESTRING      (CLTL:PATHNAME PATHNAME)))
(DEFUN CLTL:ENOUGH-NAMESTRING    (PATHNAME) (ENOUGH-NAMESTRING    (CLTL:PATHNAME PATHNAME)))


;;; Notes:
;;;
;;;  LOAD (p426) does not take the :PACKAGE keyword provided in the Genera implementation.
;;;
;;;  DIRECTORY (p427) does not take the :DELETED keyword provided in the Genera
;;;  implementation.
;;;
;;;  COMPILE-FILE (p439) does not take the :PACKAGE, :LOAD, or :SET-DEFAULT-PATHNAME
;;;  keywords provided in the Genera implementation.

(DEFVAR *LOAD-PRINT* NIL)

(DEFUN CLTL:LOAD (FILE &KEY (VERBOSE *LOAD-VERBOSE*)
		  	    (PRINT *LOAD-PRINT*)
			    (IF-DOES-NOT-EXIST :ERROR))
  (LET ((*SYNTAX-OVERRIDE* T)
	(*PACKAGE* *PACKAGE*)
	(SI:*SPECIAL-DECLARATIONS-ARE-PERVASIVE* NIL))
    (LOAD (CLTL:PATHNAME FILE)
	  :VERBOSE VERBOSE
	  :PRINT PRINT
	  :IF-DOES-NOT-EXIST IF-DOES-NOT-EXIST)))

(DEFUN CLTL:DIRECTORY (PATHNAME &KEY)
  (DIRECTORY (CLTL:PATHNAME PATHNAME)))

(DEFUN CLTL:COMPILE-FILE (INPUT-PATHNAME &KEY (OUTPUT-FILE NIL OUTPUT-FILE-P))
  (DECLARE (ARGLIST INPUT-PATHNAME &KEY OUTPUT-FILE))
  (LET ((*SYNTAX-OVERRIDE* T)
	(*PACKAGE* *PACKAGE*)
	(SI:*SPECIAL-DECLARATIONS-ARE-PERVASIVE* NIL))
    (IF OUTPUT-FILE-P
	(COMPILE-FILE (CLTL:PATHNAME INPUT-PATHNAME) :OUTPUT-FILE (CLTL:PATHNAME OUTPUT-FILE))
	(COMPILE-FILE (CLTL:PATHNAME INPUT-PATHNAME)))))



;;; Notes:
;;;
;;;  APROPOS (p443) and APROPOS-LIST (p443) are only supposed to take arguments
;;;  of STRING &OPTIONAL PACKAGE. Genera allows additional options that it should not.


(DEFUN CLTL:APROPOS (STRING &OPTIONAL (PACKAGE *PACKAGE*))
  (APROPOS STRING PACKAGE))

(DEFUN CLTL:APROPOS-LIST (STRING &OPTIONAL (PACKAGE *PACKAGE*))
  (APROPOS-LIST STRING PACKAGE))



;;; Notes:
;;;
;;;  *FEATURES* (p448) has lots of features in it that will confuse programs
;;;  trying to port (and hence trying not to rely on 3600 features). We make our
;;;  own *FEATURES*.

(DEFVAR CLTL:*FEATURES* (LIST :SYMBOLICS
			      #+3600 3600 #+3600 :|3600|
			      #+Imach :IMACH
			      :CLTL :IEEE-FLOATING-POINT))




(DEFUN CLTL:SOFTWARE-TYPE () "Symbolics Genera")
(DEFUN CLTL:SOFTWARE-VERSION ()
  (MULTIPLE-VALUE-BIND (MAJOR MINOR STATUS)
      (SCT:GET-RELEASE-VERSION)
    (FORMAT NIL "~D.~D~@[ (~:(~A~))~]"
	    MAJOR MINOR (UNLESS (EQ STATUS :RELEASED) STATUS))))


(DEFUN CLTL:MACHINE-TYPE     () "Symbolics")
(DEFUN CLTL:MACHINE-VERSION  () (STRING (SI:MACHINE-MODEL)))
(DEFUN CLTL:MACHINE-INSTANCE () (SEND NET:*LOCAL-HOST* :NAME))

(DEFUN CLTL:LISP-IMPLEMENTATION-TYPE ()
  (FORMAT NIL "Symbolics ~A" (SCT:FIND-SYSTEM-NAMED *DEVELOPER-SYSTEM*)))

(DEFUN CLTL:LISP-IMPLEMENTATION-VERSION ()
  (MULTIPLE-VALUE-BIND (SYSTEM-MAJOR SYSTEM-MINOR)
      (SCT:GET-SYSTEM-VERSION *DEVELOPER-SYSTEM*)
    (FORMAT NIL "~D.~D"D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB") 0SYSTEM-MAJOR SYSTEM-MINOR)))




(DEFUN CLTL:MACROEXPAND (FORM &OPTIONAL (ENV NIL ENV-P))
  (DECLARE (ARGLIST FORM &OPTIONAL ENV))
  (DO ((FORM FORM)
       (FLAG NIL T))
      (NIL)
    (MULTIPLE-VALUE-BIND (EXPANSION DIFFERENT-P)
	(IF ENV-P
	    (CLTL:MACROEXPAND-1 FORM ENV)
	    (CLTL:MACROEXPAND-1 FORM))
      (IF (NOT DIFFERENT-P) (RETURN (VALUES EXPANSION FLAG)))
      (SETQ FORM EXPANSION))))

(DEFUN CLTL:MACROEXPAND-1 (FORM &OPTIONAL (ENV NIL ENV-P) &AUX TEMP)
  (DECLARE (ARGLIST FORM &OPTIONAL ENV))
  (COND ((OR (ATOM FORM)
	     (NOT (SYMBOLP (CAR FORM)))
	     (GET (CAR FORM) 'SPECIAL-FORM))
	 (VALUES FORM NIL))
	((SETQ TEMP (GET (CAR FORM) 'SPECIAL-MACRO))
	 (VALUES (FUNCALL TEMP FORM ENV) T))
	(T
	 (IF ENV-P
	     (MACROEXPAND-1 FORM ENV)
	     (MACROEXPAND-1 FORM)))))

(DEFUN CLTL:MACRO-FUNCTION (FUNCTION)
  (CHECK-TYPE FUNCTION SYMBOL "a symbol")
  (OR (GET FUNCTION 'SPECIAL-MACRO)
      (MACRO-FUNCTION FUNCTION)))


(DEFUN CLTL:SPECIAL-FORM-P (NAME)
  (IF (OR (SPECIAL-FORM-P NAME) (GET NAME 'SPECIAL-FORM)) T NIL))



;;; This stuff is used by Cloe and may someday be used by the CL Developer as well.
;;; For now we'll just leave it alone. -kmp 9-Oct-89

 ;; See CLOE:WITH-INPUT-EDITING-OPTIONS.
(DEFVAR *ECHO-ENABLED* T
  "This variable is not for use by users.")

;;; *TRANSLATE-INPUT-TO-ASCII*
;;;  NIL    = Only in Run Program (and Run Expression)
;;;  T      = Always
;;;  :NEVER = Never

(DEFVAR *TRANSLATE-INPUT-TO-ASCII* NIL)

(DEFUN INTERNAL-ASCII-TO-CHAR (CODE) (ASCII-TO-CHAR CODE))

(DEFSUBST TRANSLATE-ASCII-CHAR (CHAR)
  (IF (AND (CHARACTERP CHAR) (EQ *TRANSLATE-INPUT-TO-ASCII* T))
      (COND ((EQL CHAR #\Escape) (INTERNAL-ASCII-TO-CHAR 27.))
	    ((CHAR-BIT CHAR :CONTROL)
	     (INTERNAL-ASCII-TO-CHAR (LOGAND (CHAR-CODE CHAR) #o37)))
	    (T
	     (INTERNAL-ASCII-TO-CHAR (LOGAND (CHAR-CODE CHAR) #o177))))
      CHAR))

(DEFUN CLTL:READ-CHAR (&OPTIONAL (INPUT-STREAM NIL)
		       	         (EOF-ERROR-P T)
				 (EOF-VALUE NIL)
				 (RECURSIVE-P NIL))
  (CLI::DEFAULT-READ-STREAM INPUT-STREAM)
  (LET ((CHAR (TRANSLATE-ASCII-CHAR (FUNCALL INPUT-STREAM :TYI))))
    (UNLESS (OR (NOT CHAR)
		SI:RUBOUT-HANDLER
		(NOT (FUNCALL INPUT-STREAM :INTERACTIVE)))
      (WHEN *ECHO-ENABLED*
	(FORMAT INPUT-STREAM "~C" CHAR)))
    (COND (CHAR CHAR)
	  ((NOT EOF-ERROR-P) EOF-VALUE)
	  (T (ERROR 'SYS:END-OF-FILE
		    :STREAM INPUT-STREAM
		    :FORMAT-STRING
		    (IF RECURSIVE-P
			"EOF detected by READ-CHAR in the middle of an expression in ~S"
			"READ-CHAR encountered an EOF in ~S"))))))

(DEFUN CLTL:PEEK-CHAR (&OPTIONAL (PEEK-TYPE NIL)
		       	         (INPUT-STREAM NIL)
		       	         (EOF-ERROR-P T)
				 (EOF-VALUE NIL)
				 (RECURSIVE-P NIL))
  (TRANSLATE-ASCII-CHAR (PEEK-CHAR PEEK-TYPE INPUT-STREAM EOF-ERROR-P EOF-VALUE RECURSIVE-P)))



;;; Notes:
;;;
;;;  CLtL (p442) says that DESCRIBE returns no values.
;;;  CL:DESCRIBE returns the described object.


(DEFUN CLTL:DESCRIBE (OBJECT)
  (DESCRIBE OBJECT)
  (VALUES))

;;; Notes:
;;;
;;;  CLtL (p439) says DISASSEMBLE takes only one argument.
;;;
;;;  (Also, it says it takes interpreted functions and compiles them; we don't
;;;  yet support that, but should.)


(DEFUN CLTL:DISASSEMBLE (FUNCTION)
  (DISASSEMBLE FUNCTION))

;;; Notes:
;;;
;;;  CLtL (p442) says that INSPECT requires its argument, which Genera considers
;;;  optional.


(DEFUN CLTL:INSPECT (OBJECT)
  (INSPECT OBJECT))



;;; Notes:
;;;
;;;  CLtL (p443) says DRIBBLE takes only one optional argument. Genera provides
;;;  an extra EDITOR-P argument which we disable.
;;;
;;;  We should provide an interactive interface (ie, a command) that still offered
;;;  this power we're masking out.


(DEFUN CLTL:DRIBBLE (&OPTIONAL (PATHNAME NIL PATHNAME-P))
  (DECLARE (ARGLIST &OPTIONAL PATHNAME))
  (IF PATHNAME-P
      (DRIBBLE (PATHNAME PATHNAME))
      (DRIBBLE)))



;;; Notes:
;;;
;;;  CLtL (p321) says that EVAL takes only one argument.


(DEFUN CLTL:EVAL (FORM)
  (EVAL FORM))

;;; Notes:
;;;
;;;  CLtL (p106-107) says that GET-SETF-METHOD and GET-SETF-METHOD-MULTIPLE-VALUE
;;;  does not take the extra FOR-EFFECT argument that Genera's does.


(DEFUN CLTL:GET-SETF-METHOD (FORM)
  (GET-SETF-METHOD FORM))

(DEFUN CLTL:GET-SETF-METHOD-MULTIPLE-VALUE (FORM)
  (GET-SETF-METHOD-MULTIPLE-VALUE FORM))



;;; Notes:
;;;
;;;  CLtL (p168) says that MAKE-SYMBOL just takes an argument of a string.
;;;  Genera's MAKE-SYMBOL takes an optional PERMANENT-P argument.


(DEFUN CLTL:MAKE-SYMBOL (PRINT-NAME)
  (MAKE-SYMBOL PRINT-NAME))



;;; Notes:
;;;
;;;  CLtL (p296) says that VECTOR-POP just takes an argument of a vector.
;;;  Genera's VECTOR-POP takes an extra optional argument of a default.


(DEFUN CLTL:VECTOR-POP (VECTOR)
  (VECTOR-POP VECTOR))



;;; Notes:
;;;
;;; CLtL (p442) says ROOM is a function, but it doesn't mention it being a variable.


(DEFUN CLTL:ROOM (&OPTIONAL (FLAG NIL FLAG-P))
  (COND ((NOT FLAG-P)
	 (ROOM))
	(T
	 (ECASE FLAG
	   ((NIL T) (ROOM FLAG))))))



;;; Notes:
;;;
;;;  CLtL (p330) specifies a function MAKE-ECHO-STREAM, but Genera doesn't implement it.
;;;  The following function is a crude approximation. -kmp 15-Jul-88


(DEFUN ECHO-STREAM-HANDLER (OP &OPTIONAL (ARG1 NIL ARG1-P) &REST ARGS)
  (DECLARE (SPECIAL *INPUT-STREAM* *ECHO-STREAM* *UNTYI-BUFFER* *INPUT-EDITING*))
  (FLET ((PASS-THROUGH ()
	   (IF ARG1-P
	       (APPLY *INPUT-STREAM* OP ARG1 ARGS)
	       (FUNCALL *INPUT-STREAM* OP))))
    (IF *INPUT-EDITING* (RETURN-FROM ECHO-STREAM-HANDLER (PASS-THROUGH)))
    (CASE OP
      (:WHICH-OPERATIONS '(:TYI :UNTYI :TYIPEEK))
      (:TYI (IF *UNTYI-BUFFER*
		(POP *UNTYI-BUFFER*)
		(LET ((CHAR (PASS-THROUGH)))
		  (IF (CHARACTERP CHAR) (SEND *ECHO-STREAM* :TYO CHAR))
		  CHAR)))
      (:UNTYI (PUSH ARG1 *UNTYI-BUFFER*))
      (:TYIPEEK (IF *UNTYI-BUFFER*
		    (CAR *UNTYI-BUFFER*)
		    (PASS-THROUGH)))
      ((:INPUT-EDITOR)
       (LET ((OLD-*INPUT-EDITING* *INPUT-EDITING*))
	 (UNWIND-PROTECT (MULTIPLE-VALUE-PROG1 (PROGN (SETQ *INPUT-EDITING* T)
						      (PASS-THROUGH))
					       (WRITE-STRING (SEND *INPUT-STREAM* :LAST-INPUT)
							     *ECHO-STREAM*))
	   (SETQ *INPUT-EDITING* OLD-*INPUT-EDITING*))))
      ((:INTERACTIVE :CLOSE)
       (PASS-THROUGH))
      (OTHERWISE
	(SYS:STREAM-DEFAULT-HANDLER 'ECHO-STREAM-HANDLER OP ARG1 ARGS)))))

(DEFUN CLTL:MAKE-ECHO-STREAM (INPUT-STREAM ECHO-STREAM)
  (ZL:LET-CLOSED ((*INPUT-STREAM* INPUT-STREAM)
		  (*ECHO-STREAM*  ECHO-STREAM)
		  (*INPUT-EDITING* NIL)
		  (*UNTYI-BUFFER* '()))
    'ECHO-STREAM-HANDLER))



;;; Notes:
;;;
;;; Genera 7.1d (and apparently some later releases) doesn't implement 
;;; MAKE-CONCATENATED-STREAM correctly. This implementation isn't as efficient
;;; as it might be, but I think it's at least correct. -kmp 23-Feb-89


(DEFUN CONCATENATED-STREAM-HANDLER (OP &OPTIONAL ARG1 &REST ARGS)
  (DECLARE (SPECIAL *STREAMS* *UNTYI-BUFFER*))
  (CASE OP
    (:WHICH-OPERATIONS '(:TYI :UNTYI :INTERACTIVE :CLOSE))
    (:TYI (COND (*UNTYI-BUFFER* (POP *UNTYI-BUFFER*))
		((NOT *STREAMS*) ARG1) ;; For want of something better to do. -kmp 23-Feb-89
		(T (DO ((STREAM (CAR *STREAMS*) (CAR *STREAMS*)))
		       (NIL)
		     (LET ((CHAR (SEND STREAM :TYI NIL)))
		       (COND (CHAR (RETURN CHAR))
			     ((NOT (CDR *STREAMS*)) (RETURN ARG1))
			     (T (POP *STREAMS*))))))))
    (:UNTYI (PUSH ARG1 *UNTYI-BUFFER*))
    ((:INTERACTIVE) NIL)
    ((:CLOSE) (SETQ *STREAMS* NIL) T)
    (OTHERWISE
      (SYS:STREAM-DEFAULT-HANDLER 'CONCATENATED-STREAM-HANDLER OP ARG1 ARGS))))

(DEFUN CLTL:MAKE-CONCATENATED-STREAM (&REST STREAMS)
  (ZL:LET-CLOSED ((*STREAMS* (COPY-LIST STREAMS))
		  (*UNTYI-BUFFER* '()))
    'CONCATENATED-STREAM-HANDLER))

#|| ;; Test cases...

 (read-line (lisp:make-concatenated-stream (make-string-input-stream "foo") 
					   (make-string-input-stream "bar")))

 should return "foobar", T, NIL, NIL

 but returns "foo", T, NIL, NIL in Genera 7.1d.


 (with-input-from-string (s1 (format nil "abc~%def"))
   (with-input-from-string (s2 (format nil "ghi~%jkl"))
     (let ((s (lisp:make-concatenated-stream s1 s2)))
       (list (multiple-value-list (read-line s nil nil))
	     (multiple-value-list (read-line s nil nil))
	     (multiple-value-list (read-line s nil nil))
	     (multiple-value-list (read-line s nil nil))))))

 should return (("abc"    NIL #\Return NIL)
		("defghi" NIL #\Return NIL)
	        ("jkl"    T   NIL      NIL)
	        (NIL))

 but returns (("abc" NIL #\Return NIL)
	      ("def" T   NIL      NIL)
	      (NIL) (NIL))
 in Genera 7.1d.

||#



;;; Notes:
;;;
;;; CLtL (p224) says that ASH takes two integer arguments.
;;; Genera allows a float for arg1, for example.


(DEFUN CLTL:ASH (INTEGER COUNT)
  (DECLARE LT:(SIDE-EFFECTS SIMPLE REDUCIBLE))
  (CHECK-TYPE INTEGER INTEGER)
  (CHECK-TYPE COUNT INTEGER)
  (ASH INTEGER COUNT))



;;; Notes:
;;;
;;; In ANSI CL, synonym streams will have to be disjoint from things like symbols.
;;; Nothing in CLtL forbids that now, we'll go with the change early for the sake
;;; of CLOS.

(DEFVAR *USE-SYNONYM-STREAM-INSTANCES* NIL)	;Was T in Cloe -kmp 26-Sep-89

(DEFUN CLTL:MAKE-SYNONYM-STREAM (STREAM-SYMBOL)
  (LET ((CLI::*MAKE-OLD-STYLE-SYNONYM-STREAMS* (NOT *USE-SYNONYM-STREAM-INSTANCES*)))
    (MAKE-SYNONYM-STREAM STREAM-SYMBOL)))

(DEFUN ENABLE-SYNONYM-STREAM-INSTANCES (&OPTIONAL (FLAG T))
 ;This is what it would do if we had synonym instances...
 ;(SETQ *USE-SYNONYM-STREAM-INSTANCES* FLAG)
 ;(SETQ *TERMINAL-SYNONYM-STREAM* (CLTL:MAKE-SYNONYM-STREAM '*TERMINAL-IO*))
 ;FLAG
  (IGNORE FLAG)
  NIL)

(ENABLE-SYNONYM-STREAM-INSTANCES)

