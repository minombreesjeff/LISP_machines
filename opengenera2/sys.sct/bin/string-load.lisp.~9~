;;; -*- Base: 10; Mode: LISP; Lowercase: T; Package: BIN; Syntax: Common-lisp -*-

;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

#||
(defun intest (&key (stream-element-type '(unsigned-byte 8)))
  (with-open-file (stream "Y:>RWK>foo.test" :direction :input
			  :element-type stream-element-type)
    (with-character-loader (loader stream)
      (send loader :load-string))))

||#

(defflavor binary-loader
	((char-type-table (make-array 256 :adjustable t))    D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");Index to type.  nil = undefined.
0	 (object-loader #'default-character-load-object)
	 (supplied-object-loader nil)
	 (si:stream nil)
	 (buffer)				;A buffer from the stream
	 buffer-start				;Where we started in the buffer, for debugging
	 (buffer-pointer 0)			;Where we are in the buffer
	 (buffer-end 0))			;Where to stop in this buffer.
	(si:basic-loading-stream)
  (:settable-instance-variables si:stream)
  (:gettable-instance-variables si:stream))

;;; Initialize the state of the object from the macro.

(defmethod (initialize-loader binary-loader) (cont cont-p underlying-stream
						   &optional supplied-char-table)
  (cond (supplied-char-table
	 (setq char-type-table supplied-char-table))
	(t (when underlying-stream
	     (fill char-type-table nil))
	   (setf (aref char-type-table 0) 0)))	;Char index 0 is char type 0
  (setq buffer nil
	object-loader cont
	supplied-object-loader cont-p
	si:stream underlying-stream))

;;; Initialize the state of the object by hand
(defmethod (:prepare-loader binary-loader)
	   (&key (stream si:stream)
		 ((:object-loader obj-loader) object-loader object-loader-p))
  (initialize-loader self obj-loader object-loader-p stream))

;;; Print in a way that conveys where we're loading from.
(defmethod (:print-self binary-loader) (str ignore ignore)
  (si:printing-random-object (self str :typep)
    (if (not si:stream)
	(princ "<disconnected>" str)
      (let ((path (send-if-handles si:stream :pathname)))
	(if path
	    (format str "\"~A\"" path)
	  (princ si:stream str))))))

(defmethod (:read-header binary-loader) ()
  (let ((header (send self :8byte-in)))
    (if (not (zerop (string-header-long-flag header)))
	(setf (ldb (byte 8 8) header)
	      (send self :8byte-in))
      ;; Only one byte, dimension count is 1
      (setf (string-header-dimension-count header) 1))
    (when (not (zerop (string-header-very-long-flag header)))
      (setf (ldb (byte 8 16) header)
	    (send self :8byte-in)))
    header))

;;; Invoke the supplied object loader.  Put a :before daemon on here
;;; to skip padding before invoking a supplied object loader.

(defmethod (:invoke-object-loader binary-loader) ()
  (when object-loader
    (when supplied-object-loader
      (when buffer
	;; Can't hold buffers while we give control to someone else.
	(send si:stream :advance-input-buffer buffer-pointer)
	(setq buffer nil)))
    (prog1 (funcall object-loader self si:stream)
	   (unless buffer
	     ;; (2 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")with-input-buffering0 assumes buffers don't go away.
	     (send self :next-input-buffer)))))

;;; Loader for loading from 32-bit streams.

(defflavor partial-loading-mixin
	(string-opcode
	 block-length
	 type-index
	 bytes-left
	 prev-pointer)
	(binary-loader))

(defflavor unsigned-byte-32-loader
	((pending-bytes (make-array 3 :element-type 'cl:fixnum))
	 (pending-pointer 3))
	(binary-loader))

(defflavor unsigned-byte-32-partial-loader
	((prev-pending-bytes (make-array 3 :element-type 'cl:fixnum))
	 prev-pending-pointer)
	(unsigned-byte-32-loader partial-loading-mixin))

;;; Loader for loading from 16-bit streams.

(defflavor unsigned-byte-16-loader
	((pending-byte))				;An (unsigned-byte 8) not yet read.
	(binary-loader))

;;; Loader for loading from 8-bit streams.

(defflavor unsigned-byte-8-loader
	()
	(binary-loader))

1;;; Resources.  Put them here so 2with-character-loader1 knows about them.

0(defresource unsigned-byte-8-loader ()
  :constructor (make-instance 'unsigned-byte-8-loader))

(defresource unsigned-byte-16-loader ()
  :constructor (make-instance 'unsigned-byte-16-loader))

(defresource unsigned-byte-32-loader ()
  :constructor (make-instance 'unsigned-byte-32-loader))

(defresource unsigned-byte-32-partial-loader ()
  :constructor (make-instance 'unsigned-byte-32-partial-loader))

(defmethod (initialize-loader unsigned-byte-16-loader :after) (&rest ignore)
  (setq pending-byte nil))

(defmethod (initialize-loader unsigned-byte-32-loader :after) (&rest ignore)
  (let ((pending-bytes pending-bytes))
    (declare (sys:array-register pending-bytes))
    (loop for i from 0 repeat 3 do (setf (aref pending-bytes i) 0))
    (setq pending-pointer 3)))

(defmethod (:invoke-object-loader unsigned-byte-16-loader :before) ()
  (when supplied-object-loader
    (send self :check-empty-buffer)))

(defmethod (:invoke-object-loader unsigned-byte-32-loader :before) ()
  (when supplied-object-loader
    (send self :check-empty-buffer)))

;;; Call this wherever the dumper would call 2:empty-buffer0.

(defmethod (:check-empty-buffer unsigned-byte-16-loader) ()
  (when pending-byte
    (unless (zerop pending-byte)
      (cerror "Ignore the ~D byte."
	      "A non-zero byte, ~D, was found where a zero pad byte was expected."
	      pending-byte))
    (setq pending-byte nil)))

(defmethod (:check-empty-buffer unsigned-byte-32-loader) ()
  (when (< pending-pointer 3)
    (let ((pending-bytes pending-bytes))
      (declare (sys:array-register pending-bytes))
      (unless (ecase pending-pointer
		(0 (and (zerop (aref pending-bytes 0))
			(zerop (aref pending-bytes 1))
			(zerop (aref pending-bytes 2))))
		(1 (and (zerop (aref pending-bytes 1))
			(zerop (aref pending-bytes 2))))
		(2 (zerop (aref pending-bytes 2))))
	(cerror "Ignore the byte."
		"A non-zero byte was found where a zero pad byte was expected."))
      (setq pending-pointer 3))))

;; Stub.
(defmethod (:check-empty-buffer binary-loader) ()
  ())

;;; Workhorse for the standard interface (2with-character-loader0).
(defun with-character-loader-internal (body underlying-stream
				       object-loader object-loader-p)
  (declare (sys:downward-funarg body object-loader))
  (labels ((continue (loader)
	     1;; Do the work, once we figure what kind of loader to use.
0	     (unwind-protect
		 (progn
		   (initialize-loader loader object-loader object-loader-p underlying-stream)
		   (prog1 (funcall body loader)
			  1;Tell the underlying stream about our input, before returning to our
0			  1;caller.
0			  (send loader :finish-input)))
	       1;; Clear it out when we exit, especially the possibly-stack-consed
0	       1;; object-loader
0	       (initialize-loader loader #'default-character-load-object nil nil))))
    (let ((element-type (stream-element-type underlying-stream)))
      (cond ((subtypep element-type '(unsigned-byte 8))
	     (using-resource (loader unsigned-byte-8-loader)
	       (continue loader)))
	    ((subtypep element-type '(unsigned-byte 16))
	     (using-resource (loader unsigned-byte-16-loader)
	       (continue loader)))
	    ((subtypep element-type '(unsigned-byte 32))
	     (using-resource (loader unsigned-byte-32-loader)
	       (continue loader)))
	    (t (error "Unknown stream element type ~S for stream ~S."
		      element-type underlying-stream))))))

;;; This is the standard external entry to read a string.

(defmethod (:load-string binary-loader)
	   (&optional supplied-opcode (load-character-types-p t) supplied-string)
  (default-loading-case (self :locally supplied-opcode)
			(opcode nbytes dimension-count leader named adjustable
			 conformal fat-displaced leader-length-only)
    ((2dump-string-op-simple dump-string-op-run-length-encoding 
0      2dump-string-op-16-bit dump-string-general0)
     (multiple-value-bind (leader-length dimensions)
	 (send self :load-string-dimensions leader nbytes dimension-count)
       (let ((array (or supplied-string
			(make-array dimensions
				    :leader-length leader-length
				    :element-type (if (= opcode dump-string-op-simple)
						      'string-char
						      'character)
				    :named-structure-symbol (when named 'error)	;Fill in later
				    :adjustable adjustable))))
	 (when leader
	   (if leader-length-only
	       ;; Fill in the fill pointer, leave the others 2nil0.
	       (setf (fill-pointer array) (array-total-size array))
	     (send self :load-leader array leader-length)))
	 (unless (or (= opcode 2dump-string-op-simple0) (not load-character-types-p))
	   (send self :load-character-types))
	 (cond ((= opcode 2dump-string-op-simple0)
		(send self :load-simple-string-data array))
	       ((= opcode 2dump-string-op-run-length-encoding0)
		2;; style-nbytes0 argument is 1 for now; I'm not sure where it comes from.
		;; (It is a constant 1 on the dumper's side, as well.  What I'm not sure of
		;; is where it could come from if this opcode were to be extended.  Maybe
		;; this means it isn't reasonable to extend this; add another?)
		(send self :load-run-length-data array 1))
	       ((= opcode 2dump-string-op-16-bit0)
		(send self :load-16-bit-data array))
	       ((= opcode 2dump-string-general0)
		(send self :load-general-data array)))
	 ;; Let go of the stream so the caller can use it.
	 (send self :finish-input)
	 array)))
    (2dump-string-displaced
0      (multiple-value-bind (leader-length dimensions)
	  (send self :load-string-dimensions leader nbytes dimension-count)
	(let* ((offset (send self :load-fixnum t))
	       (target (send self :invoke-object-loader))
	       (array (or supplied-string
			  (make-array dimensions
				      :element-type (if fat-displaced 'character 'string-char)
				      :leader-length leader-length
				      :named-structure-symbol (when named 'error);Fill later
				      :adjustable adjustable
				      :displaced-conformally conformal
				      :displaced-to target
				      :displaced-index-offset offset))))
	 (if (and leader (not leader-length-only))
	     (send self :load-leader array leader-length)
	   ;; Fill in the fill pointer, leave the others 2nil0.
	   (setf (fill-pointer array) (array-total-size array)))
	  ;; Let go of the stream so the caller can use it.
	  (send self :finish-input)
	  array)))))

(defmethod (:string-dimensions binary-loader) (&optional supplied-opcode)
  (default-loading-case (self :locally supplied-opcode)
			(nbytes dimension-count leader)
    ((2dump-string-op-simple dump-string-op-run-length-encoding 
0			    2dump-string-op-16-bit dump-string-general0)
     (multiple-value-bind (ignore dimensions)
	 (send self :load-string-dimensions leader nbytes dimension-count)
       dimensions))
    (2dump-string-displaced
0      (multiple-value-bind (ignore dimensions)
	  (send self :load-string-dimensions leader nbytes dimension-count)
	dimensions))))

(defmethod (:save-state partial-loading-mixin)
	   (opcode remaining-block-length next-type-index)
  (setq string-opcode opcode
	block-length remaining-block-length
	type-index next-type-index
	prev-pointer (let ((buf-size (- buffer-end buffer-start))
			   (words-read (- buffer-pointer buffer-start)))
		       ;; Because this is a binary stream, we assume we can compute
		       ;; a position and go to it without rereading through the whole
		       ;; file.  This is mostly true, and is true in the only cases we
		       ;; really care about right now.  2:read-location0 conses.  Maybe we
		       ;; should have a 2:with-location0 that takes a continuation and conses
		       ;; on the data stack?  Or maybe 2:read-location0 could take an area
		       ;; argument or 2:data-stack0?
		       (+ (- (send si:stream :read-pointer) buf-size) words-read))))

(defmethod (:save-state unsigned-byte-32-partial-loader :before) (&rest ignore)
  (let ((pending-bytes pending-bytes)
	(prev-pending-bytes prev-pending-bytes))
    (declare (sys:array-register pending-bytes prev-pending-bytes))
    (setq prev-pending-pointer pending-pointer)
    (loop for i from 0 below 3 do (setf (aref prev-pending-bytes i) (aref pending-bytes i)))))

(defmethod (:restore-state partial-loading-mixin) ()
  (send si:stream :set-pointer prev-pointer)
  ;; since buffer could have changed between time we save'd state force
  ;; getting it again.
  (setq buffer nil)
  (send self :next-input-buffer))

(defmethod (:restore-state unsigned-byte-32-partial-loader :after) ()
  (let ((pending-bytes pending-bytes)
	(prev-pending-bytes prev-pending-bytes))
    (declare (sys:array-register pending-bytes prev-pending-bytes))
    (setq pending-pointer prev-pending-pointer)
    (loop for i from 0 below 3 do (setf (aref pending-bytes i) (aref prev-pending-bytes i)))))

(defmethod (:load-string-dimensions binary-loader) (leader-p nbytes dimension-count)
  (declare (values leader-length dimensions))
  (let ((leader-length (when leader-p (send self :read-nbyte-integer nbytes)))
	(dimensions (if (= dimension-count 1)
			(send self :read-nbyte-integer nbytes)
		      (loop repeat dimension-count
			    collect (send self :read-nbyte-integer nbytes)))))
    (values leader-length dimensions)))

(defmethod (:load-simple-string-data unsigned-byte-32-loader) (string)
  (with-input-buffering (string)
    (let ((next-char 0)
	  (array-length (zl:array-length string))
	  (pending-bytes pending-bytes))
      (declare (sys:array-register pending-bytes))
      (when (< pending-pointer 3)
	(macrolet ((store-one-pending-byte (pending-byte-index)
		     `(when (< next-char array-length)
			(store-char-simple next-char (aref pending-bytes ,pending-byte-index))
			(incf next-char)
			(incf pending-pointer))))
	  (case pending-pointer
	    (0 (store-one-pending-byte 0)
	       (store-one-pending-byte 1)
	       (store-one-pending-byte 2))
	    (1 (store-one-pending-byte 1)
	       (store-one-pending-byte 2))
	    (2 (store-one-pending-byte 2)))))
      (multiple-value-bind (repeat extra)
	  (floor (- array-length next-char) 4)
	(loop repeat repeat
	      for word = (read-byte) do
	  (store-char-simple next-char (sys:%logldb (byte 8 0) word))
	  (store-char-simple (+ next-char 1) (sys:%logldb (byte 8 8) word))
	  (store-char-simple (+ next-char 2) (sys:%logldb (byte 8 16) word))
	  (store-char-simple (+ next-char 3) (sys:%logldb (byte 8 24) word))
	  (incf next-char 4)
	      finally
		(when (plusp extra)
		  (let ((word (read-byte)))
		    (store-char-simple next-char (sys:%logldb (byte 8  0) word))
		    (setf (aref pending-bytes 0) (sys:%logldb (byte 8  8) word))
		    (setf (aref pending-bytes 1) (sys:%logldb (byte 8 16) word))
		    (setf (aref pending-bytes 2) (sys:%logldb (byte 8 24) word))
		    (loop for i from 1 below extra do
		      (store-char-simple (+ next-char i) (aref pending-bytes (1- i))))
		    (setq pending-pointer (1- extra))))))))
  string)

(defmethod (:load-simple-string-data unsigned-byte-16-loader) (string)
  (with-input-buffering (string)
    (loop with old-pending-byte = pending-byte
	  with array-length = (zl:array-length string)
	  with array-length-1 = (1- array-length)
	  initially (when pending-byte
		      (store-char-simple 0 pending-byte)
		      (setq pending-byte nil))
	  for i from (if old-pending-byte 1 0) below array-length by 2
	  for byte = (read-byte)
	  do (store-char-simple i (ldb (byte 8 0) byte))
	  until (= i array-length-1)	;Was this the last character?
	  do (store-char-simple (1+ i) (ldb (byte 8 8) byte))
	  finally (when (= i array-length-1)
		    ;; If we didn't use the last byte, remember it.
		    (setq pending-byte (ldb (byte 8 8) byte)))))
  string)

(defmethod (:load-simple-string-data unsigned-byte-8-loader) (string)
  (with-input-buffering (string)
    (loop for i below (zl:array-length string)
	  do (store-char-simple i (read-byte))))
  string)

(defmethod (:load-leader binary-loader) (string leader-length)
  (when leader-length
    (loop for i below leader-length
	  for obj = (send self :invoke-object-loader)
	  do (setf (array-leader string i) obj)))
  string)

;;;		   2Run-Length String Data Format
0;;;
;;; +-------+-------+------~  ~-----+-------+-------+-------+-------+
;;; | len-1 |  type |   bytes ...   | len-1 |  type |   bytes ...
;;; +-------+-------+------~  ~-----+-------+-------+-------+-------+

(defmethod (:load-run-length-data unsigned-byte-8-loader) (string style-nbytes)
  (with-input-buffering (string type-table buf)
    (loop with length = (zl:array-length string)
	  for i = 0 then (+ i block-length)
	  until ( i length)
	  for block-length = (read-byte)
	  for type-index = (send self :read-nbyte-integer style-nbytes)
	  for char-type = (aref type-table type-index)
	  do
      ;; Above call to :read-nbyte-integer may force a new input buffer...
      (setq buf buffer)
      ;; For each segment of the same type, do...
      (loop for p from i
	    repeat block-length
	      ;; For each character in the block, do...
	    do (store-char p char-type (read-byte)))))
  string)

(defmethod (:load-run-length-data unsigned-byte-16-loader) (string style-nbytes)
  (with-input-buffering (string type-table buf)
    (loop with length = (zl:array-length string)
	  for i = 0 then (+ i block-length)
	  until ( i length)
	  for block-length = (send self :8byte-in)
	  for type-index = (send self :read-nbyte-integer style-nbytes)
	  for char-type = (aref type-table type-index)
	  do
      ;; :8byte-in and :read-nbyte-integer could the buffer
      (setq buf buffer)
      (when (zerop block-length)
	;; Special case; zero-length is useless.
	;; I regret this, but it's not worth changing incompatibly.
	;; Actualy, I made the dumper stop generating this on 7 Jan 86,
	;; while KBIN is the only client of this code.
	(setq block-length 256.))
      (when (and pending-byte (> block-length 0))
	;; The first byte was in the same 16-bit word as the count, use it first,
	;; so we'll be 16-bit-byte-aligned in the loop below.
	(store-char i char-type pending-byte)
	(setq pending-byte nil)
	(incf i)
	(decf block-length))
      (loop for p from i by 2
	    repeat (floor block-length 2)
	    for byte = (read-byte)
	    do
	(store-char p char-type (ldb (byte 8 0) byte))
	(store-char (1+ p) char-type (ldb (byte 8 8) byte))
	    finally
	      (when (and (plusp block-length)	;Redundant, but made another bug worse once.
			 (oddp block-length))
		(let ((byte (read-byte)))
		  (store-char p char-type (ldb (byte 8 0) byte))
		  ;; We didn't use the last 8-bit byte, leave it for the next guy
		  (setq pending-byte (ldb (byte 8 8) byte)))))))
  string)

(defmethod (:load-run-length-data unsigned-byte-32-loader) (string style-nbytes)
  (with-input-buffering (string type-table buf)
    (let ((pending-bytes pending-bytes))
      (declare (sys:array-register pending-bytes))
      (loop with length = (zl:array-length string)
	    for i = 0 then (+ i block-length)
	    until ( i length)
	    for block-length = (send self :8byte-in)	;:8byte-in could change bufs
	    for type-index = (send self :read-nbyte-integer style-nbytes)
	    for char-type = (aref type-table type-index)
	    do
	;; :8byte-in and :read-nbyte-integer could change the buffer
	(setq buf buffer)
	(when (< pending-pointer 3) 
	  (macrolet ((store-one-pending-byte (pending-byte-index)
		       `(when (plusp block-length)
			  (store-char i char-type (aref pending-bytes ,pending-byte-index))
			  (incf i)
			  (incf pending-pointer)
			  (decf block-length))))
	    (ecase pending-pointer
	      (0 (store-one-pending-byte 0)
		 (store-one-pending-byte 1)
		 (store-one-pending-byte 2))
	      (1 (store-one-pending-byte 1)
		 (store-one-pending-byte 2))
	      (2 (store-one-pending-byte 2)))))
	(multiple-value-bind (count extra)
	    (floor block-length 4)
	  (loop for p from i by 4
		repeat count
		for word = (read-byte)
		do
	    (store-char p char-type (sys:%logldb (byte 8 0) word))
	    (store-char (1+ p) char-type (sys:%logldb (byte 8 8) word))
	    (store-char (+ p 2) char-type (sys:%logldb (byte 8 16) word))
	    (store-char (+ p 3) char-type (sys:%logldb (byte 8 24) word))
		finally
		  (when (plusp extra)
		    (let ((word (read-byte)))
		      ;; remaining chars in block
		      (store-char p char-type (sys:%logldb (byte 8 0) word))
		      (setf (aref pending-bytes 0) (sys:%logldb (byte 8  8) word))
		      (setf (aref pending-bytes 1) (sys:%logldb (byte 8 16) word))
		      (setf (aref pending-bytes 2) (sys:%logldb (byte 8 24) word))
		      (loop for i from 1 below extra do
			(store-char (+ p i) char-type (aref pending-bytes (1- i))))
		      (setq pending-pointer (1- extra))))))))))

(defmethod (:map-substrings partial-loading-mixin)
	   (continuation array-create-continuation delimiter &optional supplied-opcode)
  (default-loading-case (self :locally supplied-opcode)
			(nbytes dimension-count leader)
    (2dump-string-op-run-length-encoding
0     (multiple-value-bind (ignore dimensions)
	 (send self :load-string-dimensions leader nbytes dimension-count)
       (send self :map-run-length-substrings
	     (if (atom dimensions)
		 dimensions
		 (apply '* dimensions))
	     1
	     delimiter
	     array-create-continuation
	     continuation)))
    (2dump-string-op-16-bit
0      (multiple-value-bind (ignore dimensions)
	  (send self :load-string-dimensions leader nbytes dimension-count)
	(send self :map-16-bit-substrings
	      (if (atom dimensions)
		 dimensions
		 (apply '* dimensions))
	      delimiter
	      array-create-continuation
	      continuation)))))

(defmethod (:map-run-length-substrings unsigned-byte-32-partial-loader)
	   (string-length style-nbytes delimiter array-create-continuation continuation)
  (send self :save-state
	2dump-string-op-run-length-encoding
0	(send self :8byte-in)
	(send self :read-nbyte-integer style-nbytes))
  (setq bytes-left string-length)
  (loop with nbytes and delimiter-found-p
	do
    (multiple-value-setq (nbytes delimiter-found-p)
      (send self :scan-run-length-data 1 delimiter))
    ;; should only restore state and ask for another input buffer if
    ;; needed.
    (when (or delimiter-found-p (plusp bytes-left))
      (send self :restore-state))
    (funcall continuation (send self :load-run-length-data
				(funcall array-create-continuation nbytes)
				1))
	while delimiter-found-p
	do
    (send self :increment-run-length-data-string-pointer style-nbytes 1)
    (send self :save-state 2dump-string-op-run-length-encoding0 block-length type-index)))

;;; probably this and :load-run-length-data should be combined into a
;;; macro, but the differences seem too big to warrent it now.
(defmethod (:scan-run-length-data unsigned-byte-32-partial-loader) (nbytes delimiter)
  (declare (values length delimiter-found))
  (with-input-buffering (nil type-table buf)
    (let ((pending-bytes pending-bytes)
	  (delimiter-char-type (let ((char-type-table char-type-table))
				 (declare (sys:array-register char-type-table))
				 (loop with char-index = (si:char-type delimiter)
				       for i from 0 below (zl:array-length char-type-table)
				       when (= char-index (aref char-type-table i))
					 do (return i))))				 
	  (delimiter-subindex (si:char-subindex delimiter)))
      (declare (sys:array-register pending-bytes))
      (block end-of-string
	(let ((found-delimiter
		(block found-delimiter
		  (loop for i = 0 then (+ i current-block-length)
			until ( i bytes-left)
			for current-block-length = block-length then (send self :8byte-in)
			for current-type-index = type-index then
			    (send self :read-nbyte-integer nbytes)
			for char-type = (aref type-table current-type-index)
			for char-types-match = (= char-type delimiter-char-type)
			do
		    (setq buf buffer)
		    (when (< pending-pointer 3)
		      (macrolet ((check-one-pending-byte (pending-byte-index)
				   `(when (plusp current-block-length)
				      (decf current-block-length)
				      (when (and char-types-match
						 (= (aref pending-bytes ,pending-byte-index)
						    delimiter-subindex))
					(return-from found-delimiter i))
				      (incf i)
				      (incf pending-pointer))))
			(case pending-pointer
			  (0 (check-one-pending-byte 0)
			     (check-one-pending-byte 1)
			     (check-one-pending-byte 2))
			  (1 (check-one-pending-byte 1)
			     (check-one-pending-byte 2))
			  (2 (check-one-pending-byte 2)))))
		    (multiple-value-bind (count extra)
			(floor current-block-length 4)
		      (loop for p from i by 4
			    repeat count
			    for word = (read-byte)
			    do
			(when char-types-match
			  (when (= (sys:%logldb (byte 8  0) word) delimiter-subindex)
			    (return-from found-delimiter p))
			  (when (= (sys:%logldb (byte 8  8) word) delimiter-subindex)
			    (return-from found-delimiter (+ p 1)))
			  (when (= (sys:%logldb (byte 8 16) word) delimiter-subindex)
			    (return-from found-delimiter (+ p 2)))
			  (when (= (sys:%logldb (byte 8 24) word) delimiter-subindex)
			    (return-from found-delimiter (+ p 3))))
			    finally
			      (when (plusp extra)
				(let ((word (read-byte)))
				  (setf (aref pending-bytes 0) (sys:%logldb (byte 8  8) word))
				  (setf (aref pending-bytes 1) (sys:%logldb (byte 8 16) word))
				  (setf (aref pending-bytes 2) (sys:%logldb (byte 8 24) word))
				  (when (and char-types-match
					     (= (sys:%logldb (byte 8 0) word)
						delimiter-subindex))
				    (return-from found-delimiter p))
				  (loop for i from 1 below extra do
				    (when (and char-types-match
					       (= (aref pending-bytes (1- i))
						  delimiter-subindex))
				      (return-from found-delimiter (+ p i))))
				  (setq pending-pointer (1- extra))))))
			finally
			  (return-from end-of-string (values i nil))))))
	  (values found-delimiter t))))))

(defmethod (:load-run-length-data unsigned-byte-32-partial-loader) (string nbytes)
  (with-input-buffering (string type-table buf)
    (let ((pending-bytes pending-bytes)
	  (length (zl:array-length string)))
      (declare (sys:array-register pending-bytes))
      (decf bytes-left length)
      (loop with bytes-to-use-this-iteration
	    with i = 0
	    until ( i length)
	    for current-block-length = block-length then (send self :8byte-in)
	    for current-type-index = type-index then (send self :read-nbyte-integer nbytes)
	    for char-type = (aref type-table current-type-index)
	    for bytes-remaining-in-string = (- length i)
	    when (> current-block-length bytes-remaining-in-string)
	      do (setq block-length (- current-block-length bytes-remaining-in-string)
		       bytes-to-use-this-iteration bytes-remaining-in-string)
	    else do (setq bytes-to-use-this-iteration current-block-length
			  block-length 0)
	    do
	(setq buf buffer)			;:8byte-in could change buffer
	(when (< pending-pointer 3)
	  (macrolet ((store-one-pending-byte (pending-byte-index)
		       `(when (plusp bytes-to-use-this-iteration)
			  (decf bytes-to-use-this-iteration)
			  (store-char i char-type (aref pending-bytes ,pending-byte-index))
			  (incf i)
			  (incf pending-pointer))))
	    (case pending-pointer
	      (0 (store-one-pending-byte 0)
		 (store-one-pending-byte 1)
		 (store-one-pending-byte 2))
	      (1 (store-one-pending-byte 1)
		 (store-one-pending-byte 2))
	      (2 (store-one-pending-byte 2)))))
	(multiple-value-bind (count extra)
	    (floor bytes-to-use-this-iteration 4)
	  (loop for p from i by 4
		repeat count
		for word = (read-byte)
		do
	    (store-char (+ p)   char-type (sys:%logldb (byte 8  0) word))
	    (store-char (+ p 1) char-type (sys:%logldb (byte 8  8) word))
	    (store-char (+ p 2) char-type (sys:%logldb (byte 8 16) word))
	    (store-char (+ p 3) char-type (sys:%logldb (byte 8 24) word))
		finally
		  (incf i bytes-to-use-this-iteration)
		  (when (plusp extra)
		    (let ((word (read-byte)))
		      (store-char p char-type (sys:%logldb (byte 8 0) word))
		      (setf (aref pending-bytes 0) (sys:%logldb (byte 8  8) word))
		      (setf (aref pending-bytes 1) (sys:%logldb (byte 8 16) word))
		      (setf (aref pending-bytes 2) (sys:%logldb (byte 8 24) word))
		      (loop for j from 1 below extra do
			(store-char (+ p j) char-type (aref pending-bytes (1- j))))
		      (setq pending-pointer (1- extra)))))))))
  string)

(defmethod (:increment-run-length-data-string-pointer unsigned-byte-32-partial-loader)
	   (style-nbytes &optional (nbytes 1))
  (loop repeat nbytes
	do
    (decf bytes-left)
    (cond ((zerop block-length)
	   (setq block-length (1- (send self :8byte-in))
		 type-index (send self :read-nbyte-integer style-nbytes))
	   (send self :8byte-in))
	  (t
	   (decf block-length)
	   (send self :8byte-in)))))

;;;		 216-bit String Data Format
0;;;
;;; +---+-~  ~-+---+------+--------+------+--------+----
;;; | N | defs |pad| char | index  | char | index  | ...
;;; +---+-~  ~-+---+------+--------+------+--------+----

(defmethod (:load-16-bit-data unsigned-byte-8-loader) (string)
  (with-input-buffering (string type-table)
    (loop for i below (zl:array-length string)
	  for subindex = (read-byte)
	  for type = (aref type-table (read-byte))
	  do (store-char i type subindex)))
  string)

(defmethod (:load-16-bit-data unsigned-byte-16-loader) (string)
  (send self :check-empty-buffer)
  (with-input-buffering (string type-table)
    (loop for i below (zl:array-length string)
	  for byte = (read-byte)
	  for type = (aref type-table (ldb (byte 8 8) byte))
	  do (store-char i type (ldb (byte 8 0) byte))))
  (send self :check-empty-buffer)
  string)

(defmethod (:load-16-bit-data unsigned-byte-32-loader) (string)
  (send self :check-empty-buffer)
  (with-input-buffering (string type-table buf)
    (ignore buf)
    (loop for i below (zl:array-length string)
	  for byte = (prog1 (send self :16byte-in)
			    (setq buf buffer))
	  for type = (aref type-table (ldb (byte 8 8) byte))
	  do (store-char i type (ldb (byte 8 0) byte))))
  (send self :check-empty-buffer)
  string)

(defmethod (:load-16-bit-data unsigned-byte-32-partial-loader) (string)
  (with-input-buffering (string type-table buf)
    (ignore buf)
    (loop for i from 0 below (zl:array-length string)
	  for byte = (prog1 (send self :16byte-in)
			    (setq buf buffer))
	  for type = (aref type-table (ldb (byte 8 8) byte))
	  do (store-char i type (ldb (byte 8 0) byte))
	  finally (decf bytes-left i)))
  string)

(defmethod (:scan-16-bit-data unsigned-byte-32-partial-loader) (delimiter)
  (declare (values length delimiter-found))
  (let ((delimiter-char-type (let ((char-type-table char-type-table))
			       (declare (sys:array-register char-type-table))
			       (loop with char-index = (si:char-type delimiter)
				     for i from 0 below (zl:array-length char-type-table)
				     when (= char-index (aref char-type-table i))
				       do (return i))))
	(delimiter-subindex (si:char-subindex delimiter)))
    (with-input-buffering (nil nil buf)
      (ignore buf)
      (loop for i from 0 below bytes-left
	    for byte = (prog1 (send self :16byte-in)
			      (setq buf buffer))
	    when (and (= delimiter-subindex (ldb (byte 8 0) byte))
		      (= delimiter-char-type (ldb (byte 8 8) byte)))
	      do (return (values i t))
	    finally (return (values i nil))))))

(defmethod (:increment-16-bit-data-string-pointer unsigned-byte-32-partial-loader)
	   (&optional (nbytes 1))
  (decf bytes-left nbytes)
  (loop repeat nbytes
	do (send self :16byte-in)))

(defmethod (:map-16-bit-substrings unsigned-byte-32-partial-loader)
	   (string-length delimiter array-create-continuation continuation)
  (send self :check-empty-buffer)
  (send self :save-state 2dump-string-op-16-bit0 nil nil)
  (setq bytes-left string-length)
  (loop with nbytes and delimiter-found-p
	do
    (multiple-value-setq (nbytes delimiter-found-p)
      (send self :scan-16-bit-data delimiter))
    (when (or delimiter-found-p (plusp bytes-left))
      (send self :restore-state))
    (funcall continuation (send self :load-16-bit-data
				(funcall array-create-continuation nbytes)))
	while delimiter-found-p
	do
    (send self :increment-16-bit-data-string-pointer 1)
    (send self :save-state 2dump-string-op-16-bit0 nil nil)))

;;; Read a variable-length integer

(defmethod (:read-nbyte-integer unsigned-byte-8-loader) (nbytes)
  (with-input-buffering ()
    (loop for i from 0 by 8
	  with integer = 0
	  repeat nbytes
	  do (setf (ldb (byte 8 i) integer)
		   (read-byte))
	  finally (return integer))))

(defmethod (:read-nbyte-integer unsigned-byte-16-loader) (nbytes)
  (with-input-buffering ()
    (loop for i from 0 by 8
	  with integer = 0
	  repeat nbytes
	  do
      (if pending-byte
	  (setf (ldb (byte 8 i) integer)
		(prog1 pending-byte (setq pending-byte nil)))
	(let ((byte (read-byte)))
	  (setf (ldb (byte 8 i) integer) (ldb (byte 8 0) byte)
		pending-byte (ldb (byte 8 8) byte))))
      finally (return integer))))

(defmethod (:read-nbyte-integer unsigned-byte-32-loader) (nbytes)
  (with-input-buffering (nil nil buf)
    (let ((pending-bytes pending-bytes))
      (declare (sys:array-register pending-bytes))
      (loop for i from 0 by 8
	    with integer = 0
	    repeat nbytes
	    do
	(if (< pending-pointer 3)
	    (setf (sys:%logldb (byte 8 i) integer)
		  (prog1 (aref pending-bytes pending-pointer)
			 (incf pending-pointer)))
	    (let ((word (read-byte)))
	      (setq pending-pointer 0)
	      (setf (aref pending-bytes 0) (sys:%logldb (byte 8  8) word))
	      (setf (aref pending-bytes 1) (sys:%logldb (byte 8 16) word))
	      (setf (aref pending-bytes 2) (sys:%logldb (byte 8 24) word))
	      (setf (sys:%logldb (byte 8 i) integer)
		    (sys:%logldb (byte 8 0) word))))
	    finally (return integer)))))

;;; Read an 8bit byte.

(defmethod (:8byte-in unsigned-byte-32-loader) ()
  (with-input-buffering (nil nil buf)
    (let ((pending-bytes pending-bytes))
      (declare (sys:array-register pending-bytes))
      (if (< pending-pointer 3)
	  (prog1 (aref pending-bytes pending-pointer) (incf pending-pointer))
	  (let ((word (read-byte)))
	    (setq pending-pointer 0)
	    (setf (aref pending-bytes 0) (sys:%logldb (byte 8  8) word))
	    (setf (aref pending-bytes 1) (sys:%logldb (byte 8 16) word))
	    (setf (aref pending-bytes 2) (sys:%logldb (byte 8 24) word))
	    (sys:%logldb (byte 8 0) word))))))

(defmethod (:8byte-in unsigned-byte-16-loader) ()
  (with-input-buffering ()
    (if pending-byte
	(prog1 pending-byte (setq pending-byte nil))
      (let ((byte (read-byte)))
	(setq pending-byte (ldb (byte 8 8) byte))
	(ldb (byte 8 0) byte)))))

(defmethod (:8byte-in unsigned-byte-8-loader) ()
  (with-input-buffering ()
    (read-byte)))

(defmethod (:8string-in unsigned-byte-32-loader) (string &optional (start 0) end)
  (unless end
    (setq end (length string)))
  (with-input-buffering (string nil buf)
    (let ((pending-bytes pending-bytes))
      (declare (sys:array-register pending-bytes))
      (unless ( start end)
	(when (< pending-pointer 3)
	  (loop for i from start
		repeat (- 3 pending-pointer)
		until (> i end)
		do
	    (store-char-simple i (aref pending-bytes pending-pointer))
	    (incf pending-pointer)
		finally
		  (incf start i)))
	(multiple-value-bind (repeat extra)
	    (floor (- end start) 4)
	  (loop for p from start by 4
		repeat repeat
		for word = (read-byte)
		do
	    (store-char-simple p (sys:%logldb (byte 8 0) word))
	    (store-char-simple (1+ p) (sys:%logldb (byte 8 8) word))
	    (store-char-simple (+ p 2) (sys:%logldb (byte 8 16) word))
	    (store-char-simple (+ p 3) (sys:%logldb (byte 8 24) word))
		finally
		  ;; load any extra bytes (0 through 3)
		  (let ((word (read-byte)))
		    (loop for i from 0 below extra do
		      (store-char-simple (+ i p) (sys:%logldb (byte 8 (* i 8)) word)))
		    (loop for i from extra below 4 do
		      (setf (aref pending-bytes i) (sys:%logldb (byte 8 (* i 8)) word)))
		    (setq pending-pointer (1- extra)))))))))

;;; Input the subindex bytes of a string from a 16-bit stream.
;;; The bytes are 1not0 word aligned.

(defmethod (:8string-in unsigned-byte-16-loader) (string &optional (start 0) end)
  (unless end
    (setq end (length string)))
  (with-input-buffering (string)
    (unless ( start end)
      (when pending-byte
	(store-char-simple start pending-byte)
	(incf start)
	(setq pending-byte nil))
      (multiple-value-bind (repeat extra)
	  (floor (- end start) 2)
	(loop for i from start by 2
	      repeat repeat
	      for byte = (read-byte)
	      do
	  (store-char-simple i (ldb (byte 8 0) byte))
	  (store-char-simple (1+ i) (ldb (byte 8 8) byte))
	      finally
		;; Load any extra bytes (either 0 or 1)
		(unless (zerop extra)
		  (let ((byte (read-byte)))
		    (store-char-simple i (ldb (byte 8 0) byte))
		    (setq pending-byte (ldb (byte 8 8) byte))))))))
  string)

;;; Input the subindex bytes of a string from an 8-bit stream.

(defmethod (:8string-in unsigned-byte-8-loader) (string &optional (start 0) end)
  (unless end
    (setq end (length string)))
  (with-input-buffering (string)
    (loop for in from start below end
	  do
      ;; Read the string and write the buffer, converting, courtesy of 2with-output-buffering0.
      (store-char-simple in (read-byte))))
  string)

;;; Input a 16-bit byte.

(defmethod (:16byte-in unsigned-byte-8-loader) ()
  (with-input-buffering ()
    (let ((byte0 (read-byte))
	  (byte1 (read-byte)))
      (dpb byte1 (byte 8 8) byte0))))

(defmethod (:16byte-in unsigned-byte-16-loader) ()
  (with-input-buffering ()
    (when pending-byte
      (send self :check-empty-buffer))
    (read-byte)))

(defmethod (:16byte-in unsigned-byte-32-loader) ()
  (with-input-buffering (nil nil buf)
    (let ((pending-bytes pending-bytes))
      (declare (sys:array-register pending-bytes))
      (case pending-pointer
	((0 2)					;odd number of bytes left in buffer
	 (unless (zerop (aref pending-bytes (incf pending-pointer)))
	   (cerror "Non-zero byte found"
		   "Ignore the non-zero byte"))))
      ;; pending-pointer is now either 1 or 3
      (ecase pending-pointer
	(1					;16 bit byte is in (aref p-b 1 and 2)
	  (prog1
	    (dpb (aref pending-bytes (1+ pending-pointer))
		 (byte 8 8)
		 (sys:%logldb (byte 8 0) (aref pending-bytes pending-pointer)))
	    (incf pending-pointer 2)))
	(3					;got to read it in
	  (let ((word (read-byte)))
	    (setf (aref pending-bytes 1) (sys:%logldb (byte 8 16) word))
	    (setf (aref pending-bytes 2) (sys:%logldb (byte 8 24) word))
	    (setq pending-pointer 1)
	    (sys:%logldb (byte 16 0) word)))))))

;;; 2:next-input-buffer0 is a subroutine of the 2(ensure-buffer-not-empty)
0;;; local macro of 2with-input-buffering0.

(defmethod (:next-input-buffer unsigned-byte-32-loader :before) ()
  (unless buffer
    (setq pending-pointer 3)))			;force input from buffer when we get it

(defmethod (:next-input-buffer binary-loader) ()
  (when (or (not buffer) ( buffer-pointer buffer-end))
    ;; Need a new input buffer.  Say the old one was used,
    ;; and grab another
    (when buffer
      (send si:stream :advance-input-buffer buffer-pointer))
    (multiple-value-setq (buffer buffer-pointer buffer-end)
			 (send si:stream :read-input-buffer))
    (setq buffer-start buffer-pointer)	;Remember where we started for debugging.
    (unless buffer
      (error 'sys:end-of-file :format-string "End of file"))))

;;; 2:finish-input0 is to tell the underlying stream what
;;; we've done so the caller can do output directly to
;;; the underlying stream.

(defmethod (:finish-input binary-loader) (&optional (check-empty-p t))
  check-empty-p
  (when buffer
    (send si:stream :advance-input-buffer buffer-pointer)
    (setq buffer nil)))

(defmethod (:finish-input unsigned-byte-16-loader :before) (&rest ignore)
  (send self :check-empty-buffer))

(defmethod (:finish-input unsigned-byte-32-loader :before) (&optional (check-empty-p t))
  ;; may be finished with input for now, but don't care about checking
  ;; for protocol.
  (when check-empty-p
    (send self :check-empty-buffer)))

;;; Workhorse for 2default-loading-case0 macro.
(defmethod (:with-default-loading binary-loader) (expect-opcode
						   supplied-opcode supplied-nbytes
						   expected-opcode body)
  (if (and (neq expect-opcode :locally) supplied-object-loader)
      (send self :invoke-object-loader)
    (if (and (not supplied-opcode) expect-opcode)
	(let* ((header (send self :read-header))
	       (opcode (string-header-opcode header))
	       (nbytes (string-header-nbytes header))
	       (dimension-count (string-header-dimension-count header))
	       (leader-flag (not (zerop (string-header-leader-flag header))))
	       (leader-length-only-flag
		 (not (zerop (string-header-leader-length-only header))))
	       (named-flag (not (zerop (string-header-named-flag header))))
	       (adjustable-flag (not (zerop (string-header-adjustable-flag header))))
	       (conformal-flag (not (zerop (string-header-conformal-flag header))))
	       (fat-displaced-flag (not (zerop (string-header-fat-displaced-flag header)))))
	  (funcall body opcode
		   :opcode opcode :nbytes nbytes :dimension-count dimension-count
		   :leader leader-flag :named named-flag :adjustable adjustable-flag
		   :conformal conformal-flag :fat-displaced fat-displaced-flag
		   :leader-length-only leader-length-only-flag))
      ;; No opcode expected
      (funcall body (or supplied-opcode expected-opcode)
	       :opcode (or supplied-opcode expected-opcode)
	       :nbytes (or supplied-nbytes 1) :dimension-count 1))))	;Defaults

;;;		    2Character Type Definitions
0;;; +-----------+-----------+-----------+-------+----------------
;;; |                                   |   0   | format-specific
;;; | Type Spec | Type Spec | Type Spec |       |    data ...
;;; +-----------+-----------+-----------+-------+----------------
;;;
;;; These are terminated by a zero byte (a "null definition").
;;;
;;; It is done this way rather than by having a count to avoid
;;; the need for doing two passes over the string's transition,
;;; doing two hash-table lookups on the character type.
;;;
;;; Also, it has the advantage of not impossing any limit on the
;;; number of type specs.  This makes it applicable to any future
;;; opcodes which allow more than 256 types.
;;;
;;;		       2Character Type Definition
0;;; +----+----+---~ ~----+----+---+--------+---~  ~--+--~  ~-+-~  ~-+
;;; |  N |Size|  index   |bits|unu| offset | charset | style | font |
;;; |  6 |    |          |    |sed|        |         |       | name |
;;; +----+----+---~ ~----+----+---+--------+---~  ~--+--~  ~-+-~  ~-+
;;;  0-5  6-7             0-3 4-7
;;;  byte 0     byte 1    byte s+2  byte s+1

(defmethod (:load-character-types binary-loader) ()
  (loop for typedef-header = (send self :8byte-in)
	until (zerop typedef-header)
	for n = (char-type-n-fields typedef-header)
	for size = (char-type-index-size typedef-header)
	do
    (unless ( n *known-char-type-field-count*)
      (error "Too few fields in character type definition."))
    (when (> n *known-char-type-field-count*)
      (error "Unknown fields in character type definition.~@
		~D were supplied, but we only know about ~D."
	     n *known-char-type-field-count*))
    (let ((index (send self :read-nbyte-integer size))
	  (bits (send self :8byte-in))
	  (offset (send self :8byte-in))
	  (charset-name (send self :invoke-object-loader))
	  (style (send self :load-style))
	  (font-name (send self :simple-string-object-in)))
      (ignore font-name)
      ;; Now we've extracted everything from the file.  Compute the character type, and
      ;; store that into the table.
      (let* ((charset (si:lookup-character-set charset-name))
	     (charset-index (send charset :decode-offset offset))
	     (style-index (si:style-index style t))
	     (char-type (ldb sys:%%char-all-but-subindex
			     (dpb bits sys:%%char-bits
				  (dpb charset-index sys:%%char-char-set
				       (dpb style-index sys:%%char-style 0))))))
	(when (> index (zl:array-length char-type-table))
	  ;; More types than we expected, grow the table a bunch bigger.
	  (adjust-array char-type-table (+ index 256)))
	(setf (aref char-type-table index) char-type)))))


(defmethod (:simple-string-object-in binary-loader) (&optional (nbytes 1))
  (let* ((length (send self :read-nbyte-integer nbytes))
	 (string (make-array length :element-type 'string-char)))
    (send self :8string-in string)
    string))


;;;	    2Default Symbol Format
0;;; +----------------+-------------------+
;;; | package string | print-name string |
;;; +----------------+-------------------+

(defmethod (:load-symbol binary-loader) (&optional (expect-opcode t) supplied-opcode)
  (default-loading-case (self expect-opcode supplied-opcode)
			(nbytes)
    (object-op-nil nil)
    (object-op-keyword
      (let ((symbol-name (send self :simple-string-object-in nbytes)))
	(intern symbol-name "")))
    (object-op-symbol
      (let ((package-name (send self :simple-string-object-in nbytes))
	    (symbol-name (send self :simple-string-object-in nbytes)))
	(intern symbol-name package-name)))))


;;; 		2Default Style Format
0;;; +-+-+---+---------------+-------------+------------+
;;; |D|T| N | family symbol | face symbol | size value |
;;; +-+-+---+---------------+-------------+------------+

(defmethod (:load-style binary-loader) (&optional expect-opcode)
  (default-loading-case (self expect-opcode)
			()
    (object-op-style
      (let ((header-byte (send self :8byte-in)))
	(let ((definition (not (zerop (object-style-definition header-byte))))
	      (fields (object-style-fields header-byte)))
	  (when definition
	    (error "Style definition is not defined yet."))
	  (si:parse-character-style
	    (loop repeat fields
		  collect (send self :invoke-object-loader))))))))

(defmethod (:load-fixnum binary-loader) (&optional supplied-opcode supplied-nbytes)
  (default-loading-case (self t supplied-opcode supplied-nbytes)
			(nbytes)
    (object-op-fixnum (send self :read-nbyte-integer nbytes))
    (object-op-negative-fixnum (- (send self :read-nbyte-integer nbytes)))))

(defmethod (:load-ratio binary-loader) (&optional supplied-opcode)
  (default-loading-case (self t supplied-opcode)
			()
    (object-op-ratio
      (ignore dont-ignore)			;Gets around a macro quirk that causes
						;warnings, that gets around a compiler bug.
						;I don't know if the original compiler bug
						;is still there, but the macro still uses
						;DONT-IGNORE.
      (let ((numerator (send self :invoke-object-loader))
	    (denominator (send self :invoke-object-loader)))
	(/ numerator denominator)))))

;;; Load any object that is in our un-augmented domain.

(defun default-character-load-object (loader stream)
  stream
  (multiple-value-prog1
    (default-loading-case (loader t)
			  (nbytes opcode)
      ((object-op-fixnum object-op-negative-fixnum)
       (send loader :load-fixnum opcode nbytes))
      (object-op-nil nil)
      ((object-op-symbol object-op-keyword)
       (send loader :load-symbol nil opcode))
      (object-op-style
	(send loader :load-style nil))
      ((dump-string-op-simple dump-string-op-run-length-encoding 
	dump-string-op-16-bit dump-string-general dump-string-displaced)
       (send loader :load-string opcode)))
    ;; Gotta do this, since we may be called by the user's version
    (send loader :check-empty-buffer)))

;;; Make them real!
(compile-flavor-methods unsigned-byte-8-loader
			unsigned-byte-16-loader
			unsigned-byte-32-loader
			unsigned-byte-32-partial-loader)
