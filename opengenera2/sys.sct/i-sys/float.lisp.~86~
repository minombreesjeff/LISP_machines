;;; -*- Mode: LISP; Syntax: Common-Lisp; Base: 10; Package: COMMON-LISP-INTERNALS -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
;;;
;;;
;;; Floating point support for Ivory

(DEFSUBST %FPA-R0-HIGH ()
  (%COPROCESSOR-READ 2))
(DEFSETF %FPA-R0-HIGH () (NEW-VALUE)
  `(%COPROCESSOR-WRITE ,NEW-VALUE 0))

(DEFSUBST %FPA-R0-LOW ()
  (%COPROCESSOR-READ 3))
(DEFSETF %FPA-R0-LOW () (NEW-VALUE)
  `(%COPROCESSOR-WRITE ,NEW-VALUE 2))

(DEFMACRO COPROCESSOR-WAIT (N)
  `(PROGN ,@(LOOP REPEAT N COLLECTING `(COMPILER:NO-OP))))

;;; Each item in this list is an operation, argument types, result type, latency, and
;;; opcode.
(EVAL-WHEN (COMPILE LOAD EVAL)
(DEFPARAMETER *FPA-OPERATIONS*
	      '((SINGLE-ADD (SINGLE-FLOAT SINGLE-FLOAT) SINGLE-FLOAT ADD 3. #o000)
		(SINGLE-SUB (SINGLE-FLOAT SINGLE-FLOAT) SINGLE-FLOAT ADD 3. #o004)
		(SINGLE-MULTIPLY (SINGLE-FLOAT SINGLE-FLOAT) SINGLE-FLOAT MULTIPLY 3. #o010)
		(SINGLE-QUOTIENT (SINGLE-FLOAT SINGLE-FLOAT) SINGLE-FLOAT DIVIDE 18. #o014)
		(SINGLE-RATIONAL-QUOTIENT (SINGLE-FLOAT SINGLE-FLOAT) SINGLE-FLOAT DIVIDE 18. #o044)
		(SINGLE-UNARY-MINUS (SINGLE-FLOAT) SINGLE-FLOAT ADD 3. #o060)
		(SINGLE-EQUAL-NUMBER (SINGLE-FLOAT SINGLE-FLOAT) BOOLEAN MULTIPLY 3. #o100)
		(SINGLE-LESSP (SINGLE-FLOAT SINGLE-FLOAT) BOOLEAN 3. MULTIPLY #o104)
		(SINGLE-GREATERP (SINGLE-FLOAT SINGLE-FLOAT) BOOLEAN MULTIPLY 3. #o110)
		(SINGLE-EQUAL-NUMBER-NO-POP (SINGLE-FLOAT SINGLE-FLOAT) BOOLEAN MULTIPLY 3. #o120)
		(SINGLE-LESSP-NO-POP (SINGLE-FLOAT SINGLE-FLOAT) BOOLEAN MULTIPLY 3. #o124)
		(SINGLE-GREATERP-NO-POP (SINGLE-FLOAT SINGLE-FLOAT) BOOLEAN MULTIPLY 3. #o130)
		(SINGLE-ZEROP (SINGLE-FLOAT) BOOLEAN MULTIPLY 3. #o160)
		(SINGLE-MINUSP (SINGLE-FLOAT) BOOLEAN MULTIPLY 3. #o164)
		(SINGLE-PLUSP (SINGLE-FLOAT) BOOLEAN MULTIPLY 3. #o170)
		(DOUBLE-ADD (DOUBLE-FLOAT DOUBLE-FLOAT) DOUBLE-FLOAT ADD 4. #o200)
		(DOUBLE-SUB (DOUBLE-FLOAT DOUBLE-FLOAT) DOUBLE-FLOAT ADD 4. #o204)
		(DOUBLE-MULTIPLY (DOUBLE-FLOAT DOUBLE-FLOAT) DOUBLE-FLOAT MULTIPLY 3. #o210)
		(DOUBLE-QUOTIENT (DOUBLE-FLOAT DOUBLE-FLOAT) DOUBLE-FLOAT DIVIDE 32. #o214)
		(DOUBLE-RATIONAL-QUOTIENT (DOUBLE-FLOAT DOUBLE-FLOAT) DOUBLE-FLOAT DIVIDE 32. #o244)
		(DOUBLE-UNARY-MINUS (DOUBLE-FLOAT) DOUBLE-FLOAT MULTIPLY 3. #o260)
		(DOUBLE-EQUAL-NUMBER (DOUBLE-FLOAT DOUBLE-FLOAT) BOOLEAN MULTIPLY 3. #o300)
		(DOUBLE-LESSP (DOUBLE-FLOAT DOUBLE-FLOAT) BOOLEAN MULTIPLY 3. #o304)
		(DOUBLE-GREATERP (DOUBLE-FLOAT DOUBLE-FLOAT) BOOLEAN MULTIPLY 3. #o310)
		(DOUBLE-EQUAL-NUMBER-NO-POP (DOUBLE-FLOAT DOUBLE-FLOAT) BOOLEAN MULTIPLY 3. #o320)
		(DOUBLE-LESSP-NO-POP (DOUBLE-FLOAT DOUBLE-FLOAT) BOOLEAN MULTIPLY 3. #o324)
		(DOUBLE-GREATERP-NO-POP (DOUBLE-FLOAT DOUBLE-FLOAT) BOOLEAN MULTIPLY 3. #o330)
		(DOUBLE-ZEROP (DOUBLE-FLOAT) BOOLEAN MULTIPLY 3. #o360)
		(DOUBLE-MINUSP (DOUBLE-FLOAT) BOOLEAN MULTIPLY 3. #o364)
		(DOUBLE-PLUSP (DOUBLE-FLOAT) BOOLEAN MULTIPLY 3. #o370)
		(FIXNUM-MULTIPLY (FIXNUM FIXNUM) FIXNUM MULTIPLY 3. #o374)
		(CONVERT-DOUBLE-TO-FIXNUM-ROUNDING (DOUBLE-FLOAT) FIXNUM ADD 3. #o400)
		(CONVERT-DOUBLE-TO-FIXNUM-TRUNCATING (DOUBLE-FLOAT) FIXNUM ADD 3. #o404)
		(CONVERT-SINGLE-TO-FIXNUM-ROUNDING (SINGLE-FLOAT) FIXNUM ADD 3. #o410)
		(CONVERT-SINGLE-TO-FIXNUM-TRUNCATING (SINGLE-FLOAT) FIXNUM ADD 3. #o414)
		(CONVERT-FIXNUM-TO-DOUBLE-ROUNDING (FIXNUM) DOUBLE-FLOAT ADD 3. #o430)
		(CONVERT-FIXNUM-TO-SINGLE-TRUNCATING (FIXNUM) SINGLE-FLOAT ADD 3. #o434)
		(CONVERT-DOUBLE-TO-SINGLE-ROUNDING (DOUBLE-FLOAT) SINGLE-FLOAT ADD 3. #o440)
		(CONVERT-SINGLE-TO-DOUBLE-ROUNDING (SINGLE-FLOAT) DOUBLE-FLOAT ADD 3. #o450)
		(DOUBLE-SQRT (DOUBLE-FLOAT) DOUBLE-FLOAT DIVIDE 59. #o500)
		(SINGLE-SQRT (SINGLE-FLOAT) SINGLE-FLOAT DIVIDE 29. #o510)
		(DOUBLE-ABS (DOUBLE-FLOAT) DOUBLE-FLOAT MULTIPLY 3. #o544)
		(SINGLE-ABS (SINGLE-FLOAT) SINGLE-FLOAT MULTIPLY 3. #o554)))
)

;;; This is the list for pre-XL1200
;;; Each item in this list is an operation, argument types, result type, latency, and
;;; opcode.
;(DEFPARAMETER *FPA-OPERATIONS*
;	      '((SINGLE-ADD (SINGLE-FLOAT SINGLE-FLOAT) SINGLE-FLOAT ADD 2. #o000)
;		(SINGLE-SUB (SINGLE-FLOAT SINGLE-FLOAT) SINGLE-FLOAT ADD 2. #o004)
;		(SINGLE-MULTIPLY (SINGLE-FLOAT SINGLE-FLOAT) SINGLE-FLOAT MULTIPLY 2. #o010)
;		(SINGLE-QUOTIENT (SINGLE-FLOAT SINGLE-FLOAT) SINGLE-FLOAT DIVIDE 17. #o014)
;		(SINGLE-RATIONAL-QUOTIENT (SINGLE-FLOAT SINGLE-FLOAT) SINGLE-FLOAT DIVIDE 17. #o044)
;		(SINGLE-UNARY-MINUS (SINGLE-FLOAT) SINGLE-FLOAT ADD 2. #o060)
;		(SINGLE-EQUAL-NUMBER (SINGLE-FLOAT SINGLE-FLOAT) BOOLEAN MULTIPLY 2. #o100)
;		(SINGLE-LESSP (SINGLE-FLOAT SINGLE-FLOAT) BOOLEAN 2. MULTIPLY #o104)
;		(SINGLE-GREATERP (SINGLE-FLOAT SINGLE-FLOAT) BOOLEAN MULTIPLY 2. #o110)
;		(SINGLE-EQUAL-NUMBER-NO-POP (SINGLE-FLOAT SINGLE-FLOAT) BOOLEAN MULTIPLY 2. #o120)
;		(SINGLE-LESSP-NO-POP (SINGLE-FLOAT SINGLE-FLOAT) BOOLEAN MULTIPLY 2. #o124)
;		(SINGLE-GREATERP-NO-POP (SINGLE-FLOAT SINGLE-FLOAT) BOOLEAN MULTIPLY 2. #o130)
;		(SINGLE-ZEROP (SINGLE-FLOAT) BOOLEAN MULTIPLY 2. #o160)
;		(SINGLE-MINUSP (SINGLE-FLOAT) BOOLEAN MULTIPLY 2. #o164)
;		(SINGLE-PLUSP (SINGLE-FLOAT) BOOLEAN MULTIPLY 2. #o170)
;		(DOUBLE-ADD (DOUBLE-FLOAT DOUBLE-FLOAT) DOUBLE-FLOAT ADD 2. #o200)
;		(DOUBLE-SUB (DOUBLE-FLOAT DOUBLE-FLOAT) DOUBLE-FLOAT ADD 2. #o204)
;		(DOUBLE-MULTIPLY (DOUBLE-FLOAT DOUBLE-FLOAT) DOUBLE-FLOAT MULTIPLY 2. #o210)
;		(DOUBLE-QUOTIENT (DOUBLE-FLOAT DOUBLE-FLOAT) DOUBLE-FLOAT DIVIDE 31. #o214)
;		(DOUBLE-RATIONAL-QUOTIENT (DOUBLE-FLOAT DOUBLE-FLOAT) DOUBLE-FLOAT DIVIDE 31. #o244)
;		(DOUBLE-UNARY-MINUS (DOUBLE-FLOAT) DOUBLE-FLOAT MULTIPLY 2. #o260)
;		(DOUBLE-EQUAL-NUMBER (DOUBLE-FLOAT DOUBLE-FLOAT) BOOLEAN MULTIPLY 2. #o300)
;		(DOUBLE-LESSP (DOUBLE-FLOAT DOUBLE-FLOAT) BOOLEAN MULTIPLY 2. #o304)
;		(DOUBLE-GREATERP (DOUBLE-FLOAT DOUBLE-FLOAT) BOOLEAN MULTIPLY 2. #o310)
;		(DOUBLE-EQUAL-NUMBER-NO-POP (DOUBLE-FLOAT DOUBLE-FLOAT) BOOLEAN MULTIPLY 2. #o320)
;		(DOUBLE-LESSP-NO-POP (DOUBLE-FLOAT DOUBLE-FLOAT) BOOLEAN MULTIPLY 2. #o324)
;		(DOUBLE-GREATERP-NO-POP (DOUBLE-FLOAT DOUBLE-FLOAT) BOOLEAN MULTIPLY 2. #o330)
;		(DOUBLE-ZEROP (DOUBLE-FLOAT) BOOLEAN MULTIPLY 2. #o360)
;		(DOUBLE-MINUSP (DOUBLE-FLOAT) BOOLEAN MULTIPLY 2 #o364)
;		(DOUBLE-PLUSP (DOUBLE-FLOAT) BOOLEAN MULTIPLY 2. #o370)
;		(FIXNUM-MULTIPLY (FIXNUM FIXNUM) FIXNUM MULTIPLY 2. #o374)
;		(CONVERT-DOUBLE-TO-FIXNUM-ROUNDING (DOUBLE-FLOAT) FIXNUM NIL 2. #o400)
;		(CONVERT-DOUBLE-TO-FIXNUM-TRUNCATING (DOUBLE-FLOAT) FIXNUM NIL 2. #o404)
;		(CONVERT-SINGLE-TO-FIXNUM-ROUNDING (SINGLE-FLOAT) FIXNUM NIL 2. #o410)
;		(CONVERT-SINGLE-TO-FIXNUM-TRUNCATING (SINGLE-FLOAT) FIXNUM NIL 2. #o414)
;		(CONVERT-FIXNUM-TO-DOUBLE-ROUNDING (FIXNUM) DOUBLE-FLOAT NIL 2. #o430)
;		(CONVERT-FIXNUM-TO-SINGLE-TRUNCATION (FIXNUM) SINGLE-FLOAT NIL 2. #o434)
;		(CONVERT-DOUBLE-TO-SINGLE-ROUNDING (DOUBLE-FLOAT) SINGLE-FLOAT NIL 2. #o440)
;		(CONVERT-SINGLE-TO-DOUBLE-ROUNDING (SINGLE-FLOAT) DOUBLE-FLOAT NIL 2. #o450)
;		(DOUBLE-SQRT (DOUBLE-FLOAT) DOUBLE-FLOAT DIVIDE 57. #o500)
;		(SINGLE-SQRT (SINGLE-FLOAT) SINGLE-FLOAT DIVIDE 28. #o510)
;		(DOUBLE-ABS (DOUBLE-FLOAT) DOUBLE-FLOAT NIL 2. #o544)
;		(SINGLE-ABS (SINGLE-FLOAT) SINGLE-FLOAT NIL 2. #o554)))

(DEFMACRO %FPA-START (OPERATION &REST ARGS)
  (LET ((INFORMATION (ASSOC OPERATION *FPA-OPERATIONS* :TEST #'STRING-EQUAL)))
    (UNLESS INFORMATION
      (ERROR "Unknown FPA operation ~s" OPERATION))
    (DESTRUCTURING-BIND (OPERATION ARGUMENTS RESULT UNIT DELAY OPCODE) INFORMATION
      (DECLARE (IGNORE OPERATION RESULT UNIT DELAY))
      (MULTIPLE-VALUE-BIND (FIRST-ARG SECOND-ARG)
	  (IF (CDR ARGUMENTS)
	      (VALUES (CAR ARGUMENTS) (CADR ARGUMENTS))
	      (VALUES NIL (CAR ARGUMENTS)))
	`(PROGN ,@(WHEN FIRST-ARG
		    (ECASE FIRST-ARG
		      (SINGLE-FLOAT
			(LET ((ARG (POP ARGS)))
			  (WHEN ARG
			    `((%COPROCESSOR-WRITE ,ARG #o0)))))
		      (FIXNUM
			(LET ((ARG (POP ARGS)))
			  (WHEN ARG
			    `((%COPROCESSOR-WRITE ,ARG #o374)))))
		      (DOUBLE-FLOAT
			(LET ((HIGH (POP ARGS))
			      (LOW (POP ARGS)))
			  (WHEN HIGH
			    `((%COPROCESSOR-WRITE ,HIGH #o0)
			      (%COPROCESSOR-WRITE ,LOW #o2)))))))
		,@(ECASE SECOND-ARG
		    ((SINGLE-FLOAT FIXNUM)
		     `((%COPROCESSOR-WRITE ,(POP ARGS) ,(+ OPCODE 1))))
		    (DOUBLE-FLOAT
		      (LET ((HIGH (POP ARGS))
			    (LOW (POP ARGS)))
			`((%COPROCESSOR-WRITE ,LOW #o3)
			  (%COPROCESSOR-WRITE ,HIGH ,(+ OPCODE 1)))))))))))

;;; If :AFTER-TEST is supplied, then we tested for the FPA after starting the
;;; operation.  It takes  
(DEFMACRO %FPA-WAIT (OPERATION &KEY AFTER-TEST)
  (LET ((INFORMATION (ASSOC OPERATION *FPA-OPERATIONS* :TEST #'STRING-EQUAL)))
    (UNLESS INFORMATION
      (ERROR "Unknown FPA operation ~s" OPERATION))
    (DESTRUCTURING-BIND (OPERATION ARGUMENTS RESULT UNIT DELAY OPCODE) INFORMATION
      (DECLARE (IGNORE OPERATION ARGUMENTS RESULT UNIT OPCODE))
      (LET ((REMAINING (- DELAY (IF AFTER-TEST 3 0))))
	(COND (( REMAINING 0) NIL)
	      (( DELAY 10.)
	       `(COPROCESSOR-WAIT ,REMAINING))
	      (T
	       `(LET ((MASK (DPB -1 %%W3X64-DIVIDE-SQUARE-ROOT-IN-PROGRESS 0)))
		  (LOOP WHILE (LOGTEST (%FPA-FPEX-DIVIDE-STATUS-REGISTER)
				       MASK)))))))))

(DEFMACRO %FPA-RESULT (OPERATION)
  (LET ((INFORMATION (ASSOC OPERATION *FPA-OPERATIONS* :TEST #'STRING-EQUAL)))
    (UNLESS INFORMATION
      (ERROR "Unknown FPA operation ~s" OPERATION))
    (DESTRUCTURING-BIND (OPERATION ARGUMENTS RESULT UNIT DELAY OPCODE) INFORMATION
      (DECLARE (IGNORE OPERATION ARGUMENTS UNIT DELAY))
      `(VALUES ,@(ECASE RESULT
		   (SINGLE-FLOAT
		    `((%COPROCESSOR-READ 2)))
		   (BOOLEAN
		     `((%COPROCESSOR-READ ,(+ OPCODE 2))))
		   (DOUBLE-FLOAT
		     `((%COPROCESSOR-READ 2)
		       (%COPROCESSOR-READ 3)))
		   (FIXNUM
		     `((%COPROCESSOR-READ #o400))))))))

(DEFMACRO %FPA-DOUBLE-RESULT-HIGH (OPERATION)
  (DECLARE (IGNORE OPERATION))
  '(%COPROCESSOR-READ 2))

(DEFMACRO %FPA-DOUBLE-RESULT-LOW (OPERATION)
  (DECLARE (IGNORE OPERATION))
  '(%COPROCESSOR-READ 3))

(DEFMACRO %FPA-DOUBLE-RESULT (OPERATION)
  (DECLARE (IGNORE OPERATION))
  `(VALUES (%FIXNUM (%COPROCESSOR-READ 2))
	   (%FIXNUM (%COPROCESSOR-READ 3))))

(DEFMACRO %FPA-STATUS (OPERATION)
  (LET ((INFORMATION (ASSOC OPERATION *FPA-OPERATIONS* :TEST #'STRING-EQUAL)))
    (UNLESS INFORMATION
      (ERROR "Unknown FPA operation ~s" OPERATION))
    (DESTRUCTURING-BIND (OPERATION ARGUMENTS RESULT UNIT DELAY OPCODE) INFORMATION
      (DECLARE (IGNORE OPERATION ARGUMENTS RESULT DELAY OPCODE))
      (ECASE UNIT
	(ADD `(LDB %%W3X64-ADDER-STATUS (%FPA-ADDER-MULTIPLIER-STATUS-REGISTER)))
	(MULTIPLY `(LDB %%W3X64-MULTIPLIER-STATUS (%FPA-ADDER-MULTIPLIER-STATUS-REGISTER)))
	(DIVIDE `(LDB %%W3X64-DIVIDER-STATUS (%FPA-FPEX-DIVIDE-STATUS-REGISTER)))))))

(EVAL-WHEN (COMPILE LOAD EVAL)
(DEFCONSTANT %FPA-SET-R2-HIGH-ADDRESS #o200)
(DEFCONSTANT %FPA-SET-R2-LOW-ADDRESS #o202)
(DEFCONSTANT %FPA-STATUS-REGISTER-BASE-ADDRESS #o600)
(DEFCONSTANT %FPA-RESET-ADDRESS #o624)
)

(DEFMACRO %FPA-STATUS-REGISTER (N)
  `(%FIXNUM (%COPROCESSOR-READ ,(+ %FPA-STATUS-REGISTER-BASE-ADDRESS N))))
(DEFSETF %FPA-STATUS-REGISTER (N) (NEW-VALUE)
  `(SETF (%COPROCESSOR-READ ,(+ %FPA-STATUS-REGISTER-BASE-ADDRESS N)) ,NEW-VALUE))

(DEFMACRO %FPA-MODE-REGISTER ()
  `(%FPA-STATUS-REGISTER 0.))
(DEFMACRO %FPA-TRAP-ENABLES-REGISTER ()
  `(%FPA-STATUS-REGISTER 2.))
(DEFMACRO %FPA-STICKY-BITS-REGISTER ()
  `(%FPA-STATUS-REGISTER 3.))
(DEFMACRO %FPA-ADDER-MULTIPLIER-STATUS-REGISTER ()
  `(%FPA-STATUS-REGISTER 6.))
(DEFMACRO %FPA-FPEX-DIVIDE-STATUS-REGISTER ()
  `(%FPA-STATUS-REGISTER 11.))

;;; Status Register 0 (Modes)
(DEFSYSBYTE %%W3X64-MULTIPLIER-LATENCY 1. 31.)
(DEFSYSBYTE %%W3X64-FPEX-STICKY 1. 30.)
(DEFSYSBYTE %%W3X64-INTERNAL-NEUT-ON 1. 27.)
(DEFSYSBYTE %%W3X64-ROUNDING-MODE 2. 25.)
(DEFSYSBYTE %%W3X64-FAST-MODE 1. 24.)

;;; Status Register 1 (Modes)
(DEFSYSBYTE %%W3X64-BYPASS-ON 1. 30.)
(DEFSYSBYTE %%W3X64-FPEX-DELAY 1. 29.)
(DEFSYSBYTE %%W3X64-I/O-MODE 5. 24.)

;;; Status Register 2 (Trap Enables)
(DEFSYSBYTE %%W3X64-NAN-TRAP-ENABLE 1. 31.)
(DEFSYSBYTE %%W3X64-INVALID-OPERATION-TRAP-ENABLE 1. 30.)
(DEFSYSBYTE %%W3X64-DIVISION-BY-ZERO-TRAP-ENABLE 1. 29.)
(DEFSYSBYTE %%W3X64-DENORMALIZED-INPUT-TRAP-ENABLE 1. 28.)
(DEFSYSBYTE %%W3X64-OVERFLOW-TRAP-ENABLE 1. 27.)
(DEFSYSBYTE %%W3X64-UNDERFLOW-TRAP-ENABLE 1. 26.)
(DEFSYSBYTE %%W3X64-INEXACT-RESULT-TRAP-ENABLE 1. 25.)
(DEFSYSBYTE %%W3X64-INTEGER-OVERFLOW-TRAP-ENABLE 1. 24.)

;;; Status Register 3 (Flags)
(DEFSYSBYTE %%W3X64-NAN-FLAG 1. 31.)
(DEFSYSBYTE %%W3X64-INVALID-OPERATION-FLAG 1. 30.)
(DEFSYSBYTE %%W3X64-DIVISION-BY-ZERO-FLAG 1. 29.)
(DEFSYSBYTE %%W3X64-DENORMALIZED-INPUT-FLAG 1. 28.)
(DEFSYSBYTE %%W3X64-OVERFLOW-FLAG 1. 27.)
(DEFSYSBYTE %%W3X64-UNDERFLOW-FLAG 1. 26.)
(DEFSYSBYTE %%W3X64-INEXACT-RESULT-FLAG 1. 25.)
(DEFSYSBYTE %%W3X64-INTEGER-OVERFLOW-FLAG 1. 24.)

;;; Status Register 10 (Status)
(DEFSYSBYTE %%W3X64-ADDER-STATUS 4. 28.)
(DEFSYSBYTE %%W3X64-MULTIPLIER-STATUS 4. 24.)

;;; Status Register 11 (Status)
(DEFSYSBYTE %%W3X64-FPEX-TAKEN 1. 31.)
(DEFSYSBYTE %%W3X64-DIVIDE-SQUARE-ROOT-IN-PROGRESS 1. 30.)
(DEFSYSBYTE %%W3X64-FLOATING-POINT-CONDITION 1. 29.)
(DEFSYSBYTE %%W3X64-CARRY 1. 28.)
(DEFSYSBYTE %%W3X64-DIVIDER-STATUS 4. 24.)

(DEFENUMERATED *W3X64-STATUS-CODES*
	       (%W3X64-NORMALIZED-EXACT-32
		%W3X64-NORMALIZED-INEXACT-32
		%W3X64-UNORMALIZED-EXACT-32
		%W3X64-UNORMALIZED-INEXACT-32
		%W3X64-OVERFLOW-32
		%W3X64-RESERVED-5
		%W3X64-RESERVED-6
		%W3X64-RESERVED-7
		%W3X64-NORMALIZED-EXACT-64
		%W3X64-NORMALIZED-INEXACT-64
		%W3X64-UNORMALIZED-EXACT-64
		%W3X64-UNORMALIZED-INEXACT-64
		%W3X64-OVERFLOW-64
		%W3X64-OVERFLOW-6432
		%W3X64-UNDERFLOW-6432
		%W3X64-INTEGER-OVERFLOW))

(DEFSUBST FP-COPROCESSOR-ENABLED-P ()
  #-VLM (LDB-TEST (BYTE 1 0) (%READ-INTERNAL-REGISTER %REGISTER-FP-COPROCESSOR-PRESENT))
  #+VLM NIL)

#+VLM
(DEFSETF FP-COPROCESSOR-ENABLED-P () (NEW-VALUE)
  NEW-VALUE)

(DEFUN W3X64-EXISTS-P ()
  #+VLM NIL
  #-VLM (PROCESS:WITHOUT-PREEMPTION
	  ;; Bus capacitance on some hardware can make the last thing written
	  ;; come back.  We use a pattern that flips a lot of bits to try to
	  ;; avoid this problem.  In other hardware, the last thing read from
	  ;; memory will show up as the next coprocessor read.  We push the
	  ;; answer onto the stack first to avoid this problem.
	  (LET ((ANSWER #B01010101010101010101010101010100))
	    (%FPA-START SINGLE-MULTIPLY
			(%FLONUM (%LOGLDB (BYTE 32. 0.) #B10101010101010101010101010101010))
			(%FLONUM (%LOGLDB (BYTE 32. 0.) #B11101010001000000000000000000000)))
	    (%FPA-WAIT SINGLE-MULTIPLY)
	    (EQL (%FIXNUM (%FPA-RESULT SINGLE-MULTIPLY)) ANSWER))))

(DEFUN INITIALIZE-W3X64 (&OPTIONAL FORCE)
  #+VLM (DECLARE (IGNORE FORCE))
  #+VLM NIL
  #-VLM
  (PROCESS:WITHOUT-PREEMPTION
    (SETF (FP-COPROCESSOR-ENABLED-P)
	  (AND (OR FORCE
		   (AND (VARIABLE-BOUNDP *ENABLE-FPA-P*)
			*ENABLE-FPA-P*))
	       (PROGN
		 (%COPROCESSOR-WRITE 0 %FPA-RESET-ADDRESS)
		 ;; Wait at least 20 cycles
		 (LOOP REPEAT 10. DOING (COMPILER:NO-OP))
		 (SETF (%FPA-STATUS-REGISTER 1)
		       (%LOGDPBS 1 %%W3X64-BYPASS-ON
				 (SYSTEM-CASE
				   ((MERLIN-II MacIvory-3 Domino) 1)
				   (OTHERWISE 0))
				 %%W3X64-FPEX-DELAY
				 0))
		 (SETF (%FPA-MODE-REGISTER)
		       (%LOGDPB (LDB %%FLOAT-ROUNDING-MODE *DEFAULT-FLOAT-OPERATING-MODE*)
				%%W3X64-ROUNDING-MODE
				(%LOGDPBS 1 %%W3X64-FPEX-STICKY
					  0)))
		 (SETF (%FPA-TRAP-ENABLES-REGISTER)
		       (%LOGDPBS
			 (LDB %%FLOAT-TRAP-ENABLE-INEXACT-RESULT
			      *DEFAULT-FLOAT-OPERATING-MODE*)
			 %%W3X64-INEXACT-RESULT-TRAP-ENABLE
			 (LDB %%FLOAT-TRAP-ENABLE-UNDERFLOW *DEFAULT-FLOAT-OPERATING-MODE*)
			 %%W3X64-UNDERFLOW-TRAP-ENABLE
			 (LDB %%FLOAT-TRAP-ENABLE-OVERFLOW *DEFAULT-FLOAT-OPERATING-MODE*)
			 %%W3X64-OVERFLOW-TRAP-ENABLE
			 1
			 %%W3X64-DENORMALIZED-INPUT-TRAP-ENABLE
			 (LDB %%FLOAT-TRAP-ENABLE-DIVISION-BY-ZERO
			      *DEFAULT-FLOAT-OPERATING-MODE*)
			 %%W3X64-DIVISION-BY-ZERO-TRAP-ENABLE
			 1
			 %%W3X64-INTEGER-OVERFLOW-TRAP-ENABLE
			 (LDB %%FLOAT-TRAP-ENABLE-INVALID-OPERATION
			      *DEFAULT-FLOAT-OPERATING-MODE*)
			 %%W3X64-INVALID-OPERATION-TRAP-ENABLE
			 0))
		 ;; Clear the status registers
		 (SETF (%FPA-ADDER-MULTIPLIER-STATUS-REGISTER) 0)
		 (SETF (%FPA-STATUS-REGISTER 10.) 0)
		 (SETF (%FPA-FPEX-DIVIDE-STATUS-REGISTER) 0)
		 (SET-FLOAT-OPERATING-MODE FLOAT-OPERATING-MODE)
		 (SET-FLOAT-OPERATION-STATUS FLOAT-OPERATION-STATUS)
		 ;; Initialize R2
		 (%COPROCESSOR-WRITE (DOUBLE-HIGH 0D0) %FPA-SET-R2-HIGH-ADDRESS)
		 (%COPROCESSOR-WRITE (DOUBLE-LOW 0D0) %FPA-SET-R2-LOW-ADDRESS)
		 (WHEN (W3X64-EXISTS-P)
		   (SI:REV4-INTEGER-MULTIPLY-TRAP-HANDLER-CHECK T)
		   T))))))

(DEFUN DISABLE-FP-COPROCESSOR ()
  (PROCESS:WITHOUT-PREEMPTION
    (SETF (FP-COPROCESSOR-ENABLED-P) NIL)
    (SETQ FLOAT-OPERATION-STATUS (FLOAT-OPERATION-STATUS))	;Move status bits into variable
    (SETF (FP-COPROCESSOR-ENABLED-P) NIL)
    #-VLM (SI:REV4-INTEGER-MULTIPLY-TRAP-HANDLER-CHECK NIL)))

;;; See comments before SI:ARITHMETIC-OPERATION-TIMES-FIXNUM-FIXNUM-REV4
#-VLM
(DEFUN SI:REV4-INTEGER-MULTIPLY-TRAP-HANDLER-CHECK (INSTALL-P)
  (DECLARE (IGNORE INSTALL-P))
  (SYSTEM-CASE
    ((MERLIN-II MacIvory-3 Domino)
     (WHEN (= SI:*IVORY-REVISION-NUMBER* %IVORY-REVISION-4)
       (IF (AND INSTALL-P
		(FBOUNDP 'SI:ARITHMETIC-OPERATION-TIMES-FIXNUM-FIXNUM-REV4-TRAP-HANDLER))
	   ;; Install special Rev4 trap-handler
	   (SI:SET-TRAP-VECTOR-ENTRY
	     #o200 TRAP-MODE-EMULATOR
	     'SI:ARITHMETIC-OPERATION-TIMES-FIXNUM-FIXNUM-REV4-TRAP-HANDLER)
	   ;; Install usual trap-handler
	   (SI:SET-TRAP-VECTOR-ENTRY
	     #o200 TRAP-MODE-EMULATOR
	     'SI:ARITHMETIC-OPERATION-TIMES-FIXNUM-FIXNUM-TRAP-HANDLER))))
    (OTHERWISE
      NIL)))


;;; Also leaves the the floating point mode in a safe state

;;; There are two versions of this macro -- One for the VLM which doesn't include all
;;; the code to handle the FPA as the VLM doesn't have one and it'd be too messy to
;;; conditionalize one copy or arrange to test D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")fp-coprocessor-enabled-p0 rather than
;;; cache its value.  (Testing it multiple times may, in fact, be wrong.)  The other
;;; version includes the code to handle the FPA and is used on Ivory-based systems.

#-VLM
(DEFMACRO WITH-FLOATING-POINT-STATUS-SAVED (PROTECTED-FORM &REST CLEANUP-HANDLERS)
  `(LET ((OLD-FLOAT-OPERATION-STATUS FLOAT-OPERATION-STATUS)
	 (OLD-FLOAT-OPERATING-MODE FLOAT-OPERATING-MODE)
	 (COPROCESSOR-P (FP-COPROCESSOR-ENABLED-P)))
     (MULTIPLE-VALUE-BIND (MODE-REG ENABLES FPEX-DIV
			   R0-HIGH R0-LOW R1-LOW
			   STICKY ADDER-MULTIPLIER)
	 (IF COPROCESSOR-P
	     (VALUES
	       ;; Wait for the FPA to finish what it is doing.  Otherwise there is a
	       ;; timing window between when the DTP-NULL value is read and when the
	       ;; tag is set to DTP-FIXNUM when the garbage collector could transport
	       ;; it.
	       (LOOP DOING
		 (LET ((MODE (%COPROCESSOR-READ (+ %FPA-STATUS-REGISTER-BASE-ADDRESS 0))))
		   (WHEN (TYPE-MEMBER MODE DTP-FIXNUM DTP-SINGLE-FLOAT)
		     (RETURN (%FIXNUM MODE)))))
	       (%FPA-TRAP-ENABLES-REGISTER)
	       (LOOP DOING
		 (LET ((SR11 (%FPA-FPEX-DIVIDE-STATUS-REGISTER)))
		   (UNLESS (LDB-TEST %%W3X64-DIVIDE-SQUARE-ROOT-IN-PROGRESS SR11)
		     (RETURN SR11))))
	       (%FPA-R0-HIGH)
	       (%FPA-R0-LOW)
	       (%COPROCESSOR-READ 1)
	       (%FPA-STICKY-BITS-REGISTER)
	       (%FPA-ADDER-MULTIPLIER-STATUS-REGISTER))
	     NIL)
       (UNWIND-PROTECT
	   (PROGN
	     (SETQ FLOAT-OPERATING-MODE *DEFAULT-FLOAT-OPERATING-MODE*)
	     (SETQ FLOAT-OPERATION-STATUS 0)
	     (WHEN COPROCESSOR-P
	       (SETF (%FPA-MODE-REGISTER)
		     (%LOGDPB (LDB %%FLOAT-ROUNDING-MODE *DEFAULT-FLOAT-OPERATING-MODE*)
			      %%W3X64-ROUNDING-MODE
			      (%LOGDPBS 1 %%W3X64-FPEX-STICKY
					0)))
	       (SETF (%FPA-TRAP-ENABLES-REGISTER)
		     (%LOGDPBS
		       (LDB %%FLOAT-TRAP-ENABLE-INEXACT-RESULT *DEFAULT-FLOAT-OPERATING-MODE*)
		       %%W3X64-INEXACT-RESULT-TRAP-ENABLE
		       (LDB %%FLOAT-TRAP-ENABLE-UNDERFLOW *DEFAULT-FLOAT-OPERATING-MODE*)
		       %%W3X64-UNDERFLOW-TRAP-ENABLE
		       (LDB %%FLOAT-TRAP-ENABLE-OVERFLOW *DEFAULT-FLOAT-OPERATING-MODE*)
		       %%W3X64-OVERFLOW-TRAP-ENABLE
		       1
		       %%W3X64-DENORMALIZED-INPUT-TRAP-ENABLE
		       (LDB %%FLOAT-TRAP-ENABLE-DIVISION-BY-ZERO
			    *DEFAULT-FLOAT-OPERATING-MODE*)
		       %%W3X64-DIVISION-BY-ZERO-TRAP-ENABLE
		       1
		       %%W3X64-INTEGER-OVERFLOW-TRAP-ENABLE
		       (LDB %%FLOAT-TRAP-ENABLE-INVALID-OPERATION
			    *DEFAULT-FLOAT-OPERATING-MODE*)
		       %%W3X64-INVALID-OPERATION-TRAP-ENABLE
		       0))
	       ;; Clear the status registers
	       (SETF (%FPA-ADDER-MULTIPLIER-STATUS-REGISTER) 0)
	       (SETF (%FPA-STATUS-REGISTER 10.) 0)
	       (SETF (%FPA-FPEX-DIVIDE-STATUS-REGISTER) 0))
	     ,PROTECTED-FORM)
	 (WHEN COPROCESSOR-P
	   (SETF (%FPA-MODE-REGISTER) MODE-REG)
	   (SETF (%FPA-TRAP-ENABLES-REGISTER) ENABLES)
	   (SETF (%FPA-FPEX-DIVIDE-STATUS-REGISTER) FPEX-DIV)
	   (SETF (%FPA-R0-HIGH) R0-HIGH)
	   (SETF (%FPA-R0-LOW) R0-LOW)
	   (%COPROCESSOR-WRITE R1-LOW 3)
	   (SETF (%FPA-STICKY-BITS-REGISTER) STICKY)
	   (SETF (%FPA-ADDER-MULTIPLIER-STATUS-REGISTER) ADDER-MULTIPLIER))
	 (SETQ FLOAT-OPERATING-MODE OLD-FLOAT-OPERATING-MODE)
	 (SETQ FLOAT-OPERATION-STATUS OLD-FLOAT-OPERATION-STATUS)
	 ,@CLEANUP-HANDLERS))))

#+VLM
(DEFMACRO WITH-FLOATING-POINT-STATUS-SAVED (PROTECTED-FORM &REST CLEANUP-HANDLERS)
  `(LET ((OLD-FLOAT-OPERATION-STATUS FLOAT-OPERATION-STATUS)
	 (OLD-FLOAT-OPERATING-MODE FLOAT-OPERATING-MODE))
     (UNWIND-PROTECT
	 (PROGN
	   (SETQ FLOAT-OPERATING-MODE *DEFAULT-FLOAT-OPERATING-MODE*)
	   (SETQ FLOAT-OPERATION-STATUS 0)
	   ,PROTECTED-FORM)
       (SETQ FLOAT-OPERATING-MODE OLD-FLOAT-OPERATING-MODE)
       (SETQ FLOAT-OPERATION-STATUS OLD-FLOAT-OPERATION-STATUS)
       ,@CLEANUP-HANDLERS)))



;;; There are two versions of this macro -- One for the VLM which doesn't include all
;;; the code to handle the FPA as the VLM doesn't have one and it'd be too messy to
;;; conditionalize one copy or arrange to test 1fp-coprocessor-enabled-p0 rather than
;;; cache its value.  (Testing it multiple times may, in fact, be wrong.)  The other
;;; version includes the code to handle the FPA and is used on Ivory-based systems.

#-VLM
(DEFMACRO WITH-FLOATING-POINT-STATUS-SAVED-FOR-TRAP (&BODY BODY)
  `(LET ((OLD-FLOAT-OPERATION-STATUS FLOAT-OPERATION-STATUS)
	 (OLD-FLOAT-OPERATING-MODE FLOAT-OPERATING-MODE)
	 (COPROCESSOR-P (FP-COPROCESSOR-ENABLED-P)))
     (MULTIPLE-VALUE-BIND (MODE-REG ENABLES FPEX-DIV
			   R0-HIGH R0-LOW R1-LOW
			   STICKY ADDER-MULTIPLIER)
	 (IF COPROCESSOR-P
	     (VALUES
	       ;; Wait for the FPA to finish what it is doing.  Otherwise there is a
	       ;; timing window between when the DTP-NULL value is read and when the
	       ;; tag is set to DTP-FIXNUM when the garbage collector could transport
	       ;; it.
	       (LOOP DOING
		 (LET ((MODE (%COPROCESSOR-READ (+ %FPA-STATUS-REGISTER-BASE-ADDRESS 0))))
		   (WHEN (TYPE-MEMBER MODE DTP-FIXNUM DTP-SINGLE-FLOAT)
		     (RETURN (%FIXNUM MODE)))))
	       (%FPA-TRAP-ENABLES-REGISTER)
	       (LOOP DOING
		 (LET ((SR11 (%FPA-FPEX-DIVIDE-STATUS-REGISTER)))
		   (UNLESS (LDB-TEST %%W3X64-DIVIDE-SQUARE-ROOT-IN-PROGRESS SR11)
		     (RETURN SR11))))
	       (%FPA-R0-HIGH)
	       (%FPA-R0-LOW)
	       (%COPROCESSOR-READ 1)
	       (%FPA-STICKY-BITS-REGISTER)
	       (%FPA-ADDER-MULTIPLIER-STATUS-REGISTER))
	     NIL)
       (MULTIPLE-VALUE-PROG1
	   (PROGN
	     (SETQ FLOAT-OPERATING-MODE *DEFAULT-FLOAT-OPERATING-MODE*)
	     (SETQ FLOAT-OPERATION-STATUS 0)
	     (WHEN COPROCESSOR-P
	       (SETF (%FPA-MODE-REGISTER)
		     (%LOGDPB (LDB %%FLOAT-ROUNDING-MODE *DEFAULT-FLOAT-OPERATING-MODE*)
			      %%W3X64-ROUNDING-MODE
			      (%LOGDPBS 1 %%W3X64-FPEX-STICKY
					0)))
	       (SETF (%FPA-TRAP-ENABLES-REGISTER)
		     (%LOGDPBS
		       (LDB %%FLOAT-TRAP-ENABLE-INEXACT-RESULT *DEFAULT-FLOAT-OPERATING-MODE*)
		       %%W3X64-INEXACT-RESULT-TRAP-ENABLE
		       (LDB %%FLOAT-TRAP-ENABLE-UNDERFLOW *DEFAULT-FLOAT-OPERATING-MODE*)
		       %%W3X64-UNDERFLOW-TRAP-ENABLE
		       (LDB %%FLOAT-TRAP-ENABLE-OVERFLOW *DEFAULT-FLOAT-OPERATING-MODE*)
		       %%W3X64-OVERFLOW-TRAP-ENABLE
		       1
		       %%W3X64-DENORMALIZED-INPUT-TRAP-ENABLE
		       (LDB %%FLOAT-TRAP-ENABLE-DIVISION-BY-ZERO
			    *DEFAULT-FLOAT-OPERATING-MODE*)
		       %%W3X64-DIVISION-BY-ZERO-TRAP-ENABLE
		       1
		       %%W3X64-INTEGER-OVERFLOW-TRAP-ENABLE
		       (LDB %%FLOAT-TRAP-ENABLE-INVALID-OPERATION
			    *DEFAULT-FLOAT-OPERATING-MODE*)
		       %%W3X64-INVALID-OPERATION-TRAP-ENABLE
		       0))
	       ;; Clear the status registers
	       (SETF (%FPA-ADDER-MULTIPLIER-STATUS-REGISTER) 0)
	       (SETF (%FPA-STATUS-REGISTER 10.) 0)
	       (SETF (%FPA-FPEX-DIVIDE-STATUS-REGISTER) 0))
	     ,@BODY)
	 (WHEN COPROCESSOR-P
	   (SETF (%FPA-MODE-REGISTER) MODE-REG)
	   (SETF (%FPA-TRAP-ENABLES-REGISTER) ENABLES)
	   (SETF (%FPA-FPEX-DIVIDE-STATUS-REGISTER) FPEX-DIV)
	   (SETF (%FPA-R0-HIGH) R0-HIGH)
	   (SETF (%FPA-R0-LOW) R0-LOW)
	   (%COPROCESSOR-WRITE R1-LOW 3)
	   (SETF (%FPA-STICKY-BITS-REGISTER) STICKY)
	   (SETF (%FPA-ADDER-MULTIPLIER-STATUS-REGISTER) ADDER-MULTIPLIER))
	 (SETQ FLOAT-OPERATING-MODE OLD-FLOAT-OPERATING-MODE)
	 (SETQ FLOAT-OPERATION-STATUS OLD-FLOAT-OPERATION-STATUS)))))

#+VLM
(DEFMACRO WITH-FLOATING-POINT-STATUS-SAVED-FOR-TRAP (&BODY BODY)
  `(LET ((OLD-FLOAT-OPERATION-STATUS FLOAT-OPERATION-STATUS)
	 (OLD-FLOAT-OPERATING-MODE FLOAT-OPERATING-MODE))
     (MULTIPLE-VALUE-PROG1
       (PROGN
	 (SETQ FLOAT-OPERATING-MODE *DEFAULT-FLOAT-OPERATING-MODE*)
	 (SETQ FLOAT-OPERATION-STATUS 0)
	 ,@BODY)
       (SETQ FLOAT-OPERATING-MODE OLD-FLOAT-OPERATING-MODE)
       (SETQ FLOAT-OPERATION-STATUS OLD-FLOAT-OPERATION-STATUS))))



(DEFUN UPDATE-FLOAT-OPERATION-STATUS (STICKY-BITS)
  (DECLARE (SYS:SAFEGUARDED-FUNCTION))
  (SETQ FLOAT-OPERATION-STATUS
	(LOGIOR FLOAT-OPERATION-STATUS
		(LOGAND STICKY-BITS
			(LOGNOT (%FPA-TRAP-ENABLES-REGISTER))
			(%LOGDPBS 0 %%FLOAT-FLAG-UNDERFLOW
				  -1 %%FLOAT-FLAG-BITS
				  0))))
  (SETF (%FPA-FPEX-DIVIDE-STATUS-REGISTER) 0)
  (SETF (%FPA-STICKY-BITS-REGISTER) 0))

(DEFUN SET-FLOAT-OPERATING-MODE (NEW-MODE)
  (DECLARE (SYS:SAFEGUARDED-FUNCTION))
  (LET ((OLD-MODE FLOAT-OPERATING-MODE))
    (UNLESS (= OLD-MODE NEW-MODE)
      (SETQ FLOAT-OPERATING-MODE NEW-MODE)
      (WHEN (FP-COPROCESSOR-ENABLED-P)
	(SETF (%FPA-STATUS-REGISTER 0)
	      (%LOGDPB (LDB %%FLOAT-ROUNDING-MODE NEW-MODE)
		       %%W3X64-ROUNDING-MODE
		       (%LOGDPBS 1 %%W3X64-FPEX-STICKY
				 0)))
	(UPDATE-FLOAT-OPERATION-STATUS (%FPA-STICKY-BITS-REGISTER))
	(SETF (%FPA-TRAP-ENABLES-REGISTER)
	      (LOGIOR NEW-MODE
		      (%LOGDPBS 1 %%W3X64-DENORMALIZED-INPUT-TRAP-ENABLE
				1 %%W3X64-INTEGER-OVERFLOW-TRAP-ENABLE
				0)))
	;; Clear the status registers
	(SETF (%FPA-ADDER-MULTIPLIER-STATUS-REGISTER) 0)
	(SETF (%FPA-STATUS-REGISTER 10.) 0)
	(SETF (%FPA-FPEX-DIVIDE-STATUS-REGISTER) 0)))))

(DEFSUBST FLOAT-OPERATING-MODE ()
  FLOAT-OPERATING-MODE)

(DEFUN FLOAT-OPERATION-STATUS ()
  (DECLARE (SYS:SAFEGUARDED-FUNCTION))
  (IF (FP-COPROCESSOR-ENABLED-P)
      (LOGIOR FLOAT-OPERATION-STATUS
	      (LOGAND (%FPA-STICKY-BITS-REGISTER)
		      (LOGNOT (%FPA-TRAP-ENABLES-REGISTER))))
      FLOAT-OPERATION-STATUS))

(DEFUN SET-FLOAT-OPERATION-STATUS (NEW-VALUE)
  (DECLARE (SYS:SAFEGUARDED-FUNCTION))
  (SETQ FLOAT-OPERATION-STATUS NEW-VALUE)
  (WHEN (FP-COPROCESSOR-ENABLED-P)
    (SETF (%FPA-STICKY-BITS-REGISTER) 0)))

(DEFSUBST READ-FPA-SIGNALS (STICKY-BITS)
  (ROT (LOGAND STICKY-BITS
	       (%LOGDPBS 0 %%FLOAT-FLAG-UNDERFLOW
			 -1 %%FLOAT-FLAG-BITS
			 0))
       (- (BYTE-POSITION %%FLOAT-SIGNAL-BITS)
	  (BYTE-POSITION %%FLOAT-FLAG-BITS))))

(DEFMACRO CLEAR-FLOAT-SIGNALS ()
  `(SETF (%LOGLDB %%FLOAT-SIGNAL-BITS FLOAT-OPERATION-STATUS) 0))


;;; Unboxed multi-word integer arithmetic
;;;
;;; These integers are like bignums, and will become a BIGNUM if allowed
;;; to escape.  The following operators do not preserve evaluation
;;; order.
;;;
;;; 1%unboxed-integer0 (2 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")sign0 &REST 2components
0;;;  2sign0 should be -1 or 0.
;;;  2components0 are ordered from least significant to most significant
;;;  Normally this is used only as a marker for the macros below.  If it "escapes",
;;;  it will turn into an appropriate FIXNUM/BIGNUM, but this is not the intended
;;;  usage.
;;;
;;; 1%positive-integer0 &REST 2components
0;;;  A convenience macro.  Makes a positive unboxed integer.
;;;
;;; 1%unboxed-integer-values0 2n unboxed-integer
0;;;  Returns the low 2n0 words of 2unboxed-integer0 as a multiple value group.
;;;
;;; 1%unboxed-ldb0 2byte-spec0 2unboxed-integer
0;;;  Returns an unboxed integer.  2byte-spec0 should be known at compile-time.
;;;
;;; 1%unboxed-dpb0 2new-byte0 2byte-spec0 2unboxed-integer
0;;;  Returns an unboxed integer.  2byte-spec0 should be known at compile-time.
;;;
;;; 1%unboxed-left-shift0 2unboxed-integer0 2n
0;;;  Shifts 2unboxed-integer0 left by 2n0, which must be a positive integer.
;;;
;;; 1%unboxed-right-shift0 2unboxed-integer0 2n
0;;; Shifts 2unboxed-integer0 right by 2-n0.  2n0 must be a negative integer.
;;;
;;; 1%unboxed-logior0 2unboxed-integer1 unboxed-integer2
0;;;
;;; 1%unboxed-zerop0 2unboxed-integer
0
;;; Mainly for debugging
(DEFUN %UNBOXED-INTEGER (SIGN &REST COMPONENTS)
  (LET* ((COMPONENTS
	   ;; Strip off any excess baggage
	   (LOOP FOR REV-COMPONENTS ON (REVERSE COMPONENTS) UNTIL ( (CAR REV-COMPONENTS) SIGN)
		 FINALLY (RETURN (REVERSE REV-COMPONENTS))))
	 (N-COMPONENTS (LENGTH COMPONENTS)))
    (COND ((ZEROP N-COMPONENTS) SIGN)
	  ((> N-COMPONENTS 1)
	   (APPLY #'SI:%MAKE-BIGNUM-FROM-FIXNUM-COMPONENTS SIGN N-COMPONENTS COMPONENTS))
	  (T
	   (LET ((COMPONENT (FIRST COMPONENTS) ))
	     (IF (= (%LOGLDB (BYTE 1. 31.) COMPONENT) (- SIGN))
		 COMPONENT
		 (SI:%MAKE-BIGNUM-FROM-FIXNUM-COMPONENTS SIGN 1 COMPONENT)))))))

(DEFMACRO %POSITIVE-INTEGER (&REST COMPONENTS)
  `(%UNBOXED-INTEGER 0 ,@COMPONENTS))

(DEFMACRO %UNBOXED-INTEGER-VALUES (N &BODY BODY &ENVIRONMENT ENVIRONMENT)
  (LT:COPYFORMS
    #'(LAMBDA (FORM KIND USAGE)
	(DECLARE (IGNORE USAGE))
	(IF (MEMBER KIND LT:*MAPFORMS-NON-FORM-KINDS*)
	    FORM
	    (IF (LISTP FORM)
		(CASE (CAR FORM)
		  (%UNBOXED-INTEGER
		    (VALUES
		      `(VALUES
			 ,@(LOOP FOR I FROM 0 BELOW N
				 COLLECT (OR (NTH I (CDDR FORM)) (CADR FORM))))
		      T))
		  (OTHERWISE FORM))
		FORM)))
    `(PROGN ,@BODY)
    :EXPAND-SUBSTS T
    :EXPAND-ALL-MACROS T
    :ENVIRONMENT ENVIRONMENT))

;;; This is the work-horse of the unboxed integer arithmetic operators.
;;; FORM should be a lisp form which returns an unboxed integer produced
;;; in a simple way; conditionals are not understood.  CONTINUATION is
;;; applied to the form producing the unboxed integer.
(DEFUN MODIFY-UNBOXED-INTEGER-INTERNAL (FORM CONTINUATION ENVIRONMENT)
  (LET ((FOUND-P NIL))
    (LABELS ((MODIFY-INTERNAL (FORM KIND USAGE)
	       (DECLARE (IGNORE USAGE))
	       (IF (MEMBER KIND LT:*MAPFORMS-NON-FORM-KINDS*)
		   FORM
		   (CASE (CAR FORM)
		     (%UNBOXED-INTEGER
		       ;; Found it!
		       (IF FOUND-P
			   (ERROR "Multiple unboxed-integer producing forms found")
			   (SETQ FOUND-P T))
		       (VALUES (FUNCALL CONTINUATION
					FORM LT::*MAPFORMS-LEXICAL-FUNCTION-ENVIRONMENT*)
			       T))
		     ((LET LET* FLET FLET* MULTIPLE-VALUE-BIND MACROLET PROGN)
		      ;; We only care about the value producer here, so skip over all
		      ;; the other junk
		      (LET* ((COPY (COPY-LIST FORM))
			     (LAST (LAST COPY))
			     (LAST-FORM (CAR LAST))
			     (MARK '#:MARK))
			(SETF (CAR LAST) MARK)
			(SETQ FOUND-P T)
			(VALUES
			  (LT:COPYFORMS
			    #'(LAMBDA (FORM KIND USAGE)
				(DECLARE (IGNORE KIND USAGE))
				(IF (EQ FORM MARK)
				    (VALUES (MODIFY-UNBOXED-INTEGER-INTERNAL
					      LAST-FORM CONTINUATION
					      LT::*MAPFORMS-LEXICAL-FUNCTION-ENVIRONMENT*)
					    T)
				    FORM))
			    COPY
			    :EXPAND-SUBSTS T
			    :EXPAND-ALL-MACROS T
			    :ENVIRONMENT LT::*MAPFORMS-LEXICAL-FUNCTION-ENVIRONMENT*)
			  T)))
		     (T FORM)))))
      (PROG1
	(LT:COPYFORMS #'MODIFY-INTERNAL FORM
		      :EXPAND-SUBSTS T
		      :EXPAND-ALL-MACROS T
		      :ENVIRONMENT ENVIRONMENT)
	(UNLESS FOUND-P
	  (ERROR "Could not understand the form"))))))

;;; This is the user-interface to the above.  VARS and VALS is a list of
;;; expressions of the form ((SIGN COMPONENTS) FORM).  SIGN and COMPONENTS are
;;; variables which will be bound to the SIGN and COMPONENTS of FORM in BODY.
(DEFMACRO WITH-UNBOXED-INTEGERS (VARS-AND-VALS ENVIRONMENT &BODY BODY)
  (IF (NULL VARS-AND-VALS)
      `(PROGN ,@BODY)
      (DESTRUCTURING-BIND ((SIGN COMPONENTS) INTEGER) (CAR VARS-AND-VALS)
	`(MODIFY-UNBOXED-INTEGER-INTERNAL
	   ,INTEGER
	   #'(LAMBDA (FORM ENVIRONMENT)
	       (LET* ((.VARS. (LOOP FOR VALUE IN (CDR FORM)
				    DO (IGNORE VALUE)
				    COLLECT (GENSYM)))
		      (,SIGN (CAR .VARS.))
		      (,COMPONENTS (COPY-LIST (CDR .VARS.))))
		 (LT:LET-SUBST .VARS. (CDR FORM)
			       (WITH-UNBOXED-INTEGERS ,(CDR VARS-AND-VALS)
						      ENVIRONMENT
				 ,@BODY)
			       ENVIRONMENT)))
	   ,ENVIRONMENT))))

(DEFMACRO %UNBOXED-LDB (BYTE INTEGER &ENVIRONMENT ENVIRONMENT)
  (LET* ((BYTE (EVAL BYTE ENVIRONMENT))
	 (BYTE-SIZE (BYTE-SIZE BYTE))
	 (BYTE-POSITION (BYTE-POSITION BYTE)))
    (WITH-UNBOXED-INTEGERS (((SIGN COMPONENTS) INTEGER)) ENVIRONMENT
      (FLET ((COMPONENT (N) (OR (NTH N COMPONENTS) SIGN)))
	(MULTIPLE-VALUE-BIND (START-WORD OFFSET) (FLOOR BYTE-POSITION 32.)
	  `(%POSITIVE-INTEGER
	     ,@(LOOP FOR WORD FROM START-WORD
		     FOR SIZE-LEFT DOWNFROM BYTE-SIZE BY 32. ABOVE 0
		     COLLECTING
		       (LET ((SIZE (MIN 32. SIZE-LEFT)))
			 (IF ( (+ OFFSET SIZE) 32.)
			     (IF (= SIZE 32.)
				 (COMPONENT WORD)
				 `(%LOGLDB (BYTE ,SIZE ,OFFSET) ,(COMPONENT WORD)))
			     `(%LOGDPB (%LOGLDB (BYTE ,OFFSET 0) ,(COMPONENT (1+ WORD)))
				       (BYTE ,OFFSET ,(- 32. OFFSET))
				       (%LOGLDB (BYTE ,(- 32. OFFSET) ,OFFSET)
						,(COMPONENT WORD))))))))))))

(DEFMACRO %UNBOXED-DPB (BYTE BYTE-SPEC INTEGER &ENVIRONMENT ENVIRONMENT)
  (LET* ((BYTE-SPEC (EVAL BYTE-SPEC ENVIRONMENT))
	 (BYTE-SIZE (BYTE-SIZE BYTE-SPEC))
	 (BYTE-POSITION (BYTE-POSITION BYTE-SPEC)))
    (MULTIPLE-VALUE-BIND (START-WORD OFFSET) (FLOOR BYTE-POSITION 32.)
      (WITH-UNBOXED-INTEGERS (((INTEGER-SIGN INTEGER-COMPONENTS) INTEGER)
			      ((BYTE-SIGN BYTE-COMPONENTS) BYTE))
			     ENVIRONMENT
	(LET ((FORMS))
	  (FLET ((INTEGER-COMPONENT (WORD) (OR (NTH WORD INTEGER-COMPONENTS) INTEGER-SIGN))
		 (BYTE-COMPONENT (WORD) (OR (NTH WORD BYTE-COMPONENTS) BYTE-SIGN)))
	    ;; This much stays the same
	    (LOOP FOR WORD FROM 0 BELOW START-WORD DOING
	      (PUSH (INTEGER-COMPONENT WORD) FORMS))
	    (COND (( (+ OFFSET BYTE-SIZE) 32.)
		   ;; Fits in one word, so use %LOGDPB
		   (PUSH (IF (AND (ZEROP OFFSET) (= BYTE-SIZE 32.))
			     (BYTE-COMPONENT 0)
			     `(%LOGDPB ,(BYTE-COMPONENT 0)
				       (BYTE ,BYTE-SIZE ,OFFSET)
				       ,(INTEGER-COMPONENT START-WORD)))
			 FORMS))
		  (T
		   (COND ((= OFFSET 0)
			  ;; No shifting needed
			  (LOOP FOR WORD BELOW (FLOOR BYTE-SIZE 32.) DOING
			    (PUSH (BYTE-COMPONENT WORD) FORMS)))
			 (T
			  ;; The first word must be merged with the INTEGER
			  (PUSH `(%LOGDPB ,(BYTE-COMPONENT 0) (BYTE ,(- 32. OFFSET) ,OFFSET)
					  ,(INTEGER-COMPONENT START-WORD))
				FORMS)
			  ;; The next words are shifted to the right by (- 32. OFFSET)
			  (LOOP FOR I BELOW (1- (FLOOR (- BYTE-SIZE OFFSET) 32.)) DOING
			    (PUSH
			      `(%LOGDPB (%LOGLDB (BYTE ,(- 32. OFFSET) 0)
						 ,(BYTE-COMPONENT (1+ I)))
					(BYTE ,(- 32. OFFSET) ,OFFSET)
					(%LOGLDB (BYTE ,OFFSET ,(- 32. OFFSET))
						 ,(BYTE-COMPONENT I)))
			      FORMS))))
		   ;; Now do the last word (unless we ended on a word boundary)
		   (MULTIPLE-VALUE-BIND (WORD EXTRA) (FLOOR (+ BYTE-SIZE BYTE-POSITION) 32.)
		     (UNLESS (ZEROP EXTRA)
		       (MULTIPLE-VALUE-BIND (DPB-WORD DPB-OFFSET)
			   (FLOOR (- BYTE-SIZE EXTRA) 32.)
			 (PUSH
			   `(%LOGDPB (%LOGLDB (BYTE ,EXTRA ,DPB-OFFSET)
					      ,(IF ( (+ DPB-OFFSET EXTRA) 32.)
						   (BYTE-COMPONENT DPB-WORD)
						   `(%LOGDPB (%LOGLDB (BYTE ,(- 32. OFFSET) 0)
								      ,(BYTE-COMPONENT
									 (1+ DPB-WORD)))
							     (BYTE ,(- 32. OFFSET) ,OFFSET)
							     (%LOGLDB (BYTE ,OFFSET
									    ,(- 32. OFFSET))
								      ,(BYTE-COMPONENT
									 DPB-WORD)))))
				     (BYTE ,EXTRA 0)
				     ,(INTEGER-COMPONENT WORD))
			   FORMS))))))
	    ;; Finish up what stays the same
	    (LOOP FOR WORD FROM (CEILING (+ BYTE-SIZE BYTE-POSITION) 32.)
			   BELOW (LENGTH INTEGER-COMPONENTS) DOING
	      (PUSH (INTEGER-COMPONENT WORD) FORMS))
	    `(%UNBOXED-INTEGER ,INTEGER-SIGN ,@(NREVERSE FORMS))))))))

;;; Overflow bits are lost
(DEFMACRO %UNBOXED-LEFT-SHIFT (INTEGER N-BITS &ENVIRONMENT ENVIRONMENT)
  (WITH-UNBOXED-INTEGERS (((INTEGER-SIGN INTEGER-COMPONENTS) INTEGER)) ENVIRONMENT
    `(%UNBOXED-INTEGER
       ,INTEGER-SIGN
       (LSH ,(CAR INTEGER-COMPONENTS) ,N-BITS)
       ,@(LOOP FOR (LOW HIGH) ON INTEGER-COMPONENTS
	       WHILE HIGH
	       COLLECTING
		 `(%LSHC-BIGNUM-STEP ,LOW ,HIGH ,N-BITS)))))

(DEFMACRO %UNBOXED-CONSTANT-LEFT-SHIFT (INTEGER N-BITS &ENVIRONMENT ENVIRONMENT)
  (LET ((SHIFT-AMOUNT (EVAL N-BITS ENVIRONMENT)))
    (WITH-UNBOXED-INTEGERS (((INTEGER-SIGN INTEGER-COMPONENTS) INTEGER)) ENVIRONMENT
      `(%UNBOXED-INTEGER
	 ,INTEGER-SIGN
	 (LSH ,(CAR INTEGER-COMPONENTS) ,SHIFT-AMOUNT)
	 ,@(LOOP FOR (LOW HIGH) ON INTEGER-COMPONENTS
		 WHILE HIGH
		 COLLECTING
		 `(%LOGDPB (%LOGLDB (BYTE ,(- 32. SHIFT-AMOUNT) 0) ,HIGH)
			   (BYTE ,(- 32. SHIFT-AMOUNT) ,SHIFT-AMOUNT)
			   (%LOGLDB (BYTE ,SHIFT-AMOUNT ,(- 32. SHIFT-AMOUNT)) ,LOW)))))))

;;; This is an arithmetic right shift.
(DEFMACRO %UNBOXED-RIGHT-SHIFT (INTEGER N-BITS &ENVIRONMENT ENVIRONMENT)
  (WITH-UNBOXED-INTEGERS (((INTEGER-SIGN INTEGER-COMPONENTS) INTEGER)) ENVIRONMENT
    (LET* ((SHIFT
	     (IF (NUMBERP N-BITS)
		 N-BITS
		 (GENSYM)))
	   (FORM `(%UNBOXED-INTEGER
		    ,INTEGER-SIGN
		    ,@(LOOP FOR (LOW HIGH) ON INTEGER-COMPONENTS
			    COLLECTING
			      (IF HIGH
				  `(%LSHC-BIGNUM-STEP ,LOW ,HIGH ,SHIFT)
				  (IF (EQL INTEGER-SIGN 0)
				      `(LSH ,LOW (- ,N-BITS))
				      `(%LSHC-BIGNUM-STEP ,LOW ,INTEGER-SIGN ,SHIFT)))))))
      (IF (NUMBERP SHIFT)
	  FORM
	  `(LET ((,SHIFT (- 32. ,N-BITS)))
	     ,FORM)))))

(DEFMACRO %UNBOXED-LOGIOR (INTEGER1 INTEGER2 &ENVIRONMENT ENVIRONMENT)
  (WITH-UNBOXED-INTEGERS (((SIGN1 COMPONENTS1) INTEGER1)
			  ((SIGN2 COMPONENTS2) INTEGER2))
		     ENVIRONMENT
    `(%UNBOXED-INTEGER
       (LOGIOR ,SIGN1 ,SIGN2)
       ,@(LOOP WITH RESULT = NIL
	       FOR PLACE1 FIRST COMPONENTS1 THEN (CDR PLACE1)
	       FOR PLACE2 FIRST COMPONENTS2 THEN (CDR PLACE2)
	       WHILE (AND PLACE1 PLACE2)
	       DO (PUSH `(LOGIOR ,(CAR PLACE1) ,(CAR PLACE2)) RESULT)
	       FINALLY
		 (IF PLACE1
		     (COND ((EQL SIGN2 0)
			    (DOLIST (COMPONENT PLACE1)
			      (PUSH COMPONENT RESULT)))
			   ((EQL SIGN2 -1))
			   (T (DOLIST (COMPONENT PLACE1)
				(PUSH `(LOGIOR ,COMPONENT ,SIGN2) RESULT))))
		     (WHEN PLACE2
		       (COND ((EQL SIGN1 0)
			      (DOLIST (COMPONENT PLACE2)
				(PUSH COMPONENT RESULT)))
			     ((EQL SIGN1 -1))
			     (T (DOLIST (COMPONENT PLACE2)
				  (PUSH `(LOGIOR ,COMPONENT ,SIGN2) RESULT))))))
		 (RETURN (REVERSE RESULT))))))

;;; Double float implementation
(DEFMACRO %UNBOXED-ZEROP (INTEGER &ENVIRONMENT ENVIRONMENT)
  (WITH-UNBOXED-INTEGERS (((SIGN COMPONENTS) INTEGER)) ENVIRONMENT
    `(AND (ZEROP ,SIGN) ,@(MAPCAR #'(LAMBDA (COMPONENT) `(ZEROP ,COMPONENT)) COMPONENTS))))

(DEFMACRO SINGLE-FLOAT-HANDLE-EXCEPTIONS ((FUNCTION &REST OPERANDS) &BODY BODY)
  `(MULTIPLE-VALUE-BIND (NON-TRAP-RESULT SIGN FRAC EXPONENT)
       (PROGN ,@BODY)
     (LET* ((OLD-STATUS FLOAT-OPERATION-STATUS)
	    (SIGNALS
	      ,(IF (MEMBER FUNCTION '(+ -))
		   `(DPB 0 (BYTE 1 (- (BYTE-POSITION %%FLOAT-SIGNAL-UNDERFLOW)
				      (BYTE-POSITION %%FLOAT-SIGNAL-BITS)))
			 (LDB %%FLOAT-SIGNAL-BITS OLD-STATUS))
		   `(LDB %%FLOAT-SIGNAL-BITS OLD-STATUS)))
	    (TRAPS (LOGAND (ROT SIGNALS (BYTE-POSITION %%FLOAT-TRAP-ENABLES))
			   FLOAT-OPERATING-MODE)))
       (SETF FLOAT-OPERATION-STATUS
	     (LOGIOR OLD-STATUS (ROT SIGNALS (BYTE-POSITION %%FLOAT-FLAG-BITS))))
       (IF (ZEROP TRAPS)
	   (%FLONUM NON-TRAP-RESULT)
	   (SIGNAL-SINGLE-FLOAT-TRAP
	     TRAPS ',FUNCTION (%FLONUM NON-TRAP-RESULT) SIGN FRAC EXPONENT ,@OPERANDS)))))

(DEFUN SIGNAL-SINGLE-FLOAT-TRAP
       (TRAPS FUNCTION NON-TRAP-RESULT SIGN FRAC EXPONENT &REST OPERANDS)
  (DECLARE (IGNORE SIGN FRAC EXPONENT))
  (COND ((LDB-TEST %%FLOAT-TRAP-ENABLE-OVERFLOW TRAPS)
	 (APPLY #'SIGNAL-SINGLE-FLOAT-OVERFLOW
		FUNCTION NON-TRAP-RESULT OPERANDS))
	((LDB-TEST %%FLOAT-TRAP-ENABLE-UNDERFLOW TRAPS)
	 (APPLY #'SIGNAL-SINGLE-FLOAT-UNDERFLOW
		FUNCTION NON-TRAP-RESULT OPERANDS))
	((LDB-TEST %%FLOAT-TRAP-ENABLE-INEXACT-RESULT TRAPS)
	 (APPLY #'SIGNAL-SINGLE-FLOAT-INEXACT-RESULT FUNCTION NON-TRAP-RESULT OPERANDS))
	((LDB-TEST %%FLOAT-TRAP-ENABLE-INVALID-OPERATION TRAPS)
	 (APPLY #'SIGNAL-SINGLE-FLOAT-INVALID-OPERATION FUNCTION NON-TRAP-RESULT OPERANDS))
	((LDB-TEST %%FLOAT-TRAP-ENABLE-DIVISION-BY-ZERO TRAPS)
	 (APPLY #'SIGNAL-SINGLE-FLOAT-DIVISION-BY-ZERO FUNCTION NON-TRAP-RESULT OPERANDS))))

(DEFUN SIGNAL-SINGLE-FLOAT-OVERFLOW (FUNCTION NON-TRAP-RESULT &REST OPERANDS)
  (DECLARE (DBG:ERROR-REPORTER))
  (IF (SI:FLOAT-TRAP-ENABLE? :OVERFLOW)
      (SIGNAL-PROCEED-CASE ((VALUE)
			    'FLOATING-EXPONENT-OVERFLOW
			    ':FUNCTION FUNCTION
			    ':OPERATION FUNCTION
			    ':OPERANDS (COPY-LIST OPERANDS)
			    ':NON-TRAP-RESULT NON-TRAP-RESULT
			    ':SAVED-FLOAT-OPERATION-STATUS (FLOAT-OPERATION-STATUS))
	(:USE-NON-TRAP-RESULT VALUE)
	(:NEW-VALUE VALUE))
      NON-TRAP-RESULT))

(DEFUN SIGNAL-SINGLE-FLOAT-UNDERFLOW (FUNCTION NON-TRAP-RESULT &REST OPERANDS)
  (DECLARE (DBG:ERROR-REPORTER))
  (IF (SI:FLOAT-TRAP-ENABLE? :UNDERFLOW)
      (SIGNAL-PROCEED-CASE ((VALUE)
			    'FLOATING-EXPONENT-UNDERFLOW
			    ':FUNCTION FUNCTION
			    ':OPERATION FUNCTION
			    ':OPERANDS (COPY-LIST OPERANDS)
			    ':NON-TRAP-RESULT NON-TRAP-RESULT
			    ':SAVED-FLOAT-OPERATION-STATUS (FLOAT-OPERATION-STATUS))
	(:USE-NON-TRAP-RESULT VALUE)
	(:USE-ZERO VALUE)
	(:NEW-VALUE VALUE))
      NON-TRAP-RESULT))

(DEFUN SIGNAL-SINGLE-FLOAT-INEXACT-RESULT (FUNCTION NON-TRAP-RESULT &REST OPERANDS)
  (DECLARE (DBG:ERROR-REPORTER))
  (IF (SI:FLOAT-TRAP-ENABLE? :INEXACT-RESULT)
      (SIGNAL-PROCEED-CASE ((VALUE)
			    'FLOAT-INEXACT-RESULT
			    ':OPERATION FUNCTION
			    ':OPERANDS (COPY-LIST OPERANDS)
			    ':NON-TRAP-RESULT NON-TRAP-RESULT
			    ':SAVED-FLOAT-OPERATION-STATUS (FLOAT-OPERATION-STATUS))
	(:USE-NON-TRAP-RESULT VALUE)
	(:USE-ZERO VALUE)
	(:NEW-VALUE VALUE))
      NON-TRAP-RESULT))

(DEFUN SIGNAL-SINGLE-FLOAT-DIVISION-BY-ZERO (FUNCTION NON-TRAP-RESULT OP1 OP2)
  (DECLARE (DBG:ERROR-REPORTER))
  (IF (SI:FLOAT-TRAP-ENABLE? :DIVISION-BY-ZERO)
      (SIGNAL-PROCEED-CASE ((VALUE)
			    'FLOAT-DIVIDE-BY-ZERO
			    ':OPERATION FUNCTION
			    ':OPERANDS (LIST OP1 OP2)
			    ':NON-TRAP-RESULT NON-TRAP-RESULT
			    ':SAVED-FLOAT-OPERATION-STATUS (FLOAT-OPERATION-STATUS))
	(:USE-NON-TRAP-RESULT VALUE)
	(:NEW-VALUE VALUE))
      NON-TRAP-RESULT))

(DEFUN SIGNAL-SINGLE-FLOAT-INVALID-OPERATION (FUNCTION NON-TRAP-RESULT &REST OPERANDS)
  (DECLARE (DBG:ERROR-REPORTER))
  (IF (SI:FLOAT-TRAP-ENABLE? :INVALID-OPERATION)
      (SIGNAL-PROCEED-CASE ((VALUE)
			    'FLOAT-INVALID-OPERATION
			    ':OPERATION FUNCTION
			    ':OPERANDS (COPY-LIST OPERANDS)
			    ':NON-TRAP-RESULT NON-TRAP-RESULT
			    ':SAVED-FLOAT-OPERATION-STATUS (FLOAT-OPERATION-STATUS))
	(:USE-NON-TRAP-RESULT VALUE)
	(:NEW-VALUE VALUE))
      NON-TRAP-RESULT))

(DEFUN FLOAT-INVALID-OPERATION (FUNCTION OPERANDS &OPTIONAL (SIGN 0))
  (DECLARE (DBG:ERROR-REPORTER))
  (LET ((NON-TRAP-RESULT (%FLONUM (%LOGDPB #.(DPB %SINGLE-EXPONENT-MAX %%SINGLE-EXPONENT -1)
					   %%SINGLE-EXCEPT-SIGN SIGN))))
    (COND ((SI:FLOAT-TRAP-ENABLE? :INVALID-OPERATION)
	   (APPLY #'SIGNAL-SINGLE-FLOAT-INVALID-OPERATION FUNCTION NON-TRAP-RESULT OPERANDS))
	  (T 
	   (SI:FLOAT-SET-FLAG :INVALID-OPERATION)
	   NON-TRAP-RESULT))))

(DEFMACRO DOUBLE-FLOAT-HANDLE-EXCEPTIONS ((FUNCTION &REST OPERANDS) &BODY BODY)
  `(MULTIPLE-VALUE-BIND
     (NON-TRAP-RESULT-HIGH NON-TRAP-RESULT-LOW SIGN FRAC-HIGH FRAC-LOW EXPONENT)
       (PROGN ,@BODY)
     (LET* ((OLD-STATUS FLOAT-OPERATION-STATUS)
	    (SIGNALS
	      ,(IF (MEMBER FUNCTION '(%DOUBLE-FLOATING-ADD
				      %DOUBLE-FLOATING-SUB
				      + -))
		   `(DPB 0 (BYTE 1 (- (BYTE-POSITION %%FLOAT-SIGNAL-UNDERFLOW)
				      (BYTE-POSITION %%FLOAT-SIGNAL-BITS)))
			 (LDB %%FLOAT-SIGNAL-BITS OLD-STATUS))
		   `(LDB %%FLOAT-SIGNAL-BITS OLD-STATUS)))
	    (TRAPS (LOGAND (ROT SIGNALS (BYTE-POSITION %%FLOAT-TRAP-ENABLES))
			   FLOAT-OPERATING-MODE)))
       (SETF FLOAT-OPERATION-STATUS
	     (LOGIOR OLD-STATUS (ROT SIGNALS (BYTE-POSITION %%FLOAT-FLAG-BITS))))
       (IF (ZEROP TRAPS)
	   (VALUES NON-TRAP-RESULT-HIGH NON-TRAP-RESULT-LOW)
	   (SIGNAL-DOUBLE-FLOAT-TRAP
	     TRAPS ',FUNCTION NON-TRAP-RESULT-HIGH NON-TRAP-RESULT-LOW
	     SIGN FRAC-HIGH FRAC-LOW EXPONENT ,@OPERANDS)))))

(DEFUN SIGNAL-DOUBLE-FLOAT-TRAP
       (TRAPS FUNCTION NON-TRAP-RESULT-HIGH NON-TRAP-RESULT-LOW
	SIGN FRAC-HIGH FRAC-LOW EXPONENT &REST OPERANDS)
  (DECLARE (IGNORE SIGN FRAC-HIGH FRAC-LOW EXPONENT))
  (COND ((LDB-TEST %%FLOAT-TRAP-ENABLE-OVERFLOW TRAPS)
	 (APPLY #'SIGNAL-DOUBLE-FLOAT-OVERFLOW
		FUNCTION NON-TRAP-RESULT-HIGH NON-TRAP-RESULT-LOW OPERANDS))
	((LDB-TEST %%FLOAT-TRAP-ENABLE-UNDERFLOW TRAPS)
	 (APPLY #'SIGNAL-DOUBLE-FLOAT-UNDERFLOW
		FUNCTION NON-TRAP-RESULT-HIGH NON-TRAP-RESULT-LOW OPERANDS))
	((LDB-TEST %%FLOAT-TRAP-ENABLE-INEXACT-RESULT TRAPS)
	 (APPLY #'SIGNAL-DOUBLE-FLOAT-INEXACT-RESULT FUNCTION
		NON-TRAP-RESULT-HIGH NON-TRAP-RESULT-LOW OPERANDS))
	((LDB-TEST %%FLOAT-TRAP-ENABLE-INVALID-OPERATION TRAPS)
	 (APPLY #'SIGNAL-DOUBLE-FLOAT-INVALID-OPERATION FUNCTION
		NON-TRAP-RESULT-HIGH NON-TRAP-RESULT-LOW OPERANDS))
	((LDB-TEST %%FLOAT-TRAP-ENABLE-DIVISION-BY-ZERO TRAPS)
	 (APPLY #'SIGNAL-DOUBLE-FLOAT-DIVISION-BY-ZERO FUNCTION
		NON-TRAP-RESULT-HIGH NON-TRAP-RESULT-LOW OPERANDS))))

(DEFUN SIGNAL-DOUBLE-FLOAT-OVERFLOW
       (FUNCTION NON-TRAP-RESULT-HIGH NON-TRAP-RESULT-LOW &REST OPERANDS)
  (DECLARE (DBG:ERROR-REPORTER))
  (IF (SI:FLOAT-TRAP-ENABLE? :OVERFLOW)
      (SI:DFLOAT-COMPONENTS
	(SIGNAL-PROCEED-CASE ((VALUE)
			      'FLOATING-EXPONENT-OVERFLOW
			      ':FUNCTION FUNCTION
			      ':OPERATION FUNCTION
			      ':OPERANDS (COPY-LIST OPERANDS)
			      ':NON-TRAP-RESULT
			      (SI:%MAKE-DOUBLE NON-TRAP-RESULT-HIGH NON-TRAP-RESULT-LOW)
			      ':SAVED-FLOAT-OPERATION-STATUS (FLOAT-OPERATION-STATUS))
	  (:USE-NON-TRAP-RESULT VALUE)
	  (:NEW-VALUE VALUE)))
      (VALUES NON-TRAP-RESULT-HIGH NON-TRAP-RESULT-LOW)))

(DEFUN SIGNAL-DOUBLE-FLOAT-UNDERFLOW
       (FUNCTION NON-TRAP-RESULT-HIGH NON-TRAP-RESULT-LOW &REST OPERANDS)
  (DECLARE (DBG:ERROR-REPORTER))
  (IF (SI:FLOAT-TRAP-ENABLE? :UNDERFLOW)
      (SI:DFLOAT-COMPONENTS
	(SIGNAL-PROCEED-CASE ((VALUE)
			      'FLOATING-EXPONENT-UNDERFLOW
			      ':FUNCTION FUNCTION
			      ':OPERATION FUNCTION
			      ':OPERANDS (COPY-LIST OPERANDS)
			      ':NON-TRAP-RESULT
			      (SI:%MAKE-DOUBLE NON-TRAP-RESULT-HIGH NON-TRAP-RESULT-LOW)
			      ':SAVED-FLOAT-OPERATION-STATUS (FLOAT-OPERATION-STATUS))
	  (:USE-NON-TRAP-RESULT VALUE)
	  (:USE-ZERO VALUE)
	  (:NEW-VALUE VALUE)))
      (VALUES NON-TRAP-RESULT-HIGH NON-TRAP-RESULT-LOW)))

(DEFUN SIGNAL-DOUBLE-FLOAT-INEXACT-RESULT
       (FUNCTION NON-TRAP-RESULT-HIGH NON-TRAP-RESULT-LOW &REST OPERANDS)
  (DECLARE (DBG:ERROR-REPORTER))
  (IF (SI:FLOAT-TRAP-ENABLE? :INEXACT-RESULT)
      (SI:DFLOAT-COMPONENTS
	(SIGNAL-PROCEED-CASE ((VALUE)
			      'FLOAT-INEXACT-RESULT
			      ':OPERATION FUNCTION
			      ':OPERANDS (COPY-LIST OPERANDS)
			      ':NON-TRAP-RESULT
			      (SI:%MAKE-DOUBLE NON-TRAP-RESULT-HIGH NON-TRAP-RESULT-LOW)
			      ':SAVED-FLOAT-OPERATION-STATUS (FLOAT-OPERATION-STATUS))
	  (:USE-NON-TRAP-RESULT VALUE)
	  (:USE-ZERO VALUE)
	  (:NEW-VALUE VALUE)))
      (VALUES NON-TRAP-RESULT-HIGH NON-TRAP-RESULT-LOW)))

(DEFUN SIGNAL-DOUBLE-FLOAT-DIVISION-BY-ZERO
       (FUNCTION NON-TRAP-RESULT-HIGH NON-TRAP-RESULT-LOW OP1-HIGH OP1-LOW OP2-HIGH OP2-LOW)
  (DECLARE (DBG:ERROR-REPORTER))
  (IF (SI:FLOAT-TRAP-ENABLE? :DIVISION-BY-ZERO)
      (SI:DFLOAT-COMPONENTS
	(SIGNAL-PROCEED-CASE ((VALUE)
			      'FLOAT-DIVIDE-BY-ZERO
			      ':OPERATION FUNCTION
			      ':OPERANDS (LIST OP1-HIGH OP1-LOW OP2-HIGH OP2-LOW)
			      ':NON-TRAP-RESULT
			      (SI:%MAKE-DOUBLE NON-TRAP-RESULT-HIGH NON-TRAP-RESULT-LOW)
			      ':SAVED-FLOAT-OPERATION-STATUS (FLOAT-OPERATION-STATUS))
	  (:USE-NON-TRAP-RESULT VALUE)
	  (:NEW-VALUE VALUE)))
      (VALUES NON-TRAP-RESULT-HIGH NON-TRAP-RESULT-LOW)))

(DEFUN SIGNAL-DOUBLE-FLOAT-INVALID-OPERATION
       (FUNCTION NON-TRAP-RESULT-HIGH NON-TRAP-RESULT-LOW &REST OPERANDS)
  (DECLARE (DBG:ERROR-REPORTER))
  (IF (SI:FLOAT-TRAP-ENABLE? :INVALID-OPERATION)
      (SI:DFLOAT-COMPONENTS
	(SIGNAL-PROCEED-CASE ((VALUE)
			      'FLOAT-INVALID-OPERATION
			      ':OPERATION FUNCTION
			      ':OPERANDS (COPY-LIST OPERANDS)
			      ':NON-TRAP-RESULT
			      (SI:%MAKE-DOUBLE NON-TRAP-RESULT-HIGH NON-TRAP-RESULT-LOW)
			      ':SAVED-FLOAT-OPERATION-STATUS (FLOAT-OPERATION-STATUS))
	  (:USE-NON-TRAP-RESULT VALUE)
	  (:NEW-VALUE VALUE)))
      (VALUES NON-TRAP-RESULT-HIGH NON-TRAP-RESULT-LOW)))		    

(DEFUN SI:DOUBLE-INVALID-OPERATION (FUNCTION OPERANDS &OPTIONAL (SIGN 0))
  (DECLARE (DBG:ERROR-REPORTER))
  (LET ((NON-TRAP-RESULT-HIGH (%LOGDPBS SIGN %%DOUBLE-SIGN
					%DOUBLE-EXPONENT-MAX %%DOUBLE-EXPONENT
					-1))
	(NON-TRAP-RESULT-LOW -1))
    (COND ((SI:FLOAT-TRAP-ENABLE? :INVALID-OPERATION)
	   (APPLY #'SIGNAL-DOUBLE-FLOAT-INVALID-OPERATION FUNCTION
		  NON-TRAP-RESULT-HIGH NON-TRAP-RESULT-LOW OPERANDS))
	  (T 
	   (SI:FLOAT-SET-FLAG :INVALID-OPERATION)
	   (VALUES NON-TRAP-RESULT-HIGH NON-TRAP-RESULT-LOW)))))

;;; Denormalized number representation:
;;;
;;; The description of the IEEE standard is not entirely explicit on
;;; this, so I'll make it entirely explicit.  Consider the minimum
;;; normalized number in -single- representation, #o40000000
;;; (1.1754943505e-38). This has expt 1 and frac (1).000...00.  The next
;;; smaller representable number would want expt 1 and frac
;;; (0).111...11; but this is not normalized, so normalize it to expt 0
;;; frac (1).111...10; but this has expt zero, so we introduce the
;;; denormalization discontinuity: expt 0 frac (0).111...11 represents
;;; the "true" number expt 0 frac (1).111...10 alternatively represented
;;; as unnormalized expt 1 frac (0).111...11

;;; Structure of "single" floating-point numbers (IEEE single-basic)
;;; |1|--8---|-----23------|
;;; |S| expt | frac        |
;;;  31<30:23>---<22:0>----

;;; Conventions
;;; 
;;; BIASED-EXPT:  The exponent with the bias
;;; EXPT:  Biasing is optional
;;; SIGN:  1 means negattive, 0 means positive or 0
;;; FRAC:  A fraction in internal form.
;;;
;;; "Internal Format" of single precision floating point fractions:
;;;
;;; We use the same format that the L machine's microcode uses.  The internal
;;; representation includes the high 1 bit which is hidden in IEEE floating point.
;;; For a normalized fraction, this bit is in the N position.  The next higher order
;;; bit is V, which is 1 if a simple overflow occurs.  The 23 bits below N are the
;;; fraction from the IEEE float, the low order bit of these being called L.  Next
;;; lower is G, the guard bit, R, the rounding bit, and S, the "sticky" bit, which is
;;; the OR of all lower ordered bits in the exact representation.

;;; Structure of internal significand ("frac")
;;; ...       -----23---- --3--
;;; ... V N . xxxxxxxxxxL G R S
;;; ...2726   --<25:3>--- 2 1 0

(EVAL-WHEN (COMPILE LOAD EVAL)
(DEFSYSBYTE %%FRAC-S-BIT 1 0)
(DEFSYSBYTE %%FRAC-GRS 3 0)
(DEFSYSBYTE %%FRAC-ROUND-DISPATCH 4 0)		;LGRS
(DEFSYSBYTE %%FRAC-L-BIT 1 3)
(DEFSYSBYTE %%FRAC-FIELD 23. 3)
(DEFSYSBYTE %%FRAC-FIELD+N-BIT 24. 3)
(DEFSYSBYTE %%FRAC-N+FIELD+GR 26. 1.)
(DEFSYSBYTE %%FRAC-N+FIELD+GRS 27. 0.)
(DEFSYSBYTE %%FRAC-NORMALIZE-DISPATCH 4 23.)	;highest bit is N
(DEFSYSBYTE %%FRAC-N-BIT 1 26.)
(DEFSYSBYTE %%FRAC-V-BIT 1 27.)
);End EVAL-WHEN

;;; WORD is %FIXNUM'd single float, and BIASED-EXPT is the biased
;;; exponent from that word.  This returns the normalized fraction in
;;; internal format.
(DEFSUBST SINGLE-FLOAT-FRAC-AND-EXPONENT
	  (WORD &OPTIONAL (BIASED-EXPT (%LOGLDB %%SINGLE-EXPONENT WORD)))
  (IF (ZEROP BIASED-EXPT)
      (NORMALIZE-INTERNAL-FRACTION
	;; Denormalized, so exponent is off by one.  Shift fraction to get the
	;; exponent in agreement
	(ROT (%LOGLDB %%SINGLE-FRACTION WORD)
	     (1+ (- (BYTE-POSITION %%FRAC-FIELD )
		    (BYTE-POSITION %%SINGLE-FRACTION))))
	0)
      (VALUES
	(%LOGDPB 1 %%FRAC-N-BIT
		 (ROT (%LOGLDB %%SINGLE-FRACTION WORD)
		      (- (BYTE-POSITION %%FRAC-FIELD )
			 (BYTE-POSITION %%SINGLE-FRACTION))))
	BIASED-EXPT)))

;;; Shift the fraction to the right by (- LEFT-SHIFT-AMOUNT)
(DEFSUBST STICKY-RIGHT-SHIFT (FRAC LEFT-SHIFT-AMOUNT)
  (IF (< LEFT-SHIFT-AMOUNT -31.)
      ;; Going off the end.  Know that S bit is low-order, FRAC non-negative
      (%LOGLDB (BYTE 1. 31.) (- FRAC))
      (DPB (%LOGLDB (BYTE 1 31.) (- (LOGAND (LSH -1 (- -31. LEFT-SHIFT-AMOUNT)) FRAC)))
	   %%FRAC-S-BIT
	   (LSH FRAC LEFT-SHIFT-AMOUNT))))

;;; This assumes that S is 0 and that FRAC is not overflown
;;; This works by shifting the fraction to the left by an amount determined by
;;; "dispatching" off the high three bits of the frac-field
(DEFUN NORMALIZE-INTERNAL-FRACTION (FRAC BIASED-EXPT)
  (DECLARE (SAFEGUARDED-FUNCTION)
	   (VALUES FRAC BIASED-EXPT))
  (LOOP DOING
    (UNLESS (ZEROP (%LOGLDB %%FRAC-N-BIT FRAC))
      (RETURN-FROM NORMALIZE-INTERNAL-FRACTION (VALUES FRAC BIASED-EXPT)))
    (LET ((SHIFT-AMOUNT
	    (1+
	      (%LOGLDB (BYTE 2. 6.)
		       (ROT #b11100101		;"Dispatch" shift amounts, -1
			    (ROT
			      (%LOGLDB (BYTE 3.
					     (- (+ (BYTE-POSITION %%FRAC-FIELD)
						   (BYTE-SIZE %%FRAC-FIELD))
						3))
				       FRAC)
			      1))))))
      (UNLESS (= SHIFT-AMOUNT 4)
	(RETURN-FROM NORMALIZE-INTERNAL-FRACTION
	  (VALUES (ROT FRAC SHIFT-AMOUNT)
		  (- BIASED-EXPT SHIFT-AMOUNT))))
      (SETQ FRAC (ROT FRAC SHIFT-AMOUNT))
      (DECF BIASED-EXPT SHIFT-AMOUNT))))

;;; Quick version for clearing overflows
(DEFMACRO NORMALIZE-FOR-OVERFLOW (FRAC EXPT)
  `(UNLESS (ZEROP (%LOGLDB %%FRAC-V-BIT ,FRAC))
     (INCF ,EXPT)
     (SETQ ,FRAC
	   (LOGIOR (%LOGLDB (BYTE 31. 1.) ,FRAC)
		   (%LOGLDB %%FRAC-S-BIT ,FRAC)))))

;;; Assumes everything is checked for overflow, underflow, etc.
(DEFSUBST MAKE-SINGLE-FLOAT (SIGN FRAC BIASED-EXPT)
  (%LOGDPB SIGN %%SINGLE-SIGN
	   (%LOGDPB BIASED-EXPT %%SINGLE-EXPONENT
		    (%LOGLDB %%FRAC-FIELD FRAC))))

;;; WRAPPED-RESULT is a normalized float with the exponent a twos complement biased
;;; exponent.  Rounding can turn the denormalized number back into a normalized
;;; number.
(DEFUN SINGLE-FLOAT-DENORMALIZE (WRAPPED-RESULT)
  (DECLARE (VALUES RESULT DENORMALIZED-P))
  (LET* ((SIGN (%LOGLDB %%SINGLE-SIGN WRAPPED-RESULT))
	 (WRAPPED-EXPONENT (%LOGLDB %%SINGLE-EXPONENT WRAPPED-RESULT))
	 (EXPT (%LOGDPB (- (LDB (BYTE 1. 7.) WRAPPED-EXPONENT))
			(BYTE 24. 8.) WRAPPED-EXPONENT))
	 (FRAC (%LOGDPB 1 %%FRAC-N-BIT
			(ROT (%LOGLDB %%SINGLE-FRACTION WRAPPED-RESULT)
			     (- (BYTE-POSITION %%FRAC-FIELD )
				(BYTE-POSITION %%SINGLE-FRACTION))))))
    (MULTIPLE-VALUE-BIND (FRAC EXPT)
	(SINGLE-FLOAT-ROUND SIGN (STICKY-RIGHT-SHIFT FRAC (- EXPT 1)) 0)
      (%FLONUM (MAKE-SINGLE-FLOAT SIGN FRAC EXPT)))))

(DEFUN SINGLE-FLOAT-OVERFLOW-VALUE (SIGN)
  (SELECT (LDB %%FLOAT-ROUNDING-MODE FLOAT-OPERATING-MODE)
    (%FLOAT-ROUNDING-MODE-NEAREST
     (IF (ZEROP SIGN)
	 SI:INFINITE-POSITIVE-SINGLE-FLOAT
	 SI:INFINITE-NEGATIVE-SINGLE-FLOAT))
    (%FLOAT-ROUNDING-MODE-PLUS
     (IF (ZEROP SIGN)
	 SI:INFINITE-POSITIVE-SINGLE-FLOAT
	 SI:MOST-NEGATIVE-SINGLE-FLOAT))
    (%FLOAT-ROUNDING-MODE-MINUS
     (IF (ZEROP SIGN)
	 SI:MOST-POSITIVE-SINGLE-FLOAT
	 SI:INFINITE-NEGATIVE-SINGLE-FLOAT))
    (OTHERWISE
     (IF (ZEROP SIGN)
	 SI:MOST-POSITIVE-SINGLE-FLOAT
	 SI:MOST-NEGATIVE-SINGLE-FLOAT))))

(DEFUN SINGLE-FLOAT-ROUND (SIGN FRAC EXPT)
  (DECLARE (SAFEGUARDED-FUNCTION)
	   (VALUES FRAC EXPT INEXACT))
  (LET* ((GRS (LDB %%FRAC-GRS FRAC))
	 (ROUND-FRAC (- FRAC GRS)))
    (WHEN (ZEROP GRS)
      ;; Easy case -- We're already exact
      (RETURN-FROM SINGLE-FLOAT-ROUND (VALUES ROUND-FRAC EXPT NIL)))
    (LET* ((MODE FLOAT-OPERATING-MODE)
	   (ROUNDING-MODE (%LOGLDB %%FLOAT-ROUNDING-MODE MODE)))
      (WHEN (OR (AND (= ROUNDING-MODE %FLOAT-ROUNDING-MODE-NEAREST)
		     (OR ( GRS #B011)
			 (= (LDB %%FRAC-ROUND-DISPATCH FRAC) #B0100)))
		(= ROUNDING-MODE %FLOAT-ROUNDING-MODE-ZERO)
		(AND (= ROUNDING-MODE %FLOAT-ROUNDING-MODE-PLUS)
		     (NOT (ZEROP SIGN)))
		(AND (= ROUNDING-MODE %FLOAT-ROUNDING-MODE-MINUS)
		     (ZEROP SIGN)))
	;; Close enough for government work
	(RETURN-FROM SINGLE-FLOAT-ROUND (VALUES ROUND-FRAC EXPT T)))
      ;; Have to increment the fraction
      (LET ((FRAC (+ ROUND-FRAC (DPB 1 %%FRAC-L-BIT 0))))
	;; Check for overflow into the V bit.  If this occurred, then the lower order
	;; bits must be 0, so nothing will be shifted back into the GRS bits.
	;; Use zero-test of frac-field for overflow test, so that both normalized
	;; and denormalized numbers will test correctly
	(IF (NOT (ZEROP (%LOGLDB %%FRAC-FIELD FRAC)))
	    (VALUES FRAC EXPT T)
	    ;;FRAC is zero, so doesn't need to be shifted
	    (VALUES FRAC (1+ EXPT) T))))))

(DEFUN SINGLE-FLOAT-UNWRAP (RESULT INEXACT-P)
  (LET ((SIGN (%LOGLDB %%SINGLE-SIGN RESULT)))
    (DECLARE (SPECIAL ZL:ZUNDERFLOW))
    (WHEN ZL:ZUNDERFLOW
      (SETF FLOAT-OPERATION-STATUS
	    (LOGIOR FLOAT-OPERATION-STATUS
		    (%LOGDPBS 1 %%FLOAT-SIGNAL-UNDERFLOW
			      1 %%FLOAT-SIGNAL-INEXACT-RESULT
			      0)))
      (RETURN-FROM SINGLE-FLOAT-UNWRAP
	(MAKE-SINGLE-FLOAT SIGN 0 0)))
    (LET* ((MODE FLOAT-OPERATING-MODE)
	   (EXPONENT (%LOGLDB %%SINGLE-EXPONENT RESULT))
	   (FINAL-EXPT (%LOGDPB (- (LDB (BYTE 1. 7.) EXPONENT)) (BYTE 24. 8.) EXPONENT))
	   (FINAL-FRAC (%LOGDPBS (IF (AND INEXACT-P
					  (= (LDB %%FLOAT-ROUNDING-MODE MODE)
					     %FLOAT-ROUNDING-MODE-NEAREST))
				     1
				     0)
				 %%FRAC-S-BIT
				 1 %%FRAC-N-BIT
				 (ROT (%LOGLDB %%SINGLE-FRACTION RESULT)
				      (- (BYTE-POSITION %%FRAC-FIELD )
					 (BYTE-POSITION %%SINGLE-FRACTION))))))
      (MULTIPLE-VALUE-BIND (ROUNDED-FRAC ROUNDED-EXPT INEXACT)
	  (SINGLE-FLOAT-ROUND SIGN (STICKY-RIGHT-SHIFT FINAL-FRAC (1- FINAL-EXPT)) 0)
	(IF (LDB-TEST %%FLOAT-TRAP-ENABLE-UNDERFLOW MODE)
	    (SETQ FLOAT-OPERATION-STATUS
		  (LOGIOR FLOAT-OPERATION-STATUS
			  (IF (OR INEXACT INEXACT-P)
			      (%LOGDPBS 1 %%FLOAT-SIGNAL-UNDERFLOW
					1 %%FLOAT-SIGNAL-INEXACT-RESULT 0)
			      (%LOGDPBS 1 %%FLOAT-SIGNAL-UNDERFLOW
					0 %%FLOAT-SIGNAL-INEXACT-RESULT 0))))
	    (WHEN (OR INEXACT INEXACT-P)
	      (SETQ FLOAT-OPERATION-STATUS
		    (LOGIOR FLOAT-OPERATION-STATUS
			    (%LOGDPBS 1 %%FLOAT-SIGNAL-UNDERFLOW
				      1 %%FLOAT-SIGNAL-INEXACT-RESULT 0)))))
	(VALUES
	  (MAKE-SINGLE-FLOAT SIGN ROUNDED-FRAC ROUNDED-EXPT)
	  SIGN FINAL-FRAC FINAL-EXPT)))))

(DEFUN SINGLE-FLOAT-NORMALIZE (SIGN FRAC EXPT)
  ;; Only the path for multiplying well-formed single-floats must be safeguarded
  (DECLARE (SAFEGUARDED-FUNCTION)
	   (UNSAFEGUARDED-REFERENCE SINGLE-FLOAT-OVERFLOW-VALUE ZL:ZUNDERFLOW))
  (DECLARE (SPECIAL ZL:ZUNDERFLOW))
  (WHEN (ZEROP FRAC)
    (RETURN-FROM SINGLE-FLOAT-NORMALIZE (MAKE-SINGLE-FLOAT SIGN 0 0)))
  (LET* ((SHIFT-AMOUNT
	   ;; Find out how many bits we'll need to shift FRAC by to get it normalized
	   (LOOP WITH SHIFT-MASK = #B00111010010101010000000000000000
		 FOR BITS-ROT FIRST (ROT FRAC (- (+ (BYTE-POSITION %%FRAC-N-BIT)
						    (BYTE-SIZE %%FRAC-N-BIT)
						    -4.)))
			      THEN (ROT BITS-ROT 4.)
		 FOR SHIFT FROM 0 BY 4
		 DOING
	     (LET ((BITS (LOGAND BITS-ROT #O17)))
	       (UNLESS (ZEROP BITS)
		 (RETURN (+ SHIFT (%LOGLDB (BYTE 2. 30.) (ROT SHIFT-MASK (ROT BITS 1)))))))))
	 (FINAL-FRAC (ROT FRAC SHIFT-AMOUNT))
	 (FINAL-EXPT (- EXPT SHIFT-AMOUNT)))
    (IF (PLUSP FINAL-EXPT)
	(MULTIPLE-VALUE-BIND (FRAC EXPT INEXACT)
	    (SINGLE-FLOAT-ROUND SIGN FINAL-FRAC FINAL-EXPT)
	  (COND (( EXPT %SINGLE-EXPONENT-MAX)
		 (SETF FLOAT-OPERATION-STATUS
		       (LOGIOR FLOAT-OPERATION-STATUS
			       (%LOGDPBS 1 %%FLOAT-SIGNAL-OVERFLOW
					 1 %%FLOAT-SIGNAL-INEXACT-RESULT
					 0)))
		 (VALUES (SINGLE-FLOAT-OVERFLOW-VALUE SIGN) SIGN FRAC EXPT))
		(T
		 (WHEN INEXACT
		   (SETF (LDB-TEST %%FLOAT-SIGNAL-INEXACT-RESULT FLOAT-OPERATION-STATUS) T))
		 (MAKE-SINGLE-FLOAT SIGN FRAC EXPT))))
	(COND (ZL:ZUNDERFLOW
	       (SETF FLOAT-OPERATION-STATUS
		       (LOGIOR FLOAT-OPERATION-STATUS
			       (%LOGDPBS 1 %%FLOAT-SIGNAL-UNDERFLOW
					 1 %%FLOAT-SIGNAL-INEXACT-RESULT
					 0)))
	       (MAKE-SINGLE-FLOAT SIGN 0 0))
	      (T 
	       (MULTIPLE-VALUE-BIND (ROUNDED-FRAC ROUNDED-EXPT INEXACT)
		   (SINGLE-FLOAT-ROUND SIGN (STICKY-RIGHT-SHIFT FINAL-FRAC (1- FINAL-EXPT)) 0)
		 (IF (LDB-TEST %%FLOAT-TRAP-ENABLE-UNDERFLOW FLOAT-OPERATING-MODE)
		     (SETQ FLOAT-OPERATION-STATUS
			   (LOGIOR FLOAT-OPERATION-STATUS
				   (IF INEXACT
				       (%LOGDPBS 1 %%FLOAT-SIGNAL-UNDERFLOW
						 1 %%FLOAT-SIGNAL-INEXACT-RESULT 0)
				       (%LOGDPBS 1 %%FLOAT-SIGNAL-UNDERFLOW
						 0 %%FLOAT-SIGNAL-INEXACT-RESULT 0))))
		     (WHEN INEXACT
		       (SETQ FLOAT-OPERATION-STATUS
			     (LOGIOR FLOAT-OPERATION-STATUS
				     (%LOGDPBS 1 %%FLOAT-SIGNAL-UNDERFLOW
					       1 %%FLOAT-SIGNAL-INEXACT-RESULT 0)))))
		 (VALUES
		   (MAKE-SINGLE-FLOAT SIGN ROUNDED-FRAC ROUNDED-EXPT)
		   SIGN FINAL-FRAC FINAL-EXPT)))))))

(DEFNUMOP ASH ((NUMBER SINGLE-FLOAT) (COUNT FIXNUM))
  (LET* ((WORD (%FIXNUM NUMBER))
	 (BIASED-EXPT (%LOGLDB %%SINGLE-EXPONENT WORD)))
    (COMPILER:%ERROR-WHEN (OR (ZEROP (%LOGLDB %%SINGLE-EXCEPT-SIGN WORD))
			      (= BIASED-EXPT %SINGLE-EXPONENT-MAX))
      (RETURN-FROM ASH NUMBER))
    (LET ((NEW-BIASED-EXPT (+ BIASED-EXPT COUNT)))
      ;; First try the easy, common, case where NUMBER and the result are
      ;; normalized finite floating point numbers
      (WHEN (AND (> BIASED-EXPT 0)
		 (< 0 NEW-BIASED-EXPT %SINGLE-EXPONENT-MAX))
	(RETURN-FROM ASH (%FLONUM (%LOGDPB NEW-BIASED-EXPT %%SINGLE-EXPONENT WORD))))
      ;; Okay, try again the slow way
      (SINGLE-FLOAT-HANDLE-EXCEPTIONS (ASH NUMBER COUNT)
	(MULTIPLE-VALUE-BIND (FRAC BIASED-EXPT)
	    (SINGLE-FLOAT-FRAC-AND-EXPONENT WORD BIASED-EXPT)
	  (CLEAR-FLOAT-SIGNALS)
	  (SINGLE-FLOAT-NORMALIZE (%LOGLDB %%SINGLE-SIGN WORD) FRAC (+ BIASED-EXPT COUNT)))))))

(DEFUN ZL:FLOAT (NUMBER)
  ;; FLOAT of a fixnum must be safeguarded for TRANSPORT-TRAP.
  (DECLARE (SIDE-EFFECTS SIMPLE REDUCIBLE)
	   (SAFEGUARDED-FUNCTION)
	   (UNSAFEGUARDED-REFERENCE
	     SI:FLOAT-BIGNUM SI:FLOAT-RATIONAL SI:%CONVERT-DOUBLE-TO-SINGLE
	     DBG:CHECK-TYPE-1 NUMBER FUTURE-COMMON-LISP:REAL))
  (ETYPECASE NUMBER
    (FIXNUM
      (FUTURE-COMMON-LISP:SYMBOL-MACROLET ((LARGEST-EXACT-FIXNUM
					     (1+ (DPB -1 %%SINGLE-FRACTION
						      (DPB -1 %%SINGLE-N-BIT 0)))))
	(COND ((AND (<= NUMBER LARGEST-EXACT-FIXNUM)
		    (>= NUMBER (- LARGEST-EXACT-FIXNUM)))
	       ;; easy case -- no rounding
	       #-VLM
	       (PROGN
		 (%FPA-START CONVERT-FIXNUM-TO-SINGLE-TRUNCATING NUMBER)
		 (WHEN (FP-COPROCESSOR-ENABLED-P)
		   (%FPA-WAIT CONVERT-FIXNUM-TO-SINGLE-TRUNCATING :AFTER-TEST T)
		   (RETURN-FROM ZL:FLOAT (%FPA-RESULT CONVERT-FIXNUM-TO-SINGLE-TRUNCATING))))
	       (COMPILER:%ERROR-WHEN (ZEROP NUMBER)
		 (RETURN-FROM ZL:FLOAT 0E0))
	       (LET* ((ABS-NUMBER (IF (MINUSP NUMBER) (- NUMBER) NUMBER))
		      (LEFTMOST-ONE (FIXNUM-LEFTMOST-ONE ABS-NUMBER)))
		 (%FLONUM (%LOGDPBS (+ (- %SINGLE-EXPONENT-BIAS 1) LEFTMOST-ONE)
				    %%SINGLE-EXPONENT
				    (LSH ABS-NUMBER
					 (- (1+ (BYTE-SIZE %%SINGLE-FRACTION)) LEFTMOST-ONE))
				    %%SINGLE-FRACTION
				    NUMBER))))
	      (T
	       #-VLM
	       (PROGN
		 (%FPA-START CONVERT-FIXNUM-TO-DOUBLE-ROUNDING NUMBER)
		 (WHEN (FP-COPROCESSOR-ENABLED-P)
		   ;; FPA doesn't do fixnum-to-single rounding, so convert to double first
		   (%FPA-WAIT CONVERT-FIXNUM-TO-DOUBLE-ROUNDING :AFTER-TEST T)
		   (%FPA-START CONVERT-DOUBLE-TO-SINGLE-ROUNDING
			       (%FPA-DOUBLE-RESULT-HIGH CONVERT-FIXNUM-TO-DOUBLE-ROUNDING)
			       (%FPA-DOUBLE-RESULT-LOW CONVERT-FIXNUM-TO-DOUBLE-ROUNDING))
		   (%FPA-WAIT CONVERT-DOUBLE-TO-SINGLE-ROUNDING)
		   (LET ((RESULT (%FPA-RESULT CONVERT-DOUBLE-TO-SINGLE-ROUNDING)))
		     (WHEN (TYPEP RESULT 'SINGLE-FLOAT)
		       (RETURN-FROM ZL:FLOAT RESULT))
		     ;; must be trying to signal inexact-result
		     (UPDATE-FLOAT-OPERATION-STATUS (%FPA-STICKY-BITS-REGISTER))
		     (RETURN-FROM ZL:FLOAT (%FLONUM RESULT)))))
	       (LET* ((ABS-NUMBER (IF (MINUSP NUMBER)
				      (%32-BIT-DIFFERENCE 0 NUMBER);handle most-negative-fixnum
				      NUMBER))
		      (LEFTMOST-ONE (FIXNUM-LEFTMOST-ONE ABS-NUMBER)))
		 (LET ((SIGN (%LOGLDB %%SINGLE-SIGN NUMBER))
		       (SHIFTED-NUMBER (ROT ABS-NUMBER (- 32 LEFTMOST-ONE))))	;n-bit in sign
		   (MULTIPLE-VALUE-BIND (FRAC BIASED-EXPT INEXACT)
		       (SINGLE-FLOAT-ROUND
			 SIGN
			 (LOGIOR (%LOGLDB (BYTE 27 5) SHIFTED-NUMBER)
				 ;; Or the lower 5 bits together for the sticky bit
				 (%LOGLDB (BYTE 1 31)
					  (- (LDB (BYTE 5 0) SHIFTED-NUMBER))))
			 (+ (- %SINGLE-EXPONENT-BIAS 1) LEFTMOST-ONE))
		     (WHEN INEXACT
		       (SETF (LDB %%FLOAT-FLAG-INEXACT-RESULT FLOAT-OPERATION-STATUS) 1))
		     (%FLONUM (MAKE-SINGLE-FLOAT SIGN FRAC BIASED-EXPT)))))))))
    (DOUBLE-FLOAT
      (%MULTIPLE-VALUE-CALL-N %CONVERT-DOUBLE-TO-SINGLE
			      (SI:%FAST-DOUBLE-COMPONENTS NUMBER) 2))
    (SINGLE-FLOAT NUMBER)
    (BIGNUM (SI:FLOAT-BIGNUM NUMBER))
    (RATIO (SI:FLOAT-RATIONAL NUMBER))))

(DEFUN %CONVERT-SINGLE-TO-FIXNUM (SINGLE-FLOAT)
  (CHECK-TYPE SINGLE-FLOAT SINGLE-FLOAT)
  (LET* ((WORD (%FIXNUM SINGLE-FLOAT))
	 (BIASED-EXPT (%LOGLDB %%SINGLE-EXPONENT WORD)))
    #-VLM
    (WHEN (< BIASED-EXPT (LDB %%SINGLE-EXPONENT (%FIXNUM (FLOAT MOST-POSITIVE-FIXNUM))))
      (%FPA-START CONVERT-SINGLE-TO-FIXNUM-ROUNDING SINGLE-FLOAT)
      (WHEN (FP-COPROCESSOR-ENABLED-P)
	(%FPA-WAIT CONVERT-SINGLE-TO-FIXNUM-ROUNDING :AFTER-TEST T)
	(LET ((RESULT (%FPA-RESULT CONVERT-SINGLE-TO-FIXNUM-ROUNDING)))
	  (WHEN (TYPEP RESULT 'SINGLE-FLOAT)
	    (RETURN-FROM %CONVERT-SINGLE-TO-FIXNUM (%FIXNUM RESULT)))
	  (LET ((STICKY-BITS (%FPA-STICKY-BITS-REGISTER)))
	    (WHEN (LDB-TEST %%W3X64-DENORMALIZED-INPUT-FLAG STICKY-BITS)
	      (%FPA-START CONVERT-SINGLE-TO-FIXNUM-ROUNDING
			  ;; just need the sign of the original number
			  (DPB 1 %%SINGLE-EXPONENT WORD))
	      (%FPA-WAIT CONVERT-SINGLE-TO-FIXNUM-ROUNDING)
	      (RETURN-FROM %CONVERT-SINGLE-TO-FIXNUM
		(PROG1 (%FIXNUM (%FPA-RESULT CONVERT-SINGLE-TO-FIXNUM-ROUNDING))
		       (UPDATE-FLOAT-OPERATION-STATUS (%FPA-STICKY-BITS-REGISTER)))))
	    ;; must be trying to signal an inexact result
	    (UPDATE-FLOAT-OPERATION-STATUS STICKY-BITS)
	    (RETURN-FROM %CONVERT-SINGLE-TO-FIXNUM (%FIXNUM RESULT))))))
    (COMPILER:%ERROR-WHEN (ZEROP (%LOGLDB %%SINGLE-EXCEPT-SIGN WORD))
      (RETURN-FROM %CONVERT-SINGLE-TO-FIXNUM 0))
    (COMPILER:%ERROR-WHEN (= BIASED-EXPT %SINGLE-EXPONENT-MAX)
      ;; Infinity, or NAN
      (RETURN-FROM %CONVERT-SINGLE-TO-FIXNUM
	(SIGNAL-PROCEED-CASE ((VALUE)
			      'FLOAT-INVALID-OPERATION
			      ':OPERATION '%CONVERT-SINGLE-TO-FIXNUM
			      ':NON-TRAP-RESULT 0
			      ':OPERANDS (LIST SINGLE-FLOAT)
			      ':SAVED-FLOAT-OPERATION-STATUS (FLOAT-OPERATION-STATUS))
	  (:NEW-VALUE VALUE))))
    (LET ((FRAC (%LOGDPB 1
			 (BYTE (- 32 (BYTE-SIZE %%SINGLE-FRACTION))
			       (BYTE-SIZE %%SINGLE-FRACTION))
			 WORD))
	  (SHIFT-AMOUNT (- BIASED-EXPT %SINGLE-EXPONENT-BIAS
			   (BYTE-SIZE %%SINGLE-FRACTION))))
      (IF (OR ( SHIFT-AMOUNT 0)
	      (AND ( SHIFT-AMOUNT -32)		; ( (+ SHIFT-AMOUNT 32) 0)
		   ;; exact if zero fraction
		   (ZEROP (LSH FRAC (+ SHIFT-AMOUNT 32)))))
	  (ASH (IF (PLUSP WORD) FRAC (- FRAC)) SHIFT-AMOUNT)
	  (PROGN
	    (SETF (LDB-TEST %%FLOAT-FLAG-INEXACT-RESULT FLOAT-OPERATION-STATUS) T)
	    (SELECT (LDB %%FLOAT-ROUNDING-MODE (FLOAT-OPERATING-MODE))
	      (%FLOAT-ROUNDING-MODE-NEAREST
	       (LET ((INTEGER (LSH FRAC SHIFT-AMOUNT))
		     (FRACTION (LSH FRAC (+ SHIFT-AMOUNT 32))))
		 (WHEN (AND (MINUSP FRACTION)	;  .5
			    (OR (NOT (ZEROP (LDB (BYTE 31 0) FRACTION)))	; > .5
				(ODDP INTEGER)))
		   (INCF INTEGER))
		 (IF (PLUSP WORD) INTEGER (- INTEGER))))
	      (%FLOAT-ROUNDING-MODE-MINUS
	       (ASH (IF (PLUSP WORD) FRAC (- FRAC)) SHIFT-AMOUNT))
	      (%FLOAT-ROUNDING-MODE-ZERO
	       (LET ((INTEGER (ASH FRAC SHIFT-AMOUNT)))
		 (IF (PLUSP WORD) INTEGER (- INTEGER))))
	      (OTHERWISE			;%FLOAT-ROUNDING-MODE-PLUS
	       (- (ASH (IF (PLUSP WORD) (- FRAC) FRAC) SHIFT-AMOUNT)))))))))

(DEFNUMOP - ((X SINGLE-FLOAT))
  (WHEN (FP-COPROCESSOR-ENABLED-P)
    (UPDATE-FLOAT-OPERATION-STATUS (%FPA-STICKY-BITS-REGISTER)))
  (%FLONUM (LOGXOR (%FIXNUM X) (ROT 1 -1))))

(DEFNUMOP PLUSP ((X SINGLE-FLOAT))
  (WHEN (FP-COPROCESSOR-ENABLED-P)
    (UPDATE-FLOAT-OPERATION-STATUS (%FPA-STICKY-BITS-REGISTER)))
  (LET ((WORD (%FIXNUM X)))
    (IF (AND (= (%LOGLDB %%SINGLE-EXPONENT WORD) %SINGLE-EXPONENT-MAX)
	     ( (%LOGLDB %%SINGLE-FRACTION WORD) 0))
	(ERROR "PLUSP of NAN not implemented")
	(PLUSP WORD))))

(DEFNUMOP MINUSP ((X SINGLE-FLOAT))
  (WHEN (FP-COPROCESSOR-ENABLED-P)
    (UPDATE-FLOAT-OPERATION-STATUS (%FPA-STICKY-BITS-REGISTER)))
  (LET ((WORD (%FIXNUM X)))
    (IF (AND (= (%LOGLDB %%SINGLE-EXPONENT WORD) %SINGLE-EXPONENT-MAX)
	     ( (%LOGLDB %%SINGLE-FRACTION WORD) 0))
	(ERROR "MINUSP of NAN not implemented")
	(AND (MINUSP WORD)
	     (NOT (ZEROP (%LOGLDB %%SINGLE-EXCEPT-SIGN WORD)))))))

(DEFNUMOP ZEROP ((X SINGLE-FLOAT))
  (WHEN (FP-COPROCESSOR-ENABLED-P)
    (UPDATE-FLOAT-OPERATION-STATUS (%FPA-STICKY-BITS-REGISTER)))
  (ZEROP (%LOGLDB %%SINGLE-EXCEPT-SIGN (%FIXNUM X))))

(DEFUN SINGLE-FLOAT-ADD-INTERNAL (X-WORD Y-WORD)
  (IF (MINUSP (LOGXOR X-WORD Y-WORD))
      (LET ((X-BUT-SIGN (%LOGLDB %%SINGLE-EXCEPT-SIGN X-WORD))
	    (Y-BUT-SIGN (%LOGLDB %%SINGLE-EXCEPT-SIGN Y-WORD)))
	(WHEN (ZEROP X-BUT-SIGN)
	  (RETURN-FROM SINGLE-FLOAT-ADD-INTERNAL
	    (IF (ZEROP Y-BUT-SIGN)
		(IF (= (%LOGLDB %%FLOAT-ROUNDING-MODE (FLOAT-OPERATING-MODE))
		       %FLOAT-ROUNDING-MODE-MINUS)
		    (%LOGDPB 1 %%SINGLE-SIGN 0)
		    0)
		Y-WORD)))
	(WHEN (ZEROP Y-BUT-SIGN)
	  (RETURN-FROM SINGLE-FLOAT-ADD-INTERNAL X-WORD))
	(MULTIPLE-VALUE-BIND (SMALL-WORD BIG-WORD SIGN)
	    ;; If the exponents are equal, compare the mantissas.  Fortunately, they live
	    ;; right next door to each other, so we can check them simultaneously
	    (IF (< X-BUT-SIGN Y-BUT-SIGN)
		(VALUES X-BUT-SIGN Y-BUT-SIGN (%LOGLDB %%SINGLE-SIGN Y-WORD))
		(VALUES Y-BUT-SIGN X-BUT-SIGN (%LOGLDB %%SINGLE-SIGN X-WORD)))
	  (LET* ((SMALL-BIASED-EXPT (%LOGLDB %%SINGLE-EXPONENT SMALL-WORD))
		 (BIG-BIASED-EXPT (%LOGLDB %%SINGLE-EXPONENT BIG-WORD)))
	    ;; Infinity and NAN handling
	    ;;
	    ;;                   BIG
	    ;;             NAN      | Finite
	    ;;           +-----+-----+--------
	    ;; S   NAN   | NAN | NAN |  NAN
	    ;; M         |     +-----+
	    ;; A        | NAN |ERROR|   
	    ;; L         +     +-----+--------
	    ;; L  Finite | NAN      | Finite
	    ;;
	    (LET ((EXPT-MAX %SINGLE-EXPONENT-MAX))
	      (IF (= BIG-BIASED-EXPT EXPT-MAX)
		  (RETURN-FROM SINGLE-FLOAT-ADD-INTERNAL
		    (IF (AND (ZEROP (%LOGLDB %%SINGLE-FRACTION BIG-WORD))
			     (= SMALL-BIASED-EXPT EXPT-MAX))
			(IF (ZEROP (%LOGLDB %%SINGLE-FRACTION SMALL-WORD))
			    (PROGN
			      (SETF (LDB-TEST %%FLOAT-SIGNAL-INVALID-OPERATION
					      FLOAT-OPERATION-STATUS) T)
			      (MAKE-SINGLE-FLOAT 0 -1 %SINGLE-EXPONENT-MAX))
			    (%LOGDPB SIGN %%SINGLE-SIGN SMALL-WORD))
			(%LOGDPB SIGN %%SINGLE-SIGN BIG-WORD)))
		  (WHEN (= SMALL-BIASED-EXPT EXPT-MAX)
		    (RETURN-FROM SINGLE-FLOAT-ADD-INTERNAL
		      (%LOGDPB SIGN %%SINGLE-SIGN SMALL-WORD)))))
	    (MULTIPLE-VALUE-BIND (BIG-FRAC BIG-BIASED-EXPT)
		(SINGLE-FLOAT-FRAC-AND-EXPONENT BIG-WORD BIG-BIASED-EXPT)
	      (MULTIPLE-VALUE-BIND (SMALL-FRAC SMALL-BIASED-EXPT)
		  (SINGLE-FLOAT-FRAC-AND-EXPONENT SMALL-WORD SMALL-BIASED-EXPT)
		(LET ((RESULT
			(SINGLE-FLOAT-NORMALIZE
			  SIGN
			  (- BIG-FRAC
			     (STICKY-RIGHT-SHIFT
			       SMALL-FRAC (- SMALL-BIASED-EXPT BIG-BIASED-EXPT)))
			  BIG-BIASED-EXPT
			  )))
		  (IF (ZEROP (%LOGLDB %%SINGLE-EXCEPT-SIGN RESULT))
		      (IF (= (%LOGLDB %%FLOAT-ROUNDING-MODE (FLOAT-OPERATING-MODE))
			     %FLOAT-ROUNDING-MODE-MINUS)
			  (%LOGDPB 1 %%SINGLE-SIGN 0)
			  0)
		      RESULT)))))))
      (LET* ((X-BIASED-EXPT (%LOGLDB %%SINGLE-EXPONENT X-WORD))
	     (Y-BIASED-EXPT (%LOGLDB %%SINGLE-EXPONENT Y-WORD)))
	(WHEN (ZEROP (%LOGLDB %%SINGLE-EXCEPT-SIGN X-WORD))
	  (RETURN-FROM SINGLE-FLOAT-ADD-INTERNAL Y-WORD))
	(WHEN (ZEROP (%LOGLDB %%SINGLE-EXCEPT-SIGN Y-WORD))
	  (RETURN-FROM SINGLE-FLOAT-ADD-INTERNAL X-WORD))
	(LET ((EXPT-MAX %SINGLE-EXPONENT-MAX))
	  ;; Infinity and NAN handling
	  ;;
	  ;;                    X
	  ;;             NAN      | Finite
	  ;;           +-----+-----+--------
	  ;;     NAN   | NAN | NAN |  NAN
	  ;;           |     |     |
	  ;; Y        | NAN |    |   
	  ;;           +-----+-----+--------
	  ;;    Finite | NAN      | Finite
	  ;;
	  ;; If X is not finite then {if X is  and Y is not finite, Y is
	  ;; the result, else X} else if Y is not finite, then Y is the
	  ;; result.
	  (IF (= X-BIASED-EXPT EXPT-MAX)
	      (RETURN-FROM SINGLE-FLOAT-ADD-INTERNAL
		(IF (AND (ZEROP (%LOGLDB %%SINGLE-FRACTION X-WORD))
			 (= Y-BIASED-EXPT EXPT-MAX))
		    (%FLONUM Y-WORD)
		    (%FLONUM X-WORD)))
	      (WHEN (= Y-BIASED-EXPT EXPT-MAX)
		(RETURN-FROM SINGLE-FLOAT-ADD-INTERNAL (%FLONUM Y-WORD)))))
	;; We want to shift the smaller magnitude number to the right to line it up with
	;; the larger magnitude number.  If the exponents are equal, we don't care.
	(MULTIPLE-VALUE-BIND (X-FRAC X-BIASED-EXPT)
	    (SINGLE-FLOAT-FRAC-AND-EXPONENT X-WORD X-BIASED-EXPT)
	  (MULTIPLE-VALUE-BIND (Y-FRAC Y-BIASED-EXPT)
	      (SINGLE-FLOAT-FRAC-AND-EXPONENT Y-WORD Y-BIASED-EXPT)
	    (MULTIPLE-VALUE-BIND (SMALL-FRAC SMALL-BIASED-EXPT BIG-FRAC BIG-BIASED-EXPT)
		(IF (< X-BIASED-EXPT Y-BIASED-EXPT)
		    (VALUES X-FRAC X-BIASED-EXPT Y-FRAC Y-BIASED-EXPT)
		    (VALUES Y-FRAC Y-BIASED-EXPT X-FRAC X-BIASED-EXPT))
	      (LET* ((SIGN (%LOGLDB %%SINGLE-SIGN X-WORD)))
		(LET ((FRAC
			(+ BIG-FRAC
			   (STICKY-RIGHT-SHIFT
			     SMALL-FRAC
			     (- SMALL-BIASED-EXPT BIG-BIASED-EXPT)))))
		  (NORMALIZE-FOR-OVERFLOW FRAC BIG-BIASED-EXPT)
		  (SINGLE-FLOAT-NORMALIZE SIGN FRAC BIG-BIASED-EXPT)))))))))

(DEFMACRO SINGLE-FLOAT-TRAP-BODY ((FUNCTION &REST ARGS)
				  (FPA-FUNCTION &REST FPA-ARGS)
				  &BODY LISP-CODE)
  #+VLM (DECLARE (IGNORE FPA-FUNCTION FPA-ARGS))
  `(BLOCK ,FUNCTION
     (SINGLE-FLOAT-HANDLE-EXCEPTIONS (,FUNCTION ,@ARGS)
       (BLOCK DO-IT
	 #-VLM
	 (BLOCK TRY-FPA
	   ,@(WHEN FPA-ARGS
	       `((%FPA-START ,FPA-FUNCTION ,@FPA-ARGS)))
	   (WHEN (FP-COPROCESSOR-ENABLED-P)
	     ,@(WHEN FPA-ARGS
		 `((%FPA-WAIT ,FPA-FUNCTION :AFTER-TEST T)))
	     (LET ((RESULT (%FPA-RESULT ,FPA-FUNCTION)))
	       ,(WHEN FPA-ARGS
		  `(WHEN (TYPEP RESULT 'SINGLE-FLOAT)
		     (RETURN-FROM ,FUNCTION RESULT)))
	       (CLEAR-FLOAT-SIGNALS)
	       (LET* ((STICKY-BITS (%FPA-STICKY-BITS-REGISTER))
		      (STATUS (%FPA-STATUS ,FPA-FUNCTION))
		      (SIGNALS (READ-FPA-SIGNALS STICKY-BITS)))
		 (SETF (%FPA-STICKY-BITS-REGISTER) 0)
		 (SETF (%FPA-FPEX-DIVIDE-STATUS-REGISTER) 0)
		 (WHEN (LDB-TEST %%W3X64-DENORMALIZED-INPUT-FLAG STICKY-BITS)
		   (RETURN-FROM TRY-FPA))
		 (RETURN-FROM DO-IT
		   (MULTIPLE-VALUE-PROG1
		     (SELECT STATUS
		       (%W3X64-UNORMALIZED-EXACT-32
			(SINGLE-FLOAT-UNWRAP RESULT NIL))
		       (%W3X64-UNORMALIZED-INEXACT-32
			(SINGLE-FLOAT-UNWRAP RESULT T))
		       ((%W3X64-OVERFLOW-32 %W3X64-OVERFLOW-6432)
			(SETF (LDB-TEST %%FLOAT-SIGNAL-OVERFLOW SIGNALS) T)
			(SETF (LDB-TEST %%FLOAT-SIGNAL-INEXACT-RESULT SIGNALS) T)
			(LET ((SIGN (%LOGLDB %%SINGLE-SIGN RESULT))
			      (EXPONENT (%LOGLDB %%SINGLE-EXPONENT RESULT)))
			  (VALUES
			    (SINGLE-FLOAT-OVERFLOW-VALUE SIGN)
			    SIGN
			    (%LOGDPB 1 %%FRAC-N-BIT
				     (ROT (%LOGLDB %%SINGLE-FRACTION RESULT)
					  (- (BYTE-POSITION %%FRAC-FIELD )
					     (BYTE-POSITION %%SINGLE-FRACTION))))
			    (IF (= EXPONENT %SINGLE-EXPONENT-MAX)
				EXPONENT
				(+ EXPONENT %SINGLE-EXPONENT-MAX)))))
		       (OTHERWISE RESULT))
		     (SETQ FLOAT-OPERATION-STATUS
			   (LOGIOR FLOAT-OPERATION-STATUS SIGNALS))))))))
	 (CLEAR-FLOAT-SIGNALS)
	 ,@LISP-CODE))))

(DEFNUMOP + ((X SINGLE-FLOAT) (Y SINGLE-FLOAT))
  (SINGLE-FLOAT-TRAP-BODY (+ X Y) (SINGLE-ADD)
    (SINGLE-FLOAT-ADD-INTERNAL (%FIXNUM X) (%FIXNUM Y))))

(DEFNUMOP + ((X SINGLE-FLOAT) (Y-FIX FIXNUM))
  (+ (FLOAT Y-FIX 1.0) X))

(DEFNUMOP - ((X SINGLE-FLOAT) (Y SINGLE-FLOAT))
  (SINGLE-FLOAT-TRAP-BODY (- X Y) (SINGLE-SUB)
    (SINGLE-FLOAT-ADD-INTERNAL (%FIXNUM X) (LOGXOR (ROT 1 -1.) (%FIXNUM Y)))))

(DEFNUMOP - ((X SINGLE-FLOAT) (Y-FIX FIXNUM))
  (- X (FLOAT Y-FIX 1.0)))

(DEFNUMOP - ((X-FIX FIXNUM) (Y SINGLE-FLOAT))
  (- (FLOAT X-FIX 1.0) Y))

(DEFUN SINGLE-FLOAT-MULTIPLY (X-WORD Y-WORD)
  (DECLARE (SAFEGUARDED-FUNCTION))
  (LET* ((X-BIASED-EXPT (%LOGLDB %%SINGLE-EXPONENT X-WORD))
	 (Y-BIASED-EXPT (%LOGLDB %%SINGLE-EXPONENT Y-WORD))
	 (SIGN (%LOGLDB %%SINGLE-SIGN (LOGXOR X-WORD Y-WORD))))
    (LET ((EXPT-MAX %SINGLE-EXPONENT-MAX))
      ;; Infinity and NAN handling
      ;;
      ;;            NAN             0     Finite
      ;;        +--------+-------+---------------
      ;;  NAN   |   NAN  |  NAN  |  NAN     NAN
      ;;        |        |       +-------+
      ;;       |   NAN  |      | ERROR |   
      ;;        |        +-------+-------+--------
      ;;   0    |   NAN  | ERROR |   0       0
      ;;        |        +-------+       +--------
      ;; Finite |   NAN         |   0   | Finite
      ;;
      (WHEN (= X-BIASED-EXPT EXPT-MAX)
	(RETURN-FROM SINGLE-FLOAT-MULTIPLY
	  (IF (ZEROP (%LOGLDB %%SINGLE-FRACTION X-WORD))
	      ;; X is infinite
	      (IF (ZEROP (%LOGLDB %%SINGLE-EXCEPT-SIGN Y-WORD))
		  (PROGN
		    (SETF (LDB-TEST %%FLOAT-SIGNAL-INVALID-OPERATION FLOAT-OPERATION-STATUS) T)
		    (MAKE-SINGLE-FLOAT 0 -1 %SINGLE-EXPONENT-MAX))
		  (%LOGDPB SIGN %%SINGLE-SIGN
			   (IF (= Y-BIASED-EXPT EXPT-MAX)
			       Y-WORD
			       X-WORD)))
	      ;; X is NaN
	      (%LOGDPB SIGN %%SINGLE-SIGN X-WORD))))
      (WHEN (= Y-BIASED-EXPT EXPT-MAX)
	(RETURN-FROM SINGLE-FLOAT-MULTIPLY
	  (IF (AND (ZEROP (%LOGLDB %%SINGLE-FRACTION Y-WORD))
		   (ZEROP (%LOGLDB %%SINGLE-EXCEPT-SIGN X-WORD)))
	      (PROGN
		(SETF (LDB-TEST %%FLOAT-SIGNAL-INVALID-OPERATION FLOAT-OPERATION-STATUS) T)
		(MAKE-SINGLE-FLOAT 0 -1 %SINGLE-EXPONENT-MAX))
	      (%LOGDPB SIGN %%SINGLE-SIGN Y-WORD)))))
    ;; Zero handling
    (WHEN (OR (ZEROP (%LOGLDB %%SINGLE-EXCEPT-SIGN X-WORD))
	      (ZEROP (%LOGLDB %%SINGLE-EXCEPT-SIGN Y-WORD)))
      (RETURN-FROM SINGLE-FLOAT-MULTIPLY
	(%LOGDPB SIGN %%SINGLE-SIGN 0)))
    (MULTIPLE-VALUE-BIND (X-FRAC X-BIASED-EXPT)
	(SINGLE-FLOAT-FRAC-AND-EXPONENT X-WORD X-BIASED-EXPT)
      (MULTIPLE-VALUE-BIND (Y-FRAC Y-BIASED-EXPT)
	  (SINGLE-FLOAT-FRAC-AND-EXPONENT Y-WORD Y-BIASED-EXPT)
	(MULTIPLE-VALUE-BIND (LOW-FRAC HIGH-FRAC) (%MULTIPLY-BIGNUM-STEP X-FRAC Y-FRAC)
	  ;; Now normalize the 2-word fraction, coming up with a 1-word fraction.
	  ;; Because we are multiplying normalized fractions, we know that
	  ;; 1_26.x,y<1_27., so 1_52.xy<1_54.  Thus, bit 52 or 53 is 1.  We want to
	  ;; shift this left so that bit 26.+32.=58. is 1, a shift of 5 or 6 bits.
	  (LET ((BIT (%LOGLDB (BYTE 1. (- (1- (* 2 (1+ (BYTE-POSITION %%FRAC-N-BIT)))) 32.))
			      HIGH-FRAC)))
	    (MULTIPLE-VALUE-BIND (EXTRA-LOW FRAC)
		(IF (ZEROP BIT)
		    (%UNBOXED-INTEGER-VALUES 2
		      (%UNBOXED-CONSTANT-LEFT-SHIFT
			(%POSITIVE-INTEGER LOW-FRAC HIGH-FRAC)
			(- (+ (BYTE-POSITION %%FRAC-N-BIT) 32.)
			      (* 2 (BYTE-POSITION %%FRAC-N-BIT)))))
		    (%UNBOXED-INTEGER-VALUES 2
		      (%UNBOXED-CONSTANT-LEFT-SHIFT
			(%POSITIVE-INTEGER LOW-FRAC HIGH-FRAC)
			(- (+ (BYTE-POSITION %%FRAC-N-BIT) 32.)
			   (* 2 (BYTE-POSITION %%FRAC-N-BIT))
			   1))))
	      (LET ((FRAC (LOGIOR FRAC (IF (ZEROP EXTRA-LOW) 0 1))))
		(SINGLE-FLOAT-NORMALIZE
		  SIGN
		  FRAC
		  (- (+ X-BIASED-EXPT Y-BIASED-EXPT BIT) %SINGLE-EXPONENT-BIAS))))))))))

(DEFNUMOP * ((X SINGLE-FLOAT) (Y SINGLE-FLOAT))
  (SINGLE-FLOAT-TRAP-BODY (* X Y) (SINGLE-MULTIPLY)
    (SINGLE-FLOAT-MULTIPLY (%FIXNUM X) (%FIXNUM Y))))

(DEFNUMOP * ((X SINGLE-FLOAT) (Y-FIX FIXNUM))
  ;; This function has to be safeguarded in order for %HARDWARE-TRANSPORT-TRAP and
  ;; friends to multiply by DBG:PDL-GROW-RATIO
  (DECLARE (SAFEGUARDED-FUNCTION))
  (* (FLOAT Y-FIX 1.0) X))

(DEFUN SINGLE-FLOAT-QUOTIENT (X-WORD Y-WORD)
  (LET* ((X-BIASED-EXPT (%LOGLDB %%SINGLE-EXPONENT X-WORD))
	 (Y-BIASED-EXPT (%LOGLDB %%SINGLE-EXPONENT Y-WORD))
	 (SIGN (%LOGLDB %%SINGLE-SIGN (LOGXOR X-WORD Y-WORD))))
    (LET ((EXPT-MAX %SINGLE-EXPONENT-MAX))
      ;; Infinity and NAN handling
      ;;
      ;;                        X
      ;;            NAN            0      Finite
      ;;        +--------+-------+----------------
      ;;  NAN   |   NAN  |  NAN  |  NAN     NAN
      ;;        |        +-------+----------------
      ;;       |   NAN  |INVALID|   0       0
      ;;        |        +-------+----------------
      ;;   0    |   NAN  |      |  0/0  |Div-by-0
      ;;        |        |       +-------+--------
      ;; Finite |   NAN  |      |   0   | Finite
      ;;
      (WHEN (= X-BIASED-EXPT EXPT-MAX)
	(RETURN-FROM SINGLE-FLOAT-QUOTIENT
	  (IF (ZEROP (%LOGLDB %%SINGLE-FRACTION X-WORD))
	      (IF (= Y-BIASED-EXPT EXPT-MAX)
		  (IF (ZEROP (%LOGLDB %%SINGLE-FRACTION Y-WORD))
		      (PROGN
			(SETF (LDB-TEST %%FLOAT-SIGNAL-INVALID-OPERATION
					FLOAT-OPERATION-STATUS) T)
			(MAKE-SINGLE-FLOAT 0 -1 %SINGLE-EXPONENT-MAX))
		      (%LOGDPB SIGN %%SINGLE-SIGN Y-WORD))
		  (%LOGDPB SIGN %%SINGLE-SIGN X-WORD))
	      (%LOGDPB SIGN %%SINGLE-SIGN X-WORD))))
      (WHEN (= Y-BIASED-EXPT EXPT-MAX)
	(RETURN-FROM SINGLE-FLOAT-QUOTIENT
	  (IF (ZEROP (%LOGLDB %%SINGLE-FRACTION Y-WORD))
	      (%LOGDPB SIGN %%SINGLE-SIGN 0)	;Y NaN
	      (%LOGDPB SIGN %%SINGLE-SIGN Y-WORD))))	;Y infinite
      (WHEN (ZEROP (%LOGLDB %%SINGLE-EXCEPT-SIGN Y-WORD))
	(RETURN-FROM SINGLE-FLOAT-QUOTIENT
	  (COND ((ZEROP (%LOGLDB %%SINGLE-EXCEPT-SIGN X-WORD))
		 (SETF (LDB-TEST %%FLOAT-SIGNAL-INVALID-OPERATION FLOAT-OPERATION-STATUS) T)
		 (MAKE-SINGLE-FLOAT 0 -1 %SINGLE-EXPONENT-MAX))
		(T (SETF (LDB-TEST %%FLOAT-SIGNAL-DIVISION-BY-ZERO FLOAT-OPERATION-STATUS) T)
		   (MAKE-SINGLE-FLOAT SIGN 0 %SINGLE-EXPONENT-MAX)))))
      (WHEN (ZEROP (%LOGLDB %%SINGLE-EXCEPT-SIGN X-WORD))
	(RETURN-FROM SINGLE-FLOAT-QUOTIENT
	  (VALUES (%LOGDPB SIGN %%SINGLE-SIGN 0) 0))))
    (MULTIPLE-VALUE-BIND (X-FRAC X-BIASED-EXPT)
	(SINGLE-FLOAT-FRAC-AND-EXPONENT X-WORD X-BIASED-EXPT)
      (MULTIPLE-VALUE-BIND (Y-FRAC Y-BIASED-EXPT)
	  (SINGLE-FLOAT-FRAC-AND-EXPONENT Y-WORD Y-BIASED-EXPT)
	(LET ((BIASED-EXPT (+ (- X-BIASED-EXPT Y-BIASED-EXPT)
			      %SINGLE-EXPONENT-BIAS
			      (+
				;; We add 32 because we are doing a double word divide,
				;; so the divisee is shifted left 32 bits.
				32.
				;; This means the result starts in the V bit, 1 to the
				;; left of the N bit
				(- (1+ (BYTE-SIZE %%FRAC-N+FIELD+GRS)))
				;; The divisor is shifted by this amount
				(- (- 32. (BYTE-SIZE %%FRAC-N+FIELD+GRS)))))))
	  (MULTIPLE-VALUE-BIND (FRAC REMAINDER)
	      (%DIVIDE-BIGNUM-STEP
		0 X-FRAC (ROT Y-FRAC (- 32. (BYTE-SIZE %%FRAC-N+FIELD+GRS))))
	    (NORMALIZE-FOR-OVERFLOW FRAC BIASED-EXPT)
	    (SINGLE-FLOAT-NORMALIZE
	      SIGN
	      (LOGIOR FRAC (IF (ZEROP REMAINDER) 0 1))
	      BIASED-EXPT)))))))

(DEFNUMOP ZL:/ ((X SINGLE-FLOAT) (Y SINGLE-FLOAT))
  (SINGLE-FLOAT-TRAP-BODY (ZL:/ X Y) (SINGLE-QUOTIENT)
    (SINGLE-FLOAT-QUOTIENT (%FIXNUM X) (%FIXNUM Y))))

(DEFNUMOP ZL:/ ((X SINGLE-FLOAT) (Y-FIX FIXNUM))
  (ZL:/ X (FLOAT Y-FIX 1.0)))

(DEFNUMOP ZL:/ ((X-FIX FIXNUM) (Y SINGLE-FLOAT))
  (ZL:/ (FLOAT X-FIX 1.0) Y))

(DEFNUMOP RATIONAL-QUOTIENT ((X SINGLE-FLOAT) (Y SINGLE-FLOAT))
  (SINGLE-FLOAT-TRAP-BODY (RATIONAL-QUOTIENT X Y) (SINGLE-QUOTIENT)
    (SINGLE-FLOAT-QUOTIENT (%FIXNUM X) (%FIXNUM Y))))

(DEFNUMOP RATIONAL-QUOTIENT ((X SINGLE-FLOAT) (Y-FIX FIXNUM))
  (RATIONAL-QUOTIENT X (FLOAT Y-FIX 1.0)))

(DEFNUMOP RATIONAL-QUOTIENT ((X-FIX FIXNUM) (Y SINGLE-FLOAT))
  (RATIONAL-QUOTIENT (FLOAT X-FIX 1.0) Y))

(DEFUN SINGLE-FLOAT-COMPARE (X-WORD Y-WORD)
  (SETQ X-WORD (%FIXNUM X-WORD)
	Y-WORD (%FIXNUM Y-WORD))
  (WHEN (LET ((EXPT-MAX %SINGLE-EXPONENT-MAX))
	  (OR (AND (= (%LOGLDB %%SINGLE-EXPONENT X-WORD) EXPT-MAX)
		   (NOT (ZEROP (%LOGLDB %%SINGLE-FRACTION X-WORD))))
	      (AND (= (%LOGLDB %%SINGLE-EXPONENT Y-WORD) EXPT-MAX)
		   (NOT (ZEROP (%LOGLDB %%SINGLE-FRACTION Y-WORD))))))
    ;; A NAN is involved
    (RETURN-FROM SINGLE-FLOAT-COMPARE 2))
  (WHEN (OR (= X-WORD Y-WORD)
	    (AND (ZEROP (%LOGLDB %%SINGLE-EXCEPT-SIGN X-WORD))
		 (ZEROP (%LOGLDB %%SINGLE-EXCEPT-SIGN Y-WORD))))
    ;; 0.0 and -0.0 are considered =
    (RETURN-FROM SINGLE-FLOAT-COMPARE 0))
  ;; X-WORD and Y-WORD are different.
  ;; Trick:  These are normalized.  If X-EXP rel Y-EXP, then |X| rel |Y|, unless rel
  ;; is =, in which case if X-FRAC rel Y-FRAC, then |X| rel |Y|.  The EXPT field is
  ;; higher order than the FRAC field, so if X and Y are of the same sign, then
  ;; X-WORD rel Y-WORD means |X| rel |Y|.
  (IF (MINUSP X-WORD)
      (IF (MINUSP Y-WORD)
	  (IF (< X-WORD Y-WORD) 1 -1)		;X,Y < 0
	  -1)					;X<0, Y 0
      (IF (MINUSP Y-WORD)
	  1					;X0, Y<0
	  (IF (< X-WORD Y-WORD) -1 1))))	;X,Y > 0

(DEFUN SINGLE-FLOAT-INVALID-COMPARE (FUNCTION &REST OPERANDS)
  (SIGNAL-PROCEED-CASE ((VALUE)
			'FLOAT-INVALID-COMPARE-OPERATION
			':OPERATION FUNCTION
			':OPERANDS OPERANDS
			':NON-TRAP-RESULT NIL
			':SAVED-FLOAT-OPERATION-STATUS (FLOAT-OPERATION-STATUS))
    (:NEW-VALUE VALUE)))

(DEFNUMOP = ((X SINGLE-FLOAT) (Y SINGLE-FLOAT))
  (WHEN (FP-COPROCESSOR-ENABLED-P)
    (UPDATE-FLOAT-OPERATION-STATUS (%FPA-STICKY-BITS-REGISTER)))
  (CASE (SINGLE-FLOAT-COMPARE (%FIXNUM X) (%FIXNUM Y))
    (0 T)
    ((1 -1) NIL)
    (2 (SINGLE-FLOAT-INVALID-COMPARE '= X Y))))

(DEFNUMOP = ((X SINGLE-FLOAT) (Y FIXNUM))
  (= (FLOAT Y 1.0) X))

(DEFNUMOP > ((X SINGLE-FLOAT) (Y SINGLE-FLOAT))
  (WHEN (FP-COPROCESSOR-ENABLED-P)
    (UPDATE-FLOAT-OPERATION-STATUS (%FPA-STICKY-BITS-REGISTER)))
  (CASE (SINGLE-FLOAT-COMPARE (%FIXNUM X) (%FIXNUM Y))
    (1 T)
    ((-1 0) NIL)
    (2 (SINGLE-FLOAT-INVALID-COMPARE '> X Y))))

(DEFNUMOP > ((X FIXNUM) (Y SINGLE-FLOAT))
  (> (FLOAT X 1.0) Y))

(DEFNUMOP > ((X SINGLE-FLOAT) (Y FIXNUM))
  ;; "commute" for addressing x
  (< (FLOAT Y 1.0) X))

(DEFNUMOP MAX ((X SINGLE-FLOAT) (Y SINGLE-FLOAT))
  (IF ( X Y) X Y))

(DEFNUMOP MAX ((X SINGLE-FLOAT) (Y FIXNUM))
  (IF ( X (FLOAT Y 1.0)) X Y))

(DEFNUMOP MIN ((X SINGLE-FLOAT) (Y SINGLE-FLOAT))
  (IF ( X Y) X Y))

(DEFNUMOP MIN ((X SINGLE-FLOAT) (Y FIXNUM))
  (IF ( X (FLOAT Y 1.0)) X Y))

;;; Double float support for Ivory
;;;
;;; This will be stuck on the end of IFLOAT when it is convenient
;;;
;;; Abstractly, double-precision is implemented in the same way as
;;; single-precision.  Pairs of words are used rather than single words,
;;; and bignum arithmetic instructions are used instead of fixnum
;;; instructions.

;;; Structure of "double" floating-point numbers (IEEE double-basic)
;;; |1|--11---|---------52------|
;;; |S| expt  |     frac        |
;;;  63<62:52>-------<51:0>-----
;;;  31<30:20><19:0>|<31:0>-----

;;; Structure of internal significand ("frac")
;;; ...       ----------52------- --3--
;;; ... V N . xxxxxxxxxxxxxxxxxxL G R S
;;; ...       ----------<54:3>--- 2 1 0
;;; ...2423.  -<22:0>-|--<31:3>-- 2 1 0

;;; Where V is overflow bit, N is normalized bit, L is least-significant
;;; bit of the significand, G is guard bit, R is rounding bit, and
;;; S is sticky right-shift bit.
(EVAL-WHEN (COMPILE LOAD EVAL)
(DEFSYSBYTE %%DOUBLE-FRAC-S-BIT 1 0)
(DEFSYSBYTE %%DOUBLE-FRAC-GRS 3 0)
(DEFSYSBYTE %%DOUBLE-FRAC-ROUND-DISPATCH 4 0)		;LGRS
(DEFSYSBYTE %%DOUBLE-FRAC-L-BIT 1 3)
(DEFSYSBYTE %%DOUBLE-FRAC-FIELD 52. 3)
(DEFSYSBYTE %%DOUBLE-FRAC-FIELD+N-BIT 53. 3)
(DEFSYSBYTE %%DOUBLE-FRAC-N+FIELD+GR 55. 1.)
(DEFSYSBYTE %%DOUBLE-FRAC-N+FIELD+GRS 56. 0.)
(DEFSYSBYTE %%DOUBLE-FRAC-NORMALIZE-DISPATCH 4 52.)	;highest bit is N
(DEFSYSBYTE %%DOUBLE-FRAC-N-BIT 1 55.)
(DEFSYSBYTE %%DOUBLE-FRAC-V-BIT 1 56.)
);End EVAL-WHEN

;;; This returns the fraction in normalized internal format, as well as the
;;; appropriate biased exponent.
(DEFSUBST DOUBLE-FLOAT-FRAC-AND-EXPONENT
	  (WORD-LOW WORD-HIGH
		    &OPTIONAL
		    (BIASED-EXPT (%LOGLDB %%DOUBLE-EXPONENT WORD-HIGH)))
  (DECLARE (VALUES FRAC-LOW FRAC-HIGH EXPONENT))
  (IF (ZEROP BIASED-EXPT)
      (%MULTIPLE-VALUE-CALL-N
	DOUBLE-NORMALIZE-INTERNAL-FRACTION
	(%UNBOXED-INTEGER-VALUES 2
	  (%UNBOXED-CONSTANT-LEFT-SHIFT
	    (%POSITIVE-INTEGER
	      WORD-LOW
	      (%LOGLDB %%DOUBLE-FRACTION-HIGH WORD-HIGH))
	    (1+ (BYTE-POSITION %%DOUBLE-FRAC-FIELD))))
	2
	0
	1)
      (%MULTIPLE-VALUE-CALL-N
	VALUES
	(%UNBOXED-INTEGER-VALUES 2
	  (%UNBOXED-DPB (%POSITIVE-INTEGER 1) %%DOUBLE-FRAC-N-BIT
			(%UNBOXED-CONSTANT-LEFT-SHIFT
			  (%POSITIVE-INTEGER
			    WORD-LOW
			    (%LOGLDB %%DOUBLE-FRACTION-HIGH WORD-HIGH))
			  (BYTE-POSITION %%DOUBLE-FRAC-FIELD))))
	2
	BIASED-EXPT
	1)))

;;; Shift the fraction to the right by (- LEFT-SHIFT-AMOUNT)
(DEFSUBST DOUBLE-STICKY-RIGHT-SHIFT (FRAC-LOW FRAC-HIGH LEFT-SHIFT-AMOUNT)
  (DECLARE (VALUES FRAC-LOW FRAC-HIGH))
  (%UNBOXED-INTEGER-VALUES 2
    (IF (< LEFT-SHIFT-AMOUNT -63.)
	;; Going off the end.  Know that S bit is low-order, FRAC non-negative
	(%POSITIVE-INTEGER
	  (IF (ZEROP (LOGIOR FRAC-LOW FRAC-HIGH))
	      0
	      1)
	  0)
	(IF ( LEFT-SHIFT-AMOUNT -31.)
	    (%UNBOXED-DPB
	      (%POSITIVE-INTEGER
		(IF (ZEROP (LOGAND (LSH -1 (- -31. LEFT-SHIFT-AMOUNT)) FRAC-LOW)) 0 1))
	      %%DOUBLE-FRAC-S-BIT
	      (%UNBOXED-RIGHT-SHIFT
		(%POSITIVE-INTEGER FRAC-LOW FRAC-HIGH)
		(- LEFT-SHIFT-AMOUNT)))
	    (%POSITIVE-INTEGER
	      (DPB (IF (ZEROP (LOGAND (LSH -1 (- -31. (- LEFT-SHIFT-AMOUNT -32.))) FRAC-HIGH))
		       0 1)
		   %%DOUBLE-FRAC-S-BIT
		   (LSH FRAC-HIGH (- LEFT-SHIFT-AMOUNT -32.)))
	      0)))))

(DEFSUBST DOUBLE-NORMALIZE-INTERNAL-FRACTION-SHIFT-AMOUNT (FRAC-LOW FRAC-HIGH)
  (IF (ZEROP FRAC-HIGH)
      (LOOP FOR BITS-ROT FIRST (ROT FRAC-LOW 4) THEN (ROT BITS-ROT 4)
	    FOR SHIFT FROM (- (+ (BYTE-POSITION %%DOUBLE-FRAC-N-BIT)
				 (BYTE-SIZE %%DOUBLE-FRAC-N-BIT)) 32.) BY 4.
	    DOING
	(LET ((BITS (LOGAND BITS-ROT #O17)))
	  (UNLESS (ZEROP BITS)
	    ;; Found something
	    (RETURN-FROM DOUBLE-NORMALIZE-INTERNAL-FRACTION-SHIFT-AMOUNT
	      (+ SHIFT (%LOGLDB (BYTE 2. 30.)
				(ROT #B00111010010101010000000000000000
				     (ROT BITS 1))))))))
      (LOOP FOR BITS-ROT FIRST (ROT FRAC-HIGH (- (+ (BYTE-POSITION %%DOUBLE-FRAC-N-BIT)
						    (BYTE-SIZE %%DOUBLE-FRAC-N-BIT)
						    -32.
						    -4.)))
			 THEN (ROT BITS-ROT 4.)
	    FOR SHIFT FROM 0 BY 4.
	    DOING
	(LET ((BITS (LOGAND BITS-ROT #O17)))
	  (UNLESS (ZEROP BITS)
	    (RETURN-FROM DOUBLE-NORMALIZE-INTERNAL-FRACTION-SHIFT-AMOUNT
	      (+ SHIFT (%LOGLDB (BYTE 2. 30.)
				(ROT #B00111010010101010000000000000000
				     (ROT BITS 1))))))))))

(DEFUN DOUBLE-NORMALIZE-INTERNAL-FRACTION (FRAC-LOW FRAC-HIGH BIASED-EXPT)
  (DECLARE (VALUES FRAC-LOW FRAC-HIGH BIASED-EXPT))
  (LET ((SHIFT-AMOUNT (DOUBLE-NORMALIZE-INTERNAL-FRACTION-SHIFT-AMOUNT FRAC-LOW FRAC-HIGH)))
    (%MULTIPLE-VALUE-CALL-N
      VALUES
      (IF ( SHIFT-AMOUNT 32.)
	  (%UNBOXED-INTEGER-VALUES 2
	    (%UNBOXED-LEFT-SHIFT
	      (%POSITIVE-INTEGER FRAC-LOW FRAC-HIGH)
	      SHIFT-AMOUNT))
	  (VALUES 0 (ROT FRAC-LOW (- SHIFT-AMOUNT 32.))))
      2
      (- BIASED-EXPT SHIFT-AMOUNT)
      1)))

;;; Assumes everything is checked for overflow, underflow, etc.
(DEFSUBST MAKE-DOUBLE-FLOAT (SIGN FRAC-LOW FRAC-HIGH BIASED-EXPT)
  (MACROLET ((SWAP-VALS (VALS &ENVIRONMENT ENVIRONMENT)
	       (WITH-UNBOXED-INTEGERS (((SIGN COMPONENTS) VALS)) ENVIRONMENT
		 `(%POSITIVE-INTEGER ,@(REVERSE COMPONENTS)))))
    (%UNBOXED-INTEGER-VALUES 2
      (%UNBOXED-DPB (%POSITIVE-INTEGER SIGN) %%DOUBLE-SIGN
		    (%UNBOXED-DPB (%POSITIVE-INTEGER BIASED-EXPT) %%DOUBLE-EXPONENT
				  (SWAP-VALS
				    (%UNBOXED-LDB %%DOUBLE-FRAC-FIELD
						  (%POSITIVE-INTEGER FRAC-LOW FRAC-HIGH))))))))

(DEFUN DOUBLE-FLOAT-OVERFLOW-VALUE (SIGN)
  (SI:DFLOAT-COMPONENTS
    (SELECT (LDB %%FLOAT-ROUNDING-MODE FLOAT-OPERATING-MODE)
      (%FLOAT-ROUNDING-MODE-NEAREST
       (IF (ZEROP SIGN)
	   SI:INFINITE-POSITIVE-DOUBLE-FLOAT
	   SI:INFINITE-NEGATIVE-DOUBLE-FLOAT))
      (%FLOAT-ROUNDING-MODE-PLUS
       (IF (ZEROP SIGN)
	   SI:INFINITE-POSITIVE-DOUBLE-FLOAT
	   SI:MOST-NEGATIVE-DOUBLE-FLOAT))
      (%FLOAT-ROUNDING-MODE-MINUS
       (IF (ZEROP SIGN)
	   SI:MOST-POSITIVE-DOUBLE-FLOAT
	   SI:INFINITE-NEGATIVE-DOUBLE-FLOAT))
      (%FLOAT-ROUNDING-MODE-ZERO
       (IF (ZEROP SIGN)
	   SI:MOST-POSITIVE-DOUBLE-FLOAT
	   SI:MOST-NEGATIVE-DOUBLE-FLOAT)))))

(DEFUN DOUBLE-FLOAT-UNWRAP (RESULT-HIGH RESULT-LOW INEXACT-P)
  (LET ((SIGN (%LOGLDB %%DOUBLE-SIGN RESULT-HIGH)))
    (DECLARE (SPECIAL ZL:ZUNDERFLOW))
    (WHEN ZL:ZUNDERFLOW
      (SETF FLOAT-OPERATION-STATUS
	    (LOGIOR FLOAT-OPERATION-STATUS
		    (%LOGDPBS 1 %%FLOAT-SIGNAL-UNDERFLOW
			      1 %%FLOAT-SIGNAL-INEXACT-RESULT
			      0)))
      (RETURN-FROM DOUBLE-FLOAT-UNWRAP
	(MAKE-DOUBLE-FLOAT SIGN 0 0 0)))
    (LET* ((MODE FLOAT-OPERATING-MODE)
	   (EXPONENT (%LOGLDB %%DOUBLE-EXPONENT RESULT-HIGH))
	   (FINAL-EXPT (%LOGDPB (- (LDB (BYTE 1. 10.) EXPONENT)) (BYTE 21. 11.) EXPONENT)))
      (MULTIPLE-VALUE-BIND (FINAL-FRAC-LOW FINAL-FRAC-HIGH)
	  (%UNBOXED-INTEGER-VALUES 2
	    (%UNBOXED-DPB (%POSITIVE-INTEGER 1) %%DOUBLE-FRAC-N-BIT
			  (%UNBOXED-CONSTANT-LEFT-SHIFT
			    (%POSITIVE-INTEGER
			      RESULT-LOW
			      (%LOGLDB %%DOUBLE-FRACTION-HIGH RESULT-HIGH))
			    (BYTE-POSITION %%DOUBLE-FRAC-FIELD))))
	(MULTIPLE-VALUE-BIND (ROUNDED-FRAC-LOW ROUNDED-FRAC-HIGH ROUNDED-EXPT INEXACT)
	    (%MULTIPLE-VALUE-CALL-N
	      DOUBLE-FLOAT-ROUND
	      SIGN 1
	      (DOUBLE-STICKY-RIGHT-SHIFT
		(LOGIOR FINAL-FRAC-LOW
			(IF (AND INEXACT-P
				 (= (LDB %%FLOAT-ROUNDING-MODE MODE)
				    %FLOAT-ROUNDING-MODE-NEAREST))
			    1
			    0))
		FINAL-FRAC-HIGH (1- FINAL-EXPT)) 2
	      0 1)
	  (IF (LDB-TEST %%FLOAT-TRAP-ENABLE-UNDERFLOW FLOAT-OPERATING-MODE)
	      (SETQ FLOAT-OPERATION-STATUS
		    (LOGIOR FLOAT-OPERATION-STATUS
			    (IF (OR INEXACT INEXACT-P)
				(%LOGDPBS 1 %%FLOAT-SIGNAL-UNDERFLOW
					  1 %%FLOAT-SIGNAL-INEXACT-RESULT 0)
				(%LOGDPBS 1 %%FLOAT-SIGNAL-UNDERFLOW
					  0 %%FLOAT-SIGNAL-INEXACT-RESULT 0))))
	      (WHEN (OR INEXACT INEXACT-P)
		(SETQ FLOAT-OPERATION-STATUS
		      (LOGIOR FLOAT-OPERATION-STATUS
			      (%LOGDPBS 1 %%FLOAT-SIGNAL-UNDERFLOW
					1 %%FLOAT-SIGNAL-INEXACT-RESULT 0)))))
	  (%MULTIPLE-VALUE-CALL-N
	    VALUES
	    (MAKE-DOUBLE-FLOAT SIGN ROUNDED-FRAC-LOW ROUNDED-FRAC-HIGH ROUNDED-EXPT) 2
	    SIGN 1
	    FINAL-FRAC-LOW 1
	    FINAL-FRAC-HIGH 1
	    FINAL-EXPT 1))))))

(DEFUN DOUBLE-FLOAT-NORMALIZE (SIGN FRAC-LOW FRAC-HIGH EXPT)
  (DECLARE (VALUES RESULT-HIGH RESULT-LOW))
  (DECLARE (SPECIAL ZL:ZUNDERFLOW))
  (WHEN (AND (ZEROP FRAC-LOW)
	     (ZEROP FRAC-HIGH))
    (RETURN-FROM DOUBLE-FLOAT-NORMALIZE
      (VALUES
	(%LOGDPB SIGN %%DOUBLE-SIGN 0)
	0)))
  (LET* ((SHIFT-AMOUNT (DOUBLE-NORMALIZE-INTERNAL-FRACTION-SHIFT-AMOUNT FRAC-LOW FRAC-HIGH))
	 (FINAL-EXPT (- EXPT SHIFT-AMOUNT)))
    (MULTIPLE-VALUE-BIND (FINAL-FRAC-LOW FINAL-FRAC-HIGH)
	(IF ( SHIFT-AMOUNT 32.)
	    (%UNBOXED-INTEGER-VALUES 2
	      (%UNBOXED-LEFT-SHIFT
		(%POSITIVE-INTEGER FRAC-LOW FRAC-HIGH)
		SHIFT-AMOUNT))
	    (VALUES 0 (ROT FRAC-LOW (- SHIFT-AMOUNT 32.))))
      (IF (PLUSP FINAL-EXPT)
	  (MULTIPLE-VALUE-BIND (FRAC-LOW FRAC-HIGH EXPT INEXACT)
	      (DOUBLE-FLOAT-ROUND SIGN FINAL-FRAC-LOW FINAL-FRAC-HIGH FINAL-EXPT)
	    (COND (( EXPT %DOUBLE-EXPONENT-MAX)
		   (SETF FLOAT-OPERATION-STATUS
			 (LOGIOR FLOAT-OPERATION-STATUS
				 (%LOGDPBS 1 %%FLOAT-SIGNAL-OVERFLOW
					   1 %%FLOAT-SIGNAL-INEXACT-RESULT
					   0)))
		   (RETURN-FROM DOUBLE-FLOAT-NORMALIZE
		     (%MULTIPLE-VALUE-CALL-N
		       VALUES
		       (DOUBLE-FLOAT-OVERFLOW-VALUE SIGN) 2
		       SIGN 1
		       FRAC-HIGH 1
		       FRAC-LOW 1
		       EXPT 1)))
		  (T
		   (WHEN INEXACT
		     (SETF (LDB-TEST %%FLOAT-SIGNAL-INEXACT-RESULT FLOAT-OPERATION-STATUS)
			   T))
		   (MAKE-DOUBLE-FLOAT SIGN FRAC-LOW FRAC-HIGH EXPT))))
	  (COND (ZL:ZUNDERFLOW
		 (SETF FLOAT-OPERATION-STATUS
		       (LOGIOR FLOAT-OPERATION-STATUS
			       (%LOGDPBS 1 %%FLOAT-SIGNAL-UNDERFLOW
					 1 %%FLOAT-SIGNAL-INEXACT-RESULT
					 0)))
		 (MAKE-DOUBLE-FLOAT SIGN 0 0 0))
		(T
		 (MULTIPLE-VALUE-BIND (ROUNDED-FRAC-LOW ROUNDED-FRAC-HIGH ROUNDED-EXPT INEXACT)
		     (%MULTIPLE-VALUE-CALL-N
		       DOUBLE-FLOAT-ROUND
		       SIGN 1
		       (DOUBLE-STICKY-RIGHT-SHIFT
			 FINAL-FRAC-LOW FINAL-FRAC-HIGH (1- FINAL-EXPT)) 2
		       0 1)
		   (IF (LDB-TEST %%FLOAT-TRAP-ENABLE-UNDERFLOW FLOAT-OPERATING-MODE)
		       (SETQ FLOAT-OPERATION-STATUS
			     (LOGIOR FLOAT-OPERATION-STATUS
				     (IF INEXACT
					 (%LOGDPBS 1 %%FLOAT-SIGNAL-UNDERFLOW
						   1 %%FLOAT-SIGNAL-INEXACT-RESULT 0)
					 (%LOGDPBS 1 %%FLOAT-SIGNAL-UNDERFLOW
						   0 %%FLOAT-SIGNAL-INEXACT-RESULT 0))))
		       (WHEN INEXACT
			 (SETQ FLOAT-OPERATION-STATUS
			       (LOGIOR FLOAT-OPERATION-STATUS
				       (%LOGDPBS 1 %%FLOAT-SIGNAL-UNDERFLOW
						 1 %%FLOAT-SIGNAL-INEXACT-RESULT 0)))))
		   (%MULTIPLE-VALUE-CALL-N
		     VALUES
		     (MAKE-DOUBLE-FLOAT SIGN ROUNDED-FRAC-LOW ROUNDED-FRAC-HIGH ROUNDED-EXPT) 2
		     SIGN 1
		     FINAL-FRAC-LOW 1
		     FINAL-FRAC-HIGH 1
		     FINAL-EXPT 1))))))))

;;; Quick version for clearing overflows
(DEFMACRO DOUBLE-NORMALIZE-FOR-OVERFLOW (FRAC-LOW FRAC-HIGH EXPT)
  `(UNLESS (%UNBOXED-ZEROP (%UNBOXED-LDB %%DOUBLE-FRAC-V-BIT
					 (%POSITIVE-INTEGER ,FRAC-LOW ,FRAC-HIGH)))
     (INCF ,EXPT)
     (MULTIPLE-VALUE-SETQ (,FRAC-LOW ,FRAC-HIGH)
       (%UNBOXED-INTEGER-VALUES 2
	 (%UNBOXED-LOGIOR
	   (%UNBOXED-LDB %%DOUBLE-FRAC-S-BIT (%POSITIVE-INTEGER ,FRAC-LOW ,FRAC-HIGH))
	   (%UNBOXED-LDB (BYTE 63. 1.) (%POSITIVE-INTEGER ,FRAC-LOW ,FRAC-HIGH)))))))

(DEFUN DOUBLE-FLOAT-ROUND (SIGN FRAC-LOW FRAC-HIGH EXPT)
  (DECLARE (VALUES FRAC-LOW FRAC-HIGH EXPT INEXACT))
  (LET* ((GRS (%UNBOXED-INTEGER-VALUES 1
		(%UNBOXED-LDB %%DOUBLE-FRAC-GRS (%POSITIVE-INTEGER FRAC-LOW FRAC-HIGH))))
	 (ROUND-FRAC (- FRAC-LOW GRS)))
    (WHEN (ZEROP GRS)
      ;; Easy case -- We're already exact
      (RETURN-FROM DOUBLE-FLOAT-ROUND (VALUES ROUND-FRAC FRAC-HIGH EXPT NIL)))
    (LET* ((MODE (FLOAT-OPERATING-MODE))
	   (ROUNDING-MODE (%LOGLDB %%FLOAT-ROUNDING-MODE MODE)))
      (WHEN (OR (AND (= ROUNDING-MODE %FLOAT-ROUNDING-MODE-NEAREST)
		     (OR ( GRS #B011)
			 (= (LDB %%DOUBLE-FRAC-ROUND-DISPATCH FRAC-LOW) #B0100)))
		(= ROUNDING-MODE %FLOAT-ROUNDING-MODE-ZERO)
		(AND (= ROUNDING-MODE %FLOAT-ROUNDING-MODE-PLUS)
		     (NOT (ZEROP SIGN)))
		(AND (= ROUNDING-MODE %FLOAT-ROUNDING-MODE-MINUS)
		     (ZEROP SIGN)))
	;; Close enough for government work
	(RETURN-FROM DOUBLE-FLOAT-ROUND (VALUES ROUND-FRAC FRAC-HIGH EXPT T)))
      ;; Have to increment the fraction
      (UNLESS (MINUSP ROUND-FRAC)
	;; No chance of overflow
	(RETURN-FROM DOUBLE-FLOAT-ROUND
	  (VALUES (%32-BIT-PLUS ROUND-FRAC (DPB 1 %%DOUBLE-FRAC-L-BIT 0))
		  FRAC-HIGH
		  EXPT
		  T)))
      (LET ((FRAC-LOW (%32-BIT-PLUS ROUND-FRAC (DPB 1 %%DOUBLE-FRAC-L-BIT 0))))
	(WHEN (MINUSP FRAC-LOW)
	  ;; We are still minus, so there was no overflow
	  (RETURN-FROM DOUBLE-FLOAT-ROUND (VALUES FRAC-LOW FRAC-HIGH EXPT T)))
	;; There was an overflow
	(LET ((FRAC-HIGH (1+ FRAC-HIGH)))
	  (IF (NOT (%UNBOXED-ZEROP
		     (%UNBOXED-LDB %%DOUBLE-FRAC-FIELD
				   (%POSITIVE-INTEGER FRAC-LOW FRAC-HIGH))))
	      (VALUES FRAC-LOW FRAC-HIGH EXPT T)
	      ;; FRAC is zero, so it doesn't need to be shifted
	      (VALUES FRAC-LOW FRAC-HIGH (1+ EXPT) T)))))))

(DEFSUBST DOUBLE-FLOAT-NAN-P (HIGH LOW
				 &OPTIONAL
				 (EXPT-MAX %DOUBLE-EXPONENT-MAX)
				 (EXPONENT (%LOGLDB %%DOUBLE-EXPONENT HIGH)))
  (AND (= EXPONENT EXPT-MAX)
       ;; Filter out infinity
       (NOT (AND (ZEROP LOW)
		 (ZEROP (%LOGLDB %%DOUBLE-FRACTION-HIGH HIGH))))))

(DEFSUBST DOUBLE-FLOAT-ZEROP (HIGH LOW)
  (AND (ZEROP LOW)
       (ZEROP (%LOGLDB %%DOUBLE-EXCEPT-SIGN-HIGH HIGH))))				 

(DEFUN %CONVERT-SINGLE-TO-DOUBLE (SINGLE)
  (DECLARE (VALUES RESULT-HIGH RESULT-LOW))
  #-VLM
  (PROGN
    (%FPA-START CONVERT-SINGLE-TO-DOUBLE-ROUNDING SINGLE)
    (WHEN (FP-COPROCESSOR-ENABLED-P)
      (%FPA-WAIT CONVERT-SINGLE-TO-DOUBLE-ROUNDING :AFTER-TEST T)
      (LET ((RESULT-HIGH (%FPA-DOUBLE-RESULT-HIGH CONVERT-SINGLE-TO-DOUBLE-ROUNDING)))
	(WHEN (TYPEP RESULT-HIGH 'SINGLE-FLOAT)
	  ;; The compiler knows RESULT-HIGH is TOS, so it doesn't need to push it to do
	  ;; anything here.
	  (SETQ RESULT-HIGH (%FIXNUM RESULT-HIGH))
	  (RETURN-FROM %CONVERT-SINGLE-TO-DOUBLE
	    (VALUES RESULT-HIGH
		    (%FIXNUM (%FPA-DOUBLE-RESULT-LOW CONVERT-SINGLE-TO-DOUBLE-ROUNDING)))))
	(LET ((STICKY-BITS (%FPA-STICKY-BITS-REGISTER)))
	  (COMPILER:%ERROR-UNLESS (LDB-TEST %%W3X64-DENORMALIZED-INPUT-FLAG STICKY-BITS)
	    (ERROR "Unexpected FPA condition"))
	  (UPDATE-FLOAT-OPERATION-STATUS STICKY-BITS)
	  (%FPA-START CONVERT-SINGLE-TO-DOUBLE-ROUNDING
		      ;; "wrap" the denorm using the FPA
		      (- (%FLONUM (DPB 193 %%SINGLE-EXPONENT (%FIXNUM SINGLE)))
			 (%FLONUM (DPB 193 %%SINGLE-EXPONENT 0))))
	  (%FPA-WAIT CONVERT-SINGLE-TO-DOUBLE-ROUNDING)
	  (MULTIPLE-VALUE-BIND (WRAPPED-HIGH WRAPPED-LOW)
	      (%FPA-DOUBLE-RESULT CONVERT-SINGLE-TO-DOUBLE-ROUNDING)
	    (RETURN-FROM %CONVERT-SINGLE-TO-DOUBLE
	      (VALUES (- WRAPPED-HIGH (DPB 192 %%DOUBLE-EXPONENT 0))
		      WRAPPED-LOW)))))))
  (SETQ SINGLE (%FIXNUM SINGLE))
  (COMPILER:%ERROR-WHEN (ZEROP (%LOGLDB %%SINGLE-EXPONENT SINGLE))
    (RETURN-FROM %CONVERT-SINGLE-TO-DOUBLE
      (IF (ZEROP (%LOGLDB %%SINGLE-FRACTION SINGLE))
	  (VALUES (DPB 0 %%DOUBLE-EXCEPT-SIGN-HIGH SINGLE)
		  0)
	  ;; denormalized single
	  ;; wrap it the hard way, since we don't have the FPA to do the float subtract
	  (LET* ((LEFTMOST-ONE (FIXNUM-LEFTMOST-ONE (%LOGLDB %%SINGLE-FRACTION SINGLE)))
		 ;; put leftmost one in the hidden bit
		 (NORM (LSH SINGLE (- (+ (BYTE-SIZE %%SINGLE-FRACTION) 1) LEFTMOST-ONE))))
	    (VALUES (%LOGDPBS (+ LEFTMOST-ONE
				 (- %DOUBLE-EXPONENT-BIAS %SINGLE-EXPONENT-BIAS
				    (BYTE-SIZE %%SINGLE-FRACTION)))
			      %%DOUBLE-EXPONENT
			      (LDB (BYTE (BYTE-SIZE %%DOUBLE-FRACTION-HIGH)
					 (- (BYTE-SIZE %%SINGLE-FRACTION)
					    (BYTE-SIZE %%DOUBLE-FRACTION-HIGH)))
				   NORM)
			      %%DOUBLE-FRACTION-HIGH
			      SINGLE)
		    (%LOGDPB NORM
			     (BYTE (- (BYTE-SIZE %%SINGLE-FRACTION)
				      (BYTE-SIZE %%DOUBLE-FRACTION-HIGH))
				   (- 32 (- (BYTE-SIZE %%SINGLE-FRACTION)
					    (BYTE-SIZE %%DOUBLE-FRACTION-HIGH))))
			     0))))))
  (COMPILER:%ERROR-WHEN (= (%LOGLDB %%SINGLE-EXPONENT SINGLE) %SINGLE-EXPONENT-MAX)
    ;; Could be a NAN or 
    (RETURN-FROM %CONVERT-SINGLE-TO-DOUBLE
      (VALUES
	(%LOGDPBS %DOUBLE-EXPONENT-MAX %%DOUBLE-EXPONENT
		  0 %%DOUBLE-FRACTION-HIGH
		  SINGLE)
	(%LOGLDB %%SINGLE-FRACTION SINGLE))))
  (VALUES (%LOGDPBS (+ (%LOGLDB %%SINGLE-EXPONENT SINGLE)
		       (- %DOUBLE-EXPONENT-BIAS %SINGLE-EXPONENT-BIAS))
		    %%DOUBLE-EXPONENT
		    (LDB (BYTE (BYTE-SIZE %%DOUBLE-FRACTION-HIGH)
			       (- (BYTE-SIZE %%SINGLE-FRACTION)
				  (BYTE-SIZE %%DOUBLE-FRACTION-HIGH)))
			 SINGLE)
		    %%DOUBLE-FRACTION-HIGH
		    SINGLE)
	  (%LOGDPB SINGLE
		   (BYTE (- (BYTE-SIZE %%SINGLE-FRACTION)
			    (BYTE-SIZE %%DOUBLE-FRACTION-HIGH))
			 (- 32 (- (BYTE-SIZE %%SINGLE-FRACTION)
				  (BYTE-SIZE %%DOUBLE-FRACTION-HIGH))))
		   0)))

(DEFUN %CONVERT-DOUBLE-TO-SINGLE (X-HIGH X-LOW)
  (COMPILER:%ERROR-WHEN (DOUBLE-FLOAT-ZEROP X-HIGH X-LOW)
    (RETURN-FROM %CONVERT-DOUBLE-TO-SINGLE
      (%FLONUM X-HIGH)))
  (COMPILER:%ERROR-WHEN (= (%LOGLDB %%DOUBLE-EXPONENT X-HIGH) %DOUBLE-EXPONENT-MAX)
    (RETURN-FROM %CONVERT-DOUBLE-TO-SINGLE
      (%FLONUM (%LOGDPB (IF (AND (ZEROP X-LOW)
				 (ZEROP (LDB %%DOUBLE-FRACTION-HIGH X-HIGH)))
			    0
			    (IF (ZEROP (LDB %%SINGLE-FRACTION X-LOW))
				-1
				X-LOW))
			%%SINGLE-FRACTION
			;; already has correct sign and exponent bits
			X-HIGH))))
  (SINGLE-FLOAT-HANDLE-EXCEPTIONS (%CONVERT-DOUBLE-TO-SINGLE X-HIGH X-LOW)
    (CLEAR-FLOAT-SIGNALS)
    (LET ((SIGN (%LOGLDB %%DOUBLE-SIGN X-HIGH))
	  (SINGLE-FRAC (LOGIOR (%LOGDPB 1
					(BYTE (- 32 (BYTE-POSITION %%FRAC-N-BIT))
					      (BYTE-POSITION %%FRAC-N-BIT))
					(%LSHC-BIGNUM-STEP
					  X-LOW X-HIGH
					  (+ (- (BYTE-SIZE %%SINGLE-FRACTION)
						(BYTE-SIZE %%DOUBLE-FRACTION-HIGH))
					     3)))
			       ;; compress the rest into the sticky bit
			       (LDB (BYTE 1 31)
				    (- (LDB (BYTE (- (+ (BYTE-SIZE %%DOUBLE-FRACTION-HIGH) 32)
						     (BYTE-SIZE %%SINGLE-FRACTION))
						  0)
					    X-LOW))))))
      ;; --- detect and handle exceptions
      (VALUES (SINGLE-FLOAT-NORMALIZE SIGN SINGLE-FRAC (+ (%LOGLDB %%DOUBLE-EXPONENT X-HIGH)
							  (- %SINGLE-EXPONENT-BIAS
							     %DOUBLE-EXPONENT-BIAS)))))))

(DEFUN %CONVERT-DOUBLE-TO-FIXNUM (X-HIGH X-LOW)
  (COMPILER:%ERROR-WHEN (DOUBLE-FLOAT-ZEROP X-HIGH X-LOW)
    (RETURN-FROM %CONVERT-DOUBLE-TO-FIXNUM 0))
  (LET ((SIGN (%LOGLDB %%DOUBLE-SIGN X-HIGH)))
    (MULTIPLE-VALUE-BIND (FRAC-LOW FRAC-HIGH BIASED-EXPT)
	(DOUBLE-FLOAT-FRAC-AND-EXPONENT X-LOW X-HIGH)
      (COMPILER:%ERROR-WHEN (= BIASED-EXPT %DOUBLE-EXPONENT-MAX)
	(RETURN-FROM %CONVERT-DOUBLE-TO-FIXNUM
	  (SIGNAL-PROCEED-CASE ((VALUE)
				'FLOAT-INVALID-OPERATION
				':OPERATION '%CONVERT-SINGLE-TO-FIXNUM
				':NON-TRAP-RESULT 0
				':OPERANDS (LIST X-HIGH X-LOW)
				':SAVED-FLOAT-OPERATION-STATUS (FLOAT-OPERATION-STATUS))
	    (:NEW-VALUE VALUE))))
      (LET ((SHIFT-AMOUNT (- BIASED-EXPT %DOUBLE-EXPONENT-BIAS
			     (BYTE-SIZE %%DOUBLE-FRAC-FIELD))))
	(WHEN (< SHIFT-AMOUNT 0)
	  ;; Need to round if there is any fractional part being shifted out
	  ;; Get the "1" bit aligned with the "L" bit
	  (MULTIPLE-VALUE-BIND (ROUND-FRAC-LOW ROUND-FRAC-HIGH NIL INEXACT)
	      ;; Make it look like a denormalized number to the rounder
	      (%MULTIPLE-VALUE-CALL-N
		DOUBLE-FLOAT-ROUND
		SIGN 1
		(DOUBLE-STICKY-RIGHT-SHIFT
		  FRAC-LOW FRAC-HIGH SHIFT-AMOUNT) 2
		0 1)
	    (WHEN INEXACT
	      (SETF (LDB-TEST %%FLOAT-FLAG-INEXACT-RESULT FLOAT-OPERATION-STATUS) 1))
	    (SETQ FRAC-LOW ROUND-FRAC-LOW
		  FRAC-HIGH ROUND-FRAC-HIGH
		  SHIFT-AMOUNT 0)))
	;; Now shift-amount is the amount we will have to shift the fraction to get the
	;; answer (plus three to the right for the GRS bits)
	(MULTIPLE-VALUE-BIND (LOW HIGH)
	    (%UNBOXED-INTEGER-VALUES 2
	      (%UNBOXED-LDB %%DOUBLE-FRAC-FIELD+N-BIT (%POSITIVE-INTEGER FRAC-LOW FRAC-HIGH)))
	  (COMPILER:%ERROR-WHEN (AND (ZEROP LOW) (ZEROP HIGH))
	    (RETURN-FROM %CONVERT-DOUBLE-TO-FIXNUM 0))
	  ;; Now if the sign is negative, we need to do a twos complement
	  (UNLESS (= SIGN 0)
	    (MULTIPLE-VALUE-BIND (NEW-LOW BORROW)
		(%SUB-BIGNUM-STEP 0 LOW 0)
	      (SETQ LOW NEW-LOW)
	      (SETQ HIGH (%SUB-BIGNUM-STEP 0 HIGH BORROW))))
	  (ASH (IF (= HIGH (- SIGN))
		   (IF (= (%LOGLDB (BYTE 1 31.) LOW) SIGN)
		       LOW
		       (SI:%MAKE-BIGNUM-FROM-FIXNUM-COMPONENTS (- SIGN) 1 LOW))
		   (SI:%MAKE-BIGNUM-FROM-FIXNUM-COMPONENTS (- SIGN) 2 LOW HIGH))
	       SHIFT-AMOUNT))))))

(DEFUN %CONVERT-FIXNUM-TO-DOUBLE (NUMBER)
  (DECLARE (VALUES RESULT-HIGH RESULT-LOW))
  (CHECK-TYPE NUMBER FIXNUM)
  #-VLM
  (PROGN
    (%FPA-START CONVERT-FIXNUM-TO-DOUBLE-ROUNDING NUMBER)
    (WHEN (FP-COPROCESSOR-ENABLED-P)
      (%FPA-WAIT CONVERT-FIXNUM-TO-DOUBLE-ROUNDING :AFTER-TEST T)
      (RETURN-FROM %CONVERT-FIXNUM-TO-DOUBLE
	(%FPA-DOUBLE-RESULT CONVERT-FIXNUM-TO-DOUBLE-ROUNDING))))
  (COMPILER:%ERROR-WHEN (ZEROP NUMBER)
    (RETURN-FROM %CONVERT-FIXNUM-TO-DOUBLE (VALUES 0 0)))
  (LET* ((ABS-NUMBER (IF (MINUSP NUMBER)
			 (%32-BIT-DIFFERENCE 0 NUMBER)	;handle most-negative-fixnum
			 NUMBER))
	 (LEFTMOST-ONE (FIXNUM-LEFTMOST-ONE ABS-NUMBER))
	 (SHIFTED-NUMBER (ROT ABS-NUMBER
			      (- (1+ (BYTE-SIZE %%DOUBLE-FRACTION-HIGH)) LEFTMOST-ONE))))
    (VALUES (%LOGDPBS (+ (- %DOUBLE-EXPONENT-BIAS 1) LEFTMOST-ONE)
		      %%DOUBLE-EXPONENT
		      SHIFTED-NUMBER
		      %%DOUBLE-FRACTION-HIGH
		      NUMBER)
	    (%LOGDPB 0 (BYTE (1+ (BYTE-SIZE %%DOUBLE-FRACTION-HIGH)) 0) SHIFTED-NUMBER))))

;;; Return -1 if X < Y, 0 if X = Y, 1 if X > Y, and 2 if there is an NAN
(DEFUN %DOUBLE-FLOATING-COMPARE (X-HIGH X-LOW Y-HIGH Y-LOW)
  (COMPILER:%ERROR-WHEN (LET ((EXPT-MAX %DOUBLE-EXPONENT-MAX))
			  (OR (DOUBLE-FLOAT-NAN-P X-HIGH X-LOW EXPT-MAX)
			      (DOUBLE-FLOAT-NAN-P Y-HIGH Y-LOW EXPT-MAX)))
    ;; There is an NAN involved
    (RETURN-FROM %DOUBLE-FLOATING-COMPARE 2))
  (COMPILER:%ERROR-WHEN (AND (DOUBLE-FLOAT-ZEROP X-HIGH X-LOW)
			     (DOUBLE-FLOAT-ZEROP Y-HIGH Y-LOW))
    ;; -0.0 and 0.0 are the same for this
    (RETURN-FROM %DOUBLE-FLOATING-COMPARE 0))
  (WHEN (= X-HIGH Y-HIGH)
    ;; The exponents and signs are the same.  The low word only contains
    ;; part of the fraction, so this degenerates to the unsigned fixnum case.
    (RETURN-FROM %DOUBLE-FLOATING-COMPARE
      (COND ((= X-LOW Y-LOW) 0)
	    ((%UNSIGNED-LESSP X-LOW Y-LOW)
	     (IF (MINUSP X-HIGH) 1 -1))
	    (T (IF (MINUSP X-HIGH) -1 1)))))
  ;; X-HIGH and Y-HIGH are different, so X-LOW and Y-LOW don't matter.
  ;; Trick:  These are normalized.  If X-EXP rel Y-EXP, then |X| rel |Y|, unless rel
  ;; is =, in which case if X-FRAC rel Y-FRAC, then |X| rel |Y|.  The EXPT field is
  ;; higher order than the FRAC field, so if X and Y are of the same sign, then
  ;; X-HIGH rel Y-HIGH means |X| rel |Y|.
  (IF (MINUSP X-HIGH)
      (IF (MINUSP Y-HIGH)
	  (IF (< X-HIGH Y-HIGH) 1 -1)		;X,Y < 0
	  -1)					;X<0, Y 0
      (IF (MINUSP Y-HIGH)
	  1					;X0, Y<0
	  (IF (< X-HIGH Y-HIGH) -1 1))))	;X,Y > 0

(DEFUN %DOUBLE-FLOATING-ABS (X-HIGH X-LOW)
  (VALUES (%LOGDPB 0 %%DOUBLE-SIGN X-HIGH)
	  X-LOW))

(DEFUN DOUBLE-FLOAT-ADD-INTERNAL (X-HIGH X-LOW Y-HIGH Y-LOW)
  (DECLARE (VALUES RESULT-HIGH RESULT-LOW))
  #+VLM
  (MULTIPLE-VALUE-BIND (HIGH LOW EXCEPTION)
      (%DOUBLE-FLOAT-OP X-HIGH X-LOW Y-HIGH Y-LOW
			%DOUBLE-FLOAT-OP-ADD)
    ;; If there was no exception, return the result.  If there was an exception,
    ;; simulate the whole shebang so that we signal the proper exception.
    (UNLESS EXCEPTION
      (RETURN-FROM DOUBLE-FLOAT-ADD-INTERNAL
	(VALUES HIGH LOW))))
  (IF (MINUSP (LOGXOR X-HIGH Y-HIGH))
      (LET ((X-BUT-SIGN (%LOGLDB %%DOUBLE-EXCEPT-SIGN-HIGH X-HIGH))
	    (Y-BUT-SIGN (%LOGLDB %%DOUBLE-EXCEPT-SIGN-HIGH Y-HIGH)))
	(WHEN (AND (ZEROP X-BUT-SIGN) (ZEROP X-LOW))
	  (RETURN-FROM DOUBLE-FLOAT-ADD-INTERNAL
	    (IF (AND (ZEROP Y-BUT-SIGN) (ZEROP Y-LOW))
		(VALUES
		  (IF (= (%LOGLDB %%FLOAT-ROUNDING-MODE (FLOAT-OPERATING-MODE))
			 %FLOAT-ROUNDING-MODE-MINUS)
		      (%LOGDPB 1 %%DOUBLE-SIGN 0)
		      0)
		  0)
		(VALUES Y-HIGH Y-LOW))))
	(WHEN (AND (ZEROP Y-BUT-SIGN) (ZEROP Y-LOW))
	  (RETURN-FROM DOUBLE-FLOAT-ADD-INTERNAL
	    (VALUES X-HIGH X-LOW)))
	;; Subtract the smaller thing from the bigger thing and take the sign of the
	;; bigger thing.
	(MULTIPLE-VALUE-BIND (SMALL-HIGH SMALL-LOW BIG-HIGH BIG-LOW SIGN)
	    (IF (OR (< X-BUT-SIGN Y-BUT-SIGN)
		    (AND (= X-BUT-SIGN Y-BUT-SIGN)
			 (%UNSIGNED-LESSP X-LOW Y-LOW)))
		(VALUES X-BUT-SIGN X-LOW Y-BUT-SIGN Y-LOW (%LOGLDB %%DOUBLE-SIGN Y-HIGH))
		(VALUES Y-BUT-SIGN Y-LOW X-BUT-SIGN X-LOW (%LOGLDB %%DOUBLE-SIGN X-HIGH)))
	  (LET ((SMALL-BIASED-EXPT (%LOGLDB %%DOUBLE-EXPONENT SMALL-HIGH))
		(BIG-BIASED-EXPT (%LOGLDB %%DOUBLE-EXPONENT BIG-HIGH)))
	    ;; Infinity and NAN handling
	    ;;
	    ;;                   BIG
	    ;;             NAN      | Finite
	    ;;           +-----+-----+--------
	    ;; S   NAN   | NAN | NAN |  NAN
	    ;; M         |     +-----+
	    ;; A        | NAN |ERROR|   
	    ;; L         +     +-----+--------
	    ;; L  Finite | NAN      | Finite
	    ;;
	    (LET ((EXPT-MAX %DOUBLE-EXPONENT-MAX))
	      (IF (= BIG-BIASED-EXPT EXPT-MAX)
		  (RETURN-FROM DOUBLE-FLOAT-ADD-INTERNAL
		    (IF (AND (ZEROP BIG-LOW)
			     (ZEROP (%LOGLDB %%DOUBLE-FRACTION-HIGH BIG-HIGH))
			     (= SMALL-BIASED-EXPT EXPT-MAX))
			(IF (AND (ZEROP SMALL-LOW)
				 (ZEROP (%LOGLDB %%DOUBLE-FRACTION-HIGH SMALL-HIGH)))
			    (PROGN
			      (SETF (LDB-TEST %%FLOAT-SIGNAL-INVALID-OPERATION
					      FLOAT-OPERATION-STATUS) T)
			      (MAKE-DOUBLE-FLOAT 0 -1 -1 %DOUBLE-EXPONENT-MAX))
			    (VALUES (%LOGDPB SIGN %%DOUBLE-SIGN SMALL-HIGH) SMALL-LOW))
			(VALUES (%LOGDPB SIGN %%DOUBLE-SIGN BIG-HIGH) BIG-LOW)))
		  (WHEN (= SMALL-BIASED-EXPT EXPT-MAX)
		    (RETURN-FROM DOUBLE-FLOAT-ADD-INTERNAL
		      (VALUES (%LOGDPB SIGN %%DOUBLE-SIGN SMALL-HIGH) SMALL-LOW)))))
	    (MULTIPLE-VALUE-BIND (BIG-FRAC-LOW BIG-FRAC-HIGH BIG-BIASED-EXPT)
		(DOUBLE-FLOAT-FRAC-AND-EXPONENT BIG-LOW BIG-HIGH BIG-BIASED-EXPT)
	      (MULTIPLE-VALUE-BIND (SMALL-FRAC-LOW SMALL-FRAC-HIGH SMALL-BIASED-EXPT)
		  (DOUBLE-FLOAT-FRAC-AND-EXPONENT SMALL-LOW SMALL-HIGH SMALL-BIASED-EXPT)
		(MULTIPLE-VALUE-BIND (SMALL-FRAC-LOW SMALL-FRAC-HIGH)
		    (DOUBLE-STICKY-RIGHT-SHIFT
		      SMALL-FRAC-LOW SMALL-FRAC-HIGH
		      (- SMALL-BIASED-EXPT BIG-BIASED-EXPT))
		  (MULTIPLE-VALUE-BIND (FRAC-LOW CARRY)
		      (%SUB-BIGNUM-STEP BIG-FRAC-LOW SMALL-FRAC-LOW 0)
		    (MULTIPLE-VALUE-BIND (FRAC-HIGH NIL)
			(%SUB-BIGNUM-STEP BIG-FRAC-HIGH SMALL-FRAC-HIGH CARRY)
		      (MULTIPLE-VALUE-BIND (RESULT-HIGH RESULT-LOW)
			  (DOUBLE-FLOAT-NORMALIZE SIGN FRAC-LOW FRAC-HIGH BIG-BIASED-EXPT)
			(IF (AND (ZEROP RESULT-LOW)
				 (ZEROP (%LOGLDB %%DOUBLE-EXCEPT-SIGN-HIGH RESULT-HIGH)))
			    (VALUES
			      (IF (= (%LOGLDB %%FLOAT-ROUNDING-MODE (FLOAT-OPERATING-MODE))
				     %FLOAT-ROUNDING-MODE-MINUS)
				  (%LOGDPB 1 %%DOUBLE-SIGN 0)
				  0)
			      0)
			    (VALUES RESULT-HIGH RESULT-LOW)))))))))))
      (LET* ((X-BIASED-EXPT (%LOGLDB %%DOUBLE-EXPONENT X-HIGH))
	     (Y-BIASED-EXPT (%LOGLDB %%DOUBLE-EXPONENT Y-HIGH)))
	(WHEN (DOUBLE-FLOAT-ZEROP X-HIGH X-LOW)
	  (RETURN-FROM DOUBLE-FLOAT-ADD-INTERNAL (VALUES Y-HIGH Y-LOW)))
	(WHEN (DOUBLE-FLOAT-ZEROP Y-HIGH Y-LOW)
	  (RETURN-FROM DOUBLE-FLOAT-ADD-INTERNAL (VALUES X-HIGH X-LOW)))
	(LET ((EXPT-MAX %DOUBLE-EXPONENT-MAX))
	  ;; Infinity and NAN handling
	  ;;
	  ;;                    X
	  ;;             NAN      | Finite
	  ;;           +-----+-----+--------
	  ;;     NAN   | NAN | NAN |  NAN
	  ;;           |     |     |
	  ;; Y        | NAN |    |   
	  ;;           +-----+-----+--------
	  ;;    Finite | NAN      | Finite
	  ;;
	  ;; If X is not finite then {if X is  and Y is not finite, Y is
	  ;; the result, else X} else if Y is not finite, then Y is the
	  ;; result.
	  (IF (= X-BIASED-EXPT EXPT-MAX)
	      (RETURN-FROM DOUBLE-FLOAT-ADD-INTERNAL
		(IF (AND (ZEROP X-LOW)
			 (ZEROP (%LOGLDB %%DOUBLE-FRACTION-HIGH X-HIGH))
			 (= Y-BIASED-EXPT EXPT-MAX))
		    (VALUES Y-HIGH Y-LOW)
		    (VALUES X-HIGH X-LOW)))
	      (WHEN (= Y-BIASED-EXPT EXPT-MAX)
		(RETURN-FROM DOUBLE-FLOAT-ADD-INTERNAL
		  (VALUES Y-HIGH Y-LOW)))))
	;; We want to shift the smaller magnitude number to the right to line it up with
	;; the larger magnitude number.  If the exponents are equal, we don't care.
	(MULTIPLE-VALUE-BIND (X-FRAC-LOW X-FRAC-HIGH X-BIASED-EXPT)
	    (DOUBLE-FLOAT-FRAC-AND-EXPONENT X-LOW X-HIGH X-BIASED-EXPT)
	  (MULTIPLE-VALUE-BIND (Y-FRAC-LOW Y-FRAC-HIGH Y-BIASED-EXPT)
	      (DOUBLE-FLOAT-FRAC-AND-EXPONENT Y-LOW Y-HIGH Y-BIASED-EXPT)
	    (MULTIPLE-VALUE-BIND (SMALL-FRAC-LOW SMALL-FRAC-HIGH SMALL-BIASED-EXPT
				  BIG-FRAC-LOW BIG-FRAC-HIGH BIG-BIASED-EXPT)
		(IF (< X-BIASED-EXPT Y-BIASED-EXPT)
		    (VALUES X-FRAC-LOW X-FRAC-HIGH X-BIASED-EXPT
			    Y-FRAC-LOW Y-FRAC-HIGH Y-BIASED-EXPT)
		    (VALUES Y-FRAC-LOW Y-FRAC-HIGH Y-BIASED-EXPT
			    X-FRAC-LOW X-FRAC-HIGH X-BIASED-EXPT))
	      (LET ((SIGN (%LOGLDB %%DOUBLE-SIGN X-HIGH)))
		(MULTIPLE-VALUE-BIND (SMALL-FRAC-LOW SMALL-FRAC-HIGH)
		    (DOUBLE-STICKY-RIGHT-SHIFT
		      SMALL-FRAC-LOW SMALL-FRAC-HIGH (- SMALL-BIASED-EXPT BIG-BIASED-EXPT))
		  (MULTIPLE-VALUE-BIND (FRAC-LOW CARRY)
		      (%ADD-BIGNUM-STEP BIG-FRAC-LOW SMALL-FRAC-LOW 0)
		    (MULTIPLE-VALUE-BIND (FRAC-HIGH NIL)
			(%ADD-BIGNUM-STEP BIG-FRAC-HIGH SMALL-FRAC-HIGH CARRY)
		      (DOUBLE-NORMALIZE-FOR-OVERFLOW FRAC-LOW FRAC-HIGH BIG-BIASED-EXPT)
		      (DOUBLE-FLOAT-NORMALIZE
			SIGN FRAC-LOW FRAC-HIGH BIG-BIASED-EXPT)))))))))))

(DEFMACRO DOUBLE-FLOAT-TRAP-BODY ((FUNCTION &REST ARGS)
				  (FPA-FUNCTION &REST FPA-ARGS)
				  &BODY BODY)
  #+VLM (DECLARE (IGNORE FPA-FUNCTION FPA-ARGS))
  `(BLOCK ,FUNCTION
     (DOUBLE-FLOAT-HANDLE-EXCEPTIONS (,FUNCTION ,@ARGS)
       (BLOCK DO-IT
	 #-VLM
	 (BLOCK TRY-FPA
	   (%FPA-START ,FPA-FUNCTION ,@FPA-ARGS)
	   (WHEN (FP-COPROCESSOR-ENABLED-P)
	     (%FPA-WAIT ,FPA-FUNCTION :AFTER-TEST T)
	     (LET ((RESULT-HIGH (%FPA-DOUBLE-RESULT-HIGH ,FPA-FUNCTION)))
	       (WHEN (TYPEP RESULT-HIGH 'SINGLE-FLOAT)
		 ;; The compiler knows RESULT-HIGH is TOS, so it can just %FIXNUM it
		 ;; without pushing anything.
		 (SETQ RESULT-HIGH (%FIXNUM RESULT-HIGH))
		 (RETURN-FROM ,FUNCTION
		   (VALUES RESULT-HIGH (%FIXNUM (%FPA-DOUBLE-RESULT-LOW ,FPA-FUNCTION)))))
	       (LET* ((RESULT-LOW (%FPA-DOUBLE-RESULT-LOW ,FPA-FUNCTION))
		      (STICKY-BITS (%FPA-STICKY-BITS-REGISTER))
		      (STATUS (%FPA-STATUS ,FPA-FUNCTION))
		      (SIGNALS (READ-FPA-SIGNALS STICKY-BITS)))
		 (CLEAR-FLOAT-SIGNALS)
		 (SETF (%FPA-STICKY-BITS-REGISTER) 0)
		 (SETF (%FPA-FPEX-DIVIDE-STATUS-REGISTER) 0)
		 (WHEN (LDB-TEST %%W3X64-DENORMALIZED-INPUT-FLAG STICKY-BITS)
		   (RETURN-FROM TRY-FPA))
		 (SETQ FLOAT-OPERATION-STATUS (LOGIOR FLOAT-OPERATION-STATUS SIGNALS))
		 (RETURN-FROM DO-IT
		   (SELECT STATUS
		     (%W3X64-UNORMALIZED-EXACT-64
		      (DOUBLE-FLOAT-UNWRAP RESULT-HIGH RESULT-LOW NIL))
		     (%W3X64-UNORMALIZED-INEXACT-64
		      (DOUBLE-FLOAT-UNWRAP RESULT-HIGH RESULT-LOW T))
		     (%W3X64-OVERFLOW-64
		      (SETF (LDB-TEST %%FLOAT-SIGNAL-OVERFLOW SIGNALS) T)
		      (SETF (LDB-TEST %%FLOAT-SIGNAL-INEXACT-RESULT SIGNALS) T)
		      (MULTIPLE-VALUE-BIND (FRAC-LOW FRAC-HIGH)
			  (%UNBOXED-INTEGER-VALUES 2
			    (%UNBOXED-DPB (%POSITIVE-INTEGER 1) %%DOUBLE-FRAC-N-BIT
					  (%UNBOXED-CONSTANT-LEFT-SHIFT
					    (%POSITIVE-INTEGER
					      RESULT-LOW
					      (%LOGLDB %%DOUBLE-FRACTION-HIGH RESULT-HIGH))
					    (BYTE-POSITION %%DOUBLE-FRAC-FIELD))))
			(LET ((SIGN (%LOGLDB %%DOUBLE-SIGN RESULT-HIGH))
			      (EXPONENT (%LOGLDB %%DOUBLE-EXPONENT RESULT-HIGH)))
			  (%MULTIPLE-VALUE-CALL-N
			    VALUES
			    (DOUBLE-FLOAT-OVERFLOW-VALUE SIGN) 2
			    SIGN 1
			    FRAC-HIGH 1
			    FRAC-LOW 1
			    (IF (= EXPONENT %DOUBLE-EXPONENT-MAX)
				EXPONENT
				(+ EXPONENT %DOUBLE-EXPONENT-MAX)) 1))))
		     (OTHERWISE (VALUES RESULT-HIGH RESULT-LOW))))))))
	 (CLEAR-FLOAT-SIGNALS)
	 ,@BODY))))

(DEFUN %DOUBLE-FLOATING-ADD (X-HIGH X-LOW Y-HIGH Y-LOW)
  (DECLARE (VALUES RESULT-HIGH RESULT-LOW))
  (DOUBLE-FLOAT-TRAP-BODY (%DOUBLE-FLOATING-ADD X-HIGH X-LOW Y-HIGH Y-LOW)
			  (DOUBLE-ADD X-HIGH X-LOW Y-HIGH Y-LOW)
    (DOUBLE-FLOAT-ADD-INTERNAL X-HIGH X-LOW Y-HIGH Y-LOW)))

(DEFUN %DOUBLE-FLOATING-SUB (X-HIGH X-LOW Y-HIGH Y-LOW)
  (DECLARE (VALUES RESULT-HIGH RESULT-LOW))
  (DOUBLE-FLOAT-TRAP-BODY (%DOUBLE-FLOATING-SUB X-HIGH X-LOW Y-HIGH Y-LOW)
			  (DOUBLE-SUB X-HIGH X-LOW Y-HIGH Y-LOW)
    (DOUBLE-FLOAT-ADD-INTERNAL X-HIGH X-LOW (LOGXOR Y-HIGH (ROT 1 -1)) Y-LOW)))

(DEFUN DOUBLE-FLOAT-MULTIPLY-INTERNAL (X-HIGH X-LOW Y-HIGH Y-LOW)
  (DECLARE (VALUES RESULT-HIGH RESULT-LOW))
  #+VLM
  (MULTIPLE-VALUE-BIND (HIGH LOW EXCEPTION)
      (%DOUBLE-FLOAT-OP X-HIGH X-LOW Y-HIGH Y-LOW
			%DOUBLE-FLOAT-OP-MULTIPLY)
    ;; If there was no exception, return the result.  If there was an exception,
    ;; simulate the whole shebang so that we signal the proper exception.
    (UNLESS EXCEPTION
      (RETURN-FROM DOUBLE-FLOAT-MULTIPLY-INTERNAL
	(VALUES HIGH LOW))))
  (LET* ((X-BIASED-EXPT (%LOGLDB %%DOUBLE-EXPONENT X-HIGH))
	 (Y-BIASED-EXPT (%LOGLDB %%DOUBLE-EXPONENT Y-HIGH))
	 (SIGN (%LOGLDB %%DOUBLE-SIGN (LOGXOR X-HIGH Y-HIGH))))
    (LET ((EXPT-MAX %DOUBLE-EXPONENT-MAX))
      ;; Infinity and NAN handling
      ;;
      ;;            NAN            0      Finite
      ;;        +--------+-------+----------------
      ;;  NAN   |   NAN  |  NAN  |  NAN     NAN
      ;;        |        |       +-------+
      ;;       |   NAN  |      | ERROR |   
      ;;        |        +-------+-------+--------
      ;;   0    |   NAN  | ERROR |   0       0
      ;;        |        +-------+       +--------
      ;; Finite |   NAN         |   0   | Finite
      ;;
      (COMPILER:%ERROR-WHEN (= X-BIASED-EXPT EXPT-MAX)
	(RETURN-FROM DOUBLE-FLOAT-MULTIPLY-INTERNAL
	  (IF (AND (ZEROP X-LOW)
		   (ZEROP (%LOGLDB %%DOUBLE-FRACTION-HIGH X-HIGH)))
	      (IF (DOUBLE-FLOAT-ZEROP Y-HIGH Y-LOW)
		  (PROGN
		    (SETF (LDB-TEST %%FLOAT-SIGNAL-INVALID-OPERATION
				    FLOAT-OPERATION-STATUS) T)
		    (MAKE-DOUBLE-FLOAT 0 -1 -1 %DOUBLE-EXPONENT-MAX))
		  (IF (= Y-BIASED-EXPT EXPT-MAX)
		      (VALUES (%LOGDPB SIGN %%DOUBLE-SIGN Y-HIGH) Y-LOW)
		      (VALUES (%LOGDPB SIGN %%DOUBLE-SIGN X-HIGH) X-LOW)))
	      (VALUES (%LOGDPB SIGN %%DOUBLE-SIGN X-HIGH) X-LOW))))
      (COMPILER:%ERROR-WHEN (= Y-BIASED-EXPT EXPT-MAX)
	(RETURN-FROM DOUBLE-FLOAT-MULTIPLY-INTERNAL
	  (IF (AND (ZEROP Y-LOW)
		   (ZEROP (%LOGLDB %%DOUBLE-FRACTION-HIGH Y-HIGH))
		   (ZEROP X-LOW)
		   (ZEROP (%LOGLDB %%DOUBLE-EXCEPT-SIGN-HIGH X-HIGH)))
	      (PROGN
		(SETF (LDB-TEST %%FLOAT-SIGNAL-INVALID-OPERATION
				FLOAT-OPERATION-STATUS) T)
		(MAKE-DOUBLE-FLOAT 0 -1 -1 %DOUBLE-EXPONENT-MAX))
	      (VALUES (%LOGDPB SIGN %%DOUBLE-SIGN Y-HIGH) Y-LOW))))
      ;; Zero handling
      (COMPILER:%ERROR-WHEN (OR (DOUBLE-FLOAT-ZEROP X-HIGH X-LOW)
				(DOUBLE-FLOAT-ZEROP Y-HIGH Y-LOW))
	(RETURN-FROM DOUBLE-FLOAT-MULTIPLY-INTERNAL
	  (VALUES
	    (%LOGDPB SIGN %%DOUBLE-SIGN 0)
	    0))))
    (MULTIPLE-VALUE-BIND (X-LOW X-HIGH X-BIASED-EXPT)
	(DOUBLE-FLOAT-FRAC-AND-EXPONENT X-LOW X-HIGH X-BIASED-EXPT)
      (MULTIPLE-VALUE-BIND (Y-LOW Y-HIGH Y-BIASED-EXPT)
	  (DOUBLE-FLOAT-FRAC-AND-EXPONENT Y-LOW Y-HIGH Y-BIASED-EXPT)
	;; Now do the multiplication
	(MULTIPLE-VALUE-BIND (PRODUCT-0 PRODUCT-1 PRODUCT-2 PRODUCT-3)
	    (MULTIPLE-VALUE-BIND (PRODUCT-0 PRODUCT-1-0)
		(%MULTIPLY-BIGNUM-STEP X-LOW Y-LOW)
	      (MULTIPLE-VALUE-BIND (PRODUCT-1-1 PRODUCT-2-1)
		  (%MULTIPLY-BIGNUM-STEP Y-LOW X-HIGH)
		(MULTIPLE-VALUE-BIND (PRODUCT-1-2 PRODUCT-2-2)
		    (%MULTIPLY-BIGNUM-STEP X-LOW Y-HIGH)
		  (MULTIPLE-VALUE-BIND (PRODUCT-2-3 PRODUCT-3-3)
		      (%MULTIPLY-BIGNUM-STEP X-HIGH Y-HIGH)
		    (MULTIPLE-VALUE-BIND (PRODUCT-1 CARRY-2)
			(%ADD-BIGNUM-STEP PRODUCT-1-0 PRODUCT-1-1 PRODUCT-1-2)
		      (MULTIPLE-VALUE-BIND (SUM-2-TEMP CARRY-3-0)
			  (%ADD-BIGNUM-STEP PRODUCT-2-1 PRODUCT-2-2 CARRY-2)
			(MULTIPLE-VALUE-BIND (PRODUCT-2 CARRY-3-1)
			    (%ADD-BIGNUM-STEP SUM-2-TEMP PRODUCT-2-3 0)
			  (VALUES PRODUCT-0
				  PRODUCT-1
				  PRODUCT-2
				  (+ PRODUCT-3-3 CARRY-3-0 CARRY-3-1)))))))))
	  ;; Now normalize the 4-word fraction, and come up with a 2-word result.
	  ;; Because we are multiplying normalized fractions, we know that
	  ;; 1_55.x,y<1_56., so 1_110.xy<1_112.  Thus bit 110. or 111. is 1.  We
	  ;; want to shift this left so that bit 55.+64.=119. is 1, which is a shift
	  ;; of 8 or 9 bits.
	  (LET* ((BIT
		   (%UNBOXED-INTEGER-VALUES 1
		     (%UNBOXED-LDB
		       (BYTE 1. (1- (* 2 (1+ (BYTE-POSITION %%DOUBLE-FRAC-N-BIT)))))
		       (%POSITIVE-INTEGER PRODUCT-0 PRODUCT-1 PRODUCT-2 PRODUCT-3)))))
	    (MULTIPLE-VALUE-BIND (EXTRA-LOW FRAC-LOW FRAC-HIGH)
		(IF (ZEROP BIT)
		    (%UNBOXED-INTEGER-VALUES 3
		      (%UNBOXED-CONSTANT-LEFT-SHIFT
			(%POSITIVE-INTEGER PRODUCT-1 PRODUCT-2 PRODUCT-3)
			(- (+ (BYTE-POSITION %%DOUBLE-FRAC-N-BIT) 64.)
			   (* 2 (BYTE-POSITION %%DOUBLE-FRAC-N-BIT)))))
		    (%UNBOXED-INTEGER-VALUES 3
		      (%UNBOXED-CONSTANT-LEFT-SHIFT
			(%POSITIVE-INTEGER PRODUCT-1 PRODUCT-2 PRODUCT-3)
			(- (+ (BYTE-POSITION %%DOUBLE-FRAC-N-BIT) 64.)
			   (* 2 (BYTE-POSITION %%DOUBLE-FRAC-N-BIT))
			   1))))
	      (DOUBLE-FLOAT-NORMALIZE
		SIGN
		(LOGIOR FRAC-LOW (IF (ZEROP (LOGIOR EXTRA-LOW PRODUCT-0)) 0 1))
		FRAC-HIGH
		(+ (- (+ X-BIASED-EXPT Y-BIASED-EXPT) %DOUBLE-EXPONENT-BIAS)
		   BIT)))))))))

(DEFUN %DOUBLE-FLOATING-MULTIPLY (X-HIGH X-LOW Y-HIGH Y-LOW)
  (DECLARE (VALUES RESULT-HIGH RESULT-LOW))
  (DOUBLE-FLOAT-TRAP-BODY (%DOUBLE-FLOATING-MULTIPLY X-HIGH X-LOW Y-HIGH Y-LOW)
			  (DOUBLE-MULTIPLY X-HIGH X-LOW Y-HIGH Y-LOW)
    (DOUBLE-FLOAT-MULTIPLY-INTERNAL X-HIGH X-LOW Y-HIGH Y-LOW)))

;;; Based on Knuth, Algorithm D (Division of nonnegative integers) in seminumerical
;;; algorithms.
;;;
;;; This is called with the numerator being [X1 X0] and the denominator being [Y1 Y0].
;;; b = 2^32.
;;; We guarantee that Y1  b/2 (i.e. a negative fixnum) and that [X1 X0]<[Y1 Y0].
(DEFUN DOUBLE-DIVIDE-STEP (X0 X1 Y0 Y1)
  (DECLARE (VALUES QUOTIENT REMAINDER-0 REMAINDER-1))
  ;; Q^ is the estimate of this digit of the quotient, which we choose as
  ;; (floor [X1 X0] Y1), unless X1 = Y1, in which case we choose b-1.
  ;; This estimate should be no more than 4 greater than the actual quotient.
  (LET ((Q^ (IF (= X1 Y1) -1 (%DIVIDE-BIGNUM-STEP X0 X1 Y1))))
    (MULTIPLE-VALUE-BIND (P0 P1-1) (%MULTIPLY-BIGNUM-STEP Q^ Y0)
      (MULTIPLE-VALUE-BIND (P1-2 P2) (%MULTIPLY-BIGNUM-STEP Q^ Y1)
	(MULTIPLE-VALUE-BIND (P1 CARRY)
	    (%ADD-BIGNUM-STEP P1-1 P1-2 0)
	  (LET ((P2 (%32-BIT-PLUS P2 CARRY)))
	    (MULTIPLE-VALUE-BIND (REM0 BORROW) (%SUB-BIGNUM-STEP 0 P0 0)
	      (MULTIPLE-VALUE-BIND (REM1 BORROW) (%SUB-BIGNUM-STEP X0 P1 BORROW)
		(LET ((REM2 (%SUB-BIGNUM-STEP X1 P2 BORROW)))
		  (LOOP UNTIL (ZEROP REM2) DOING
		    (SETQ Q^ (%32-BIT-DIFFERENCE Q^ 1))
		    (MULTIPLE-VALUE-SETQ (REM0 CARRY) (%ADD-BIGNUM-STEP REM0 Y0 0))
		    (MULTIPLE-VALUE-SETQ (REM1 CARRY) (%ADD-BIGNUM-STEP REM1 Y1 CARRY))
		    (SETQ REM2 (%32-BIT-PLUS REM2 CARRY)))
		  (VALUES Q^ REM0 REM1))))))))))

(DEFUN DOUBLE-FLOAT-DIVIDE-INTERNAL (X-HIGH X-LOW Y-HIGH Y-LOW)
  (DECLARE (VALUES RESULT-HIGH RESULT-LOW))
  #+VLM
  (MULTIPLE-VALUE-BIND (HIGH LOW EXCEPTION)
      (%DOUBLE-FLOAT-OP X-HIGH X-LOW Y-HIGH Y-LOW
			%DOUBLE-FLOAT-OP-DIVIDE)
    ;; If there was no exception, return the result.  If there was an exception,
    ;; simulate the whole shebang so that we signal the proper exception.
    (UNLESS EXCEPTION
      (RETURN-FROM DOUBLE-FLOAT-DIVIDE-INTERNAL
	(VALUES HIGH LOW))))
  (LET ((X-BIASED-EXPT (%LOGLDB %%DOUBLE-EXPONENT X-HIGH))
	(Y-BIASED-EXPT (%LOGLDB %%DOUBLE-EXPONENT Y-HIGH))
	(SIGN (%LOGLDB %%DOUBLE-SIGN (LOGXOR X-HIGH Y-HIGH))))
    (LET ((EXPT-MAX %DOUBLE-EXPONENT-MAX))
      ;; Infinity and NAN handling
      ;;
      ;;                        X
      ;;            NAN            0      Finite
      ;;        +--------+-------+----------------
      ;;  NAN   |   NAN  |  NAN  |  NAN     NAN
      ;;        |        +-------+----------------
      ;;       |   NAN  |INVALID|   0       0
      ;;        |        +-------+----------------
      ;;   0    |   NAN  |      |  0/0  |Div-by-0
      ;;        |        |       +-------+--------
      ;; Finite |   NAN  |      |   0   | Finite
      ;;
      (COMPILER:%ERROR-WHEN (= X-BIASED-EXPT EXPT-MAX)
	(RETURN-FROM DOUBLE-FLOAT-DIVIDE-INTERNAL
	  (IF (AND (ZEROP X-LOW)
		   (ZEROP (%LOGLDB %%DOUBLE-FRACTION-HIGH X-HIGH)))
	      (IF (= Y-BIASED-EXPT EXPT-MAX)
		  (IF (AND (ZEROP Y-LOW)
			   (ZEROP (%LOGLDB %%DOUBLE-FRACTION-HIGH Y-HIGH)))
		      (PROGN
			(SETF (LDB-TEST %%FLOAT-SIGNAL-INVALID-OPERATION
					FLOAT-OPERATION-STATUS) T)
			(MAKE-DOUBLE-FLOAT 0 -1 -1 %DOUBLE-EXPONENT-MAX))
		      (VALUES (%LOGDPB SIGN %%DOUBLE-SIGN Y-HIGH) Y-LOW))
		  (VALUES (%LOGDPB SIGN %%DOUBLE-SIGN X-HIGH) X-LOW))
	      (VALUES (%LOGDPB SIGN %%DOUBLE-SIGN X-HIGH) X-LOW))))
      (COMPILER:%ERROR-WHEN (= Y-BIASED-EXPT EXPT-MAX)
	(RETURN-FROM DOUBLE-FLOAT-DIVIDE-INTERNAL
	  (IF (AND (ZEROP Y-LOW)
		   (ZEROP (%LOGLDB %%DOUBLE-FRACTION-HIGH Y-HIGH)))
	      (VALUES (%LOGDPB SIGN %%DOUBLE-SIGN 0) 0)
	      (VALUES (%LOGDPB SIGN %%DOUBLE-SIGN Y-HIGH) Y-LOW))))
      (COMPILER:%ERROR-WHEN (DOUBLE-FLOAT-ZEROP Y-HIGH Y-LOW)
	(RETURN-FROM DOUBLE-FLOAT-DIVIDE-INTERNAL
	  (COND ((DOUBLE-FLOAT-ZEROP X-HIGH X-LOW)
		 (SETF (LDB-TEST %%FLOAT-SIGNAL-INVALID-OPERATION
				 FLOAT-OPERATION-STATUS) T)
		 (MAKE-DOUBLE-FLOAT 0 -1 -1 %DOUBLE-EXPONENT-MAX))
		(T
		 (SETF (LDB-TEST %%FLOAT-SIGNAL-DIVISION-BY-ZERO FLOAT-OPERATION-STATUS) T)
		 (MAKE-DOUBLE-FLOAT SIGN 0 0 %DOUBLE-EXPONENT-MAX)))))
      (COMPILER:%ERROR-WHEN (DOUBLE-FLOAT-ZEROP X-HIGH X-LOW)
	(RETURN-FROM DOUBLE-FLOAT-DIVIDE-INTERNAL
	  (VALUES (%LOGDPB SIGN %%DOUBLE-SIGN 0) 0))))
    (MULTIPLE-VALUE-BIND (X-LOW X-HIGH X-BIASED-EXPT)
	(DOUBLE-FLOAT-FRAC-AND-EXPONENT X-LOW X-HIGH X-BIASED-EXPT)
      (MULTIPLE-VALUE-BIND (Y-LOW Y-HIGH Y-BIASED-EXPT)
	  (DOUBLE-FLOAT-FRAC-AND-EXPONENT Y-LOW Y-HIGH Y-BIASED-EXPT)
	;; We want Y to be shifted so the N bit is in the high bit, and the X word
	;; shifted so that the result needs at most a one bit shift to the right.
	(MULTIPLE-VALUE-BIND (Y-LOW Y-HIGH)
	    (%UNBOXED-INTEGER-VALUES 2
	      (%UNBOXED-CONSTANT-LEFT-SHIFT
		(%POSITIVE-INTEGER Y-LOW Y-HIGH)
		(- 63. (BYTE-POSITION %%DOUBLE-FRAC-N-BIT))))
	  (MULTIPLE-VALUE-BIND (FRAC-HIGH REMAINDER-LOW REMAINDER-HIGH)
	      (DOUBLE-DIVIDE-STEP X-LOW X-HIGH Y-LOW Y-HIGH)
	    (MULTIPLE-VALUE-BIND (FRAC-LOW REMAINDER-LOW REMAINDER-HIGH)
		(DOUBLE-DIVIDE-STEP REMAINDER-LOW REMAINDER-HIGH Y-LOW Y-HIGH)
	      (LET ((BIASED-EXPT
		      (1- (+ (- X-BIASED-EXPT Y-BIASED-EXPT) %DOUBLE-EXPONENT-BIAS))))
		(DOUBLE-NORMALIZE-FOR-OVERFLOW FRAC-LOW FRAC-HIGH BIASED-EXPT)
		(DOUBLE-FLOAT-NORMALIZE
		  SIGN
		  (LOGIOR FRAC-LOW (IF (ZEROP (LOGIOR REMAINDER-LOW REMAINDER-HIGH)) 0 1))
		  FRAC-HIGH
		  BIASED-EXPT)))))))))

(DEFUN %DOUBLE-FLOATING-DIVIDE (X-HIGH X-LOW Y-HIGH Y-LOW)
  (DECLARE (VALUES RESULT-HIGH RESULT-LOW))
  (DOUBLE-FLOAT-TRAP-BODY (%DOUBLE-FLOATING-DIVIDE X-HIGH X-LOW Y-HIGH Y-LOW)
			  (DOUBLE-QUOTIENT X-HIGH X-LOW Y-HIGH Y-LOW)
    (DOUBLE-FLOAT-DIVIDE-INTERNAL X-HIGH X-LOW Y-HIGH Y-LOW)))

(DEFUN %DOUBLE-FLOATING-MINUS (X-HIGH X-LOW)
  (DECLARE (VALUES RESULT-HIGH RESULT-LOW))
  (VALUES (LOGXOR X-HIGH (%LOGDPB 1 %%DOUBLE-SIGN 0)) X-LOW))

(DEFUN %DOUBLE-FLOATING-SCALE (DOUBLE-HIGH DOUBLE-LOW INTEGER)
  (DECLARE (VALUES RESULT-HIGH RESULT-LOW))
  (LET ((BIASED-EXPT (%LOGLDB %%DOUBLE-EXPONENT DOUBLE-HIGH))
	(EXPT-MAX %DOUBLE-EXPONENT-MAX))
    (COMPILER:%ERROR-WHEN (OR (DOUBLE-FLOAT-ZEROP DOUBLE-HIGH DOUBLE-LOW)
			      (= BIASED-EXPT EXPT-MAX))
      (RETURN-FROM %DOUBLE-FLOATING-SCALE (VALUES DOUBLE-HIGH DOUBLE-LOW)))
    (LET ((NEW-BIASED-EXPT (+ BIASED-EXPT INTEGER)))
      ;; First try the easy common case where everything is normalized
      (WHEN (AND (> BIASED-EXPT 0)
		 (< 0 NEW-BIASED-EXPT EXPT-MAX))
	(RETURN-FROM %DOUBLE-FLOATING-SCALE
	  (VALUES (%LOGDPB NEW-BIASED-EXPT %%DOUBLE-EXPONENT DOUBLE-HIGH)
		  DOUBLE-LOW)))
      (DOUBLE-FLOAT-HANDLE-EXCEPTIONS (%DOUBLE-FLOATING-SCALE DOUBLE-HIGH DOUBLE-LOW INTEGER)
	(CLEAR-FLOAT-SIGNALS)
	(MULTIPLE-VALUE-BIND (FRAC-LOW FRAC-HIGH BIASED-EXPT)
	    (DOUBLE-FLOAT-FRAC-AND-EXPONENT DOUBLE-LOW DOUBLE-HIGH BIASED-EXPT)
	  (DOUBLE-FLOAT-NORMALIZE
	    (%LOGLDB %%DOUBLE-SIGN DOUBLE-HIGH)
	    FRAC-LOW
	    FRAC-HIGH
	    (+ BIASED-EXPT INTEGER)))))))

(DEFINE-INSTRUCTION-EXCEPTION-HANDLER INCREMENT TRAP-MODE-EMULATOR (LOCATIVE)
  (DECLARE (SAFEGUARDED-FUNCTION DISABLE-REFERENCE-VALIDATION))
  (LET ((NUMBER (LOCATION-CONTENTS LOCATIVE)))
    (SI:CHECK-ARG LOCATIVE (NUMBERP NUMBER)
	       "The argument given to the INCREMENT instruction was not a number")
    (SETF (LOCATION-CONTENTS LOCATIVE)
	  (TYPECASE NUMBER
	    (SINGLE-FLOAT (+ NUMBER 1.0))
	    (DOUBLE-FLOAT (+ NUMBER 1D0))
	    (OTHERWISE (+ NUMBER 1))))
    (VALUES)))

(DEFINE-INSTRUCTION-EXCEPTION-HANDLER DECREMENT TRAP-MODE-EMULATOR (LOCATIVE)
  (DECLARE (SAFEGUARDED-FUNCTION DISABLE-REFERENCE-VALIDATION))
  (LET ((NUMBER (LOCATION-CONTENTS LOCATIVE)))
    (SI:CHECK-ARG LOCATIVE (NUMBERP NUMBER)
	       "The argument given to the DECREMENT instruction was not a number")
    (SETF (LOCATION-CONTENTS LOCATIVE)
	  (TYPECASE NUMBER
	    (SINGLE-FLOAT (- NUMBER 1E0))
	    (DOUBLE-FLOAT (- NUMBER 1D0))
	    (OTHERWISE (- NUMBER 1))))
    (VALUES)))

(DEFINE-INSTRUCTION-EXCEPTION-HANDLER LOOP-DECREMENT-TOS TRAP-MODE-EMULATOR (NUMBER &PC PC)
  (DECLARE (SAFEGUARDED-FUNCTION DISABLE-REFERENCE-VALIDATION)
	   (INLINE PC-NEXT-PC))
  (LET ((VALUE
	  (TYPECASE NUMBER
	    (SINGLE-FLOAT (- NUMBER 1E0))
	    (DOUBLE-FLOAT (- NUMBER 1D0))
	    (OTHERWISE (- NUMBER 1)))))
    (COMPILER:%ERROR-UNLESS (PLUSP VALUE)
      (SETF (%READ-INTERNAL-REGISTER %REGISTER-CONTINUATION) (PC-NEXT-PC PC))
      (COMPILER:NO-OP))
    (RETURN-KLUDGE VALUE)))

(DEFINE-INSTRUCTION-EXCEPTION-HANDLER LOOP-INCREMENT-TOS-LESS-THAN TRAP-MODE-EMULATOR
				      (ARG1 ARG2 &PC PC)
  (DECLARE (SAFEGUARDED-FUNCTION DISABLE-REFERENCE-VALIDATION)
	   (INLINE PC-NEXT-PC))
  (COMPILER:%ERROR-UNLESS (< ARG2 ARG1)
    (SETF (%READ-INTERNAL-REGISTER %REGISTER-CONTINUATION) (PC-NEXT-PC PC)))
  (VALUES ARG1
	  (TYPECASE ARG2
	    (SINGLE-FLOAT (+ ARG2 1E0))
	    (DOUBLE-FLOAT (+ ARG2 1D0))
	    (OTHERWISE (1+ ARG2)))))
