;;; -*- Mode: LISP; Syntax: Common-Lisp; Package: CLI; Base: 10 -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

#| Simple linker for Ivory

---- This can't really work until there's something which detects
---- a function spec being defined to a different function.

This linker supports the following transformations:

  1.  DTP-CALL-INDIRECT ==> DTP-CALL-COMPILED-[EVEN/ODD].  In the general case,
  an indirect call to a compiled function is replaced with a DTP-CALL-COMPILED-EVEN
  to the entry instruction of the compiled function.  When the number of arguments
  passed by the caller can be determined by simple analysis, however, the entry
  instruction can be skipped and the call can point to anywhere in the entry vector.
  The linker also follows branches and NO-OPs found in the entry vector.
  
  2.  DTP-CALL-INDIRECT ==> DTP-CALL-GENERIC.  Indirect calls to cells containing
  generic functions are replaced with DTP-CALL-GENERIC.
  
  3.  DTP-EXTERNAL-VALUE-CELL-POINTER ==> DTP-[COMPILED/GENERIC]-FUNCTION.  When a 
  function cell is referenced for value, the reference can be replaced by the cell's
  contents.

D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")  4.  (NYI) "variable-boundp" ==> Unconditional branch.

0Skipping entry instructions.

Simple code analysis is used in the caller to determine how many
arguments are passed, and whether there is an apply argument.  The entry
instruction is then parsed to determine the minimum and maximum number
of arguments, and whether a rest arg is accepted.  The cases which we
can skip the entry instruction are as follows.  In all cases, the entry
vector index is (- args min-args).

  1.  No apply, no rest, min-args  args  max-args.
  2.  No apply,    rest, min-args  args  max-args.
  3.  Apply,       rest, args = max-args + 1.

--- Need to implement something which skips over keyword initialization in
--- the case where no keywords are passed.  At the very least we could skip
--- the call to SI:VALIDATE-KEYWORDS-INTERNAL.  At best, we could skip everything.

--- If we really want to get hairy, we could make the linker 
--- assemble a helper function for every combination keyword arguments, and
--- link to it somehow.

Unlinking.

We need to be able to unlink linked calls when the callee is redefined.
For CALL-COMPILED-[EVEN/ODD] this is fairly easy; we just replace the
call with DTP-CALL-INDIRECT to the function cell of the callee.  Some
care is required to ensure that calls emitted by the compiler are not
mistakenly unlinked.  The PREFETCH bit of the calls is always preserved.

All DTP-COMPILED-FUNCTION references are unlinked to
DTP-EXTERNAL-VALUE-CELL-POINTER's.  This means that code such as
'#,#'foo will be mistakenly unlinked, but I don't think that's a big
deal.  Some care is required to ensure that DTP-COMPILED-FUNCTION
references to internal functions are not unlinked.

The compiler only generates DTP-CALL-GENERIC-PREFETCH, and the linker
only generates DTP-CALL-GENERIC, so DTP-CALL-GENERIC can be
unconditionally unlinked to DTP-CALL-INDIRECT to the generic function's
function cell.  The original linked call may have been
DTP-CALL-INDIRECT-PREFETCH, but that doesn't help with generic functions
anyway, so the loss of information isn't important.

DTP-GENERIC-FUNTION's are unlinked only if the location linked appears
in the hash table *GENERIC-FUNCTION-LINKS*.  That's the only way I can
think of to distinguish (flavor:generic foo) and (function foo) in
linked code.  This means the linker is responsible for entering the
link locations into the table.

|#

;; Databases

;; This table maps generic functions to a list of all locations
;; which have been linked via DTP-EVCP ==> DTP-GENERIC-FUNCTION.
(DEFVAR *GENERIC-FUNCTION-LINKS* (MAKE-HASH-TABLE :TEST 'EQ))

;;;--- Needs to be maintained by the flavor system.
;;;--- For now, though, do it at link time.
(DEFVAR *GENERIC-FUNCTION-FUNCTION-CELLS* NIL)

(DEFUN INITIALIZE-GENERIC-FUNCTION-FUNCTION-CELLS ()
  (LET ((HASH *GENERIC-FUNCTION-FUNCTION-CELLS*)
	(LENGTH (LENGTH *ALL-GENERIC-FUNCTION-NAMES*)))
    (WHEN (OR (NULL HASH)
	      (< (TABLE-SIZE HASH) LENGTH))
      (SETQ *GENERIC-FUNCTION-FUNCTION-CELLS*
	    (SETQ HASH (MAKE-HASH-TABLE :TEST 'EQ :NUMBER-OF-VALUES 0
					:SIZE LENGTH))))
    (CLRHASH HASH)
    (TV:DOLIST-NOTING-PROGRESS (NAME *ALL-GENERIC-FUNCTION-NAMES*
				"Collecting generic function function cells")
      (LET ((GF (FLAVOR:FIND-GENERIC-FUNCTION NAME NIL)))
	(WHEN (AND GF (GENERIC-FUNCTION-P (GENERIC-FUNCTION-SELECTOR GF)))
	  (LET ((CELL (FOLLOW-CELL-FORWARDING (FDEFINITION-LOCATION NAME) NIL)))
	    (UNLESS (EQ (%AREA-NUMBER CELL) COMPILED-FUNCTION-AREA)
	      (SETF (GETHASH CELL HASH) T))))))))

;;;--- Needs to be maintained by the loader/compiler.
;;;--- For now, though, do it at link time.
;;;--- (Should be maintained via %LINK-MODE-INDIRECT.)
;;;--- This still doesn't make new LETF's work.
(DEFVAR *FUNCTION-CELLS-NOT-TO-LINK* (MAKE-HASH-TABLE :TEST 'EQ :NUMBER-OF-VALUES 0))

;;;--- Kludge.  This is fixed by a combination of declarations
;;;--- in the target function (DBG:DEBUGGER-TOP-LEVEL) and the named-by-other-fspecs flag.
(DEFVAR *FUNCTIONS-NEVER-TO-LINK*
	'(;; Redefined by metering
	  DBG:DEBUGGER-TOP-LEVEL
	  PROCESS::RUN-PROCESS-DISPATCHER

	  ;; Function specs which name other functions.
	  NET:TELNET-SERVER-ON
	  SI:ENCAPSULATION-LIST*
	  SI:ADVISE-VALUES-LIST
	  SI:TRACE-APPLY
	  SI:ADVISE-APPLY
	  SI:ADVISE-LIST*
	  DBG:FRAME-PREVIOUS-INTERESTING-ACTIVE-FRAME
	  DBG:FRAME-NEXT-NTH-INTERESTING-ACTIVE-FRAME
	  DBG:FRAME-NEXT-INTERESTING-ACTIVE-FRAME
	  DBG:FRAME-OUT-TO-INTERESTING-ACTIVE-FRAME
	  TV:MAKE-BINARY-GRAY
	  TV:LINE-INTERSECTION
	  TV:SHEET-Y
	  TV:SHEET-X))

;;;--- (For this to really work, you have to SI:OPTIMIZE-COMPILED-FUNCTIONS.)
;;;--- (You could do that in parallel with this pass, I think.)
(DEFUN FIND-UNLINKABLE-FUNCTION-CELLS (&OPTIONAL VERBOSE)
  (LET ((HASH *FUNCTION-CELLS-NOT-TO-LINK*))
    (CLRHASH HASH)
    (LOOP FOR FUNCTION IN *FUNCTIONS-NEVER-TO-LINK* DO
      (SETF (GETHASH (FOLLOW-CELL-FORWARDING (FDEFINITION-LOCATION FUNCTION) NIL) HASH) T))
    (SI:MAP-COMPILED-FUNCTIONS T NIL "Collecting unlinkable function cells"
      (LAMBDA (FUNCTION CCA)
	(DECLARE (IGNORE CCA))
	(SI:DO-COMPILED-FUNCTION-INSTRUCTIONS (INSTRUCTION LOCATION :PREFETCH T
								    :SKIP-ENTRY-INSTRUCTION T)
					      FUNCTION
	  (WHEN (AND (LOCATIVEP INSTRUCTION)
		     (OR (EQ (%AREA-NUMBER (SETQ INSTRUCTION
						 (FOLLOW-CELL-FORWARDING INSTRUCTION NIL)))
			     COMPILED-FUNCTION-AREA)
			 (GETHASH INSTRUCTION *GENERIC-FUNCTION-FUNCTION-CELLS*)))
	    (MULTIPLE-VALUE-BIND (NAME TYPE)
		(COMPILER:DISASSEMBLE-DECODE-LOCATIVE INSTRUCTION)
	      (WHEN (EQ TYPE :FUNCTION)
		;; Ensure this isn't VARIABLE-BOUNDP, which compiles as
		;; DTP-LOCATIVE, %MEMORY-READ DATA-WRITE
		(UNLESS (EQ (DBG:PACKED-INSTRUCTION-FROM-PC
			      (DBG:PC-NEXT-PC (%SET-TAG LOCATION DTP-EVEN-PC)))
			    (DPB ILC:*%MEMORY-READ-OPCODE* %%PACKED-INSTRUCTION-OPCODE
				 #.(SI:PACK-BLOCK-BITS :CYCLE-TYPE %MEMORY-DATA-WRITE
						       :SET-CDR-NEXT T)))
		  (WHEN VERBOSE
		    (FORMAT T "~%Locative reference from ~S to ~S"
			    (SI:COMPILED-FUNCTION-NAME FUNCTION) NAME))
		  (SETF (GETHASH INSTRUCTION HASH) T))))))))))

#+ignore
(defvar *accepted-cross-definitions*
	(zl:pkg-bind 'si
	  `(,@(loop for i below 40 collect (fintern "STRUCTURE-AREF-~D" i))
	    ,@(loop for i below 15 collect (fintern "STRUCTURE-ARRAY-LEADER-~D" i))
	    ,@(loop for i below 10 collect (fintern "STRUCTURE-NTH-~D" i)))))

#+ignore
;; For early debugging
(DEFUN FIND-CROSS-DEFINITIONS ()
  (DO-ALL-SYMBOLS (SYMBOL)
    (WHEN (FBOUNDP SYMBOL)
      (LET ((DEF (SYMBOL-FUNCTION SYMBOL)))
	(WHEN (COMPILED-FUNCTION-P DEF)
	  (LET ((NAME (SI:COMPILED-FUNCTION-NAME DEF)))
	    (AND (NEQ SYMBOL NAME)
		 (NEQ SYMBOL (MACRO-FUNCTION NAME))
		 (NEQ SYMBOL (SPECIAL-FORM-P NAME))
		 (OR (NOT (SYMBOLP NAME))
		     (NEQ (FOLLOW-CELL-FORWARDING (ZL:FUNCTION-CELL-LOCATION SYMBOL) NIL)
			  (FOLLOW-CELL-FORWARDING (ZL:FUNCTION-CELL-LOCATION NAME) NIL)))
		 (NOT (MEMBER NAME *ACCEPTED-CROSS-DEFINITIONS*))
		 (NOT (EQ (%AREA-NUMBER DEF) SI:FEP-AREA))
		 (FORMAT T "~%~S ~S" SYMBOL DEF))))))))

;; Metering

;; Meter the reasons why we can't determine n-arguments
(DEFVAR *COUNT-LINKS* 0)
(DEFVAR *COUNT-LINK-NORMAL* 0)
(DEFVAR *COUNT-LINK-REST* 0)
(DEFVAR *COUNT-LINK-APPLY* 0)
(DEFVAR *COUNT-LINK-THROUGH-ENTRY* 0)
(DEFVAR *COUNT-LINK-CALL-GENERIC* 0)
(DEFVAR *COUNT-LINK-COMPILED-FUNCTION-CONSTANT* 0)
(DEFVAR *COUNT-LINK-GENERIC-FUNCTION-CONSTANT* 0)

(DEFVAR *COUNT-NO-LINK-FINISH-CALL-LOSSAGE* 0)

(DEFUN RESET-LINKER-METERS ()
  (SETQ *COUNT-LINKS* 0)
  (SETQ *COUNT-LINK-NORMAL* 0)
  (SETQ *COUNT-LINK-REST* 0)
  (SETQ *COUNT-LINK-APPLY* 0)
  (SETQ *COUNT-LINK-THROUGH-ENTRY* 0)
  (SETQ *COUNT-LINK-CALL-GENERIC* 0)
  (SETQ *COUNT-LINK-COMPILED-FUNCTION-CONSTANT* 0)
  (SETQ *COUNT-LINK-GENERIC-FUNCTION-CONSTANT* 0)
  (SETQ *COUNT-NO-LINK-FINISH-CALL-LOSSAGE* 0)
  T)

(DEFUN SHOW-LINKER-METERS ()
  (FORMAT T "
~6D references were linked:
      ~6D links to functions with no rest argument
      ~6D links to functions with a rest argument
      ~6D links from applied functions
      ~6D links through entry instructions
      ~6D generic function calls
      ~6D compiled function constants
      ~6D generic function constants

~D references were not linked due to FINISH-CALL pipeline lossage
~D functions cannot be linked because locative references exist"
	  *COUNT-LINKS*
	  *COUNT-LINK-NORMAL*
	  *COUNT-LINK-REST*
	  *COUNT-LINK-APPLY*
	  *COUNT-LINK-THROUGH-ENTRY*
	  *COUNT-LINK-CALL-GENERIC*
	  *COUNT-LINK-COMPILED-FUNCTION-CONSTANT*
	  *COUNT-LINK-GENERIC-FUNCTION-CONSTANT*
	  *COUNT-NO-LINK-FINISH-CALL-LOSSAGE*
	  (HASH-TABLE-COUNT *FUNCTION-CELLS-NOT-TO-LINK*)))

;; Linker

;; Interfaces:
;;   CLI::LINK-TO-FUNCTIONS functions-or-t
;;   CLI::LINK-FROM-FUNCTION function

(DEFUN LINK-CALL (CALL-LOCATION N-ARGS APPLY-P)
  (DECLARE (VALUES LINKED-P))
  (LET* ((INSTRUCTION (%MEMORY-READ CALL-LOCATION :CYCLE-TYPE %MEMORY-BIND-READ))
	 (FUNCTION (%MEMORY-READ INSTRUCTION :CYCLE-TYPE %MEMORY-BIND-READ)))
    (WHEN (TYPE-MEMBER FUNCTION DTP-COMPILED-FUNCTION DTP-GENERIC-FUNCTION)
      (%P-STORE-CONTENTS CALL-LOCATION
	(COND
	  ((TYPE-MEMBER INSTRUCTION DTP-CALL-INDIRECT DTP-CALL-INDIRECT-PREFETCH)
	   (IF (TYPE-MEMBER FUNCTION DTP-GENERIC-FUNCTION)
	       ;; Always generate the non-prefetch instruction for unlinking.
	       (PROGN (INCF *COUNT-LINK-CALL-GENERIC*)
		      (%SET-TAG FUNCTION DTP-CALL-GENERIC))
	     ;; Ensure that we don't make a link which would screw up pipelining
	     ;;--- Do we really want this to auto-disable in Rev4?
	     (WHEN (< (%READ-INTERNAL-REGISTER %REGISTER-CHIP-REVISION) 4)
	       (LOOP WITH PC = (DBG:PC-NEXT-PC (%SET-TAG CALL-LOCATION DTP-EVEN-PC))
		     AS INST = (OR (DBG:PACKED-INSTRUCTION-FROM-PC PC) (RETURN))
		     DO (DBG:OPCODE-SELECT INST
			  (FINISH-CALL-N
			    (INCF *COUNT-NO-LINK-FINISH-CALL-LOSSAGE*)
			    (RETURN-FROM LINK-CALL NIL))
			  ;; Have to follow branches since they might execute in 0 cycles.
			  (BRANCH (UNLESS (SETQ PC (BRANCH-PC PC INST)) (RETURN)))
			  (OTHERWISE (RETURN)))))
	     (LET* ((ENTRY (%POINTER (%MEMORY-READ FUNCTION)))
		    (ENTRY-P (NOT (NULL (MEMBER (LDB %%PACKED-INSTRUCTION-OPCODE ENTRY)
						I-LISP-COMPILER::
						`(,*ENTRY-REST-ACCEPTED-OPCODE*
						  ,*ENTRY-REST-NOT-ACCEPTED-OPCODE*)))))
		    (MIN  (- (LDB %%ENTRY-INSTRUCTION-MIN ENTRY) 2))
		    (MAX  (- (LDB %%ENTRY-INSTRUCTION-MAX ENTRY) 2))
		    (REST (LDB (BYTE 1 (BYTE-POSITION %%PACKED-INSTRUCTION-OPCODE)) ENTRY)))
	       (COND ((AND N-ARGS ENTRY-P
			   (IF APPLY-P
			       (AND (ZEROP REST) (= (1+ MAX) N-ARGS))
			       ( MIN N-ARGS MAX)))
		      (COND (APPLY-P      (INCF *COUNT-LINK-APPLY*))
			    ((ZEROP REST) (INCF *COUNT-LINK-REST*))
			    (T            (INCF *COUNT-LINK-NORMAL*)))
		      (DISPATCH-CALL FUNCTION
				     (- N-ARGS MIN)
				     (TYPE-MEMBER INSTRUCTION DTP-CALL-INDIRECT-PREFETCH)))
		     (T (WHEN (AND N-ARGS ENTRY-P
				   (NOT APPLY-P)
				   (OR (= REST 1)
				       (< N-ARGS MIN)))
			  (LET ((CALLER (%FIND-STRUCTURE-HEADER CALL-LOCATION)))
			    (WHEN (SI:FUNCTION-SAME-AS-FUNCTION-FROM-NAME CALLER)
			      (FORMAT *ERROR-OUTPUT*
				      "~%Warning: Incorrect arguments passed~%~4@Tfrom ~S~%~6@Tto ~S"
				      CALLER FUNCTION))))
			(INCF *COUNT-LINK-THROUGH-ENTRY*)
			(%SET-TAG FUNCTION
				  (IF (TYPE-MEMBER INSTRUCTION DTP-CALL-INDIRECT-PREFETCH)
				      DTP-CALL-COMPILED-EVEN-PREFETCH
				      DTP-CALL-COMPILED-EVEN)))))))
	  ;; Convert #'FOO into '#<COMPILED-FUNCTION FOO> or '#<GENERIC-FUNCTION FOO>
	  ((TYPE-MEMBER INSTRUCTION DTP-EXTERNAL-VALUE-CELL-POINTER)
	   ;; Remember this location for unlinking.
	   (IF (TYPE-MEMBER FUNCTION DTP-COMPILED-FUNCTION)
	       (INCF *COUNT-LINK-COMPILED-FUNCTION-CONSTANT*)
	     (INCF *COUNT-LINK-GENERIC-FUNCTION-CONSTANT*)
	     (PUSH CALL-LOCATION (GETHASH FUNCTION *GENERIC-FUNCTION-LINKS*)))
	   FUNCTION)
	  ;; No chance of linking.
	  (T (RETURN-FROM LINK-CALL NIL))))
      (INCF *COUNT-LINKS*)
      ;; Make a note in the linked object that there are direct references to it.
      (IF (TYPE-MEMBER FUNCTION DTP-COMPILED-FUNCTION)
	  (SETF (SI:COMPILED-FUNCTION-LINKED FUNCTION) T)
	  (SETF (FLAVOR::GENERIC-FUNCTION-LINKED FUNCTION) T))
      T)))

(DEFUN DIRECT-CALL-INSTRUCTION (FUNCTION N-ARGS APPLY-P PREFETCH-P)
  (WHEN N-ARGS
    (LET ((ENTRY (%POINTER (%MEMORY-READ FUNCTION))))
      (WHEN (MEMBER (LDB %%PACKED-INSTRUCTION-OPCODE ENTRY)
		    I-LISP-COMPILER::
		    `(,*ENTRY-REST-ACCEPTED-OPCODE* ,*ENTRY-REST-NOT-ACCEPTED-OPCODE*))
	(LET ((MIN  (- (LDB %%ENTRY-INSTRUCTION-MIN ENTRY) 2))
	      (MAX  (- (LDB %%ENTRY-INSTRUCTION-MAX ENTRY) 2))
	      (REST (LDB (BYTE 1 (BYTE-POSITION %%PACKED-INSTRUCTION-OPCODE)) ENTRY)))
	  (WHEN (AND (> N-ARGS 0)		; < rev. 4 pipeline problem
		     (IF APPLY-P
			 (AND (ZEROP REST) (= (1+ MAX) N-ARGS))
			 ( MIN N-ARGS MAX)))
	    (RETURN-FROM DIRECT-CALL-INSTRUCTION
	      (DISPATCH-CALL FUNCTION (- N-ARGS MIN) PREFETCH-P)))))))
  ;; just call direct to first instruction
  (%SET-TAG FUNCTION (IF PREFETCH-P
			 DTP-CALL-COMPILED-EVEN-PREFETCH
			 DTP-CALL-COMPILED-EVEN)))

;; I don't think all this hair for odd instructions is really necessary in the
;; current compiler.
(DEFUN DISPATCH-CALL (FUNCTION DISPATCH PREFETCH)
  (LET ((PC (%SET-TAG (%POINTER-PLUS FUNCTION (1+ DISPATCH)) DTP-EVEN-PC)))
    (LOOP AS INSTRUCTION = (DBG:PACKED-INSTRUCTION-FROM-PC PC) DO
      (IF INSTRUCTION
	  (DBG:OPCODE-SELECT INSTRUCTION
	    (BRANCH (SETQ PC (OR (BRANCH-PC PC INSTRUCTION) (RETURN))))
	    (NO-OP (SETQ PC (DBG:PC-NEXT-PC PC)))
	    (OTHERWISE (RETURN)))
	;; This is a full-word instruction.  See if it's a PC to branch to.
	(SETQ INSTRUCTION (%MEMORY-READ PC :CYCLE-TYPE %MEMORY-BIND-READ))
	(UNLESS (TYPE-MEMBER INSTRUCTION DTP-EVEN-PC DTP-ODD-PC) (RETURN))
	(LET* ((NEXT-PC (DBG:PC-NEXT-PC PC))
	       (NEXT-INSTRUCTION (DBG:PACKED-INSTRUCTION-FROM-PC NEXT-PC)))
	  (UNLESS (EQ (DPBS ILC:*%JUMP-OPCODE* %%PACKED-INSTRUCTION-OPCODE
			    STACK-ADDRESSING-MODE-STACK-POINTER
			    %%PACKED-INSTRUCTION-ADDRESSING-MODE 0)
		      NEXT-INSTRUCTION)
	    (RETURN))
	  (SETQ PC INSTRUCTION))))
    (%SET-TAG PC
      (IF (TYPE-MEMBER PC DTP-EVEN-PC)
	  (IF PREFETCH DTP-CALL-COMPILED-EVEN-PREFETCH DTP-CALL-COMPILED-EVEN)
	  (IF PREFETCH DTP-CALL-COMPILED-ODD-PREFETCH  DTP-CALL-COMPILED-ODD)))))

(DEFUN BRANCH-PC (PC INSTRUCTION &OPTIONAL (HACK-BRANCH-. T))
  (LET ((OFFSET (%LOGDPB (- (LDB (BYTE 1 9) INSTRUCTION))
			 (BYTE 22 10) INSTRUCTION)))
    (COND ((AND HACK-BRANCH-. (ZEROP OFFSET)) NIL)
	  ((EVENP OFFSET) (%POINTER-PLUS PC (ASH OFFSET -1)))
	  ((TYPE-MEMBER PC DTP-EVEN-PC)
	   (%SET-TAG (%POINTER-PLUS PC (FLOOR OFFSET 2)) DTP-ODD-PC))
	  (T (%SET-TAG (%POINTER-PLUS PC (CEILING OFFSET 2)) DTP-EVEN-PC)))))

;; Counting arguments is actually quite simple in 99.9% of the cases.
;; All we have to do is find one path from the start-call to the finish-call, and
;; look at the number of arguments expected by the finish-call.  Any conditional
;; branches must branch to the same level of call nesting, so we can arbitrarily pick
;; one possible outcome of the branch and follow it.  In order to guarantee termination,
;; we search depth-first with a loop detector.
(DEFUN COUNT-CALL-ARGUMENTS (CALL-PC)
  (DECLARE (VALUES N-ARGUMENTS APPLY-P))
  (LABELS ((SEARCH-PC (PC LEVEL BRANCHES)
	     (LOOP WITH (LAST-INSTRUCTION INSTRUCTION) DO
	       (SETQ LAST-INSTRUCTION INSTRUCTION
		     INSTRUCTION (DBG:PACKED-INSTRUCTION-FROM-PC PC))
	       (IF INSTRUCTION
		   (DBG:OPCODE-SELECT INSTRUCTION
		     (START-CALL (INCF LEVEL))
		     (BRANCH
		       ;; Punt on loops.
		       (WHEN (CL:MEMBER PC BRANCHES) (RETURN-FROM SEARCH-PC NIL))
		       (LET ((NEXT (BRANCH-PC PC INSTRUCTION)))
			 ;; Punt on BRANCH-.
			 (UNLESS NEXT (RETURN-FROM SEARCH-PC NIL))
			 (WITH-STACK-LIST* (BRANCHES PC BRANCHES)
			   (RETURN-FROM SEARCH-PC
			     (SEARCH-PC NEXT LEVEL BRANCHES)))))
		     (%JUMP
		       ;; Punt on loops.
		       (WHEN (CL:MEMBER PC BRANCHES) (RETURN-FROM SEARCH-PC NIL))
		       (UNLESS (AND (EQ (DPBS ILC:*%JUMP-OPCODE* %%PACKED-INSTRUCTION-OPCODE
					      STACK-ADDRESSING-MODE-STACK-POINTER
					      %%PACKED-INSTRUCTION-ADDRESSING-MODE 0)
					INSTRUCTION)
				    (TYPE-MEMBER LAST-INSTRUCTION DTP-EVEN-PC DTP-ODD-PC))
			 ;; Punt all but PUSH-PC, JUMP SP|POP
			 (RETURN-FROM SEARCH-PC NIL))
		       (WITH-STACK-LIST* (BRANCHES PC BRANCHES)
			 (RETURN-FROM SEARCH-PC
			   (SEARCH-PC LAST-INSTRUCTION LEVEL BRANCHES))))
		     (T (COND ((= (LDB (BYTE 6 12) INSTRUCTION)
				  (LDB (BYTE 6 2) ILC:*FINISH-CALL-N-OPCODE*))
			       (UNLESS (PLUSP (DECF LEVEL))
				 (WHEN (LDB-TEST (BYTE 1 11) INSTRUCTION)
				   ;; Return from the outer loop, since further searching
				   ;; is pointless.
				   (RETURN-FROM COUNT-CALL-ARGUMENTS NIL))
				 ;; This could return from the outer loop too, but
				 ;; avoiding a throw is probably faster.
				 (RETURN-FROM SEARCH-PC
				   (VALUES (1- (LDB %%PACKED-INSTRUCTION-8-BIT-OPERAND
						    INSTRUCTION))
					   (LDB-TEST (BYTE 1 10) INSTRUCTION)))))
			      ((OR (= (LDB (BYTE 4 14) INSTRUCTION)
				      (LDB (BYTE 4 4) ILC:*BRANCH-TRUE-OPCODE*))
				   (= (LDB (BYTE 7 10) INSTRUCTION)
				      (LDB (BYTE 7 0) ILC:*LOOP-DECREMENT-TOS-OPCODE*)))
			       ;; Punt on loops.
			       (WHEN (CL:MEMBER PC BRANCHES) (RETURN-FROM SEARCH-PC NIL))
			       (WITH-STACK-LIST* (BRANCHES PC BRANCHES)
				 (MULTIPLE-VALUE-BIND (N-ARGS APPLY-P)
				     (SEARCH-PC (DBG:PC-NEXT-PC PC) LEVEL BRANCHES)
				   (IF N-ARGS (RETURN-FROM SEARCH-PC (VALUES N-ARGS APPLY-P)))
				   (LET ((BRANCH-PC (BRANCH-PC PC INSTRUCTION)))
				     (RETURN-FROM SEARCH-PC
				       (WHEN BRANCH-PC
					 (SEARCH-PC BRANCH-PC LEVEL BRANCHES))))))))))
		 (SETQ INSTRUCTION (%MEMORY-READ PC :CYCLE-TYPE %MEMORY-BIND-READ))
		 (WHEN (TYPE-MEMBER INSTRUCTION DTP-CALL-COMPILED-EVEN
						DTP-CALL-COMPILED-ODD
						DTP-CALL-INDIRECT
						DTP-CALL-GENERIC
						DTP-CALL-COMPILED-EVEN-PREFETCH
						DTP-CALL-COMPILED-ODD-PREFETCH
						DTP-CALL-INDIRECT-PREFETCH
						DTP-CALL-GENERIC-PREFETCH)
		   (INCF LEVEL)
		   (UNLESS (TYPE-MEMBER INSTRUCTION DTP-CALL-COMPILED-ODD
						    DTP-CALL-COMPILED-ODD-PREFETCH
						    DTP-CALL-GENERIC
						    DTP-CALL-GENERIC-PREFETCH)
		     ;; We have to avoid certain functions known about by the compiler,
		     ;; since it will remove dead code after the finish-call to these
		     ;; functions.
		     (WHEN (IF (TYPE-MEMBER INSTRUCTION DTP-CALL-INDIRECT
							DTP-CALL-INDIRECT-PREFETCH)
			       ;; This does BIND-READ to avoid unbound-function traps.
			       (MEMBER (%MEMORY-READ INSTRUCTION
						     :CYCLE-TYPE %MEMORY-BIND-READ)
				 '#,`(,#'%THROW
				      ,#'%RETURN-FROM-LAMBDA
				      ,#'SI:ABORT-CALL-0
				      ,#'SI:ABORT-CALL-1
				      ,#'SI:ABORT-CALL-MULTIPLE))
			       (MEMBER (%SET-TAG INSTRUCTION DTP-EVEN-PC)
				 '#,`(;; These can be entered anywhere.
				      ,(%SET-TAG (%POINTER-PLUS #'%THROW 0)
						 DTP-EVEN-PC)
				      ,(%SET-TAG (%POINTER-PLUS #'%THROW 1)
						 DTP-EVEN-PC)
				      ,(%SET-TAG (%POINTER-PLUS #'%THROW 2)
						 DTP-EVEN-PC)
				      ,(%SET-TAG (%POINTER-PLUS #'%RETURN-FROM-LAMBDA 0)
						 DTP-EVEN-PC)
				      ,(%SET-TAG (%POINTER-PLUS #'%RETURN-FROM-LAMBDA 1)
						 DTP-EVEN-PC)
				      ,(%SET-TAG (%POINTER-PLUS #'%RETURN-FROM-LAMBDA 2)
						 DTP-EVEN-PC)
				      ;; The compiler always emits simple calls to these,
				      ;; so they're always linked to the entry vector.
				      ,(%SET-TAG (%POINTER-PLUS #'SI:ABORT-CALL-0 1)
						 DTP-EVEN-PC)
				      ,(%SET-TAG (%POINTER-PLUS #'SI:ABORT-CALL-1 1)
						 DTP-EVEN-PC)
				      ,(%SET-TAG (%POINTER-PLUS #'SI:ABORT-CALL-MULTIPLE 1)
						 DTP-EVEN-PC))))
		       (RETURN-FROM SEARCH-PC NIL)))))
	       (SETQ PC (DBG:PC-NEXT-PC PC)))))
    (SEARCH-PC (DBG:PC-NEXT-PC CALL-PC) 1 NIL)))

(DEFUN LINK-CALLS (CALLEE-PREDICATE &OPTIONAL LINK-NOTER VERBOSE)
  (SI:MAP-COMPILED-FUNCTIONS T NIL "Linking function calls"
    (LAMBDA (FUNCTION IGNORE &AUX FLAG)
      (CATCH-ERROR-RESTART (ERROR "Skip linking references from ~S" FUNCTION)
	(SI:DO-COMPILED-FUNCTION-INSTRUCTIONS (INSTRUCTION LOCATION :SKIP-ENTRY-INSTRUCTION T)
					      FUNCTION
	  (WHEN (AND (TYPE-MEMBER INSTRUCTION DTP-CALL-INDIRECT
					      DTP-CALL-INDIRECT-PREFETCH
					      DTP-EXTERNAL-VALUE-CELL-POINTER)
		     (FUNCALL CALLEE-PREDICATE (%SET-TAG INSTRUCTION DTP-LOCATIVE))
		     (%MULTIPLE-VALUE-CALL-N LINK-CALL
		       LOCATION 1
		       (AND (TYPE-MEMBER INSTRUCTION DTP-CALL-INDIRECT
					 DTP-CALL-INDIRECT-PREFETCH)
			    (COUNT-CALL-ARGUMENTS (%SET-TAG LOCATION DTP-EVEN-PC))) 2
		       ))
	    (WHEN LINK-NOTER (FUNCALL LINK-NOTER FUNCTION (%SET-TAG LOCATION DTP-EVEN-PC)))
	    (WHEN VERBOSE
	      (UNLESS FLAG
		(FORMAT T "~%From function ~S" FUNCTION)
		(SETQ FLAG T))
	      (LET ((LINK (LOCATION-CONTENTS LOCATION)))
		(FORMAT T "~%   Linked PC ~3O to ~S"
			(* 2 (%POINTER-DIFFERENCE LOCATION FUNCTION))
			(COND ((TYPE-MEMBER LINK DTP-CALL-COMPILED-EVEN
						 DTP-CALL-COMPILED-EVEN-PREFETCH)
			       (%SET-TAG LINK DTP-EVEN-PC))
			      ((TYPE-MEMBER LINK DTP-CALL-COMPILED-ODD
						 DTP-CALL-COMPILED-ODD-PREFETCH)
			       (%SET-TAG LINK DTP-ODD-PC))
			      ((TYPE-MEMBER LINK DTP-CALL-GENERIC)
			       (%SET-TAG LINK DTP-GENERIC-FUNCTION))
			      (T LINK)))))))))))

(DEFUN LINKABLE-LOCATION-P (LOCATION)
  ;; Don't link through variables or function cells not normally forwarded.
  (AND (OR (GETHASH LOCATION *GENERIC-FUNCTION-FUNCTION-CELLS*)
	   (LET ((AREA (%AREA-NUMBER LOCATION)))
	     (OR (EQ AREA COMPILED-FUNCTION-AREA)
		 (AND (OR (EQ AREA WIRED-CONTROL-TABLES)
			  (EQ AREA SAFEGUARDED-OBJECTS-AREA))
		      (COMPILED-FUNCTION-P
			(%FIND-STRUCTURE-HEADER LOCATION))))))
       (NOT (GETHASH LOCATION *FUNCTION-CELLS-NOT-TO-LINK*))))

(DEFUN LINK-TO-FUNCTIONS (FUNCTIONS &OPTIONAL LINK-NOTER VERBOSE)
  (INITIALIZE-GENERIC-FUNCTION-FUNCTION-CELLS)
  (SI:OPTIMIZE-COMPILED-FUNCTIONS VERBOSE)
  (FIND-UNLINKABLE-FUNCTION-CELLS VERBOSE)
  (IF (EQ FUNCTIONS T)
      (LINK-CALLS #'LINKABLE-LOCATION-P LINK-NOTER VERBOSE)
    (UNLESS (LISTP FUNCTIONS)
      (SETQ FUNCTIONS (LIST FUNCTIONS)))
    (LET ((LOCATIONS (DELETE-IF-NOT #'LINKABLE-LOCATION-P
		       (LOOP FOR FUNCTION IN FUNCTIONS
			     WHEN (COMPILED-FUNCTION-P FUNCTION)
			       COLLECT (CCA-FUNCTION-CELL (COMPILED-FUNCTION-CCA FUNCTION))
			     ELSE
			       COLLECT (PROGN (WHEN (GENERIC-FUNCTION-P FUNCTION)
						(SETQ FUNCTION
						      (GENERIC-FUNCTION-NAME FUNCTION)))
					      (FOLLOW-CELL-FORWARDING
						(FDEFINITION-LOCATION FUNCTION) NIL))))))
      (LINK-CALLS #'(LAMBDA (LOCATION) (MEMBER LOCATION LOCATIONS)) LINK-NOTER VERBOSE))))

(DEFUN LINK-FROM-FUNCTION (FUNCTION &OPTIONAL LINK-NOTER VERBOSE)
  (INITIALIZE-GENERIC-FUNCTION-FUNCTION-CELLS)
  (SI:OPTIMIZE-COMPILED-FUNCTIONS VERBOSE)
  (FIND-UNLINKABLE-FUNCTION-CELLS VERBOSE)
  (SI:DO-COMPILED-FUNCTION-INSTRUCTIONS (INSTRUCTION LOCATION
						     :PREFETCH T
						     :SKIP-ENTRY-INSTRUCTION T)
					FUNCTION
    (WHEN (AND (TYPE-MEMBER INSTRUCTION DTP-EXTERNAL-VALUE-CELL-POINTER
					DTP-CALL-INDIRECT
					DTP-CALL-INDIRECT-PREFETCH)
	       (LINKABLE-LOCATION-P (%SET-TAG INSTRUCTION DTP-LOCATIVE)))
      (WHEN (%MULTIPLE-VALUE-CALL-N LINK-CALL
	      LOCATION 1
	      (AND (TYPE-MEMBER INSTRUCTION DTP-CALL-INDIRECT
				DTP-CALL-INDIRECT-PREFETCH)
		   (COUNT-CALL-ARGUMENTS (%SET-TAG LOCATION DTP-EVEN-PC))) 2)
	(WHEN LINK-NOTER (FUNCALL LINK-NOTER FUNCTION (%SET-TAG LOCATION DTP-EVEN-PC)))
	(WHEN VERBOSE
	  (LET ((LINK (LOCATION-CONTENTS LOCATION)))
	    (FORMAT T "~%Linked PC ~3O to ~S"
		    (* 2 (%POINTER-DIFFERENCE LOCATION FUNCTION))
		    (COND ((TYPE-MEMBER LINK DTP-CALL-COMPILED-EVEN
					     DTP-CALL-COMPILED-EVEN-PREFETCH)
			   (%SET-TAG LINK DTP-EVEN-PC))
			  ((TYPE-MEMBER LINK DTP-CALL-COMPILED-ODD
					     DTP-CALL-COMPILED-ODD-PREFETCH)
			   (%SET-TAG LINK DTP-ODD-PC))
			  ((TYPE-MEMBER LINK DTP-CALL-GENERIC)
			   (%SET-TAG LINK DTP-GENERIC-FUNCTION))
			  (T LINK)))))))))

;; Unlinker

;; Interface:
;; CLI::UNLINK-TO-FUNCTIONS functions-or-t

(DEFUN UNLINK-CALL (CALL-LOCATION)
  (DECLARE (VALUES UNLINKED-P))
  (LET ((INSTRUCTION (%MEMORY-READ CALL-LOCATION :CYCLE-TYPE %MEMORY-BIND-READ)))
    (%P-STORE-CONTENTS CALL-LOCATION
      (COND ((TYPE-MEMBER INSTRUCTION
			  DTP-CALL-COMPILED-EVEN
			  DTP-CALL-COMPILED-EVEN-PREFETCH
			  DTP-CALL-COMPILED-ODD
			  DTP-CALL-COMPILED-ODD-PREFETCH)
	     (MULTIPLE-VALUE-BIND (FUNCTION CCA SIZE)
		 (%FIND-STRUCTURE-EXTENT INSTRUCTION)
	       (WHEN (OR (NOT (COMPILED-FUNCTION-P FUNCTION))
			 (NOT (ZEROP (%P-LDB %%ENTRY-INSTRUCTION-INTERNAL-FUNCTION-P
					     FUNCTION))))
		 (RETURN-FROM UNLINK-CALL NIL))
	       ;; Don't get confused by direct calls pointing to other entry instructions
	       ;; in the same function.  (Hmm.  It looks like this is completely subsumed
	       ;; by the above test!)
	       (WHEN (AND (NOT (%POINTER-LESSP CALL-LOCATION FUNCTION))
			  (%UNSIGNED-LESSP (%POINTER-DIFFERENCE CALL-LOCATION FUNCTION) SIZE)
			  (NOT (ZEROP (%POINTER-DIFFERENCE INSTRUCTION FUNCTION))))
		 (LET ((CONTENTS (%MEMORY-READ INSTRUCTION :CYCLE-TYPE %MEMORY-BIND-READ)))
		   ;; %TAG = %DATA-TYPE because %MEMORY-READ above returns CDR-NEXT.
		   (WHEN ( (%TAG CONTENTS) DTP-PACKED-INSTRUCTION-60)
		     (DBG:OPCODE-SELECT (%POINTER CONTENTS)
		       ((ENTRY-REST-ACCEPTED
			 ENTRY-REST-NOT-ACCEPTED)
			(RETURN-FROM UNLINK-CALL NIL))))))
	       ;; All others can be unlinked in a straightforward fashion.
	       (%SET-TAG (LOCF (CCA-FUNCTION-CELL CCA))
			 (IF (TYPE-MEMBER INSTRUCTION DTP-CALL-COMPILED-EVEN-PREFETCH
						      DTP-CALL-COMPILED-ODD-PREFETCH)
			     DTP-CALL-INDIRECT-PREFETCH
			     DTP-CALL-INDIRECT))))
	    ((TYPE-MEMBER INSTRUCTION DTP-COMPILED-FUNCTION)
	     (WHEN (NOT (ZEROP (%P-LDB %%ENTRY-INSTRUCTION-INTERNAL-FUNCTION-P INSTRUCTION)))
	       ;; Never unlink calls to internal functions.
	       (RETURN-FROM UNLINK-CALL NIL))
	     (%SET-TAG (LOCF (CCA-FUNCTION-CELL (COMPILED-FUNCTION-CCA INSTRUCTION)))
		       DTP-EXTERNAL-VALUE-CELL-POINTER))
	    ((TYPE-MEMBER INSTRUCTION DTP-CALL-GENERIC)	;Not DTP-CALL-GENERIC-PREFETCH!
	     ;; This is too slow.
	     (%SET-TAG (FOLLOW-CELL-FORWARDING
			 (FDEFINITION-LOCATION (GENERIC-FUNCTION-NAME
						 (%SET-TAG INSTRUCTION DTP-GENERIC-FUNCTION)))
			 NIL)
		       ;;--- Need to parse the code to determine prefetch bit.
		       DTP-CALL-INDIRECT))
	    ((TYPE-MEMBER INSTRUCTION DTP-GENERIC-FUNCTION)
	     (LET ((LINKS (GETHASH INSTRUCTION *GENERIC-FUNCTION-LINKS*)))
	       (UNLESS (MEMBER CALL-LOCATION LINKS)
		 (RETURN-FROM UNLINK-CALL NIL))
	       (SETF (GETHASH INSTRUCTION *GENERIC-FUNCTION-LINKS*)
		     (DELETE INSTRUCTION LINKS))
	       (%SET-TAG
		 (FOLLOW-CELL-FORWARDING
		   (FDEFINITION-LOCATION (GENERIC-FUNCTION-NAME
					   (%SET-TAG INSTRUCTION DTP-GENERIC-FUNCTION)))
		   NIL)
		 DTP-EXTERNAL-VALUE-CELL-POINTER)))
	    (T (RETURN-FROM UNLINK-CALL NIL))))
    T))

(DEFUN UNLINK-CALLS (CALLEE-PREDICATE &OPTIONAL UNLINK-NOTER VERBOSE)
  (SI:MAP-COMPILED-FUNCTIONS T NIL "Unlinking function calls"
    (LAMBDA (FUNCTION IGNORE &AUX FLAG)
      (SI:DO-COMPILED-FUNCTION-INSTRUCTIONS (INSTRUCTION LOCATION :SKIP-ENTRY-INSTRUCTION T)
					    FUNCTION
	(WHEN (AND (COND ((TYPE-MEMBER INSTRUCTION DTP-CALL-COMPILED-EVEN
						   DTP-CALL-COMPILED-EVEN-PREFETCH
						   DTP-CALL-COMPILED-ODD
						   DTP-CALL-COMPILED-ODD-PREFETCH)
			  (OR (NULL CALLEE-PREDICATE)
			      (FUNCALL CALLEE-PREDICATE (%FIND-STRUCTURE-HEADER INSTRUCTION))))
			 ((TYPE-MEMBER INSTRUCTION DTP-CALL-GENERIC)
			  (OR (NULL CALLEE-PREDICATE)
			      (FUNCALL CALLEE-PREDICATE
				       (%SET-TAG INSTRUCTION DTP-GENERIC-FUNCTION))))
			 ((TYPE-MEMBER INSTRUCTION DTP-COMPILED-FUNCTION DTP-GENERIC-FUNCTION)
			  (OR (NULL CALLEE-PREDICATE)
			      (FUNCALL CALLEE-PREDICATE INSTRUCTION))))
		   (UNLINK-CALL LOCATION))
	  (WHEN UNLINK-NOTER (FUNCALL UNLINK-NOTER FUNCTION (%SET-TAG LOCATION DTP-EVEN-PC)))
	  (WHEN VERBOSE
	    (UNLESS FLAG
	      (FORMAT T "~%From function ~S" FUNCTION)
	      (SETQ FLAG T))
	    (LET ((CALL (%MEMORY-READ LOCATION :CYCLE-TYPE %MEMORY-BIND-READ)))
	      (FORMAT T "~%   Unlinked PC ~3O to ~A #'~S"
		      (* 2 (%POINTER-DIFFERENCE LOCATION FUNCTION))
		      (DATA-TYPE-NAME (%TAG CALL))
		      (COMPILER:DISASSEMBLE-DECODE-LOCATIVE
			(%SET-TAG CALL DTP-LOCATIVE))))))))))

(DEFUN UNLINK-CALLS-FROM-FUNCTION (FUNCTION CALLEE-PREDICATE &OPTIONAL UNLINK-NOTER VERBOSE)
  (LET (FLAG)
    (SI:DO-COMPILED-FUNCTION-INSTRUCTIONS (INSTRUCTION LOCATION :SKIP-ENTRY-INSTRUCTION T)
					  FUNCTION
      (WHEN (AND (COND ((TYPE-MEMBER INSTRUCTION DTP-CALL-COMPILED-EVEN
				     DTP-CALL-COMPILED-EVEN-PREFETCH
				     DTP-CALL-COMPILED-ODD
				     DTP-CALL-COMPILED-ODD-PREFETCH)
			(OR (NULL CALLEE-PREDICATE)
			    (FUNCALL CALLEE-PREDICATE (%FIND-STRUCTURE-HEADER INSTRUCTION))))
		       ((TYPE-MEMBER INSTRUCTION DTP-CALL-GENERIC)
			(OR (NULL CALLEE-PREDICATE)
			    (FUNCALL CALLEE-PREDICATE
				     (%SET-TAG INSTRUCTION DTP-GENERIC-FUNCTION))))
		       ((TYPE-MEMBER INSTRUCTION DTP-COMPILED-FUNCTION DTP-GENERIC-FUNCTION)
			(OR (NULL CALLEE-PREDICATE)
			    (FUNCALL CALLEE-PREDICATE INSTRUCTION))))
		 (UNLINK-CALL LOCATION))
	(WHEN UNLINK-NOTER (FUNCALL UNLINK-NOTER FUNCTION (%SET-TAG LOCATION DTP-EVEN-PC)))
	(WHEN VERBOSE
	  (UNLESS FLAG
	    (FORMAT T "~%From function ~S" FUNCTION)
	    (SETQ FLAG T))
	  (LET ((CALL (%MEMORY-READ LOCATION :CYCLE-TYPE %MEMORY-BIND-READ)))
	    (FORMAT T "~%   Unlinked PC ~3O to ~A #'~S"
		    (* 2 (%POINTER-DIFFERENCE LOCATION FUNCTION))
		    (DATA-TYPE-NAME (%TAG CALL))
		    (COMPILER:DISASSEMBLE-DECODE-LOCATIVE
		      (%SET-TAG CALL DTP-LOCATIVE)))))))))

(DEFUN NOTE-UNLINKED (FUNCTION &OPTIONAL IGNORE)
  (IF (COMPILED-FUNCTION-P FUNCTION)
      (IF (NOT (ZEROP (%P-LDB %%ENTRY-INSTRUCTION-LINKED-REFERENCES-EXIST-P FUNCTION)))
	  (SETF (%P-LDB %%ENTRY-INSTRUCTION-LINKED-REFERENCES-EXIST-P FUNCTION) 0))
      (IF (FLAVOR::GENERIC-FUNCTION-LINKED FUNCTION)
	  (SETF (FLAVOR::GENERIC-FUNCTION-LINKED FUNCTION) NIL))))

(DEFUN UNLINK-TO-FUNCTIONS (FUNCTIONS &OPTIONAL UNLINK-NOTER VERBOSE)
  ;; There are real timing problems here which have to be addressed.
  (IF (EQ FUNCTIONS T)
      (PROGN (UNLINK-CALLS NIL UNLINK-NOTER VERBOSE)
	     (SI:MAP-COMPILED-FUNCTIONS T NIL "Updating compiled function link attributes"
					#'NOTE-UNLINKED)
	     (TV:DOLIST-NOTING-PROGRESS (NAME *ALL-GENERIC-FUNCTION-NAMES*
					       "Updating generic function link attributes")
	       (LET ((GF (FLAVOR:FIND-GENERIC-FUNCTION NAME NIL)))
		 (WHEN GF (NOTE-UNLINKED GF)))))
    (UNLESS (LISTP FUNCTIONS)
      (SETQ FUNCTIONS (LIST FUNCTIONS)))
    (SETQ FUNCTIONS (LOOP FOR FUNCTION IN FUNCTIONS
			  WHEN (TYPE-MEMBER FUNCTION DTP-COMPILED-FUNCTION
						     DTP-GENERIC-FUNCTION)
			    COLLECT FUNCTION
			  ELSE
			    COLLECT (FDEFINITION FUNCTION)))
    (UNLINK-CALLS #'(LAMBDA (FUNCTION) (MEMBER FUNCTION FUNCTIONS)) UNLINK-NOTER VERBOSE)
    (TV:DOLIST-NOTING-PROGRESS (FUNCTION FUNCTIONS "Updating function link attributes")
      (NOTE-UNLINKED FUNCTION))))

(DEFUN UNLINK-TO-FUNCTIONS-USING-WHO-CALLS (FUNCTIONS &OPTIONAL UNLINK-NOTER VERBOSE)
  (IF (EQ FUNCTIONS T)
      (UNLINK-TO-FUNCTIONS FUNCTIONS UNLINK-NOTER VERBOSE)
    (UNLESS (LISTP FUNCTIONS)
      (SETQ FUNCTIONS (LIST FUNCTIONS)))
    (SETQ FUNCTIONS (LOOP FOR FUNCTION IN FUNCTIONS
			  WHEN (TYPE-MEMBER FUNCTION DTP-COMPILED-FUNCTION
						     DTP-GENERIC-FUNCTION)
			    COLLECT FUNCTION
			  ELSE
			    COLLECT (FDEFINITION FUNCTION)))
    (TV:DOLIST-NOTING-PROGRESS (FUNCTION FUNCTIONS "Unlinking references using Who-Calls")
      (LET ((NAME (IF (TYPE-MEMBER FUNCTION DTP-COMPILED-FUNCTION)
		      (SI:COMPILED-FUNCTION-NAME FUNCTION)
		      (GENERIC-FUNCTION-NAME FUNCTION))))
	(SI:MAP-OVER-CALLERS NAME
	  (LAMBDA (CALLER IGNORE)
	    ;; The caller can be undefined due to who-calls lossage I don't understand...
	    (WHEN (FDEFINEDP CALLER)
	      (LET ((DEFINITION (FDEFINITION CALLER)))
		(WHEN (COMPILED-FUNCTION-P DEFINITION)
		  (UNLINK-CALLS-FROM-FUNCTION DEFINITION
					      #'(LAMBDA (F) (EQ FUNCTION F))
					      UNLINK-NOTER
					      VERBOSE)))))
	  :CALLED-HOW :FUNCTION)
	 (NOTE-UNLINKED FUNCTION)
	 ))))

;;;; Simple test suite for the guts of function linking.  Compile this
;;;; stuff, then link and run TEST-LINKING and TEST-LINKING-1.

#||

(defun link-target-0 (a b &optional (c 2) (d 3))
  (list a b c d))

(defun link-target-1 (a b &optional (c 2) (d 3) &rest e)
  (list* a b c d (copy-list e)))

;;; CL:IDENTITY, except that it doesn't get optimized out by the compiler.
(defun bogus (argument) argument)

(defmacro link-test (&key (spread 0) (apply 0 apply-p) rest)
  `(let ((result
	   ,(if apply-p
		`(with-stack-list (list ,@(loop repeat apply for i from spread
						collect i))
		   (apply
		     #',(if rest 'link-target-1 'link-target-0)
		     ,@(loop repeat spread for i from 0 collect i)
		     list))
	      `(,(if rest 'link-target-1 'link-target-0)
		,@(loop repeat spread for i from 0 collect i)))))
     (when (not (equal result ,(list 'quote
				     (loop for i below (max 4 (+ spread apply))
					   collect i))))
       (error "Failed case with ~D spread, ~D apply arguments"
	       ,spread ,apply))))

;;; This version inserts a long branch and function call between each start/finish call.
(defmacro link-test-1 (&key (spread 0) (apply 0 apply-p) rest)
  `(let ((result
	   ,(if apply-p
		`(with-stack-list (list ,@(loop repeat apply for i from spread
						collect i))
		   (apply
		     #',(if rest 'link-target-1 'link-target-0)
		     ,@(loop repeat spread for i from 0
			     when (> i 0)
			       collect i
			     else
			       collect `(compiler:%error-when (not (null #'link-target-1))
							      (bogus 0)))
		     list))
	      `(,(if rest 'link-target-1 'link-target-0)
		,@(loop repeat spread for i from 0
			when (> i 0)
			  collect i
			else
			  collect `(compiler:%error-when (not (null #'link-target-1))
							 (bogus 0)))))))
     (when (not (equal result ,(list 'quote
				     (loop for i below (max 4 (+ spread apply))
					   collect i))))
       (error "Failed case with ~D spread, ~D apply arguments"
	       ,spread ,apply))))

(defun test-linking ()
  (link-test :spread 2)
  (link-test :spread 3)
  (link-test :spread 4)
  (link-test :spread 0 :apply 2)		;pull 2, default 2 optionals
  (link-test :spread 0 :apply 3)		;pull 3, default 1 optional
  (link-test :spread 0 :apply 4)		;pull 4
  (link-test :spread 1 :apply 1)		;pull 1, default 2 optionals
  (link-test :spread 1 :apply 2)		;pull 2, default 1 optional
  (link-test :spread 1 :apply 3)		;pull 3
  (link-test :spread 2 :apply 0)		;canonicalize, default 2 optionals
  (link-test :spread 2 :apply 1)		;pull 1, default 1 optional
  (link-test :spread 2 :apply 2)		;pull 2
  (link-test :spread 3 :apply 0)		;canonicalize, default 1 optional
  (link-test :spread 3 :apply 1)		;pull 1
  (link-test :spread 4 :apply 0)		;canonicalize
  (link-test :spread 2 :rest t)			;default 2 optionals, rest
  (link-test :spread 3 :rest t)			;default 1 optional, rest
  (link-test :spread 4 :rest t)			;default rest
  (link-test :spread 5 :rest t)			;push 1 apply arg
  (link-test :spread 6 :rest t)			;push 2 apply args
  (link-test :spread 0 :apply 2 :rest t)	;pull 2, default 2 optionals, rest
  (link-test :spread 0 :apply 3 :rest t)	;pull 3, default 1 optional, rest
  (link-test :spread 0 :apply 4 :rest t)	;pull 4, default rest (maybe not?)
  (link-test :spread 0 :apply 5 :rest t)	;pull 4
  (link-test :spread 1 :apply 1 :rest t)	;pull 1, default 2 optionals, rest
  (link-test :spread 1 :apply 2 :rest t)	;pull 2, default 1 optional, rest
  (link-test :spread 1 :apply 3 :rest t)	;pull 3, default rest (maybe?)
  (link-test :spread 1 :apply 4 :rest t)	;pull 3
  (link-test :spread 2 :apply 0 :rest t)	;canonicalize, default 2 optionals, rest
  (link-test :spread 2 :apply 1 :rest t)	;pull 1, default 1 optional, rest
  (link-test :spread 2 :apply 2 :rest t)	;pull 2, default rest
  (link-test :spread 2 :apply 3 :rest t)	;pull 2
  (link-test :spread 3 :apply 0 :rest t)	;canonicalize, default 1 optional, rest
  (link-test :spread 3 :apply 1 :rest t)	;pull 1, default rest
  (link-test :spread 3 :apply 2 :rest t)	;pull 1
  (link-test :spread 4 :apply 0 :rest t)	;canonicalize, default rest
  (link-test :spread 4 :apply 1 :rest t)	;easy
  (link-test :spread 5 :apply 0 :rest t)	;canonicalize (?), push 1 apply arg
  (link-test :spread 5 :apply 1 :rest t)	;push 1 apply arg
  (link-test :spread 6 :apply 0 :rest t)	;canonicalize (?), push 2 apply args
  (link-test :spread 6 :apply 1 :rest t))	;push 2 apply args

(defun test-linking-1 ()
  (link-test-1 :spread 2)
  (link-test-1 :spread 3)
  (link-test-1 :spread 4)
  (link-test-1 :spread 0 :apply 2)		;pull 2, default 2 optionals
  (link-test-1 :spread 0 :apply 3)		;pull 3, default 1 optional
  (link-test-1 :spread 0 :apply 4)		;pull 4
  (link-test-1 :spread 1 :apply 1)		;pull 1, default 2 optionals
  (link-test-1 :spread 1 :apply 2)		;pull 2, default 1 optional
  (link-test-1 :spread 1 :apply 3)		;pull 3
  (link-test-1 :spread 2 :apply 0)		;canonicalize, default 2 optionals
  (link-test-1 :spread 2 :apply 1)		;pull 1, default 1 optional
  (link-test-1 :spread 2 :apply 2)		;pull 2
  (link-test-1 :spread 3 :apply 0)		;canonicalize, default 1 optional
  (link-test-1 :spread 3 :apply 1)		;pull 1
  (link-test-1 :spread 4 :apply 0)		;canonicalize
  (link-test-1 :spread 2 :rest t)		;default 2 optionals, rest
  (link-test-1 :spread 3 :rest t)		;default 1 optional, rest
  (link-test-1 :spread 4 :rest t)		;default rest
  (link-test-1 :spread 5 :rest t)		;push 1 apply arg
  (link-test-1 :spread 6 :rest t)		;push 2 apply args
  (link-test-1 :spread 0 :apply 2 :rest t)	;pull 2, default 2 optionals, rest
  (link-test-1 :spread 0 :apply 3 :rest t)	;pull 3, default 1 optional, rest
  (link-test-1 :spread 0 :apply 4 :rest t)	;pull 4, default rest (maybe not?)
  (link-test-1 :spread 0 :apply 5 :rest t)	;pull 4
  (link-test-1 :spread 1 :apply 1 :rest t)	;pull 1, default 2 optionals, rest
  (link-test-1 :spread 1 :apply 2 :rest t)	;pull 2, default 1 optional, rest
  (link-test-1 :spread 1 :apply 3 :rest t)	;pull 3, default rest (maybe?)
  (link-test-1 :spread 1 :apply 4 :rest t)	;pull 3
  (link-test-1 :spread 2 :apply 0 :rest t)	;canonicalize, default 2 optionals, rest
  (link-test-1 :spread 2 :apply 1 :rest t)	;pull 1, default 1 optional, rest
  (link-test-1 :spread 2 :apply 2 :rest t)	;pull 2, default rest
  (link-test-1 :spread 2 :apply 3 :rest t)	;pull 2
  (link-test-1 :spread 3 :apply 0 :rest t)	;canonicalize, default 1 optional, rest
  (link-test-1 :spread 3 :apply 1 :rest t)	;pull 1, default rest
  (link-test-1 :spread 3 :apply 2 :rest t)	;pull 1
  (link-test-1 :spread 4 :apply 0 :rest t)	;canonicalize, default rest
  (link-test-1 :spread 4 :apply 1 :rest t)	;easy
  (link-test-1 :spread 5 :apply 0 :rest t)	;canonicalize (?), push 1 apply arg
  (link-test-1 :spread 5 :apply 1 :rest t)	;push 1 apply arg
  (link-test-1 :spread 6 :apply 0 :rest t)	;canonicalize (?), push 2 apply args
  (link-test-1 :spread 6 :apply 1 :rest t))

||#
