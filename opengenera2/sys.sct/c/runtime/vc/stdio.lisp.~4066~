;;; -*- Mode: LISP; Package: C-SYSTEM; Base: 10; Lowercase: Yes -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");; This file contains the C interface to input/output facilities.
;; There are two levels of interface. First, there is the interface
;; to the C functions and constants that are defined in the ANSI
;; standard as living in <stdio.h>. Second, there is the stream 
;; interface to the Lisp world. The protocol defined contains the
;; following operations: :open, :close, :seek, :tyo, :tyi, :string-in,
;; :string-out, :temp-p.


;; Simple Utilities

;; the interface to the C file stdio.h

0;       (2 0 (NIL 0) (SAGE:SANS-SERIF-BODY SAGE::TYPEWRITER :NORMAL) "CPTFONT")     #define _IOFBF 1
0;       2     #define _IOLBF 2
0;       2     #define _IONBF 3
0;
;       2     #define BUFSIZ 1024
0;
;       2     #define EOF -1
0;
;       2     #define L_tmpnam 40
0;
;       2     #define SEEK_CUR 1
0;       2     #define SEEK_END 2
0;       2     #define SEEK_SET 3
0;
;       2     #define OPEN_MAX 8
0;
;       2     #define TMP_MAX 32767
0;
;       2     #define stderr _stderr
0;       2     #define stdin _stdin
0;       2     #define stdout _stdout

0(zl:defconst _IOFBF 1)

(zl:defconst _IOLBF 2)

(zl:defconst _IONBF 3)

(zl:defconst BUFSIZ 1024)

(zl:defconst L_tmpnam 40)


(zl:defconst SEEK_END 1)

(zl:defconst SEEK_CUR 2)

(zl:defconst SEEK_SET 3)

(zl:defconst OPEN_MAX 8)

(zl:defconst TMP_MAX 32767)

1;; Special bound to a string by c-sys::execute, holds the lisp version of format string
0(defvar *format-string* nil) 
1;; Special bound if you don't want to echo.
0(defvar *no-echo* nil)
(zl:defconst L_tmpname 40)
1;; counter of tmp files for the purposes
;; of getting past two tmp files created in the
;; same micro-second
0(defvar *tmp-name-counter* 0)
(defconstant c-null 0)				

1;; tracing tag bytes etc.
0(defmacro tag-byte-p (actual-position)
  `(= (rem ,actual-position 9) 0))

(defmacro translate-to-actual (virtual-position)
  `(+ ,virtual-position (floor ,virtual-position 8) 1))

(defmacro translate-to-virtual (actual-position)
  `(floor (* ,actual-position 8) 9))

(defmacro tag-byte-offset-from-actual (actual-position)
  `(let ((temp ,actual-position))
     (- temp (* 9 (floor temp 9)))))

(defmacro tag-byte-position (actual-position)
  `(- ,actual-position (mod ,actual-position 9)))

1;; keeps track of the currently open files.
0(defvar *c-open-files* nil)

1;; error indicators
0(defconstant no-error-indication 0)
(defconstant error-indication -1)

1;; compute the word offset of an array.
0(defmacro word-offset (byte-offset)
  `(ash ,byte-offset -2))

;;;
;;; PURPOSE:	Create a C string from a Lisp string.
;;; ARGUMENTS:  The Lisp string.
;;; RETURNS:	An art-q array of length (floor (+ lisp-string-size 4) 4) all of whose
;;;	elements are actually fixnums.
;;;
(defun copy-lisp-string-into-c-string (lisp-string)
  (if lisp-string
      (do* ((lisp-string-size (length lisp-string))
	    ;;
	    ;;      The floor size computation below is designed to account for the null
	    ;; character which we have to append to the resulting C string.
	    ;;
	    (c-string-object (make-array (floor (+ lisp-string-size 4) 4)
					 :element-type t
					 :initial-element 0
					 :adjustable nil))
	    (char-offset 0 (+ char-offset 1)))
	   ((= char-offset lisp-string-size)
	    ;;
	    ;;      bash in the null character ('\0')
	    ;;
	    (setf (si:octet-aref-8 c-string-object char-offset) 0)
	    (values c-string-object 0))
	(setf (si:octet-aref-8 c-string-object char-offset) (char-code
							      (aref lisp-string char-offset))))
      (values nil 0)))

1;; file stream flavors that correspond to the possible C cases
;; The different streams are decided by the possible modes given
;; in the C standard. In addition, there is a different flavor
;; for temporary files. Stdin, stdout, and stderr are represented
;; by *standard-input*, *standard-output*, *error-output* respectively.

0(zl:defconst *c-file-flavors*
  '(("r" .
     ( c-text-stream
		     :element-type string-char
		     :direction :input
		     :if-exists :overwrite
		     :if-does-not-exist :error))
    ("w" .
     ( c-text-stream
		     :element-type string-char
		     :direction :output
		     :if-exists :truncate
		     :if-does-not-exist :create))
    ("v" .
     ( c-text-stream
		     :element-type string-char
		     :direction :output
		     :if-exists :new-version
		     :if-does-not-exist :create))
    ("a" .
     ( c-append-text-stream
		     :element-type string-char
		     :direction :output
		     :if-exists :append
		     :if-does-not-exist :create))
    ("rb" .
     ( c-binary-direct-stream
		     :element-type (unsigned-byte 8)
		     :direction :io
		     :if-exists :overwrite
		     :if-does-not-exist :error))
    ("wb" .
     ( c-binary-direct-stream
		     :element-type (unsigned-byte 8)
		     :direction :io
		     :if-exists :truncate
		     :if-does-not-exist :create))
    ("vb" .
     ( c-binary-direct-stream
		     :element-type (unsigned-byte 8)
		     :direction :io
		     :if-exists :new-version
		     :if-does-not-exist :create))
    ("ab" .
     ( c-append-binary-direct-stream
		     :element-type (unsigned-byte 8)
		     :direction :io
		     :if-exists :append
		     :if-does-not-exist :create))
    ("r+" .
     ( c-char-direct-stream
		     :element-type (unsigned-byte 8)
		     :direction :io
		     :if-exists :overwrite
		     :if-does-not-exist :error))
    ("w+" .
     ( c-char-direct-stream
		     :element-type (unsigned-byte 8)
		     :direction :io
		     :if-exists :supersede
		     :if-does-not-exist :create))
    ("v+" .
     ( c-char-direct-stream
		     :element-type (unsigned-byte 8)
		     :direction :io
		     :if-exists :new-version
		     :if-does-not-exist :create))
    ("a+" .
     ( c-append-char-direct-stream
		     :element-type (unsigned-byte 8)
		     :direction :io
		     :if-exists :append
		     :if-does-not-exist :create))
    ("r+b" .
     ( c-binary-direct-stream
		     :element-type (unsigned-byte 8)
		     :direction :io
		     :if-exists :overwrite
		     :if-does-not-exist :error))
    ("rb+" .
     ( c-binary-direct-stream
		     :element-type (unsigned-byte 8)
		     :direction :io
		     :if-exists :overwrite
		     :if-does-not-exist :error))
    ("w+b" .
     ( c-binary-direct-stream
		     :element-type (unsigned-byte 8)
		     :direction :io
		     :if-exists :supersede
		     :if-does-not-exist :create))
    ("wb+" .
     ( c-binary-direct-stream
		     :element-type (unsigned-byte 8)
		     :direction :io
		     :if-exists :supersede
		     :if-does-not-exist :create))
    ("v+b" .
     ( c-binary-direct-stream
		     :element-type (unsigned-byte 8)
		     :direction :io
		     :if-exists :new-version
		     :if-does-not-exist :create))
    ("vb+" .
     ( c-binary-direct-stream
		     :element-type (unsigned-byte 8)
		     :direction :io
		     :if-exists :new-version
		     :if-does-not-exist :create))
    ("a+b" .
     ( c-append-binary-direct-stream
		     :element-type (unsigned-byte 8)
		     :direction :io
		     :if-exists :append
		     :if-does-not-exist :create))
    ("ab+" .
     ( c-append-binary-direct-stream
		     :element-type (unsigned-byte 8) 
		     :direction :io
		     :if-exists :append
		     :if-does-not-exist :create))))

(defflavor c-stream
	((direction :input)
	 (if-exists :error)
	 (if-does-not-exist :error)
	 (element-type 'string-char)
	 (stream nil)
	 (start-position 0)
	 (position 0)
	 (file-size 0)
	 (char-to-untyi nil)
	 (count 0)
	 (error-indicator 0)
	 (file-name nil)
	 (eof-p nil))
	()
  (:gettable-instance-variables)
  (:settable-instance-variables start-position position stream count file-name eof-p error-indicator)
  (:initable-instance-variables element-type direction if-exists if-does-not-exist))


(defflavor c-text-stream
	()
	(c-stream)
  :initable-instance-variables
  :gettable-instance-variables
  :settable-instance-variables)
(defflavor c-append-text-stream
	()
	(c-text-stream)
  :initable-instance-variables
  :gettable-instance-variables
  :settable-instance-variables)

(defflavor c-direct-stream
	((mode :output))
	(c-stream)
  :gettable-instance-variables
  (:settable-instance-variables mode)
  :initable-instance-variables)

(defflavor c-char-direct-stream
	((buffer-size 1))
	(c-direct-stream c-stream)
  :gettable-instance-variables
  :settable-instance-variables
  :initable-instance-variables)
(defflavor c-append-char-direct-stream
	()
	(c-char-direct-stream)
  :gettable-instance-variables
  :settable-instance-variables
  :initable-instance-variables)

(defflavor c-binary-direct-stream
	((buffer-size 1)
	 (tag-byte nil))
	(c-direct-stream c-stream)
  :gettable-instance-variables
  :settable-instance-variables
  :initable-instance-variables)

(defflavor c-append-binary-direct-stream
	()
	(c-binary-direct-stream)
  :gettable-instance-variables
  :settable-instance-variables
  :initable-instance-variables)

1;; in a c-string-stream the stream is a c-string.  the
;; stream-offset is the offset of the pointer passed to
;; sprintf. :String-in, :tyi, :tyo and :String-out just copy
;; between a lisp string and the C counterpart, in or out.
0(defflavor c-string-stream
	((stream-offset 0))
	(c-stream)
  :gettable-instance-variables
  :settable-instance-variables
  :initable-instance-variables)

(defflavor temporary-binary-stream
	()
	(c-binary-direct-stream))

1;; The following documents how the various streams are mapped onto
;; si:open.
0;       2       :element-type    :direct  :direction  :if-exists  :if-does-not-ex0ist
;
1;       r       string-char       nil     :input     :dont-care       :error 
;
0;       2w       string-char       nil     :output    :truncate        :create
0;
;       2a       string-char       nil     :output     :append         :create
0;
;       2rb   (unsigned-byte 8)     t      :input     :dont-care       :error
0;
;       2wb   (unsigned-byte 8)     t      :output    :truncate        :create
0;
;       2ab   (unsigned-byte 8)     t      :output     :append         :create
0;
;       2r+      string-char       1 t2       :io      :overwrite       :error
0;
;       2w+      string-char       1 t2       :io      :truncate        :create
0;
;       2a+      string-char       1 t2       :io       :append         :create
0;
;       2r+b  (unsigned-byte 8)     t        :io      :overwrite       :error
0;
;       2w+b  (unsigned-byte 8)     t        :io      :truncate        :create
0;
;       2a+b  (unsigned-byte 8)     t        :io       :append         :create

0(defmethod (:open c-text-stream) ()
  (unless stream
    (setq stream (open file-name :element-type 'string-char
		                 :direction direction
				 :if-does-not-exist if-does-not-exist
				 :if-exists if-exists))
    (setq start-position (send stream :read-pointer))
    (setq position start-position))
  self)

(defmethod (:fseek c-text-stream) (offset whence)
  (declare (special c-user::|errno|))
  (setq char-to-untyi nil)
  (setq eof-p nil)
  (flet ((return-error-indication ()
	   (declare (sys:downward-function))
	   (setf (si:octet-aref c-user::|errno| 0) 1)
	   (return-from :fseek error-indication)))
     (cond (stream
	    (unless (or (= offset 0) (= whence SEEK_SET))
	      (return-error-indication))
	    
	    (when (or (< offset 0) (< offset start-position))
	      (setf (si:octet-aref c-user::|errno| 0) 1)
	      (return-from :fseek EOF))
	    
	    (cond
	       ((= whence SEEK_SET)
		(send stream :set-pointer offset)
		(setq position offset))
	       ((= whence SEEK_CUR))		1; fseek(f,0L,SEEK_CUR) is a no-op
0	       ((= whence SEEK_END)
		(file-position stream ':end)	1; fseek(f,0L,SEEK_END)
0		(setq position (file-position stream)))
	       (t (return-error-indication)))
	    no-error-indication)
	   (t (setf (si:octet-aref c-user::|errno| 0) 1)
	      EOF))))
1;;;
0(defmethod (:fseek c-append-text-stream) (offset whence)
  (declare (special c-user::|errno|))
  (setq char-to-untyi nil)
  (setq eof-p nil)
  (flet ((return-error-indication ()
	   (declare (sys:downward-function))
	   (setf (si:octet-aref c-user::|errno| 0) 1)
	   (return-from :fseek error-indication)))
     (cond (stream
	    (unless (or (= offset 0) (= whence SEEK_SET))
	      (return-error-indication))
	    
	    (when (or (< offset 0) (< offset start-position))
	      (setf (si:octet-aref c-user::|errno| 0) 1)
	      (return-from :fseek EOF))
	    
	    (cond
	       ((= whence SEEK_SET)
		(send stream :set-pointer offset)
		(setq position offset))
	       ((= whence SEEK_CUR))		1; fseek(f,0L,SEEK_CUR) is a no-op
0	       ((= whence SEEK_END)
		(file-position stream (max position start-position))	1; fseek(f,0L,SEEK_END)
0		(setq position (file-position stream)))
	       (t (return-error-indication)))
	    no-error-indication)
	   (t (setf (si:octet-aref c-user::|errno| 0) 1)
	      EOF))))
(defmethod (:fseek c-char-direct-stream) (offset whence)
  (declare (special c-user::|errno|))
  (setq char-to-untyi nil)
  (setq eof-p nil)
  (cond (stream
	 (send stream :finish)

	 (let ((offset-to-seek-to
		 (select whence
		   (SEEK_SET offset)
		   (SEEK_CUR (+ position offset))
		   (SEEK_END (+ offset file-size))
		   (otherwise (setf (si:octet-aref c-user::|errno| 0) 1)
			      (return-from :fseek error-indication)))))
	   (when (< offset-to-seek-to 0)
	     (setf (si:octet-aref c-user::|errno| 0) 1)
	     (return-from :fseek EOF))

	   (case mode
	     (:notinput (setq mode :dont-care))
	     (:notoutput (setq mode :dont-care))
	     (otherwise nil))
    
	   (send stream :set-pointer offset-to-seek-to)
	   (setq position offset-to-seek-to)
	   no-error-indication))
	(t (setf (si:octet-aref c-user::|errno| 0) 1)
	   EOF)))

(defmethod (:open c-binary-direct-stream) ()
  (unless stream
    (setq stream (open file-name :element-type element-type
		       :direction direction
		       :direct t
		       :if-does-not-exist if-does-not-exist
		       :if-exists if-exists))
    (setq mode :dont-care)
    (setq position
	  (translate-to-virtual
	    (progn
	      (cond ((and (eq direction :io) (eq if-exists :append))
		     (file-position stream :end))
		    ((and (eq direction :output) (eq if-exists :append))
		     (let ((end-position (send stream :read-pointer)))
		       1;; this is the only way I know how to get what
0		       1;; I want in this instance.
0		       (send stream :close)
		       (setq stream (open file-name :element-type element-type
					  :direction direction
					  :direct t
					  :if-does-not-exist if-does-not-exist
					  :if-exists :overwrite))
		       (send stream :set-pointer end-position)))
		    (t nil))
	      (file-position stream))))
    ;; establish the absolute size of the file.
    (when (send-if-handles stream :length) 
      (setq file-size (translate-to-virtual
			(zl:get (send stream :properties)
			     :length-in-bytes))))
    (setq start-position position))
  self)

(defmethod (:open c-char-direct-stream) ()
  (unless stream
    (setq stream (open file-name :element-type element-type
		                 :direction direction
				 :direct t
				 :if-does-not-exist if-does-not-exist
				 :if-exists if-exists))
    (setq mode :dont-care)
    (setq position
	  (progn
	      (cond ((and (eq direction :io) (eq if-exists :append))
		     (file-position stream :end))
		    ((and (eq direction :output) (eq if-exists :append))
		     (let ((end-position (send stream :read-pointer)))
		       1;; this is the only way I know how to get what
0		       1;; I want in this instance.
0		       (send stream :close)
		       (setq stream (open file-name :element-type element-type
					  :direction direction
					  :direct t
					  :if-does-not-exist if-does-not-exist
					  :if-exists :overwrite))
		       (send stream :set-pointer end-position)))
		    (t nil))
	      (file-position stream)))
    ;; establish the absolute size of the file.
    (when (send-if-handles stream :length) 
      (setq file-size (zl:get (send stream :properties)
			   :length-in-bytes)))
    (setq start-position position))
  self)

(defmethod (:fseek c-binary-direct-stream) (offset whence)
  (declare (special c-user::|errno|))
  (setq char-to-untyi nil)
  (setq eof-p nil)

  (cond (stream
	 (when (operation-handled-p stream :finish)
	   (send stream :finish))
	 
	 (let ((offset-to-seek-to
		 (select whence
		   (SEEK_SET offset)
		   (SEEK_CUR (+ position offset))
		   (SEEK_END (+ offset file-size))
		   (otherwise (return-from :fseek error-indication)))))

	   (when (< offset-to-seek-to 0)
	     (setf (si:octet-aref c-user::|errno| 0) 1)
	     (return-from :fseek EOF))

	   (case mode
	     (:notinput (setq mode :dont-care))
	     (:notoutput (setq mode :dont-care))
	     (otherwise nil))
    
	   (send self :set-pointer offset-to-seek-to)
	   no-error-indication))
	(t (setf (si:octet-aref c-user::|errno| 0) 1)
	   EOF)))
(defmethod (:eof c-stream) ()
  eof-p)

(defmethod (:close c-stream) ()
  (cond (stream
	 (send stream :close)
	 (setq position nil)
	 (setq stream nil)
	 (setq error-indicator no-error-indication)
	 no-error-indication)
	(t error-indication)))

(defmethod (:close temporary-binary-stream) ()
  (cond (stream
	 (send stream :close)
	 (delete-file file-name nil)
	 (setq position nil)
	 (setq stream nil)
	 (setq error-indicator no-error-indication)
	 no-error-indication)
	(t error-indication)))


(defmethod (:finish c-stream) ()
  (declare (values))
  (setq char-to-untyi nil)
  (when stream (send stream :finish))
  (values))

(defmethod (:finish c-char-direct-stream) ()
  (declare (values))
  (setq char-to-untyi nil)
  (when stream (send stream :finish))
  (when (eq mode :notoutput)
    (send stream :set-pointer position))
  (setq mode :dont-care)
  (values))

(defmethod (:finish c-binary-direct-stream) ()
  (declare (values))
  (setq char-to-untyi nil)
  (when stream (send stream :finish))
  (when (eq mode :notoutput)
    (send self :set-pointer position))
  (setq mode :dont-care)
  (values))

(defmethod (:finish c-string-stream) ()
  (declare (values))
  (setq char-to-untyi nil)
  (values))

(defmethod (:get-pos c-stream) ()
  (cond (stream
	 (file-position stream))
	(t error-indication)))

(defmethod (:untyi c-stream) (char)
  (when (and char (= char EOF))
    (return-from :untyi EOF))
  
  (cond (stream
	 (when char-to-untyi
	     (setq char-to-untyi nil)
	     (return-from :untyi EOF))
	 (decf position)
	 (setq eof-p nil)
	 (setq char-to-untyi char))
	(t error-indication)))

(defmethod (:tyi c-stream) ()
  (cond (stream
	 (let ((current-char (or (and char-to-untyi (code-char char-to-untyi))
				 (send stream :tyi))))
	   (setq char-to-untyi nil)
	   (if current-char
	       (progn
		 (unless (or *no-echo*
			     si:rubout-handler
			     (not (funcall stream :interactive)))
		   ;; 1the same test as read-char in the system.
0		   (send stream :tyo current-char))
		 (incf position)
		 (incf count)
		 (char-code current-char))
	       (progn
		 (setq eof-p t)
		 EOF))))
	 (t error-indication)))
1;; returns t if the stream wants to be input edited.
0(defmethod (input-editable c-stream) ()
  (not (or *no-echo* si:rubout-handler (not (funcall stream :interactive)))))
;; N.B. if number-of-characters is nil, all it means is that :line-in will use it's own buffering
;; and not make a copy of every string.

(defvar *fgetc-buffer* nil)

(defun get-read-string-buffer ()
  (if *fgetc-buffer*
      *fgetc-buffer*
      (setq *fgetc-buffer* (make-string 128 :initial-element #\space :element-type 'character))))

(defun make-longer-read-string-buffer (short-buffer)
  (let* ((short-buffer-size (zl:array-length short-buffer))
	 (longer-buffer (make-string (* 2 short-buffer-size) :initial-element #\space :element-type 'character)))
    (loop for i from 0 below short-buffer-size
	  do (setf (aref longer-buffer i) (aref short-buffer i)))
    longer-buffer))


(defmethod (:read-string-internal c-stream) (string-array string-offset &optional number-of-characters)
  (if (and *no-echo* (send stream :interactive))	; interactive streams are treated specially in the no-echo case.
      (let ((line (zl:readline-no-echo stream)))
	(copy-lisp-string-to-c-string line 0 (zl:array-length line) string-array string-offset)
	(values string-array string-offset nil nil (zl:array-length line)))
      (let ((start-offset (if char-to-untyi 1 0))
	    (buffer (get-read-string-buffer))
	    length-so-far more-on-line-p)
	1;; if there was some untyi before you.
0	(when char-to-untyi
	  (setf (aref buffer 0) (code-char char-to-untyi))
	  (when number-of-characters (decf number-of-characters))
	  (setq char-to-untyi nil))

	(loop for start = start-offset then length-so-far
	      as curr-buff-len = (zl:array-length buffer)
	      do (multiple-value-setq (length-so-far eof-p more-on-line-p)
		   (send stream :string-line-in nil buffer start
			 (if number-of-characters
			     (min (+ number-of-characters start) curr-buff-len)
			     curr-buff-len)))
		 (when number-of-characters (decf number-of-characters (- length-so-far start)))
		 (when (and eof-p (= length-so-far 0))
		   (return-from :read-string-internal (values nil 0 eof-p nil length-so-far)))
	      until (or eof-p (not more-on-line-p) (when number-of-characters ( number-of-characters 0)))
	      do (setq buffer (make-longer-read-string-buffer buffer)))
	(let ((buffer-length (min (zl:array-length buffer) length-so-far)))
	  (copy-lisp-string-to-c-string buffer 0 buffer-length string-array string-offset)
	  (values string-array string-offset eof-p more-on-line-p buffer-length))))) 

(defmethod (:read-string c-stream) (string-array string-offset &optional number-of-characters)
  (if (input-editable self)
      (with-input-editing (stream)
	(send self :read-string-internal string-array string-offset number-of-characters))
      (send self :read-string-internal string-array string-offset number-of-characters)))
1;;;
0(defmethod (:string-out c-stream) (string &optional (start 0) end)
  (setq char-to-untyi nil)
  (let* ((computed-end (or end (string-length string)))
	 (number-of-chars (- computed-end start)))
     (incf count number-of-chars)
     (incf position number-of-chars))
  (send stream :string-out string start end))
1;;;
0(defwhopper (:string-out c-append-text-stream) (string &optional (start 0) end)
  (setq position (max start-position position))
  (file-position stream position)
  (continue-whopper string start end))
1;;;
0(defmethod (:tyo c-stream) (char)
  (setq char-to-untyi nil)
  (incf position)
  (incf count)
  (send stream :tyo char))
1;;;
0(defwhopper (:tyo c-append-text-stream) (char)
  (setq position (max position start-position))
  (file-position stream position)
  (continue-whopper char))

(defmethod (:string-out c-string-stream) (string &optional (start 0) end)
  (let ((string-length 
	  (if end
	      (- end start)
	      (- (string-length string) start))))
    (setq char-to-untyi nil)
    (incf count string-length)
    (copy-lisp-string-to-c-string string start (if end end (string-length string)) stream stream-offset)
    (incf stream-offset string-length)
    string))

(defmethod (:tyo c-string-stream) (char)
  (setq char-to-untyi nil)
  (sys:octet-aset-8 (char-code char) stream stream-offset)
  (incf stream-offset)
  (incf count))
1;; do you need to be able to untyi from string-streams.
0(defmethod (:tyi c-string-stream) ()
  (let ((char-to-return (or (and char-to-untyi (code-char char-to-untyi))
			    (sys:octet-aref-8 stream stream-offset))))
    (setq char-to-untyi nil)
    (cond ((zerop char-to-return)
	   (setq eof-p t)
	   eof)
	  (t
	   (incf stream-offset)
	   (incf position)
	   (incf count)
	   char-to-return))))

(defmethod (:untyi c-string-stream) (char)
  (when (and char (= char EOF))
    (return-from :untyi EOF))
  
  (when char-to-untyi
    (setq char-to-untyi nil)
    (return-from :untyi EOF))
  (decf position)
  (setq eof-p nil)
  (decf stream-offset)
  (decf count)
  (sys:octet-aset-8 char stream stream-offset))

(defmethod (:tyi c-char-direct-stream) ()
  (cond (stream
	 (when ( position file-size)
	   (setq eof-p t)
	   (return-from :tyi EOF))

	 (when (eq mode :notinput)
	   (zl:ferror "Input attempted from stream, ~A, which is open for output" stream))
	 (setq mode :notoutput)
	 
	 (or char-to-untyi (send stream :read-bytes 1 (send stream :read-pointer)))
	 (let ((current-char (or char-to-untyi (send stream :tyi))))
	   (setq char-to-untyi nil)
	   (if current-char
	       (progn
		 (incf count)
		 (incf position)
		 current-char)
	       (setq eof-p t)
	       EOF)))
	(t error-indication)))

(defmethod (:tyi c-binary-direct-stream) ()
  (cond (stream
	 (when ( position file-size)
	   (setq eof-p t)
	   (return-from :tyi EOF))

	 (when (eq mode :notinput)
	   (zl:ferror "Input attempted from stream, ~A, which is open for output" stream))
	 
	 (or char-to-untyi (send self :read-bytes 1 position))
	 (let ((current-char (or char-to-untyi (send stream :tyi))))
	   (setq char-to-untyi nil)
	   (if current-char
	       (progn
		 (incf count)
		 (incf position)
		 current-char)
	       (setq eof-p t)
	       EOF)))
	(t error-indication)))

(defmethod (:string-out c-char-direct-stream) (string &optional (start 0) end)
   (setq char-to-untyi nil)
   (let ((string-length (if end (- end start) (- (string-length string) start)))
	 (c-string (copy-lisp-string-into-c-string string)))
      (incf count  string-length)

      (when (eq mode :notoutput)
	(zl:ferror "Attempt to write to a stream, ~A, in input mode" stream))
      (setq mode :notinput)
      (send self :write c-string start string-length)))
(defwhopper (:string-out c-append-char-direct-stream) (string &optional (start 0) end)
  (when (eq mode :notoutput)
	(zl:ferror "Attempt to write to a stream, ~A, in input mode" stream))
  (setq position (send self :set-pointer file-size))
  (continue-whopper string start end))

(defmethod (:string-out c-binary-direct-stream) (string &optional (start 0) end)
   (setq char-to-untyi nil)
   (let ((string-length (if end (- end start) (- (string-length string) start)))
	 (c-string (copy-lisp-string-into-c-string string)))
      (incf count  string-length)
      (when (eq mode :notoutput)
	(zl:ferror "Attempt to write to a stream, ~A, in input mode" stream))
      (setq mode :notinput)
      (send self :write c-string start string-length)))
(defwhopper (:string-out c-append-binary-direct-stream) (string &optional (start 0) end)
  (when (eq mode :notoutput)
	(zl:ferror "Attempt to write to a stream, ~A, in input mode" stream))
  (setq position (send stream :set-pointer file-size))
  (continue-whopper string start end))

(defmethod (:tyo c-binary-direct-stream) (char)
  (setq char-to-untyi nil)
  1;; write the tag byte and then write the actual byte.
0  (when (eq mode :notoutput)
    (zl:ferror "Attempt to write to a stream, ~A, in input mode" stream))
1  ;; this will set the pointer up to point at the tag and
0  1;; then at the position that the next character is
0  1;; supposed to write at.
0  (send self :write-tag 0)
  (setq mode :notinput)
  (let ((char-to-return (send stream :tyo (char-code char))))
    (incf count)
    (incf position)
    (when (> position file-size)
      (setq file-size position))
    char-to-return))
(defwhopper (:tyo c-append-binary-direct-stream) (char)
  (setq position (send self :set-pointer (max position file-size)))
  (when (eq mode :notoutput)
    (zl:ferror "Attempt to write to a stream, ~A, in input mode" stream))
  (continue-whopper char))

(defmethod (:tyo c-char-direct-stream) (char)
  (setq char-to-untyi nil)
  (when (eq mode :notoutput)
    (zl:ferror "Attempt to write to a stream, ~A, in input mode" stream))
  (cond (stream
	 (let ((char-to-return (send stream :tyo (char-code char))))
	   (setq mode :notinput)
	   (incf count)
	   (incf position)
	   (when (> position file-size)
	     (setq file-size position))
	   char-to-return))
	(t error-indication)))
(defwhopper (:tyo c-append-char-direct-stream) (char)
  (when (eq mode :notoutput)
    (zl:ferror "Attempt to write to a stream, ~A, in input mode" stream))
  (setq position (send stream :set-pointer (max position file-size)))
  (continue-whopper char))

(defmethod (:set-pointer c-binary-direct-stream) (virtual-position)
  (file-position stream (if (= virtual-position file-size)
			    ':end
			    (translate-to-actual virtual-position)))
  (setq position virtual-position))

(defmethod (:read-pointer c-binary-direct-stream) ()
  1;; the virtual position is the current position minus the
0  1;; tag fields.
0  (translate-to-actual position))
(defmethod (:read-bytes c-binary-direct-stream) (how-many &optional (virtual-position 0))
  (let* ((bytes-to-read (- (translate-to-actual (+ how-many virtual-position))
			   (translate-to-actual virtual-position))))
    (send stream :read-bytes bytes-to-read (translate-to-actual virtual-position))))
(defmethod (:write-tag c-binary-direct-stream) (tag-to-write)
  (let ((actual-position (translate-to-actual position)))
    (send stream :set-pointer (- actual-position (tag-byte-offset-from-actual actual-position)))
    (send stream :tyo tag-to-write)
    (send stream :set-pointer actual-position)))
(defun copy-c-string-into-lisp-string (c-string-object c-string-byte-offset number-of-bytes-to-copy)
							
  (declare (values lisp-string))
  (when c-string-object
    (do* ((lisp-string (make-array number-of-bytes-to-copy
				   :element-type 'string-char
				   :fill-pointer 0))
	  (lisp-char-offset 0 (+ lisp-char-offset 1))
	  (c-byte-offset c-string-byte-offset (+ c-byte-offset 1)))
	 ((= c-byte-offset (+ c-string-byte-offset number-of-bytes-to-copy))
	  (setf (array-leader lisp-string 0) lisp-char-offset)
	  lisp-string)
      (setf (aref lisp-string lisp-char-offset) (code-char (si:octet-aref-8 c-string-object c-byte-offset))))))
;;;
(defmethod (:write c-stream) (array array-offset-in-bytes bytes-to-write-length)
  (let ((lisp-string (copy-c-string-into-lisp-string array array-offset-in-bytes bytes-to-write-length)))
    (send self :string-out lisp-string)))
1;;;
0(defwhopper (:write c-append-text-stream) (array array-offset-in-bytes bytes-to-write-length)
  (setq position (max position start-position))
  (file-position stream position)
  (continue-whopper array array-offset-in-bytes bytes-to-write-length))

(defmethod (:write c-char-direct-stream) (array array-offset-in-bytes bytes-to-write-length)
  (let ((byte-array (make-array bytes-to-write-length :displaced-to array
				:displaced-index-offset array-offset-in-bytes
				:element-type '(unsigned-byte 8))))
    (send stream :set-pointer position)
    (incf position bytes-to-write-length)
    (send stream :string-out byte-array 0 bytes-to-write-length)
    (when (> position file-size)
      (setq file-size position))
    bytes-to-write-length))
1;;;
0(defwhopper (:write c-append-char-direct-stream) (array array-offset-in-bytes bytes-to-write-length)
  (setq position (max file-size position))
  (continue-whopper array array-offset-in-bytes bytes-to-write-length))

(defmethod (:read c-stream) (array array-offset-in-bytes bytes-to-read-length)
  (sys:with-stack-array (lisp-string bytes-to-read-length
				     :element-type 'string-char :fill-pointer 0)
    (multiple-value-bind (number-of-chars-read eof-p)
	(send stream :string-in nil lisp-string 0 bytes-to-read-length)
      (ignore eof-p)
      (convert-lisp-string-to-c-format lisp-string 0 number-of-chars-read array
				       array-offset-in-bytes)
      (incf position number-of-chars-read)
      number-of-chars-read)))

(defmethod (:read c-char-direct-stream) (array array-offset-in-bytes bytes-to-read-length)
  (cond (stream
	 (when (eq mode :notinput)
	   (zl:ferror "Input on stream, ~A, not open for reading" stream))
	 (setq mode :notoutput)
	 (send stream :read-bytes bytes-to-read-length position)
	 (stack-let* ((word-array (make-array (ceiling bytes-to-read-length 4) :initial-element 0))
		      (byte-array (make-array bytes-to-read-length :element-type '(unsigned-byte 8) :displaced-to word-array)))
	   (incf position bytes-to-read-length)
	   (multiple-value-bind (bytes-read eof-p)
	       (send stream :string-in nil byte-array 0 bytes-to-read-length)
	     (ignore eof-p)
	     (c-byte-move array array-offset-in-bytes word-array 0 bytes-read)
	     bytes-read)))
	(t error-indication)))

1;; write out to a binary stream the array from array-offset-in-bytes to
;; array-offset-in-bytes + (array-size-in-bytes * element-size-in-bytes).  at the
;; current file-position.  There is a 9 byte buffer: 1 byte for tag bits, 8 bytes
;; of data.
0(defun take-byte-from-float (the-float byte-index)
  (cl:case (sys:%logldb (byte 2 0) byte-index)
    (0 (sys:%logldb (byte 8 0) the-float))
    (1 (sys:%logldb (byte 8 8) the-float))
    (2 (sys:%logldb (byte 8 16.) the-float))
    (3 (sys:%logldb (byte 8 24.) the-float))))

(defmethod (:write c-binary-direct-stream) (array array-offset-in-bytes bytes-to-write-length)
  (let* ((array-offset-in-words 1(1- (floor array-offset-in-bytes 40)))
	 1;; the output-byte-buffer is an actual based on the offset from the current tag
0	 1;; and number of bytes that must be written.
0	 (output-byte-buffer-length
	   (translate-to-actual (+ (tag-byte-offset-from-actual (translate-to-actual position))
				   bytes-to-write-length)))
	 (the-float nil))			1;; fixnum temporary when reading a floating point
0						1;; number because octet-aref-8 doesn't work on floating point.
0    (unless (= bytes-to-write-length 0)
      (si:with-stack-array (output-byte-buffer output-byte-buffer-length :type 'si:art-8b)
	1;; initialize the current tag.
0	1;; If you are starting in the middle of
0	1;; a two-word quantity, there must exist a tag byte
0	1;; which should be used to initialize the tag-byte for
0	1;; this buffer. 
0	(setf (aref output-byte-buffer 0)
	      (if (= 1 (tag-byte-offset-from-actual (translate-to-actual position)))
		  0
		  (progn
		    (file-position stream (tag-byte-position (translate-to-actual position)))
		    (send stream :read-bytes 1)
		    (send stream :tyi))))
	(loop with array-byte-offset = array-offset-in-bytes
	      with current-tag = 0
	      with output-byte-buffer-index =  (tag-byte-offset-from-actual (translate-to-actual position)) do
	  1;; loop invariant: elements from array = elements written into buffer
0;	  (unless (= (- array-byte-offset array-offset-in-bytes)
;		     (translate-to-virtual output-byte-buffer-index))
;	    (zl:ferror "elements read from array are not elements written into buffer"))
	  
	  1;; take into account the tag byte
0	  (when (tag-byte-p output-byte-buffer-index)
	    (setq current-tag output-byte-buffer-index)
	    (setf (aref output-byte-buffer output-byte-buffer-index) 0)
	    (incf output-byte-buffer-index))
	  1;; get the tag for this word
0	  (when (= (mod array-byte-offset 4) 0)
	    (incf array-offset-in-words)
	    (setq tag-byte (typecase (aref array array-offset-in-words)
			     (fixnum 0)
			     (single-float (progn (setq the-float (si:%fixnum (aref array array-offset-in-words)))
						  1))
			     1;; the nil case is special to write null pointers
0			     (symbol (if (eq (aref array array-offset-in-words) nil)
					 (setf (aref array array-offset-in-words) 0)
					 (zl:ferror "Illegal type field for printing to a binary file,
                                             ~type expected to be one of: fixnum, float")))
			     (otherwise
			       (zl:ferror "Illegal type field for printing to a binary file,
                               ~type expected to be one of: fixnum, float")))))
	  1;; put in the appropriate tag for this byte.
0	  (setf (aref output-byte-buffer current-tag)
		(dpb tag-byte
		       (byte 1 (- (1- output-byte-buffer-index) current-tag))
		       (aref output-byte-buffer current-tag)))
	  1;; put in the appropriate data
0	  (setf (aref output-byte-buffer
		      output-byte-buffer-index)
		(if (= tag-byte 1)		1;; it's a float
0		    (take-byte-from-float the-float array-byte-offset)
		    (si:octet-aref-8 array array-byte-offset)))

	  1;; increment counters
0	  (incf output-byte-buffer-index)
	  (incf array-byte-offset)
	  
	  1;; exit the loop if you're done.
0	  (unless (< (- array-byte-offset array-offset-in-bytes) bytes-to-write-length)
	    1;; have to have written the entire array to the buffer
0		(unless (= (- array-byte-offset array-offset-in-bytes)
			   bytes-to-write-length)
		  (zl:ferror "Didn't write the entire array"))
		1;; write the buffer to the file.
0		(file-position stream (tag-byte-position (translate-to-actual position)))
		1;; write the tag byte.
0		(send stream :tyo (aref output-byte-buffer 0))
		1;; write out the data.
0		(file-position stream (translate-to-actual position))
		(send stream :string-out
		      output-byte-buffer
		      (tag-byte-offset-from-actual (translate-to-actual position))
		      output-byte-buffer-index)
		(incf position bytes-to-write-length)
		(when (> position file-size)
		  (setq file-size position))
		(return)))))))
	  

(defwhopper (:write c-append-binary-direct-stream) (array array-offset-in-bytes bytes-to-write-length)
  (setq position (send self :set-pointer file-size))
  (continue-whopper array array-offset-in-bytes bytes-to-write-length))

(defvar *tag-list* '((#b0000 . t)
		     (#b1111 . t)))

(defvar *tag-type* (make-array 2 :initial-contents `("an integer" ,"a single precision floating point")))

(defmacro check-for-legal-tag (current-tag)
  `(unless (cdr (assoc ,current-tag *tag-list*))
     (zl:ferror "Illegal tag: you are probably trying to read a structure
                 ~with improper alignment")))	
  
(defmacro get-tag-name (current-tag)
  `(aref *tag-type* ,current-tag))

(defmacro get-tag-bit (input-buffer buffer-index current-tag)
  `(ldb (byte 1 (- (1- ,buffer-index) ,current-tag))
	(aref ,input-buffer ,current-tag)))

(defmethod (:read c-binary-direct-stream)
	   (array array-byte-offset bytes-to-read-length)
  (when (eq mode :notinput)
    (zl:ferror "Attempt to read from an output stream, ~A" stream))
  (setq mode :not-output)
  (when (> (+ bytes-to-read-length position) file-size)
    (setq eof-p t)
    (setq error-indicator error-indication)
    (return-from :read 0))
  1;; read in a bunch of bytes at the current file position
0  (let* ((start-array-byte-offset array-byte-offset)
	 (offset-from-tag (tag-byte-offset-from-actual (send self :read-pointer)))
	 (array-word-offset (floor array-byte-offset 4))
	 (limit-in-bytes (+ array-byte-offset bytes-to-read-length))
	 (input-byte-buffer-length (+ (1- offset-from-tag) bytes-to-read-length
				      (ceiling (+ (1- offset-from-tag) bytes-to-read-length) 8))))
    (si:with-stack-array (input-byte-buffer input-byte-buffer-length :type 'si:art-8b)
      1;; initiate a read from the file
0      (send stream :read-bytes input-byte-buffer-length
	    (tag-byte-position (send self :read-pointer)))
      (send stream :string-in nil input-byte-buffer)
      (loop with current-tag = 0
	    with current-tag-bit = 0
	    with input-byte-buffer-index = offset-from-tag
	    while (< array-byte-offset limit-in-bytes) do
	1;; keep current tag and input-byte-buffer-index
0	1;; correct
0	(when (= (mod input-byte-buffer-index 9) 0)
	  1;; skip reading the tag byte into the array and update current-tag
0	  (setq current-tag input-byte-buffer-index)
	  (incf input-byte-buffer-index))
	1;; when at a word boundary see what kind of thing this word should
	;; be a fix or a float based upon what we are just about to read. and
0	1;; place the appropriate type field in place.
0	(when (= (mod array-byte-offset 4) 0)
	  (setq current-tag-bit (get-tag-bit input-byte-buffer input-byte-buffer-index current-tag)))
	1;; insert the byte
0	(setf (si:octet-aref-8 array array-byte-offset)
	      (aref input-byte-buffer input-byte-buffer-index))
	1;; check for the proper tag byte.
0	(unless (= current-tag-bit (get-tag-bit input-byte-buffer input-byte-buffer-index current-tag))
	  (error "Mismatched alignment:  The byte read is coded as part of ~A, while the word that it~% ~
                  is being read into is being treated as ~A.~%"
		 (get-tag-name (get-tag-bit input-byte-buffer input-byte-buffer-index current-tag))
		 (get-tag-name current-tag-bit)))
	(when (and (= (mod array-byte-offset 4) 3) (= current-tag-bit 1))
	    (setf (aref array array-word-offset) (sys:%flonum (aref array array-word-offset)))
	    (incf array-word-offset))

	(incf input-byte-buffer-index)
	(incf array-byte-offset)
	finally
	  (return (progn
		    (incf position bytes-to-read-length)
		    (- array-byte-offset start-array-byte-offset)))))))

(defvar stderr (make-array 1 :initial-contents `(,(make-instance 'c-stream :stream *error-output*))))

(defvar stdin (make-array 1 :initial-contents `(,*standard-input*)))

(defvar stdout (make-array 1 :initial-contents `(,(make-instance 'c-stream :stream *standard-output*))))

(defvar c-user::|_stdin| (make-array 2 :initial-contents `(,stdin 0)))

(defvar c-user::|_stdout| (make-array 2 :initial-contents `(,stdout 0)))

(defvar c-user::|_stderr| (make-array 2 :initial-contents `(,stderr 0)))

(defun make-standard-c-file (stream)
  (make-array 2 :initial-contents
	      `(,(make-array 1 :initial-contents `(,(make-instance 'c-stream :stream stream))) 0)))

(defun-c-runtime-routine c-user::|remove| (file-name file-name-offset)
  (let ((lisp-name (merge-pathnames
		     (copy-c-two-word-pointer-string-into-lisp-string
		       file-name file-name-offset)
		     *user-file-pathname-defaults*)))
    (c-condition-bind error-indication
		      (if (eq (delete-file lisp-name) t) no-error-indication error-indication))))


(defun-c-runtime-routine c-user::|rename| (old-string old-offset new-string new-offset)
  (let* ((old-pathname-string
	   (merge-pathnames
	     (copy-c-two-word-pointer-string-into-lisp-string old-string old-offset)
			    *user-file-pathname-defaults*))
	 (new-pathname-string
	   (merge-pathnames
	     (copy-c-two-word-pointer-string-into-lisp-string new-string new-offset)
			    *user-file-pathname-defaults*)))
    (c-condition-bind (return-from c-user::|rename| error-indication)
		      (if (zl:renamef old-pathname-string new-pathname-string t)
			  no-error-indication
			  error-indication))))
  
(defun-c-runtime-routine c-user::|tmpfile| ()
  (let ((lisp-name (merge-pathnames
		     (copy-c-two-word-pointer-string-into-lisp-string
		       (funcall #'c-user::|tmpnam| nil 0) 0)
		     *temporary-file-pathname-defaults*))
	(file-array (make-array 1 :element-type t)))
    (c-condition-bind (return-from c-user::|tmpfile| error-indication)
	 (progn
	   (setf (aref file-array 0)
		 (send (make-instance 'temporary-binary-stream
				    :file-name lisp-name
				    :if-exists :error
				    :if-does-not-exist :create
				    :element-type '(unsigned-byte 8)
				    :direction :io)
		       :open))
	   (send (aref file-array 0) :set-start-position
		 (translate-to-virtual (send (aref file-array 0) :read-pointer)))))
    (push (aref file-array 0) *c-open-files*)
    (values file-array 0)))
1;;; Same as below, except that it does not put the special "\0" terminator at the end of the string.  
0(defun convert-lisp-string-to-c-format (lisp-string lisp-string-start lisp-string-end
				    c-string-object c-string-start)
  (if lisp-string
      (do* ((lisp-string-size (- lisp-string-end lisp-string-start))
	    ;;
	    (char-offset 0 (+ char-offset 1)))
	   ((= char-offset lisp-string-size)
	    (values c-string-object c-string-start))
	(setf (si:octet-aref-8 c-string-object (+ c-string-start char-offset))
	      (char-code (aref lisp-string (+ lisp-string-start char-offset)))))
      (values nil 0)))

(defun copy-lisp-string-to-c-string (lisp-string lisp-string-start lisp-string-end
				    c-string-object c-string-start)
  (if lisp-string
      (do* ((lisp-string-size (- lisp-string-end lisp-string-start))
	    ;;
	    (char-offset 0 (+ char-offset 1)))
	   ((= char-offset lisp-string-size)
	    ;;
	    ;;      bash in the null character ('\0')
	    ;;
	    (setf (si:octet-aref-8 c-string-object (+ c-string-start char-offset)) 0)
	    (values c-string-object c-string-start))
	(setf (si:octet-aref-8 c-string-object (+ c-string-start char-offset))
	      (char-code (aref lisp-string (+ lisp-string-start char-offset)))))
      (values nil 0)))

(defun-c-runtime-routine c-user::|tmpnam| (name name-offset)
  (let ((temp-counter))
    (without-interrupts
      (setq temp-counter (incf *tmp-name-counter*)))
    (let ((temp-name (format nil "~D~D.temp" temp-counter (si:time))))
      (if (null-pointer name name-offset)
	  (values (copy-lisp-string-into-c-string temp-name) 0)
	  (progn
	    (copy-lisp-string-to-c-string temp-name 0 (min (string-length temp-name) L_tmpname)
					  name name-offset)
	    (values name name-offset))))))
	  
(defun-c-runtime-routine c-user::|fclose| (file-desc file-desc-offset)
  "Flush the descriptor's buffer and close the associated stream"
  (declare (values error-indication))
  (when (null file-desc)
    (return-from c-user::|fclose| EOF))
  (let ((file (si:octet-aref file-desc file-desc-offset))
	(return-value error-indication))
    (c-condition-bind error-indication
	 (progn
	   (when (and *c-open-files*
		      (loop for file-descriptor in *c-open-files*
			    when (eq file file-descriptor)
			      do (setq *c-open-files* (zl:delq file *c-open-files*))
				 (return t)))
	     (setq return-value (send file :close)))
	   return-value))))

1;; fflush is a no-op because the stream keeps track of its own
;; buffering.
0(defun-c-runtime-routine c-user::|fflush| (file-desc file-desc-offset)
  "Flush the descriptor's buffer"
  (declare (values error-indicator))
  (when (null file-desc)
    (return-from c-user::|fflush| EOF))
  (let ((file (si:octet-aref file-desc file-desc-offset)))
    (unless (member file-desc `(,stdin ,(aref c-user::|_stdout| 0) ,stderr))
      (send file :finish))
    no-error-indication))

(defmacro strings-point-to-same-file-p (string1 string2)
  `(eq (send (fs:parse-pathname ,string1) :translated-pathname)
       (send (fs:parse-pathname ,string2) :translated-pathname)))

(defun-c-runtime-routine c-user::|fopen| (file-name file-name-offset
	      mode      mode-offset)
  "Create a file descriptor for the file-name and open a stream for it"
  (declare (values file-desc file-desc-offset))
  (let* ((lisp-name (when file-name
		      (merge-pathnames
			(copy-c-two-word-pointer-string-into-lisp-string
			  file-name file-name-offset)
			*user-file-pathname-defaults*)))
	 (lisp-mode (when mode
		      (copy-c-two-word-pointer-string-into-lisp-string mode mode-offset)))
	 (file-array (make-array 1 :element-type t)))
1    ;; if the file by this name is already open then return an error
0    (loop for file-descriptor in *c-open-files*
	    when (strings-point-to-same-file-p
		   lisp-name
		   (send file-descriptor :file-name))
	      do (return-from c-user::|fopen| (values nil 0)))

    1;; now create the file descriptor by instantiating the flavor and sending
0    1;; it the open message.
0    (c-condition-bind  (return-from c-user::|fopen| (values nil 0))
	 (setf (aref file-array 0)
	       (send (zl:apply #'make-instance
			    (append (cdr
				      (assoc lisp-mode *c-file-flavors* :test #'string-equal))
				    `(:file-name ,lisp-name)))
		     :open)))
    (push (aref file-array 0) *c-open-files*)
  (values file-array 0)))

(defun-c-runtime-routine c-user::|freopen| (file-name file-name-offset
		mode      mode-offset
		file-desc file-desc-offset)
  "Closes any file associated with file-desc and re-initializes it to use file-name and mode"
  (declare (values file-desc file-desc-offset))
  (when (null file-name)
    (return-from c-user::|freopen| (values nil 0)))
  (let ((file (si:octet-aref file-desc file-desc-offset)))
    1;; ignores any errors on the close.
0    (unless (or (eq file *standard-input*)
		(eq file *standard-output*)
		(eq file *error-output*))
      (funcall #'c-user::|fclose| file-desc file-desc-offset))
    (c-condition-bind (return-from c-user::|freopen| (values nil 0))
	 (progn
	   (setf (si:octet-aref file-desc file-desc-offset)
		 (aref (funcall #'c-user::|fopen|
				file-name file-name-offset mode mode-offset) 0))
	   (values file-desc file-desc-offset)))))

(defun-c-runtime-routine c-user::|setbuf| (ignore ignore ignore ignore)
  "Call to setvbuf with _IOFBF for mode and BUFSIZ for size"
  1;; this is a no-op in our system because the stream itself supports buffering
0  1;; below the level of the C interface.
0  nil)

(defun-c-runtime-routine c-user::|setvbuf| (ignore ignore ignore ignore mode size)
  "Sets up how buffering should occur in the file-desc"
  (declare (values error-indicator))
  1;; this is a no-op in our system because the stream itself supports buffering
0  1;; below the level of the C interface.

0  ;; check for error values
  (when (or (< size 0) (not ( _IOFBF mode _IONBF)))
    (return-from c-user::|setvbuf| error-indication))
  0)

(defun-c-runtime-routine c-user::|fprintf| (file-desc file-desc-offset
		format-desc format-offset
		&rest args)
  (declare (values characters-transimitted))
  (let ((file (si:octet-aref file-desc file-desc-offset))
	(format (move-c-string-into-lisp-string format-desc format-offset *format-string*)))
    (send file :set-count 0)
    (printf-internal file format #'(lambda () (if args
						  (pop args)
						  (error "Not enough arguments for PRINTF."))))
    (send file :count)))
(defun-c-runtime-routine c-user::|sprintf| (c-string c-string-offset
		format-desc format-offset
		&rest args)
  (declare (values characters-transimitted))
  (let ((format (move-c-string-into-lisp-string format-desc format-offset *format-string*))
	(file
	  (make-instance 'c-string-stream :stream c-string :stream-offset c-string-offset)))
    (send file :set-count 0)
    (printf-internal file format #'(lambda () (if args
						  (pop args)
						  (error "Not enough arguments for PRINTF."))))
    (send file :count)))
(defun-c-runtime-routine c-user::|fscanf| (file-desc file-desc-offset
	       format-desc format-offset
	       &rest args)	1;; args are C pointers here.
0  (declare (values characters-succesfully-input))
  (let ((file (si:octet-aref file-desc file-desc-offset))
	(format (move-c-string-into-lisp-string format-desc format-offset *format-string*)))
    (c-condition-bind (return-from c-user::|fscanf| EOF)
       (if (input-editable file)
	   (with-input-editing ((send file :stream))
	     (scanf-internal file format args))
	   (scanf-internal file format args)))))

(defun-c-runtime-routine c-user::|printf| (format format-offset
	       &rest args)
  "fprintf for stdout"
  (declare (values characters-transimitted)
	   (special c-user::|_stdout|))
  (apply #'c-user::|fprintf| (si:octet-aref c-user::|_stdout| 0) 0 format format-offset args))

(defun-c-runtime-routine c-user::|scanf| (format format-offset
	       &rest args)
  "fscanf for stdin"
  (declare (values characters-succesfully-input))
  (apply #'c-user::|fscanf| (si:octet-aref c-user::|_stdin| 0) 0 format format-offset args))

(defun-c-runtime-routine c-user::|sscanf| (c-string c-string-offset
			 format-desc format-offset &rest args)
  (let ((format (move-c-string-into-lisp-string format-desc format-offset *format-string*))
	(file
	  (make-instance 'c-string-stream :stream c-string :stream-offset c-string-offset)))
    (c-condition-bind EOF
		      (scanf-internal file format args))))
(defun-c-runtime-routine c-user::|vfprintf| (file-desc file-desc-offset
			   format-desc format-offset
			   args args-offset)
  (declare (values characters-transimitted))
  (let ((file (si:octet-aref file-desc file-desc-offset))
	(format (move-c-string-into-lisp-string format-desc format-offset *format-string*)))
    (send file :set-count 0)
    (printf-internal file format #'(lambda () (prog1 (sys:octet-aref args args-offset)
						     (incf args-offset 4))))
    (send file :count)))
(defun-c-runtime-routine c-user::|vprintf| (format format-offset
			  args args-offset)
  "fprintf for stdout"
  (declare (values characters-transimitted)
	   (special c-user::|_stdout|))
  (c-user::|vfprintf| (si:octet-aref c-user::|_stdout| 0) 0 format format-offset args args-offset))
(defun-c-runtime-routine c-user::|vsprintf| (c-string c-string-offset
			   format-desc format-offset
			   args args-offset)
  (declare (values characters-transimitted))
  (let ((format (move-c-string-into-lisp-string format-desc format-offset *format-string*))
	(file
	  (make-instance 'c-string-stream :stream c-string :stream-offset c-string-offset)))
    (send file :set-count 0)
    (printf-internal file format #'(lambda () (prog1 (sys:octet-aref args args-offset)
						     (incf args-offset 4))))
    (send file :count)))



(defun-c-runtime-routine c-user::|fgetc| (file-desc file-desc-offset)
  "Return the next character from the file-desc"
  (declare (values character-returned))
  (let ((file (si:octet-aref file-desc file-desc-offset)))
    (c-condition-bind
      (progn (send file :set-error-indicator error-indication)
	     EOF)
      (send file :tyi))))

(defun-c-runtime-routine c-user::|getch| ()
  (let ((*no-echo* t))
    (c-user::|fgetc| (aref c-user::|_stdin| 0) 0)))

(defun-c-runtime-routine c-user::|getc| (file-desc file-desc-offset)
  (c-user::|fgetc| file-desc file-desc-offset))

(defun-c-runtime-routine c-user::|getchar| ()
  (c-user::|fgetc| (aref c-user::|_stdin| 0) 0))

(defun-c-runtime-routine c-user::|fgets| (string string-offset
	      length
	      file-desc file-desc-offset)
  "Tries to fill string from file-desc"
  (declare (values string string-offset))
  (let ((file (si:octet-aref file-desc file-desc-offset)))
    (c-condition-bind
      (progn (send file :set-error-indicator error-indication)
	     (values nil 0))
      (multiple-value-bind (return-string return-string-o eof-indicator eol-indicator string-length)
	  (send file :read-string string string-offset (1- length))

	(when (and (= string-length 0) eof-indicator)	1;; check for eof before finishing.
0	  (return-from c-user::|fgets| (values nil 0)))
	   
	(when (and (null eof-indicator) (null eol-indicator))		1;; got to the end of the line with no mishap
0	  (setf (si:octet-aref-8 return-string (+ return-string-o string-length))
		(char-code #\Return))
	  (setf (si:octet-aref-8 return-string (+ return-string-o string-length 1))
		0))
	(values return-string return-string-o)))))

(defun-c-runtime-routine c-user::|gets| (string string-offset)
  (declare (values string string-offset))
  (c-condition-bind
    EOF
    (multiple-value-bind (return-string return-string-o
			  eof-indicator ignore string-length)
	(send (aref (aref c-user::|_stdin| 0) 0) :read-string string string-offset)
      (when (and (= string-length 0) eof-indicator)	1;; check for eof before finishing.
0	(return-from c-user::|gets| (values nil 0)))
      (values return-string return-string-o))))

(defun-c-runtime-routine c-user::|fputc| (char file-desc file-desc-offset)
	      
  "Puts the next character to the file-desc"
  (declare (values character-written))
  (let ((file (si:octet-aref file-desc file-desc-offset)))
    (c-condition-bind
      (progn
	(send file :set-error-indicator error-indication)
	EOF)
      (progn
	(send file :tyo (code-char char))
	char))))

(defun-c-runtime-routine c-user::|putc| (char file-desc file-desc-offset)
  (c-user::|fputc| char file-desc file-desc-offset))

(defun-c-runtime-routine c-user::|putchar| (char)
  (c-user::|fputc| char (si:octet-aref c-user::|_stdout| 0) 0))


(defun-c-runtime-routine c-user::|fputs| (string string-offset
	      file-desc file-desc-offset)
  "put the string to the file-desc"
  (declare (values error-indicator))
  (c-condition-bind
    (progn
      (send (si:octet-aref file-desc file-desc-offset) :set-error-indicator error-indication)
      EOF)
    (let ((file (si:octet-aref file-desc file-desc-offset))
	  (lisp-string (copy-c-two-word-pointer-string-into-lisp-string string string-offset)))
    (send file :string-out lisp-string)
    (return-from c-user::|fputs| 0))))

(defun-c-runtime-routine c-user::|puts| (string string-offset)
  "put string to stdout"
  (declare (values error-indicator))
  (c-condition-bind
    (progn
      (send (si:octet-aref (si:octet-aref c-user::|_stdout| 0) 0)
	    :set-error-indicator error-indication)
      EOF)
    (let ((file (si:octet-aref (si:octet-aref c-user::|_stdout| 0) 0))
	  (lisp-string (copy-c-two-word-pointer-string-into-lisp-string string string-offset)))
    (send file :string-out lisp-string)
    (send file :tyo #\Return)
    (return-from c-user::|puts| 0))))

(defun-c-runtime-routine c-user::|ungetc| (char file-desc file-desc-offset)
  "return char to file-desc"
  (declare (values error-indicator))
  (let ((file (si:octet-aref file-desc file-desc-offset)))
    (send file :untyi char)))

1;; Direct I/O
0(defun-c-runtime-routine c-user::|fread| (ptr ptr-offset
	      size
	      nmemb
	      file-desc file-desc-offset)
  "reads into ptr, bytes = size * nmemb from file-desc"
  (declare (values members-read))
  (ignore ptr ptr-offset size nmemb file-desc file-desc-offset)
  (let ((file (si:octet-aref file-desc file-desc-offset))
	(bytes-to-read (* nmemb size)))
    (c-condition-bind 0
	 (if ( bytes-to-read 0)
	     0
	     (ceiling (send file :read ptr ptr-offset bytes-to-read) size)))))

(defun-c-runtime-routine c-user::|fwrite| (ptr ptr-offset
	      size
	      nmemb
	      file-desc file-desc-offset)
  "writes size*nmemb bytes from ptr to file-desc"
  (declare (values members-written))
  (let* ((file (si:octet-aref file-desc file-desc-offset))
	 (bytes-to-write (* nmemb size)))
    (c-condition-bind 0
	 (progn
	   (send file :write ptr ptr-offset bytes-to-write)
	   nmemb))))

(defun-c-runtime-routine c-user::|fgetpos| (file-desc file-desc-offset
		pos-pointer pos-pointer-offset)
  "puts the current value of file-indication-position into pos-pointer, if fails
   sets (3 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")errno0"
  (declare (values error-indicator))
  (declare (special c-user::|errno|))
  (c-condition-bind
    (progn
      (setf (si:octet-aref c-user::|errno| 0) 1)
      EOF)
  (let ((file (si:octet-aref file-desc file-desc-offset)))
    (setf (si:octet-aref pos-pointer pos-pointer-offset) (send file :position))
    (if (not (null (si:octet-aref pos-pointer pos-pointer-offset)))
	no-error-indication
	(setf (si:octet-aref c-user::|errno| 0) 1)
	EOF))))

(defun-c-runtime-routine c-user::|fseek| (file-desc file-desc-offset
	      offset whence)
  "sets the file position indicator to point to whence + offset"
  (declare (values error-indicator))
  (declare (special c-user::|errno|))
  (c-condition-bind
    (progn
      (setf (si:octet-aref c-user::|errno| 0) 1)
      EOF)
    (let ((file (si:octet-aref file-desc file-desc-offset)))
      (send file :fseek offset whence))))

(defun-c-runtime-routine c-user::|get_name| (file-desc file-desc-offset)
  (let ((file (si:octet-aref file-desc file-desc-offset)))
     (values (copy-lisp-string-into-c-string (send (send file :file-name) :string-for-printing)) 0)))
(defun-c-runtime-routine c-user::|rewind| (file-desc file-desc-offset)
  "sets the file position indicator back to the begining"
  (declare (values nil))
  (declare (special c-user::|errno|))
  (c-condition-bind
    (progn
      (setf (si:octet-aref c-user::|errno| 0) 1)
      EOF)
  (let ((file (si:octet-aref file-desc file-desc-offset)))
    (send file :fseek 0 SEEK_SET)
    (send file :set-error-indicator no-error-indication))))
(defun-c-runtime-routine c-user::|fsetpos| (file-desc file-desc-offset
		pos pos-offset)
  "sets the file position indicator to pos"
  (declare (values error-indicator))
  (declare (special c-user::|errno|))
  (c-condition-bind
    (progn
      (setf (si:octet-aref c-user::|errno| 0) 1)
      EOF)
    (let ((file (si:octet-aref file-desc file-desc-offset)))
      (send file :fseek (si:octet-aref pos pos-offset) SEEK_SET))))

(defun-c-runtime-routine c-user::|ftell| (file-desc file-desc-offset)
  "return the current value of the file position indicator"
  (declare (special c-user::|errno|))
  (c-condition-bind
    (progn
      (setf (si:octet-aref c-user::|errno| 0) 1)
      -1)
    (let ((file (si:octet-aref file-desc file-desc-offset)))
      (if (send file :position)
	  (send file :position)
	  (setf (si:octet-aref c-user::|errno| 0) 1)
	  -1))))

(defun-c-runtime-routine c-user::|clearerr| (file-desc file-desc-offset)
  "clears the error indications and end-of-file"
  (declare (special c-user::|errno|))
  (let ((file (si:octet-aref file-desc file-desc-offset)))
    (send file :set-eof-p nil)
    (setq *error* nil)
    (setf (si:octet-aref c-user::|errno| 0) 0)
    (send file :set-error-indicator no-error-indication))
    nil)

(defun-c-runtime-routine c-user::|feof| (file-desc file-desc-offset)
  "true for end of file"
  (declare (values boolean))
  (let ((file (si:octet-aref file-desc file-desc-offset)))
    (prog1
      (if (send file :eof-p) 1 0)
      (when (send (send file :stream) :interactive)
	  (send file :set-eof-p nil)))))

(defun-c-runtime-routine c-user::|ferror| (file-desc file-desc-offset)
  "returns non-zero if the error-indicator is set"
  (declare (values boolean))
  (let ((file (si:octet-aref file-desc file-desc-offset)))
    (send file :error-indicator)))

(defun-c-runtime-routine c-user::|perror| (char-array char-offset)
  "prints to stderr the current error message"
  (ignore char-array char-offset)
  (when *error*
    (dbg:report *error* *error-output*)))

