;;; -*- Mode: LISP; Package: NETI; Base: 8 -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;;; Media and protocols

(DEFSTRUCT (MEDIUM :NAMED :CONC-NAME)
  NAME						;Medium name
  TYPE						;of "stream" provided
  IMPLEMENTATIONS				;A list of MEDIUM-IMPLEMENATIONs
  )

(DEFSELECT ((:PROPERTY MEDIUM NAMED-STRUCTURE-INVOKE))
  (:PRINT-SELF (MEDIUM STREAM IGNORE SLASHIFY)
   (IF SLASHIFY
       (SI:PRINTING-RANDOM-OBJECT (MEDIUM STREAM :TYPEP)
	 (PRINC MEDIUM STREAM))
       (PRINC (MEDIUM-NAME MEDIUM) STREAM))))

(DEFSTRUCT (MEDIUM-IMPLEMENTATION :NAMED :CONC-NAME)
  MEDIUM					;What this is an implementation of
  PATH						;List of networks and services to get there
  FUNCTION					;For getting the stream
  connection-args				;if we encapsulate, the stream that
						;we encapsulate on should be given these.
  )

(DEFPROP DEFINE-MEDIUM "Network medium" DEFINITION-TYPE-NAME)

(DEFMACRO DEFINE-MEDIUM (NAME TYPES &BODY IMPLEMENTATIONS)
  (LET ((FUNCTIONS NIL)
	(IMPLEMENTATION-FUNCTION-sets NIL))
    (LOOP FOR IMPLEMENTATION IN IMPLEMENTATIONS
	  DO (IF (ATOM (CAAR IMPLEMENTATION))
		 (SETQ IMPLEMENTATION-FUNCTION-sets
		       `(,@IMPLEMENTATION-FUNCTION-sets ,IMPLEMENTATION NIL nil))
		 (LET ((FNAME (INTERN (FORMAT NIL "MEDIUM-~A-~A-~A"
					      NAME (CAR IMPLEMENTATION) (GENSYM))))
		       (arg-list (car (cdr IMPLEMENTATION)))
		       (one-down-connection-args nil))
		   (when (and (second arg-list) ; "connection"
			      (listp (second arg-list)))
		     (setq one-down-connection-args (cdr (second arg-list)))
		     (setq arg-list (list* (first arg-list) (first (second arg-list))
					   (rest2 arg-list))))
		   (PUSH `(DEFUN ,FNAME ,arg-list ,@(cddr IMPLEMENTATION)) FUNCTIONS)
		   (SETQ IMPLEMENTATION-FUNCTION-sets
			 `(,@IMPLEMENTATION-FUNCTION-sets ,(CAR IMPLEMENTATION)
			   ,FNAME ,one-down-connection-args)))))
    `(LOCAL-DECLARE ((FUNCTION-PARENT ,NAME DEFINE-MEDIUM))
       ,@FUNCTIONS
       (DEFINE-MEDIUM-1 ',NAME ',TYPES ',IMPLEMENTATION-FUNCTION-sets))))

(DEFVAR *MEDIUM-LIST* NIL)

(DEFUN FIND-MEDIUM-NAMED (MEDIUM-NAME)
  (LOOP FOR MEDIUM IN *MEDIUM-LIST*
	WHEN (EQ (MEDIUM-NAME MEDIUM) MEDIUM-NAME)
	RETURN MEDIUM))

;;; implementation-sets are (path function connection-args)
(DEFUN DEFINE-MEDIUM-1 (MEDIUM-NAME TYPES IMPLEMENTATION-sets)
  (WHEN (RECORD-SOURCE-FILE-NAME MEDIUM-NAME 'DEFINE-MEDIUM)
    (LET ((MEDIUM (FIND-MEDIUM-NAMED MEDIUM-NAME)))
      (WHEN (NULL MEDIUM)
	(SETQ MEDIUM (MAKE-MEDIUM NAME MEDIUM-NAME))
	(PUSH MEDIUM *MEDIUM-LIST*))
      (UNLESS (OR (LISTP TYPES) (NULL TYPES))
	(SETF TYPES (LIST TYPES)))
      (SETF (MEDIUM-TYPE MEDIUM) TYPES)
      (LOOP FOR TYPE IN TYPES
		;; This medium constitutes an implicit implementation of the type medium
	    FOR IMPLEMENTS = (FIND-MEDIUM-NAMED TYPE)
	    FOR PATH = `((:MEDIUM ,MEDIUM-NAME))
	    WHEN (NULL IMPLEMENTS)
	      DO (FERROR "Medium ~A is based on ~A, which has not been defined."
			 MEDIUM-NAME TYPE)
	    UNLESS (LOOP FOR IMPL IN (MEDIUM-IMPLEMENTATIONS IMPLEMENTS)
			 THEREIS (EQUAL (MEDIUM-IMPLEMENTATION-PATH IMPL) PATH))
	      DO (PUSH (MAKE-MEDIUM-IMPLEMENTATION MEDIUM IMPLEMENTS PATH PATH)
		       (MEDIUM-IMPLEMENTATIONS IMPLEMENTS)))
      (SETF (MEDIUM-IMPLEMENTATIONS MEDIUM)
	    (LOOP FOR (PATH FUNCTION connection-args) ON IMPLEMENTATION-sets BY 'CDDdR
		  COLLECT (MAKE-MEDIUM-IMPLEMENTATION MEDIUM MEDIUM PATH PATH
						      FUNCTION FUNCTION
						      connection-args connection-args))))))

(DEFSTRUCT (PROTOCOL :NAMED :CONC-NAME)
  NAME						;Of this protocol
  SERVICE					;Provided
  BASE-MEDIUM-NAME
  DESIRABILITY					;A number (or a function?)
  INVOKE-FUNCTION
  PROPERTY-LIST)

(DEFSELECT ((:PROPERTY PROTOCOL NAMED-STRUCTURE-INVOKE))
  (:PRINT-SELF (PROTOCOL STREAM IGNORE SLASHIFY)
   (IF SLASHIFY
       (SI:PRINTING-RANDOM-OBJECT (PROTOCOL STREAM :TYPEP)
	 (PRINC PROTOCOL STREAM))
       (PRINC (PROTOCOL-NAME PROTOCOL) STREAM))))

(DEFPROP DEFINE-PROTOCOL "Network protocol" DEFINITION-TYPE-NAME)

(MAPC #'(LAMBDA (KEY) (SI:DEFMACRO-SET-INDENTATION-FOR-ZWEI KEY '(1 1)))
      '(:INVOKE :INVOKE-WITH-STREAM :INVOKE-WITH-STREAM-AND-CLOSE))

(DEFMACRO DEFINE-PROTOCOL (NAME (SERVICE BASE-MEDIUM) &BODY OPTIONS)
  (DECLARE (ZWEI:INDENTATION 2 1))
  (LET ((FUNCTION-NAME (INTERN (FORMAT NIL "INVOKE-SERVICE-~A-WITH-~A" SERVICE NAME)))
	(FUNCTION-BODY NIL)
	(DESIRABILITY 1)
	(OTHER-PROPERTIES NIL))
    (LOOP FOR OPTION IN OPTIONS
	  DO (SELECTQ (FIRST OPTION)
	       (:DESIRABILITY
		(SETQ DESIRABILITY (SECOND OPTION)))
	       (:PROPERTY
		(PUTPROP (LOCF OTHER-PROPERTIES) (THIRD OPTION) (SECOND OPTION)))
	       (:INVOKE
		(SETQ FUNCTION-BODY (IF (ATOM (CADR OPTION))
					`((.SERVICE.) (,(CADR OPTION) .SERVICE.))
					(CDR OPTION))))
	       (:INVOKE-WITH-STREAM
		(MULTIPLE-VALUE-BIND (FUNCTION CONNECTION-ARGS)
		    (GET-DEFINE-PROTOCOL-FUNCTION OPTION)
		  (SETQ FUNCTION-BODY `((.SERVICE.)
					(LEXPR-FUNCALL
					  #',FUNCTION
					  (GET-CONNECTION-FOR-SERVICE
					    .SERVICE.
					    . ,CONNECTION-ARGS)
					  (SERVICE-ACCESS-PATH-ARGS .SERVICE.))))))
	       (:INVOKE-WITH-STREAM-AND-CLOSE
		(MULTIPLE-VALUE-BIND (FUNCTION CONNECTION-ARGS)
		    (GET-DEFINE-PROTOCOL-FUNCTION OPTION)
		  (SETQ FUNCTION-BODY `((.SERVICE.)
					(WITH-OPEN-STREAM
					  (.STREAM. (GET-CONNECTION-FOR-SERVICE
						      .SERVICE. . ,CONNECTION-ARGS))
					  (LEXPR-FUNCALL
					    #',FUNCTION
					    .STREAM.
					    (SERVICE-ACCESS-PATH-ARGS .SERVICE.)))))))
	       (OTHERWISE
		(FERROR "Unknown option: ~S" OPTION))))
    (WHEN (NULL FUNCTION-BODY)
      (SETQ FUNCTION-BODY `((.SERVICE.) (GET-CONNECTION-FOR-SERVICE .SERVICE.))))
    `(LOCAL-DECLARE ((FUNCTION-PARENT ,NAME DEFINE-PROTOCOL))
       (DEFUN ,FUNCTION-NAME . ,FUNCTION-BODY)
       (DEFINE-PROTOCOL-1 ',NAME ':SERVICE ',SERVICE ':BASE-MEDIUM-NAME ',BASE-MEDIUM
			  ':DESIRABILITY ',DESIRABILITY ':INVOKE-FUNCTION ',FUNCTION-NAME
			  ':PROPERTY-LIST ',OTHER-PROPERTIES))))

(EVAL-WHEN (EVAL COMPILE LOAD)
(DEFUN GET-DEFINE-PROTOCOL-FUNCTION (OPTION)
  (IF (ATOM (CADR OPTION))
      (CADR OPTION)
      (LET ((BODY (CDR OPTION))
	    (CONNECTION-ARGS NIL))
	(AND (LISTP (CAAR BODY))
	     (SETQ CONNECTION-ARGS (CDAAR BODY)
		   BODY `((,(CAAAR BODY) . ,(CDAR BODY)) . ,(CDR BODY))))
	(VALUES `(LAMBDA . ,BODY) CONNECTION-ARGS))))
)

(DEFVAR *PROTOCOL-LIST* NIL :LOCALIZE T)

(DEFUN FIND-PROTOCOL-NAMED (NAME &OPTIONAL SERVICE)
  (LOOP FOR PROTOCOL IN *PROTOCOL-LIST*
	WHEN (AND (EQ (PROTOCOL-NAME PROTOCOL) NAME)
		  (OR (NULL SERVICE)
		      (EQ (PROTOCOL-SERVICE PROTOCOL) SERVICE)))
	RETURN PROTOCOL))

(DEFUN DEFINE-PROTOCOL-1 (NAME &KEY SERVICE BASE-MEDIUM-NAME DESIRABILITY INVOKE-FUNCTION
				    PROPERTY-LIST)
  (WHEN (RECORD-SOURCE-FILE-NAME NAME 'DEFINE-PROTOCOL T)
    (LET ((PROTOCOL (FIND-PROTOCOL-NAMED NAME SERVICE)))
      (WHEN (NULL PROTOCOL)
	(SETQ PROTOCOL (MAKE-PROTOCOL NAME NAME SERVICE SERVICE))
	(PUSH PROTOCOL *PROTOCOL-LIST*))
      (ALTER-PROTOCOL PROTOCOL BASE-MEDIUM-NAME BASE-MEDIUM-NAME DESIRABILITY DESIRABILITY
		      INVOKE-FUNCTION INVOKE-FUNCTION PROPERTY-LIST PROPERTY-LIST))))

;;; An alist indexed by service name.
(DEFVAR-RESETTABLE *SPECIAL-HOSTS-SUPPORTING-SERVICE* NIL)

(DEFUN HOSTS-SUPPORTING-SERVICE (SERVICE &OPTIONAL ADDITIONAL-ATTRIBUTES)
  (SI:ELIMINATE-DUPLICATES
    (KEEPING-NAMESPACE-SERVER
      (APPEND
	(LOOP FOR HOST IN (CDR (ASSQ SERVICE *SPECIAL-HOSTS-SUPPORTING-SERVICE*))
	      WHEN (AND (SEND HOST ':NAMES)
			(SEND HOST ':PROPERTY-LIST-COMPARE ADDITIONAL-ATTRIBUTES))
	      COLLECT HOST)
	(LOOP FOR PROTOCOL IN *PROTOCOL-LIST*
	      WHEN (EQ (PROTOCOL-SERVICE PROTOCOL) SERVICE)
		WHEN (PROTOCOL-LOCALLY-IMPLEMENTED-P PROTOCOL)
		  WHEN (SEND *LOCAL-HOST* ':PROPERTY-LIST-COMPARE ADDITIONAL-ATTRIBUTES)
		    COLLECT *LOCAL-HOST* ELSE DO ()
		ELSE APPEND (LEXPR-FUNCALL #'FIND-OBJECTS-FROM-PROPERTY-LIST ':HOST
					   ':SERVICE `((,SERVICE :* ,(PROTOCOL-NAME PROTOCOL))
						       )
					   ADDITIONAL-ATTRIBUTES))))))

(DEFUN PROTOCOL-LOCALLY-IMPLEMENTED-P (PROTOCOL)
  (EQ (PROTOCOL-BASE-MEDIUM-NAME PROTOCOL) ':LOCAL))

;;;; Service lookup

;;; How a service is implemented - the path to it.
(DEFSTRUCT (SERVICE-ACCESS-PATH :NAMED :CONC-NAME)
  SERVICE					;The name of the service provided
  ARGS						;Arguments to the service invocation
  HOST						;Host providing the service
  PROTOCOL					;Protocol to be used
  MEDIUM					;A MEDIUM-DESCRIPTION
  DESIRABILITY					;A number between 0 and 1
  STREAM					;For PCLSR'ing a future
  )

(DEFSELECT ((:PROPERTY SERVICE-ACCESS-PATH NAMED-STRUCTURE-INVOKE))
  (:PRINT-SELF (SERVICE-ACCESS-PATH STREAM IGNORE SLASHIFY)
   (IF SLASHIFY
       (SI:PRINTING-RANDOM-OBJECT (SERVICE-ACCESS-PATH STREAM :TYPEP)
	 (PRINC SERVICE-ACCESS-PATH STREAM))
       (PRINT-SERVICE-ACCESS-PATH SERVICE-ACCESS-PATH STREAM))))

;;; This is designed to mostly be what TELNET wants
(DEFUN PRINT-SERVICE-ACCESS-PATH (SERVICE-ACCESS-PATH STREAM
				  &KEY (PRINT-SERVICE-NAME T)
				  (ONLY-SHOW-ROUTE NIL))
  (IF ONLY-SHOW-ROUTE
      (FORMAT STREAM "via ~A" (SERVICE-ACCESS-PATH-HOST SERVICE-ACCESS-PATH))
      (WHEN PRINT-SERVICE-NAME
	(FORMAT STREAM "~A " (SERVICE-ACCESS-PATH-SERVICE SERVICE-ACCESS-PATH)))
      (FORMAT STREAM "(~A) -- ~A" (SERVICE-ACCESS-PATH-PROTOCOL SERVICE-ACCESS-PATH)
	      (SERVICE-ACCESS-PATH-HOST SERVICE-ACCESS-PATH)))
  (FORMAT STREAM " ~A" (SERVICE-ACCESS-PATH-MEDIUM SERVICE-ACCESS-PATH)))

;;; How the path is constructed - possibly using gateway services.
(DEFSTRUCT (MEDIUM-DESCRIPTION :NAMED :CONC-NAME)
  IMPLEMENTATION				;One of the MEDIUM-IMPLEMENTATIONS for this
  PARAMETERS					;The specifics for the IMPLEMENTATION.
						;:LOCAL - NIL
						;:SERVICE - A list of SERVICE-ACCESS-PATH's
						;:MEDIUM - A MEDIUM-DESCRIPTION
						;:NETWORK - A NETWORK
  )

;;; A protocol supported by a host
(DEFSTRUCT (HOST-SERVICE (:TYPE :LIST) :CONC-NAME)
  SERVICE-NAME
  MEDIUM-NAME
  PROTOCOL-NAME
  )

(DEFSELECT ((:PROPERTY MEDIUM-DESCRIPTION NAMED-STRUCTURE-INVOKE))
  (:PRINT-SELF (MEDIUM-DESCRIPTION STREAM IGNORE SLASHIFY)
   (IF SLASHIFY
       (SI:PRINTING-RANDOM-OBJECT (MEDIUM-DESCRIPTION STREAM :TYPEP)
	 (PRINC MEDIUM-DESCRIPTION STREAM))
       (LET ((IMPLEMENTATION (MEDIUM-DESCRIPTION-IMPLEMENTATION MEDIUM-DESCRIPTION))
	     (PARAMETERS (MEDIUM-DESCRIPTION-PARAMETERS MEDIUM-DESCRIPTION)))
	 (SELECTQ (FIRST (FIRST (MEDIUM-IMPLEMENTATION-PATH IMPLEMENTATION)))
	   (:LOCAL (FORMAT STREAM "locally"))
	   (:SERVICE (LOOP FOR PATH IN (FIRST PARAMETERS)
			   WITH OR-P = NIL
			   DOING (IF OR-P
				     (FORMAT STREAM " or ")
				     (FORMAT STREAM "(")
				     (SETQ OR-P T))
				 (PRINT-SERVICE-ACCESS-PATH (FIRST PATH) STREAM
							    ':ONLY-SHOW-ROUTE T)
			   FINALLY (WHEN OR-P (FORMAT STREAM ")"))))
	   (:MEDIUM (FORMAT STREAM "~A" (FIRST PARAMETERS)))
	   (:NETWORK (FORMAT STREAM "on ~A" (FIRST PARAMETERS)))
	   (OTHERWISE (FORMAT STREAM "via ~S" IMPLEMENTATION)))))))

(DEFVAR *UNAVAILABLE-HOSTS* NIL)

;;; This returns the best path to each host
(DEFUN FIND-PATHS-TO-SERVICE (SERVICE &OPTIONAL ADDITIONAL-HOST-ATTRIBUTES)
  (LOOP FOR HOST IN (HOSTS-SUPPORTING-SERVICE SERVICE ADDITIONAL-HOST-ATTRIBUTES)
	AS PATHS = (AND (NOT (MEMQ HOST *UNAVAILABLE-HOSTS*))
			(FIND-PATHS-TO-SERVICE-ON-HOST SERVICE HOST))
	WHEN PATHS COLLECT (MOST-DESIRABLE-SERVICE-ACCESS-PATH PATHS) INTO RPATHS
        FINALLY (RETURN (SORT RPATHS #'SERVICE-ACCESS-PATH-DESIRABILITY-GREATERP))))

;;;

(DEFFLAVOR HOST-DOES-NOT-SUPPORT-SERVICE
	((SERVICE NIL)
	 (PROTOCOL NIL)
	 HOST
	 (POSSIBILITIES NIL)
	 (POSSIBLE-PATHS NIL)
	 HOST-PROTOCOLS
	 LOCAL-PROTOCOLS)
	(NETWORK-ERROR DBG:SPECIAL-COMMANDS-MIXIN)
  :GETTABLE-INSTANCE-VARIABLES
  (:INITABLE-INSTANCE-VARIABLES SERVICE PROTOCOL HOST POSSIBILITIES))

(DEFMETHOD (MAKE-INSTANCE HOST-DOES-NOT-SUPPORT-SERVICE) (&REST IGNORE)
  (WHEN (AND PROTOCOL (NULL SERVICE))
    (LET ((P (FIND-PROTOCOL-NAMED PROTOCOL)))
      (AND P (SETQ SERVICE (PROTOCOL-SERVICE P)))))
  (SETF HOST-PROTOCOLS (LOOP FOR ENTRY IN (SEND HOST :NETWORK-SERVICES)
			     WHEN (EQ SERVICE (HOST-SERVICE-SERVICE-NAME ENTRY))
			     COLLECT ENTRY))
  (SETF LOCAL-PROTOCOLS (LOOP FOR P IN *PROTOCOL-LIST*
			      WHEN (EQ (PROTOCOL-SERVICE P) SERVICE)
			      COLLECT P)))

(DEFMETHOD (:REPORT HOST-DOES-NOT-SUPPORT-SERVICE) (STREAM)
  (COND ((NULL LOCAL-PROTOCOLS)
	 (FORMAT STREAM "The local host does not implement any protocols for the ~A service."
	   SERVICE))
	(T (FORMAT STREAM "~A does not support ~A service" HOST SERVICE)
	   (COND (PROTOCOL (FORMAT STREAM " with ~A." PROTOCOL))
		 ((NULL HOST-PROTOCOLS)
		  (FORMAT STREAM "."))
		 (T (FORMAT STREAM " through any locally supported protocol.~%~
                                    It supports only ")
		    (FORMAT:PRINT-LIST STREAM "~{~A via ~A~}"
				       (LOOP FOR ENTRY IN HOST-PROTOCOLS
					     COLLECT (LIST (HOST-SERVICE-PROTOCOL-NAME ENTRY)
							   (HOST-SERVICE-MEDIUM-NAME ENTRY))))
		    (FORMAT STREAM ".~%The local host supports only ")
		    (FORMAT:PRINT-LIST STREAM "~{~A via ~A~}"
				       (LOOP FOR PROT IN LOCAL-PROTOCOLS
					     UNLESS (PROTOCOL-LOCALLY-IMPLEMENTED-P PROT)
					     COLLECT (LIST (PROTOCOL-NAME PROT)
							   (PROTOCOL-BASE-MEDIUM-NAME PROT))))
		    (FORMAT STREAM ".")
		    (WHEN POSSIBILITIES
		      (FORMAT STREAM "~%No path could be found for ")
		      (FORMAT:PRINT-LIST STREAM "~{~*~A via ~A~*~}" POSSIBILITIES)
		      (FORMAT STREAM "."))
		    )))))

(DEFMETHOD (:SPECIAL-COMMAND HOST-DOES-NOT-SUPPORT-SERVICE :SPECIFY-PATH) (&REST IGNORE)
  (LET ((PATH (COND ((NULL POSSIBLE-PATHS)
		     NIL)
		    ((NULL (CDR POSSIBLE-PATHS))
		     (CAR POSSIBLE-PATHS))
		    (T
		     (LOOP FOR PATH IN POSSIBLE-PATHS
			   WHEN (FQUERY NIL "Use protocol ~A on medium ~A? "
					(HOST-SERVICE-PROTOCOL-NAME PATH)
					(HOST-SERVICE-MEDIUM-NAME PATH))
			   RETURN PATH)))))
    (UNLESS (NULL PATH)
      (PUSH PATH (SEND HOST ':GET ':SERVICE))
      ;; No named error restarts yet.
      (THROW 'FIND-PATH-RETRY T))))

(DEFMETHOD (:DOCUMENT-SPECIAL-COMMAND HOST-DOES-NOT-SUPPORT-SERVICE :SPECIFY-PATH) (STREAM)
  (LOOP FOR PATH IN POSSIBLE-PATHS
	FOR FIRST-P = T THEN NIL
	DO (FORMAT STREAM (IF FIRST-P "Use protocol " ", or "))
	   (FORMAT STREAM "~A on " (HOST-SERVICE-PROTOCOL-NAME PATH))
	   (WHEN FIRST-P (FORMAT STREAM "medium "))
	   (FORMAT STREAM "~A" (HOST-SERVICE-MEDIUM-NAME PATH)))
  (FORMAT STREAM "."))

(DEFMETHOD (:INITIALIZE-SPECIAL-COMMANDS HOST-DOES-NOT-SUPPORT-SERVICE) ()
  (SETQ POSSIBLE-PATHS 
	(IF PROTOCOL
	    (FIND-POSSIBLE-PATHS-TO-PROTOCOL-ON-HOST HOST SERVICE
						     (FIND-PROTOCOL-NAMED PROTOCOL))
	    (LOOP FOR PTCL IN LOCAL-PROTOCOLS
		  APPEND (FIND-POSSIBLE-PATHS-TO-PROTOCOL-ON-HOST HOST SERVICE PTCL))))
  (SETQ POSSIBLE-PATHS (LET ((ALREADY-THERE (SEND HOST ':NETWORK-SERVICES)))
			 (LOOP FOR PATH IN POSSIBLE-PATHS
			       UNLESS (OR (MEMBER PATH ALREADY-THERE)
					  (LOOP FOR (NIL PROT MED) IN POSSIBILITIES
						THEREIS (AND (EQ MED
								 (HOST-SERVICE-MEDIUM-NAME
								   PATH))
							     (EQ (PROTOCOL-NAME PROT)
								 (HOST-SERVICE-PROTOCOL-NAME
								   PATH)))))
			       COLLECT PATH)))
  (WHEN (NULL POSSIBLE-PATHS)
    (SETQ DBG:SPECIAL-COMMANDS (REMQ ':SPECIFY-PATH DBG:SPECIAL-COMMANDS))))

;;;

(DEFUN FIND-POSSIBLE-PATHS-TO-PROTOCOL-ON-HOST (HOST SERVICE PROTOCOL)
  (LOOP WITH MEDIUM
	FOR ADDRESSES ON (SEND HOST ':NETWORK-ADDRESSES)
	AS (NETWORK) = (CAR ADDRESSES)
	UNLESS (LOOP FOR (OTHER-NETWORK) IN (CDR ADDRESSES)
		     THEREIS (EQ OTHER-NETWORK NETWORK))
	WHEN (SETQ MEDIUM (SEND NETWORK ':POSSIBLE-MEDIUM-FOR-PROTOCOL
				(PROTOCOL-NAME PROTOCOL)
				(PROTOCOL-BASE-MEDIUM-NAME PROTOCOL)))
	COLLECT (MAKE-HOST-SERVICE SERVICE-NAME SERVICE
				   MEDIUM-NAME MEDIUM
				   PROTOCOL-NAME (PROTOCOL-NAME PROTOCOL))))

;;; This is the equivalent of the above special command for use with condition-bind.
;;; Useful for applications that don't enter the error handler.
(DEFUN HOST-DOES-NOT-SUPPORT-PROTOCOL-SPECIFY-PATH-HANDLER (ERROR)
  (LET* ((HOST (SEND ERROR ':HOST))
	 (POSSIBLE-PATHS (LET ((PROTOCOL (SEND ERROR ':PROTOCOL))
			       (SERVICE (SEND ERROR ':SERVICE)))
			   (IF PROTOCOL
			       (FIND-POSSIBLE-PATHS-TO-PROTOCOL-ON-HOST
				 HOST SERVICE
				 (FIND-PROTOCOL-NAMED PROTOCOL))
			       (LOOP FOR PTCL IN *PROTOCOL-LIST*
				     WHEN (EQ (PROTOCOL-SERVICE PTCL) SERVICE)
				     APPEND (FIND-POSSIBLE-PATHS-TO-PROTOCOL-ON-HOST
					      HOST SERVICE PTCL))))))
    (SETQ POSSIBLE-PATHS (LET ((ALREADY-THERE (SEND HOST ':NETWORK-SERVICES)))
			   (LOOP FOR PATH IN POSSIBLE-PATHS
				 UNLESS (MEMBER PATH ALREADY-THERE)
				 COLLECT PATH)))
    (LOOP FOR PATH IN POSSIBLE-PATHS
	  WITH FIRST-P = T
	  DO (WHEN FIRST-P
	       (FORMAT QUERY-IO "~&~A" ERROR)
	       (SETQ FIRST-P NIL))
	     (WHEN (FQUERY NIL "Use protocol ~A on medium ~A? "
			   (HOST-SERVICE-PROTOCOL-NAME PATH)
			   (HOST-SERVICE-MEDIUM-NAME PATH))
	       (PUSH PATH (SEND HOST ':GET ':SERVICE))
	       ;; No named error restarts yet.
	       (THROW 'FIND-PATH-RETRY T))))
  NIL)						;Didn't handle if didn't throw.

;;; This is another disgusting kludge of the likes of the one above but can be used without
;;; user intervention
(DEFUN HOST-DOES-NOT-SUPPORT-PROTOCOL-USE-FIRST-PATH (ERROR)
  (LET* ((HOST (SEND ERROR ':HOST))
	 (POSSIBLE-PATHS (LET ((PROTOCOL (SEND ERROR ':PROTOCOL))
			       (SERVICE (SEND ERROR ':SERVICE)))
			   (IF PROTOCOL
			       (FIND-POSSIBLE-PATHS-TO-PROTOCOL-ON-HOST
				 HOST SERVICE
				 (FIND-PROTOCOL-NAMED PROTOCOL))
			       (LOOP FOR PTCL IN *PROTOCOL-LIST*
				     WHEN (EQ (PROTOCOL-SERVICE PTCL) SERVICE)
				     APPEND (FIND-POSSIBLE-PATHS-TO-PROTOCOL-ON-HOST
					      HOST SERVICE PTCL))))))
    (SETQ POSSIBLE-PATHS (LET ((ALREADY-THERE (SEND HOST ':NETWORK-SERVICES)))
			   (LOOP FOR PATH IN POSSIBLE-PATHS
				 UNLESS (MEMBER PATH ALREADY-THERE)
				 COLLECT PATH)))
    (WHEN POSSIBLE-PATHS
      (PUSH (FIRST POSSIBLE-PATHS) (SEND HOST ':GET ':SERVICE))
      ;; No named error restarts yet.
      (THROW 'FIND-PATH-RETRY T)))
  NIL)

(DEFFLAVOR NO-SUCH-PROTOCOL (PROTOCOL) (NETWORK-ERROR)
  :INITABLE-INSTANCE-VARIABLES
  :GETTABLE-INSTANCE-VARIABLES)

(DEFMETHOD (:REPORT NO-SUCH-PROTOCOL) (STREAM)
  (FORMAT STREAM "~A is not a known network protocol." PROTOCOL))

(COMPILE-FLAVOR-METHODS HOST-DOES-NOT-SUPPORT-SERVICE NO-SUCH-PROTOCOL)

;;

(DEFVAR *INVOKE-SERVICE-AUTOMATIC-RETRY* NIL "Cause INVOKE-SERVICE-ON-HOST to automatically try all paths.")

(DEFFLAVOR UNABLE-TO-INVOKE-SERVICE (SERVICE HOST SERVICE-ACCESS-PATHS ERRORS)
	   (NETWORK-ERROR)
  :INITABLE-INSTANCE-VARIABLES)

(DEFMETHOD (:REPORT UNABLE-TO-INVOKE-SERVICE) (STREAM)
  (FORMAT STREAM "Unable to invoke service ~A on host ~A by any path." SERVICE HOST)
  (LOOP FOR SERVICE-ACCESS-PATH IN SERVICE-ACCESS-PATHS
	FOR ERROR IN ERRORS
	DO (FORMAT STREAM "~&~A: ~A" SERVICE-ACCESS-PATH ERROR)))

;;

;;; This is probably the normal interface function
(DEFUN INVOKE-SERVICE-ON-HOST (SERVICE HOST &REST SERVICE-ARGS)
  (LET ((THESE-ARGS (COPYLIST SERVICE-ARGS)))
    (ERROR-RESTART ((ERROR) "Retry invoking ~A on ~A." SERVICE HOST)
      (LOOP DOING
	    (CATCH 'FIND-PATH-RETRY
	      (LET ((SERVICE-ACCESS-PATHS (FIND-PATHS-TO-SERVICE-ON-HOST SERVICE HOST NIL T))
		    (ERRORS))
		(RETURN
		  (IF (AND *INVOKE-SERVICE-AUTOMATIC-RETRY*
			   (NOT (NULL (REST1 SERVICE-ACCESS-PATHS))))
		      (LOOP FOR THIS-PATH IN SERVICE-ACCESS-PATHS
			    DO (CONDITION-CASE (ERROR)
				    (RETURN (INVOKE-SERVICE-ACCESS-PATH THIS-PATH THESE-ARGS))
				  (CONNECTION-ERROR (PUSH ERROR ERRORS)))
			    FINALLY (ERROR 'UNABLE-TO-INVOKE-SERVICE
					   ':SERVICE SERVICE ':HOST HOST
					   ':SERVICE-ACCESS-PATHS SERVICE-ACCESS-PATHS
					   ':ERRORS (REVERSE ERRORS)))
		      (LOOP FOR SAPS ON SERVICE-ACCESS-PATHS
			    FOR THIS-PATH = (FIRST SAPS)
			    DO (CATCH-ERROR-RESTART-IF
				 (NOT (NULL (REST1 SAPS)))
				 ((ERROR) "Try ~A~@[ (~{or ~A~^ ~})~]."
				  (SECOND SAPS) (REST2 SAPS))
				 (RETURN (INVOKE-SERVICE-ACCESS-PATH THIS-PATH THESE-ARGS))))
		      ))))))))

(DEFUN FIND-PATH-TO-SERVICE-ON-HOST (SERVICE HOST)
  (LOOP DOING
    (CATCH 'FIND-PATH-RETRY
      (LET ((PATHS (FIND-PATHS-TO-SERVICE-ON-HOST SERVICE HOST T T)))
	(RETURN (MOST-DESIRABLE-SERVICE-ACCESS-PATH PATHS))))))

(DEFUN FIND-PATHS-TO-SERVICE-USING-BROADCAST (SERVICE)
  (LOOP FOR PROTOCOL IN *PROTOCOL-LIST*
	WHEN (EQ (PROTOCOL-SERVICE PROTOCOL) SERVICE)
	APPEND (FIND-PATHS-TO-SERVICE-ON-HOST-1 SERVICE PROTOCOL ':BROADCAST
						(PROTOCOL-BASE-MEDIUM-NAME PROTOCOL))
	  INTO PATHS
        FINALLY (RETURN (SORT PATHS #'SERVICE-ACCESS-PATH-DESIRABILITY-GREATERP))))

(DEFUN FIND-PATH-TO-PROTOCOL-ON-HOST (PROTOCOL-NAME HOST)
  (LOOP DOING
    (CATCH 'FIND-PATH-RETRY
      (LET ((PATHS (FIND-PATHS-TO-PROTOCOL-ON-HOST PROTOCOL-NAME HOST T)))
	(RETURN (MOST-DESIRABLE-SERVICE-ACCESS-PATH PATHS))))))

(DEFUN FIND-PATHS-TO-PROTOCOL-ON-HOST (PROTOCOL-NAME HOST &OPTIONAL MUST-HAVE-ONE)
  (LET ((PROTOCOL (FIND-PROTOCOL-NAMED PROTOCOL-NAME)))
    (UNLESS PROTOCOL
      (ERROR 'NO-SUCH-PROTOCOL ':PROTOCOL PROTOCOL-NAME))
    (LET ((MEDIUM (PROTOCOL-BASE-MEDIUM-NAME PROTOCOL)))
      ;; For efficiency, see if there is only one medium over which this host implements
      ;; the protocol.  If so, use that to avoid searching for screwy implementations
      ;; of the medium.
      (LOOP FOR HOST-SERVICES ON (SEND HOST :NETWORK-SERVICES)
	    AS HOST-SERVICE = (CAR HOST-SERVICES)
	    WHEN (EQ (HOST-SERVICE-PROTOCOL-NAME HOST-SERVICE) PROTOCOL-NAME)
	    RETURN (WHEN (LOOP FOR HOST-SERVICE IN (CDR HOST-SERVICES)
			       NEVER (EQ (HOST-SERVICE-PROTOCOL-NAME HOST-SERVICE)
					 PROTOCOL-NAME))
		     (SETQ MEDIUM (HOST-SERVICE-MEDIUM-NAME HOST-SERVICE)))
	    FINALLY (WHEN MUST-HAVE-ONE
		      (ERROR 'HOST-DOES-NOT-SUPPORT-SERVICE
			     :HOST HOST :PROTOCOL PROTOCOL-NAME)))
      (LET ((PATHS (FIND-PATHS-TO-SERVICE-ON-HOST-1
		     (PROTOCOL-SERVICE PROTOCOL) PROTOCOL HOST MEDIUM)))
	(UNLESS PATHS
	  (ERROR 'HOST-DOES-NOT-SUPPORT-SERVICE
		 :HOST HOST :PROTOCOL PROTOCOL-NAME :POSSIBILITIES `((NIL PROTOCOL MEDIUM))))
	(SORT PATHS #'SERVICE-ACCESS-PATH-DESIRABILITY-GREATERP)))))

;;; Stack cons'ed list of pairs of host and service required of host, to prevent infinite
;;; recursion.
(DEFVAR *HOSTS-ALREADY-IN-PATH* NIL)

(DEFUN FIND-USEFUL-SERVICE-ENTRIES (HOST SERVICE ONLY-NEED-BEST)
  (APPEND (WHEN (NS-EQ HOST *LOCAL-HOST*)
	    (LOOP FOR PROTOCOL IN *PROTOCOL-LIST*
		  WHEN (AND (EQ SERVICE (PROTOCOL-SERVICE PROTOCOL))
			    (PROTOCOL-LOCALLY-IMPLEMENTED-P PROTOCOL))
		  COLLECT (LIST 1.0 PROTOCOL :LOCAL NIL)))
	  (LOOP FOR HOST-SERVICE IN (SEND HOST :SERVICE)
		AS PROTOCOL = (WHEN (EQ (HOST-SERVICE-SERVICE-NAME HOST-SERVICE)
					SERVICE)
				(FIND-PROTOCOL-NAMED
				  (HOST-SERVICE-PROTOCOL-NAME HOST-SERVICE)
				  SERVICE))
		WHEN PROTOCOL
		COLLECT (LIST (IF ONLY-NEED-BEST
				  (HOST-SERVICE-MAXIMUM-DESIRABILITY
				    HOST PROTOCOL HOST-SERVICE)
				  1.0)
			      PROTOCOL
			      (HOST-SERVICE-MEDIUM-NAME HOST-SERVICE)
			      NIL))))

;;; This returns a list (reverse) sorted by desirability.
;;; ONLY-NEED-BEST means we are only going to use the best, so we try to guess the best from
;;; the start and save lots of searching for long paths.
(DEFUN FIND-PATHS-TO-SERVICE-ON-HOST (SERVICE HOST &OPTIONAL ONLY-NEED-BEST MUST-HAVE-ONE)
  (KEEPING-NAMESPACE-SERVER
    (WITH-STACK-LIST (SERVICE-AND-HOST SERVICE HOST)
      (UNLESS (MEMBER SERVICE-AND-HOST *HOSTS-ALREADY-IN-PATH*)
	(WITH-STACK-LIST* (*HOSTS-ALREADY-IN-PATH* SERVICE-AND-HOST *HOSTS-ALREADY-IN-PATH*)
	  (LET ((PATHS NIL)
		(MINIMUM-REQUIRED-DESIRABILITY NIL)
		(SERVICES (FIND-USEFUL-SERVICE-ENTRIES HOST SERVICE ONLY-NEED-BEST)))
	    ;;Make the best services likely to come early
	    (WHEN ONLY-NEED-BEST
	      (SETF SERVICES (SORTCAR SERVICES #'>)))
	    ;;Process each service
	    (LOOP FOR ENTRY IN SERVICES
		  FOR (MAX-DESIRABILITY PROTOCOL MEDIUM) = ENTRY
		  WHEN (OR (NULL MINIMUM-REQUIRED-DESIRABILITY)
			   ( MAX-DESIRABILITY MINIMUM-REQUIRED-DESIRABILITY))
		  DO (LET ((THESE-PATHS (FIND-PATHS-TO-SERVICE-ON-HOST-1
					  SERVICE PROTOCOL HOST MEDIUM)))
		       (SETF (FOURTH ENTRY) (COPYLIST THESE-PATHS))
		       (IF ONLY-NEED-BEST
			   (LOOP FOR PATH IN THESE-PATHS
				 FOR DESIRABILITY = (SERVICE-ACCESS-PATH-DESIRABILITY PATH)
				 WHEN (OR (NULL MINIMUM-REQUIRED-DESIRABILITY)
					  (> DESIRABILITY MINIMUM-REQUIRED-DESIRABILITY))
				 DO
				 (SETF MINIMUM-REQUIRED-DESIRABILITY DESIRABILITY)
				 (SETF PATHS PATH))
			   (SETF PATHS (APPEND THESE-PATHS PATHS)))))
	    ;;Make sure we got one
	    (WHEN (AND MUST-HAVE-ONE (NULL PATHS))
	      (ERROR 'HOST-DOES-NOT-SUPPORT-SERVICE
		     :HOST HOST :SERVICE SERVICE :POSSIBILITIES SERVICES))
	    ;;Return
	    (IF ONLY-NEED-BEST
		(AND PATHS (LIST PATHS))
		(SORT PATHS #'SERVICE-ACCESS-PATH-DESIRABILITY-GREATERP))))))))

(DEFUN FIND-PATHS-TO-SERVICE-ON-HOST-1 (SERVICE PROTOCOL HOST MEDIUM-NAME)
  (MULTIPLE-VALUE-BIND (ENCAPSULATIONS MEDIUM-CONTAINED)
      (COMPUTE-MEDIUM-ENCAPSULATIONS MEDIUM-NAME (PROTOCOL-BASE-MEDIUM-NAME PROTOCOL) NIL)
    (WHEN MEDIUM-CONTAINED
      (LOOP FOR MEDIUM IN (FIND-PATHS-FOR-MEDIUM-TO-HOST MEDIUM-NAME PROTOCOL HOST)
	    FOR ENCAPSULATION = (LOOP FOR ENC-MEDIUM IN ENCAPSULATIONS
				      WITH MEDIUM-DESC = MEDIUM
				      DO (SETF MEDIUM-DESC (MAKE-MEDIUM-DESCRIPTION
							     IMPLEMENTATION ENC-MEDIUM
							     PARAMETERS (LIST MEDIUM-DESC)))
				      FINALLY (RETURN MEDIUM-DESC))
	    AS PATH = (MAKE-SERVICE-ACCESS-PATH SERVICE SERVICE
						HOST HOST
						PROTOCOL PROTOCOL
						MEDIUM ENCAPSULATION
						DESIRABILITY
						(* (COMPUTE-PROTOCOL-DESIRABILITY
						     HOST PROTOCOL SERVICE
						     (GET-MEDIUM-NETWORK MEDIUM))
						   (COMPUTE-MEDIUM-DESIRABILITY
						     MEDIUM HOST)))
	    COLLECT PATH))))

(DEFUN COMPUTE-MEDIUM-ENCAPSULATIONS (MEDIUM-NAME BASE-MEDIUM-NAME IMPLEMENTATION-LIST)
  (DECLARE (VALUES ENCAPSULATIONS MEDIUM-CONTAINED))
  (IF (EQ MEDIUM-NAME BASE-MEDIUM-NAME)
      (VALUES IMPLEMENTATION-LIST T)
      (LOOP WITH BASE-MEDIUM = (FIND-MEDIUM-NAMED BASE-MEDIUM-NAME)
	    FOR IMPLEMENTATION IN (MEDIUM-IMPLEMENTATIONS BASE-MEDIUM)
	    FOR FIRST-STEP = (FIRST (MEDIUM-IMPLEMENTATION-PATH IMPLEMENTATION))
	    WHEN (EQ (FIRST FIRST-STEP) :MEDIUM)
	    DO (MULTIPLE-VALUE-BIND (NEXT-ENCAPSULATIONS NEXT-CONTAINED)
		   (COMPUTE-MEDIUM-ENCAPSULATIONS
		     MEDIUM-NAME (SECOND FIRST-STEP)
		     (IF (MEDIUM-IMPLEMENTATION-FUNCTION IMPLEMENTATION)
			 (LIST* IMPLEMENTATION IMPLEMENTATION-LIST)
			 IMPLEMENTATION-LIST))
		 (WHEN NEXT-CONTAINED
		   (RETURN (VALUES NEXT-ENCAPSULATIONS T)))))))

(DEFUN MEDIUM-CAN-IMPLEMENT-BASE-MEDIUM (MEDIUM-NAME BASE-MEDIUM-NAME)
  (OR (EQ MEDIUM-NAME BASE-MEDIUM-NAME)
      (LET ((BASE-MEDIUM (FIND-MEDIUM-NAMED BASE-MEDIUM-NAME)))
	(WHEN BASE-MEDIUM
	  (LOOP FOR IMPLEMENTATION IN (MEDIUM-IMPLEMENTATIONS BASE-MEDIUM)
		FOR FIRST-STEP = (FIRST (MEDIUM-IMPLEMENTATION-PATH IMPLEMENTATION))
		WHEN (EQ (FIRST FIRST-STEP) :MEDIUM)
		  THEREIS (MEDIUM-CAN-IMPLEMENT-BASE-MEDIUM MEDIUM-NAME
							    (SECOND FIRST-STEP)))))))

(defun compute-protocol-desirability (host protocol service-name network)
  (* (protocol-desirability protocol)
     ;; Refinement factors.  Host demerits take from 0 to .01.
     ;; Operating system considerations take from 0 to .001.
     ;; Being at another site takes .00005.
     D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");; Being in another namespace takes .00005
0     (if (eq host ':broadcast) 1
       (let ((desirability 1)
	     (host-availability (send host ':availability
				      ':service service-name ':network network))
	     (host-desirability (compute-host-protocol-desirability
				  host (protocol-name protocol))))
	 (unless (= host-availability 1)
	   (decf desirability (* .01 (- 1.0 host-availability))))
	 (unless (= host-desirability 1)
	   (decf desirability (* .001 (- 1.0 host-desirability))))
	 (unless (eq (send host ':site) *local-site*)
	   (decf desirability .00005))
	 (unless (and (not (symbolp (send host :site)))
		      (eq (send (send host :site) :local-namespace) *namespace*))
	   (decf desirability .00005))		      
	 desirability))))


(DEFVAR *SITE-HOST-PROTOCOL-DESIRABILITIES* NIL)

(DEFUN RECOMPUTE-SITE-HOST-PROTOCOL-DESIRABILITIES ()
  (SCL:WITH-STANDARD-IO-ENVIRONMENT
    (SETQ *SITE-HOST-PROTOCOL-DESIRABILITIES*
	  (COPYLIST (LOOP FOR (HOST PROTOCOL DESIRABILITY)
			      IN (SI:GET-SITE-OPTION :HOST-PROTOCOL-DESIRABILITY)
			  COLLECT (LIST HOST PROTOCOL (READ-FROM-STRING DESIRABILITY)))))))

(ADD-INITIALIZATION "SITE:*SITE-HOST-PROTOCOL-DESIRABILITIES*"
		    '(RECOMPUTE-SITE-HOST-PROTOCOL-DESIRABILITIES)
		    '(:SITE :NORMAL))

(DEFUN COMPUTE-HOST-PROTOCOL-DESIRABILITY (HOST PROTOCOL-NAME)
  (OR (LOOP FOR (HST PROT DESIRABILITY) IN *SITE-HOST-PROTOCOL-DESIRABILITIES*
	    WHEN (AND (EQ HST HOST) (EQ PROT PROTOCOL-NAME))
	    RETURN DESIRABILITY)
      (SEND HOST ':PROTOCOL-DESIRABILITY PROTOCOL-NAME)))

(DEFUN COMPUTE-MEDIUM-DESIRABILITY (MEDIUM &OPTIONAL FOR-HOST)
  (LOOP WITH DESIRABILITY = 1
	FOR ISTEP IN (MEDIUM-IMPLEMENTATION-PATH
		       (MEDIUM-DESCRIPTION-IMPLEMENTATION MEDIUM))
	FOR PSTEP IN (MEDIUM-DESCRIPTION-PARAMETERS MEDIUM)
	AS FIRST-P = T THEN NIL
	AS STEP-DESIRABILITY = (SELECTQ (FIRST ISTEP)
				 (:SERVICE (SERVICE-ACCESS-PATH-DESIRABILITY
					     (FIRST (FIRST PSTEP))))
				 (:MEDIUM (COMPUTE-MEDIUM-DESIRABILITY
					    PSTEP (AND FIRST-P FOR-HOST)))
				 (:NETWORK (SEND PSTEP ':DESIRABILITY
						 (AND FIRST-P FOR-HOST)))
				 (:LOCAL 1)
				 (OTHERWISE (FERROR "Unknown step ~S" ISTEP)))
	DO (SETQ DESIRABILITY (* STEP-DESIRABILITY DESIRABILITY))
	FINALLY (RETURN DESIRABILITY)))

(DEFUN GET-MEDIUM-NETWORK (MEDIUM)
  (LET ((ISTEP (FIRST (MEDIUM-IMPLEMENTATION-PATH
			(MEDIUM-DESCRIPTION-IMPLEMENTATION MEDIUM))))
	(PSTEP (FIRST (MEDIUM-DESCRIPTION-PARAMETERS MEDIUM))))
    (SELECTQ (FIRST ISTEP)
      (:MEDIUM (GET-MEDIUM-NETWORK PSTEP))
      (:NETWORK PSTEP)
      (OTHERWISE NIL))))

;;; This is the maximum that the desirability could be, takes the protocol, host and
;;; best implementation of the medium into account.
(DEFUN HOST-SERVICE-MAXIMUM-DESIRABILITY (HOST PROTOCOL HOST-SERVICE)
  (* (COMPUTE-PROTOCOL-DESIRABILITY HOST PROTOCOL
				    (HOST-SERVICE-SERVICE-NAME HOST-SERVICE) NIL)
     (HOST-MEDIUM-MAXIMUM-DESIRABILITY HOST (HOST-SERVICE-MEDIUM-NAME HOST-SERVICE))))

(DEFUN HOST-MEDIUM-MAXIMUM-DESIRABILITY (HOST MEDIUM-NAME &OPTIONAL RECURSIVE)
  (LET ((MEDIUM (FIND-MEDIUM-NAMED MEDIUM-NAME)))
    (IF (NULL MEDIUM) 0
      (LOOP FOR IMPLEMENTATION IN (MEDIUM-IMPLEMENTATIONS MEDIUM)
	    MAXIMIZE (LOOP WITH RESULT = 1
			   FOR ISTEP IN (MEDIUM-IMPLEMENTATION-PATH IMPLEMENTATION)
			   AS STEP-DESIR = (SELECTQ (FIRST ISTEP)
					     (:MEDIUM
					      ;; If recursive, you have to use some other
					      ;; implementation to get there.
					      (IF RECURSIVE 0
						(HOST-MEDIUM-MAXIMUM-DESIRABILITY
						  HOST (SECOND ISTEP) T)))
					     (:NETWORK
					      (LOOP FOR (NETWORK)
						      IN (SEND HOST ':NETWORK-ADDRESSES)
						    WHEN (SEND NETWORK ':NETWORK-TYPEP
							       (SECOND ISTEP))
						      MAXIMIZE (SEND NETWORK ':DESIRABILITY
								     HOST)))
					     (OTHERWISE 1))
			   DO (SETQ RESULT (* RESULT STEP-DESIR))
			   FINALLY (RETURN RESULT))))))

(DEFUN SERVICE-ACCESS-PATH-DESIRABILITY-GREATERP (X Y)
  (> (SERVICE-ACCESS-PATH-DESIRABILITY X) (SERVICE-ACCESS-PATH-DESIRABILITY Y)))

;;; Use this instead of FIRST to choose the most desirable access-path.
;;; ACCESS-PATHS is sorted, chooses a random one of the most desirable.
;;; This should tend to offload gateways and mail servers that are equivalent.
(DEFUN MOST-DESIRABLE-SERVICE-ACCESS-PATH (ACCESS-PATHS)
  (IF (NULL (CDR ACCESS-PATHS))
      (FIRST ACCESS-PATHS)			;Fast handling of this case
    (LET ((LENGTH (LOOP WITH PREV = NIL
			FOR PATH IN ACCESS-PATHS
			DO (IF (NULL PREV)
			       (SETQ PREV (SERVICE-ACCESS-PATH-DESIRABILITY PATH))
			       (UNLESS (= PREV (SERVICE-ACCESS-PATH-DESIRABILITY PATH))
				 (LOOP-FINISH)))
			SUM 1)))
      (NTH (RANDOM LENGTH) ACCESS-PATHS))))

;;; If the desirability ever drops THRESHOLD below the best, flush it.
(DEFUN WEED-OUT-SILLY-SERVICE-ACCESS-PATHS (ACCESS-PATHS THRESHOLD)
  (WHEN ACCESS-PATHS
    (LET* ((BEST (SERVICE-ACCESS-PATH-DESIRABILITY (FIRST ACCESS-PATHS)))
	   (THIS-THRESH (* BEST THRESHOLD)))
      (LOOP FOR LIST = ACCESS-PATHS THEN (CDR LIST) UNTIL (NULL (CDR LIST))
	    WHEN (> (- BEST (SERVICE-ACCESS-PATH-DESIRABILITY (SECOND LIST))) THIS-THRESH)
	    RETURN (SETF (CDR LIST) NIL))))
  ACCESS-PATHS)

;;; PROTOCOL need only be looked at in the broadcast case, since we otherwise know that
;;; the medium supports this protocol because it came from the host table.
(DEFUN FIND-PATHS-FOR-MEDIUM-TO-HOST (MEDIUM-NAME PROTOCOL HOST
				      &OPTIONAL (FROM-HOST *LOCAL-HOST*))
  (LET ((MEDIUM (FIND-MEDIUM-NAMED MEDIUM-NAME)))
    (AND MEDIUM
	 (LOOP FOR IMPLEMENTATION IN (MEDIUM-IMPLEMENTATIONS MEDIUM)
	       AS POSSIBILITIES = (FIND-PATHS-FOR-MEDIUM-TO-HOST-1
				    (MEDIUM-IMPLEMENTATION-PATH IMPLEMENTATION)
				    PROTOCOL HOST FROM-HOST MEDIUM)
	       WHEN POSSIBILITIES
		 APPEND (LOOP FOR PARAMETERS IN POSSIBILITIES
			      COLLECT (MAKE-MEDIUM-DESCRIPTION IMPLEMENTATION IMPLEMENTATION
							       PARAMETERS PARAMETERS))))))

(DEFUN FIND-PATHS-FOR-MEDIUM-TO-HOST-1 (PATH PROTOCOL HOST FROM-HOST MEDIUM)
  (LET ((FIRST-STEP (FIRST PATH)))
    (SELECTQ (FIRST FIRST-STEP)
      (:SERVICE
       (WHEN (AND (EQ FROM-HOST *LOCAL-HOST*)
		  ;; Assume it's a waste to go through a gateway
		  1;; 0to get a broadcast done.
		  (NEQ HOST ':BROADCAST))
	 (LET ((GATEWAY-PATHS
		 (SORTCAR
		   (LOOP FOR SERVICE-ACCESS-PATH IN (FIND-PATHS-TO-SERVICE (SECOND FIRST-STEP))
			 APPEND (WITH-STACK-LIST (SERVICE-AND-HOST
						   (SERVICE-ACCESS-PATH-SERVICE
						     SERVICE-ACCESS-PATH)
						   (SERVICE-ACCESS-PATH-HOST
						     SERVICE-ACCESS-PATH))
				  (UNLESS (MEMBER SERVICE-AND-HOST *HOSTS-ALREADY-IN-PATH*)
				    (WITH-STACK-LIST* (*HOSTS-ALREADY-IN-PATH*
							SERVICE-AND-HOST
							*HOSTS-ALREADY-IN-PATH*)
				      (LOOP FOR PATH IN
						(FIND-PATHS-FOR-MEDIUM-TO-HOST-1
						  (CDR PATH) PROTOCOL HOST
						  (SERVICE-ACCESS-PATH-HOST
						    SERVICE-ACCESS-PATH)
						  MEDIUM)
					    COLLECT (CONS SERVICE-ACCESS-PATH PATH))
				      ))))
		   #'SERVICE-ACCESS-PATH-DESIRABILITY-GREATERP)))
	   (AND GATEWAY-PATHS (LIST (LIST GATEWAY-PATHS))))))
      (:MEDIUM
       (LOOP FOR MEDIUM IN (FIND-PATHS-FOR-MEDIUM-TO-HOST (SECOND FIRST-STEP) PROTOCOL
							  HOST FROM-HOST)
	     COLLECT (LIST MEDIUM)))
      (:NETWORK
       ;; Only count each network once
       (IF (EQ HOST ':BROADCAST)
	   (LOOP WITH TYPE = (SECOND FIRST-STEP)
		 FOR LIST ON (SEND FROM-HOST ':NETWORK-ADDRESSES)
		 AS (NETWORK NIL) = (FIRST LIST)
		 UNLESS (LOOP FOR (OTHER-NETWORK NIL) IN (CDR LIST)
			      THEREIS (EQ OTHER-NETWORK NETWORK))
		   WHEN (AND (SEND NETWORK ':NETWORK-TYPEP TYPE)
			     (SEND NETWORK ':SUPPORTS-BROADCAST
				   (PROTOCOL-NAME PROTOCOL))
			     (SEND NETWORK :ENABLED))
		     COLLECT (LIST NETWORK))
	   (LOOP WITH TYPE = (SECOND FIRST-STEP)
		 FOR LIST ON (SEND HOST ':NETWORK-ADDRESSES)
		 AS (NETWORK NIL) = (FIRST LIST)
		 WHEN (AND (SEND NETWORK :NETWORK-TYPEP TYPE)
			   (NOT (LOOP FOR (OTHER-NETWORK NIL) IN (CDR LIST)
				      THEREIS (NETWORK-EQL OTHER-NETWORK NETWORK)))
			   (SEND NETWORK :SUPPORTS-PROTOCOL-ON-MEDIUM
				 (PROTOCOL-NAME PROTOCOL) (MEDIUM-NAME MEDIUM)))
		   WHEN (LOOP FOR (FROM-NETWORK NIL) IN
				  (SEND FROM-HOST ':NETWORK-ADDRESSES)
			      THEREIS
				(AND (NETWORK-EQL FROM-NETWORK NETWORK)
				     (OR (NOT (EQ FROM-HOST *LOCAL-HOST*))
					 (SEND FROM-NETWORK :ENABLED))))
		     COLLECT (LIST NETWORK))))
      (:LOCAL
       (WHEN (NS-EQ HOST *LOCAL-HOST*)
	 (LIST (LIST NIL))))
      (OTHERWISE
       (FERROR "Unknown implementation step: ~S" FIRST-STEP)))))

(DEFUN INVOKE-SERVICE-ACCESS-PATH (SERVICE-ACCESS-PATH SERVICE-ARGS)
  (SETF (SERVICE-ACCESS-PATH-ARGS SERVICE-ACCESS-PATH) SERVICE-ARGS)
  (MULTIPLE-VALUE-PROG1
    (ERROR-RESTART ((ERROR) "Retry invoking ~A." SERVICE-ACCESS-PATH)
      (CONDITION-BIND ((CONNECTION-ERROR #'CONNECTION-ERROR-DEMERIT-HOST))
	(FUNCALL (PROTOCOL-INVOKE-FUNCTION (SERVICE-ACCESS-PATH-PROTOCOL SERVICE-ACCESS-PATH))
		 SERVICE-ACCESS-PATH)))
    (LET ((HOST (SERVICE-ACCESS-PATH-HOST SERVICE-ACCESS-PATH)))
      (UNLESS (SYMBOLP HOST)
	(SEND HOST ':SET-AVAILABLE
	      ':SERVICE (SERVICE-ACCESS-PATH-SERVICE SERVICE-ACCESS-PATH))))))

(DEFUN CONNECTION-ERROR-DEMERIT-HOST (CONDITION)
  (LET ((FOREIGN-HOST (SEND CONDITION ':FOREIGN-HOST)))
    (UNLESS (SYMBOLP FOREIGN-HOST)		;NIL or :NONE
      (LET ((NETWORK (SEND CONDITION ':NETWORK)))
	(TYPECASE CONDITION
	  (HOST-NOT-RESPONDING
	    (SEND FOREIGN-HOST ':SET-UNAVAILABLE ':NETWORK NETWORK ':REASON CONDITION))
	  (CONNECTION-REFUSED
	    (SEND FOREIGN-HOST ':SET-AVAILABLE ':NETWORK NETWORK)
	    (SEND FOREIGN-HOST ':SET-UNAVAILABLE ':SERVER T ':REASON CONDITION))))))
  NIL)

(DEFUN INVOKE-SERVICE-ACCESS-PATH-WITH-CACHED-UNAVAILABILITY
       (SERVICE-ACCESS-PATH TIMEOUT SERVICE-ARGS)
  (WHEN (MULTIPLE-VALUE-BIND (AVAILABLE TIME)
	    (SEND (SERVICE-ACCESS-PATH-HOST SERVICE-ACCESS-PATH) :AVAILABLE
		  :SERVICE (SERVICE-ACCESS-PATH-SERVICE SERVICE-ACCESS-PATH)
		  :NETWORK (GET-MEDIUM-NETWORK
			      (SERVICE-ACCESS-PATH-MEDIUM SERVICE-ACCESS-PATH)))
	  (AND (NOT AVAILABLE)
	       (OR (EQ TIME :PERMANENTLY)
		   (NOT (TIME-ELAPSED-P TIMEOUT TIME)))))
    (SIGNAL 'HOST-BELIEVED-UNAVAILABLE
	    :FOREIGN-HOST (SERVICE-ACCESS-PATH-HOST SERVICE-ACCESS-PATH)))
  (INVOKE-SERVICE-ACCESS-PATH SERVICE-ACCESS-PATH SERVICE-ARGS))

(DEFFLAVOR GATEWAY-CONNECTION-ERROR (SERVICE-ACCESS-PATH SERVICE-ACCESS-PATHS ERRORS)
	   (NETWORK-ERROR)
  :INITABLE-INSTANCE-VARIABLES)

(DEFMETHOD (:REPORT GATEWAY-CONNECTION-ERROR) (STREAM)
  (FORMAT STREAM "Unable to invoke ~A by any path." SERVICE-ACCESS-PATH)
  (LOOP FOR PATH IN SERVICE-ACCESS-PATHS
	FOR ERROR IN ERRORS
	DO (FORMAT STREAM "~&~A: ~A" PATH ERROR)))

(DEFPROP CALLED-WITH-MEDIUM T SI:DEBUG-INFO)

(DEFUN GET-CONNECTION-FOR-SERVICE (SERVICE-ACCESS-PATH &REST CONNECTION-ARGS)
  (GET-CONNECTION-FOR-SERVICE-ON-MEDIUM (SERVICE-ACCESS-PATH-MEDIUM SERVICE-ACCESS-PATH)
				SERVICE-ACCESS-PATH CONNECTION-ARGS))

(DEFUN GET-CONNECTION-FOR-SERVICE-ON-MEDIUM (MEDIUM SERVICE-ACCESS-PATH CONNECTION-ARGS)
  (LET* ((IMPLEMENTATION (MEDIUM-DESCRIPTION-IMPLEMENTATION MEDIUM))
	 (IMPLEMENTATION-PATH (MEDIUM-IMPLEMENTATION-PATH IMPLEMENTATION))
	 (implementation-connection-args
	   (medium-implementation-connection-args IMPLEMENTATION))
	 (FIRST-STEP (FIRST IMPLEMENTATION-PATH))
	 (FIRST-PARAMETER (FIRST (MEDIUM-DESCRIPTION-PARAMETERS MEDIUM))))
    (SELECTQ (FIRST FIRST-STEP)
      (:SERVICE
       (ERROR-RESTART (ERROR "Retry invoking gateway services ~A for ~A."
			     MEDIUM SERVICE-ACCESS-PATH)
	 (LOOP WITH (PATH-LIST ERROR-LIST)
	       FOR PATH IN FIRST-PARAMETER
	       DO (CONDITION-CASE (ERROR)
		      (RETURN (INVOKE-SERVICE-ACCESS-PATH
				(FIRST PATH)
				(LIST SERVICE-ACCESS-PATH CONNECTION-ARGS (REST1 PATH))))
		    (CONNECTION-ERROR (PUSH ERROR ERROR-LIST) (PUSH (FIRST PATH) PATH-LIST)))
	       FINALLY (ERROR 'GATEWAY-CONNECTION-ERROR
			      ':SERVICE-ACCESS-PATH SERVICE-ACCESS-PATH
			      ':SERVICE-ACCESS-PATHS PATH-LIST ':ERRORS ERROR-LIST))))
      (:MEDIUM
       (LET ((FUNCTION (MEDIUM-IMPLEMENTATION-FUNCTION IMPLEMENTATION)))
	 (IF (AND FUNCTION (SI:DEBUGGING-INFO-USER-ENTRY FUNCTION 'CALLED-WITH-MEDIUM))
	     (LEXPR-FUNCALL FUNCTION SERVICE-ACCESS-PATH FIRST-PARAMETER CONNECTION-ARGS)
	     (LET ((CONNECTION (GET-CONNECTION-FOR-SERVICE-ON-MEDIUM
				 FIRST-PARAMETER SERVICE-ACCESS-PATH
				 (APPEND IMPLEMENTATION-CONNECTION-ARGS CONNECTION-ARGS)))
		   (CONNECTED NIL))
	       (IF (NULL FUNCTION)
		   CONNECTION
		   (UNWIND-PROTECT
		     (PROG1
		       (LEXPR-FUNCALL FUNCTION SERVICE-ACCESS-PATH CONNECTION CONNECTION-ARGS)
		       (SETQ CONNECTED T))
		     (UNLESS CONNECTED
		       (SEND CONNECTION ':CLOSE ':ABORT))))))))
      (:NETWORK
       (ERROR-RESTART (ERROR "Retry getting connection ~A for ~A." MEDIUM SERVICE-ACCESS-PATH)
	 (GET-CONNECTION-FOR-SERVICE-TO-HOST SERVICE-ACCESS-PATH FIRST-PARAMETER
					     IMPLEMENTATION CONNECTION-ARGS)))
      (:LOCAL
       (FERROR "Attempt to get network connection for locally implemented service."))
      (OTHERWISE
       (FERROR "Unknown first step type ~S" FIRST-STEP)))))

;;;; Service futures

;;; Start the connection going, returns T if future started, else NIL and values from normal
;;;  invocation (such as from a local service).
(DEFUN START-SERVICE-ACCESS-PATH-FUTURE (SERVICE-ACCESS-PATH &REST SERVICE-ARGS)
  (SETF (SERVICE-ACCESS-PATH-STREAM SERVICE-ACCESS-PATH) ':FUTURE)
  (LET ((VALUES '(T)))
    (CATCH 'FUTURE-STARTED
      (SETQ VALUES (CONS 'NIL
			 (MULTIPLE-VALUE-LIST
			   (INVOKE-SERVICE-ACCESS-PATH SERVICE-ACCESS-PATH
						       (COPYLIST SERVICE-ARGS))))))
    (VALUES-LIST VALUES)))

(DEFUN SERVICE-ACCESS-PATH-FUTURE-CONNECTED-P (SERVICE-ACCESS-PATH)
  (NOT (SEND (SERVICE-ACCESS-PATH-STREAM SERVICE-ACCESS-PATH) ':CONNECTION-PENDING-P)))

(DEFUN ABORT-SERVICE-ACCESS-PATH-FUTURE (SERVICE-ACCESS-PATH)
  (SEND (SERVICE-ACCESS-PATH-STREAM SERVICE-ACCESS-PATH) ':CLOSE ':ABORT))

(DEFUN SERVICE-ACCESS-PATH-FUTURE-NUMBER-OF-OUTSTANDING-ALLOWED (SERVICE-ACCESS-PATH)
  (SEND (SERVICE-ACCESS-PATH-STREAM SERVICE-ACCESS-PATH) ':NUMBER-OF-OUTSTANDING-CONNECTIONS))

(DEFUN CONTINUE-SERVICE-ACCESS-PATH-FUTURE (SERVICE-ACCESS-PATH)
  (INVOKE-SERVICE-ACCESS-PATH SERVICE-ACCESS-PATH
			      (SERVICE-ACCESS-PATH-ARGS SERVICE-ACCESS-PATH)))

(DEFUN GET-CONNECTION-FOR-SERVICE-TO-HOST (SERVICE-ACCESS-PATH NETWORK
					   IMPLEMENTATION CONNECTION-ARGS)
  (PROG1
    (LET ((STREAM (SERVICE-ACCESS-PATH-STREAM SERVICE-ACCESS-PATH)))
      (COND ((NULL STREAM)
	     ;; Get ordinary connection
	     (LEXPR-FUNCALL (MEDIUM-IMPLEMENTATION-FUNCTION IMPLEMENTATION)
			    SERVICE-ACCESS-PATH CONNECTION-ARGS))
	    ((EQ STREAM ':FUTURE)
	     ;; Future request
	     (SETF (SERVICE-ACCESS-PATH-STREAM SERVICE-ACCESS-PATH)
		   (LEXPR-FUNCALL (MEDIUM-IMPLEMENTATION-FUNCTION IMPLEMENTATION)
				  SERVICE-ACCESS-PATH ':FUTURE-P T
				  CONNECTION-ARGS))
	     (THROW 'FUTURE-STARTED T))
	    (T
	     ;; Future continuation
	     (LET ((NORMAL-EXIT NIL))
	       (UNWIND-PROTECT
		 (PROGN
		   (SEND STREAM ':CHECK-CONNECTION-STATE)
		   (SETQ NORMAL-EXIT T))
		 (UNLESS NORMAL-EXIT
		   (SEND STREAM ':CLOSE ':ABORT))))
	     STREAM)))
    (LET ((HOST (SERVICE-ACCESS-PATH-HOST SERVICE-ACCESS-PATH)))
      (UNLESS (SYMBOLP HOST)
	(SEND HOST ':SET-AVAILABLE ':SERVER T ':NETWORK NETWORK)))))

(DEFVAR *PARALLELISM-IN-NETWORK* 1)		;for now

;;; Useful macro for dealing with multiple paths to a service at once.
;;; SERVICES is a list of services to use (e.g. (FIND-PATHS-TO-SERVICE ':TIME)).
;;; TIMEOUT is the maximum time a host can take to respond.
;;; HOST-VARIABLE will be bound to the host it is talking to.
;;; OTHER-VARIABLES and CLAUSES are as for CONDITION-CASE.
(DEFMACRO INVOKE-MULTIPLE-SERVICES ((SERVICES TIMEOUT &OPTIONAL WHOSTATE SERVICE-VARIABLE)
				    (HOST-VARIABLE &REST OTHER-VARIABLES)
				    &BODY CLAUSES)
  (LET ((OTHER-TEMPORARIES (LOOP REPEAT (LENGTH OTHER-VARIABLES)
				 COLLECT (GENSYM))))
    `(FLET
       ((.INVOKE-MULTIPLE-SERVICES-INTERNAL. (SERVICES)
	  (LET ((.SERVICES. SERVICES)
		(.TIMEOUT. ,TIMEOUT)
		(.WHOSTATE. ,(OR WHOSTATE "Service Wait"))
		(.OUTSTANDING-FUTURES. NIL)
		(.TIMEOUTS. NIL)
		(.NUMBER-OF-OUTSTANDING-FUTURES. 0)
		(.NUMBER-OF-OUTSTANDING-FUTURES-ALLOWED. 1))
	    (UNWIND-PROTECT
		(LOOP DOING
		  (LOOP WITH .PREV-OUT. = (LOCF .OUTSTANDING-FUTURES.)
			FOR .OUTSTANDING. ON .OUTSTANDING-FUTURES.
			AS .SERVICE. = (FIRST .OUTSTANDING.)
			WITH .PREV-TIME. = (LOCF .TIMEOUTS.)
			FOR .TIMES. ON .TIMEOUTS.
			AS .TIMEOUT. = (FIRST .TIMES.)
			WHEN (OR (SERVICE-ACCESS-PATH-FUTURE-CONNECTED-P .SERVICE.)
				 (TIME-LESSP .TIMEOUT. (TIME)))
			  DO (LET (,@(AND SERVICE-VARIABLE `((,SERVICE-VARIABLE .SERVICE.)))
				   (,HOST-VARIABLE (SERVICE-ACCESS-PATH-HOST .SERVICE.)))
			       (CONDITION-CASE ,OTHER-VARIABLES
				    (CONTINUE-SERVICE-ACCESS-PATH-FUTURE .SERVICE.)
				  . ,CLAUSES))
			     (RPLACD .PREV-OUT. (CDR .OUTSTANDING.))
			     (RPLACD .PREV-TIME. (CDR .TIMES.))
			     (DECF .NUMBER-OF-OUTSTANDING-FUTURES.)
			ELSE DO (SETQ .PREV-OUT. .OUTSTANDING. .PREV-TIME. .TIMES.))
		  (LOOP WHILE (< .NUMBER-OF-OUTSTANDING-FUTURES.
				 .NUMBER-OF-OUTSTANDING-FUTURES-ALLOWED.)
			AS .SERVICE. = (POP .SERVICES.)
			WHILE .SERVICE.
			DO (PROG FUTURE-STARTED (,@(AND SERVICE-VARIABLE
							`((,SERVICE-VARIABLE .SERVICE.)))
						 (,HOST-VARIABLE
						  (SERVICE-ACCESS-PATH-HOST .SERVICE.)))
				 (CONDITION-CASE ,OTHER-VARIABLES
				      (MULTIPLE-VALUE-BIND (FUTURE-P . ,OTHER-TEMPORARIES)
					  (LEXPR-FUNCALL #'START-SERVICE-ACCESS-PATH-FUTURE .SERVICE.
							 (SERVICE-ACCESS-PATH-ARGS .SERVICE.))
					(IF (NOT FUTURE-P)
					    ;; Not a future, invoke now
					    (VALUES . ,OTHER-TEMPORARIES)
					    (PUSH .SERVICE. .OUTSTANDING-FUTURES.)
					    (PUSH (TIME-INCREMENT (TIME) .TIMEOUT.)
						  .TIMEOUTS.)
					    (INCF .NUMBER-OF-OUTSTANDING-FUTURES.)
					    (SETQ .NUMBER-OF-OUTSTANDING-FUTURES-ALLOWED.
						  (SERVICE-ACCESS-PATH-FUTURE-NUMBER-OF-OUTSTANDING-ALLOWED
						    .SERVICE.))
					    (RETURN-FROM FUTURE-STARTED T)))	;A future, skip invocation
				    . ,CLAUSES)))
		  (UNLESS (OR .SERVICES. .OUTSTANDING-FUTURES.)
		    (RETURN NIL)) 
		  (PROCESS-WAIT .WHOSTATE.
		    #'(LAMBDA (OUTSTANDING TIMEOUTS)
			(LOOP FOR SERVICE IN OUTSTANDING
			      FOR TIMEOUT IN TIMEOUTS
			      THEREIS (OR (SERVICE-ACCESS-PATH-FUTURE-CONNECTED-P
					    SERVICE)
					  (TIME-LESSP TIMEOUT (TIME)))))
		    .OUTSTANDING-FUTURES. .TIMEOUTS.))
	      (LOOP FOR SERVICE IN .OUTSTANDING-FUTURES.
		    DO (ABORT-SERVICE-ACCESS-PATH-FUTURE SERVICE))))))
       (LET ((SERVICES ,SERVICES)
	     (SIMULTANEOUS *PARALLELISM-IN-NETWORK*))
	 (IF (> SIMULTANEOUS 1)
	     (LET ((LOCK (PROCESS:MAKE-LOCK ,(STRING-APPEND (OR WHOSTATE "Multiple Services")
							    " Lock")))
		   (RUNNING-COUNT SIMULTANEOUS)
		   (PROCESSES NIL))
	       (UNWIND-PROTECT
		   (LET ((SKIP #'(LAMBDA (LIST) (NTHCDR SIMULTANEOUS LIST))))
		     (LOOP FOR I BELOW SIMULTANEOUS DO
		       (LET ((PROC
			       (PROCESS-RUN-FUNCTION
				 (FORMAT NIL "~A ~D" ,(OR WHOSTATE "Multiple Services") I)
				 #'(LAMBDA (SERVICES)
				     (UNWIND-PROTECT
					 (.INVOKE-MULTIPLE-SERVICES-INTERNAL. SERVICES)
				       (PROCESS:WITH-LOCK (LOCK)
					 (DECF RUNNING-COUNT)
					 (SETF PROCESSES (DELETE *CURRENT-PROCESS* PROCESSES)))))
				 (LOOP FOR SERVICE IN (NTHCDR I SERVICES) BY SKIP
				       COLLECT SERVICE))))
			 (PROCESS:WITH-LOCK (LOCK)
			   (PUSH PROC PROCESSES))))
		     (PROCESS-WAIT
			 (FORMAT NIL "Wait for ~A" ,(OR WHOSTATE "Multiple Services"))
		       #'(LAMBDA ()
			   (OR (NULL PROCESSES)
			       (NOT (PLUSP RUNNING-COUNT))))))
		 (LOOP FOR P IN PROCESSES DO
		   (PROCESS:PROCESS-KILL P T))))
	     (.INVOKE-MULTIPLE-SERVICES-INTERNAL. SERVICES))))))

;;;; Actual media

(DEFINE-MEDIUM :BYTE-STREAM ())

(DEFINE-MEDIUM :DATAGRAM ())

(DEFINE-MEDIUM :LOCAL ()
  ((:LOCAL T)))

;;; Useful for medium implementation code.
(DEFUN DECODE-SERVICE-ACCESS-PATH-FOR-MEDIUM (PATH &OPTIONAL GATEWAY-MEDIUM-DESCRIPTION)
  (DECLARE (VALUES HOST NETWORK ADDRESSES))
  (LET ((HOST (SERVICE-ACCESS-PATH-HOST PATH))
	(NETWORK
	  (LOOP WITH DESCRIPTION = (SERVICE-ACCESS-PATH-MEDIUM PATH)
		FOR IMPLEMENTATION = (MEDIUM-DESCRIPTION-IMPLEMENTATION DESCRIPTION)
		FOR THIS-PATH = (MEDIUM-IMPLEMENTATION-PATH IMPLEMENTATION)
		DO (SELECTQ (FIRST (FIRST THIS-PATH))
			    (:NETWORK
			      (RETURN (FIRST (MEDIUM-DESCRIPTION-PARAMETERS DESCRIPTION))))
			    (:SERVICE
			      (SETQ DESCRIPTION (OR GATEWAY-MEDIUM-DESCRIPTION
						    (SERVICE-ACCESS-PATH-MEDIUM
						      (FIRST
							(FIRST
							  (FIRST
							    (MEDIUM-DESCRIPTION-PARAMETERS
							      DESCRIPTION)))))))
			      (SETQ GATEWAY-MEDIUM-DESCRIPTION NIL))
			    (:MEDIUM
			      (SETQ DESCRIPTION
				    (FIRST (MEDIUM-DESCRIPTION-PARAMETERS DESCRIPTION))))
			    (OTHERWISE (FERROR "Unknown service path type ~S." THIS-PATH))))))
    (VALUES
      HOST (CANONICAL-NETWORK NETWORK)
      (IF (EQ HOST :BROADCAST)
	  (MULTIPLE-VALUE-BIND (IGNORE IGNORE IGNORE BROADCAST-ADDRESS)
	      (SEND (CANONICAL-NETWORK NETWORK) :ADDRESS-RESOLUTION-PARAMETERS)
	    (LIST BROADCAST-ADDRESS))
	  (LOOP FOR (NET ADDR) IN (SEND HOST ':NETWORK-ADDRESSES)
		WHEN (EQ NETWORK NET)
		  COLLECT ADDR)))))

;;; Encache possible gateway services
(DEFUN GET-LOCAL-GATEWAYS ()
  (DOLIST (MEDIUM *MEDIUM-LIST*)
    (DOLIST (IMPLEMENTATION (MEDIUM-IMPLEMENTATIONS MEDIUM))
      (LET ((PATH (MEDIUM-IMPLEMENTATION-PATH IMPLEMENTATION)))
	(WHEN (EQ (CAAR PATH) ':SERVICE)
	  (NETI:HOSTS-SUPPORTING-SERVICE (CADAR PATH)))))))

(ADD-INITIALIZATION "Local gateways" '(GET-LOCAL-GATEWAYS) NIL 'COMMONLY-USED-PROPERTY-LISTS)
