;;; -*- Syntax: Zetalisp; Mode: LISP; Package: CHAOS; Base: 8; Lowercase: Yes -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

  ;;
;;;;;;  Interface to network interfaces
  ;;

(defmethod (:receive-packet chaos-network) (packet interface interface-chaos-address)
  (let ((chaos-packet (packet-chaos-packet packet)))
    (neti:with-network-packet (chaos-packet)
      (when *record-debugging-info* (record-pkt-header chaos-packet ':in))
      (cond ((null *enable*) (neti:deallocate-packet-buffer packet))
	    ((and (zerop (pkt-mbz chaos-packet))
		  ( (pkt-nbytes chaos-packet) max-data-bytes-per-pkt))
	     (when interface
	       (let ((subnet (ldb (byte 10 10) interface-chaos-address)))
		 (aset interface *routing-table* subnet)
		 (aset (send interface ':chaos-routing-cost) *routing-table-cost* subnet)))
	     (or (pkt-string chaos-packet)
		 (setf (pkt-string chaos-packet)
		       (chaos-packet-string chaos-packet)))
	     (alter-pkt-leader chaos-packet
			       pkt-time-transmitted 0
			       pkt-times-transmitted 0
			       pkt-link t)	;not on a user list
	     (mark-chaos-packet-allocated chaos-packet)
	     (incf *pkts-in*)
	     (cond
D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")	       ;; Simple case:  This packet is addressed to this interface or it is a
0	       1;; broadcast and0 1we are not a bridge.
0	       ((or (= (pkt-dest-address chaos-packet) interface-chaos-address)
			(and (not *forward-packets*)
			     (= (pkt-dest-address chaos-packet) 0)))
		 (receive-chaos-packet chaos-packet))
	       1;; We are not a bridge so throw anything else away
0	       ((not *forward-packets*)
		 (return-pkt chaos-packet))
	       1;; Everything beyond here assume we are a gateway.
0	       1;; Throw out over-forwarded packets
0	       (( (let ((fwd (1+ (pkt-fwd-count chaos-packet))))
			 (setf (pkt-fwd-count chaos-packet) fwd)
			 fwd)
		       16.)
		(incf *pkts-over-forwarded*)
		(return-pkt chaos-packet))
	       1;; Sort out broadcasts
0	       ((= (pkt-dest-address chaos-packet) 0)
		 (if ( (pkt-opcode chaos-packet) brd-op)
		     1;; Receive it if it is not a BRD packet that we don't have to forward 
0		     (receive-chaos-packet chaos-packet)
		     1;; Otherwise, send it out on all interfaces that it hasn't been sent
0		     1;; out on.
0		     (let ((interfaces-to-xmit-to nil)
			   (pkt-array (pkt-8b-array chaos-packet)))
		       (loop for interface in neti:*interfaces*
			     as protocol-address = (send interface :protocol-address self)
			     when (and protocol-address
				       (send interface :enabled))
			       do 
				 (let ((subnet (ldb (byte 8 8) protocol-address)))
				   1;; When a packet hasn't been sent to this subnet, set the
				   ;; flag to 0 and remember the interface
0				   (when (not (zerop (logand (aref pkt-array
								   (truncate subnet 8.))
							     (lsh 1 (remainder subnet 8.)))))
				     (push interface interfaces-to-xmit-to)
				     (setf (aref pkt-array (truncate subnet 8.))
					   (logand (aref pkt-array (truncate subnet 8.))
						   (lognot (lsh 1 (remainder subnet 8.))))))))
		       (when interfaces-to-xmit-to
			 (loop for interface in interfaces-to-xmit-to
				do
				  (incf (pkt-times-transmitted chaos-packet))
				  (incf *brd-pkts-out*)
				  (transmit-pkt-1 chaos-packet interface 0 nil)))
			 1;;Receive it for ourselves
0			 (receive-chaos-packet chaos-packet))))
		   (t				1;Otherwise, just forward it
0		    (incf *pkts-forwarded*)
		    (transmit-pkt chaos-packet nil))))
	    (t					1;Can't figure it out, punt.
0	     (neti:deallocate-packet-buffer packet)
	     (incf *pkts-in-bad-format*))))))

(defmethod (:enable chaos-network) ()
  (setq *local-chaosnet* self)
  (clear-routing-table)				;don't get confused by old addresses
  (neti:find-network-interfaces self)		;add self to interfaces
  (add-interfaces-to-routing-table)		;update routing table
  (process:process-enable *background*)
  (setq *enable* t))

(defmethod (:disable chaos-network) ()
  (setq *enable* nil)
  (process:process-disable *background*))

(defmethod (:reset chaos-network) ()
  (send self ':disable)
  (process:reset *background*)
  ;; Don't remove the conns.  Users still have pointers to them
  (dolist (conn (copylist *conn-list*))
    (setf (state conn) 'closed-state)
    (let ((stream (conn-user-stream conn)))
      (when stream
	(send stream :close :abort)))
    (free-all-read-pkts conn)
    (free-all-received-pkts conn)
    (free-all-send-pkts conn))
  (setq *conn-list* nil)
  ;; It doesn't matter how 'expensive' this is, it is *right*.
  (page-in-area neti:ether-buffer-area :hang-p nil)
  (map-chaos-packets #'(lambda (pkt)
			 (when (pkt-allocated pkt)
			   (mark-chaos-packet-returned pkt))))
  (si:fill-array *conn-table* nil nil)
  
  ;;;++ uniquizer table??
  
  (setq *pending-listens* nil)
  (free-pkt-list *pending-rfc-pkts*)
  (setq *pending-rfc-pkts* nil)
  (setq *brd-history* nil)

  (setq *address-demerits* nil))

(defmethod (:enabled chaos-network) () *enable*)

(defun assure-enabled ()
  (loop until *enable*
	do (process-wait "Await Chaosnet enabled"
	       #'(lambda () *enable*))))

(defmethod (:packet-buffer-panic chaos-network) ()
  (dolist (conn *conn-list*)
    (free-all-received-pkts conn)))

(defun init-routing-table ()
  (clear-routing-table)
  (add-interfaces-to-routing-table))

(defun clear-routing-table ()
  (setf my-address nil)
  (setf my-subnet nil)
  (si:fill-array *routing-table*      nil 0)
  (si:fill-array *routing-table-cost* nil maximum-routing-cost))

(defun add-interfaces-to-routing-table ()
  (let ((interface-count 0))
    (dolist (interface neti:*interfaces*)
      (let ((my-chaos-address (send interface :protocol-address *local-chaosnet*)))
	(when (not (null my-chaos-address))
	  (incf interface-count)
	  (let ((this-subnet (ldb (byte 8. 8.) my-chaos-address)))
	    (when (null my-address)
	      (setf my-address my-chaos-address)
	      (setf my-subnet this-subnet))
	    (setf (aref *routing-table* this-subnet) interface)
	    (setf (aref *routing-table-cost* this-subnet) (// maximum-routing-cost 2))))))
    (setq *forward-packets* (> interface-count 1))))


  ;;
;;;;;;  Interface to generic packet system
  ;;

;;; Given a (sub)packet whose first byte is the first byte of a chaosnet
;;; packet, actually return a chaos packet.
(defun packet-chaos-packet (packet)
  (neti:get-sub-packet packet 'art-16b 0 pkt-leader-size 'pkt))

;;; Given a chaos packet, get the data portion as a string
(defun chaos-packet-string (chaos-packet)
  (let ((string (neti:get-sub-packet chaos-packet 'art-string first-data-byte-in-pkt)))
    (setf (fill-pointer string) (pkt-nbytes chaos-packet))
    string))

;;; Given a chaos packet, gets an offset array that is word aligned for array registers
(defsubst chaos-packet-data-aligned (chaos-packet array-type)
  (neti:get-sub-packet chaos-packet array-type (- first-data-byte-in-pkt 2)))

(defun pkt-8b-array (pkt)
  (let ((string (neti:get-sub-packet pkt 'art-8b first-data-byte-in-pkt)))
    (setf (fill-pointer string) (pkt-nbytes pkt))
    string))

(defun map-chaos-packets (function &rest other-function-args)
  (declare (sys:downward-funarg function))
  (neti:map-sub-packets
    #'(lambda (sub-packet named-structure-symbol function other-function-args)
	(when (eq named-structure-symbol 'pkt)
	  (lexpr-funcall function sub-packet other-function-args)))
    function
    other-function-args))



  ;;
;;;;;; Interface to the generic SERVER system
  ;;

(defun (:chaos define-server) (options)
  (let ((argument-list nil)
	(argument-descriptions nil)
	(property-list nil))
    (loop for (indicator value) on options by 'cddr
	  do (selectq indicator
	       (:window-size
		(putprop (locf property-list) value indicator))
	       (:conn
		(push value argument-list)
		(push ':conn argument-descriptions))))
    (values (nreverse argument-list) (nreverse argument-descriptions)
	    property-list '(:conn :window-size))))


  ;;
;;;;;;  Chaos packet allocation and freeing
  ;;

(deff allocate-pkt 'get-pkt)
(defun get-pkt (&optional (wait-p t) &aux packet pkt)
  (when (setq packet (neti:allocate-packet-buffer wait-p))
    (setq pkt (packet-chaos-packet packet))
    (or (pkt-string pkt)
	(setf (pkt-string pkt) (chaos-packet-string pkt)))
    (neti:with-network-packet (pkt)
      (setf (fill-pointer (pkt-string pkt)) 0)
      (alter-pkt pkt
		 pkt-opcode-left-justified 0
		 pkt-opcode 0
		 pkt-nbytes 0)			;not on a user list
      (alter-pkt-leader pkt
			pkt-time-transmitted 0
			pkt-times-transmitted 0
			pkt-link t)
      (mark-chaos-packet-allocated  pkt))
    pkt))
  
(deff free-pkt 'return-pkt)
(defun return-pkt (pkt)
  (when pkt
    (without-interrupts
      (mark-chaos-packet-returned pkt)
      (neti:deallocate-packet-buffer pkt))))

(defun mark-chaos-packet-allocated (pkt)
  (without-interrupts
    (incf *pkts-given-out*)
    (setf (pkt-allocated pkt) t)))

(defun mark-chaos-packet-returned (pkt)
  (when pkt
    (without-interrupts
      (incf *pkts-given-back*)
      (setf (pkt-allocated pkt) nil))))

(defun copy-pkt (pkt
		 &optional (wait-p t) (new-pkt (get-pkt wait-p))
		 &aux (nw (pkt-nwords pkt)))
  (copy-array-portion pkt 0 nw new-pkt 0 nw)
  (setf (fill-pointer (pkt-string new-pkt)) (pkt-nbytes pkt))
  new-pkt)


  ;;
;;;;;;  Connection allocation and freeing.
  ;;

;;; the cons idea was in the original code and attempts to save a cons!!
(defun make-connection (&optional conn &aux cons)
  (without-interrupts
    (cond (conn)				;caller supplying conn to be recycled
	  ((setq cons *free-conn-list*)		;recycle one
	   (setq *free-conn-list* (cdr cons)
		 conn (car cons))
	   (copy-array-contents *prototype-conn* conn))
	  (t (setq conn (make-conn))
	     (incf *conns-made*))))
  (cond ((neq (state conn) 'inactive-state)
	 (ferror "Attempt to reuse ~S, which is in the ~A, not INACTIVE-STATE"
		 conn (state conn)))
	((memq conn *free-conn-list*)
	 (ferror "You can't reuse this connection, it's been freed"))
	((memq conn *conn-list*)
	 (ferror "You can't reuse this connection, it's already in use"))
	(t
	 (alter-conn conn
		     foreign-window-size 0
		     offered-foreign-window-size 0
		     local-address my-address)
	 (do ((index *conn-table-free-pointer*)
	      (counter maximum-index (1- counter)))
	     ((minusp counter)
	      (error 'connection-table-full))
	   (setq index (\ (1+ index) maximum-index))
	   (if (zerop index) (setq index 1))
	   (without-interrupts
	     (when (null (aref *conn-table* index))
	       (setf (aref *conn-table* index) conn)
	       (setq *conn-table-free-pointer* index)
	       (setf (local-index-num conn) (dpb (incf (aref *uniquizer-table* index))
						 conn-index-high-bits
						 index))
	       (setq *conn-list* (rplacd (or cons (ncons conn)) *conn-list*))
	       (incf *conns-released*)
	       (return conn)))))))

;;; Given a connection, makes it null and void.
(defun remove-conn (conn)
  (process:with-no-other-processes
    (setf (state conn) 'inactive-state)
    (free-all-read-pkts conn)
    (free-all-received-pkts conn)
    (free-all-send-pkts conn)
    (let ((index (ldb conn-index-low-bits (local-index-num conn))))
      (if (eq (aref *conn-table* index) conn)
	  (setf (aref *conn-table* index) nil)))
    (setf (conn-user-stream conn) nil)
    (setf (conn-owning-process conn) nil)
    #+flush
    (setq distinguished-port-conn-table
	  (delq (rassq conn distinguished-port-conn-table) distinguished-port-conn-table))
    (let ((cons (memq conn *conn-list*)))
      (setq *conn-list* (delq conn *conn-list*))
      (or (memq conn *free-conn-list*)
	  (setq *free-conn-list* (rplacd (or cons (ncons conn)) *free-conn-list*))))
    (incf *conns-returned*)
    (setq *pending-listens* (delq conn *pending-listens*))
    nil))

;;; what used to be called CLOSE (++ BTW, it would be nice if remove-conn
;;; and close-conn could be made the same.)
(defun close-conn (conn &optional (reason "") remove &aux pkt)
  (unwind-protect
    (selectq (state conn)
      ((open-state rfc-received-state)
       (setq pkt (get-pkt))
       (setf (pkt-opcode pkt) cls-op)
       (set-pkt-string pkt reason)
       (send-reply-for-conn conn pkt)
       (setf (state conn) 'closed-state))
      ((cls-received-state answered-state los-received-state host-down-state
			   listening-state rfc-sent-state brd-sent-state closed-state
			   brd-received-state)
       (setf (state conn) 'closed-state))
      (otherwise
       (bad-chaos-connection-state conn "close")))
    (without-interrupts
      (free-all-received-pkts conn)
      (free-all-send-pkts conn))
    (if remove (remove-conn conn)))
  nil						;Often ends up back at user, something less
  )						;scary than CHAOS:CLOSED-STATE.

;;;++ compatibility kludge

;;; --->> NOTE WELL <<--- The documentation below is from the original
;;; implementation.  Currently, QFILE is the only function that is known to
;;; use INTERRUPT-CONN, and its interrupt function only looks at :INPUT.
;;; There are plans afoot to support only :INPUT, since all others are not
;;; currently used and it is unclear what, if anything, is the right thing.

;Causes the CONN's INTERRUPT-FUNCTION to be run in the background process with the
; specified reason and arguments
; Reasons are:
;	:INPUT			input has arrived
;	:OUTPUT			the window, which was full, now has room in it
;	:CHANGE-OF-STATE	the state of the connection has just changed
(defun interrupt-conn (reason conn &rest args &aux (ifun (interrupt-function conn)))
  (let ((waiter (conn-owning-process conn)))
    (when waiter
      (process:process-wakeup waiter)))
  (when ifun
    (process-run-function "Chaos Interrupt Function"
      #'interrupt-conn-internal
      ifun reason
      conn (local-index-num conn)
      (copylist args))))

;If while the request was on the queue, the connection was flushed, get rid
;of the interrupt.  Because of connection reusing, this is somewhat heuristic.
(defun interrupt-conn-internal (ifun reason conn local-index args)
  (or (eq (state conn) 'inactive-state)
      ( (local-index-num conn) local-index)
      (neq (interrupt-function conn) ifun)
      (lexpr-funcall ifun reason conn args)))


  ;;
;;;;;;  Simple packet management.
  ;;

;;; this will probably lose big if the total length of the strings exceeds a
;;; packet-buffer (about 1900. bytes).  There is provision for overflowing
;;; the chaos packet maximum (488.)

(defun set-pkt-string (pkt string &rest other-strings &aux (pkt-string (pkt-string pkt)))
  (setf (fill-pointer pkt-string) 0)
  (lexpr-funcall #'string-nconc pkt-string string other-strings)
  (let ((len (fill-pointer pkt-string)))
    (when (> len max-data-bytes-per-pkt)
      (setq len max-data-bytes-per-pkt)
      (incf *pkt-strings-truncated*))
    (setf (pkt-nbytes pkt) len)))


  ;;
;;;;;;  Simple connection/packet interactions.
  ;;

;;; Free a list of packets linked through pkt-link.  This function should be
;;; called with interrupts off, since an abort would cause a failure to free
;;; all the packets.  Before interrupts are turned back on, all previous
;;; pointers to the packets should have been nullified.  This routine is
;;; mainly used by the three functions that follow it.

(defun free-pkt-list (pkt-list)
  (loop for pkt = pkt-list then next-pkt
	while pkt
	as next-pkt = (pkt-link pkt)
	do (return-pkt pkt)))

;;; The following three routines free the various packet lists.  It is not
;;; necessary to call these without interrupts unless there is a timing
;;; window at a higher level.

(defun free-all-read-pkts (conn)
  (without-interrupts
    (free-pkt-list (prog1 (read-pkts conn)
			  (setf (read-pkts conn) nil)
			  (setf (read-pkts-last conn) nil)
			  (setf (read-pkts-length conn) 0)))))

(defun free-all-received-pkts (conn)
  (without-interrupts
    (free-pkt-list (prog1 (received-pkts conn)
			  (setf (received-pkts conn) nil)))))

(defun free-all-send-pkts (conn)
  (without-interrupts
    (free-pkt-list (prog1 (send-pkts conn)
			  (setf (send-pkts conn) nil)
			  (setf (send-pkts-last conn) nil)
			  (setf (send-pkts-length conn) 0)))))


  ;;
;;;;;;  Output packet routing.
  ;;

(defun transmit-pkt (pkt &optional (clear-fwd-count t))
  (neti:with-network-packet (pkt)
    (if clear-fwd-count (setf (pkt-fwd-count pkt) 0))
    (if (> (pkt-nbytes pkt) max-data-bytes-per-pkt)
	(ferror "Attempt to transmit an invalid packet (~S).~@
	       The length ~O is greater than the maximum packet size, ~O"
		pkt (pkt-nbytes pkt) max-data-bytes-per-pkt))
    (setf (pkt-time-transmitted pkt) (time))
    (incf (pkt-times-transmitted pkt))
    (let* ((host (pkt-dest-address pkt))
	   (subnet (ldb (byte 10 10) host))
	   (free-it (eq (pkt-link pkt) t)))
      (multiple-value-bind (interface next-host interface-valid)
	  (route-destination-address host subnet)
	(if (or (not interface-valid)
		(and (zerop next-host)
		     (not (zerop host))		;might be routing a BRD
		     (not (zerop (pkt-fwd-count pkt)))))
	    (progn (incf *pkts-couldnt-transmit*)
		   (when free-it (return-pkt pkt)))
	    (transmit-pkt-1 pkt interface next-host free-it))))))

;;; The division between these two functions is so send-rut-packet works.

(defun transmit-pkt-1 (pkt interface next-host free-it)
  (if *record-debugging-info* (record-pkt-header pkt ':out))
  (incf *pkts-transmitted*)
  (when free-it
    (mark-chaos-packet-returned pkt))
  (send interface ':transmit-packet
	pkt free-it *local-chaosnet* next-host
	(+ (pkt-nbytes pkt) first-data-byte-in-pkt)))

(defun route-destination-address (host &optional (subnet (ldb (byte 10 10) host)))
  (declare (values interface immediate-destination interface-valid))
  ;; First iteration of this loop is with the given subnet number.
  ;; If we don't have a direct interface to that, the second iteration
  ;; is finding the interface that points towards the bridge we will forward through.
  ;; Never iterate more than twice (can happen if bogus routing packet is received).
  (loop repeat 2
	when ( subnet (array-length *routing-table*))
	  do (setq subnet 0)
	as interface = (aref *routing-table* subnet)
	until (not (fixp interface))
	do (setq host interface subnet (ldb (byte 10 10) host))
	;; interface an instance or an address of a bogus bridge (0 or unreachable)
	finally
	  (when (fixp interface)
	    ;; Try broadcasting on some subnet on which we have an interface
	    (setq interface (aref *routing-table* my-subnet)
		  host 0))
	  (return (values interface host (not (fixp interface))))))

  ;;
;;;;;;  Packet output utilities (to be called by the next set of routines).
;;;;;;  All of these functions are for effect.  They return NIL for value.
  ;;

;;; These could be macros or substs, and may be at some point.

(defun assign-pkt-num (conn pkt)
  (neti:with-network-packet (pkt)
    (without-interrupts
      (let ((pktn (1+ (pkt-num-sent conn))))
	(setf (pkt-num pkt) pktn)
	(setf (pkt-num-sent conn) pktn)
	nil))))

(defun set-pkt-ack-num-from-conn (conn pkt)
  (neti:with-network-packet (pkt)
    (without-interrupts
      (let ((ackn (pkt-num-read conn)))
	(setf (pkt-ack-num pkt) ackn)
	(setf (pkt-num-acked conn) ackn)
	(setf (auto-status-count conn) (local-window-size conn))
	nil))))

(defun set-pkt-indices-from-conn (conn pkt)
  (neti:with-network-packet (pkt)
    (setf (pkt-source-address   pkt) (local-address     conn))
    (setf (pkt-source-index-num pkt) (local-index-num   conn))
    (setf (pkt-dest-address     pkt) (foreign-address   conn))
    (setf (pkt-dest-index-num   pkt) (ldb 0020 (foreign-index-num conn)))
    nil))

(defun add-to-output-queue (conn pkt)
  (neti:with-network-packet (pkt)
    (setf (pkt-link pkt) nil)
    (process:without-preemption
      (cond ((send-pkts conn)
	     (setf (pkt-link (send-pkts-last conn)) pkt))
	    (T (setf (send-pkts conn) pkt)
	       (setf (last-retransmit-time conn) (time))))
      (setf (send-pkts-last conn) pkt)
      (incf (send-pkts-length conn))
      (decf (window-available conn))
      (setq *need-to-retransmit-possible* t)
      (reset-chaos-background-timer *chaos-retransmit-timer* *retransmit-interval*)
      ;;(process:process-wakeup *background*)
      nil)))


  ;;
;;;;;;  SEND-foo-FOR-CONN functions.  By the time you get here, you have
;;;;;;  committed to sending the packet.  All use level blocking has happened.
;;;;;;  These are also for effect.  Do not expect any reasonable values.
  ;;

(defun send-controlled-pkt-for-conn (conn pkt)
  (incf *controlled-pkts-out*)
  (set-pkt-indices-from-conn conn pkt)
  (without-interrupts
    (assign-pkt-num conn pkt)
    (add-to-output-queue conn pkt)
    (set-pkt-ack-num-from-conn conn pkt)
    (transmit-pkt pkt)))

(defun send-new-rfc-for-conn (conn pkt)		;called by a reception of a FWD
  (setf (pkt-opcode pkt) rfc-op)
  (alter-conn conn
	      send-pkts nil
	      send-pkts-last nil
	      window-available 1)
  (send-controlled-pkt-for-conn conn pkt))

(defun retransmit-pkt-for-conn (conn pkt)
  (incf *retransmitted-pkts*)
  (set-pkt-ack-num-from-conn conn pkt)
  (transmit-pkt pkt))

;;; [++ should go with retransmitter??]
(defun signal-retransmit-for-conn (conn)
  (incf *retransmissions-signalled*)
  (when (send-pkts conn)			;it's hard to retransmit non-existent packets
    (cond (*batch-sts-enabled*
	   (setf (needs-retransmission conn) t)
	   (setf *some-conn-needs-retransmission* t)
	   (process:process-wakeup *background*)
	   t)
	  (T (retransmit-for-conn conn)))))

(defun retransmit-for-conn (conn &aux (time (time)) (last-effective-retransmit-time time))
  (incf *retransmissions-actual*)
  (setf (needs-retransmission conn) nil)
  (without-interrupts				;just in case not already in scheduler
    (let ((time-threshold (time-difference time
					   (if *adaptive-retransmission-enabled*
					       (ash (round-trip-time conn)
						    *retransmit-delay-lsh*)
					     *minimum-packet-retransmit-interval*)))
	  (there-was-a-retransmission nil))
      (loop for pkt first (send-pkts conn) then (pkt-link pkt)
	    while pkt
	    as pkt-time-transmitted = (pkt-time-transmitted pkt)
	    do (cond ((time-lessp pkt-time-transmitted time-threshold)
		      (unless (neti:packet-being-transmitted pkt)
			(retransmit-pkt-for-conn conn pkt)
			(setq there-was-a-retransmission 't)
			(return)))
		     ((time-lessp pkt-time-transmitted last-effective-retransmit-time)
		      (setq last-effective-retransmit-time pkt-time-transmitted))))
      (setf (last-retransmit-time conn) last-effective-retransmit-time)
      (when there-was-a-retransmission
	(when *window-adjustment-enabled*
	  (setf (foreign-window-size conn)
		(max 1 (1- (foreign-window-size conn)))))
	(when *adaptive-retransmission-enabled*
	  (setf (round-trip-time conn)
		(min (+ (round-trip-time conn)
			(min (lsh (round-trip-time conn) -1)	;50%
			     (lsh 30. (- *round-trip-time-lsh*))))	;.5 seconds
		     (lsh *max-round-trip-time* (- *round-trip-time-lsh*)))))))))

(comment
  "old version"
  defun retransmit-for-conn (conn &aux (time (time)) (last-effective-retransmit-time time))
  (incf *retransmissions-actual*)
  (setf (needs-retransmission conn) nil)
  (without-interrupts				;just in case not already in scheduler
    (let ((time-threshold (time-difference time
					   (if *adaptive-retransmission-enabled*
					       (ash (round-trip-time conn)
						    *retransmit-delay-lsh*)
					     *minimum-packet-retransmit-interval*)))
	  (there-was-a-retransmission nil))
      (prog (pkt-head pkt pkt-time-transmitted)
	 from-the-front
	    (setq pkt-head (send-pkts conn))
	    (setq pkt pkt-head)
	 loop-repeat
	    (if (null pkt) (return))
	    (setq pkt-time-transmitted (pkt-time-transmitted pkt))
	    (cond ((time-lessp pkt-time-transmitted time-threshold)
		   (unless (neti:packet-being-transmitted pkt)
		     (retransmit-pkt-for-conn conn pkt)
		     (setq there-was-a-retransmission 't)
		     (when (neq pkt-head (send-pkts conn))
		       (go from-the-front))))	;chain was invalidated, must start over
		  ((time-lessp pkt-time-transmitted last-effective-retransmit-time)
		   (setq last-effective-retransmit-time pkt-time-transmitted)))
	    (setq pkt (pkt-link pkt))
	    (go loop-repeat))
      (setf (last-retransmit-time conn) last-effective-retransmit-time)
      (when there-was-a-retransmission
	(when *window-adjustment-enabled*
	  (setf (foreign-window-size conn)
		(max 1 (1- (foreign-window-size conn)))))
	(when *adaptive-retransmission-enabled*
	  (setf (round-trip-time conn)
		(min (+ (round-trip-time conn)
			(min (lsh (round-trip-time conn) -1)	;50%
			     (lsh 30. (- *round-trip-time-lsh*))))	;.5 seconds
		     (lsh *max-round-trip-time* (- *round-trip-time-lsh*)))))))))

(defun signal-send-sts-for-conn (conn pkt reason)
  (incf *sts-pkts-signalled*)
  (cond (*batch-sts-enabled*
	 (return-pkt pkt)
	 (when *record-debugging-info* (update-sts-why-array reason))
	 (setf (needs-sts conn) t)
	 (setq *some-conn-needs-sts* t)
	 (process:process-wakeup *background*)
	 t)
	(T (send-sts-for-conn conn pkt reason))))

(defun send-sts-for-conn (conn pkt reason)
  (when pkt
    (neti:with-network-packet (pkt)
      (incf *sts-pkts-actual*)
      (setf (pkt-link pkt) t)
      (when *record-debugging-info* (update-sts-why-array reason))
      (setf (needs-sts conn) nil)
      (setf (pkt-opcode pkt) sts-op)
      (setf (pkt-first-data-word pkt)  (pkt-num-received conn))
      (setf (pkt-second-data-word pkt) (local-window-size conn))
      (setf (pkt-nbytes pkt) 4)
      (setf (pkt-num pkt) 0)
      (set-pkt-indices-from-conn conn pkt)
      (set-pkt-ack-num-from-conn conn pkt)
      (transmit-pkt pkt))))

(defun send-sns-for-conn (conn pkt)
  (when pkt
    (neti:with-network-packet (pkt)
      (incf *sns-pkts-out*)
      (setf (pkt-link pkt) t)
      (setf (pkt-opcode pkt) sns-op)
      (setf (pkt-nbytes pkt) 0)
      (setf (pkt-num pkt) 0)
      (set-pkt-indices-from-conn conn pkt)
      (set-pkt-ack-num-from-conn conn pkt)
      (transmit-pkt pkt))))

;;; assumes pkt-num and ack-num are already set, if they have any meaning
(defun send-unc-for-conn (conn pkt)
  (neti:with-network-packet (pkt)
    (incf *unc-pkts-out*)
    (setf (pkt-link pkt) t)
    (setf (pkt-opcode pkt) unc-op)
    (set-pkt-indices-from-conn conn pkt)
    (transmit-pkt pkt)))

;;; assumes pkt-num and ack-num are already set, if they have any meaning
(defun send-reply-for-conn (conn pkt)
  (neti:with-network-packet (pkt)
    (incf *reply-pkts-out*)
    (setf (pkt-link pkt) t)
    (set-pkt-indices-from-conn conn pkt)
    (transmit-pkt pkt)))

(defun send-los-pkt (pkt op reason)
  (incf *los-pkts-out*)
  (send-reply-pkt pkt op reason))

(defun send-reply-pkt (pkt op reason &optional (ack-num 0))
  (neti:with-network-packet (pkt)
    (setf (pkt-link pkt) t)
    (setf (pkt-opcode pkt) op)
    (set-pkt-string pkt reason)
    (swapf (pkt-source-address   pkt) (pkt-dest-address   pkt))
    (swapf (pkt-source-index-num pkt) (pkt-dest-index-num pkt))
    (setf (pkt-ack-num pkt) ack-num)
    (transmit-pkt pkt)))

(defun send-reply-to-rfc (rfc reply op &optional (ack-num 0))
  (neti:with-network-packet (reply)
    (setf (pkt-link reply) t)
    (setf (pkt-opcode reply) op)
    (setf (pkt-dest-address     reply) (pkt-source-address   rfc))
    (setf (pkt-dest-index-num   reply) (pkt-source-index-num rfc))
    (setf (pkt-source-address   reply) (pkt-dest-address	   rfc))
    (setf (pkt-source-index-num reply) (pkt-dest-index-num   rfc))
    (setf (pkt-ack-num reply) ack-num)
    (return-pkt rfc)
    (transmit-pkt reply)))


  ;;
;;;;;;  Input utility routines.  These are for side effects; values are undefined.
  ;;

(defsubst update-round-trip-time (conn time)
  (when *adaptive-retransmission-enabled*
    (setf (round-trip-time conn)
	  (+ (- (round-trip-time conn)
		(lsh (round-trip-time conn) *round-trip-time-lsh*))
	     (min-max 1 time 600.)))))

;;; ack-level is the pkt-ack-num of a packet, which implies receipt.  An
;;; explicit receipt (as from a STS or OPN packet) will override this.
;;; This also updates the available output window.
(defun process-ack (conn ack-level &optional (receipt-level ack-level))
  (without-interrupts
    (if (or (pktnum-< (pkt-num-sent conn) ack-level)
	    (pktnum-< (pkt-num-sent conn) receipt-level))
	(incf *pkts-in-ack-out-of-range*)
      (let ((pkt (send-pkts conn)))
	(when pkt				;avoid unnecessary work if no pkts
	  (if (pktnum-< receipt-level ack-level)	;just in case
	      (setq receipt-level ack-level))
	  (loop with length = (send-pkts-length conn)
		until (pktnum-< receipt-level (pkt-num pkt))
		as next = (pkt-link pkt)
		do (update-round-trip-time conn (time-difference (time)
								 (pkt-time-transmitted pkt)))
		   (return-pkt pkt)
		   (decf length)
		   (setq pkt next)
		while pkt
		finally (setf (send-pkts conn) pkt)
			(setf (send-pkts-length conn) length)
			(when (null pkt)
			  (setf (send-pkts-last conn) nil)
			  (when *window-adjustment-enabled*
			    (setf (foreign-window-size conn)
				  (min (+ (foreign-window-size conn) 2)	;[?? what's good?]
				       (offered-foreign-window-size conn))))))))
      (if (pktnum-< (send-pkt-acked conn) ack-level)
	  (setf (send-pkt-acked conn) ack-level))
      (update-window-available conn))))

(defun update-window-available (conn)
  (let* ((old-available (window-available conn))
	 (new-available (max old-available
			     (- (foreign-window-size conn)
				(pktnum-- (pkt-num-sent conn) (send-pkt-acked conn))))))
    (setf (window-available conn) new-available)
    (if (and (zerop old-available) (plusp new-available))
	(interrupt-conn ':output conn))))

;;; There are three ways to add packets to the input list:
;;;  1 queue-input-pkt puts the packet on the end of the input list.
;;;  2 queue-unordered-input-pkt puts the packet on the end of the input
;;; 	list as long as there is room (number on list < local window size). 
;;;  3 queue-ordered-input-pkt either discards the packet (because it was a
;;; 	duplicate), puts it on READ-PKTS if it is an in-order packet, or
;;; 	splices it onto RECEIVED-PKTS if it is within the window but otherwise
;;; 	out of order.
;;; All of these are for side effects only.  Their return value is undefined.

;;; NOTE WELL: These functions do not need to turn off interrupts, since the
;;; only allowed caller is the packet receiver, which runs in the scheduler.

(defun queue-input-pkt (conn pkt)
  (neti:with-network-packet (pkt)
    (setf (pkt-link pkt) nil)
    (if (read-pkts conn)
	(setf (pkt-link (read-pkts-last conn)) pkt)
	(setf (read-pkts conn) pkt)
	(interrupt-conn ':input conn))
    (setf (read-pkts-last conn) pkt)
    (incf (read-pkts-length conn)))
  nil)

(defun queue-unordered-input-pkt (conn pkt)
  (if (< (read-pkts-length conn) (local-window-size conn))
      (queue-input-pkt conn pkt)
    (return-pkt pkt)))

;;; If this routine is wrong, you'll know it soon
(defun queue-ordered-input-pkt (conn pkt)
  (neti:with-network-packet (pkt)
    (let ((conn conn))
      (declare (sys:array-register conn))
      (let* ((pkt-num (pkt-num pkt))
	     (expected (pktnum-1+ (pkt-num-received conn)))
	     (prev pkt))
	(cond ((= pkt-num expected)
	       (queue-input-pkt conn pkt)
	       (setq expected (pktnum-1+ expected))
	       (when (and (setq pkt (received-pkts conn))	;if there are unordered packets
			  (= (pkt-num pkt) expected))	;and the next one is in order
		 (setf (pkt-link prev) pkt)	;link two lists together
		 (loop do (incf (read-pkts-length conn))
			  (setq expected (pktnum-1+ expected))
			  (setq prev pkt)
			  (setq pkt (pkt-link prev))
		       while (and pkt (= (pkt-num pkt) expected))
		       finally (setf (pkt-link prev) nil)
			       (setf (read-pkts-last conn) prev)
			       (setf (received-pkts conn) pkt)))
	       (setf (pkt-num-received conn) (pktnum-- expected 1)))
	      ((pktnum-< pkt-num expected)
	       (incf *dat-pkts-duped-in-order*)
	       (signal-send-sts-for-conn conn pkt 'already-on-read-pkts))
	      (( (pktnum-- pkt-num (pkt-num-read conn)) (local-window-size conn))
	       (do ((prev nil received)
		    (received (received-pkts conn) (pkt-link received)))
		   ((null received)
		    (setf (pkt-link pkt) nil)
		    (cond (prev (setf (pkt-link prev) pkt))
			  (T    (setf (received-pkts conn) pkt))))
		 (let ((received-num (pkt-num received)))
		   (cond ((= pkt-num received-num)
			  (incf *dat-pkts-duped-out-order*)
			  (signal-send-sts-for-conn conn pkt 'alread-on-received-pkts)
			  (return))
			 ((pktnum-< pkt-num received-num)
			  (cond (prev (setf (pkt-link pkt)  (pkt-link prev))
				      (setf (pkt-link prev) pkt))
				(T (setf (pkt-link pkt) received)
				   (setf (received-pkts conn) pkt)))
			  (return))))))
	      (T (incf *dat-pkts-over-window*)
		 (signal-send-sts-for-conn conn pkt 'over-window))))))
  nil)

(defun classify-pkt-opcode (opcode)
  (cond ((or ( opcode dat-op) (= opcode eof-op)) 'dat)
	((< 0 opcode #.(length opcode-list))
	 ;(nth opcode opcode-list)
	 (aref #.(cl:coerce (cdr opcode-list) 'cl:vector)
	       (1- opcode)))
	(T nil)))

(defun find-conn-for-pkt (pkt)
  (neti:with-network-packet (pkt)
    (when (pkt-dest-conn pkt)
      (let ((conn (pkt-dest-conn pkt)))
	(declare (sys:array-register conn))
	(and 
	  (= (local-index-num conn) (pkt-dest-index-num pkt))
	  (or (= (foreign-index-num conn) (pkt-source-index-num pkt))
	      (not (foreign-index-valid conn)))
	  (or (= (foreign-address conn) (pkt-source-address pkt))
	      (not (foreign-address-valid conn)))
	  (= (local-address conn) (pkt-dest-address pkt))
	  (progn (setf (time-last-received conn) (time))
		 conn))))))


  ;;
;;;;;;  The actual workhorse of receiving a packet.  Forwarding, if
;;;;;;  necessary, has already been done.
  ;;

(defun receive-chaos-packet (pkt)
  (setf (fill-pointer (pkt-string pkt)) (pkt-nbytes pkt))	;make sure string length is set
  (let* ((conn (find-conn-for-pkt pkt))
	 (waiter (and conn (conn-owning-process conn))))
    (when waiter
      ;; this is probably premature
      (process:process-wakeup (conn-owning-process conn)))
    (neti:with-network-packet (pkt)
      (neti:fsm-invoke
	(remove-unreferenced-labels t)		;for human readability of macro expansion
	(fsm-var pkt :form
		 :value (classify-pkt-opcode (pkt-opcode pkt))
		 :cached t
		 :quoted t
		 :null-value :unknown)
	(fsm-var state :form
		 :accessor (state conn)
		 :value (and conn (state conn))
		 :cached t
		 :quoted t
		 :null-value :no-such)
	(fsm-var dest-port :number
		 :accessor (pkt-dest-index-num pkt))
	(fsm-var foreign-address :form
		 :accessor (foreign-address conn))
	(fsm-var foreign-address-valid :form
		 :accessor (foreign-address-valid conn))
	(fsm-var foreign-index-valid :form
		 :accessor (foreign-index-valid conn))
      
	(fsm-state ((pkt :unknown))
		   (incf *pkts-in-bad-opcode*)
		   (lisp (send-los-pkt pkt los-op "Unknown opcode")))
	(fsm-state ((pkt :default) (state :no-such))
		   (incf *pkts-in-no-conn*)
		   (lisp (send-los-pkt pkt los-op "No such connection")))
	(fsm-state ((pkt :default) (state :default))
		   (incf *pkts-in-conn-bad-state*)
		   (lisp (send-los-pkt pkt los-op "Connection in invalid state")))
      
	(fsm-state ((pkt DAT) (state OPEN-state))
		   (incf *dat-pkts-in*)
		   (lisp (process-ack conn (pkt-ack-num pkt))
			 (queue-ordered-input-pkt conn pkt)
			 (when waiter (process:process-wakeup waiter))))
	(fsm-state ((pkt STS) (state OPEN-state))
		   (incf *sts-pkts-in*)
		   (lisp (when ( (offered-foreign-window-size conn)
				  (pkt-second-data-word pkt))
			   (setf (foreign-window-size conn)
				 (setf (offered-foreign-window-size conn)
				       (min (pkt-second-data-word pkt)
					    32.))))
			 (process-ack conn (pkt-ack-num pkt) (pkt-first-data-word pkt))
			 (return-pkt pkt)
			 (when waiter (process:process-wakeup waiter))
			 (signal-retransmit-for-conn conn)))
	(fsm-state ((pkt STS) (state RFC-sent-state))	;Somebody trying to find it's OPN, 
						;which we havn't received yet.
		   (lisp (return-pkt pkt)))
	(fsm-state ((pkt SNS) (state OPEN-state))
		   (incf *sns-pkts-in*)
		   (lisp (process-ack conn (pkt-ack-num pkt))
			 (send-sts-for-conn conn pkt 'Requested-by-SNS)
			 (when waiter (process:process-wakeup waiter))))
	(fsm-state ((pkt SNS) (state :no-such))
		   (incf *sns-pkts-in-bad*)
		   (as-if (pkt :default) (state :no-such)))	      
	(fsm-state ((pkt SNS) (state :default))
		   (incf *sns-pkts-ignored*)
		   (lisp (return-pkt pkt)))
	(fsm-state ((pkt UNC) (state :no-such) (dest-port 0))
		   (incf *encapsulated-pkts-in*)
		   (lisp (process-encapsulated-pkt pkt)
			 (when waiter (process:process-wakeup waiter))))
	(fsm-state ((pkt UNC) (state OPEN-state FOREIGN-state))
		   (incf *unc-pkts-in*)
		   (lisp (queue-unordered-input-pkt conn pkt)
			 (when waiter (process:process-wakeup waiter))))
	(fsm-state ((pkt OPN) (state RFC-sent-state BRD-sent-state))
		   (incf *opn-pkts-in*)
		   (new state OPEN-state)
		   (new foreign-address (pkt-source-address pkt))
		   (new foreign-address-valid t)	;in case was BRD-sent
		   (new foreign-index-valid t)
		   (lisp (free-all-read-pkts conn)	;in case was BRD-sent
			 (setf (foreign-index-num conn) (pkt-source-index-num pkt))
			 (setf (pkt-num-read conn) (pkt-num pkt))
			 (setf (pkt-num-received conn) (pkt-num pkt))
			 (setf (foreign-window-size conn)
			       (setf (offered-foreign-window-size conn)
				     (pkt-second-data-word pkt)))
			 (process-ack conn (pkt-ack-num pkt) (pkt-first-data-word pkt))
			 (send-sts-for-conn conn pkt 'Response-to-OPN)
			 ;; this will wakeup waiter, so we don't have to
			 (INTERRUPT-CONN ':CHANGE-OF-STATE CONN 'OPEN-STATE)))
	(fsm-state ((pkt OPN) (state OPEN-state))
		   (incf *opn-pkts-duplicated*)
		   (lisp (send-sts-for-conn conn pkt 'Response-to-OPN)
			 (when waiter (process:process-wakeup waiter))))
	(fsm-state ((pkt ANS CLS FWD) (state :default :no-such))
		   (incf *reply-pkts-ignored*)
		   (lisp (return-pkt pkt)))
	(fsm-state ((pkt LOS) (state :default :no-such))
		   (lisp (when *record-los-reasons*
			   (push (string-append (pkt-string pkt) "") *los-reasons*)))
		   (same-as (pkt ANS) (state :default)))
	(fsm-state ((pkt ANS) (state RFC-sent-state))
		   (incf *ans-pkts-in*)
		   (new state answered-state)
		   (lisp (free-all-send-pkts conn)
			 (queue-input-pkt conn pkt)
			 (interrupt-conn ':change-of-state conn (state conn))))
	(fsm-state ((pkt CLS) (state OPEN-state RFC-sent-state))
		   (incf *cls-pkts-in*)
		   (new state CLS-received-state)
		   (lisp (free-all-send-pkts conn)
			 (free-all-received-pkts conn)
			 (queue-input-pkt conn pkt)
			 (INTERRUPT-CONN ':CHANGE-OF-STATE CONN (state conn))))
	(fsm-state ((pkt ANS CLS) (state BRD-sent-state))
		   (incf *brd-replies-in*)
		   (lisp (queue-unordered-input-pkt conn pkt)
			 (when waiter (process:process-wakeup waiter))))
	(fsm-state ((pkt LOS) (state OPEN-state))
		   (incf *los-pkts-in*)
		   (new state LOS-received-state)
		   (as-if (pkt CLS) (state OPEN-state)))
	(fsm-state ((pkt FWD) (state RFC-sent-state))
		   (incf *fwd-pkts-in*)
		   (lisp (setf (foreign-address conn) (pkt-ack-num pkt))
			 (setf (foreign-host conn) nil)
			 (return-pkt (send-pkts conn))
			 (send-new-rfc-for-conn conn pkt)))
	(fsm-state ((pkt RFC))
		   (incf *rfc-pkts-in*)
		   (lisp (receive-RFC pkt)))	;special treatment
	(fsm-state ((pkt BRD))
		   (incf *brd-pkts-in*)
		   (lisp (convert-brd-to-rfc pkt))
		   (as-if (pkt RFC)))
	(fsm-state ((pkt RUT))
		   (incf *rut-pkts-in*)
		   (lisp (receive-RUT pkt)))
	(fsm-state ((pkt MNT LSN))
		   (lisp (return-pkt pkt)))
	))))


  ;;
;;;;;;  Functions that are too involved to be inline with the above FSM
  ;;


;;; This list must be added to each time a new network medium is defined that uses
;;; :network :chaos as a path.  The order of this list is significant.  In composing 
;;; media, this list is traversed from the beginning.  
;;; For example, :token-list-stream has two paths, (:medium :chaos-token-list)
;;; and (:medium :byte-stream-with-mark).  :chaos implemented :byte-stream-with-mark.
;;; If :chaos were first on the list, then it would be chosen, and an encapsulated
;;; token list stream constructed, which would be incompatable with the chaos-token-list
;;; stream on the user end.
;;;
;;; All this happens because RFC's don't tell what sort of 
;;; chaos stream the user side opened.  Alternatively, it might be argued that
;;; there aught to be a way that the define-medium forms for :chaos-token-list,
;;; :chaos, and :token-list-stream manage to say that it is 1never0 correct to
;;; encapsulate a chaos non-token-list stream to get a token-list.

;;; ---Perhaps there should be a form to add to this list, so that users can
;;; ---define new media on CHAOS?

(cl:defparameter *possible-server-media* '(:chaos-token-list :chaos :chaos-simple))

(defun receive-rfc (pkt)
  (prog process-rfc (pkt-string pkt-string-space server contact-name)
	(do tst-pkt *pending-rfc-pkts* (pkt-link tst-pkt) (null tst-pkt)
	    (when (and (= (pkt-source-address   pkt) (pkt-source-address   tst-pkt))
		       (= (pkt-source-index-num pkt) (pkt-source-index-num tst-pkt)))
	      ;; this packet is a duplicate RFC that we already have on the list
	      (go free-it)))
	(dolist (conn *conn-list*)
	  (when (and (= (foreign-address   conn) (pkt-source-address   pkt))
		     (= (foreign-index-num conn) (pkt-source-index-num pkt)))
	    ;; a connection already has a previous version of this packet
	    (go free-it)))
	(setq pkt-string (pkt-string pkt))
	(setq pkt-string-space (string-search-char #\space pkt-string))
	(dolist (lsn *pending-listens*)
	  (when (string-equal pkt-string (contact-name lsn) 0 0 pkt-string-space)
	    ;; found an connection listening for this contact name
	    (setq *pending-listens* (delq lsn *pending-listens*))
	    (rfc-meets-lsn lsn pkt)
	    (return-from process-rfc nil)))
	(unless (or *services-enabled*
		    (equal pkt-string "STATUS"))       
	  (when ( (pkt-opcode pkt) rfc-op)
	    ;; if not a RFC (e.g., a BRD) just ignore it.
	    (go free-it))
	  (send-los-pkt pkt cls-op "Not available as a server now")
	  (return nil))
	(when (and (setq server (loop for x in *chaos-contact-names*
				      when (string-equal pkt-string (second x)
							 0 0 pkt-string-space)
				      do (setq contact-name (second x))
				      and return (first x)))
		   (setq server (neti:find-server-named server)))
	  (without-interrupts
	    (setf (pkt-link pkt) *pending-rfc-pkts*)
	    (setq *pending-rfc-pkts* pkt))
	  (neti:invoke-server server *possible-server-media* 
			      *local-chaosnet* (pkt-source-address pkt)
			      (listen contact-name *default-window-size* nil))
	  (return nil))
     free-it
	(return-pkt pkt)))

(defvar *unc-interface* nil "The interface for Chaos UNC packets.")

(defun process-encapsulated-pkt (pkt)
  (if *unc-interface*
      (send *unc-interface* ':receive-unc-packet pkt)
      (return-pkt pkt)))

(defun convert-brd-to-rfc (pkt &aux (nbitmap-words (// (pkt-ack-num pkt) 2))
			   (nwords (pkt-nwords pkt)))
  (setf (pkt-dest-address pkt) my-address)
  1;; Kludge.  copy-array-portion will blow out if the bounds are wrong (ie. bad BRD packet).
0  1;; The RFC receive code will drop a bad packet on the floor so we just have to get
0  1;; beyond the copy-array-portion.  It would be nice to get our hands on all the
0  1;; necessary information to drop bad packets before they get into the state machine.
0  (if (> nwords (+ first-data-word-in-pkt nbitmap-words))
      (copy-array-portion pkt (+ first-data-word-in-pkt nbitmap-words) nwords
			  pkt    first-data-word-in-pkt (- nwords nbitmap-words)))
  (decf (pkt-nbytes pkt) (pkt-ack-num pkt))
  (setf (array-leader (pkt-string pkt) 0) (pkt-nbytes pkt))
  (setf (pkt-ack-num pkt) 0))

;;; This is called when we have a LSN matching an RFC.  It can be called when we do
;;; a LSN (m.p. level) or when an RFC gets here (p.i. level).
;;; Here LISTEN has filled in some of the fields of the CONN, we must
;;; fill in the rest.
(defun rfc-meets-lsn (conn pkt)
    (setf (foreign-address conn) (pkt-source-address pkt))
    (setf (foreign-address-valid conn) t)
    (setf (foreign-index-num conn) (pkt-source-index-num pkt))
    (setf (foreign-index-valid conn) t)
    (setf (local-address conn) (pkt-dest-address pkt))
    (setf (pkt-num-read conn) (pkt-num pkt))
    (setf (pkt-num-received conn) (pkt-num pkt))
    (setf (pkt-num-acked conn) (pkt-num pkt))
    (setf (window-available conn) 1)
    (setf (time-last-received conn) (time))
    (if (eq (pkt-opcode pkt) brd-op)
	(setf (state conn) 'brd-received-state)
	(setf (state conn) 'rfc-received-state))
    (setf (pkt-link pkt) nil)
    (setf (read-pkts conn) pkt)
    (setf (read-pkts-last conn) pkt)
    #-ignore
    (interrupt-conn ':change-of-state conn (state conn))
    #-ignore
    (interrupt-conn ':input conn))



(defun receive-rut (pkt)
  (neti:with-network-packet (pkt)
    (do ((i first-data-word-in-pkt (+ i 2))
	 (n (// (pkt-nbytes pkt) 4) (1- n))
	 (gateway (pkt-source-address pkt))
	 (subnet) (cost))
	((zerop n) (return-pkt pkt))
      (setq subnet (aref pkt i) cost (aref pkt (1+ i)))
      (let ((current-cost (aref *routing-table-cost* subnet))
	    (current-route (aref *routing-table* subnet)))
	(when (and (not (zerop subnet))		;zero is not a valid subnet
		   (< subnet max-subnet)	1;255 is the largest subnet number
0		   ( cost 17.)			;avoid broken software on other end
		   1;; Only update routes that cost less and ones we don't have an interface
		   ;; for.
0		   (or (and ( cost current-cost) (numberp current-route))
		       (eql current-route 0)))
	  (setf (aref *routing-table*      subnet) gateway)
	  (setf (aref *routing-table-cost* subnet) cost))))))


(defsubst ticks-to-timer-units (n) (* n (floor 1 (* 60 process:*timer-units*))))

(defun reset-chaos-background-timer (timer delta-time)
  (let ((delta-timer-units (ticks-to-timer-units delta-time)))
    (unless (and (process:timer-pending-p timer)
		 (process::timer-expires-by-relative-timer-units timer delta-timer-units))
      (process:reset-timer-relative-timer-units timer delta-timer-units))))

  ;;
;;;;;;  The background (simple) process
  ;;

(defun chaos-background ()
  (process:with-no-other-processes
    (let* ((time (time))
	   (need-to-retransmit (process:timer-expired-p *chaos-retransmit-timer*))
	   (need-to-probe (not (process:timer-pending-p *chaos-probe-timer*))))

      ;; update the timer variables
      (when need-to-retransmit
	(reset-chaos-background-timer *chaos-retransmit-timer* *retransmit-interval*))
      (when need-to-probe
	(reset-chaos-background-timer *chaos-probe-timer* *probe-interval*))

      ;; Retransmit and/or probe connections as needed
      (when (or *some-conn-needs-retransmission*
		*some-conn-needs-sts*
		need-to-retransmit
		need-to-probe)
	(setq *need-to-retransmit-possible* nil)
	(dolist (conn *conn-list*)
	  (when (and (send-pkts conn)
		     (memq (state conn) '(open-state rfc-sent-state)))
	    (setq *need-to-retransmit-possible* t)
	    (reset-chaos-background-timer *chaos-retransmit-timer* *retransmit-interval*)
	    (when (or (needs-retransmission conn)
		      (if *adaptive-retransmission-enabled*
			  (time-elapsed-p (ash (round-trip-time conn) *retransmit-timeout-lsh*)
					  (last-retransmit-time conn)
					  time)
			  need-to-retransmit))
	      (retransmit-for-conn conn)))
	  (when (needs-sts conn) (send-sts-for-conn conn (get-pkt nil) 'batched-sts))
	  (when (and need-to-probe (eq (state conn) 'open-state))
	    (probe-conn conn))))

      ;; Age the routing table if needed
      (unless (process:timer-pending-p *chaos-routing-table-timer*)
	(reset-chaos-background-timer *chaos-routing-table-timer* *age-routing-table-interval*)
	(dotimes (sbn max-subnet)
	  (setf (aref *routing-table-cost* sbn)
		(min (1+ (aref *routing-table-cost* sbn))
		     (if (numberp (aref *routing-table* sbn))
			 maximum-routing-cost
						1;Never let direct interfaces completely die
0			 (1- maximum-routing-cost))))))

      (unless (process:timer-pending-p *chaos-routing-pkt-timer*)
	(reset-chaos-background-timer *chaos-routing-pkt-timer* *send-routing-packet-interval*)
	(neti:maybe-packet-buffer-panic)
	(when *forward-packets*
	  (loop for count-only first t then nil
		with count = 0
		do (loop for interface in neti:*interfaces*
			 when (and (send interface ':enabled)
				   (send interface ':protocol-address *local-chaosnet*))
			   do (if count-only
				  (progn (incf count)
					 (if (> count 1) (return)))
				  (send-rut-packet interface)))
		until (null count-only)
		while (> count 1))))

      ;; initialized variables that get set when processing received packets
      (setq *some-conn-needs-retransmission* nil)
      (setq *some-conn-needs-sts* nil))))

;;; state known to be OPEN-STATE.  RFC-SENT-STATUS is checked by others
(defun probe-conn (conn &aux (delta-time (time-difference (time) (time-last-received conn))))
  (cond ((> delta-time *host-down-interval*)
	 (setf (state conn) 'host-down-state)
	 (free-all-send-pkts conn)
	 (free-all-received-pkts conn)
	 (INTERRUPT-CONN ':CHANGE-OF-STATE CONN 'HOST-DOWN-STATE))
	((and (or (pktnum-< (send-pkt-acked conn) (pkt-num-sent conn))
		  (> delta-time *long-probe-interval*)
		  (zerop (foreign-window-size conn))))
	 (send-sns-for-conn conn (get-pkt nil)))))


;;; Send out a routing packet on the interface specified
(defun send-rut-packet (interface)
  (let ((pkt (get-pkt nil)))
    (when pkt
      (let* ((local-address (send interface ':protocol-address *local-chaosnet*)))
	(loop with index = first-data-word-in-pkt
	      with my-cost = (send interface ':chaos-routing-cost)
	      for subnet upfrom 1 below max-subnet
	      as cost = (+ my-cost (aref *routing-table-cost* subnet))
	      when (and (not (eql (aref *routing-table* subnet) 0))
			(< cost maximum-routing-cost))
	      do (setf (aref pkt     index)  subnet)
		 (setf (aref pkt (1+ index)) cost)
		 (incf index 2)
	      until ( index max-data-bytes-per-pkt)	;Don't try to fill more than can fit.
	      finally (setf (pkt-nbytes pkt)
			    (* (- index first-data-word-in-pkt) 2)))
	(alter-pkt pkt
		   pkt-opcode rut-op
		   pkt-dest-address 0		;broadcast
		   pkt-dest-index-num 0
		   pkt-source-address local-address
		   pkt-source-index-num 0)
	(transmit-pkt-1 pkt interface 0 t)))))


  ;;
;;;;;;  User level input and output.  These block if necessary.
  ;;

(defun get-next-pkt (conn &optional (no-hang-p nil) stream &aux state pkt)
  (do () (nil)
    (setq state (state conn))
    (cond ((or (data-available conn) (eq state 'open-state)))
	  ((memq state '(cls-received-state answered-state rfc-received-state
					    brd-received-state))
	   (error 'chaos-connection-no-more-data
		  ':connection conn
		  ':reason (cdr (assq (state conn)
				      '((cls-received-state . "closed")
					(answered-state . "answered")
					(rfc-received-state . "in RFC received state")
					(brd-received-state . "in BRD received state"))))))
	  ;; states accounted for so far: open, cls-received, answered, rfc-received.
	  ;; Other legal states without input packets queued get checked
	  ;; for validity here.
	  ((memq (state conn) '(foreign-state brd-sent-state)))
	  ;; If we get here, the connection is in an illegal state to
	  ;; receive a packet.  Signal an error, even if no-hang-p is
	  ;; non-NIL.
	  (T (bad-chaos-connection-state conn "get a packet from")))
    ;; once we're patching this, make this a with-preemption-disabled instead of
    ;; without-interrupts.
    ;; It really should ne neither.  This should be using locks.
    (process:with-no-other-processes
      (when (setq pkt (read-pkts conn))
	(setf (read-pkts conn) (pkt-link pkt))
	(decf (read-pkts-length conn))
	(when (null (read-pkts conn))
	  (setf (read-pkts-last conn) nil))
	(when ( (pkt-opcode pkt) UNC-op)
	  (setf (pkt-num-read conn) (pkt-num pkt)))))
    (when pkt
      (setf (pkt-link pkt) nil)
      (when (and (eq state 'open-state)
		 ( (pkt-opcode pkt) unc-op)
		 (or ( (decf (auto-status-count conn) 3) 0)
		     (and *trigger-retransmission-enabled*
			  (null (read-pkts conn)))
		     (= (pkt-opcode pkt) eof-op)))
	(send-sts-for-conn conn (get-pkt nil) 'window-opening))
      (return pkt))
    (when no-hang-p (return nil))
    ;; this is a condensed version of conn-input-wait.  It is here to
    ;; minimize time in the process-wait function.  On a server machine
    ;; with 40 connections or so, the process wait function gets called
    ;; over 600 times per second.  This happens both when active
    ;; (because the process runs out of data and process-waits again)
    ;; and when idle.
    (flet ((waiter ()
		   (declare (sys:downward-function))
		   (or (data-available conn)
		       (not (memq (state conn)
				  '(open-state foreign-state brd-sent-state))))))
      (setf (conn-owning-process conn) *current-process*)
      (multiple-value-prog1
	(if stream
	    (send stream :input-exception-wait "Chaos In" #'waiter)
	    (process-wait "Chaos In" #'waiter))
	#||
	(setf (conn-owning-process conn) nil)
	||#))))

;;; get-next-pkt above has a condensed version of this
(defun conn-input-wait (conn stream &optional whostate function &rest arguments)
  (flet ((waiter ()
	   (declare (sys:downward-function))
	   (or (data-available conn)
	       (not (memq (state conn)
			  '(open-state foreign-state brd-sent-state)))
	       (and function (not (null (apply function arguments)))))))
    (setf (conn-owning-process conn) *current-process*)
    (multiple-value-prog1
      (if stream
	  (send stream :input-exception-wait (or whostate "Chaos In") #'waiter)
	  (process-wait (or whostate "Chaos In") #'waiter))
      #||
      (setf (conn-owning-process conn) nil)
      ||#)))

(defun conn-listen (conn)
  (or (not (memq (state conn) '(open-state foreign-state brd-sent-state)))
      (without-interrupts
	(loop as pkt = (read-pkts conn)
	      when (null pkt)
	        return nil			;no data
	      when (or (< (pkt-opcode pkt) dat-op)
		       (> (pkt-nbytes pkt) 0))
		return t			;non-data or non-zero length
	      do (setq pkt (get-next-pkt conn t))	;officially get it
		 (if pkt
		     (return-pkt pkt)
		   (ferror "Chaos implementation error: PKT should be non-NIL."))))))


(defun send-pkt (conn pkt &optional (opcode dat-op) stream)
  (unwind-protect
      (do () (nil)
	(cond ((neq (state conn) 'open-state)
	       (bad-chaos-connection-state conn "send a packet to"))
	      ((not (or ( opcode dat-op) (= opcode eof-op)))
	       (ferror "~O is not a legal data opcode" opcode))
	      ((may-transmit conn)
	       (setf (pkt-opcode pkt) opcode)
	       (send-controlled-pkt-for-conn conn (prog1 pkt (setq pkt nil)))
	       (return t))
	      (T (flet ((waiter ()
				(declare (sys:downward-function))
				(or (may-transmit conn)
				    (neq (state conn) 'open-state))))
		   (if stream
		       (send stream :output-exception-wait "Chaos Out" #'waiter)
		       (process-wait "Chaos Out" #'waiter))))))
    (when pkt (return-pkt pkt))))

(defun send-unc-pkt (conn pkt &optional pkt-num-field ack-num-field)
  (unwind-protect
    (progn (if (not (memq (state conn) '(open-state foreign-state)))
	       (bad-chaos-connection-state conn "Send an UNC packet to"))
	   (if pkt-num-field (setf (pkt-num     pkt) pkt-num-field))
	   (if ack-num-field (setf (pkt-ack-num pkt) ack-num-field))
	   (send-unc-for-conn conn (prog1 pkt (setq pkt nil))))
    (when pkt (return-pkt pkt))))

(defun finish-conn (conn &optional (whostate "Chaos Finish") stream)
  (flet ((waiter ()
		 (declare (sys:downward-function))
		 (conn-finished-p conn)))
    (if stream
	(send stream :output-exception-wait whostate #'waiter)
	(process-wait whostate #'waiter)))
  (eq (state conn) 'open-state))

;;; predicate to determine when all sent packets have been acknowledged,
;;; or when connection has gone non-OPEN. 
(defun conn-finished-p (conn)
  (or (not (pktnum-< (send-pkt-acked conn) (pkt-num-sent conn)))
      (neq (state conn) 'open-state)))



(defun update-sts-why-array (reason &aux (idx (array-leader *sts-why-array* 1)))
  (setf (aref *sts-why-array* idx) reason)
  (setf (array-leader *sts-why-array* 1)
	(\ (1+ idx) (array-leader *sts-why-array* 0)))
  nil)

(defun record-pkt-header (pkt dir)
  (without-interrupts
    (let* ((idx (array-leader *recent-headers* 1))
	   (rcnt (aref *recent-headers* idx)))
      (copy-array-portion pkt  0 first-data-word-in-pkt
			  rcnt 0 first-data-word-in-pkt)
      (setf (rcnt-time-recorded rcnt) (time))
      (setf (rcnt-dir rcnt) (if (eq dir ':in) 0 -1))
      (setf (array-leader *recent-headers* 1)
	    (\ (1+ idx) (array-leader *recent-headers* 0)))
      nil)))
