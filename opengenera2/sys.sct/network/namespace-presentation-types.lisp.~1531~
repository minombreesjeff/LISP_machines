;;; -*- Mode: LISP; Syntax: Common-lisp; Package: COMMON-LISP-NETWORK-INTERNALS; Base: 10; Lowercase: T -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

(defparameter D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")*namespace-presentation-type-alist*
0	      '((:user-property . user-property)
		(:service . service-entry)
		(:address . address-entry-triple)
		(:root-domain-server-address . address-entry)
		(:console-location . location-entry)
		(:printer-location . location-entry)
		(:server-machine . namespace-boolean)
		(:default-secondary-name-server . namespace-boolean)
		(:standalone . namespace-boolean)
		(:validate-lmfs-dump-tapes . namespace-boolean)
		(:all-mail-addresses-forward . namespace-boolean)
		(:affiliation . affiliation-entry)
		(:body-character-style . character-style-entry)
		(:heading-character-style . character-style-entry)
		(:protocol . service-name)
		(:fonts-widths-file . namespace-pathname)
		(:descriptor-file . namespace-pathname)
		(:site-directory . namespace-pathname)
		(:root-directory . namespace-pathname)
		(:file-control-lifetime . file-control-lifetime)
		(:host-protocol-desirability . host-protocol-desirability)
		)) 

(2 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");;; Functions that are used instead of ptypes
0(defparameter 1*namespace-function-alist*
0	      '((:peripheral . parse-peripheral)
		(:interface . parse-printer-interface)
		(:interface-options . parse-printer-interface-options)
		(:spooled-printer . parse-spooled-printer)
		))

(defun 1template-to-presentation-type0 (indicator template namespace description)
  (declare (values ptype element-p))
  (let ((element-p (eq (first template) :element)))
    (when element-p (pop template))    
    (labels ((pop-ptype ()
	       (let ((token (pop template)))
		 (case token
		   (:token
		     `((namespace-token) :help-text ,description))
		   (:global-name
		     `((namespace-global-name) :help-text ,description))
		   (:name
		     `((neti:name :namespace ,namespace) :help-text ,description))
		   (:pair
		     `((namespace-n-set ,(pop-ptype) ,(pop-ptype)))) 
		   (:triple
		     `((namespace-n-set ,(pop-ptype) ,(pop-ptype) ,(pop-ptype))))
		   (:set
			 `((namespace-set ,(pop-ptype))))
		   (otherwise
		     (cond ((member token neti:*all-classes*)
			    `((net:object :class ,token)))
			   (t
			    (error "Invalid class template."))))))))
      (let* ((special-type (cdr (assoc indicator *namespace-presentation-type-alist*)))
	     (ptype `((,special-type) :help-text ,description)))
	(unless special-type
	  (setq ptype (pop-ptype))
	  (unless (null template)
	    (error "Invalid class template.")))
	(values ptype element-p)))))

2;;; Presentation types used by the namespace and namespace editor.

;;; Even though user properties are just a keyword and a string, we need a separate ptype
;;; to help with the strings that have "s and spaces in them so we don't confuse the delimiter
;;; space with a space in the string.
0(define-presentation-type 1user-property 0(() &key help-text)
   :description "a user property pair of a global name and a token"
   :printer ((object stream)
	     (cl:apply #'format stream "~A ~A" object))
   :parser ((stream)
	    (flet ((check-for-space ()
		     (unless (dw:compare-char-for-accept (dw:read-char-for-accept stream)
							 #\space)
		       (zl:parse-ferror "Must terminate field with space"))))
	      (dw:with-accept-help-if help-text ((:subhelp help-text))
		(let ((property
			(accept 'keyword :stream stream :prompt nil
				:additional-blip-chars '(#\space))))
		  (check-for-space)
		  (let ((value
			  (accept 'string :stream stream :prompt nil)))
		    (list property value))))))
   )

(define-presentation-type1 namespace-token0 (() &key help-text)
   :parser ((stream)
	    (dw:with-accept-help-if help-text ((:subhelp help-text))
	      (accept 'string :stream stream :prompt nil :default nil)))
   :history t
   :describer ((stream)
	       (write-string "a token" stream)))

(define-presentation-type 1namespace-global-name0 (() &key help-text)
   :history t
   :describer ((stream)
		 (write-string "a global name" stream))
   :parser ((stream)
	    (dw:with-accept-help-if help-text ((:subhelp help-text))
	      (multiple-value-bind (string quoted)
		  (dw::with-accept-activation-chars ('(#\space))
		    (dw:read-standard-token stream))
		(unless quoted (setf string (string-upcase string)))
	      ;; intern returns TWO values, dammit.
	      (values
		(intern string "KEYWORD"))))))

(define-presentation-type1 neti:name0 ((&key namespace) &key help-text)
   :no-deftype t
   :history t
   :describer ((stream)
	       (if namespace
		   (format stream "a name in namespace ~A" namespace)
		   (write-string "a namespace name" stream)))
   :typep ((object)
	   (or (null namespace)
	       (eq (send object :namespace) namespace)))
   :parser ((stream &key default)
	    (dw:with-accept-help-if help-text ((:subhelp help-text))
	      (let ((loc (send stream :read-location)))
		(multiple-value-bind (string quoted)
		    (dw::with-accept-activation-chars ('(#\space))
		      (dw:read-standard-token stream))
		  (if (and (not quoted) (zerop (length string)))
		      (progn
			(when default
			  (dw::presentation-replace-input
			    stream loc
			    (if namespace
				(send default :string)
				(send default :qualified-string))))
			default)
		      (let ((name (neti:parse-name string nil namespace)))
			(when (and namespace
				   (not (eq namespace (send name :namespace))))
			  (zl:parse-ferror "~A is not in namespace ~A." name namespace))
			name))))))
   :printer ((object stream)
	     (if namespace
		 (write-string (send object :string) stream)
		 (princ object stream))))

(define-presentation-type 1namespace-n-set0 ((&rest types))
   :abbreviation-for `((dw::sequence-enumerated ,@types)
		       :sequence-delimiter #\space :echo-space nil)
   :describer ((stream &key plural-count)
	       (ecase (length types)
		 (2
		   (if plural-count
		       (format stream "pairs")
		       (format stream "a pair")))
		 (3
		   (if plural-count
		       (format stream "triples")
		       (format stream "a triple"))))
	       (format stream " of ")
	       (format-textual-list types #'dw:describe-presentation-type :stream stream
				    :conjunction "and")))

(define-presentation-type 1namespace-set0 ((type))
   :abbreviation-for `((sequence ,type)
		       :sequence-delimiter #\space :echo-space nil)
   ;; --- this parser exists only to mask a bug (feature?)
   ;; in the sequence presentation type.
   ;; If you do (accept '((sequence integer)))
   ;; you get back (sequence-enumerated integer integer ...) as the type.
   ;; Unfortunately, this type is NOT presentation-subtypep to (sequence integer)
   ;; which causes all sorts of problems for things like the sequence default-preprocessor.
   ;; - Doughty
   :parser ((stream &key original-type initially-display-possibilities)
	    (values
	      (accept `(or ((sequence ,type) :sequence-delimiter #\space :echo-space nil)
			   null)
		      :stream stream
		      :initially-display-possibilities
		      initially-display-possibilities
		      :prompt nil)
	      original-type))
   :describer ((stream)
	       (write-string "zero or more " stream)
	       (dw:describe-presentation-type type stream t "zero or more")))

2;;; Presentation types used for Service triples.
0;;; This would be called 1service0, but Benson used that name up for something confusingly
;;; similar.  We might be able to merge the two with more data arguments.
(define-presentation-type 1service-name0 ((&key allow-any-input) &key help-text)
   :expander 'keyword
   :parser ((stream &key original-type initially-display-possibilities)
	    (dw:with-accept-help-if help-text ((:subhelp help-text))
	      (multiple-value-bind (object success string)
		  (dw:completing-from-suggestions
		    (stream :type original-type
			    :allow-any-input allow-any-input
			    :initially-display-possibilities initially-display-possibilities)
		    (dolist (protocol neti:*protocol-list*)
		      (let ((name (neti:protocol-service protocol)))
			(dw:suggest (string name) name)))
		    (dolist (service-triple *known-but-unimplemented-protocols*)
		      (let ((name (first service-triple)))
			(dw:suggest (string name) name))))
		(if success object (intern (string-thin (string-upcase string)) "")))))
   :description "a service"
   )

(define-presentation-type1 medium-name0 ((&key allow-any-input service))
   :expander 'keyword
   :parser ((stream &key original-type initially-display-possibilities)
	    (multiple-value-bind (object success string)
		(dw:completing-from-suggestions
		  (stream :type original-type
			  :allow-any-input allow-any-input
			  :initially-display-possibilities initially-display-possibilities)
		  (if service
		      (dolist (protocol neti:*protocol-list*)
			(when (eq service (neti:protocol-service protocol))
			  (dolist (medium (find-base-medium-for-medium
					    (neti:protocol-base-medium-name protocol)))
			    (dw:suggest (string medium) medium))))
		    (dolist (medium neti:*medium-list*)
		      (dolist (base-medium (find-base-medium-for-medium medium))
			(dw:suggest (string base-medium) base-medium))))
		  (dolist (service-triple *known-but-unimplemented-protocols*)
		    (when (or (null service)
			      (eq service (first service-triple)))
		      (let ((name (second service-triple)))
			(dw:suggest (string name) name)))))
	      (if success object (intern (string-thin (string-upcase string)) ""))))
   :description "a medium"
   )

;;; This supersedes one in telnet.lisp.
neti:
(define-presentation-type 1protocol-name0 ((&key allow-any-input service medium))
   :expander 'keyword
   :parser ((stream &key original-type initially-display-possibilities)
	    (multiple-value-bind (object success string)
		(dw:completing-from-suggestions
		  (stream :type original-type
			  :allow-any-input allow-any-input
			  :initially-display-possibilities initially-display-possibilities)
		  2;; When both the service and the medium are provided, we can check all the
0		  2;; protocols that implement SERVICE over MEDIUM.  When just SERVICE is
0		  2;; provided, we can find all the protocols that implement it.
0		  (dolist (protocol neti:*protocol-list*)
		    (when (or (and (null service) (null medium))
			      (and (member medium (cl-neti::find-base-medium-for-medium
						    (neti:protocol-base-medium-name protocol)))
				   (eq service (neti:protocol-service protocol)))
			      (and (null service)
				   (member medium (cl-neti::find-base-medium-for-medium
						    (neti:protocol-base-medium-name protocol))))
			      (and (null medium)
				   (eq service (neti:protocol-service protocol))))
		      2;; Don't mention protocols implemented over the :local medium
0		      (when (not (eq (neti:protocol-base-medium-name protocol) :local))
			(let ((name (neti:protocol-name protocol)))
			  (dw:suggest (string name) name)))))
		  (when (null service)
		    (dolist (server neti:*servers*)
		      (when (or (null medium)
				(member medium (cl-neti::find-base-medium-for-medium
						 (neti:server-medium-type server))))
			(let ((name (neti:server-protocol-name server)))
			  (dw:suggest (string name) name)))))
		  (dolist (service-triple cl-neti::*known-but-unimplemented-protocols*)
		    (when (or (and (null service) (null medium))
			      (and (eq medium (second service-triple))
				   (eq service (third service-triple)))
			      (and (null service) (eq medium (second service-triple)))
			      (and (null medium) (eq service (third service-triple))))
		      (let ((name (third service-triple)))
			(dw:suggest (string name) name)))))
	      (if success object (intern (string-thin (string-upcase string)) ""))))
   :description "a protocol"
   )

(define-presentation-type 1service-entry0 (() &key help-text)
   :expander '((sequence-enumerated keyword keyword keyword))
   :printer ((entry stream)
	     (cl:apply #'format stream "~A ~A ~A" entry))
   :description "a triple of service, medium, and protocol"
   :parser ((stream)
	    (flet ((check-for-space ()
		     (unless (dw:compare-char-for-accept (dw:read-char-for-accept stream)
							 #\space)
		       (zl:parse-ferror "Must terminate field with space"))))
	      (dw:with-accept-help-if help-text ((:subhelp help-text))
		(let ((service (accept '((service-name :allow-any-input t)) :stream stream
				       :additional-blip-chars '(#\space)
				       :prompt "service" :default nil)))
		  (check-for-space)
		  (let ((medium (accept `((medium-name :allow-any-input t
						       :service ,service))
					:stream stream
					:additional-blip-chars '(#\space)
					:prompt "medium" :default nil)))
		    (check-for-space)
		    (let ((protocol (accept `((neti:protocol-name :allow-any-input t
								  :service ,service
								  :medium ,medium))
				      :stream stream
				      :prompt "protocol" :default nil)))
		      (list service medium protocol)))))))
   )


2;;; We can use this elsewhere so create it rather than having it in the parser for
;;; address-entry.
0(define-presentation-type 1internet-address 0()
   :abbreviation-for 'string
   :describer ((stream)
	       (write-string "an Internet address of the form A.B.C.D" stream))
   :parser ((stream)
	    (apply #'format nil "~D.~D.~D.~D"
		   (accept '((sequence-enumerated
			       (integer 1 255) (integer 0 255)
			       (integer 0 4096) (integer 1 4096))
			     :sequence-delimiter #\.
			     :echo-space nil)
			   :stream stream
			   :default nil :prompt nil))))

(define-presentation-type 1chaos-address 0()
   :abbreviation-for 'string
   :describer ((stream)
	       (write-string "A chaos address between 401 and 177776 octal" stream))
   :parser ((stream)
	    (format nil "~O"
		    (accept '((integer #o401 #o177776) :base 8)
			    :stream stream
			    :default nil
			    :prompt nil
			    ))))
(define-presentation-type 1decnet-address 0()
  :abbreviation-for 'string
  :describer ((stream)
	      (write-string "An area and node number of the form A.B" stream))
  :parser ((stream)
	   (apply #'format nil "~D.~D"
		  (accept '((sequence-enumerated 
			      (integer 1 64) (integer 1 1024))
			    :sequence-delimiter #\.
			    :echo-space nil)
			  :default nil
			  :stream stream
			  :prompt nil)))
  )


(define-presentation-type1 neti:phone-number0 ()
   :expander 'string
   :description "a phone number"
   :parser ((stream &key original-type)
	    (let ((token (dw:read-standard-token stream)))
	      (when (string-search-not-set "0123456789" token)
		(error 'dw:input-not-of-required-type :string token :type original-type))
	      token))
   )

(define-presentation-type 1sna-address 0()
   :expander 'string
   :description "a SNA address between 2 and 255"
   :parser ((stream)
	    (format nil "~D"
		    (accept '((integer 2 255))
			    :stream stream
			    :default nil)))
   )

2;;; This is just the pair of a network and an address.  Address-entry-triple includes the
;;; interface.
0(define-presentation-type 1address-entry 0(() &key help-text)
   :expander '((sequence-enumerated net:network string))
   :printer ((entry stream)
	     (cl:apply #'format stream "~A ~A" entry))
   :description "a pair of a network and an address" 
   :parser ((stream )
	    (flet ((check-for-space ()
		     (unless (dw:compare-char-for-accept (dw:read-char-for-accept stream)
							 #\space)
		       (zl:parse-ferror "Must terminate field with space"))))
	      (dw:with-accept-help-if help-text ((:subhelp help-text))
		(let ((network (accept '((net:object :class :network)) :stream stream
				       :additional-blip-chars '(#\space)
				       :default nil
				       :prompt "network")))
		  (check-for-space)
		  (let ((network-address
			  (case (send network :type)
			    (:Internet
			      (accept 'internet-address
				      :stream stream :default nil 
				      :additional-blip-chars '(#\space)))
			    (:Chaos
			      (accept 'chaos-address
				      :stream stream :default nil 
				      :additional-blip-chars '(#\space)))
			    (:DNA
			      (accept 'decnet-address
				      :stream stream :default nil 
				      :additional-blip-chars '(#\space)))
			    (:SNA
			      (accept 'sna-address
				      :stream stream :default nil 
				      :additional-blip-chars '(#\space)))
			    (:Dial
			      (accept 'neti:phone-number
				      :stream stream :default nil 
				      :additional-blip-chars '(#\space)))
			    (:X25
			      (format nil "~A"
				      (accept '((integer 1))
					      :stream stream
					      :default nil
					      :Prompt "A X.121 address" 
					      :additional-blip-chars '(#\space))))
			    (otherwise
			      (accept '((string))
				      :Prompt "A Network Address"
				      :additional-blip-chars '(#\space)
				      :default nil
				      :stream stream
				      )))))
		    (list network network-address)))))))

(define-presentation-type 1address-entry-triple 0(() &key help-text)
   :expander '((sequence-enumerated address-entry string))
   :printer ((entry stream)
	     (cl:apply #'format stream "~A ~A~:[~:;~:*~{ ~A~}~]" entry))
   :description "a pair of a network and an address" 
   :parser ((stream )
	      (dw:with-accept-help-if help-text ((:subhelp help-text))
		(let ((address-pair (accept 'address-entry :stream stream
				       :additional-blip-chars '(#\space #\return)
				       :default nil)))
		  (let ((accept-char (dw:read-char-for-accept stream))
			(address-interface-spec nil))
		    (cond ((dw:compare-char-for-accept accept-char #\space)
			   (setq address-interface-spec
				  (accept '((null-or-type string)) :default nil 
					  :stream stream
					  :prompt "Interface")))
			  ((dw:compare-char-for-accept accept-char #\return)
			   (setq address-interface-spec nil))
			  (t (zl:parse-ferror "Must terminate field with space or return")))
		    (if (and address-interface-spec
			     (plusp (string-length address-interface-spec))
			     (not (string-equal address-interface-spec "None")))
			(append address-pair (list (list address-interface-spec)))
			(append address-pair nil)))))))


2;;; Locations (Printer and Console)
0(define-presentation-type 1location-entry 0(() &key help-text)
   :describer ((stream)
	       (write-string "a building, floor, and location" stream))
   :parser ((stream)
	    (flet ((check-for-space ()
		     (unless (dw:compare-char-for-accept (dw:read-char-for-accept stream)
							 #\space)
		       (zl:parse-ferror "Must terminate field with space"))))
	      (dw:with-accept-help-if help-text ((:subhelp help-text))
		(let ((building
			(accept 'string :stream stream
				:additional-blip-chars '(#\space)
				:default nil
				:prompt "building")))
		  (check-for-space)
		  (let ((floor
			  (accept 'string :stream stream
				  :default nil
				  :additional-blip-chars '(#\space)
				  :prompt "floor")))
		    (check-for-space)
		    (let ((location
			    (accept 'string :stream stream
				    :default nil
				    :prompt "location")))
		      (list building floor location)))))))
   :printer ((entry stream)
	     (apply #'format stream "~A ~A ~A" entry)))

2;;; Affiliations (Boy, it would be nice if this wasn't saved as a !@#$%^*()ing string)
0(define-presentation-type 1affiliation-entry 0(() &key help-text)
   :describer ((stream)
	       (write-string "a character" stream))
   :parser ((stream)
	    (dw:with-accept-help-if help-text ((:subhelp help-text))
	      (format nil "~A"
		      (accept 'character :stream stream :provide-default nil
			      :default nil :prompt nil))))
   :printer ((entry stream)
	     (write-string entry stream)))

2;;; Character-styles (Sigh, more useless translating)
0(define-presentation-type 1character-style-entry 0(() &key help-text)
   :describer ((stream)
	       (write-string "a character style" stream))
   :parser ((stream)
	    (dw:with-accept-help-if help-text ((:subhelp help-text))
	      (si:unparse-character-style
		(accept 'character-style :stream stream :provide-default nil
			:prompt nil :default nil))))
   :printer ((entry stream)
	     (if entry
		 (present (si:parse-character-style entry) 'character-style
			  :stream stream ))))

2;;; Pathnames
0(define-presentation-type 1namespace-pathname 0(() &key help-text)
   :describer ((stream)
	       (write-string "a pathname of a file" stream))
   :parser ((stream)
	    (dw:with-accept-help-if help-text ((:subhelp help-text))
	      (send (accept 'pathname :stream stream :provide-default nil :prompt nil
			    :default nil)
		    :string-for-printing)))
   :printer ((entry stream)
	     (write-string entry stream)))

2;;; Once again, since things are saved as strings, we have to to this...

;;; This does not use the help-text because the default text is misleading since this is now
;;; presented as a time interval.
0(define-presentation-type 1file-control-lifetime 0()
   :describer ((stream)
	       (write-string "a time interval" stream))
   :parser ((stream)
	    (format nil "~A" (accept 'time:time-interval-60ths
				     :stream stream :provide-default nil
				     :prompt nil :default nil)))
   :printer ((entry stream)
	     2;; the call to parse-integer used to go up to si:*largest-fixnum* but it was not
0	     2;; big enough. 189345600000 = 100 years.  If they use anything larger, they
	     ;; deserve to get the debugger.s
0	     (present (si:parse-integer entry nil 10 1 189345600000)
		      'time:time-interval-60ths :stream stream)))

2;;; Host-protocol-desirability
0(define-presentation-type 1host-protocol-desirability 0(() &key help-text)
   :describer ((stream)
	       (write-string "a host, protocol, and desirability between 0 and 1" stream))
   :parser ((stream)
	    (flet ((check-for-space ()
		     (unless (dw:compare-char-for-accept (dw:read-char-for-accept stream)
							 #\space)
		       (zl:parse-ferror "Must terminate field with space"))))
	      (dw:with-accept-help-if help-text ((:subhelp help-text))
		(let ((host
			(accept 'net:host :stream stream
				:additional-blip-chars '(#\space)
				:default nil
				:prompt "host")))
		  (check-for-space)
		  (let ((protocol
			  (accept 'neti:protocol-name :stream stream
				  :default nil
				  :additional-blip-chars '(#\space)
				  :prompt "protocol")))
		    (check-for-space)
		    (let ((desirability
			    (format nil "~A"
				    (accept '((number 0 1)) :stream stream
					    :default nil
					    :prompt "a desirability between 0 and 1"))))
		      (list host protocol desirability)))))))
   :printer ((entry stream)
	     (if entry
		 (format stream "~A ~A ~A" (send (first entry) :name) (second entry)
			 (third entry)))))

(define-presentation-type 1namespace-boolean 0(() &key help-text)
   :parser ((stream)
	    (let ((item
		    (dw::with-accept-help-if help-text ((:subhelp help-text))
		      (accept 'boolean :stream stream
			      ))))
	      (if item "Yes" nil)))
   :describer ((stream)
	       (write-string "No" stream))	2;Only displayed if the field is empty = nil.
0   :printer ((entry stream)
	     (present (string-equal entry "Yes") 'boolean :stream stream)))

;;; This is a list describeing the valid options for the :SPOOL-VIA
;;; option of the :SPOOLED-PRINTER property of :HOST.  Each element of
;;; the list is itself a list.  The CAR of the element is the type for
;;; the :SPOOL-VIA option.  It should be a symbol with the
;;; 'HCI::HARDCOPY-SPOOLER-STREAM-FUNCTION property.  The CDR is a list
;;; each element of which describes a further option for that :SPOOL-VIA
;;; type.  The CAR is a keyword to flag the value and the CADR is a
;;; presentation type.
(defparameter1 spool-via-types
0	      '((:network)
		(:file (:file-name pathname "File name"))
		;; :gould :its-dover
		(:ascii-file (:file-name pathname "File name"))
		))

(defun1 parse-spooled-printer0 (&key (stream *query-io*) (default nil) (query-identifier nil))
  (let* ((unchanged t)
	 (any-known-fields (let ((collection nil))
			     (dolist (type spool-via-types)
			       (dolist (option (cdr type))
				 (pushnew (car option) collection)))
			     collection))
	 (printer (if default (first default)))
	 (default-options (first (rest default)))
	 (known-other-options nil)
	 (home-directory (cadr (assoc :home-directory default-options)))
	 (spooled-via (cadr (assoc :spool-via default-options)))
	 (other-options nil))
    (macrolet ((entry (query-id variable ptype prompt)
		 `(let ((unchanged-p t)
			(ptype ,ptype)
			(current-value ,variable)
			(prompt ,prompt))
		    (multiple-value-setq (,variable nil unchanged-p)
		      (accept ,ptype :stream stream
			      :default (cond ((dw::ptypep current-value ptype)
					      current-value)
					     ((stringp current-value)
					      (accept-from-string ptype current-value))
					     (t nil))
			      :query-identifier (list ',query-id query-identifier)
			      :prompt prompt))
		    (when unchanged
		      (setq unchanged unchanged-p))
		    unchanged-p))
	       (alist-set-default (key alist value)
		 `(let* ((key ,key)
			 (elem (assoc key ,alist))
			 (value ,value))
		   (unless elem
		       (push (list key value) ,alist))))
	       (alist-set (key alist value)
		 `(let* ((key ,key)
			 (elem (assoc key ,alist))
			 (value ,value))
		   (if elem
		       (setf (second elem) value)
		       (push (list key value) ,alist)))))
      (entry printer printer '((net:object :class :printer)) "Spooled Printer")
      (when printer
	(entry home-directory home-directory 'namespace-pathname "  Home Directory")
	(entry spooled-via spooled-via
	       `(dw:member-sequence ,(mapcar #'car spool-via-types))
	       "  Spooled Via")
	(let ((spooled-via-type-options (cdr (assoc spooled-via spool-via-types))))
	  (dolist (d default-options)
	    (unless (member (car d) '(:spool-via :home-directory))
	      (if (member (car d) spooled-via-type-options :key #'car)
		  (alist-set-default (car d) known-other-options (second d))
		  ;; If there is an option which is appropriate for some other spool-via-type
		  ;; but not for this one, assume that the user just changed the type and
		  ;; discard the inappropriate options.  Any totally unknown options should be
		  ;; preserved in case there is something which actually implements them (on an
		  ;; experimental basis for example) but UI for them has not yet been
		  ;; implemented.
		  (unless (member (car d) any-known-fields)
		    (setq other-options (nconc other-options (list d)))))))
	  (dolist (koo spooled-via-type-options)
	    (destructuring-bind (kwd ptype &optional (prompt nil)) koo
	      (let* ((value (second (assoc kwd known-other-options))))
		;; If there was a value for the option, make sure
		;; that value gets put in KNOWN-OTHER-OPTIONS so that we
		;; will return it on exit, but don't add the option if
		;; it wasn't there before and the user didn't edit it.
		(unless (entry kwd value ptype
			       #'(lambda (stream ignore)
				   (format stream "  ~a" (or prompt kwd))))
		  (alist-set kwd known-other-options value)))))
	  (entry other-options other-options
		 '((namespace-set ((namespace-n-set namespace-global-name namespace-token))))
		 "  Other Options"))))
    (if printer
	(values
	  `(,printer
	    (,@(when home-directory
		 `((:home-directory ,home-directory)))
	     ,@(when spooled-via
		 `((:spool-via ,spooled-via)))
	     ,@known-other-options
	     ,@other-options))
	  'spooled-printer unchanged)
	(values nil 'spooled-printer unchanged))))


(defparameter 1*printer-interface-types* 0'(:serial :elp :appletalk :other))


(define-presentation-type 1printer-interface 0(() &key help-text)
   :expander `((member . ,*printer-interface-types*)))

(defun 1parse-printer-interface 0(&key (stream *query-io*) (default nil) (query-identifier nil))
  (let ((interface-type default)
	(unchanged t))
    (multiple-value-bind (interface nil unchanged-p)
	(accept 'printer-interface :stream stream :query-identifier query-identifier
		:default (if (and default (member default *printer-interface-types*))
			     default :other)
		:Prompt "Interface")
      (if unchanged
	  (setq unchanged unchanged-p))
      (if (not unchanged)
	  (setq interface-type interface))
      (if (eq interface :other)
	(multiple-value-bind (other-interface nil unchngd-p)
	    (accept 'namespace-global-name :stream stream
		    :default (if (not (member default *printer-interface-types*)) default)
		    :prompt (format nil "~2@TInterface Type"))
	  (if unchanged
	      (setq unchanged unchngd-p))
	  (if other-interface
	      (setq interface-type other-interface))))
      (values interface-type 'peripheral-interface unchanged))))

(defun 1parse-printer-interface-options
0       (&key (stream *query-io*) (default nil) (query-identifier nil))
  (let ((unchanged t)
	(default-list (loop for item in (copy-tree default) nconc item)))
    (dw:redisplayable-format stream "Interface Options:~%")
    (multiple-value-bind (unit nil unchanged-p)
	(accept '(or ((integer 0 3))
		     string) :stream stream
		:default (when (getf default-list :unit)
			   (condition-case (error)
				(accept-from-string '(or integer string)
						    (getf default-list :unit))
			      (error
				(format *error-output*
					"~&An error occurred while trying to display the default Unit number for this interface.  The default will not be displayed.  ~&Press any key to continue.")
				(read-char *error-output*)
				(setq unchanged nil))))
		:prompt "  Unit"
		:query-identifier (list :unit query-identifier))
      (if unchanged (setq unchanged unchanged-p))
      (multiple-value-bind (baud nil unchanged-p)
	  (accept '((member 300 600 1200 1800 2000 2400 3600 4800 7200 9600 19200 56000))
		  :stream stream
		  :default (when (getf default-list :baud)
			     (condition-case (error)
				  (accept-from-string 'integer (getf default-list :baud))
				(error
				  (format *error-output*
					  "~&An error occurred while trying to display the default Baud Rate for this interface.  The default will not be displayed.  ~&Press any key to continue.")
				  (read-char *error-output*)
				  (setq unchanged nil))))
		  :prompt "  Baud"
		  :query-identifier (list :baud query-identifier))
	(if unchanged (setq unchanged unchanged-p))
	(multiple-value-bind (other-options nil unchanged-p)
	    (accept '((namespace-set
			((namespace-n-set namespace-global-name namespace-token))))
		    :stream stream
		    :default (let ((default-subset default))
			       (loop repeat (length default) do
				 (setq default-subset
				       (remove-if #'(lambda (item)
						      (member (first item) '(:unit :baud)))
						  default-subset)))
			       default-subset)
		    :prompt "  Other Options"
		    :query-identifier (list :other-options query-identifier))
	  (if unchanged (setq unchanged unchanged-p))
	  (values 
	    `(,@(if unit (list (list :unit (format nil "~A" unit))))
	      ,@(if baud (list (list :baud (format nil "~A" baud))))
	      ,@other-options)
	    'printer-options unchanged))))))

(define-presentation-type 1blank-peripheral 0(() &key help-text)
   :describer ((stream)
	       (write-string
		 "a pair of a global name and one or more pairs of a global name and a token"
		 stream))
   :abbreviation-for '((namespace-n-set
			 namespace-global-name
			 ((namespace-set ((namespace-n-set namespace-global-name
							   namespace-token)))))))


(defun1 (:boolean peripheral-presentation-type)0 (ignore) 'boolean)
(defun1 (:keyword peripheral-presentation-type)0 (ignore) 'keyword)

(defun1 (:integer peripheral-presentation-type)0 (ignore &key (radix 10.) range member)
  (if member `((cl:member . ,member)) `((cl:integer . ,range) :base ,radix)))


(define-presentation-type1 neti:modem-model0 ()
   :expander `((cl:member . ,dial:*modem-types*)))

neti:
(define-presentation-type1 serial-terminal-type0 ()
   :expander `((alist-member
		 :alist ,(loop for flavor in telnet:*terminal-simulator-types*
			       collect (flavor:funcall-handler flavor :name))))
   )

neti:
(define-presentation-type 1parity0 ()
  :abbreviation-for '(alist-member
		       :alist (("Even" :even) ("Odd" :odd) ("None" nil))))

(define-presentation-type1 peripheral-device-type0 ()
   :printer ((type stream)
	     (cl:write-string (dw::token-element-string
				(neti:peripheral-device-type-name type))
			      stream))
   :parser ((stream &key original-type)
	    (values
	      (dw:complete-from-sequence neti:*peripheral-device-types*
					 stream
					 :type original-type
					 :name-key #'(lambda (type)
						       (dw::token-element-string
							 (neti:peripheral-device-type-name
							   type)))
					 )))
   :choose-displayer ((stream object query-identifier &key original-type)
		      2;; Put NONE on the left and OTHER on the right.
0		      (dw:accept-values-choose-from-sequence
			stream
			(append (list
					(find :none neti:*peripheral-device-types* :key #'car))
				      (remove :none
					      (remove :other
						      (sort neti:*peripheral-device-types*
							    #'scl:alphalessp :key #'car)
						      :key #'car)
					      :key #'car)
				      (list
					(find :other neti:*peripheral-device-types*
					      :key #'car)))
			object query-identifier
			:type original-type)))

(define-presentation-type 1sdlc-station-address 0()
   :abbreviation-for 'string
   :description "a SDLC station address between 1 and FE hex"
   :parser ((stream)
	    (format nil "~X"
		    (accept '((integer 1 #XFE) :base 16)
			    :stream stream :default nil)))
   )

(defparameter 1*graphics-tablet-defaults*
0	      '((:GTCO  ("1117" "1111" "3648" "4260" "Macintizer"))
		(:Kurta ("Series-Two"))
		(:WACOM ("SD-Series"))))

(define-presentation-type 1graphics-tablet-manufacturer 0()
   :description "a graphics tablet manufacturer"
   :parser ((stream &key original-type initially-display-possibilities)
	    (let ((possibilities (loop for thing in *graphics-tablet-defaults*
					   collect (first thing))))
	      (multiple-value-bind (object success string)
		  (dw:completing-from-suggestions
		    (stream :type original-type
			    :allow-any-input T
			    :initially-display-possibilities initially-display-possibilities)
		    (dolist (item possibilities)
		      (dw:suggest (format nil "~A" item) item)))
		(if success object (intern (string-upcase string) "KEYWORD")))))
)

(define-presentation-type 1graphics-tablet-model 0(() &key manufacturer)
   :description "a graphics tablet manufacturer model"
   :expander 'string
   :parser ((stream &key original-type initially-display-possibilities)
	    (let ((possibilities (if manufacturer
				     (second (assoc manufacturer *graphics-tablet-defaults*))
				     (loop for thing in *graphics-tablet-defaults*
					   append (second thing)))))
	      (multiple-value-bind (object success string)
		  (dw:completing-from-suggestions
		    (stream :type original-type
			    :allow-any-input T
			    :initially-display-possibilities initially-display-possibilities)
		    (dolist (item possibilities)
		      (dw:suggest item item)))
		(if success object string))))
		    
   )

(define-presentation-type 1neti:graphics-tablet 0()
   :abbreviation-for '((sequence-enumerated keyword string))
   :description "a graphics tablet manufacturer and model"
   :printer ((entry stream)
	     (when entry
	       (let ((space-position (string-search #\space entry)))
		 (if (and (stringp entry) space-position)
		     (format stream "~A ~A"
			     (intern (substring entry 0 space-position) "")
			     (substring entry (+ 1 space-position) (length entry)))
		     (format stream "~A" entry)))))
   :parser ((stream)
	    (flet ((check-for-space ()
		     (unless (dw:compare-char-for-accept (dw:read-char-for-accept stream)
							 #\space)
		       (zl:parse-ferror "Must terminate field with space"))))
	      (let ((manufacturer (accept 'graphics-tablet-manufacturer :stream stream
					  :default nil :prompt "manufacturer"
					  :additional-blip-chars '(#\space))))
		(check-for-space)
		(let ((model (accept `((graphics-tablet-model) :manufacturer ,manufacturer)
				     :stream stream :default nil
				     :prompt "model")))
		  (format nil "~A ~A" manufacturer model)))))
   )



2;;; The real work in doing peripherals

;;; Take a plist from a namespace object and produce a list acceptable to parse-peripheral
0(defun 1parse-incoming-peripheral 0(initial-plist)
  (if initial-plist
      (let* ((type (first initial-plist))
	     (plist (first (copy-tree (cdr initial-plist))))
	     (peripheral-type (assoc type neti:*peripheral-device-types*)))
	(when peripheral-type
	  2;; See if everything they have in the plist matches the template
0	  (loop for element in plist do
	    (if (not (or (member (first element) (cdr peripheral-type) :key 'car)
			 (loop for interface in neti:*peripheral-interface-types* do
			   (when (member (first element) (cddr interface) :key 'car)
			     (return t)))))
		2;; If not, set it to nil so we can set it up as :other
0		(setf peripheral-type nil))))
	(if (not peripheral-type)
	    (list :other type plist)
	    (list*
	      (if (listp peripheral-type)
		  (first peripheral-type)
		  peripheral-type)
	      (loop for item in plist nconc item))))
      (list :none)))

2;;; Take the list created by parse-peripheral and make a plist for the host.
0(defun 1unparse-outgoing-peripheral 0(plist)
  (when plist
    (let ((type (first plist)))
      (if (eq type :other)
	  (if (second plist)
	      (second plist)
	      plist)
	  (let ((parsed-plist
		    (loop for (key val) on (rest plist) by 'cddr
			  when val
			    collect
			      (list key
				    (cond
				      ((eq val t) "Yes")
				      ((stringp val) val)
				      (T (format nil "~A" val)))))))
	    (if parsed-plist
		(list type parsed-plist)
		(list type)))))))

(defun 1parse-peripheral 0(&key (stream *query-io*) (default nil) (query-identifier nil))
  (let ((default (parse-incoming-peripheral default))
	(unchanged t))
    (labels ((find-device-type (type)
	       (assoc type neti:*peripheral-device-types*))
	     (find-interface-type (type)
	       (assoc type neti:*peripheral-interface-types*))
	     (parse-options (options query-identifier indent force-if-interface device-type)
	       (loop for option in options
		     as value =
			(parse-next-option
			  option stream default query-identifier indent device-type)
		     when (or value
			      2;; If this is the keyword that specifies the interface type,
0			      2;; always return it in the plist, even if 0nil2 for the value.
0			      (and force-if-interface (find-interface-type (first option))))
		       if (neq (first option) :peripheral-options)	2;Used by :Other
0			 collect (first option) and collect value
		     else collect value))
	     (parse-next-option (option stream default query-identifier indent device-type)
	       (destructuring-bind (option-name option-type . option-args) option
		 (let ((def (if (eq device-type :other)
				(if (keywordp (first default))
				    default
				    (car default))
				(getf default option-name)))
		       (function (get option-type 'peripheral-presentation-type)))
		   (multiple-value-bind (new-value nil unchanged-p)
		       (condition-case (error)
			    (accept (if function
					(cl:apply function option-type option-args)
					(if (dw:presentation-type-p option-type)
					    option-type
					    'string))
				    :prompt (format nil "~v@T~@(~A~)" indent option-name)
				    :query-identifier (list query-identifier option-name)
				    :default (when def
					       (if (stringp def)
						   (accept-from-string
						     (if function
							 (cl:apply
							   function option-type option-args)
							 (if (dw:presentation-type-p
							       option-type)
							     option-type
							     'string)) def)
						   def))
				    :stream stream)
			  2;; In case someone has slipped in something bogus
0			  (error (accept 'string
					 :prompt (format nil "~v@T~@(~A~)" indent option-name)
					 :query-identifier (list query-identifier option-name)
					 :default (if (stringp def)
						      (accept-from-string 'string def))
					 :stream stream)))
		     (if unchanged
			 (setf unchanged unchanged-p))
		     new-value)))))
      (let ((result-list
	      (multiple-value-bind (device-type nil unchanged-p)
		  (accept 'peripheral-device-type
			  :prompt (format nil "Peripheral")
			  :query-identifier query-identifier
			  :default (find-device-type (pop default))
			  :stream stream)
		(if unchanged
		    (setq unchanged unchanged-p))
		(if (and device-type (not (eq (first device-type) :none)))
		    (list*
		      (neti:peripheral-device-type-name device-type)
		      (nconc
			(if (not (eq (first device-type) :other))
			    (let ((interface-type
				    (or (loop for (key) on default by 'cddr
					      thereis (find-interface-type key))
					(find-interface-type :unit))))
			      (parse-options
				(neti:peripheral-interface-type-allowed-options
				  interface-type)
				query-identifier 2 t (first device-type))))
			(parse-options
			  (neti:peripheral-device-type-allowed-options device-type)
			  query-identifier 2 nil (first device-type))))))))
	(values (unparse-outgoing-peripheral result-list) nil unchanged)))))
#||

;;; Testing functions
(defun 1parse-peripheral-test0 (&optional (value nil))
  (let (unchanged)
    (dw:accepting-values ()
      (multiple-value-setq (value nil unchanged)
	(parse-peripheral :default value)))
    (values value unchanged)))

(defun 1test-all-peripherals 0()
  (loop for host in (neti:find-objects-from-property-list :host :peripheral '((:*))) do
    (send host :check-validity nil t)
    (loop for peripheral in (send host :peripheral) do
      (let ((result (parse-peripheral-test peripheral)))
	(when (or (neq (first peripheral) (first result))
		  (loop for (key val) in (cadr peripheral) and
			(new-key new-val) in (cadr result) do
		    (if (or (neq key new-key)
			    (not (string-equal val new-val)))
			(return t))))
	  (beep)
	  (format t "~&The input and output do not match for ~&~A ~&~A" peripheral result))
	(terpri)))))

||#

