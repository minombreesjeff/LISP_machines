;;; -*- Mode: LISP; Syntax: Common-Lisp; Base: 10; Package: COMMON-LISP-NETWORK-INTERNALS; Lowercase: Yes -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");;; Site0 1Configuration commands0 1and functions (moved from sys:cp;utility-commands.lisp)

0(define-presentation-type (2 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")primary-network 0()
   :parser ((stream &key original-type initially-display-possibilities)
	    (multiple-value-bind (network nil nil)
	      (dw:completing-from-suggestions (stream :force-complete t
						      :partial-completers '(#\Space)
						      :initially-display-possibilities
						      initially-display-possibilities
						      :type original-type)
		(loop for net in neti:*local-networks*
		      when (neti:get-primary-address-entry-of-type (send net :type))
			do (dw:suggest (format nil "~A" net) net)))
	      network))
   :printer ((network stream)
	     (format stream "~A" network))
   :description "the name of a local primary network")

1;;; Heavily borrowed from the address-entry presentation type from the
;;; namespace-presentation-types but this one only allows primary networks
0(define-presentation-type 2namespace-server-address 0(() &key help-text)
   :printer ((entry stream)
	     (cl:apply #'format stream "~A ~A" entry))
   :description "a pair of a network and an address" 
   :parser ((stream)
	    (flet ((check-for-space ()
		     (unless (dw:compare-char-for-accept (dw:read-char-for-accept stream)
							 #\space)
		       (zl:parse-ferror "Must terminate field with space"))))
	      (dw:with-accept-help-if help-text ((:subhelp help-text))
		(let ((network (accept '((primary-network))
				       :stream stream
				       :additional-blip-chars '(#\space)
				       :default nil
				       :prompt "network")))
		  (check-for-space)
		  (let ((network-address
			  (case (send network :type)
			    (:Internet
			      (accept 'internet-address
				      :stream stream :default nil))
			    (:Chaos
			      (accept 'chaos-address
				      :stream stream :default nil))
			    (otherwise
			      (accept '((string))
				      :Prompt "A Network Address"
				      :default nil
				      :stream stream
				      )))))
		    (list network network-address)))))))


1;;; A more specific version of NETI:PROTOCOL-NAME that provides a protocol name for all
;;; mediums on a network
0(define-presentation-type 2protocol-name-for-service-using-network
0      ((service network &key allow-any-input))
   :expander 'keyword
   :printer ((object stream) (write-string (string-upcase object) stream))
   :parser ((stream &key original-type initially-display-possibilities)
	    (multiple-value-bind (object success string)
		(dw:completing-from-suggestions
		  (stream :type original-type
			  :allow-any-input allow-any-input
			  :initially-display-possibilities initially-display-possibilities)
		  1;; When both the service and the medium are provided, we can check all the
0		  1;; protocols that implement SERVICE over MEDIUM.  When just SERVICE is
0		  1;; provided, we can find all the protocols that implement it.
0		  (dolist (protocol neti:*protocol-list*)
		    (when (eq service (neti:protocol-service protocol))
		      (let ((protocol-name (neti:protocol-name protocol)))
			(dolist (medium neti:*medium-list*)
			  (dolist (real-medium (find-base-medium-for-medium medium))
			    (when (send network :possible-medium-for-protocol protocol-name
					real-medium)
			      (dw:suggest (string protocol-name) protocol-name)))))))
		  (dolist (service-triple *known-but-unimplemented-protocols*)
		    (when (and (eq service (first service-triple))
			       (send network :supports-protocol-on-medium
				     (third service-triple) (second service-triple)))
		      (let ((name (third service-triple)))
			(dw:suggest (string name) name)))))
	      (if success object (intern (string-thin (string-upcase string)) ""))))
   :description "a protocol"
   )

(define-presentation-type 2system-type 0((&key allow-any-input))
   :expander 'keyword
   :printer ((object stream) (write-string (string-upcase object) stream))
   :parser ((stream &key original-type initially-display-possibilities)
	    (multiple-value-bind (object success string)
		(dw:complete-from-sequence neti:all-system-types stream
					   :type original-type
					   :allow-any-input allow-any-input
					   :initially-display-possibilities
					   initially-display-possibilities)
	      (if success object (intern (string-thin (string-upcase string)) ""))))
   :description "a system type")


1;;; This is a string that has a ":" in it so we know we have a host.  It can't be a pathname
;;; since the host might not be known.  We also strip off any excess spaces.
0(define-presentation-type 2pseudo-pathname 0()
   :expander 'string
   :parser ((stream &key original-type initially-display-possibilities)
	    (let ((pathname
		    (accept 'string :stream stream :original-type original-type :default nil
			    :initially-display-possibilities initially-display-possibilities)))
	      (when pathname
		(if (not (string-search #\: pathname))
		    (zl:parse-ferror "No host component in pathname")
		    (string-trim '(#\space) pathname))))))

1;;; Simple site finding using broadcast.  Called from :Set Site
0(defun 2find-site-using-broadcast 0()
  (loop with done = nil until done doing
    (multiple-value-bind (site host server)
			 (neti:find-local-site-via-broadcast)
      (if site
	  (return-from find-site-using-broadcast  site)
	  1;; We lost, find out what we got and ask the user if they want to try again
0	  (cond ((not server)
		 1;; Nobody responded
0		 (setq done
		       (not (y-or-n-p "No server responded.  Try again? "))))
		((or (null host) (not (stringp host)))
		 1;; Somebody responded but they didn't know our host
0		 (setq done
		       (not (y-or-n-p
			      (format nil
				      "The server ~A does not know the local host.  Perhaps a namespace object for the local host does not exist.  Try again? " server)))))
		(t
		 (setq done
		       (not (y-or-n-p
			      (format nil "The server ~A thinks the local host is ~A but we were unable to find the right site.  Try again?" server host))))))))))

1;;; This is a bit harder.  We have to prompt the user through the various things necessary to
;;; set the site.  This can be just the name and address of the server or it can be complete
;;; host descriptions needed to access file hosts to load the namespace files.  Things are
;;; done with an AVV that expands and contracts depending on the information necessary.
0(defun 2find-site-with-dialog 0(site)
  (format *query-io* "Parameters for site ~A" (string-upcase site))
  (flet ((fixed-line (string)
	   (dw:with-redisplayable-output (:unique-id string
					  :cache-value string
					  :stream *query-io*)
1;0	       (terpri *query-io*)
	       (cl:write-line string *query-io*))))
  (let (server-name server-address-entry descriptor-file file-host-address file-host-name
	file-host-protocol namespace-name file-host-system-type server-real-name
	server-is-local-host
	#+IMach file-host-is-emb-host)
    (flet ((embedded-dialog ()
	     #+IMach
	     (sys:system-case
	       ((VLM UX)
		(fixed-line "")
		(dw:redisplayable-format *query-io*
		  "Since the Namespace Descriptor File is on the Unix host (i.e., the ~A),~%"
		  (neti:emb-machine-type))
		(fixed-line "the name of the Unix host in the new site must be provided.")
		(setq file-host-name
		      (accept '((string)
				:description "The real name of the Unix host in the site")
			      :prompt " Real Name of Unix Host"
			      :default nil :confirm t))
		(when (and server-is-local-host (neti:ns-eq server-name net:*local-host*))
		  (fixed-line "")
		  (dw:redisplayable-format *query-io*
		    "The name of the local host (i.e., the ~A) in the new site ~
		     must be provided.~%"
		    (neti:local-machine-type))
		  (setq server-real-name
			(accept '((string)
				  :description "The real name of the local host in the site")
				:prompt " Real Name of Local Host"
				:default nil :confirm t)))
		(setq file-host-system-type :UNIX42
		      file-host-address (first (send net:*emb-host* :address))
		      file-host-protocol :NFS))
	       (MacIvory
		 ;; The MacIvory accesses the Macintosh FS directly.
		 nil)
	       (otherwise (error))))
	   (standalone-dialog (host-name)
	     (setq file-host-name host-name)
	     (when (and server-is-local-host (neti:ns-eq server-name net:*local-host*))
	       (fixed-line "")
	       (fixed-line "Since the Namespace Descriptor File is not on the local host,")
	       (fixed-line "the name of the local host in the new site must be provided.")
	       (setq server-real-name
		     (accept '((string)
			       :description "The real name of the local host in the site")
			     :prompt " Real Name of Local Host"
			     :default nil :confirm t)))
	     (fixed-line "")
	     (dw:redisplayable-format
	       *query-io*
	       "Additional attributes needed to define host ~A:~%" file-host-name)
	     (setq file-host-system-type
		   (accept '((system-type :allow-any-input t))
			   :default nil
			   :prompt (format nil " System type for ~A" file-host-name)
			   :confirm t))
	     (setq file-host-address
		   (accept 'namespace-server-address
			   :prompt (format nil " Address for ~A" file-host-name)
			   :default nil :confirm t))
	     (when file-host-address
	       (setq file-host-protocol
		     (accept `(protocol-name-for-service-using-network
				:file ,(first file-host-address))
			     :default nil :confirm t
			     :prompt (format nil " File Protocol for accessing ~A"
					     file-host-name))))))
      (dw:accepting-values (*query-io* :resynchronize-every-pass t)
	(setq namespace-name (accept
			       '((keyword)
				 :description
				 (format nil
					 "The name of the namespace that site ~A is in" site))
			       :prompt "Namespace Name"
			       :default (intern (string-upcase site) :KEYWORD)
			       :confirm t))
	(multiple-value-bind (server nil unchanged)
	    (accept '((type-or-string neti:local-host)
		      :description "the name of the primary namespace server")
		    :Prompt "Namespace Server Name" :default nil :confirm t)
	  (setq server-name server)
	  (unless unchanged			1;When the name has changed clear everything.
0	    (setq server-address-entry nil
		  descriptor-file nil
		  server-is-local-host nil
		  file-host-is-emb-host nil)))
	(when server-name
	  1;; Once we have a server name, we start the process of gathering more information.  
	  ;; If0 1the server is local, get the descriptor file, if not, get the network address.
	  ;; We have to go through a lot of hair in here since most of this stuff is very state
	  ;; sensitive.  There has to be a lot of checks to see if something we assumed has
	  ;; changed.
0	  (when (neti:ns-eq server-name net:*local-host*)
	    (setq server-is-local-host t))
	  (when (or server-address-entry
		    (not server-is-local-host))		  
	    (setq server-address-entry
		  (accept 'namespace-server-address :prompt "Namespace Server Address"
			  :default nil :confirm t))
	    1;; Check to see if the user entered the address of the local host.  If so, the
	    ;; server is the local host.
0	    (setq server-is-local-host
		  (and server-address-entry
		       (string-equal (second server-address-entry)
				     (let ((entry (neti:get-primary-address-entry-of-type
						    (send (first server-address-entry)
							  :type))))
				       (when entry
					 (neti:primary-address-address-string entry))))))
	    (when (and server-address-entry (not server-is-local-host))
	      (setq descriptor-file nil)))
	  (when (or server-is-local-host descriptor-file)
	    (setq descriptor-file
		  (accept '((or pathname pseudo-pathname) :description
			    "pathname of namespace descriptor file")
			  :prompt "Namespace Descriptor File"
			  :default
			  (or descriptor-file
			      (pathname
				(format nil
				  #+VLM
				  ;; VLM has no local LMFS so offer a path on the AXP ...
				  "HOST:/var/lib/symbolics/sys.sct/site/~A-namespace.text"
				  #-VLM
				  "LOCAL:>sys>site>~A-namespace.text"
				  (string-downcase site))))
			  :confirm t)))
	  (when server-is-local-host
	    (setq server-real-name server-name))
	  1;; Check the descriptor file to make sure that it is local, if not, we have to find
	  ;; out about the file host.
0	  (if descriptor-file
	      (let ((host-name (if (pathnamep descriptor-file)
				   (send (send descriptor-file :host) :name)
				 (let ((idx (or (string-search #\| descriptor-file)	1;|
0						(string-search #\: descriptor-file))))
				   (substring descriptor-file 0 idx)))))
		#+IMach
		(sys:system-case
		  (Embedded
		    1;; Check for a descriptor file on the embedding host.
0		    (when (or (string-equal host-name "HOST")
			      (and (boundp 'net:*emb-host*)
				   (string-equal host-name (send net:*emb-host* :name))))
		      (setq file-host-is-emb-host t)))
		  (otherwise nil))
		(when (not (or (string-equal host-name server-name)
			       (string-equal host-name "Local")
			       (string-equal host-name (send net:*local-host* :name))))
		  #+IMach
		  (if file-host-is-emb-host
		      (embedded-dialog)
		      (standalone-dialog host-name))
		  #-IMach
		  (standalone-dialog host-name)))
	      (setq file-host-name nil
		    file-host-is-emb-host nil
		    file-host-address nil
		    file-host-protocol nil
		    file-host-system-type nil)))))
    #+IMach
    (when file-host-is-emb-host
      1;; Make sure that the pathname specifies the new name of the embedding host
      ;; (i.e., the Unix box) rather than "HOST" or its name in the current site.
0      (sys:system-case
	((VLM UX)
	 (let ((filename (if (pathnamep descriptor-file)
			     (send descriptor-file :string-for-host)
			     (substring descriptor-file
					(1+ (string-search #\: descriptor-file))))))
	   (setq descriptor-file (format nil "~A:~A" file-host-name filename))))
	(MacIvory
	  1;; The MacIvory can access the Macintosh FS directly using the "HOST" mechanism.
0	  nil)
	(otherwise (error))))
    1;; Whew!  We now theoretically have everything we need from the user, let's do it!
0    1;; Pass the information on to the relevant function to find the site.  
0    (setq site (intern (string-upcase site) "KEYWORD"))
    1;; Each of the below should return a site object or nil
0    (if (not server-is-local-host)
	(neti:find-site-given-server-address namespace-name site server-name
						(first server-address-entry)
						(second server-address-entry))
	(if file-host-name
	    (neti:create-a-host-named file-host-name file-host-system-type
				      :addresses (list file-host-address)
				      :file-protocol file-host-protocol)
	    (fs:add-file-computer net:*local-host*))
	(neti:find-site-from-descriptor-file
	  namespace-name site descriptor-file
	  (if (stringp server-real-name) server-real-name nil))))))

1;;; All of the prompting for setting the site is here.  This replaces the functionality of
;;; NET:SET-SITE and calls everything to set the site directly.  NET:SET-SITE still exists for
;;; backward compatibility
0(cp:define-command (2com-set-site0 :command-table "Namespace"
				 :provide-output-destination-keyword nil)
    ((site '((scl:type-or-string (scl:token-or-type (("Get from network" . attempt-broadcast))
						    neti:site)))
	   :default 'attempt-broadcast
	   :prompt "site name"
	   :documentation "name of site and namespace to be set"))
   (fs:with-automatic-login-to-sys-host
     (let ((real-site
	     (cond ((eq site 'attempt-broadcast)
		    1;; Simple case:  Handle it first.
0		    (find-site-using-broadcast))
		   ((typep site 'neti:site)
		    1;; They gave us a site we already know about
0		    (if (eq site net:*local-site*)
			(format *error-output*	1;returns nil...
0				"~& You are already at the site ~A, so there is no need to change sites." site)
			site))
		   (t
		    (find-site-with-dialog site)))))
       (if (null real-site)
	   (format *error-output* "~&Site not changed.")
	   (let ((really-do-it t))
	     (unless (or (eq net:*local-site* neti:*distribution-site*)
			 (eq real-site neti:*distribution-site*))
	       (if (yes-or-no-p
		     "~& The local site is not the distribution site.  You must change to the distribution site first.  ~&  Are you sure you want to do this? ")
		   (neti:change-to-distribution-site)
		   (setq really-do-it nil)))
	     (when really-do-it
	       1;; Here we go....
0	       (neti:change-local-site-and-host real-site)
	       (send net:*namespace* :get-latest-timestamp)))))))

(cp:define-command (2com-define-site0 :command-table "Namespace"
				    :provide-output-destination-keyword nil)
    ((site '((scl:type-or-string neti:site :reject-null-string t))
	   :prompt "site name"
	   :documentation "name of site and namespace to be created"))
   (fs:with-automatic-login-to-sys-host
     (let ((define-it t))
       (unless (stringp site)			; presentation system couldn't find a site
						; with this name
	 (setq define-it
	       (yes-or-no-p
		 (format
		   nil
		   "These is already a site named ~A. Are you sure that you want to proceed? "
		   site))))
       (when define-it
	 (define-site-dialog (intern (string-upcase (string site)) "KEYWORD"))))))


1;;; Now, the hard part....
0(defun 2define-site-dialog 0(site)
1  ;; NB!  The site and namespace are assumed to have the same name here.  If the user wants to
  ;; define another site in a namespace, they can use the namespace editor.
0  (format *standard-output*
	  "~&Defining site ~A with the local host as the Primary Namespace Server~%" site)
  1;; Define a plist to hold the host-name, site-directory, descriptor-file, sys-host-name,
  ;; sys-host-address, sys-host-type, sys-host-protocol, NS-host-name, NS-host-address,
  ;; NS-host-type, NS-host-protocol, etc.
0  (let ((plist nil))
    (error-restart (error "Respecify site parameters")	1;Allow respecification on error
0      (dw:accepting-values (*query-io* :resynchronize-every-pass t)
	(setf (getf plist :host-name)
	      (accept '((string)
			:description "the name of the primary namespace server")
		      :Prompt "Namespace Server Name" :default (getf plist :host-name)
		      :confirm t))
	(when (getf plist :host-name)
	  (setf (getf plist :host-name) (string-trim '(#\space) (getf plist :host-name)))
	  1;; Since site definition is so different for Unix embeddings, do it as a separate
0	  1;; dialog.
0	  (setq plist
		(if #+IMach (sys:system-case ((Solstice VLM) T) (otherwise NIL))
		    #+3600 NIL
		    (define-site-dialog-for-unix-embeddings site plist)
		    (define-site-dialog-for-standard-platforms site plist)))
	  (setf (getf plist :default-login)
		(string-trim
		  `(#\space)
		  (accept '((string) :description "a valid user login")
			  :default (let ((default (getf plist :default-login)))
				     (if default default "Lisp-Machine"))
			  :prompt "Default Login" :confirm t)))
	  (setf (getf plist :bug-host-name)
		(accept '((string)
			  :description "the name of the host that will accept bug-report mail")
			:Prompt "Host for Bug Reports" :default (getf plist :host-name)
			:confirm t))
	  (let ((bug-host (getf plist :bug-host-name)))
	    1;; Get the other attributes for the bug-host when it is not one of the already
	    ;; mentioned hosts
0	    (when (and bug-host
		       (not (string-equal bug-host (getf plist :host-name)))
		       (not (string-equal bug-host (getf plist :sys-host-name)))
		       (not (string-equal bug-host (getf plist :ns-host-name))))
	      (setf (getf plist :bug-host-type)
		    (accept 'system-type :confirm t :default (getf plist :bug-host-type)
			    :prompt (string-append "System Type for " bug-host)))
	      (setf (getf plist :bug-host-address)
		    (accept 'namespace-server-address
			    :prompt (string-append "Address for " bug-host)
			    :default (getf plist :bug-host-address) :confirm t))))
	  (setf (getf plist :timezone)
		(accept 'time:timezone :prompt "Local Timezone" :confirm t
			:default (let ((default (getf plist :timezone)))
				   (if default default time:*timezone*))))
	  (setf (getf plist :standalone-p)
		(accept 'boolean :confirm t :default t :prompt "Standalone Site"))))
      (let ((do-it t))
	(unless (eq net:*local-site* neti:*distribution-site*)
	  (if (yes-or-no-p
		"The local site is not the distribution site.
~& The site will be changed to the distribution site before continuing the site definition.
~& Are you sure you want to do this? "
		)
	      (neti:change-to-distribution-site)
	      (setq do-it nil)))
	(when do-it
	  (create-site site plist))))))

1;;; Called from inside an dw:accepting-values
0(defun 2define-site-dialog-for-standard-platforms 0(site plist)
  (let ((host-name (getf plist :host-name)))
    (setf (getf plist :site-directory)
	  (accept '((pseudo-pathname)
		    :description
		    "the directory that will hold the system files (SYS:SITE;)")
		  :default (let ((default (getf plist :site-directory)))
			     (if default default (string-append host-name ":>sys>site>")))
		  :confirm t :Prompt "System File Directory"))
    (setf (getf plist :descriptor-file)
	  (accept '((pseudo-pathname)
		    :description "pathname of the namespace descriptor file")
		  :default (let ((default (getf plist :descriptor-file)))
			     (if default default
				 (string-append host-name ":>sys>site>" site
						"-namespace.text")))
		  :confirm t :Prompt "Namespace Descriptor File"))
    (let ((site-directory (getf plist :site-directory)))
      (when site-directory
	1;; extract the host from the site-directory and try to get the parameters for it.
0	(let ((sys-host (let ((idx (or (string-search #\| site-directory)	1;|
0				       (string-search #\: site-directory))))
			  (substring site-directory 0 idx))))
	  (cond ((or (string-equal sys-host "local")
		     (string-equal sys-host host-name))
		 (setf (getf plist :sys-host-name) host-name))
		(t
		 (setf (getf plist :sys-host-name) sys-host)
		 (setf (getf plist :sys-host-type)
		       (accept 'system-type :confirm t :default (getf plist :sys-host-type)
			       :prompt (string-append "System Type for " sys-host)))
		 (setf (getf plist :sys-host-address)
		       (accept 'namespace-server-address
			       :prompt (string-append "Address for " sys-host)
			       :default (getf plist :sys-host-address) :confirm t))
		 (let ((sys-host-address (getf plist :sys-host-address)))
		   (when sys-host-address
		     (setf (getf plist :sys-host-protocol)
			   (accept `(protocol-name-for-service-using-network
				      :file ,(first sys-host-address))
				   :default (getf plist :sys-host-protocol) :confirm t
				   :prompt (string-append "File Protocol for accessing "
							  sys-host))))))))
	(let ((descriptor-file (getf plist :descriptor-file))
	      (sys-host-name (getf plist :sys-host-name)))
	  (when (and descriptor-file sys-host-name)
	    (let ((ns-host (let ((idx (or (string-search #\| descriptor-file)	1;|
0					  (string-search #\: descriptor-file))))
			     (substring descriptor-file 0 idx))))
	      (cond ((or (string-equal ns-host "local")
			 (string-equal ns-host host-name))
		     (setf (getf plist :ns-host-name) host-name))
		    ((string-equal ns-host sys-host-name)
		     (setf (getf plist :ns-host-name) sys-host-name))
		    (t
		     (setf (getf plist :ns-host-name) ns-host)
		     (setf (getf plist :ns-host-type)
			   (accept 'system-type :confirm t :default (getf plist :ns-host-type)
				   :prompt
				   (string-append "System Type for " ns-host)))
		     (setf (getf plist :ns-host-address)
			   (accept 'namespace-server-address
				   :prompt (string-append "Address for " ns-host)
				   :default (getf plist :ns-host-address) :confirm t))
		     (let ((server-address (getf plist :ns-host-address)))
		       (setf (getf plist :ns-host-protocol)
			     (accept `(protocol-name-for-service-using-network
					:file ,(first server-address))
				     :default (getf plist :ns-host-protocol) :confirm t
				     :prompt (string-append "File Protocol for accessing "
							    ns-host))))))))))))
  plist)

#+imach
1;;; Very similar to the above but different in enough ways that it is too hairy to combine.
;;; 0Note:1  The VLM running on a DEC AXP under OSF/1 is considered to be a Unix embedding
;;; as far as 0:Define Site1 is concerned.  (The VLM has no local LMFS; the namespace files
;;; must reside on the AXP.)
0(defun 2define-site-dialog-for-unix-embeddings 0(site plist)
  (let ((host-name (getf plist :host-name)))
    (setf (getf plist :site-directory)
	  (accept '((pseudo-pathname)
		    :description
		    "the directory that will hold the system files (SYS:SITE;)")
		  :default (let ((default (getf plist :site-directory)))
			     (if default default
			       (sys:system-case
				 (VLM "HOST:/var/lib/symbolics/sys.sct/site/")
				 (otherwise "HOST:/usr/share/symbolics/sys.sct/site/"))))
		  :confirm t :Prompt "System File Directory"))
    (setf (getf plist :descriptor-file)
	  (accept '((pseudo-pathname)
		    :description "pathname of the namespace descriptor file")
		  :default (let ((default (getf plist :descriptor-file)))
			     (if default default
			       (string-append (getf plist :site-directory)
					      (string-downcase site)
					      "-namespace.text")))
		  :confirm t :Prompt "Namespace Descriptor File"))
    (let ((site-directory (getf plist :site-directory)))
      (when site-directory
	1;; extract the host from the site-directory and try to get the parameters for it.
0	(let ((sys-host (let ((idx (or (string-search #\| site-directory)	1;|
0				       (string-search #\: site-directory))))
			  (substring site-directory 0 idx))))
	  (flet ((emb-host-query (default)
		   (setf (getf plist :host-embedded-in)
			 (flet ((emb-host-description (stream &rest ignore)
				  (format stream
					  #-VLM "the name of the ~A host in ~
						 which the ~A is embedded"
					  #+VLM "the name of the ~A host on ~
						 which Open Genera is running"
					  (neti:emb-machine-type)
					  (neti:local-machine-type))))
			   (accept `((string)
				     :description ,#'emb-host-description)
				   :prompt "Unix Host Name"
				   :confirm t :default default)))
		   (setf (getf plist :host-embedded-in-type)
			 (send net:*emb-host* :system-type))
		   (setf (getf plist :host-embedded-in-address)
			 (first (send net:*emb-host* :address)))
		   (setf (getf plist :host-embedded-in-machine-type)
			 (send net:*emb-host* :machine-type))
		   (setf (getf plist :host-embedded-in-protocol)
			 (let ((path (net:find-path-to-service-on-host :file net:*emb-host*)))
			   (when path
			     (neti:protocol-name (neti:service-access-path-protocol path)))))))
	    (cond ((or (string-equal sys-host "local")
		       (string-equal sys-host host-name))
		   (setf (getf plist :sys-host-name) host-name)
		   (emb-host-query (getf plist :host-embedded-in)))
		  ((string-equal sys-host "host")
		   (emb-host-query (getf plist :sys-host-name))		   
		   (setf (getf plist :sys-host-name) (getf plist :host-embedded-in))
		   (setf (getf plist :sys-host-type) (getf plist :host-embedded-in-type))
		   (setf (getf plist :sys-host-address) (getf plist :host-embedded-in-address))
		   (setf (getf plist :sys-host-machine-type)
			 (getf plist :host-embedded-in-machine-type))
		   (setf (getf plist :sys-host-protocol)
			 (getf plist :host-embedded-in-protocol)))
		  (t
		   (emb-host-query (getf plist :host-embedded-in))
		   (setf (getf plist :sys-host-name) sys-host)
		   (setf (getf plist :sys-host-type)
			 (accept 'system-type :confirm t :default (getf plist :sys-host-type)
				 :prompt (string-append "System Type for " sys-host)))
		   (setf (getf plist :sys-host-address)
			 (accept 'namespace-server-address
				 :prompt (string-append "Address for " sys-host)
				 :default (getf plist :sys-host-address) :confirm t))
		   (let ((sys-host-address (getf plist :sys-host-address)))
		     (when sys-host-address
		       (setf (getf plist :sys-host-protocol)
			     (accept `(protocol-name-for-service-using-network
					:file ,(first sys-host-address))
				     :default (getf plist :sys-host-protocol) :confirm t
				     :prompt (string-append "File Protocol for accessing "
							    sys-host)))))))))
	(let ((descriptor-file (getf plist :descriptor-file))
	      (sys-host-name (getf plist :sys-host-name)))
	  (when (and descriptor-file sys-host-name)
	    (let ((ns-host (let ((idx (or (string-search #\| descriptor-file)	1;|
0					  (string-search #\: descriptor-file))))
			     (substring descriptor-file 0 idx))))
	      (cond ((or (string-equal ns-host "local")
			 (string-equal ns-host host-name))
		     (setf (getf plist :ns-host-name) host-name))
		    ((or (string-equal ns-host sys-host-name)
			 (string-equal ns-host "host"))
		     (setf (getf plist :ns-host-name) sys-host-name))
		    (t
		     (setf (getf plist :ns-host-name) ns-host)
		     (setf (getf plist :ns-host-type)
			   (accept 'system-type :confirm t :default (getf plist :ns-host-type)
				   :prompt
				   (string-append "System Type for " ns-host)))
		     (setf (getf plist :ns-host-address)
			   (accept 'namespace-server-address
				   :prompt (string-append "Address for " ns-host)
				   :default (getf plist :ns-host-address) :confirm t))
		     (let ((server-address (getf plist :ns-host-address)))
		       (setf (getf plist :ns-host-protocol)
			     (accept `(protocol-name-for-service-using-network
					:file ,(first server-address))
				     :default (getf plist :ns-host-protocol) :confirm t
				     :prompt (string-append "File Protocol for accessing "
							    ns-host))))))))))))
  plist)

1;;; Takes a site-and-namespace-name and plist generated by define-site-dialog and writes out
;;; the files and switches the site.
0(defun 2create-site 0(site plist)
  (setf (getf plist :host-name) (string-upcase (getf plist :host-name)))
  (setf (getf plist :sys-host-name) (string-upcase (getf plist :sys-host-name)))
  (setf (getf plist :ns-host-name) (string-upcase (getf plist :ns-host-name)))
  (setf (getf plist :bug-host-name) (string-upcase (getf plist :bug-host-name)))
  (setf (getf plist :host-embedded-in) (string-upcase (getf plist :host-embedded-in)))
  1;; First, we need to create temporary host objects for the local host with the new name and
  ;; any other servers necessary.
0  (let* ((local-host (neti:create-a-host-named
		       (getf plist :host-name) (send net:*local-host* :system-type)
		       :addresses (send net:*local-host* :address) :site site
		       :machine-type (neti:local-machine-type)
		       :embedded-in (getf plist :host-embedded-in)))
	 (sys-host (if (string-equal (getf plist :host-name) (getf plist :sys-host-name))
		       local-host
		       (neti:create-a-host-named
			 (getf plist :sys-host-name) (getf plist :sys-host-type)
			 :addresses (list (getf plist :sys-host-address)) :site site
			 :file-protocol (getf plist :sys-host-protocol)
			 :machine-type (getf plist :sys-host-machine-type))))
	 (embedded-in-host
	   (let ((name (getf plist :host-embedded-in)))
	     (cond ((string-equal name (getf plist :host-name))
		    local-host)
		   ((string-equal name (getf plist :sys-host-name))
		    sys-host)
		   (t
		     (neti:create-a-host-named
		       (getf plist :host-embedded-in) (getf plist :host-embedded-in-type)
		       :addresses (list (getf plist :host-embedded-in-address)) :site site
		       :file-protocol (getf plist :host-embedded-in-protocol)
		       :machine-type (getf plist :host-embedded-in-machine-type))))))
	 (ns-data-host (let ((name (getf plist :ns-host-name)))
			 (cond ((string-equal name (getf plist :host-name))
				local-host)
			       ((string-equal name (getf plist :sys-host-name))
				sys-host)
			       ((string-equal name (getf plist :host-embedded-in))
				embedded-in-host)
			       (t
				(neti:create-a-host-named
				  (getf plist :ns-host-name) (getf plist :ns-host-type)
				  :addresses (list (getf plist :ns-host-address)) :site site
				  :file-protocol (getf plist :ns-host-protocol))))))
	 (bug-host (let ((name (getf plist :bug-host-name)))
		     (cond ((string-equal name (getf plist :host-name))
			    local-host)
			   ((string-equal name (getf plist :sys-host-name))
			    sys-host)
			   ((string-equal name (getf plist :host-embedded-in))
			    embedded-in-host)
			   ((string-equal name (getf plist :ns-host-name))
			    ns-data-host)
			   (t
			    (neti:create-a-host-named
			      (getf plist :bug-host-name) (getf plist :bug-host-type)
			      :addresses (list (getf plist :bug-host-address))))))))
    (fs:add-file-computer local-host)
    (unless (eq local-host sys-host)
      (fs:add-file-computer sys-host))
    (unless (or (eq embedded-in-host local-host)
		(eq embedded-in-host sys-host))
      (fs:add-file-computer embedded-in-host))
    (unless (or (eq ns-data-host local-host)
		(eq ns-data-host sys-host)
		(eq ns-data-host embedded-in-host))
      (fs:add-file-computer ns-data-host))
    1;; Parse the pathnames, fixing up any references to "Local" or "Host"
0    (let* ((site-directory (let* ((name (getf plist :site-directory))
				  (idx (string-search #\: name))
				  (bar-idx (string-search #\| name))	1;|
0				  (host (substring name 0  (or bar-idx idx))))
			     (cond ((string-equal host "host")
				    (pathname
				      (string-append (getf plist :sys-host-name)
						     (substring name idx))))
				   ((string-equal host "local")
				    (pathname
				      (string-append (getf plist :host-name)
						     (substring name (or bar-idx idx)))))
				   (t (pathname name)))))
	   (descriptor-file (let* ((name (getf plist :descriptor-file))
				   (idx (string-search #\: name))
				   (bar-idx (string-search #\| name))	1;|
0				   (host (substring name 0  (or bar-idx idx))))
			      (cond ((string-equal host "host")
				     (pathname
				       (string-append (getf plist :ns-host-name)
						      (substring name idx))))
				    ((string-equal host "local")
				     (pathname
				       (string-append (getf plist :host-name)
						      (substring name (or bar-idx idx)))))
				    (t (pathname name)))))
	   1;; This is needed so we don't go over the network to access the local host when the
	   ;; files are store locally
0	   (local-site-directory (if (neq (send site-directory :host) local-host)
				     site-directory
				     (fs:add-file-computer net:*local-host*)
				     (pathname
				       (string-append "local:" (neti:pathname-hostless-string
								site-directory)))))
	   (local-descriptor-file (if (neq (send descriptor-file :host) local-host)
				      descriptor-file
				      (fs:add-file-computer net:*local-host*)
				      (pathname
					(string-append "local:" (neti:pathname-hostless-string
								 descriptor-file)))))
	   (sys-translations nil))
      1;; OK, now that we have hosts, let's see if the site directory the user provided is good.
0      (let ((dir (send site-directory :directory)))
	(cond ((null dir)
	       (error "The site directory ~A has no directory component" site-directory))
	      ((not (string-equal (car (last dir)) "SITE"))
	       (error
		 "~A does not have a structured directory component whose last sub-component is \"SITE\"."
		 site-directory))
	      (t
	       1;; Create the translations (heavily borrowed from define-local-site-1)
0	       (let* ((all-but-site-dir (butlast dir))
		      (dir-component
			(append
			  (butlast all-but-site-dir)
			  (multiple-value-bind (major minor)
			      (sct:get-release-version)
			    (ncons
			      (let ((parsed-minor
				      (if (stringp minor)
					  (parse-integer minor :junk-allowed t) minor)))
				(format nil "REL-~D-~D" major (or parsed-minor 0)))))
			  (last all-but-site-dir))))
		 (setq sys-translations
		       (if (send site-directory :valid-directory-p '(:wild :wild-inferiors))
1			   ;; Winning operating systems with :WILD-INFERIORS
0			   `(("**;"
			      ,(send site-directory :new-pathname
				     :directory (append dir-component '(:wild-inferiors)))))
1			 ;; losing operating systems without :WILD-INFERIORS (TOPS20)
0			 `(("*;"
			    ,(send site-directory :new-pathname 
				   :directory (append dir-component '(:wild))))
			   ("*;*;"
			    ,(send site-directory :new-pathname
				   :directory (append dir-component '(:wild :wild))))
			   ("*;*;*;"
			    ,(send site-directory :new-pathname
				   :directory (append dir-component '(:wild :wild :wild))))
			   ("*;*;*;*;"
			    ,(send site-directory :new-pathname
				   :directory (append dir-component
						      '(:wild :wild :wild :wild))))
			   ("*;*;*;*;*;"
			    ,(send site-directory :new-pathname
				   :directory (append dir-component
						      '(:wild :wild :wild :wild :wild))))
			   ("*;*;*;*;*;*;"
			    ,(send site-directory :new-pathname
				   :directory (append dir-component
						      '(:wild :wild :wild :wild :wild
							      :wild)))))))))))
      1;; More code borrowed from define-new-local-site-1
0      (let* ((base-file (send local-site-directory :new-pathname
			      :host (send local-site-directory :host)
			      :canonical-type :text
			      :version :newest))
	     (base-data-file (send local-descriptor-file
				   :new-pathname :host (send local-descriptor-file :host)
				   :canonical-type :text :version :newest))
	     (log-file (neti:make-namespace-file-name base-data-file site :log))
	     (object-file (neti:make-namespace-file-name base-data-file site :objects))
	     (changes-file (neti:make-namespace-file-name base-data-file site :changes))
	     (translations-file
	       (send base-file :new-pathname :name "SYS" 		 
		     :canonical-type :logical-pathname-directory-translations))
	     (initial-timestamp)
	     (primary-network-type (send neti:*primary-network* :type))
	     (parsed-primary-address
	       (send neti:*primary-network* :parse-address neti:*primary-network-address*))
	     (secure-subnet
	       (ecase primary-network-type
		 (:chaos (format nil "~O" (ldb (byte 8. 8.) parsed-primary-address)))
		 (:internet (tcp::unparse-internet-address
			      (tcp::official-internet-subnet-number parsed-primary-address))))
	       ))
	(fs:create-directories-recursively base-file)
	(fs:create-directories-recursively base-data-file)
	(with-open-file (stream log-file :direction :output)
	  (format stream "~\\DATIME\\ ~A created by ~A~%" site zl:user-id)
	  (send stream :close)
	  (setq initial-timestamp (let* ((info (send stream :info))
					 (version (send (car info) :version)))
				    (if (eq version :unspecific) (cdr info) version))))
	(with-open-file (stream local-descriptor-file :direction :output)
	  (format stream "VERSION \"~a:~a\"~%* \"~a:~a\"~%"
		  (getf plist :ns-host-name) (neti:pathname-hostless-string log-file)
		  (getf plist :ns-host-name) (neti:pathname-hostless-string object-file))
	  (format stream "CHANGES \"~a:~a\"~%"
		  (getf plist :ns-host-name) (neti:pathname-hostless-string changes-file)))
	1;; Write out the objects file
0	(with-open-file (stream object-file :direction :output)
	  (format stream ";-*- Mode: Text; Network-Namespace: ~A-*-
NAMESPACE ~A
PRIMARY-NAME-SERVER ~A
SEARCH-RULES ~A
DESCRIPTOR-FILE \"~a:~a\"

SITE ~A
PRETTY-NAME ~A
LOCAL-NAMESPACE ~A
SITE-DIRECTORY \"~a:~a\"
TIMEZONE ~A
HOST-FOR-BUG-REPORTS ~A
SECURE-SUBNETS ~A ~A
~:[~;STANDALONE YES
~]
"
		  site site local-host site ns-data-host
		  (neti:pathname-hostless-string descriptor-file)
		  site (zl:string-capitalize-words site t t) site sys-host
		  (neti:pathname-directory-only-string site-directory)
		  (time:timezone-string (getf plist :timezone)) bug-host
		  primary-network-type secure-subnet
		  (getf plist :standalone-p))
	  (loop for network-pair in (send local-host :address)
		as type = (send (first network-pair) :type) do
	    (format stream "NETWORK ~A
SITE ~A
TYPE ~A
"
		    type site type)
	    (terpri stream))
	  (neti:print-host-attributes-for-new-site local-host stream site)
	  (unless (eq local-host sys-host)
	    (neti:print-host-attributes-for-new-site sys-host stream site))
	  (unless (or (eq embedded-in-host local-host)
		      (eq embedded-in-host sys-host))
	    (neti:print-host-attributes-for-new-site embedded-in-host stream site))
	  (unless (or (eq ns-data-host local-host)
		      (eq ns-data-host sys-host)
		      (eq ns-data-host embedded-in-host))
	    (neti:print-host-attributes-for-new-site ns-data-host stream site))
	  (unless (or (eq bug-host local-host)
		      (eq bug-host sys-host)
		      (eq bug-host embedded-in-host)
		      (eq bug-host ns-data-host))
	    (neti:print-host-attributes-for-new-site bug-host stream site))
	  (format stream "USER LISP-MACHINE~%HOME-HOST ~A~%" sys-host)
	  (if (eq (send sys-host :system-type) :lispm)
	      (format stream "LISPM-NAME ~A~%" (getf plist :default-login))
	      (format stream
		      "LISPM-NAME \"Lisp Machine\"~%LOGIN-NAME ~A ~A~%MAIL-ADDRESS ~A ~A~%"
		      (getf plist :default-login) sys-host (getf plist :default-login)
		      sys-host))
	  )
	1;; And the changes file...
0	(with-open-file (stream changes-file :direction :output)
	  (format stream "TIMESTAMP ~D~%" initial-timestamp))
	1;; Finally, the translations file
0	(with-open-file (stream translations-file :direction :output)
	  (with-standard-io-environment
	    (let* ((*readtable* si:*common-lisp-readtable*)
		   (*package* (find-package "CL-USER"))
		   (*print-case* :downcase))
	      (format stream ";;; -*- Mode: Lisp; Syntax: ~A; Package: ~A -*-~%~%"
		      (string-capitalize 
			(symbol-name (si:readtable-appropriate-file-syntax *readtable*)))
		      (package-name *package*))
	      (gprint:print-object
		`(fs:set-logical-pathname-host "SYS" :translations
		   ',(loop for (logical physical) in sys-translations
			   collect `(,logical ,(send physical :string-for-printing))))
		#'(lambda (x) (gprint:gformat "(2*_*_*!*)" x))
		stream)))))
      1;; The files are all written, hold your breath, here we go....
0      (let ((real-site
	      (neti:find-site-from-descriptor-file site site local-descriptor-file
						   (getf plist :host-name))))
	(if real-site
	    (neti:change-local-site-and-host real-site)
	    (format *error-output*
		    "Unable to find site ~A" site))))))


1;;; The prescribed way to merge namespaces.  Merging networks should only be done if
;;; :global-namespace-name can't be used.
0(defun 2link-namespaces 0(site-to-find &key (merge-networks nil))
  (if (neq (send net:*namespace* :local-server-p) :primary)
      (format *error-output*
	      "Sorry, this function can only be used on the primary namespace server.")
      (let ((new-site
	      (find-site-with-dialog site-to-find)))
	(when new-site
	  (let ((namespace (send new-site :local-namespace)))
	    (if (and merge-networks
		     (yes-or-no-p
		       "You are about to permanently merge all the networks in namespace ~A with the networks in namespace ~A.
~&You had better know what you are doing.  Are you sure you want to do this? "))
		(loop for network in neti:*local-networks* do
		  (neti:add-view-for-local-network network namespace)
		      finally (return T))
		T))))))


1;;; Backwards compatibility -- Users might have 0si:com-set-site1 in a wobbling script
0si:
(defun 2com-set-site 0(&optional (site 'attempt-broadcast)
		     (server-host-name :local)
		     server-chaos-address)
  (when (and server-chaos-address
	     (string-equal neti:*primary-network-address*
			   (format nil "~O" server-chaos-address)))
    (setq server-host-name :local
	  server-chaos-address nil))
  (let ((a-site-name (cond ((eq site 'attempt-broadcast) nil)
			   ((stringp site) (intern (string-upcase site) "KEYWORD"))
			   (t (send site :name)))))
    (cond ((eq site 'attempt-broadcast)
	   (net:set-site a-site-name :attempt-broadcast t))
	  ((or (typep site 'neti:site)
	       (eq server-host-name ':local)
	       (and (stringp site)
		    (string-equal site "distribution")))
	   (net:set-site a-site-name :force-existing-site t))
	  (t    
	   (net:set-site a-site-name
			 ;; :force-existing-site t implicit in :server-name
			 :server-name server-host-name
			 :server-chaos-address server-chaos-address)))))
