;;; -*- Mode: LISP; Package: NETWORK-INTERNALS; Base: 10 -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
;;; Server and user implementations of random network protocols

;;;; TIME service

(DEFINE-SERVER :RESET-TIME-SERVER (:MEDIUM :DATAGRAM)
  (LET ((UT (GET-TIME-FROM-NETWORK)))
    (COND (UT (TIME:INITIALIZE-TIMEBASE UT)
	      (VALUES T "RESET-TIME-SERVER successful"))
	  (T (VALUES NIL "Couldn't get time from network")))))

(DEFINE-PROTOCOL :RESET-TIME-SERVER (:RESET-TIME-SERVER :DATAGRAM)
  (:DESIRABILITY .9)
  (:INVOKE-WITH-STREAM-AND-CLOSE (STREAM)
   (MULTIPLE-VALUE-BIND (BUFFER START END)
       (SEND STREAM :READ-INPUT-BUFFER NIL T)
     (SEND STANDARD-OUTPUT :STRING-OUT (ASCII-TO-STRING BUFFER) START END))))

(DEFUN RESET-TIME-SERVER (HOST)
  (INVOKE-SERVICE-ACCESS-PATH
    (FIND-PATH-TO-SERVICE-ON-HOST :RESET-TIME-SERVER (PARSE-HOST HOST))
    NIL))

;;; TIME is Lispm order
(DEFINE-SERVER :TIME-SIMPLE (:MEDIUM :DATAGRAM :SIMPLE-P T :RESPONSE-ARRAY (ARRAY START)
				     :REJECT-UNLESS-TRUSTED NIL)
  (IF (NOT TIME:*TIMEBASE-INITIALIZED*)
      (VALUES NIL "I don't know what time it is.")
      (FILL-IN-BYTES :LITTLE ARRAY START (TIME:GET-UNIVERSAL-TIME) 4)
      (VALUES T START)))


(DEFINE-SERVER :TIME-SIMPLE-MSB (:MEDIUM :DATAGRAM :SIMPLE-P T :RESPONSE-ARRAY (ARRAY START)
					 :REJECT-UNLESS-TRUSTED NIL)
  (IF (NOT TIME:*TIMEBASE-INITIALIZED*)
      (VALUES NIL "I don't know what time it is.")
      (FILL-IN-BYTES :BIG ARRAY START (TIME:GET-UNIVERSAL-TIME) 4)
      (VALUES T START)))


;;; TIME as 32-bits in PDP-10 order.
(DEFINE-PROTOCOL :TIME-MSB (:TIME :BYTE-STREAM)
  (:DESIRABILITY .5)
  (:INVOKE (SERVICE &OPTIONAL MULTIPLE)
   (WITH-OPEN-STREAM (STREAM (NET:GET-CONNECTION-FOR-SERVICE SERVICE :CHARACTERS NIL))
     (LOOP REPEAT 4
	   WITH WORD = 0
	   AS BYTE = (SEND STREAM ':TYI)
	   WHEN (NULL BYTE)			;Host doesn't know
	     RETURN NIL
	   DO (SETQ WORD (+ (ASH WORD 8) BYTE))
	   FINALLY
	     ;; MULTIPLE should never be true, but just in case... 
	     (RETURN (IF MULTIPLE (LIST WORD) WORD)))))
  )

;;; TIME in an ANS
(DEFINE-PROTOCOL :TIME-SIMPLE (:TIME :DATAGRAM)
  (:DESIRABILITY .75)
  (:INVOKE-WITH-STREAM-AND-CLOSE (STREAM &OPTIONAL MULTIPLE)
   (TIME-SIMPLE STREAM NIL MULTIPLE)))

;;; TIME is a UDP datagram (byte order per PDP10)
(DEFINE-PROTOCOL :TIME-SIMPLE-MSB (:TIME :DATAGRAM)
  (:DESIRABILITY .75)
  (:INVOKE-WITH-STREAM-AND-CLOSE (STREAM &OPTIONAL MULTIPLE)
   (TIME-SIMPLE STREAM T MULTIPLE)))

(DEFUN TIME-SIMPLE (STREAM MSB &OPTIONAL MULTIPLE)
  (LOOP WITH TRY-PROCESS-ALLOW-SCHEDULE = T
	AS TIME = (MULTIPLE-VALUE-BIND (BUFFER START END)
		      (SEND STREAM ':READ-INPUT-BUFFER NIL T)
		    (AND BUFFER
			 ( END (+ START 4))
			 (LOOP REPEAT 4
			       FOR I FROM START
			       WITH DELTA = (IF MSB #o-1000 #o1000)
			       FOR PPSS FIRST (IF MSB #o3010 #o0010) THEN (+ PPSS DELTA)
			       WITH WORD = 0
			       AS BYTE = (AREF BUFFER I)
			       DO (SETQ WORD (DPB BYTE PPSS WORD))
			       FINALLY
				 (SEND STREAM :ADVANCE-INPUT-BUFFER)
				 (RETURN WORD))))
	WHEN (NOT MULTIPLE)
	  RETURN TIME
	WHILE (OR TIME (AND TRY-PROCESS-ALLOW-SCHEDULE
			    (PROGN (PROCESS-ALLOW-SCHEDULE)
				   (SETQ TRY-PROCESS-ALLOW-SCHEDULE NIL)
				   T)))
	WHEN TIME
	  COLLECT TIME))

(DEFINE-PROTOCOL :LOCAL-TIME (:TIME :LOCAL)
  (:INVOKE (IGNORE &OPTIONAL MULTIPLE)
   (AND TIME:*TIMEBASE-INITIALIZED*
	(LET ((TIME (TIME:GET-UNIVERSAL-TIME)))
	  ;; multiple should never be true, bug just in case...
	  (IF MULTIPLE (LIST TIME) TIME)))))

;;; Same protocol could be used for other purposes too.
(DEFINE-PROTOCOL :PUP-MISC-SERVICES (:TIME :PUP-DATAGRAM)
  (:DESIRABILITY .6)
  (:INVOKE (SERVICE &OPTIONAL IGNORE)
   (WITH-OPEN-STREAM (STREAM (GET-CONNECTION-FOR-SERVICE SERVICE ':PUP-TYPE #o206
							 ':RESPONSE-PUP-TYPE #o207))
     (LET ((TIME (TIME-SIMPLE STREAM T)))	;Alto byte order like PDP-10
       (AND TIME
	    (+ TIME 31536000.))))))		;Time is relative to 1901, not 1900.

;;; This is called by TIME:INITIALIZE-TIMEBASE.
(DEFUN GET-TIME-FROM-NETWORK ()
  ;; We assume that if a broadcast fails, the network is probably broken and
  ;; there is no point in slowly polling every host we might know about that
  ;; support time service.
  (BLOCK GET-TIME-FROM-NETWORK
    (LET (SERVICES MULTIPLE RESULTS)
      (COND ((SETQ SERVICES (FIND-PATHS-TO-SERVICE-USING-BROADCAST ':TIME))
	     (LOOP FOR SERVICE IN SERVICES
		       ;; give all broadcast TIME services an optional
		       ;; argument saying they can receive multiple times
		       ;; and return a list of the times. 
		   DO (SETF (SERVICE-ACCESS-PATH-ARGS SERVICE) '(T)))
	     (SETQ MULTIPLE T))
	    ((SETQ SERVICES (SEARCHING-ONE-NAMESPACE (*NAMESPACE*)
			      (FIND-PATHS-TO-SERVICE ':TIME)))
	     ;; maybe this should try to collect some percentage of the
	     ;; length of the list and use the median from those?
	     ))
      (INVOKE-MULTIPLE-SERVICES (SERVICES (* 60. 10.) "Time") (IGNORE TIME)
	(SYS:NETWORK-ERROR
	  )
	(:NO-ERROR
	 (IF MULTIPLE
	     (SETQ RESULTS (NCONC RESULTS TIME))
	   (RETURN-FROM GET-TIME-FROM-NETWORK TIME))))
      (SETQ RESULTS (SORT RESULTS #'<))
      ;; take median, or average of two around the median
      (AND RESULTS
	   (LET* ((LENGTH (LENGTH RESULTS))
		  (L//2 (// LENGTH 2)))	    
	     (IF (ODDP LENGTH)
		 (NTH L//2 RESULTS)
	       (// (+ (NTH (1- L//2) RESULTS) (NTH L//2 RESULTS)) 2)))))))

(DEFUN PRINT-HOST-TIMES (&REST HOSTS)
  (LET ((SERVICES (IF HOSTS (LOOP FOR HOST IN HOSTS
				  DO (SETQ HOST (PARSE-HOST HOST))	;User interface
				  AS PATH = (ignore-errors
						 (FIND-PATH-TO-SERVICE-ON-HOST
						   ':TIME HOST))
				  WHEN PATH COLLECT IT)
		      (FIND-PATHS-TO-SERVICE ':TIME)))
	(START-TIME (TIME))
	(COUNT 0) (SUM 0)
	(MESSAGES NIL))
    (INVOKE-MULTIPLE-SERVICES
      (SERVICES (* 60. 10.) "Time")
      (HOST TIME)
      (SYS:NETWORK-ERROR
	(PUSH (FORMAT NIL "~&~A: ~~A~" HOST TIME) MESSAGES))
      (:NO-ERROR
	(PUSH
	  (FORMAT nil "~&~A: ~:[unknown~;~\TIME\~]"
		  (IF (EQ HOST *LOCAL-HOST*) "local" HOST) TIME TIME)
	  MESSAGES)
	(WHEN TIME
	  (SETQ SUM (+ SUM TIME) COUNT (1+ COUNT)))))
    (FORMAT T "~%Real time used: ~D second~:P." (FIXR (// (- (TIME) START-TIME) 60.)))
    (LOOP FOR MESSAGE IN MESSAGES DO (FORMAT T "~&~A" MESSAGE))))

(DEFF CHAOS:PRINT-ALL-HOST-TIMES 'PRINT-HOST-TIMES)

;;;; UPTIME

(DEFINE-SERVER :UPTIME-SIMPLE (:MEDIUM :DATAGRAM :SIMPLE-P T :REJECT-UNLESS-TRUSTED NIL
			       :RESPONSE-ARRAY (ARRAY START))
  (IF (NOT TIME:*TIMEBASE-INITIALIZED*)
      (VALUES NIL "I don't know what time it is.")
    (FILL-IN-BYTES :LITTLE ARRAY START
		   (* 60. (- (TIME:GET-UNIVERSAL-TIME)
			     (SECOND (FIRST SI:COLD-BOOT-HISTORY))))
		   4)
    (VALUES T START)))


(DEFINE-PROTOCOL :UPTIME-SIMPLE (:UPTIME :DATAGRAM)
  (:INVOKE-WITH-STREAM-AND-CLOSE (STREAM)
   (TIME-SIMPLE STREAM NIL)))

(DEFUN UPTIME (&REST HOSTS)
  (UPTIME-INTERNAL HOSTS))

(DEFUN UPTIME-INTERNAL (HOSTS &KEY SORTED)
  (LET ((SERVICES (IF (NULL HOSTS) (FIND-PATHS-TO-SERVICE ':UPTIME)
		      (LOOP FOR HOST IN HOSTS
			    DO (SETQ HOST (PARSE-HOST HOST))
			    COLLECT (FIND-PATH-TO-SERVICE-ON-HOST ':UPTIME HOST))))
	UP DOWN)
    (FORMAT T "~%~25A~25A~%" "Host Name" "Time up")
    (INVOKE-MULTIPLE-SERVICES
      (SERVICES (* 60. 10.) "Uptime")
      (HOST TIME)
      (SYS:NETWORK-ERROR
	(IF SORTED
	    (PUSH HOST DOWN)
	    (FORMAT T "~&~25A~~A~" HOST TIME)))
      (:NO-ERROR 
        (IF SORTED
	    (PUSH (CONS TIME HOST) UP)
	  (FORMAT T "~&~25A" HOST)
	  (TIME:PRINT-INTERVAL-OR-NEVER (// TIME 60.))
	  (TERPRI))))
    (WHEN SORTED
      (SETQ UP (SORTCAR UP #'>))
      (LOOP FOR (TIME . HOST) IN UP
	    DO (FORMAT T "~&~25A" HOST)
	       (TIME:PRINT-INTERVAL-OR-NEVER (// TIME 60.))
	       (TERPRI))
      (WHEN DOWN
	(FORMAT T "~&Hosts not responding: ")
	(FORMAT:PRINT-LIST STANDARD-OUTPUT "~A" DOWN)))))

#| Not common enough
(ADD-INITIALIZATION "Get hosts for uptime"
		    '(HOSTS-SUPPORTING-SERVICE ':UPTIME)
		    NIL
		    'COMMONLY-USED-PROPERTY-LISTS) |#

;;;; SHOW-USERS and LISPM-FINGER service

(DEFVAR GIVE-FINGER-SAVED-TRUSTED-STRING NIL)
(DEFVAR GIVE-FINGER-SAVED-UNTRUSTED-STRING NIL)
(DEFVAR GIVE-FINGER-SAVED-TRUSTED-STRING-IDLE-INDEX NIL)
(DEFVAR GIVE-FINGER-SAVED-UNTRUSTED-STRING-IDLE-INDEX NIL)

;;; These variables censor LISPM-FINGER and NAME.
;;; Defined keywords so far are:
;;;
;;;  :SOFTWARE-INFO to suppress the "what versions of what" string.
;;;  :HARDWARE-INFO		    hardware configuration.
;;;  :WHOIS			WHOIS wholesale.
;;;  :PROJECT			the project field.
;;;  :SUPERVISOR		as it seems.
;;;  :WORK-ADDRESS		ditto.
;;;  :WORK-PHONE		ditto.
;;;  :HOME-ADDRESS		ditto.
;;;  :HOME-PHONE		ditto.

(CL:DEFPARAMETER *FINGER-FIELDS-TO-SUPPRESS* NIL)
(CL:DEFPARAMETER *FINGER-FIELDS-TO-SUPPRESS-FOR-UNTRUSTED-HOSTS* NIL)

;;; You can set this to override LOCAL-FINGER-LOCATION.  If you were to
;;; just set LOCAL-FINGER-LOCATION, it would be overwritten if you
;;; updated site configuration information.  If this is NIL, LOCAL-FINGER-LOCATION
;;; is used; otherwise it should be a string.
(DEFVAR FINGER-LOCATION NIL)

(DEFUN FINGER-SUPPRESS-INFO (TRUSTED-P INFO-KEYWORD)
  (OR
    (CL:MEMBER INFO-KEYWORD *FINGER-FIELDS-TO-SUPPRESS* :TEST #'EQ)
    (AND
      (NOT TRUSTED-P)
      (CL:MEMBER INFO-KEYWORD
		 *FINGER-FIELDS-TO-SUPPRESS-FOR-UNTRUSTED-HOSTS*
		 :TEST #'EQ))))

;;; Call this when anything changes, such as the above options, the user id,
;;; or the software version
;;; If ONLY-USER-CHANGED is true, the software and hardware info are known not to
;;; have changed, so we don't have to do anything unless the user has changed
(DEFUN COMPUTE-FINGER-STRING (&OPTIONAL ONLY-USER-CHANGED
			      &AUX (GROUP FS:USER-GROUP-AFFILIATION))
  (SETQ GROUP (TYPECASE GROUP
		(:CHARACTER GROUP)
		(:STRING (IF (PLUSP (STRING-LENGTH GROUP))
			     (AREF GROUP 0)
			     #\SPACE))
		(OTHERWISE #\SPACE)))
  (WHEN ONLY-USER-CHANGED
    ;; Return if the user info is already up to date
    (LET ((STRING GIVE-FINGER-SAVED-TRUSTED-STRING))
      (WHEN (STRINGP STRING)
	(LET* ((CR1 (STRING-SEARCH-EXACT-CHAR #\RETURN STRING))
	       (CR2 (STRING-SEARCH-EXACT-CHAR #\RETURN STRING (1+ CR1)))
	       (CR3 (STRING-SEARCH-EXACT-CHAR #\RETURN STRING (1+ CR2)))
	       (CR4 (STRING-SEARCH-EXACT-CHAR #\RETURN STRING (1+ CR3)))
	       (LOCATION (OR FINGER-LOCATION LOCAL-FINGER-LOCATION)))
	  (WHEN (AND (STRING= STRING USER-ID 0 0 CR1 (STRING-LENGTH USER-ID))
		     (STRING= STRING LOCATION (1+ CR1) 0 (+ CR1 1 (STRING-LENGTH LOCATION)))
		     (STRING= STRING FS:USER-PERSONAL-NAME-FIRST-NAME-FIRST (1+ CR3) 0 CR4)
		     (CHAR= (AREF STRING (1+ CR4)) GROUP))
	    (RETURN-FROM COMPUTE-FINGER-STRING NIL))))))
  ;; We need to do the slow computations
  (LET ((SOFTWARE-INFO (SCT:SYSTEM-VERSION-INFO :FINGER))
	(HARDWARE-INFO (SI:HARDWARE-RESOURCES-STRING)))
    (FLET ((MAKE-FINGER-STRING (TRUSTED-P &AUX IDLE-INDEX)
	     (DECLARE (VALUES STRING IDLE-INDEX))
	     (LET ((SOFTWARE-INFO (UNLESS (FINGER-SUPPRESS-INFO TRUSTED-P :SOFTWARE-INFO)
				    SOFTWARE-INFO))
		   (HARDWARE-INFO (UNLESS (FINGER-SUPPRESS-INFO TRUSTED-P :HARDWARE-INFO)
				    HARDWARE-INFO)))
	       (VALUES (WITH-OUTPUT-TO-STRING (S)
			 (SEND S :LINE-OUT USER-ID)
			 (SEND S :STRING-OUT (OR FINGER-LOCATION LOCAL-FINGER-LOCATION))
			 (WHEN (OR SOFTWARE-INFO HARDWARE-INFO)
			   (SEND S :STRING-OUT " (")
			   (WHEN SOFTWARE-INFO
			     (SEND S :STRING-OUT SOFTWARE-INFO))
			   (WHEN (AND SOFTWARE-INFO HARDWARE-INFO)
			     (SEND S :TYO #\SPACE))
			   (WHEN HARDWARE-INFO
			     (SEND S :STRING-OUT HARDWARE-INFO))
			   (SEND S :TYO #\CLOSE))
			 (SEND S :TYO #\RETURN)
			 (SETQ IDLE-INDEX (SEND S :READ-POINTER))
			 (SEND S :LINE-OUT "       ")	;Space for idle time (7 chars)
			 (SEND S :LINE-OUT FS:USER-PERSONAL-NAME-FIRST-NAME-FIRST)
			 (SEND S :TYO GROUP)
			 (SEND S :TYO #\RETURN))
		       IDLE-INDEX))))
      (MULTIPLE-VALUE (GIVE-FINGER-SAVED-TRUSTED-STRING
		       GIVE-FINGER-SAVED-TRUSTED-STRING-IDLE-INDEX)
	(MAKE-FINGER-STRING T))
      (MULTIPLE-VALUE (GIVE-FINGER-SAVED-UNTRUSTED-STRING
		       GIVE-FINGER-SAVED-UNTRUSTED-STRING-IDLE-INDEX)
	(MAKE-FINGER-STRING NIL)))))

(DEFINE-SERVER :LISPM-FINGER (:MEDIUM :DATAGRAM :TRUSTED-P TRUSTED-P :REJECT-UNLESS-TRUSTED NIL
				      :SIMPLE-P T)
   (MULTIPLE-VALUE-BIND (STRING INDEX)
       (IF TRUSTED-P
	   (VALUES GIVE-FINGER-SAVED-TRUSTED-STRING
		   GIVE-FINGER-SAVED-TRUSTED-STRING-IDLE-INDEX)
	   (VALUES GIVE-FINGER-SAVED-UNTRUSTED-STRING
		   GIVE-FINGER-SAVED-UNTRUSTED-STRING-IDLE-INDEX))
     (IF STRING	;can be NIL during world building
	 ;; Plug in idle time in minutes
	 (LET ((IDLE (// (TIME-DIFFERENCE (TIME) TV:KBD-LAST-ACTIVITY-TIME) 3600.)))
	   ;; First fill the field with spaces
	   (LOOP REPEAT 7 DO
	     (SETF (AREF STRING INDEX) #\SPACE)
	     (INCF INDEX))
	   ;; Now plug in the right-justified idle time if needed
	   ;; Maximum value from TIME-DIFFERENCE is (EXPT 2 31)
	   ;; so maximum value of IDLE is 9942 hours, so 7 spaces is enough.
	   (MACROLET ((CL:DIGIT-CHAR (DIGIT)	;(DECLARE (INLINE CL:DIGIT-CHAR))
			`(AREF SI:*WEIGHT-DIGITS* ,DIGIT)))
	     (UNLESS (ZEROP IDLE)			;Blank
	       (SETF (AREF STRING (DECF INDEX)) (CL:DIGIT-CHAR (MOD IDLE 10.)))
	       (UNLESS (ZEROP (SETQ IDLE (// IDLE 10.)))
		 (SETF (AREF STRING (DECF INDEX)) (CL:DIGIT-CHAR (MOD IDLE 6)))
		 (UNLESS (ZEROP (SETQ IDLE (// IDLE 6)))
		   ;; There are hours
		   (SETF (AREF STRING (DECF INDEX)) #\:)
		   (LOOP DOING
		     (SETF (AREF STRING (DECF INDEX)) (CL:DIGIT-CHAR (MOD IDLE 10.)))
		     (WHEN (ZEROP (SETQ IDLE (// IDLE 10.))) (RETURN))))))
	     (VALUES T STRING)))
	 (VALUES NIL "Finger information unknown"))))

(DEFINE-SERVER :ASCII-NAME (:MEDIUM :BYTE-STREAM :STREAM (STREAM :ASCII-TRANSLATION T)
				    :TRUSTED-P TRUSTED-P :REJECT-UNLESS-TRUSTED NIL)
  (MULTIPLE-VALUE-BIND (USER WHOIS)
      (PARSE-NAME-ARGUMENT (SEND STREAM ':LINE-IN))
    (NAME-SERVER-INTERNAL STREAM USER WHOIS TRUSTED-P)))

(DEFINE-SERVER :NAME (:MEDIUM :BYTE-STREAM :STREAM (STREAM :ACCEPT-P NIL)
			      :REJECT-UNLESS-TRUSTED NIL
			      :TRUSTED-P TRUSTED-P)
  (MULTIPLE-VALUE-BIND (USER WHOIS)
      (MULTIPLE-VALUE-BIND (STRING START END)
	  (SEND STREAM ':READ-INPUT-BUFFER)
	(SETQ START (LET ((TEM (STRING-SEARCH-CHAR #\SP STRING START END)))
		      (IF TEM (1+ TEM) END)))
	(PARSE-NAME-ARGUMENT STRING START END))
    (SEND STREAM ':ACCEPT)
    (NAME-SERVER-INTERNAL STREAM USER WHOIS TRUSTED-P)))

(DEFUN PARSE-NAME-ARGUMENT (STRING &OPTIONAL (START 0) END)
  (OR END (SETQ END (STRING-LENGTH STRING)))
  (SETQ START (OR (STRING-SEARCH-NOT-SET '(#\SP #\TAB) STRING START END) END)
	END (LET ((TEM (STRING-REVERSE-SEARCH-NOT-SET '(#\SP #\TAB) STRING END START)))
	      (IF TEM (1+ TEM) START)))
  (UNLESS (= START END)
    (LET ((SLASH (STRING-SEARCH-CHAR #// STRING START END)))
      (VALUES
	(COND ((NULL SLASH)
	       (SUBSTRING STRING START END))
	      ((= SLASH START)
	       (LET ((TEM (STRING-SEARCH-NOT-SET '(#\SP #\TAB) STRING (+ SLASH 2) END)))
		 (IF TEM (SUBSTRING STRING TEM END) "")))
	      (T
	       (SUBSTRING
		 STRING START
		 (LET ((TEM (STRING-REVERSE-SEARCH-NOT-SET '(#\SP #\TAB) STRING SLASH START)))
		   (IF TEM (1+ TEM) START)))))
	(AND SLASH (< SLASH (1- END))
	     (CHAR-EQUAL #/W (AREF STRING (1+ SLASH))))))))

(DEFUN NAME-SERVER-INTERNAL (STREAM USER WHOIS TRUSTED-P)
  (CONDITION-CASE ()
      (LET ((IDLE (// (TIME-DIFFERENCE (TIME) TV:KBD-LAST-ACTIVITY-TIME) 3600.)))
	(FORMAT STREAM "~6A ~C ~22A ~6A ~:[    ~3*~;~:[~D:~2,48D~;  ~*~D~]~]     ~A (~A ~A)"
		USER-ID
		(IF (STRINGP FS:USER-GROUP-AFFILIATION)
		    (IF (PLUSP (STRING-LENGTH FS:USER-GROUP-AFFILIATION))
			(AREF FS:USER-GROUP-AFFILIATION 0)
			#\SPACE)
		    FS:USER-GROUP-AFFILIATION)
		FS:USER-PERSONAL-NAME-FIRST-NAME-FIRST
		LOCAL-HOST-NAME
		(NOT (ZEROP IDLE))
		(ZEROP (// IDLE 60.))
		(// IDLE 60.)
		(\ IDLE 60.)
		(OR FINGER-LOCATION LOCAL-FINGER-LOCATION)
		(IF (FINGER-SUPPRESS-INFO TRUSTED-P :SOFTWARE-INFO)
		    ""
		    (SCT:SYSTEM-VERSION-INFO :FINGER))
		(IF (FINGER-SUPPRESS-INFO TRUSTED-P :HARDWARE-INFO)
		    ""
		    (SI:HARDWARE-RESOURCES-STRING)))
	(LET ((USER-OBJECT (INTERPRET-USER-ARGUMENT USER)))
	  (COND ((ERRORP USER-OBJECT)
		 (FORMAT STREAM "~%~A: ~A" USER USER-OBJECT))
		((LISTP USER-OBJECT)
		 (FORMAT STREAM "~%~A is ambiguous:" USER)
		 (DOLIST (USER USER-OBJECT)
		   (LET ((MAILBOX (SEND USER ':MAIL-ADDRESS)))
		     (FORMAT STREAM "~%~6A ~22A~:[~;[~A@~A]~]"
			     USER (SEND USER ':PERSONAL-NAME)
			     (NOT (NULL MAILBOX)) (FIRST MAILBOX) (SECOND MAILBOX)))))
		((NEQ USER-OBJECT SI:*USER*)
		 (FORMAT STREAM "~%~6A ~C ~22A not using this machine."
			 (SEND USER-OBJECT ':LISPM-NAME)
			 (LET ((AFFIL (SEND USER-OBJECT ':AFFILIATION)))
			   (IF (AND AFFIL (PLUSP (STRING-LENGTH AFFIL)))
			       (AREF AFFIL 0)
			       #\SP))
			 (SEND USER-OBJECT ':PERSONAL-NAME))))
	  (WHEN (AND WHOIS (TYPEP USER-OBJECT 'SI:USER)
		     (NOT (FINGER-SUPPRESS-INFO TRUSTED-P :WHOIS)))
	    (PRINT-WHOIS-INTERNAL STREAM USER-OBJECT TRUSTED-P))))
    (SYS:REMOTE-NETWORK-ERROR)))

(DEFUN INTERPRET-USER-ARGUMENT (USER)
  (IF (OR (NULL USER) (EQUAL USER "") (EQUAL USER USER-ID))
      SI:*USER*
    (CONDITION-CASE (ERROR)
	(FIND-OBJECT-NAMED ':USER USER)
      (OBJECT-NOT-FOUND
	(LET ((LIST (LOOP FOR OBJ IN (FIND-OBJECTS-FROM-PROPERTY-LIST ':USER)
			  WHEN (LET ((PERSONAL-NAME (SEND OBJ ':PERSONAL-NAME)))
				 (AND PERSONAL-NAME (STRING-SEARCH USER PERSONAL-NAME)))
			  COLLECT OBJ)))
	  (COND ((NULL LIST)
		 ERROR)
		((NULL (CDR LIST))
		 (CAR LIST))
		(T LIST)))))))

(DEFUN PRINT-WHOIS-INTERNAL (STREAM USER TRUSTED-P)
  (TERPRI STREAM)
  (LET ((NICKNAME (SEND USER ':NICKNAME)))
    (WHEN NICKNAME
      (FORMAT STREAM "~3@T(~A)" NICKNAME)))
  (LET ((MAIL-ADDRESS (SEND USER ':MAIL-ADDRESS)))
    (FORMAT STREAM "~3@T[~A@~A]" (FIRST MAIL-ADDRESS) (SECOND MAIL-ADDRESS)))
  (LET ((PROJECT (AND (NOT (FINGER-SUPPRESS-INFO TRUSTED-P :PROJECT))
		      (SEND USER ':PROJECT)))
	(SUPER (AND (NOT (FINGER-SUPPRESS-INFO TRUSTED-P :SUPERVISOR))
		    (SEND USER ':SUPERVISOR))))
    (WHEN (OR PROJECT SUPER)
      (FORMAT STREAM "~3@THacking~@[ ~A~]~@[ for ~A~]" PROJECT SUPER)))
  (TERPRI STREAM)
  (LET ((WORK-ADDRESS (AND (NOT (FINGER-SUPPRESS-INFO TRUSTED-P :WORK-ADDRESS))
			   (SEND USER ':WORK-ADDRESS)))
	(WORK-PHONE (AND (NOT (FINGER-SUPPRESS-INFO TRUSTED-P :WORK-PHONE))
			 (SEND USER ':WORK-PHONE))))
    (WHEN (OR WORK-ADDRESS WORK-PHONE)
      (FORMAT STREAM "~3@TWork: ~@[~A~3@T~]~A~%" WORK-ADDRESS WORK-PHONE)))
  (LET ((HOME-ADDRESS (AND (NOT (FINGER-SUPPRESS-INFO TRUSTED-P :HOME-ADDRESS))
			   (SEND USER ':HOME-ADDRESS)))
	(HOME-PHONE (AND (NOT (FINGER-SUPPRESS-INFO TRUSTED-P :HOME-PHONE))
			 (SEND USER ':HOME-PHONE))))
    (WHEN (OR HOME-ADDRESS HOME-PHONE)
      (FORMAT STREAM "~3@THome: ~@[~A~3@T~]~A~%" HOME-ADDRESS HOME-PHONE)))
  (LET ((REMARKS (SEND USER ':REMARKS)))
    (WHEN REMARKS
      (FORMAT STREAM "~3@T~~A~~%" REMARKS))))

(DEFCONST *SYSTEM-TYPES-FOR-WHOIS-COMES-BEFORE* '(:UNIX :UNIX42 :ULTRIX))

;;; Show who is logged in to a machine.  Apparently no one supports the various inferior
;;; SYSTAT type protocols that do this on the arpanet, so no need to have them.
(DEFINE-PROTOCOL :ASCII-NAME (:SHOW-USERS :BYTE-STREAM)
  (:DESIRABILITY .6)
  (:INVOKE-WITH-STREAM-AND-CLOSE ((NET-STREAM ':ASCII-TRANSLATION T)
				  &KEY USER WHOIS)
   (LET* ((SYSTEM-TYPE (SEND (SEND NET-STREAM :FOREIGN-HOST) :SYSTEM-TYPE))
	  (WHOIS-COMES-BEFORE (MEMBER SYSTEM-TYPE *SYSTEM-TYPES-FOR-WHOIS-COMES-BEFORE*)))
     ;; UNIX wants the /W before the username.
     (WHEN (AND WHOIS WHOIS-COMES-BEFORE)
       (SEND NET-STREAM ':STRING-OUT "//W "))
     (WHEN USER
       (SEND NET-STREAM ':STRING-OUT USER))
     (WHEN (AND WHOIS (NOT WHOIS-COMES-BEFORE))
       (SEND NET-STREAM ':STRING-OUT "//W")))
   (SEND NET-STREAM ':TYO #\CR)
   (SEND NET-STREAM ':FORCE-OUTPUT)
   (FLET ((DISPLAY-RESULTS ()
	    (CL:FRESH-LINE STANDARD-OUTPUT)
	    (STREAM-COPY-UNTIL-EOF NET-STREAM STANDARD-OUTPUT)))
     (IF USER
	 (DW:WITH-OUTPUT-AS-PRESENTATION
	   (:STREAM STANDARD-OUTPUT
	    :TYPE 'CP::USER-AT-HOST-OR-SITE 
	    :OBJECT `(:USER ,USER :HOST,(SEND NET-STREAM :FOREIGN-HOST)))
	   (DISPLAY-RESULTS))
	 (DISPLAY-RESULTS)))))


(CHAOS:DEFINE-CHAOS-PROTOCOL :NAME (:SHOW-USERS :CHAOS)
  (:DESIRABILITY .75)
  (:INVOKE-WITH-STREAM-AND-CLOSE ((STREAM :DIRECTION :INPUT) &KEY USER WHOIS)
    WHOIS					;Just for error checking
    (FLET ((DISPLAY-RESULTS ()
	     (CL:FRESH-LINE STANDARD-OUTPUT)
	     (STREAM-COPY-UNTIL-EOF STREAM STANDARD-OUTPUT)))
      (IF USER
	  (DW:WITH-OUTPUT-AS-PRESENTATION
	    (:STREAM STANDARD-OUTPUT
	     :TYPE 'CP::USER-AT-HOST-OR-SITE 
	     :OBJECT `(:USER ,USER :HOST,(SEND STREAM :FOREIGN-HOST)))
	    (DISPLAY-RESULTS))
	  (DISPLAY-RESULTS)))
    (CLOSE STREAM T))
  (:CHAOS-CONTACT-NAME (BASE-CONTACT-NAME SERVICE)
   (LET ((USER NIL)
	 (WHOIS NIL))
     (LOOP FOR (KEY VALUE) ON (SERVICE-ACCESS-PATH-ARGS SERVICE)
	   DO (SELECTQ KEY
		(:USER (SETQ USER VALUE))
		(:WHOIS (SETQ WHOIS VALUE))))
     (IF (OR USER WHOIS)
	 (STRING-APPEND BASE-CONTACT-NAME #\SP (OR USER "") (IF WHOIS "//W" ""))
	 BASE-CONTACT-NAME))))


;;; User interface functions
(DEFUN WHOIS (&OPTIONAL SPEC (STREAM STANDARD-OUTPUT))
  (FINGER SPEC STREAM ':WHOIS T))

;;; Don't blame me that the arglist here is totally bankrupt.
;;; Fixed in the command processor.  SPEC is the old style string.
(DEFUN FINGER (&OPTIONAL SPEC (STREAM STANDARD-OUTPUT)
	       &KEY (USER "") (HOST FS:USER-LOGIN-MACHINE) (WHOIS NIL))
  (UNLESS (NULL SPEC)
    (LET ((TEM (STRING-SEARCH-CHAR #/@ SPEC)))
      (IF (NULL TEM)
	  (SETQ USER SPEC)
	  (SETQ USER (SUBSTRING SPEC 0 TEM)
		HOST (PARSE-HOST (SUBSTRING SPEC (1+ TEM)))))))
  (SEND STREAM ':FRESH-LINE)
  (LET ((STANDARD-OUTPUT STREAM)
	(NETI:*INVOKE-SERVICE-AUTOMATIC-RETRY* T))
    ;; Don't blow up if someone passes in a bold string
    (SETQ USER (STRING-THIN USER :REMOVE-BITS T :ERROR-IF :FAT))
    (INVOKE-SERVICE-ON-HOST ':SHOW-USERS HOST
			    ':USER USER ':WHOIS WHOIS))
  NIL)

;;; User interface functions:
;;;  GET-LOCAL-LISPMS    returns a list of all Lisp machines at this site
;;;  GET-ALL-LISPMS	 returns a list of all Lisp machines in the host table 
;;;  GET-LOCAL-HOSTS	 returns a list of all hosts at this site
;;;  GET-ALL-HOSTS       returns a list of all hosts on the local networks
;;;  FINGER-LOCAL-LISPMS fingers all Lisp machines at this site
;;;  FINGER-ALL-LISPMS   fingers all Lisp machines in the host table

(DEFUN GET-LOCAL-LISPMS ()
  ;; Assume all local objects are in the local namespace
  (SEARCHING-ONE-SITE ()
    (FIND-OBJECTS-FROM-PROPERTY-LIST ':HOST
				     ':SITE *LOCAL-SITE* ':SYSTEM-TYPE ':LISPM)))

(DEFUN GET-LOCAL-HOSTS ()
  ;; Assume all local objects are in the local namespace
  (SEARCHING-ONE-SITE ()
    (FIND-OBJECTS-FROM-PROPERTY-LIST ':HOST ':SITE *LOCAL-SITE*)))

(DEFUN GET-ALL-LISPMS ()
  (FIND-OBJECTS-FROM-PROPERTY-LIST ':HOST ':SYSTEM-TYPE ':LISPM))

(DEFUN GET-LISPMS-AT-SITE (A-SITE-NAME)
  (LET ((SITE (FIND-OBJECT-NAMED ':SITE (STRING A-SITE-NAME))))
    ;; Assume all objects are in the site's namespace
    (SEARCHING-ONE-SITE (SITE)
      (FIND-OBJECTS-FROM-PROPERTY-LIST ':HOST
				       ':SITE SITE ':SYSTEM-TYPE ':LISPM))))

(DEFUN GET-ALL-HOSTS ()
  (SI:ELIMINATE-DUPLICATES
    (LOOP FOR (NETWORK) IN (SEND *LOCAL-HOST* :ADDRESS)
	  APPEND (SEARCHING-ONE-NETWORK (NETWORK)
		   (FIND-OBJECTS-FROM-PROPERTY-LIST :HOST :ADDRESS `((,NETWORK :*)))))))

#|| This stuff is too expensive. --Hornig

;;; Alist of namespace timestamp at which we encached host information
(DEFVAR *LAST-NAMESPACE-HOST-INFORMED-ALIST* NIL)

(DEFUN GET-LOCAL-HOST-LISTS ()
  (LET ((CHANGED-NAMESPACES (LOOP FOR NAMESPACE IN *NAMESPACE-SEARCH-LIST*
				  AS ELEM = (ASSQ NAMESPACE
						  *LAST-NAMESPACE-HOST-INFORMED-ALIST*)
				  WHEN (NULL ELEM)
				  DO (PUSH (SETQ ELEM (LIST NAMESPACE -1))
					   *LAST-NAMESPACE-HOST-INFORMED-ALIST*)
				  WHEN ( (SECOND ELEM)
					  (SEND NAMESPACE ':VALIDATION-TIMESTAMP))
				  COLLECT ELEM)))
    (UNLESS (NULL CHANGED-NAMESPACES)
      (GET-LOCAL-LISPMS)
      ;; Validate all the names to cut down lookup time for hosts in namespaces down in
      ;; namespace search list.
      ;; Put in inverse host to address mappings for all hosts as well.
      (LOOP FOR HOST IN (GET-ALL-HOSTS)
	    DO
	    (LOOP FOR NAME IN (SEND HOST ':NAMES)
		  DO (SEND NAME ':SHADOWED-P ':HOST NIL))
	    (LOOP FOR (NAMESPACE) IN CHANGED-NAMESPACES
		  DO (SEND HOST ':INFORM-NAMESPACE-OF-ADDRESSES NAMESPACE :HOST)))
      ;; Validate all networks to cut down path finding time.
      (LOOP FOR HOST IN (GET-ALL-LISPMS)
	    DO (LOOP FOR (NETWORK) IN (SEND HOST ':ADDRESS)
		     DO (SEND NETWORK ':GET ':TYPE)))
      (LOOP FOR ELEM IN CHANGED-NAMESPACES
	    DO (SETF (SECOND ELEM) (SEND (FIRST ELEM) ':VALIDATION-TIMESTAMP))))))

||#

(ADD-INITIALIZATION "Get local host lists"
		    '(GET-LOCAL-LISPMS)
		    NIL
		    'COMMONLY-USED-PROPERTY-LISTS)


(DEFUN FIND-LISPMS-LOGGED-IN-AS-USER (USER &OPTIONAL (LISPMS (GET-LOCAL-LISPMS)))
  "Return a list of lisp machines that USER is logged into."
  (LET ((HOSTS NIL))
    (*SCAN-LISPMS LISPMS
		  (LAMBDA (HOST DATA)
		    (IF (EQUAL USER (FIRST DATA))
			(PUSH HOST HOSTS))))
    HOSTS))

(DEFUN FIND-LISPMS-RETURNING-INFO-LOGGED-IN-AS-USER (USER &OPTIONAL (LISPMS (GET-LOCAL-LISPMS)))
  "Return a list of lists for all hosts that USER is logged into.  Each sublist has the
following syntax: (host user-id location-string idle-time personal-name group), where
host is a host object and the rest are strings."
  (LET ((HOSTS NIL))
    (*SCAN-LISPMS LISPMS
		  (LAMBDA (HOST DATA)
		    (IF (EQUAL USER (FIRST DATA))
			(PUSH (CONS HOST DATA) HOSTS))))
    HOSTS))

;;; Return a list of (ID LOCATION IDLE-TIME PERSONAL-NAME GROUP)
(DEFINE-PROTOCOL :LISPM-FINGER (:LISPM-FINGER :DATAGRAM)
  (:INVOKE-WITH-STREAM-AND-CLOSE (STREAM)
   (MULTIPLE-VALUE-BIND (STRING START END)
       (SEND STREAM ':READ-INPUT-BUFFER)
     (UNLESS (STRINGP STRING)
       (SETF STRING (MAKE-ARRAY (- END START) :TYPE 'ART-STRING
				:DISPLACED-TO STRING :DISPLACED-INDEX-OFFSET START))
       (DECF END START)
       (SETF START 0))
     (LOOP FOR BEGIN = START THEN (1+ IDX)
	   AS IDX = (STRING-SEARCH-CHAR #\CR STRING BEGIN END) WHILE IDX
	   COLLECT (SUBSTRING STRING BEGIN IDX)))))

;;; Invoke LISPM-FINGER service from each host.  For each one which responds, calls
;;; ALIVE-FUNCTION with the host and the list of data (see above).  For each host which
;;; doesn't respond, applies DEAD-FUNCTION to the host.  REFUSE-FUNCTION may be used to
;;; process hosts that reject, called with host and error.

(DEFUN *SCAN-LISPMS (HOSTS ALIVE-FUNCTION &OPTIONAL DEAD-FUNCTION REFUSE-FUNCTION)
  (DECLARE (DOWNWARD-FUNARG ALIVE-FUNCTION DEAD-FUNCTION REFUSE-FUNCTION))
  (LET ((DEAD-HOSTS NIL))
    (INVOKE-MULTIPLE-SERVICES ((LOOP FOR HOST IN HOSTS
				     AS PATH = (CONDITION-CASE (ERROR)
						   (FIND-PATH-TO-SERVICE-ON-HOST
						     ':LISPM-FINGER HOST)
						 (NETWORK-ERROR
						   (WHEN REFUSE-FUNCTION
						     (FUNCALL REFUSE-FUNCTION HOST ERROR))
						   NIL))
				     WHEN PATH COLLECT IT)
			       (* 4 60.) "Finger")
			      (HOST DATA)
      (CONNECTION-REFUSED
	(WHEN REFUSE-FUNCTION
	  (FUNCALL REFUSE-FUNCTION HOST DATA)))
      (CONNECTION-ERROR
	(WHEN DEAD-FUNCTION
	  (PUSH (LIST HOST DATA) DEAD-HOSTS)))
      (:NO-ERROR
       (FUNCALL ALIVE-FUNCTION HOST DATA)))
    (WHEN DEAD-FUNCTION
      (LOOP FOR (HOST DATA) IN DEAD-HOSTS
	    DOING (FUNCALL DEAD-FUNCTION HOST DATA)))))

;;; The original version of *SCAN-LISPMS from before the days of lexical scoping, kept for
;;; compatibility.  Invoke LISPM-FINGER service from each host.  For each one which responds,
;;; calls ALIVE-FUNCTION with the host, the list of data (see above), and ALIVE-ARGS.  For
;;; each host which doesn't respond, applies DEAD-FUNCTION to the host and DEAD-ARGS.
;;; REFUSE-FUNCTION may be used to process hosts that reject, called with host and error.

(DEFUN SCAN-LISPMS (HOSTS ALIVE-FUNCTION ALIVE-ARGS DEAD-FUNCTION DEAD-ARGS
		    &OPTIONAL REFUSE-FUNCTION REFUSE-ARGS)
  (*SCAN-LISPMS HOSTS
		#'(LAMBDA (HOST DATA) (LEXPR-FUNCALL ALIVE-FUNCTION HOST DATA ALIVE-ARGS))
		#'(LAMBDA (HOST DATA) (LEXPR-FUNCALL DEAD-FUNCTION HOST DATA DEAD-ARGS))
		#'(LAMBDA (HOST ERROR) (LEXPR-FUNCALL REFUSE-FUNCTION HOST ERROR REFUSE-ARGS))))

(COMPILER:MAKE-OBSOLETE SCAN-LISPMS
			"it has been replaced by NETI:*SCAN-LISPMS, which assumes lexical scoping")

;;; Old name
(DEFF CHAOS:FINGER-ALL-LMS 'FINGER-LOCAL-LISPMS)
(COMPILER:MAKE-OBSOLETE CHAOS:FINGER-ALL-LMS "it has been replaced by NET:FINGER-LOCAL-LISPMS")

;;;; EVAL server

;;; Values can be T, :NOTIFY or NIL
(DEFVAR EVAL-SERVER-ON NIL)

(DEFUN EVAL-SERVER-ON (&OPTIONAL (MODE T)) (SETQ EVAL-SERVER-ON MODE))

(DEFUN EVAL-SERVER-FUNCTION (PROTOCOL SERVER-ON STREAM SERVER)
  (CATCH 'EVAL-SERVER-EXIT
    (COND ((AND (NULL SERVER-ON) (NOT (EQUAL USER-ID "")))
	   (SEND STREAM ':REJECT (FORMAT NIL "This machine is in use by ~A" USER-ID))
	   (THROW 'EVAL-SERVER-EXIT NIL))
	  ((EQ SERVER-ON ':NOTIFY)
	   (TV:NOTIFY NIL "Use of ~A server by ~A"
		      PROTOCOL (HOST-SHORT-NAME (SEND STREAM ':FOREIGN-HOST)))
	   (PROCESS-ALLOW-SCHEDULE)
	   (SEND STREAM ':ACCEPT))
	  (T
	   (SEND STREAM ':ACCEPT)))
    (SETQ SI:WHO-LINE-JUST-COLD-BOOTED-P NIL)
    ;; Don't blow machine away on lossage.
    (CATCH-ERROR
      (WITH-OPEN-STREAM (STREAM STREAM)
	(FUNCALL SERVER STREAM))
      NIL)))

;;; Note that the connection will be closed if there is a read-time error
;;; since the call to READ lies outside the CATCH-ERROR.
(DEFINE-SERVER :EVAL (:MEDIUM :BYTE-STREAM :REJECT-UNLESS-TRUSTED T :WHO-LINE T
		      :STREAM (STREAM :ACCEPT-P NIL))
  (EVAL-SERVER-FUNCTION ':EVAL EVAL-SERVER-ON STREAM #'EVAL-SERVER))

(DEFUN EVAL-SERVER (TERMINAL-IO)
  (DO ((INPUT)) (NIL)
    (IF (EQ (SETQ INPUT (READ TERMINAL-IO 'QUIT)) 'QUIT)
	(THROW 'EVAL-SERVER-EXIT NIL))
    (CONDITION-CASE (ERROR)
	(PRINT (MULTIPLE-VALUE-LIST (EVAL INPUT)))
      ((ERROR PDL-OVERFLOW)
       (TERPRI)
       (PRINC ERROR)))
    (SEND TERMINAL-IO ':TYO #\NEWLINE)
    (SEND TERMINAL-IO ':FORCE-OUTPUT)
    ;; Update the idle time.
    (SETQ TV:KBD-LAST-ACTIVITY-TIME (TIME))))

;;;; Universal PRINT-DISK-LABEL

;;; To make this work on the Chaosnet, you need to do
;;; (chaos:add-contact-name-for-protocol :print-disk-label "PRINT-DISK-LABEL")

(DEFINE-SERVER :PRINT-DISK-LABEL (:MEDIUM :BYTE-STREAM :STREAM STANDARD-OUTPUT)
  (PRINT-DISK-LABEL))

(DEFINE-PROTOCOL :LOCAL-PRINT-DISK-LABEL (:PRINT-DISK-LABEL :LOCAL)
  (:INVOKE (IGNORE)
   (PRINT-DISK-LABEL)))

(DEFINE-PROTOCOL :NETWORK-PRINT-DISK-LABEL (:PRINT-DISK-LABEL :BYTE-STREAM)
  (:DESIRABILITY .8)
  (:INVOKE-WITH-STREAM-AND-CLOSE ((NET-STREAM ':ASCII-TRANSLATION T))
   (STREAM-COPY-UNTIL-EOF NET-STREAM STANDARD-OUTPUT)
   (CLOSE NET-STREAM T)))

(DEFUN PRINT-DISK-LABEL-ANY (HOST)
  (INVOKE-SERVICE-ON-HOST ':PRINT-DISK-LABEL (PARSE-HOST HOST)))



;;; Notify protocol and servers

(DEFUN MAKE-NOTIFY-RFC (MESSAGE &KEY (ERROR-P NIL) (REPORT NIL) (ERROR-STREAM ERROR-OUTPUT))
  (LET ((RFC (STRING-APPEND "from " USER-ID #/@ SI:LOCAL-PRETTY-HOST-NAME
			    ": " (STRING-THIN MESSAGE :REMOVE-BITS T)))
	(MAX-SIZE (- CHAOS:MAX-DATA-BYTES-PER-PKT (STRING-LENGTH "NOTIFY "))))
    (WHEN (> (STRING-LENGTH RFC) MAX-SIZE)
      D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");; The message is too long for sending.
0      (LET ((TRUNCATE (NOT ERROR-P)))
	(WHEN ERROR-P
	  (CL:CERROR
	    "Truncate the message."
	    "Message too long to fit in one packet. ~
Total length must be less than ~D characters."
	    CHAOS:MAX-DATA-BYTES-PER-PKT)
	  (SETQ TRUNCATE T))
	(WHEN TRUNCATE
	  (SETQ RFC (NSUBSTRING RFC 0 MAX-SIZE))
	  (WHEN REPORT
	    (FORMAT ERROR-STREAM "~&Message truncated to fit into one packet.")))))
    RFC))

(DEFUN PRINT-NOTIFY-RFC (STRING HOST NETWORK)
  (IF (AND (STRING-EQUAL "From " STRING 0 0 5 5)
	   (STRING-SEARCH ": " STRING 5))
	(TV:NOTIFY NIL "~A" STRING)
	(TV:NOTIFY NIL "From ~A: ~A" HOST STRING))
  ;; Special hack, maybe this notify says that the host is available for service
  ;; again.
  (WHEN HOST
    (SEND HOST ':SET-AVAILABLE ':NETWORK NETWORK ':SERVER T)))

(DEFVAR *LAST-NOTIFICATION-STRING* (CL:MAKE-STRING 1500. :AREA NETWORK-CONS-AREA)
  "The string from the last notification packet received to avoid duplicate notifcations")

(DEFVAR *LAST-NOTIFICATION-LENGTH* 0)

(DEFVAR *DUPLICATE-NOTIFICATION-WINDOW* (* 10. 60.)	;10 seconds
  "Time period during which duplicate notifications are ignored (in 60ths).")

(DEFVAR *LAST-NOTIFICATION-TIME* 0
  "Time last notification was received.")

(DEFVAR *LAST-NOTIFICATION-HOST* NIL
  "Host that sent the last notification")

(DEFINE-SERVER :NOTIFY (:MEDIUM :DATAGRAM :NETWORK NETWORK :ADDRESS ADDRESS
				:REJECT-UNLESS-TRUSTED T
				:REQUEST-ARRAY (REQUEST-ARRAY REQUEST-START REQUEST-END))
   (LET ((PKT-LENGTH (- REQUEST-END REQUEST-START))
	 (HOST (LET ((*INHIBIT-VALIDITY-CHECKING* T))
		 (GET-HOST-FROM-ADDRESS ADDRESS NETWORK T))))
     (SYS:WITH-STACK-ARRAY (PKT-STRING PKT-LENGTH :TYPE 'ART-STRING
				       :DISPLACED-TO REQUEST-ARRAY
				       :DISPLACED-INDEX-OFFSET REQUEST-START)
       ;; Ignore duplicates from the same host within the last *DUPLICATE-NOTIFICATION-WINDOW*
       ;; seconds.
       (UNLESS  (AND
		  (= *LAST-NOTIFICATION-LENGTH* PKT-LENGTH)
		  HOST *LAST-NOTIFICATION-HOST*
		  (NS-EQ HOST *LAST-NOTIFICATION-HOST*)
		  (NOT (TIME-ELAPSED-P *DUPLICATE-NOTIFICATION-WINDOW*
				       *LAST-NOTIFICATION-TIME*))
		  ;; save the most costly comparision for last
		  (STRING-EQUAL PKT-STRING *LAST-NOTIFICATION-STRING*
				0 0 PKT-LENGTH PKT-LENGTH))
	 (SETQ *LAST-NOTIFICATION-TIME* (TIME)
	       *LAST-NOTIFICATION-HOST* HOST
	       *LAST-NOTIFICATION-LENGTH* PKT-LENGTH)
	 (COPY-ARRAY-PORTION PKT-STRING 0 PKT-LENGTH *LAST-NOTIFICATION-STRING* 0 PKT-LENGTH)
	 (PRINT-NOTIFY-RFC PKT-STRING HOST NETWORK))))
   (VALUES T "Done"))

(DEFINE-PROTOCOL :NOTIFY (:NOTIFY :DATAGRAM)
  (:INVOKE (SAP)
    (DESTRUCTURING-BIND (MESSAGE) (SERVICE-ACCESS-PATH-ARGS SAP)
      (WITH-OPEN-STREAM
	(STREAM (GET-CONNECTION-FOR-SERVICE SAP :RFC-DATA MESSAGE))
	(MULTIPLE-VALUE-BIND (DATAGRAM START END)
	    (SEND STREAM :READ-INPUT-BUFFER)
	  ;; Copy the response into an array for return since we can throw away the datagram
	  ;; before we get to see the response
	  (LET ((RESPONSE-LENGTH (- END START)))
	    (WITH-STACK-ARRAY
	      (STRING-ARRAY RESPONSE-LENGTH :TYPE ART-STRING :DISPLACED-TO DATAGRAM
			    :DISPLACED-INDEX-OFFSET START)
	      (LET ((RETURN-ARRAY (MAKE-ARRAY RESPONSE-LENGTH :TYPE ART-STRING)))
		(COPY-ARRAY-PORTION STRING-ARRAY 0 RESPONSE-LENGTH RETURN-ARRAY 0
				    RESPONSE-LENGTH)
		RETURN-ARRAY))))))))

(DEFUN NOTIFY (HOST &OPTIONAL MESSAGE &KEY (ERROR-P NIL) (REPORT NIL)
	       (ERROR-STREAM ERROR-OUTPUT))
  (FS:FORCE-USER-TO-LOGIN)
  (SETQ HOST (PARSE-HOST HOST))
  (UNLESS MESSAGE
    (SETQ MESSAGE (ZWEI:QSEND-GET-MESSAGE (STRING HOST))))
  (SETQ MESSAGE (MAKE-NOTIFY-RFC MESSAGE :ERROR-P ERROR-P :REPORT REPORT
				 :ERROR-STREAM ERROR-STREAM))
  (LET ((PATHS (IF ERROR-P
		   (FIND-PATHS-TO-SERVICE-ON-HOST :NOTIFY HOST NIL T)
		   (LIST 
		     (CONDITION-BIND 
		       ((HOST-DOES-NOT-SUPPORT-SERVICE
			  #'(LAMBDA (ERROR)
			      (WHEN REPORT
				(FORMAT ERROR-STREAM "~&Host ~A does not support NOTIFY ~
                                                        service, adding it locally"
					HOST))
			      (HOST-DOES-NOT-SUPPORT-PROTOCOL-USE-FIRST-PATH ERROR))))
		       (FIND-PATH-TO-SERVICE-ON-HOST :NOTIFY HOST))))))
    (WHEN PATHS
      (LOOP WITH SUCCESS = NIL
	    WITH ERRORS = NIL
	    WITH RETURN-VALUE = NIL
	    FOR PATH IN PATHS
	    DO
	;; Try all paths until at least one succeeds
	(CONDITION-CASE-IF (NOT ERROR-P) (ERROR)
	     (SETQ RETURN-VALUE (INVOKE-SERVICE-ACCESS-PATH PATH (LIST MESSAGE)))
	   (CONNECTION-ERROR
	     (PUSH ERROR ERRORS))
	   (:NO-ERROR
	     (SETQ SUCCESS T)))
	    WHEN SUCCESS RETURN RETURN-VALUE	;Return what we got from the packet.
	    FINALLY
	      ;; Nothing won, print the errors we received,
	      (WHEN REPORT
		(LOOP FOR ERROR IN ERRORS DO
		  (SEND ERROR-STREAM :FRESH-LINE)
		  (SEND ERROR ':REPORT ERROR-STREAM)))))))

(DEFVAR *MULTIPLE-NOTIFY-TIMEOUT* (* 60. 10.)	;10 seconds
  "The timeout used by NOTIFY-HOSTS and all its callers")

;;; Someday broadcasts could be used but the protocol definition would need some changes to
;;; collect the responses, if desired.
(DEFUN NOTIFY-HOSTS (HOSTS &OPTIONAL MESSAGE &KEY (REPORT T) (ERROR-P NIL)
		     (OUTPUT-STREAM ERROR-OUTPUT))
  (DECLARE (VALUES HOSTS-NOT-RESPONDING))
  (FS:FORCE-USER-TO-LOGIN)
  (UNLESS MESSAGE
    (SETQ MESSAGE (ZWEI:QSEND-GET-MESSAGE (FORMAT NIL "~{~A~^, ~}" HOSTS))))
  (SETQ MESSAGE (MAKE-NOTIFY-RFC MESSAGE :ERROR-P ERROR-P :REPORT REPORT
				 :ERROR-STREAM OUTPUT-STREAM))
  (LET ((PATHS (LOOP FOR HOST IN HOSTS
		     AS HOST-OBJECT = (PARSE-HOST HOST (NOT ERROR-P))
		     AS PATH =
			(WHEN HOST-OBJECT
			  ;; Only use the best path for each host, we don't get to do any
			  ;; retrying.
			  (IF ERROR-P
			      (FIND-PATH-TO-SERVICE-ON-HOST :NOTIFY HOST-OBJECT)
			      (CONDITION-BIND
				((HOST-DOES-NOT-SUPPORT-SERVICE
				   #'(LAMBDA (ERROR)
				       (WHEN REPORT
					 (FORMAT OUTPUT-STREAM
						 "~&Host ~A does not support NOTIFY ~
						       service, adding it locally."
						 HOST-OBJECT))
				       (HOST-DOES-NOT-SUPPORT-PROTOCOL-USE-FIRST-PATH
					 ERROR))))
				(FIND-PATH-TO-SERVICE-ON-HOST :NOTIFY HOST-OBJECT))))
		     WHEN PATH COLLECT IT))
	NOT-RESPONDING)
    (LOOP FOR PATH IN PATHS DO
      (SETF (SERVICE-ACCESS-PATH-ARGS PATH) (LIST MESSAGE)))
    (INVOKE-MULTIPLE-SERVICES
      (PATHS *MULTIPLE-NOTIFY-TIMEOUT* "Notify")
      (HOST RESPONSE)
      (SYS:CONNECTION-REFUSED
	(PUSH HOST NOT-RESPONDING)
	(WHEN REPORT
	  (FORMAT OUTPUT-STREAM "~&~A connection refused" HOST)))
      (SYS:HOST-NOT-RESPONDING
	(PUSH HOST NOT-RESPONDING)
	(WHEN REPORT
	  (FORMAT OUTPUT-STREAM "~&~A not responding" HOST)))
      (SYS:NETWORK-ERROR
	(PUSH HOST NOT-RESPONDING)
	(WHEN REPORT
	  (FORMAT OUTPUT-STREAM "~&~A ~A" HOST RESPONSE)))
      (:NO-ERROR
	(WHEN REPORT
	  (FORMAT OUTPUT-STREAM "~&~A ~A" HOST RESPONSE))))
    NOT-RESPONDING))

(DEFUN SORT-HOSTS-BY-NAME (LIST)
  (SORT LIST #'(LAMBDA (X Y) (STRING-LESSP (SEND X :NAME) (SEND Y :NAME)))))

(DEFUN NOTIFY-LOCAL-LISPMS (&OPTIONAL MESSAGE &KEY (REPORT T) (ERROR-P NIL)
			    (OUTPUT-STREAM ERROR-OUTPUT))
  (NOTIFY-LISPMS-AT-SITE *LOCAL-SITE* MESSAGE :REPORT REPORT :ERROR-P ERROR-P
			 :OUTPUT-STREAM OUTPUT-STREAM))

(DEFUN NOTIFY-LISPMS-AT-SITE (SITE-OR-SITES &OPTIONAL MESSAGE &KEY (REPORT T) (ERROR-P NIL)
			      (OUTPUT-STREAM ERROR-OUTPUT))
  (FS:FORCE-USER-TO-LOGIN)
  (UNLESS (CL:CONSP SITE-OR-SITES)
    (SETQ SITE-OR-SITES (LIST SITE-OR-SITES)))
  (SETQ SITE-OR-SITES (LOOP FOR NAME IN SITE-OR-SITES COLLECT (FIND-OBJECT-NAMED :SITE NAME)))
  (UNLESS MESSAGE
    (SETQ MESSAGE (ZWEI:QSEND-GET-MESSAGE
		    (WITH-OUTPUT-TO-STRING (S)
		      (FORMAT S "Lisp Machines at ")
		      (FORMAT-TEXTUAL-LIST SITE-OR-SITES #'PRINC
					   :STREAM S :CONJUNCTION "and")))))
  ;; Gratuitously sort the list so it prints out nice.
  (NOTIFY-HOSTS (SORT-HOSTS-BY-NAME
		  (LOOP FOR SITE IN SITE-OR-SITES APPEND (NETI:GET-LISPMS-AT-SITE SITE)))
		MESSAGE :REPORT REPORT :ERROR-P ERROR-P :OUTPUT-STREAM OUTPUT-STREAM))

;; Obsolete names
(DEFF CHAOS:NOTIFY-ALL-LMS 'NOTIFY-LOCAL-LISPMS)
(DEFF CHAOS:NOTIFY-ALL-LISPMS 'NOTIFY-LOCAL-LISPMS)

(COMPILER:MAKE-OBSOLETE CHAOS:NOTIFY-ALL-LMS
			"it has been renamed to NET:NOTIFY-LOCAL-LISPMS")

(COMPILER:MAKE-OBSOLETE CHAOS:NOTIFY-ALL-LISPMS
			"it has been renamed to NET:NOTIFY-LOCAL-LISPMS")
