;;; -*- Mode: LISP; Syntax: Common-lisp; Package: COMMON-LISP-NETWORK-INTERNALS; Base: 10; Lowercase: Yes -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

(dw:define-program-framework D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")namespace-editor
0  :select-key nil
  :system-menu t
  :command-definer t
  :inherit-from (dw:help-program)
  :command-table (:inherit-from
		   '("help-program"
		     "accept-values-pane-with-keyboard-commands"
		     "colon full command"
		     "standard arguments"
		     "input editor compatibility")
		   :kbd-accelerator-p 't)
  :help namespace-editor-help
  :state-variables
  ((object)					(2 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");nil if we are creating a new object
0   (name )					2;name of the object (neti:name)
0   (plist )					2;Property list of object
0   (class )					
   (namespace )
   (local nil)
   (database )					2;The list that the AVV hacks
0   (object-modified)
   (object-list)
   (add-defaults))
  :top-level (namespace-editor-top-level)
  :panes
  ((title-pane :title :height-in-lines 1 :redisplay-after-commands t
	       :default-character-style '(:eurex :italic :huge))
   (object-name :title :height-in-lines 1 :redisplay-function 'print-editor-title
		:redisplay-after-commands t)
   (object-pane :accept-values :accept-values-function 'avv-function
		:size-from-output nil :redisplay-after-commands t
		:typeout-window t
		:automatically-remove-typeout-window nil
		:margin-components
		`((dw:margin-ragged-borders :thickness 1)
		  (dw:margin-whitespace :margin :left
					:thickness 2)
		  (dw:margin-scroll-bar :visibility :if-needed)
		  (dw:margin-scroll-bar :margin :bottom
					:visibility :if-needed)
		  (dw:margin-white-borders :thickness 2)))
   (menu-pane :command-menu :equalize-column-widths t
	      :columns '(("Edit Object" "Save Object" "Copy Object" "Create Object"
			 "Delete Object" "Revert Object" "Insert Defaults")
			("Help" "Quit" "Locally" "Show History" "Clear History"
			 "Previous Object"))
	      :menu-level :top-level)
   (command-pane :interactor
		 :margin-components
		 `((dw:margin-ragged-borders :thickness 1)
		   (dw:margin-whitespace :margin :left :thickness 2)
		   (dw:margin-scroll-bar )
		   (dw:margin-white-borders :thickness 2))))
  :configurations
  '((dw::main (:layout
		(dw::main :column title-pane object-pane object-name row-1)
		(row-1 :row menu-pane command-pane))
	      (:sizes
		(row-1 (menu-pane :ask-window self :size-for-pane menu-pane)
		       :then (command-pane :even))
		(dw::main (title-pane 1 :lines)
			  (object-name 1 :lines)
			  (row-1 :ask-window self :size-for-pane menu-pane)
			  :then  (object-pane :even))
		))))

(defmethod 1(namespace-editor-execute-command namespace-editor)0 (command command-args)
  2;; Moved the removing of the typeout window from the command-loop (just before
0  2;; accepting a command) to here, just after accepting a command.  This makes
0  2;; clicking on something in the c-0 c-m-L display much nicer.
0  (dw:remove-window-typeout-window (dw:get-program-pane 'object-pane) :prompt-p nil)
  (apply command command-args))

(define-namespace-editor-command 1(com-remove-typeout-window)
0    ()
   (dw:remove-window-typeout-window (dw:get-program-pane 'object-pane) :prompt-p nil))

2;;; This masks the standard accelerator for SPACE so we can trap a SPACE to clear the typeout
;;; window.
0(cp:define-command-accelerator 1remove-typeout-window-or-replace-highlighted-choice-pane
0			       namespace-editor #\Space (:Echo nil) ()
  "Enter a value for the highlighted question or remove the typeout window, if exposed"
  (let* ((object-pane (dw:get-program-pane 'object-pane))
	 (typeout-p (send (send object-pane :typeout-window) :exposed-p)))
    (cond (typeout-p
	   `(com-remove-typeout-window))
	  2;; Note, this is a kludge because there is a command on SPACE so we have to call it
0	  2;; directly.
0	  (t dw::(accept-values-stream-cursor-edit-command
		   (accept-values-pane-stream)
		   'com-accept-values-pane-choose-value
		   'com-edit-accept-values-pane-query-value
		   :edit-old nil)))))

(defmethod 1(dw::program-command-evaluator namespace-editor)0 ()
  'namespace-editor-execute-command)

(defmethod 1(namespace-editor-top-level namespace-editor)0 (&rest options)
  (letf ((cp::*default-command-accelerator-echo* nil))	  ; Don't echo "  Rubout" if user types , etc.
    (apply 'dw:default-command-top-level self
	   :prompt "Namespace: "
	   :unknown-accelerator-is-command :alpha options)))

2;;; Returns T if there is a current object.
0(defun-in-flavor 1(object-p namespace-editor)0 ()
  (and class name namespace))

(defun-in-flavor 1(add-item-to-database namespace-editor)
0		 (uid indicator datum description ptype element-p required)
  (setf database (acons (if uid uid (gensym))
			(list `(,indicator
				      ,(copy-tree datum)
				      ,(string-append
					 (string-capitalize-words (symbol-name indicator))
					 (if (eq required :required) "*" ""))
				      ,description
				      ,ptype
				      ,element-p
				      ,required))
			database)))

(defun-in-flavor 1(initialize-database-for-object namespace-editor)0 ()
  (setq database nil)
  (if (getf plist :service)
      (setf (getf plist :service)
	    (sort (getf plist :service) #'string-lessp :key #'car)))	2;Sort any services
0  (when class
    (loop for (indicator (required description template))
	      on (neti:class-all-templates class) by 'cddr
	  with ptype and element-p
	  unless (eq required :internal)
	    do (multiple-value-setq (ptype element-p)
		 (template-to-presentation-type indicator template namespace description))
	       (when element-p
		 (loop for item in (getf plist indicator) do
		   (add-item-to-database nil indicator item description
					 ptype element-p required)))
	       (add-item-to-database nil indicator
				     (if element-p nil (getf plist indicator))
				     description
				     ptype element-p required)))
  (dw::clear-accept-values-stream-cursor-highlighting (dw::accept-values-pane-stream))
  (send (dw:get-program-pane 'object-pane) :clear-history))  2;Clear the object-pane

0(defun-in-flavor 1(remove-item-from-database namespace-editor)0 (uid)
  (setf database (remove (assoc uid database) database)))

(defun-in-flavor 1(update-plist-from-database namespace-editor)0 ()
  (let (item-for-plist)
    (setq plist nil)
    (loop for (indicator (nil nil template))
	      on (neti:class-all-templates class) by 'cddr do
      (setq item-for-plist 
	    (if (eq (first template) :element)	2;element-p
0		(loop for entry in (reverse database) 
		      when (and (second (second entry))
				(eq (first (second entry)) indicator))
			collect (second (second entry)))
		(loop for entry in database
		      when (and (second (second entry))
				(eq (first (second entry)) indicator))
			return (second (second entry)))))
      (if item-for-plist (setf (getf plist indicator) item-for-plist)))))
2;;; The inverse of the above, compares the plist to the database.  If different the database
;;; is initialized
0(defun-in-flavor 1(update-database-from-plist namespace-editor)0 ()
  (let ((difference-encountered 
	  (loop for entry in database do
	    (destructuring-bind (nil (indicator value nil nil nil element-p nil)) entry
	      (when (and (or value (getf plist indicator))
			 (not
			   (if element-p
			       (member value (getf plist indicator) :test #'equal)
			       (equal value (getf plist indicator)))))
		  (return t))))))
    (when difference-encountered
      (setq object-modified t)
      (initialize-database-for-object))))

(defun-in-flavor 1(push-object namespace-editor)0 ()
  (when (and name class namespace)
    (update-plist-from-database)
    (push (list object  name plist class namespace local object-modified add-defaults)
	  object-list)))

(defvar 1*inside-namespace-editor* 0nil)		2;Used by presentation-handlers

0(defparameter 1*namespace-editor-validation-functions*
0	      '((:service . validate-service-entry)
		(:address . validate-address-entry)
		(:nickname . validate-name)
		(:short-name . validate-name)))

(defmethod 1(avv-function namespace-editor)0 (stream)
  (when (and name class namespace)
    (let* ((neti:*namespace* namespace)
	   (neti:*namespace-search-list* (list namespace))
	   (*inside-namespace-editor* t))
      (loop for (current-indicator (nil nil nil))
		on (neti:class-all-templates class) by 'cddr do
	(loop for entry in (reverse database)
	      when (eq (first (second entry)) current-indicator)
		do
		  (destructuring-bind (uid (indicator value prompt description
						      ptype element-p required)) entry
		    (let ((special-function
			    (cdr (assoc indicator *namespace-function-alist*))))
		      (multiple-value-bind (new-value nil unchanged)
			  2;; This allows us to use functions to parse things and not just
0			  2;; ptypes!  The function must use the keywords listed.
0			  (if special-function
			      (funcall special-function :default value :query-identifier uid
				       :stream stream)
			      (accept ptype :prompt prompt
				      :default value
				      :query-identifier uid
				      :confirm (eq required :required)
				      :stream stream))
			(unless unchanged
			  (let ((function (assoc
					    indicator
					    *namespace-editor-validation-functions*)))
			    (when (and function new-value)
			      (apply (cdr function) new-value
				     (list class object namespace))))
			  (setq object-modified t)
			  2;; OK, somebody changed something.
0			  2;; If they cleared an item, delete it from the database
			  ;; if not required.
0			  (setf (second (second entry)) new-value)
			  (when element-p
			    (if (and value (not new-value))
				(remove-item-from-database uid))
			    (if (and new-value (not value))
				(add-item-to-database nil indicator nil description
						      ptype element-p required)))
			  (when add-defaults
			    (maybe-add-defaults self)))))))))))

(defmethod 1(print-editor-title namespace-editor)0 (stream)
  (let (title)
    (if (and class name namespace)
      (setq title
	    (string-append 
	      (format nil "Editing ~A ~A~:[ (locally)~]~:[ in namespace ~A~]"
		      class (if (symbolp name) name (send name :string)) (not local)
		      (neti:class-globally-named-p class) namespace)
	      (format nil "~:[ (modified)~]" (not object-modified))
	      (format nil "~:[ (insert defaults)~]" (not add-defaults))))
      (setq title "(No Object)"))
    (send stream :display-centered-string title)))

2;;; Default insertion DWIMing

;;; This is called only upon initialization and when anything is changed.

0(defmethod 1(maybe-add-defaults namespace-editor)0 ()
  2;; There is nothing we can do with networks and namespaces
0  (when (object-p)
    (unless (or (eq class :network)
		(eq class :namespace))
      2;; First, update the plist.  It is easier to work with than the database for our
0      2;; purposes.
0      (update-plist-from-database)
      (loop for (indicator (nil nil nil)) on (neti:class-all-templates class)
			   by 'cddr
	    with services-updated = nil
	    do
	(cond ((and (eq indicator :address) (not services-updated)
		    (getf plist :address) (getf plist :system-type))
	       2;; special case for services using addresses
0	       (setf (getf plist :service) (maybe-add-default-services plist))
	       (setq services-updated t))
	      (t
	       2;; These items are all element-p = nil
0	       (unless (getf plist indicator)
		 (setf (getf plist indicator)
		       (select indicator
			 2;; Default pretty-name to the object name, if it is not there.
0			 (:pretty-name
			  (string-capitalize
			    (if (symbolp name) (string name) (send name :string))))
			 2;; Guess that the site name is the same as the namespace name
0			 (:site
			  (net:find-object-named :site (send namespace :name)))
			 2;; Use the site's default-printer for printer and bitmap-printer
0			 ((:printer :bitmap-printer)
			  (let ((site (getf plist :site)))
			    (and site (send site :default-printer))))
			 2;; Use the default file-control-lifetime for the local host
0			 (:file-control-lifetime
			  (format nil "~D" fs:*default-file-control-connection-lifetime*))
			 2;; Use the mail-address when home-host is available and vice-versa
0			 (:home-host
			  (let ((mail-address (getf plist :mail-address)))
			    (when mail-address
			      (second mail-address))))
			 (:mail-address
			  (let ((host (getf plist :home-host))
				(id (or (getf plist :lispm-name) (send name :string))))
			    (when (and host id)
			      (list id host))))
			 2;; Default lispm-name to the user name
0			 (:lispm-name
			  (send name :string))
			 2;; Printer interfaces are most often :serial
0			 (:interface
			  :serial)))))))
      (update-database-from-plist))))

(defun 1maybe-add-default-services 0(plist)
  (remove-duplicates
    (append (getf plist :service)
	    (loop for address in (getf plist :address)
		  as network-type = (send (first address) :type)
		  append
		  (neti:commonly-supported-services (getf plist :system-type) network-type)))
    :test #'equal))
      


2;;; Commands, etc.

;;; Set this to nil if you are feeling dangerous and don't want to be prompted when saving
;;; or deleting objects
0(defparameter 1*query-for-namespace-editor-operations* 0t)


(define-namespace-editor-command 1(com-edit-object
0				   1:menu-accelerator0 "Edit1 0Object"
				   :echo nil
				   :menu-documentation
				   "Read a namespace object into the editor"
1					   )
0    ((Obj 'net:object
	  :confirm t
	  :documentation "Namespace object to edit")
     (NS `((member ,@(send obj :namespaces)))
		:when (and obj (/= (length (send obj :namespaces)) 1))
		:prompt "Namespace"
		:documentation "Namespace view to edit.")
     &key
     (locally 'boolean
	      :default local
	      :mentioned-default t
	      :documentation
	      "Whether to edit only a local copy of the object")
     (insert-defaults 'boolean
		   :default nil
		   :mentioned-default t
		   :documentation
		   "Whether to insert any default values when possible"))
   "Read an object into the Namespace Editor."
   (push-object)
   (setq object obj)
   (setq local locally)
   (setq add-defaults insert-defaults)
   (unless local
     (send object :check-validity nil t))
   (let ((namespaces (send object :namespaces)))
     (when (= (length namespaces) 1)
       (setf ns (first namespaces))))
   (setf namespace ns)
   (setq class (send object :class))
   (setq object-modified nil)
   (multiple-value-setq (name plist)
     (send object :namespace-view namespace))
   (initialize-database-for-object)
   (when add-defaults
     (maybe-add-defaults self)))


(define-namespace-editor-command 1(com-save-object
0				   :menu-accelerator "Save Object"
				   :echo nil
				   :menu-documentation
				   "Save the current object")
    (&key (force-save 'boolean
		      :default nil
		      :mentioned-default t
		      :documentation
		      "Force saving the current object even if it is not modified."))
   "Save the current object."
   2;; Validate anything that can be validated first (this even works if the object has not
0   2;; been modified.
0   (setf (dw:accept-values-pane-inhibit-redisplay self) t)	   
   (when (not (object-p))
     (format *query-io* "~&There is no object to save.")
     (return-from com-save-object))
   (let ((machine-type nil)
	 (user-properties nil))			2;For checking UX400S for EMBEDDED-IN property
0     (neti:keeping-namespace-server 
       (loop for entry in database do
	 (destructuring-bind (nil (indicator value nil nil nil nil required))
	     entry
	   2;; Check that required fields are filled in.
0	   (when (and (or (not value) (eql value "") (eq value :||))
		      (eq required :required))
	     (beep)
	     (format *error-output*
		     "Required fields must be filled in.~&There is no value in the ~A field."
		     indicator)
	     (format *query-io* "Object not saved.")
	     (return-from com-save-object))
	   2;; Run the validation functions
0	   (let ((function (assoc indicator *namespace-editor-validation-functions*)))
	     (when (and function value)
	       (apply (cdr function) value (list class object namespace))))
	   2;; Make sure they haven't left a dangling peripheral.
0	   (when (and (eq indicator :peripheral)
		      value
		      (not (rest value)))
	     (beep)
	     (format *error-output*
		     "Peripherals must be specified more completely.~&Additional parameters are needed for the ~A peripheral." (first value))
	     (format *query-io* "Object not saved.")
	     (return-from com-save-object))
	   (when (eq indicator :machine-type)    
	     (setq machine-type value))		2;Save it for later
0	   (when (and (eq indicator :user-property) value)
	     (push value user-properties))
	   )))
     2;; Unix Embeddings need to have the :EMBEDDED-IN user property
0     (when (and *print-namespace-warnings*
		(member machine-type '(:UX400S :UX400 :SOLSTICE))	2;Only there for hosts
0		(not (member :embedded-in user-properties :test #'EQ :Key #'CAR)))
       (namespace-warning
	 "The machine-type is for an embedded system but there is no EMBEDDED-IN user property"
	 object)))
   2;; All checks complete, now ask if they really want to save the object
0   (if (or object-modified force-save)
       (let ((save-it t))
	(when *query-for-namespace-editor-operations*
	  (setq save-it
		(y-or-n-p "Do you really want to save ~A ~A~:[ (locally)~]? " class
			      (if (symbolp name) name (send name :string))
			      (not local))))
	 2;; Ask again if they are trying to create a new namespace or site.
0	 2;; This should not be overridden by flags.  It is a truely dangerous operation.
0	 (if (and (not object) (neti:class-globally-named-p class))
	     (setq save-it
		   (yes-or-no-p
		     "You are about to save out a global object.  ~&This operation is normally done at site configuration time, are you really sure you want to do this? ")))
	 (when save-it
	   (update-plist-from-database)
	   (when (not local)
	     (fs:force-user-to-login))2		;make sure they are logged in
0	   (net:update-object-permanently class namespace name plist local)
	   2;; Because we ask our own namespace servers for this, there is the possibility that
0	   2;; we won't be able to get an object.  Delete-Object is the only command to use object
0	   2;; and it tries to find it as well.
0	   (if (not object)
	       (condition-case (object)
		    (setq object (neti:find-object-named class name nil))
		  (net:object-not-found)))
	   (format *query-io*  "~&~A ~A saved ~:[locally~;on the Primary Namespace Server for Namespace ~A ~&Other servers and hosts will not get updates until they ask something of the Primary Server~]."
		   class (if (symbolp name) name (send name :string)) (not local) namespace)
	   (setq object-modified nil)))
       (format *query-io* "~&No changes were made to the object so it was not saved.")))

(define-namespace-editor-command 1(com-locally
0				   :menu-accelerator "Locally"
				   :echo nil
				   :menu-documentation
				   "Toggle between editing the current object locally or globally")
    ()
   "Toggle between editing an object locally, where changes are saved only on the local
 machine, or globally, where changes are saved on the namespace server."
   (setf (dw:accept-values-pane-inhibit-redisplay self) t)	   
   (if local
       (setq local nil)
       (setq local t)))

(define-namespace-editor-command 1(com-insert-defaults
0				   :menu-accelerator "Insert Defaults"
				   :echo nil
				   :menu-documentation
				   "Toggle insertion of any possible defaults into the current object")
    ()
   "Allow the namespace editor to try to fill slots with default values for the current
 object."
   (when (object-p)
     (if add-defaults
	 (setq add-defaults nil)
	 (setq add-defaults t)
	 (maybe-add-defaults self))))

(define-namespace-editor-command 1(com-quit
0				   :menu-accelerator "Quit"
				   :echo nil
				   :menu-documentation
				   "Leave the Namespace Editor") ()
   "Deselect the Namespace Editor Frame."
   (send dw:*program-frame* :deselect))


2;;; The global CP command is actually better than this.
0(define-namespace-editor-command 1(com-delete-object
0				   :menu-accelerator "Delete Object"
				   :echo nil
				   :menu-documentation
				   "Delete the current object from the namespace")
    ()
   "Delete the current object from the namespace."
   (if (object-p)
       (let ((delete-it t))
	 (when *query-for-namespace-editor-operations*
	   (setq delete-it
		 (yes-or-no-p
		   "Are you sure you want to~:[ locally~] delete ~A ~A from namespace ~A? "
		   (not local) class (if (symbolp name) name (send name :string)) namespace)))
	 (if (and (not local) (not object))
	     (condition-case (object)
		  (setq object (neti:find-object-named class name))
		(net:object-not-found
		  (format *error-output*
			  "~&Sorry, the namespace server just contacted, does not know about ~A ~A.  ~&Perhaps it has not received an update or the object was never saved."
			  class (if (symbolp name) name (send name :string)))
		  (setq delete-it nil))))
	 (when delete-it
	 2;;; Delete the object if it really is an object
0	   (when object
	     (when (not local)
	       (fs:force-user-to-login))
	     (neti:delete-object-from-namespace object namespace local))
	 2;;; Tell them it is deleted even if it isn't.
0	   (format *query-io* "~&~A ~A has been deleted~:[ from namespace ~A~]~:[ locally~]."
		   class (if (symbolp name) name (send name :string))
		   (neti:class-globally-named-p class) namespace
		   (not local))
	   2;; Remove this object from any histories
0	   (loop for item in object-list do
	     (if (neti:ns-eq object (first item))
		 (setf object-list (remove item object-list))))
	   2;; Pop the last object (if any)
0	   (if object-list
	       (multiple-value-setq
		 (object name plist class namespace local object-modified add-defaults)
		 (apply #'values (pop object-list)))
	       2;; If all else fails...
0	       (setq object nil
		     name nil
		     plist nil
		     class nil
		     namespace nil))
	   (initialize-database-for-object)
	   (when add-defaults
	     (maybe-add-defaults self))))
       (format *query-io* "~&There is no object to delete.")))

(define-namespace-editor-command 1(com-create-object
0				   :menu-accelerator "Create Object"
				   :echo nil
				   :menu-documentation
				   "Create a namespace object")
    ((class-name `((member ,@neti:*all-classes*))  :confirm t :prompt "Class" :default nil)
     (object-name (if (neti:class-globally-named-p class-name)
		      'namespace-global-name
		      'neti:name)
		  :default nil
		  :confirm t
		  :prompt "Name"
		  :when class-name)
     &key
     (copy-from `((net:object :class ,class-name))
		:documentation "An object to provide the initial property list."
		:when (and class-name object-name)
		:default nil)
     (property-list 'expression
		    :default nil
		    :documentation "Initial property list for the object."
		    :when (and class-name object-name))
     (locally 'boolean
	      :default local
	      :mentioned-default t
	      :documentation
	      "Whether to edit only a local copy of the object")
     (insert-defaults 'boolean
		   :default nil
		   :mentioned-default t
		   :documentation
		   "Whether to insert any possible default values into the object"))
   "Create a new namespace object.  Keywords allow you to supply default information from another object."
   (push-object)
   (setq object nil)				2;We don't really have an object yet.
0   (setq class class-name)
   (setq name object-name)
   (setq add-defaults insert-defaults)
   (condition-case (object)
	(neti:find-object-named class name)
      (net:object-not-found)
      (:no-error
	(fresh-line *query-io*)
	(present object 'net:object :stream *query-io*)
	(write-string " already exists." *query-io*)
	(return-from com-create-object (values))))

   (if property-list
       (setq plist property-list)
       (setq plist nil))
   (setq local locally)
   (setq database nil)
   (setq object-modified t)
   (setq namespace (if (neti:class-globally-named-p class)
		       net:*namespace*
		       (send name :namespace)))
   2;; Clean out names from the plist of the copy-from object.  They will only make you lose.
0   (when copy-from
     (setf plist (send copy-from :property-list))
     (if (getf plist :nickname)
	 (setf (getf plist :nickname) nil))
     (if (getf plist :short-name)
	 (setf (getf plist :short-name) nil)))
   (initialize-database-for-object)
   (when add-defaults
     (maybe-add-defaults self)))

(define-namespace-editor-command 1(com-copy-object
0				   :menu-accelerator "Copy Object"
				   :echo nil
				   :menu-documentation
				   "Create a new object by copying the contents of the current object"
				   )
    ((object-name (if (neti:class-globally-named-p class)
		      'namespace-global-name
		      'neti:name)
		  :prompt "name object to create"
		  :when class
		  :confirm t)
     &key
     (locally 'boolean
	      :default local
	      :mentioned-default t
	      :documentation
	      "Create the object locally")
     (insert-defaults 'boolean
		   :default nil
		   :mentioned-default t
		   :documentation
		   "Add any possible defaults to the new object"))
   "Create a new object by copying the contents of the current object."
   (when (not (object-p))
     (format *query-io* "There is no current object to copy.")
     (return-from com-copy-object))
   (push-object)
   (setq object nil)
   (setq name object-name)
   (setq namespace (if (neti:class-globally-named-p class)
			 net:*namespace*
			 (send name :namespace)))
     (condition-case (object)
	  (neti:find-object-named class name)
	(net:object-not-found)
	(:no-error
	  (fresh-line *query-io*)
	  (present object 'net:object :stream *query-io*)
	  (write-string " already exists." *query-io*)
	  (return-from com-copy-object (values))))
     (setq local locally)
     (setq add-defaults insert-defaults)
     2;; We are using the item that is already in the database so let's update the plist
0     (update-plist-from-database)
     (setq object-modified t)
     2;; Clean out names from the plist of the copy-from object.  They will only make you lose.
0     (if (getf plist :nickname)
	 (setf (getf plist :nickname) nil))
     (if (getf plist :short-name)
	 (setf (getf plist :short-name) nil))
     (setq object-modified t)
     (initialize-database-for-object)
     (when add-defaults
       (maybe-add-defaults self)))

2;;; History mechanism

0(define-presentation-type 1namespace-editor-object 0()
   :expander 'list
   :printer ((object-list stream)
	     (destructuring-bind
	       (object name plist class namespace local modified defaults)
		 object-list
	       plist object
	       (format
		 stream
		 "~A ~A~:[ (locally)~;~] in namespace ~A~:[ (modified)~;~]~:[ (insert defaults)~;~]"
		 class (if (symbolp name) name (send name :string)) (not local) namespace
		 (not modified) (not defaults)))))

(defmethod 1(print-object-history namespace-editor)0 (stream)
  (when object-list
    (loop for object in object-list
	  do
      (format stream "~&")
      (present object 'namespace-editor-object :stream stream))))

(define-namespace-editor-command 1(com-show-history
0				   :menu-accelerator "Show History"
				   :echo nil
				   :menu-documentation
				   "Display a mouse-sensitive list of all the objects read into the Namespace Editor"
				   ) ()
  "Display a mouse sensitive list of all the objects that have been read into the Namespace Editor.
 Clicking on one of the objects makes it the current object."
   (com-previous-object :count 0))

(define-presentation-to-command-translator 1select-namespace-object
0   (namespace-editor-object
     :gesture :select
     :documentation "Select this object"
     :tester t)
   (object)
  (cp:build-command 'com-previous-object :history-object object))

(define-namespace-editor-command 1(com-previous-object
0				   :menu-accelerator "Previous Object"
				   :echo nil
				   :menu-documentation
1				   0"Select the last object displayed"1)
0    (&key
      (count 'integer
	     :default nil
	     :mentioned-default 2
	     :documentation "Numeric argument to go to the nth previous object.")
      (history-object 'namespace-editor-object :default nil
		      :documentation "A specific object from the object history"))
   
   "Selects a previous object.
   With a numeric argument, it selects the nth previous object.  The default
   argument is 2.  When the argument is 1, it rotates the entire object history.
   An argument of zero displays the object history."

   (when (and (not (object-p)) (not object-list))
     (format *query-io* "~&There is no object history.")
     (return-from com-previous-object))
   (when (and (null history-object) (null count))
     (setq count 2))
   (let ((success nil))
     (update-plist-from-database)			2;Update the current-object
0     2;; Push it on the object-list
0     (push (list object name plist class namespace local object-modified add-defaults)
	   object-list) 
     (cond
       (history-object
	(if (eq history-object (first object-list))
	    (pop object-list)
	    (multiple-value-setq (object name plist class namespace local object-modified
					 add-defaults)
	      (apply #'values history-object))
	    (setq object-list (remove history-object object-list :test #'equal))
	    (initialize-database-for-object)
	    (when add-defaults
	      (maybe-add-defaults self)))
	(setq success t))
       ((zerop count)
	(setf (dw:accept-values-pane-inhibit-redisplay self) t)	  
	(print-object-history self *standard-output*)
	(pop object-list)
	(setq success t))
       ((= count 1)
	(setq success t)
	(com-remove-typeout-window))
       ((> count 1)
	(let ((zero-base-count (1- count)))
	  (when ( count (length object-list))
	    (multiple-value-setq (object name plist class namespace local object-modified
					 add-defaults)
	      (apply #'values (nth zero-base-count object-list)))
	    (setq object-list (remove (nth zero-base-count object-list) object-list
				      :start zero-base-count :end count))
	    (initialize-database-for-object)
	    (when add-defaults
	      (maybe-add-defaults self))
	    (setq success t)))))
     (when (not success)
       (beep)
       (pop object-list))))

(cp:define-command-accelerator 1pop-previous-objects
0			       "namespace-editor" #\c-m-L
			       () (numeric-arg-p numeric-arg)
  `(com-previous-object :count
			,(if numeric-arg-p numeric-arg 2)))

(define-namespace-editor-command (1com-object-scroll
0				   :echo nil)
    ((type '((member :screen :line :beginning :end))
	   :prompt "by" :default :screen)
     (count 'integer :default +1 :prompt "repeat count"))
   "Scroll the object pane forward and back using š, m-š, c-V, and c-m-V."
1   (setf (dw:accept-values-pane-inhibit-redisplay self) t)0	   
   (let ((tv:*asynchronous-window-operation* t))
2     ;; pretend that the scroll bar was used to scroll this
     ;; so that our window-wakeup-handler will run and reformat stuff
     ;; if necessary.
0     (cp::scroll-window-command-internal type count :y (dw:get-program-pane 'object-pane))))

(cp:define-command-accelerator 1scroll-object-forward
0			       "namespace-editor" (#\scroll #\c-V)
			       (:echo nil)
			       (numeric-arg-p numeric-arg)
  `(com-object-scroll
     ,(case numeric-arg-p
	((nil :sign) :screen)
	(:infinity :end)
	(otherwise :line))
     ,numeric-arg))

(cp:define-command-accelerator 1scroll-object-backward
0			       "namespace-editor" (#\m-scroll #\m-V)
			       (:echo nil) (numeric-arg-p numeric-arg)
  `(com-object-scroll
     ,(case numeric-arg-p
	((nil :sign) :screen)
	(:infinity :beginning)
	(otherwise :line))
     ,(- numeric-arg)))

(define-namespace-editor-command 1(com-not-modified
0				   :keyboard-accelerator #\m-~
				   :echo nil) ()
   "Set the status of this object to Not Modified.  Available on m-~."
   (setf (dw:accept-values-pane-inhibit-redisplay self) t)	   
   (setq object-modified nil))


(define-namespace-editor-command 1(com-clear-history
0				   :menu-accelerator "Clear History"
				   :echo nil
				   :menu-documentation
				   "Clear the current object and the object history") ()
   "Clear the current object and all objects in the object history."
   (setf object-list nil
	 object nil
	 name nil
	 plist nil
	 database nil
	 class nil
	 namespace nil))

(define-namespace-editor-command 1(com-revert-object
0				   :menu-accelerator "Revert Object"
				   :echo nil
				   :menu-documentation
				   "Revert changes made to the current object") ()
   "Revert changes made to the current object in this editing session when editing locally.
 Otherwise, get a fresh copy of the current object by asking the namespace server."
   (when (not (object-p))
     (format *query-io* "~&There is no object to revert.")
     (return-from com-revert-object))
   2;; Try to find an object if this one has been created and saved but we haven't seen the
0   2;; update from the namespace server.
0   (if (not object)
       (condition-case (object)
	    (setq object (neti:find-object-named class name))
	  (net:object-not-found)))
   (when object
     (if (not local)
	 (send object :check-validity nil t))
     (multiple-value-setq (name plist)
       (send object :namespace-view namespace)))
   (initialize-database-for-object)
   (setq object-modified nil)
   2;; Now tell them what we did.
0   (if local
     (format *query-io*
	     "~&Changes made during this editing session have been reverted.~&Toggle locally and Revert Object to get a fresh copy of this object from the namespace server.")
     (if object
	 (format *query-io*
	     "~&A fresh copy of the current object has been read from the namespace server.")
	 (format *query-io* "~&Changes made during this editing session have been reverted.~&The current object is not known by the namespace server so a fresh copy could not be obtained.")
	 )))

(define-namespace-editor-command 1(com-refresh
0				   :keyboard-accelerator #\Refresh
				   :echo nil) ()
   "Clear the command pane history and refresh the other panes."
   (setf (dw:accept-values-pane-inhibit-redisplay self) t)	   
   (send (dw:get-program-pane 'command-pane) :clear-history)
   (send (dw:get-program-pane 'object-pane) :refresh)
   (send (dw:get-program-pane 'object-name) :refresh)
   (send (dw:get-program-pane 'title-pane) :refresh))

(cp:define-command-accelerator namespace-no-op "namespace-editor"
			       (#\return #\tab #\clear-input #\rubout #\line #\end)
			       (:echo nil) ()
  (setf (dw:accept-values-pane-inhibit-redisplay dw:*program*) t)	   
  '(cp::com-noop))


2;;; Hooks for the Help-Program
0;; Get "Help" into the menu
(dw::define-standard-menu-accelerator dw::com-help namespace-editor "Help")


(define-presentation-translator 1namespace-prompt-help
0   (dw::accept-values-query-display dw:help-topic
				    :tester (()
					     (and (variable-boundp dw:*program*)
						  (typep dw:*program*
							 'cl-neti::namespace-editor))))
   (query &key window)
  (let ((program (dw:current-program :type 'dw:help-program :window window :error-p nil))
	(prompt
	  (remove "*" (getf (dw::accept-values-query-other-accept-options query) :prompt)
		  :test #'string-equal))
	(class (format nil "~A" (namespace-editor-class dw:*program*))))
    (when (and program prompt)
      (multiple-value-bind (available record-group)
	  (dw:help-topic-available program "the" prompt class "attribute")
	(when available record-group)))))

(define-presentation-to-command-translator 1namespace-prompt-help-command
0   (dw::accept-values-query-display :gesture :command-menu-help
				    :menu nil
				:tester (()
					 (and (variable-boundp dw:*program*)
					      (typep dw:*program*
						     'cl-neti::namespace-editor))))
   (query &key window)
  (let ((program (dw:current-program :type 'dw:help-program :window window :error-p nil))
	(prompt
	  (remove "*" (getf (dw::accept-values-query-other-accept-options query) :prompt)
		  :test #'string-equal))
	(class (format nil "~A" (namespace-editor-class dw:*program*))))
    (when (and program prompt)
      (dw:help-command-if-available program "the" prompt class "attribute"))))

2;;; And a keyboard accelerator.
0(cp:define-command-accelerator help-key
			       "namespace-editor" (#\help)
			       (:echo nil) ()
  `(dw:com-help))


2;;; The global CP commands

0(cp:define-command (1com-edit-namespace-object0 :provide-output-destination-keyword nil
					      :command-table "Namespace")
    ((object '((or null net:object))
	     :prompt "A Namespace Object"
	     :documentation "Namespace object to edit"
	     :default nil)
     (namespace `((member ,@(send object :namespaces)))
		:when (and object (/= (length (send object :namespaces)) 1))
		:prompt "Namespace"
		:documentation "Namespace view to edit.")
     &key
     (locally 'boolean
	      :default nil
	      :mentioned-default t
	      :documentation
	      "Whether to edit only a local copy of the object")
     (insert-defaults 'boolean
		   :default nil
		   :mentioned-default t
		   :documentation
		   "Whether to insert any possible default values into the object"))
   (if (not (neti:remote-terminal-p))	 
       (let* ((program (select-activity "Namespace Editor":superior
					(tv:console-default-superior *terminal-io*)))
		(interactor-stream (send program :get-pane 'command-pane)))
	   (when object
	     (send interactor-stream
		   :force-kbd-input
		   (dw::make-presentation-blip
		     :presentation-type 'cp:command
		     :object
		     `(cl-neti::com-edit-object ,object ,namespace :locally ,locally
						:insert-defaults ,insert-defaults))))
	   (tv:await-window-exposure))
       (format *error-output*
	       "Sorry, objects can only be edited on the local machine for now.")))


(cp:define-command (1com-create-namespace-object0 :provide-output-destination-keyword nil
						:command-table "Namespace")
    ((class 'neti:namespace-class :prompt "Class")
     (name (if (neti:class-globally-named-p class)
	       'namespace-global-name
	       'neti:name)
	   :prompt "Name")
     &key
     (copy-from `((net:object :class ,class))
		:default nil
		:documentation "An object to provide the initial property list.")
     (property-list 'expression
		    :default nil
		    :documentation "Initial property list for the object.")
     (locally 'boolean
	      :default nil
	      :mentioned-default t
	      :documentation
	      "Whether to edit only a local copy of the object")
     (insert-defaults 'boolean
		   :default nil
		   :mentioned-default t
		   :documentation
		   "Whether to insert any possible default values into the new object"))
   (if (not (neti:remote-terminal-p))
       (let* ((program (select-activity "Namespace Editor" :superior
					(tv:console-default-superior *terminal-io*)))
	      (interactor-stream (send program :get-pane 'command-pane)))
	 (when (and class name)
	   (send interactor-stream
		 :force-kbd-input
		 (dw::make-presentation-blip
		   :presentation-type 'cp:command
		   :object
		   `(cl-neti::com-create-object ,class ,name :copy-from ,copy-from
						:property-list ,property-list
						:locally ,locally
						:insert-defaults ,insert-defaults))))
	 (tv:await-window-exposure))
       (format *error-output*
	       "Sorry, objects can only be created on the local machine for now.")))

(cp:define-command (1com-show-namespace-object0 :command-table "Namespace")
    ((object 'net:object)
     &key
     (locally 'boolean
	      :prompt "Show local copy without checking validity?"
	      :default nil
	      :mentioned-default t
	      :documentation
	      "Specify :LOCALLY to show the information about this object
currently in virtual memory.  The default is to get the latest
information about this object from a namespace server.")
     (format '((member :detailed :normal))
	     :default :normal
	     :mentioned-default :detailed
	     :documentation "Whether to show fields with no assigned value."))
   (unless locally
     (send object :check-validity nil t))
   (let ((class (send object :class)))
     (dolist (namespace (send object :namespaces))
       (let ((net:*namespace* namespace))
	 (multiple-value-bind (primary-name property-list)
	     (send object :namespace-view namespace)
	   (setf (getf property-list :service)
		 (sort (getf property-list :service) #'string-lessp :key #'car))
	   (with-character-face (:italic)
	     (format t "~2&Showing ~A " class)
	     (present primary-name (if (neti:class-globally-named-p class)
				       'namespace-global-name
				       `((neti:name :namespace ,namespace))))
	     (format t " in namespace ~A:" namespace))
	   (loop for (indicator (required description template))
		     on (neti:class-all-templates class) by 'cddr do
	     description			; ignore
	     (unless (eq required :internal)
	       (let ((value (getf property-list indicator)))
		 (when (or value (eq format :detailed))
		   (multiple-value-bind (ptype element-p)
		       (template-to-presentation-type indicator template namespace nil)
		     (flet ((presenter (value)
			      (format t
				      "~&~A: "
				      (string-capitalize-words (symbol-name indicator)))
			      (if value
				  (present value ptype)
				  (format t "~'ino value~"))))
		       (if element-p
			   (mapc #'presenter value)
			   (presenter value)))))))))))))

(defun 1make-service-string 0(services &optional (conjunction "and"))
  (with-output-to-string (s)
    (format-textual-list services
			 #'(lambda (object str)
			     (format str "~@\\presentation\\" object 'service-entry))
			 :conjunction conjunction
			 :stream s)))
(defun 1find-hosts 0(namespace site type)
  (format *query-io*
	  "~&Finding all the hosts~@[ of type ~A~] in namespace ~A~@[ and in site ~A~]"
	  type namespace site)
  (let ((plist (append (when site (list :site site))
		       (when type (list :system-type type)))))
    (let ((net:*namespace-search-list* (list namespace)))
      (neti:keeping-namespace-server
	(apply 'neti:find-objects-from-property-list :host plist)))))
(defun 1add-services 0(services list-of-hosts &optional namespace locally (verbose t))
  (neti:keeping-namespace-server
    (tv:dolist-noting-progress (host list-of-hosts " ")
      (filling-output (t :after-line-break " ")
	(tv:alter-progress-note-text
	  (format nil "Adding service~P to host ~A~@[ (locally)~]."
		  (length services) host locally))
	(let ((services-to-add nil)
	      (name (send host :primary-name))
	      (ns namespace))
	  (when (not (stringp host))		2;Protection
0	    (if (not locally)
		(send host :check-validity nil t))	2;Get a fresh copy of the host
0	    (when (not ns)
	      (setq ns (send name :namespace)))
	    (if (not (and ns (eq ns (send name :namespace))))	2;Just to be sure.
0		(format *error-output*
			"~&Can't determine which namespace to use for host ~A.  It will have to be modified separately." host)
	      (multiple-value-bind (nil plist)
		  (send host :namespace-view ns)
		(dolist (s services)
		  (unless (member s (getf plist :service) :test #'equal)
		    (pushnew s services-to-add :test #'equal)))
		(setq services-to-add (reverse services-to-add))
		2;; No use in adding services to a host that already supports them.
0		(when (and verbose (null services-to-add))
		  (format t "~&Host ~A already supports the service~P ~A."
			  host (length services) (make-service-string services)))
		(when services-to-add
		  2;; Do it.
0		  (dolist (s services-to-add)
		    (setf (getf plist :service) (push s (getf plist :service))))
		  (neti:update-object-permanently :host ns name plist locally)
		  (when verbose
		    (format t "~&Service~P ~A added to host ~A in namespace ~A."
			    (length services-to-add) (make-service-string services-to-add)
			    host ns)
		    )))))))))
  (format t "~&  Done."))
(cp:define-command (1com-add-services-to-hosts0 :command-table "Namespace"
					      :provide-output-destination-keyword nil)
    ((services '((sequence service-entry)) :prompt "service triples (service)"
	       :default nil)
     (hosts '((type-or-string ((sequence neti:host))))
	    :prompt "a sequence of hosts or All"
	    :default nil)
     &key
     (namespace '((neti:object :class :namespace))
		:when (and (stringp hosts) (string-equal hosts "All"))
		:default nil
		:documentation "Only add these services to hosts in this namespace."
		:prompt "A namespace")
     (site '((neti:object :class :site))
	   :when (and (stringp hosts) (string-equal hosts "All"))
	   :default nil
	   :documentation "Only add these services to hosts in this site."
	   :prompt "a site")
     (locally 'boolean
	      :default nil
	      :mentioned-default t
	      :documentation "Only add the services locally.")
     (type 'namespace-global-name
	   :when (and (stringp hosts) (string-equal hosts "All"))
	   :default nil
	   :documentation "Only add these services to hosts of this type."
	   :prompt "a system type")
     (verbose 'boolean
	      :default t
	      :mentioned-default nil
	      :documentation "Print messages for each host modified."))
   2;; Check to see if these are valid services.
0   (and (loop with warning-p = nil
	      for s in services
	      do (when (validate-service-entry s) (setq warning-p t))
	      finally (return warning-p))
	(not (yes-or-no-p "Do you still want to add this services? "))
	(return-from com-add-services-to-hosts))
   (let ((valid-p t)
	 (all-query (and (stringp hosts) (string-equal hosts "All"))))
     2;; Setup the list of hosts when "All" is specified.
0     (when all-query
       (when (not namespace)
	 (setf namespace (if (not site)
			     net:*namespace*
			   (first (send site :namespaces)))))
       (multiple-value-setq  (hosts valid-p)
	 (find-hosts namespace site type)))
     2;; Tell them if things are out of date.
0     (When (and (not valid-p) (not locally))
       (if (not (Yes-or-no-p "The namespace information is not completely up to date, do you still want to do this? "))
	   (return-from com-add-services-to-hosts)))
     2;; Remove the duplicate hosts and sort them (sort of).
0     (setf hosts (sort (remove-duplicates hosts :test 'neti:ns-eq) #'string-lessp))
     2;; Warn them that this might take awhile.
0     (When (> (length hosts) 5)
       (filling-output ()
	 (format t "~&~D hosts have been found in search space specified.
It may take some time to add ~A to the hosts that do not already support it."
		 (length hosts) (make-service-string services)))
       (if (not (yes-or-no-p "~&Are you sure you want to do this? "))
	   (return-from com-add-services-to-hosts)))
2     ;; Well, they asked for it....
0     (format t "~2&Adding service~P ~A to hosts~@[ of type ~A~]~@[ in namespace ~A~]~@[ and in site ~A~]~@[ (locally)~]."
	     (length services) (make-service-string services) type namespace site locally)
     (when (not locally)
       (fs:force-user-to-login))
     (add-services services hosts namespace locally verbose)))
2;;; This does the work of removing the services
0(defun 1remove-services 0(services list-of-hosts &optional locally (verbose t))
  (neti:keeping-namespace-server
    (tv:dolist-noting-progress (host list-of-hosts " ")
      (filling-output (t :after-line-break " ")
	(tv:alter-progress-note-text
	  (format nil "Removing service~P from host ~A~@[ (locally)~]."
		  (length services) host locally))
	(let ((services-to-remove nil))
	  (if (not locally)
	      (send host :check-validity nil t))	2;Get a fresh copy of the host
0	  2;; We have to delete the services from all of the namespaces that the host lives in.
0	  (loop for namespace in (send host :namespaces) do
	    (when (not (eq (send namespace :name) :dial))	2;Sigh
0	      (multiple-value-bind (name plist)
		  (send host :namespace-view namespace)
		(dolist (s services)
		  (when (member s (getf plist :service) :test #'equal)
		    (pushnew s services-to-remove :test #'equal)))
		(setq services-to-remove (reverse services-to-remove))
		2;; No use in removing a service from a host that already doesn't support it.
0		(when (and verbose (null services-to-remove))
		  (format t "~&Host ~A does not support the service~P ~A in namespace ~A."
			  host (length services) (make-service-string services "or") namespace))
		(when services-to-remove
		  (dolist (s services-to-remove)
		    (setf (getf plist :service)
			  (remove s (getf plist :service) :test #'equal)))
		  (neti:update-object-permanently :host namespace name plist locally)
		  (when verbose
		    (format t "~&Service~P ~A removed from host ~A in namespace ~A."
			    (length services-to-remove)
			    (make-service-string services-to-remove) host namespace))))))))))
  (format t "~&  Done."))

2;;; Rather than quering to get a list of hosts that support the service to be removed, this
;;; finds all the hosts and does a :check-validity (if not locally) so that it is sure that
;;; the host does not support the service.  This means there are more hosts to go through
;;; but the end result is more certain.
0(cp:define-command (1com-remove-services-from-hosts0 :command-table "Namespace"
						   :provide-output-destination-keyword nil)
    ((services '((sequence service-entry)) :prompt "service triples (service)"
	       :default nil)
     (hosts '((type-or-string ((sequence neti:host))))
	    :prompt "a sequence of hosts or All"
	    :default nil)
     &key
     (namespace '((neti:object :class :namespace))
		:when (and (stringp hosts) (string-equal hosts "All"))
		:default nil
		:documentation "Only remove these services from hosts in this namespace."
		:prompt "a namespace")
     (site '((neti:object :class :site))
	   :when (and (stringp hosts) (string-equal hosts "All"))
	   :default nil
	   :documentation "Only remove these services from hosts in this site."
	   :prompt "a site")
     (locally 'boolean
	      :default nil
	      :mentioned-default t
	      :documentation "Only remove the services locally.")
     (type 'namespace-global-name
	   :when (and (stringp hosts) (string-equal hosts "All"))
	   :default nil
	   :documentation "Only remove these services from hosts of this type."
	   :prompt "a system type")
     (verbose 'boolean
	      :default t
	      :mentioned-default nil
	      :documentation "Print messages for each host modified."))
   (let ((valid-p t)
	 (all-query (and (stringp hosts) (string-equal hosts "All"))))
     2;; Setup the list of hosts when "All" is specified.
0     (when all-query
       (when (not namespace)
	 (setf namespace (if (not site)
			     net:*namespace*
			   (first (send site :namespaces)))))
       (multiple-value-setq  (hosts valid-p)
	 (find-hosts namespace site type)))
     2;; Tell them if things are out of date.
0     (When (and (not valid-p) (not locally))
       (if (not (Yes-or-no-p "The namespace information is not completely up to date, do you still want to do this? "))
	   (return-from com-remove-services-from-hosts)))
     2;; Remove the duplicate hosts and sort them (sort of).
0     (setf hosts (sort (remove-duplicates hosts :test 'neti:ns-eq) #'string-lessp))
     2;; Warn them that this might take awhile.
0     (When (> (length hosts) 5)
       (filling-output ()
	 (format t "~&~D hosts have been found in search space specified.
It may take some time to remove ~A from the hosts that support it."
		 (length hosts) (make-service-string services)))
       (if (not (yes-or-no-p "~&Are you sure you want to do this? "))
	   (return-from com-remove-services-from-hosts)))
2     ;; Well, they asked for it....
0     (format t "~2&Removing service~P ~A from hosts~@[ of type ~A~]~@[ in namespace ~A~]~@[ and in site ~A~]~@[ (locally)~]."
	     (length services) (make-service-string services) type namespace site locally)
     (when (not locally)
       (fs:force-user-to-login))
     (remove-services services hosts locally verbose)))


2;;; Kludge the old form so the stubborn can still use it to some degree.
0(defun 1tv:edit-namespace-object
0       (&optional
	(class (accept 'neti:namespace-class))
	(name (accept (if (neti:class-globally-named-p class)
			  'namespace-global-name
			  'neti:name)))
	&key locally create property-list new wait)
  (ignore new wait)
  (let* ((object (neti:find-object-named class name))
	(namespaces (send object :namespaces)))
    (if create
	(com-create-namespace-object class name :property-list property-list :locally locally)
	(if (rest namespaces)
	    2;; Can't get locally to work in this case, let them toggle it in the editor
0	    (com-edit-namespace-object object
				       (first namespaces))
	    (com-edit-namespace-object object)))))

(cp:define-command (1com-delete-namespace-object0 :provide-output-destination-keyword nil
						:command-table "Namespace")
    ((object 'net:object
	     :documentation "Namespace object to delete.")
     (namespace `((member ,@(send object :namespaces)))
		:when (/= (length (send object :namespaces)) 1)
		:prompt "Namespace"
		:documentation "Namespace view to delete.")
     &key (locally 'boolean
		   :default nil
		   :mentioned-default t
		   :documentation
		   "Whether to delete only a local copy of the object"))
   (let ((namespaces (send object :namespaces)))
     (when (= (length namespaces) 1)
       (setf namespace (first namespaces))))
   (when (y-or-n-p "Are you sure you want to~:[ locally~] delete ~A ~A from the ~A namespace? "
		   (not locally) (send object :class) object namespace)
     (when (not locally)
       (fs:force-user-to-login))
     (neti:delete-object-from-namespace object namespace locally)))
