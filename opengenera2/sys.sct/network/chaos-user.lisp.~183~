;;; -*- Mode: LISP; Package: CHAOS; Base: 8 -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

(DEFUN CONNECT (host CONTACT-NAME
		&OPTIONAL (WINDOW-SIZE *DEFAULT-WINDOW-SIZE*) (TIMEOUT *HOST-CONNECT-TIMEOUT*)
		&AUX CONN (TRY 1))
  (NET:WITH-CONNECTION-RETRYING (HOST CONTACT-NAME TRY-REASON)
    (IF (EQ TRY-REASON ':LONGER-TIMEOUT) (SETQ TRY (* TRY 2)))
    (SETQ CONN NIL)
    (ASSURE-ENABLED)
    (UNWIND-PROTECT
      (PROGN (SETQ CONN (OPEN-CONNECTION host CONTACT-NAME WINDOW-SIZE))
	     (WAIT-FOR-CONNECT CONN 'open-state (AND (NEQ TRY-REASON ':WAIT-INDEFINITELY)
						     TIMEOUT
						     (* TIMEOUT TRY)))
	     (PROG1 CONN (SETQ CONN NIL)))
      (WHEN CONN (REMOVE-CONN CONN)))))

(DEFUN SIMPLE (HOST CONTACT-NAME &OPTIONAL (TIMEOUT *HOST-CONNECT-TIMEOUT*)
	       &AUX CONN (TRY 1))
  (NET:WITH-CONNECTION-RETRYING (host CONTACT-NAME TRY-REASON)
    (IF (EQ TRY-REASON ':LONGER-TIMEOUT) (SETQ TRY (* TRY 2)))
    (SETQ CONN NIL)
    (ASSURE-ENABLED)
    (UNWIND-PROTECT
      (PROGN (SETQ CONN (OPEN-CONNECTION HOST CONTACT-NAME 1))
	     (WAIT-FOR-CONNECT CONN 'answered-state (AND (NEQ TRY-REASON ':WAIT-INDEFINITELY)
							 TIMEOUT
							 (* TIMEOUT TRY)))
	     (GET-NEXT-PKT CONN))
      (WHEN CONN (REMOVE-CONN CONN)))))

(defun wait (conn state timeout
	     &optional (whostate "Chaos Wait")
	     &aux (start-time (time)))
   (do () (nil)
     (if (neq state (state conn))
	 (return t))
     (when timeout
       (if ( (time-difference (time) start-time) timeout)
	   (return nil)))
     (setf (conn-owning-process conn) *current-process*)
     (process-wait whostate
		   #'(lambda (conn state start-time timeout)
		       (or (neq (state conn) state)
			   (and timeout
				( (time-difference (time) start-time)
				   timeout))))
		   conn state start-time timeout)
     (setf (conn-owning-process conn) nil)))


(defun open-connection (host contact-name &optional (window-size *default-window-size*)
			&aux address pkt conn)
  (multiple-value (address host) (address-parse host))
  (check-arg contact-name
	     (and (stringp contact-name)
		  (<= 1 (array-active-length contact-name) max-data-bytes-per-pkt))
	     "a string between 1 and 488 bytes")
  (check-arg window-size numberp "a number")
  
  (unwind-protect ;; to free connection if something goes wrong
    (progn (setq conn (make-connection))
	   (setf (local-window-size conn) (max 1 (min window-size *maximum-window-size*)))
	   (setf (local-address conn) (multiple-value-bind (interface ignore valid)
					  (route-destination-address address)
					(or (and valid (send interface ':protocol-address
							     *local-chaosnet*))
					    my-address)))
	   (setf (foreign-host conn) host)
	   (setf (foreign-address conn) address)
	   (setf (contact-name conn) contact-name)
	   
	   (setq pkt (get-pkt))
	   (setf (pkt-opcode pkt) rfc-op)
	   (set-pkt-string pkt contact-name)
	   
	   (without-interrupts
	     (setf (time-last-received conn) (time))
	     (setf (last-retransmit-time conn) (time))
	     (setf (state conn) 'rfc-sent-state)
	     (setf (window-available conn) 1))
	   (send-controlled-pkt-for-conn conn (prog1 pkt (setq pkt nil)))
	   (prog1 conn (setq conn nil)))
    (when pkt (return-pkt pkt))
    (when conn (remove-conn conn))))

(defun wait-for-connect (conn expected-state timeout)
  (wait conn 'rfc-sent-state timeout (get-connect-whostate (foreign-host-or-address conn)))
  (check-connection-state conn expected-state))

(defun check-connection-state (conn expected-state)
  (let ((state (state conn)))
    (cond ((eq state 'brd-sent-state)
	   (unless (without-interrupts
		     (loop as pkt = (read-pkts conn)
			   while pkt
			   when (= (pkt-opcode pkt) ans-op)
			   return t
			   do (return-pkt (get-next-pkt conn))))
	     (error 'broadcast-connection-no-host-responding
		    ':connection conn
		    ':contact-name (contact-name conn))))
	  ((eq state expected-state))
	  ((eq state 'rfc-sent-state)
	   (let (demerit)
	     (or (setq demerit (assq (foreign-address conn) *address-demerits*))
		 (push (setq demerit (cons (foreign-address conn) 1))
		       *address-demerits*))
	     (setf (cdr demerit) (min 1000. (* (cdr demerit) 1.5s0))))
	   (error 'chaos-host-not-responding-during-connection
		  ':connection conn
		  ':contact-name (contact-name conn)))
	  ((eq state 'cls-received-state)
	   (let* ((pkt (get-next-pkt conn))
		  (str (string-append (pkt-string pkt))))
	     (return-pkt pkt)
	     (error 'chaos-connection-refused
		    ':connection conn
		    ':contact-name (contact-name conn)
		    ':reason str)))
	  (T (if (and (eq state 'open-state)
		      (neq expected-state 'open-state))
		 (close-conn conn "Expected an ANS"))
	     (error 'bad-state-in-connect
		    ':connection conn
		    ':contact-name (contact-name conn)
		    ':state state
		    ':expected-state expected-state)))))
  

  ;;
;;;;;;  A (not necessarily a good one) BRD user interface
  ;;

(defun open-broadcast-connection (&optional (window-size *default-window-size*) &aux conn)
  (check-arg window-size numberp "a number")
  (setq conn (make-connection))
  (alter-conn conn
	      local-window-size (min-max 1 window-size *maximum-window-size*)
	      foreign-host nil
	      foreign-address 0
	      foreign-address-valid nil
	      contact-name "<<no contact name provided yet>>"
	      time-last-received (time)
	      window-available 0
	      state 'brd-sent-state)
  conn)

(defun broadcast (contact-name
		  &optional (subnets ':all) (window-size *default-window-size*) (origin 0)
		  &aux conn)
  (unwind-protect				;in case bad args given
    (progn (setq conn (open-broadcast-connection window-size))
	   (broadcast-again conn contact-name subnets origin)
	   (prog1 conn (setq conn nil)))
    (when conn (remove-conn conn))))

(defun broadcast-again (conn contact-name &optional (subnets ':all) (origin 0))
  (check-arg subnets
	     (or (eq subnets ':all)
		 (and (listp subnets)
		      (do ((subnets subnets (cdr subnets)))
			  ((null subnets) t)
			(unless (and (numberp (car subnets))
				     (< 0 (car subnets) 256.))
			  (return nil)))))
	     "a set of CHAOS subnet numbers or :ALL")		 
  (check-arg contact-name
	     (and (stringp contact-name)
		  (<= (array-active-length contact-name)
		      (- max-data-bytes-per-pkt 32.)))	;for the bitmap
	     "a string")
  (unless (eq (state conn) 'brd-sent-state)
    (bad-chaos-connection-state conn "send a BRD on"))	;create conditions later
  (assure-enabled)
  (setf (contact-name conn) contact-name)
  (let ((name-length (array-active-length contact-name)))
    (loop for interface in neti:*interfaces*
	  when (and (send interface :enabled)
		    (send interface :protocol-address *local-chaosnet*))
	    do
	      (let ((pkt (get-pkt)))
		(unwind-protect
		    (progn
		      (alter-pkt pkt
				 pkt-ack-num 32.	;easiest to allocate entire bitmap
				 pkt-nbytes (+ name-length 32.)
				 pkt-opcode brd-op
				 pkt-num (pkt-num-sent conn)
				 pkt-source-address (local-address conn)
				 pkt-dest-address (if (eql origin 0)
							0
							(address-parse origin))
				 pkt-dest-index-num (ldb 0020 (foreign-index-num conn))
				 pkt-source-index-num (local-index-num conn)
				 pkt-fwd-count 0
				 )
		      (incf *brd-pkts-out*)
		      (let ((pkt-string (pkt-string pkt))
			    (pkt-array (pkt-8b-array pkt)))
			(setf (fill-pointer pkt-string) (+ name-length 32.))
			(if (eq subnets ':all)
			    (dotimes (i 32.) (setf (aref pkt-array i) #b11111111))
			    (dotimes (i 32.) (setf (aref pkt-array i) 0))	;ensure zeroed
			    (dolist (subnet subnets)
			      (setf (aref pkt-array (// subnet 8))
				    (logior (aref pkt-array (// subnet 8))
					    (lsh 1 (\ subnet 8))))))
			(copy-array-portion contact-name 0    name-length
					    pkt-string 32. (+ name-length 32.)))
		      (setf (pkt-time-transmitted pkt) (time))
		      (incf (pkt-times-transmitted pkt))
		      (transmit-pkt-1 (prog1 pkt (setq pkt nil)) interface 0 t))
		  (when pkt (return-pkt pkt))))))
  conn)


(defun open-foreign-connection (foreign-host foreign-index
				&optional (pkt-allocation 10.) #| distinguished-port |#
				&aux foreign-address conn)
  (multiple-value (foreign-address foreign-host) (address-parse foreign-host))
  (setq conn (make-connection))
  (alter-conn conn
	      local-window-size   (max 1 (min pkt-allocation *maximum-window-size*))
	      foreign-address	  foreign-address
	      foreign-host	  foreign-host
	      foreign-index-num	  foreign-index
	      state		  'foreign-state)
  (comment
    (cond (distinguished-port
	   (aset nil index-conn (ldb maximum-index-log-2-minus-1 (local-index-num conn)))
	   (setf (local-index-num conn) distinguished-port)
	   (push (cons distinguished-port conn) distinguished-port-conn-table))))	    
  conn)

  ;;
;;;;;;  Random host-info-gathering untilities
  ;;

(defun address-parse (host-spec &aux address host)
  (declare (values address host))
  (neti:collecting-namespace-errors-if t
    (cond ((and (fixp host-spec) ( 1 host-spec #o177777))
	   (values host-spec nil))
	  ((numberp host-spec) (error 'unknown-chaos-address ':address host-spec))
	  ((typep host-spec 'network:host)
	   (setq host host-spec)
	   (unless (setq address (send host ':best-chaos-address))
	     (error 'host-not-on-chaosnet ':host host))
	   (values address host))
	  ((setq host (parse-host host-spec t))
	   (unless (setq address (send host ':best-chaos-address))
	     (error 'host-not-on-chaosnet ':host host))
	   (values address host))
	  ((and (stringp host-spec) (setq address (parse-number host-spec 0 nil 8)))
	   (values address nil))
	  (t (error 'unknown-host-name ':name host-spec)))))

;HOST-DATA: returns information about a specified host.  Currently,
; returns name of machine as primary value and host number as second value
(DEFUN HOST-DATA (&OPTIONAL (HOST NETWORK:*LOCAL-HOST*) &AUX HOST-ADDRESS)
  (DECLARE (VALUES HOST-NAME HOST-ADDRESS))
  (if (numberp host)
      (setq host-address host
	    host (get-host-from-address host-address ':chaos))
      (setq host (si:parse-host host t)
	    host-address (address-parse host)))
  (values (send host ':pretty-name) host-address))

(defun host-short-name (host)
  ;;; try and coerce host into a host
  (cond ((fixp host) (setq host (get-host-from-address host ':chaos t)))
	((typep host 'network:host))
	(T (setq host (si:parse-host host t))))
  (and host (send host ':send-if-handles ':short-name)))

(defun get-connect-whostate (host)
  (let ((short-name (let ((*namespace-search-list* (send (send *local-site* ':local-namespace)
							 ':search-rules)))
		      (host-short-name host))))
    (if (null short-name)
	"Chaos Connect"
      (string-append "Chaos Connect " short-name))))

;;; I don't think anybody uses this anymore
(DEFUN GET-HOST-STATUS-PACKET (HOST)
  (condition-case (err)
      (simple host "STATUS" 300.)
    (connection-error nil)))





;;; server utilities

;;; [++ maybe this should go in NCP right next to rfc-meets-lsn?]
(defun find-rfc-for-contact-name (contact-name)
  (without-interrupts
    (do ((prev nil rfc)
	 (rfc *pending-rfc-pkts* (pkt-link rfc)))
	((null rfc) nil)
      (when (let* ((pkt-string (pkt-string rfc))
		   (pkt-string-space (string-search-char #\space pkt-string)))
	      (string-equal pkt-string contact-name 0 0 pkt-string-space))
	(cond (prev (setf (pkt-link prev)    (pkt-link rfc)))
	      (t    (setq *pending-rfc-pkts* (pkt-link rfc))))
	(return rfc)))))

(defun listen (contact-name &optional (window-size *default-window-size*) (wait-for-rfc t)
	       &aux conn)
  "Listen for an incoming RFC to CONTACT-NAME.  If WAIT-FOR-RFC is NIL, doesn't
   wait for the RFC to arrive, just sets up a queue.  Returns the CONN, ready
   to have ACCEPT, REJECT, ANSWER, or FORWARD done to it."
  (check-arg contact-name stringp "a string")
  (check-arg window-size numberp "a number")
  (unwind-protect
    (progn
      (setq conn (make-connection))
      (setf (state conn) 'listening-state)
      (setf (contact-name conn) contact-name)
      (setf (local-window-size conn) (min-max 1 window-size *maximum-window-size*))
      (prog listen (rfc)
	    (without-interrupts			;first try to pick up a pending RFC
	      (when (setq rfc (find-rfc-for-contact-name contact-name))
		(rfc-meets-lsn conn rfc)
		(return-from listen (prog1 conn (setq conn nil))))
	      (push conn *pending-listens*))
	    (cond (wait-for-rfc
		   (wait conn 'listening-state nil "Chaos Listen")
		   (or (memq (state conn) '(rfc-received-state brd-received-state))
		       (bad-chaos-connection-state conn "listen on"))))
	    (return (prog1 conn (setq conn nil)))))
    (when conn (remove-conn conn))))

;; Send an OPN, and leave conn in OPEN-STATE.
;; Note that when this returns the other end has not yet acknowledged
;; the OPN, and the window size is still 0.  Transmitting the first packet
;; will wait.
(defun accept (conn &aux pkt)
    (or (memq (state conn) '(rfc-received-state brd-received-state))
	(bad-chaos-connection-state conn "accept a Request For Connection on"))

    (free-all-read-pkts conn)			;in case RFC still there

    (setq pkt (get-pkt))			;get an OPN packet
    (setf (pkt-opcode pkt) opn-op)		;fill in the necessary fields
    (setf (pkt-nbytes pkt) 4)
    (setf (pkt-second-data-word pkt) (local-window-size conn))
    (setf (pkt-first-data-word pkt) (pkt-num-read conn))
    (setf (window-available conn) 1)		;make it look like we can send
    (setf (time-last-received conn) (time))
    (without-interrupts
      (setf (state conn) 'open-state)
      (send-controlled-pkt-for-conn conn pkt))
    T)

;;; File system access ---

(DEFVAR *ENABLE-SUBNET-SECURITY* NIL)
(DEFVAR *TRUSTED-SUBNETS* NIL)

(DEFUN ENABLE-SUBNET-SECURITY ()
  (SETQ *ENABLE-SUBNET-SECURITY* NIL)
  (LOOP FOR (NETWORK SUBNETS) IN (SEND *LOCAL-SITE* ':SECURE-SUBNETS)
	WHEN (AND (EQ (SEND NETWORK ':TYPE) ':CHAOS)
		  (NOT (CL:MEMBER "All" SUBNETS :TEST #'STRING-EQUAL)))
	  DO (SETQ *ENABLE-SUBNET-SECURITY* T
		   *TRUSTED-SUBNETS* (LOOP FOR SUBNET IN SUBNETS
					   COLLECT (PARSE-NUMBER SUBNET 0 NIL 8 T)))))

(ADD-INITIALIZATION "Enable Chaosnet Security" '(ENABLE-SUBNET-SECURITY) '(SITE NORMAL))

(DEFUN HOST-TRUSTED-P (HOST) 
  (IF *ENABLE-SUBNET-SECURITY*
      (MEMQ (LDB (BYTE 10 10) (ADDRESS-PARSE HOST)) *TRUSTED-SUBNETS*)
    T))


  ;;
;;;;;;  Various server reply possibilities
  ;;

;;; { FAST-, "" } x { ANSWER, FORWARD, REJECT } x { "", -STRING }

;;; The FAST- cases.  Try to avoid consing

;;; These could be done as macros, subst or combined to call a generic
;;; function.  However, that would probably take more room and just
;;; clutter things up. 

(defun fast-answer (contact-name pkt)
  (let ((rfc (find-rfc-for-contact-name contact-name)))
    (if rfc
	(send-reply-to-rfc rfc pkt ans-op)
      (return-pkt pkt))))

(defun fast-reject (contact-name pkt)
  (let ((rfc (find-rfc-for-contact-name contact-name)))
    (if rfc
	(send-reply-to-rfc rfc pkt cls-op)
      (return-pkt pkt))))

(defun fast-forward (contact-name pkt new-host)
  (let ((rfc (find-rfc-for-contact-name contact-name)))
    (if rfc
	(send-reply-to-rfc rfc pkt fwd-op new-host)
      (return-pkt pkt))))

(defun fast-answer-string (contact-name string)
  (let ((rfc (find-rfc-for-contact-name contact-name)))
    (when rfc (send-reply-pkt rfc ans-op string))))

(defun fast-reject-string (contact-name string)
  (let ((rfc (find-rfc-for-contact-name contact-name)))
    (when rfc (send-reply-pkt rfc cls-op string))))

(defun fast-forward-string (contact-name string new-host)
  (let ((rfc (find-rfc-for-contact-name contact-name)))
    (when rfc (send-reply-pkt rfc fwd-op string new-host))))


;;; The non-FAST- variety, i.e., reply to a connection

(defun answer-string (conn string &aux (pkt (get-pkt)))
  (set-pkt-string pkt string)
  (answer conn pkt))

(deff reject 'reject-string)

(defun reject-string (conn string)
  (let ((pkt (if (si:process-simple-p si:current-process)
		 (get-pkt nil)			D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");Can't wait if we are a simple process.
0		 (get-pkt t))))
    (if pkt
	(progn
	  (set-pkt-string pkt string)
	  (reject-with-pkt conn pkt))
	1;; Can't do anything since we don't have a packet.  Remove the connection, if it exists
0	(when conn
	  (remove-conn conn)))))

(defun forward-string (conn string new-host &aux (pkt (get-pkt)))
  (set-pkt-string pkt string)
  (forward conn pkt new-host))

(defun answer (conn pkt)
  (setf (pkt-opcode pkt) ans-op)
  (if (memq (state conn) '(rfc-received-state brd-received-state))
      (send-reply-for-conn conn pkt)
    (unwind-protect
      (bad-chaos-connection-state conn "answer")
      (return-pkt pkt)))
  (remove-conn conn))

;;; For compatibility with the previous NCP, REJECT takes CONN and REASON
;;; (see above).  Therefore, the function which takes a CONN and a PKT must
;;; be called something else, here REJECT-WITH-PKT.  Note that CLOSE-CONN
;;; takes the same arguments, but CLOSE-CONN is designed to clobber an "more
;;; complete" connection, while REJECT-WITH-PKT is for refusing RFCs.

(defun reject-with-pkt (conn pkt)
  (cond ((eq (state conn) 'rfc-received-state)
	 (setf (pkt-opcode pkt) cls-op)
	 (send-reply-for-conn conn pkt))
	((eq (state conn) 'brd-received-state)	1;Don't send a CLS to a BRD
0	 (return-pkt pkt))
	(t
	 (unwind-protect
	     (bad-chaos-connection-state conn "reject")
	   (return-pkt pkt))))
  (remove-conn conn))

(defun forward (conn pkt new-host)
  (setf (pkt-opcode pkt) fwd-op)
  (setf (pkt-ack-num pkt) new-host)
  (if (memq (state conn) '(rfc-received-state brd-received-state))
      (send-reply-for-conn conn pkt)
    (unwind-protect
      (bad-chaos-connection-state conn "forward")
      (return-pkt pkt)))
  (remove-conn conn))


  ;;
;;;;;; Streams
  ;;

;;; This is included in all chaosnet streams, input or output
(DEFFLAVOR BASIC-STREAM
	((CONNECTION NIL))
	(SI:STREAM)
  (:INITABLE-INSTANCE-VARIABLES CONNECTION))

(DEFMETHOD (:CLOSE BASIC-STREAM) (&OPTIONAL ABORT-P)
  (COND (CONNECTION				;Allowed to keep doing this
	 (CLOSE-CONN (PROG1 CONNECTION (SETQ CONNECTION NIL))
		     (IF ABORT-P "Aborted" "")
		     T))))

(DEFMETHOD (:CLOSE-WITH-REASON BASIC-STREAM) (REASON &OPTIONAL ABORT-P)
  (UNWIND-PROTECT				;unless EOF errors out
    (UNLESS ABORT-P
      (SEND SELF ':EOF))
    (UNLESS (NULL CONNECTION)
      (CLOSE-CONN (PROG1 CONNECTION (SETQ CONNECTION NIL)) REASON T))))

(DEFMETHOD (:FOREIGN-HOST BASIC-STREAM) ()
  (AND CONNECTION
       (FOREIGN-HOST-OBJECT CONNECTION)))

(DEFMETHOD (:ACCEPT BASIC-STREAM) ()
  (ACCEPT CONNECTION))

(DEFMETHOD (:REJECT BASIC-STREAM) (&OPTIONAL (REASON ""))
  (REJECT CONNECTION REASON)
  (SETQ CONNECTION NIL))

(DEFMETHOD (:NETWORK BASIC-STREAM) () *LOCAL-CHAOSNET*)

(defmethod (:connected-p basic-stream) ()
  (and connection
       (eq (state connection) 'open-state)))

(defmethod (:start-open-auxiliary-stream basic-stream)
	   (active-p &key local-id foreign-id stream-options application-id)
  ;; Contact-name must be passed through because other
  ;; networks might not allow the caller to assert arbitrary identifiers.
  (let ((contact-name (if (not active-p)
			  (or local-id (fs:file-gensym application-id)))))
    (values
      (lexpr-funcall #'make-stream
		     (if active-p
			 (open-connection (foreign-host connection) foreign-id
					  ;;window-size)  What do about this?
					  )
			 (listen contact-name *default-window-size* nil))
		     ':accept-p nil
		     stream-options)
      contact-name)))

(defmethod (:complete-connection basic-stream) (&key (timeout (* 60. 6.)))
  ;; We really want to know if we are active or passive, but this should work.
  (loop doing
	(when (null connection)
	  (error 'chaos-stream-closed :attempt "complete open" :stream self))
	(selectq (state connection)
	  (listening-state
	   (wait connection 'listening-state timeout "Chaos Listen"))
	  ((rfc-received-state brd-received-state)
	   (send self :accept)
	   (return nil))
	  (t (wait-for-connect connection 'open-state timeout)
	     (return nil)))))

(defmethod (:set-input-interrupt-function basic-stream) (function &rest args)
  (let ((sgra (copylist args)))			;Stack-consed list..
    (setf (interrupt-function connection)
	  #'(lambda (reason &rest ignore)
	      (when (memq reason '(:input :change-of-state))
		(lexpr-funcall function sgra))))))

  ;;
;;;;;;  Basic input and output
  ;;

;;; Note for posterity: There are a few reasons that INPUT-PACKET and
;;; OUTPUT-PACKET are sometimes initialized to NIL and sometimes unbound.
;;; The simple minded streams set them to NIL.  QFILE, however, leaves some
;;; things unbound as a bug-trap (which has never gone off).  This
;;; unboundness would also catch violations of protocol or other bugs.

;;; This is included in all chaosnet input streams, character and binary
(DEFFLAVOR INPUT-STREAM-MIXIN
	(INPUT-PACKET)
	(SI:BASIC-BUFFERED-INPUT-STREAM))

(DEFMETHOD (:DISCARD-INPUT-BUFFER INPUT-STREAM-MIXIN) (IGNORE)
  (RETURN-PKT INPUT-PACKET)
  (SETQ INPUT-PACKET NIL))

(defun-in-flavor (cleanup-chaos-stream-input-side input-stream-mixin) ()
  (when (and (variable-boundp input-packet)
	     input-packet)
    (return-pkt input-packet)
    (setq input-packet nil)))

(defwhopper (:close input-stream-mixin) (&optional abort-p)
  (unwind-protect
    (continue-whopper abort-p)
    (cleanup-chaos-stream-input-side)))

(defwhopper (:close-with-reason input-stream-mixin) (reason &optional abort-p)
  (unwind-protect
    (continue-whopper reason abort-p)
    (cleanup-chaos-stream-input-side)))

;;; This is included in all chaosnet output streams, character and binary
(DEFFLAVOR OUTPUT-STREAM-MIXIN
	(OUTPUT-PACKET)
	(SI:BASIC-BUFFERED-OUTPUT-STREAM))

(DEFMETHOD (:DISCARD-OUTPUT-BUFFER OUTPUT-STREAM-MIXIN) (IGNORE)
  (RETURN-PKT OUTPUT-PACKET)
  (SETQ OUTPUT-PACKET NIL))

;;;
;;; This makes sure that the output packet buffer gets deallocated correctly
;;; regardless of what state the caller leaves the stream in.
;;;
(defwhopper (:close output-stream-mixin) (&optional abort-p)
  (unwind-protect
      (continue-whopper abort-p)
    (when (and (variable-boundp output-packet) output-packet)
      (return-pkt output-packet)
      (setq output-packet nil))))

;;; This is included in simple chaosnet input streams, but not file streams, where certain
;;; opcodes have special meaning.
(DEFFLAVOR BASIC-INPUT-STREAM
	((INPUT-PACKET NIL))
	(INPUT-STREAM-MIXIN BASIC-STREAM SI:INPUT-STREAM-EXCEPTION-MIXIN))

(DEFUN-IN-FLAVOR (BASIC-INPUT-STREAM-BAD-INPUT-PACKET BASIC-INPUT-STREAM) ()
  (ERROR (IF (= (PKT-OPCODE INPUT-PACKET) CLS-OP)
	     'CHAOS-CONNECTION-CLOSED
	     'CHAOS-CONNECTION-LOST)
	 ':CONNECTION CONNECTION
	 ':ATTEMPT "read from"
	 ':REASON (STRING-APPEND (PKT-STRING INPUT-PACKET))))

(DEFMETHOD (:GET-NEXT-INPUT-PKT BASIC-INPUT-STREAM) (NO-HANG-P &AUX OP)
  (COND ((AND INPUT-PACKET (= (PKT-OPCODE INPUT-PACKET) EOF-OP))
	 (VALUES NIL T))
	((NULL CONNECTION)
	 (ERROR 'CHAOS-STREAM-CLOSED :ATTEMPT "read from" :STREAM SELF))
	((AND INPUT-PACKET
	      (OR (= (SETQ OP (PKT-OPCODE INPUT-PACKET)) CLS-OP)
		  (= OP LOS-OP)))
	 (BASIC-INPUT-STREAM-BAD-INPUT-PACKET))				  
	((AND INPUT-PACKET
	      (PROGN (FSIGNAL "BASIC-INPUT-STREAM INPUT-PACKET about to be lost!!~@
			       Proceed to return it and continue.")
		     (RETURN-PKT INPUT-PACKET))
	      NIL))
	((NULL (SETQ INPUT-PACKET (GET-NEXT-PKT CONNECTION NO-HANG-P SELF)))
	 NIL)
	(( (SETQ OP (PKT-OPCODE INPUT-PACKET)) DAT-OP)
	 (WHEN (= OP 201)
	   (RETURN-PKT (PROG1 INPUT-PACKET
			      (SETQ INPUT-PACKET NIL)))
	   (ERROR 'NETI:MARK-SEEN ':STREAM SELF))
	 T)
	((= OP EOF-OP)
	 (VALUES NIL T))
	((OR (= OP CLS-OP) (= OP LOS-OP))
	 (BASIC-INPUT-STREAM-BAD-INPUT-PACKET))
	((AND (OR (= OP RFC-OP) (= OP BRD-OP))
	      (MEMQ (STATE CONNECTION) '(RFC-RECEIVED-STATE BRD-RECEIVED-STATE)))
	 T)
	(T (ERROR 'UNKNOWN-PKT-OPCODE
		  ':CONNECTION CONNECTION
		  ':PKT INPUT-PACKET
		  ':OPCODE OP)))) 

(DEFMETHOD (:INPUT-WAIT BASIC-INPUT-STREAM) (&OPTIONAL WHOSTATE FUNCTION &REST ARGUMENTS)
  (OR INPUT-PACKET
      (NULL CONNECTION)
      (LEXPR-FUNCALL #'CONN-INPUT-WAIT CONNECTION SELF WHOSTATE FUNCTION ARGUMENTS)))

;;; There is an assumption here, which is that basic-xxx-stream first
;;; checks (via whopper or wrapper) if there is data.  If not, THEN it
;;; invokes the :LISTEN method of the thing that implements the stream.
;;; This does NOT necessarily mean INPUT-PACKET is NIL, since it may not
;;; have been discarded yet. 
(DEFMETHOD (:LISTEN BASIC-INPUT-STREAM) ()
  (OR (NULL CONNECTION)				;connection closed, so cause error on :TYI
      (CONN-LISTEN CONNECTION)))		;yes, there is data, of a sort

(DEFMETHOD (:CLEAR-EOF BASIC-INPUT-STREAM) ()
  (WHEN (AND INPUT-PACKET (= (PKT-OPCODE INPUT-PACKET) EOF-OP))
    (RETURN-PKT INPUT-PACKET)
    (SETQ INPUT-PACKET NIL)))

;;; This is included in simple chaosnet output streams, but not file streams, where a
;;; connection is maintained for longer.
(DEFFLAVOR BASIC-OUTPUT-STREAM
	()
	(OUTPUT-STREAM-MIXIN BASIC-STREAM
	 SI:OUTPUT-STREAM-EXCEPTION-MIXIN SI:BASIC-BUFFERED-OUTPUT-STREAM))

(DEFMETHOD (:EOF BASIC-OUTPUT-STREAM) ()
  (SEND SELF ':FORCE-OUTPUT)
  (SEND-PKT CONNECTION (GET-PKT) EOF-OP SELF)
  (FINISH-CONN CONNECTION "Chaos Finish" SELF))

(DEFMETHOD (:FINISH BASIC-OUTPUT-STREAM) ()
  (FINISH-CONN CONNECTION "Chaos Finish" SELF))

(DEFMETHOD (:CLOSE BASIC-OUTPUT-STREAM :BEFORE) (&OPTIONAL ABORT-P &aux completed-normally)
  (when (AND CONNECTION
	     (NOT ABORT-P)
	     (EQ (STATE CONNECTION) 'OPEN-STATE))
    (unwind-protect (progn (SEND SELF ':EOF)
			   (setq completed-normally t))
		    (unless completed-normally
		      (send self ':close t)))))

(DEFMETHOD (:SEND-MARK BASIC-OUTPUT-STREAM) ()
  (SEND SELF ':FORCE-OUTPUT)
  (SEND-PKT CONNECTION (GET-PKT) 201 SELF))

(DEFFLAVOR CHARACTER-INPUT-STREAM-MIXIN
	(INPUT-PACKET)
	(INPUT-STREAM-MIXIN BASIC-STREAM SI:BASIC-BUFFERED-INPUT-STREAM)
  ;;:GET-NEXT-INPUT-PKT returns T if INPUT-PACKET is a valid packet
  (:REQUIRED-METHODS :GET-NEXT-INPUT-PKT))

(DEFMETHOD (:NEXT-INPUT-BUFFER CHARACTER-INPUT-STREAM-MIXIN) (&OPTIONAL NO-HANG-P)
  (MULTIPLE-VALUE-BIND (PKT-AVAILABLE AT-EOF)
      (SEND SELF ':GET-NEXT-INPUT-PKT NO-HANG-P)
    (IF PKT-AVAILABLE
	(VALUES (LET ((ARRAY (CHAOS-PACKET-DATA-ALIGNED INPUT-PACKET 'ART-STRING)))
		  (SETF (FILL-POINTER ARRAY) (+ (PKT-NBYTES INPUT-PACKET) 2))
		  ARRAY)
		2
		(+ (PKT-NBYTES INPUT-PACKET) 2))
	(VALUES NIL NIL NIL AT-EOF))))

(DEFFLAVOR BINARY8-INPUT-STREAM-MIXIN
	(INPUT-PACKET)
	(INPUT-STREAM-MIXIN BASIC-STREAM SI:BASIC-BUFFERED-INPUT-STREAM)
  ;;:GET-NEXT-INPUT-PKT returns T if INPUT-PACKET is a valid packet
  (:REQUIRED-METHODS :GET-NEXT-INPUT-PKT))

(DEFMETHOD (:NEXT-INPUT-BUFFER BINARY8-INPUT-STREAM-MIXIN) (&OPTIONAL NO-HANG-P)
  (MULTIPLE-VALUE-BIND (PKT-AVAILABLE AT-EOF)
      (SEND SELF ':GET-NEXT-INPUT-PKT NO-HANG-P)
    (IF PKT-AVAILABLE
	(VALUES (LET ((ARRAY (CHAOS-PACKET-DATA-ALIGNED INPUT-PACKET 'ART-8B)))
		  (SETF (FILL-POINTER ARRAY) (+ (PKT-NBYTES INPUT-PACKET) 2))
		  ARRAY)
		2
		(+ (PKT-NBYTES INPUT-PACKET) 2))
	(VALUES NIL NIL NIL AT-EOF))))

(DEFFLAVOR BINARY-INPUT-STREAM-MIXIN
	(INPUT-PACKET)
	(INPUT-STREAM-MIXIN BASIC-STREAM SI:BASIC-BUFFERED-INPUT-STREAM)
  (:REQUIRED-METHODS :GET-NEXT-INPUT-PKT))

(DEFMETHOD (:NEXT-INPUT-BUFFER BINARY-INPUT-STREAM-MIXIN) (&OPTIONAL NO-HANG-P)
  (MULTIPLE-VALUE-BIND (PKT-AVAILABLE AT-EOF)
      (SEND SELF ':GET-NEXT-INPUT-PKT NO-HANG-P)
    (IF PKT-AVAILABLE
	(VALUES (LET ((ARRAY (CHAOS-PACKET-DATA-ALIGNED INPUT-PACKET 'ART-16B)))
		  (SETF (FILL-POINTER ARRAY) (+ (// (PKT-NBYTES INPUT-PACKET) 2) 1))
		  ARRAY)
		1
		(+ (// (PKT-NBYTES INPUT-PACKET) 2) 1))
	(VALUES NIL NIL NIL AT-EOF))))

(DEFFLAVOR CHARACTER-OUTPUT-STREAM-MIXIN
	(OUTPUT-PACKET)
	(OUTPUT-STREAM-MIXIN BASIC-STREAM SI:BASIC-BUFFERED-OUTPUT-STREAM))

(DEFMETHOD (:NEW-OUTPUT-BUFFER CHARACTER-OUTPUT-STREAM-MIXIN) ()
  (WHEN (AND (VARIABLE-BOUNDP OUTPUT-PACKET) OUTPUT-PACKET)
    (FSIGNAL "Output packet about to be lost.  Continue to return it and proceed.")
    (RETURN-PKT (PROG1 OUTPUT-PACKET (SETQ OUTPUT-PACKET NIL))))
  (SETQ OUTPUT-PACKET (GET-PKT))
  (VALUES (CHAOS-PACKET-DATA-ALIGNED OUTPUT-PACKET 'ART-STRING)
	  2 (+ MAX-DATA-BYTES-PER-PKT 2)))

(DEFUN-IN-FLAVOR (SEND-CHARACTER-PKT CHARACTER-OUTPUT-STREAM-MIXIN) (LIMIT)
  (WHEN (NULL CONNECTION)
    (ERROR 'CHAOS-STREAM-CLOSED :ATTEMPT "write to" :STREAM SELF))
  (SETF (PKT-NBYTES OUTPUT-PACKET) (- LIMIT 2))
  (SEND-PKT CONNECTION (PROG1 OUTPUT-PACKET (SETQ OUTPUT-PACKET NIL)) DAT-OP SELF))

(DEFMETHOD (:SEND-OUTPUT-BUFFER CHARACTER-OUTPUT-STREAM-MIXIN) (ARRAY LIMIT END-OF-RECORD)
  (IGNORE ARRAY END-OF-RECORD)
  (SEND-CHARACTER-PKT LIMIT))

(DEFFLAVOR BINARY8-OUTPUT-STREAM-MIXIN
	(OUTPUT-PACKET)
	(OUTPUT-STREAM-MIXIN BASIC-STREAM SI:BASIC-BUFFERED-OUTPUT-STREAM))

(DEFMETHOD (:NEW-OUTPUT-BUFFER BINARY8-OUTPUT-STREAM-MIXIN) ()
  (WHEN (AND (VARIABLE-BOUNDP OUTPUT-PACKET) OUTPUT-PACKET)
    (FSIGNAL "Output packet about to be lost.  Continue to return it and proceed.")
    (RETURN-PKT (PROG1 OUTPUT-PACKET (SETQ OUTPUT-PACKET NIL))))
  (SETQ OUTPUT-PACKET (GET-PKT))
  (VALUES (CHAOS-PACKET-DATA-ALIGNED OUTPUT-PACKET 'ART-8B)
	  2 (+ MAX-DATA-BYTES-PER-PKT 2)))

(DEFMETHOD (:SEND-OUTPUT-BUFFER BINARY8-OUTPUT-STREAM-MIXIN)  (IGNORE LIMIT IGNORE)
  (WHEN (NULL CONNECTION)
    (ERROR 'CHAOS-STREAM-CLOSED :ATTEMPT "write to" :STREAM SELF))
  (SETF (PKT-NBYTES OUTPUT-PACKET) (- LIMIT 2))
  (SEND-PKT CONNECTION (PROG1 OUTPUT-PACKET (SETQ OUTPUT-PACKET NIL)) DAT-OP SELF))

(DEFFLAVOR BINARY-OUTPUT-STREAM-MIXIN
	(OUTPUT-PACKET)
	(OUTPUT-STREAM-MIXIN BASIC-STREAM SI:BASIC-BUFFERED-OUTPUT-STREAM))

(DEFMETHOD (:NEW-OUTPUT-BUFFER BINARY-OUTPUT-STREAM-MIXIN) ()
  (WHEN (AND (VARIABLE-BOUNDP OUTPUT-PACKET) OUTPUT-PACKET)
    (FSIGNAL "Output packet about to be lost.  Continue to return it and proceed.")
    (RETURN-PKT (PROG1 OUTPUT-PACKET (SETQ OUTPUT-PACKET NIL))))    
  (SETQ OUTPUT-PACKET (GET-PKT))
  (VALUES (CHAOS-PACKET-DATA-ALIGNED OUTPUT-PACKET 'ART-16B)
	  1
	  (+ MAX-DATA-WORDS-PER-PKT 1)))

(DEFUN-IN-FLAVOR (SEND-BINARY-PKT BINARY-OUTPUT-STREAM-MIXIN) (LIMIT)
  (WHEN (NULL CONNECTION)
    (ERROR 'CHAOS-STREAM-CLOSED :ATTEMPT "write to" :STREAM SELF))
  (SETF (PKT-NBYTES OUTPUT-PACKET) (* (- LIMIT 1) 2))
  (SEND-PKT CONNECTION (PROG1 OUTPUT-PACKET (SETQ OUTPUT-PACKET NIL)) 300 SELF))

(DEFMETHOD (:SEND-OUTPUT-BUFFER BINARY-OUTPUT-STREAM-MIXIN) (ARRAY LIMIT END-OF-RECORD)
  (IGNORE ARRAY END-OF-RECORD)
  (SEND-BINARY-PKT LIMIT))

  ;;
;;;;;; Now the instantiatable flavors
  ;;

(DEFFLAVOR INPUT-CHARACTER-STREAM
	()
	(CHARACTER-INPUT-STREAM-MIXIN BASIC-INPUT-STREAM SI:BUFFERED-INPUT-CHARACTER-STREAM))

(DEFFLAVOR OUTPUT-CHARACTER-STREAM
	()
	(CHARACTER-OUTPUT-STREAM-MIXIN BASIC-OUTPUT-STREAM
	 SI:BUFFERED-OUTPUT-CHARACTER-STREAM))

(DEFFLAVOR CHARACTER-STREAM
	()
	(CHARACTER-INPUT-STREAM-MIXIN CHARACTER-OUTPUT-STREAM-MIXIN
	 BASIC-INPUT-STREAM BASIC-OUTPUT-STREAM SI:BUFFERED-CHARACTER-STREAM))

;;; This is to make the EVAL server work
(DEFMETHOD (:BEEP CHARACTER-STREAM) (&OPTIONAL IGNORE)
  )

(COMPILE-FLAVOR-METHODS INPUT-CHARACTER-STREAM OUTPUT-CHARACTER-STREAM CHARACTER-STREAM )

(DEFFLAVOR INPUT-BINARY8-STREAM
	()
	(BINARY8-INPUT-STREAM-MIXIN BASIC-INPUT-STREAM SI:BUFFERED-INPUT-STREAM
	 SI:UNSIGNED-BYTE-8-WITH-CHARACTER-INPUT-MIXIN))

(DEFFLAVOR OUTPUT-BINARY8-STREAM
	()
	(BINARY8-OUTPUT-STREAM-MIXIN BASIC-OUTPUT-STREAM
	 SI:BUFFERED-OUTPUT-STREAM
	 SI:UNSIGNED-BYTE-8-WITH-CHARACTER-OUTPUT-MIXIN))

(DEFFLAVOR BINARY8-STREAM
	()
	(BINARY8-INPUT-STREAM-MIXIN BINARY8-OUTPUT-STREAM-MIXIN
	 BASIC-INPUT-STREAM BASIC-OUTPUT-STREAM SI:BUFFERED-STREAM
	 SI:UNSIGNED-BYTE-8-WITH-CHARACTER-IO-MIXIN))

(COMPILE-FLAVOR-METHODS INPUT-BINARY8-STREAM OUTPUT-BINARY8-STREAM BINARY8-STREAM )

(DEFFLAVOR INPUT-BINARY-STREAM
	()
	(BINARY-INPUT-STREAM-MIXIN BASIC-INPUT-STREAM
	 SI:BUFFERED-INPUT-STREAM
	 SI:UNSIGNED-BYTE-8-WITH-CHARACTER-INPUT-MIXIN))

(DEFFLAVOR OUTPUT-BINARY-STREAM
	()
	(BINARY-OUTPUT-STREAM-MIXIN BASIC-OUTPUT-STREAM
	 SI:BUFFERED-OUTPUT-STREAM
	 SI:UNSIGNED-BYTE-8-WITH-CHARACTER-OUTPUT-MIXIN))

(DEFFLAVOR BINARY-STREAM
	()
	(BINARY-INPUT-STREAM-MIXIN BINARY-OUTPUT-STREAM-MIXIN
	 BASIC-INPUT-STREAM BASIC-OUTPUT-STREAM SI:BUFFERED-STREAM
	 SI:UNSIGNED-BYTE-8-WITH-CHARACTER-IO-MIXIN))

(COMPILE-FLAVOR-METHODS INPUT-BINARY-STREAM OUTPUT-BINARY-STREAM BINARY-STREAM)

(DEFFLAVOR CHAOS-TOKEN-LIST-STREAM () (NETI:TOKEN-LIST-STREAM NETI:STREAM-WITH-MARK
				       BINARY8-STREAM))

(COMPILE-FLAVOR-METHODS CHAOS-TOKEN-LIST-STREAM)

(DEFFLAVOR ASCII-TRANSLATING-INPUT-CHARACTER-STREAM
	()
	(SI:ASCII-TRANSLATING-INPUT-STREAM-MIXIN
	 BINARY8-INPUT-STREAM-MIXIN BASIC-INPUT-STREAM
	 SI:BUFFERED-TYI-INPUT-STREAM))

(DEFFLAVOR ASCII-TRANSLATING-OUTPUT-CHARACTER-STREAM
	()
	(SI:ASCII-TRANSLATING-OUTPUT-STREAM-MIXIN
	 BINARY8-OUTPUT-STREAM-MIXIN BASIC-OUTPUT-STREAM
	 SI:BUFFERED-TYO-OUTPUT-STREAM))

(DEFFLAVOR ASCII-TRANSLATING-CHARACTER-STREAM
	()
	(SI:ASCII-TRANSLATING-INPUT-STREAM-MIXIN SI:ASCII-TRANSLATING-OUTPUT-STREAM-MIXIN
	 BINARY8-INPUT-STREAM-MIXIN BINARY8-OUTPUT-STREAM-MIXIN
	 BASIC-INPUT-STREAM BASIC-OUTPUT-STREAM SI:BUFFERED-TYI-TYO-STREAM))

(COMPILE-FLAVOR-METHODS ASCII-TRANSLATING-INPUT-CHARACTER-STREAM
			ASCII-TRANSLATING-OUTPUT-CHARACTER-STREAM
			ASCII-TRANSLATING-CHARACTER-STREAM)


;;; Stream for the TELNET server.

;(DEFFLAVOR TELNET-STREAM () (TELNET:TELNET-SERVER-STREAM-MIXIN CHARACTER-STREAM))

;(COMPILE-FLAVOR-METHODS TELNET-STREAM)


(DEFUN OPEN-STREAM (HOST CONTACT-NAME &KEY
		    (WINDOW-SIZE *DEFAULT-WINDOW-SIZE*)
		    (TIMEOUT *HOST-CONNECT-TIMEOUT*)
		    (DIRECTION ':BIDIRECTIONAL)
		    (ERROR T)
		    (CHARACTERS T)
		    (BYTE-SIZE NIL)
		    (ASCII-TRANSLATION NIL)
		    (TOKEN-LIST NIL)
		    &AUX CONN
		    )
  (CONDITION-CASE-IF (NOT ERROR) (.ERROR.)
      (SETQ CONN (IF HOST
		     (CONNECT HOST CONTACT-NAME WINDOW-SIZE TIMEOUT)
		     (LISTEN CONTACT-NAME WINDOW-SIZE)))
    (CONNECTION-ERROR .ERROR.)
    (:NO-ERROR
      (MAKE-STREAM CONN :DIRECTION DIRECTION :CHARACTERS CHARACTERS :BYTE-SIZE BYTE-SIZE
			:TOKEN-LIST TOKEN-LIST :ASCII-TRANSLATION ASCII-TRANSLATION))))


(DEFUN MAKE-STREAM (CONNECTION &KEY (DIRECTION ':BIDIRECTIONAL)
		    (CHARACTERS T)
		    (BYTE-SIZE NIL)
		    (ASCII-TRANSLATION NIL)
		    (ACCEPT-P T)
		    (TOKEN-LIST NIL))
  (WHEN (AND ACCEPT-P (memq (STATE CONNECTION) '(RFC-RECEIVED-STATE BRD-RECEIVED-STATE)))
    (ACCEPT CONNECTION))
  (LET* ((FLAVOR
	   (COND (ASCII-TRANSLATION
		  (UNLESS CHARACTERS
		    (FERROR ":CHARACTERS NIL is inconsistent with :ASCII-TRANSLATION T"))
		  (WHEN BYTE-SIZE
		    (FERROR ":BYTE-SIZE ~S is inconsistent with :ASCII-TRANSLATION T"
			    BYTE-SIZE))
		  'ASCII-TRANSLATION)
		 (CHARACTERS
		  (WHEN (AND BYTE-SIZE (NOT (EQL BYTE-SIZE 8)))
		    (FERROR ":BYTE-SIZE ~S is inconsistent with :CHARACTERS T"
			    BYTE-SIZE))
		  'CHARACTERS)
		 ((OR (NULL BYTE-SIZE) (EQL BYTE-SIZE 16.))
		  'BINARY)
		 ((EQL BYTE-SIZE 8)
		  'BINARY8)
		 (T (FERROR ":BYTE-SIZE ~S is illegal; only 8 and 16 are allowed."
			    BYTE-SIZE))))
	 (STREAM
	   (MAKE-INSTANCE
	     (IF TOKEN-LIST 'CHAOS-TOKEN-LIST-STREAM
		 (SELECTQ DIRECTION
		   (:INPUT
		    (SELECTQ FLAVOR
		      (ASCII-TRANSLATION 'ASCII-TRANSLATING-INPUT-CHARACTER-STREAM)
		      (CHARACTERS 'INPUT-CHARACTER-STREAM)
		      (BINARY 'INPUT-BINARY-STREAM)
		      (BINARY8 'INPUT-BINARY8-STREAM)))
		   (:OUTPUT
		    (SELECTQ FLAVOR
		      (ASCII-TRANSLATION 'ASCII-TRANSLATING-OUTPUT-CHARACTER-STREAM)
		      (CHARACTERS 'OUTPUT-CHARACTER-STREAM)
		      (BINARY 'OUTPUT-BINARY-STREAM)
		      (BINARY8 'OUTPUT-BINARY8-STREAM)))
		   (:BIDIRECTIONAL
		    (SELECTQ FLAVOR
		      (ASCII-TRANSLATION 'ASCII-TRANSLATING-CHARACTER-STREAM)
		      (CHARACTERS 'CHARACTER-STREAM)
		      (BINARY 'BINARY-STREAM)
		      (BINARY8 'BINARY8-STREAM)))))
	     ':CONNECTION CONNECTION)))
    (SETF (CONN-USER-STREAM CONNECTION) STREAM)
    STREAM))


  ;;
;;;;;;  This belongs in utilities
  ;;


;; The HOSTAT function

;; Print the status of all the hosts and gateways, or specified ones
(DEFUN HOSTAT (&REST HOSTS)
  (FORMAT T "~&Chaosnet host status report.  Type Control-Abort to quit.")
  (LEXPR-FUNCALL #'HOSTAT-INTERNAL HOSTS))

(DEFUN HOSTAT-INTERNAL (&REST HOSTS)
  (POLL-HOSTS HOSTS "STATUS" #'HOSTAT-HEADING #'HOSTAT-FORMAT-ANS))

(DEFUN POLL-HOSTS (HOSTS CONTACT-NAME HEADING-FCN FORMAT-FCN
		   &OPTIONAL (SKIP-CLOSED-CONNECTIONS NIL) (WHOSTATE "Host Reply")
		   &AUX CONNECTIONS PKT (CONNECTION-COUNT 0))
  (UNWIND-PROTECT
    (PROGN
      (ASSURE-ENABLED)
      ;; Get all hosts to do.  If HOSTS specified use them, else all chaos hosts,
      ;; including more that one address for the same host.
      (SETQ CONNECTIONS (IF HOSTS
			    (LOOP FOR HOST IN HOSTS
				  IF (NUMBERP HOST)
				    COLLECT (LIST NIL HOST NIL)
				  ELSE
				    NCONC (LET* ((HOST (PARSE-HOST HOST))
						 (ADDRESSES (SEND HOST :CHAOS-ADDRESSES)))
					    (IF ADDRESSES
						(LOOP FOR ADDRESS IN ADDRESSES
						      COLLECT (LIST HOST ADDRESS NIL))
					      (FORMAT T "~&~A is not a Chaos host~%" HOST))))
			    (LOOP FOR HOST IN (GET-LOCAL-HOSTS)
				  AS ADDRESSES = (SEND HOST ':CHAOS-ADDRESSES)
				  WHEN ADDRESSES
				  NCONC (LOOP FOR ADDRESS IN ADDRESSES
					      COLLECT (LIST HOST ADDRESS NIL)))))
      ;; Now print heading
      (FUNCALL HEADING-FCN)
      ;; Now wait until connections come up with an answer, when they do print it out
      ;; Note host-name truncated to 27. characters to make more room for statistics
      (DO () ((NULL CONNECTIONS))
	;; Fill up the connection table with as many connections as we have room for.
	;; Try not to use up too many connections.  Only open a maximum of 20 at a time.
	(CONDITION-CASE ()
	    (LOOP FOR ELEM IN CONNECTIONS
		  WHILE (< CONNECTION-COUNT 20.)
		  WHEN (NULL (THIRD ELEM))
		  DO (SETF (THIRD ELEM) (OPEN-CONNECTION (SECOND ELEM) CONTACT-NAME 1))
		  (INCF CONNECTION-COUNT))
	  (CONNECTION-TABLE-FULL NIL))
	(PROCESS-WAIT-WITH-TIMEOUT WHOSTATE 120.
				   #'(LAMBDA (CONNECTIONS)
				       (DO LIST CONNECTIONS (CDR LIST) (NULL LIST)
					   (LET* ((ELEM (CAR LIST))
						  (CONNECTION (THIRD ELEM)))
					     (WHEN (AND CONNECTION
							(NEQ (STATE CONNECTION)
							     'RFC-SENT-STATE))
					       (RETURN T)))))
				   CONNECTIONS)				       
	(DO LIST CONNECTIONS (CDR LIST) (NULL LIST)
	    (LET* ((ELEM (CAR LIST))
		   (CONNECTION (THIRD ELEM)))
	      (AND CONNECTION
		   (SELECTQ (STATE CONNECTION)
		     (RFC-SENT-STATE
		      (COND (( (TIME-DIFFERENCE (TIME) (TIME-LAST-RECEIVED CONNECTION))
				600.)		;10-second timeout
			     (IF (SYMBOLP SKIP-CLOSED-CONNECTIONS)
				 (FORMAT T "~&~O~7T~@[~A   ~]host not responding~%"
					 (SECOND ELEM) (FIRST ELEM))
				 (FUNCALL SKIP-CLOSED-CONNECTIONS (SECOND ELEM) NIL))
			     (REMOVE-CONN CONNECTION)
			     (SETQ CONNECTIONS (DELQ ELEM CONNECTIONS))
			     (DECF CONNECTION-COUNT))))
		     (ANSWERED-STATE		;This is what we want
		      (SETQ PKT (GET-NEXT-PKT CONNECTION))
		      (UNWIND-PROTECT
			(FUNCALL FORMAT-FCN (SECOND ELEM) PKT)
			(RETURN-PKT PKT))
		      ;; Delete not only this connection, but every one to this same
		      ;; host, in case it has multiple addresses.  One copy of the
		      ;; answer is enough, but if it fails we would like to see all paths.
		      (COND (HOSTS
			     (REMOVE-CONN CONNECTION)
			     (SETQ CONNECTIONS (DELQ ELEM CONNECTIONS))
			     (DECF CONNECTION-COUNT))
			    (T (LOOP WITH HOST = (FIRST ELEM)
				     FOR X IN CONNECTIONS
				     WHEN (EQ (CAR X) HOST)
				     DO (WHEN (THIRD X)
					  ;; When multiple addresses fall across a
					  ;; connection-table-limitation boundary, there
					  ;; won't be a connection
					  (REMOVE-CONN (THIRD X)))
				     (SETQ CONNECTIONS (DELQ X CONNECTIONS))
				     (DECF CONNECTION-COUNT))))
		      (SETQ LIST NIL))
		     (CLS-RECEIVED-STATE
		      (SETQ PKT (GET-NEXT-PKT CONNECTION))
		      (UNWIND-PROTECT
			(COND ((NULL SKIP-CLOSED-CONNECTIONS)
			       (FORMAT T "~&~O~7T~@[~A   ~]returned a CLS:~A~%"
				       (SECOND ELEM) (FIRST ELEM) (PKT-STRING PKT)))
			      ((SYMBOLP SKIP-CLOSED-CONNECTIONS))
			      (T (FUNCALL SKIP-CLOSED-CONNECTIONS (SECOND ELEM) PKT)))
			(RETURN-PKT PKT))
		      (REMOVE-CONN CONNECTION)
		      (SETQ CONNECTIONS (DELQ ELEM CONNECTIONS))
		      (DECF CONNECTION-COUNT))
		     (OPEN-STATE
		      (IF (SYMBOLP SKIP-CLOSED-CONNECTIONS)
			  (FORMAT T "~&~O~7T~@[~A   ~]returned an OPN~%"
				  (SECOND ELEM) (FIRST ELEM) )
			  (FUNCALL SKIP-CLOSED-CONNECTIONS (SECOND ELEM) PKT))
		      (CLOSE-CONN CONNECTION "I expected an ANS, not an OPN.")
		      (REMOVE-CONN CONNECTION)
		      (SETQ CONNECTIONS (DELQ ELEM CONNECTIONS))
		      (DECF CONNECTION-COUNT))
		     (LOS-RECEIVED-STATE
		      (SETQ PKT (READ-PKTS-LAST CONNECTION))
		      (IF (SYMBOLP SKIP-CLOSED-CONNECTIONS)
			  (FORMAT T "~&~O~7T~@[~A   ~]returned a LOS:~A~%"
				  (SECOND ELEM) (FIRST ELEM) (PKT-STRING PKT))
			  (FUNCALL SKIP-CLOSED-CONNECTIONS (SECOND ELEM) PKT))
		      (REMOVE-CONN CONNECTION)
		      (SETQ CONNECTIONS (DELQ ELEM CONNECTIONS))
		      (DECF CONNECTION-COUNT))
		     (OTHERWISE
		      (IF (SYMBOLP SKIP-CLOSED-CONNECTIONS)
			  (FORMAT T "~&~O~7T~@[~A   ~]connection entered bad state:~A~%"
				  (SECOND ELEM) (FIRST ELEM) (STATE CONNECTION))
			  (FUNCALL SKIP-CLOSED-CONNECTIONS (SECOND ELEM) :BAD-STATE))
		      (REMOVE-CONN CONNECTION)
		      (SETQ CONNECTIONS (DELQ ELEM CONNECTIONS))
		      (DECF CONNECTION-COUNT))))))))
    ;; Unwind-protect cleanup
    (DO L CONNECTIONS (CDR L) (NULL L)		;Flush any connections that remain
	(LET ((CONNECTION (THIRD (CAR L))))
	  (AND CONNECTION (REMOVE-CONN CONNECTION))))))

(DEFUN HOSTAT-HEADING (&OPTIONAL (STREAM STANDARD-OUTPUT))
  (FORMAT STREAM "~%~7A~25A" "Site" "Name//Status")
  (DO ((HEADS '("Subnet" "#-in" "#-out" "abort" "lost" "crc" "ram" "bitc" "other")
	      (CDR HEADS))
       (WIDTHS '(6 9 9 8 8 8 4 5 6) (CDR WIDTHS)))
      ((NULL HEADS) (TERPRI STREAM))
    (FORMAT STREAM "~V@A" (CAR WIDTHS) (CAR HEADS))))

(DEFUN HOSTAT-FORMAT-ANS (HOST PKT &OPTIONAL (STREAM STANDARD-OUTPUT)
			  &AUX (NBYTES (PKT-NBYTES PKT)))
  (FORMAT STREAM "~7@<~O ~>~27A"		;Print host number and name as returned
	  HOST
	  (NSUBSTRING (PKT-STRING PKT) 0
		      (MIN NBYTES 27. (OR (STRING-SEARCH-CHAR (CODE-CHAR 0) (PKT-STRING PKT) 0 32.)
					  ;; This line is temporary! *******
					  (STRING-SEARCH-CHAR (CODE-CHAR 200) (PKT-STRING PKT) 0 32.)
					  32.))))
  (HOSTAT-FORMAT-ANS-1 PKT 34. '(4 9 9 8 8 8 4 5 6) STREAM))

(DEFUN HOSTAT-FORMAT-ANS-1 (PKT START-COLUMN COLUMN-WIDTHS STREAM
			    &AUX (NBYTES (PKT-NBYTES PKT)))
  (DO ((I 24. (+ I 2 CT))		;Now display subnet meters
       (FIRST-LINE T NIL)
       (ID) (CT)
       (MAXI (+ 8 (// NBYTES 2))))
      ((>= I MAXI) (AND FIRST-LINE (TERPRI STREAM)))
    (SETQ ID (AREF PKT I) CT (AREF PKT (1+ I)))	;Block header
    (OR FIRST-LINE (FORMAT STREAM "~VA" START-COLUMN ""))
    (COND ((< ID 400)				;Subnet info (old 16-bit format)
	   (FORMAT STREAM "~VO" (CAR COLUMN-WIDTHS) ID)
	   (DO ((J (+ I 2) (1+ J))		;Now print those meters that are present
		(L (CDR COLUMN-WIDTHS) (CDR L))
		(N (MIN CT 8) (1- N)))
	       ((ZEROP N))
	     (FORMAT STREAM "~VD" (CAR L) (AREF PKT J))))
	  ((< ID 1000)				;Subnet info
	   (FORMAT STREAM "~VO" (CAR COLUMN-WIDTHS) (- ID 400))
	   (DO ((J (+ I 2) (+ J 2))		;Now print those meters that are present
		(L (CDR COLUMN-WIDTHS) (CDR L))
		(N (MIN (// CT 2) 8) (1- N)))
	       ((ZEROP N))
	     (FORMAT STREAM "~VD" (CAR L) (DPB (AREF PKT (1+ J))
					       (BYTE 20 20) (AREF PKT J)))))
	  (T					;I don't know about this
	   (FORMAT STREAM "~O unknown info block ID" ID)))
    (TERPRI STREAM))) 


(DEFUN POLL-HOSTS-WITH-BRD (CONTACT-NAME HEADING-FUN FORMAT-FUN
			    &OPTIONAL (SUBNETS ':ALL) (ORIGIN 0)
			    &AUX CONN PKTS ADDRS)
  (UNWIND-PROTECT
    (keeping-namespace-server			;assuming format functions will want
						;to get info from the source address 
      (FUNCALL HEADING-FUN)
      (SETQ CONN (BROADCAST CONTACT-NAME SUBNETS 40 ORIGIN))
      (LOOP DO (OR (DATA-AVAILABLE CONN)
		   PKTS
		   (PROCESS-WAIT-WITH-TIMEOUT "BRD in" 300.
		       #'data-available
		       CONN))
	    AS PKT = (GET-NEXT-PKT CONN T)
	    WHILE (COND (PKT (let ((addr (pkt-source-address pkt)))
			       (IF (MEMBER ADDR ADDRS)
				   (RETURN-PKT PKT)
				 (PUSH PKT PKTS)
				 (PUSH ADDR ADDRS)))
			     T)
			(PKTS (SETQ PKT  (POP PKTS))
			      (SELECT (PKT-OPCODE pkt)
				(ANS-OP (FUNCALL FORMAT-FUN
						 (PKT-SOURCE-ADDRESS PKT) PKT))
				(CLS-OP (FORMAT T "~&Received a CLS packet from ~A: ~A~%"
						(HOST-DATA (PKT-SOURCE-ADDRESS PKT))
						(PKT-STRING PKT))))
			      (RETURN-PKT PKT)
			      T))))
    (WHEN CONN (REMOVE-CONN CONN))
    (MAPC #'RETURN-PKT PKTS)))

(DEFUN BRD-HOSTAT (&OPTIONAL (SUBNETS ':ALL) (ORIGIN 0))
  (POLL-HOSTS-WITH-BRD "STATUS" #'HOSTAT-HEADING #'HOSTAT-FORMAT-ANS
		       SUBNETS ORIGIN))

(DEFUN BRD-UPTIME (&OPTIONAL (SUBNETS ':ALL) (ORIGIN 0))
  (POLL-HOSTS-WITH-BRD "UPTIME" #'UPTIME-HEADING #'UPTIME-FORMAT-ANS
		       SUBNETS ORIGIN))

(DEFUN UPTIME-HEADING ()
  (FORMAT T "~%~25A~25A" "Host Name" "Time up"))

(DEFUN UPTIME-FORMAT-ANS (HOST PKT)
  (FORMAT T "~%~25A" (HOST-DATA HOST))
  (TIME:PRINT-INTERVAL-OR-NEVER (// (DPB (AREF PKT (1+ FIRST-DATA-WORD-IN-PKT))
					 (BYTE 20 20) (AREF PKT FIRST-DATA-WORD-IN-PKT))
				    60.)))

(DEFUN BRD-HOST-TIME (&OPTIONAL (SUBNETS ':ALL) (ORIGIN 0))
  (POLL-HOSTS-WITH-BRD "TIME" #'IGNORE #'BRD-HOST-TIME-FORMAT-ANS
		       SUBNETS ORIGIN))

(DEFUN BRD-HOST-TIME-FORMAT-ANS (HOST PKT)
  (FORMAT T "~% ~A:~17T" (HOST-DATA HOST))
  (TIME:PRINT-UNIVERSAL-TIME (DPB (AREF PKT (1+ FIRST-DATA-WORD-IN-PKT))
				  (BYTE 20 20) (AREF PKT FIRST-DATA-WORD-IN-PKT))))

(DEFUN BRD-FINGER (&OPTIONAL (SUBNETS ':ALL))
  (POLL-HOSTS-WITH-BRD "FINGER" #'IGNORE #'BRD-FINGER-FORMAT-ANS SUBNETS))

(DEFUN BRD-FINGER-FORMAT-ANS (ADDR PKT)
  (LET* ((STRING (PKT-STRING PKT))
	 (HOST-NAME (SEND (get-host-from-address addr ':chaos)
			  ':LOCAL-NAME)))
    (DESTRUCTURING-BIND (ID LOCATION IDLE-TIME PERSONAL-NAME GROUP)
			(LOOP FOR BEGIN = 0 THEN (1+ END)
			      FOR END = (STRING-SEARCH-CHAR #\CR STRING BEGIN) WHILE END
			      COLLECT (NSUBSTRING STRING BEGIN END))
      (FORMAT T "~&~V@<~11A ~A ~22A ~14A ~5@A   ~A~>~%"
	      (- (send standard-output ':size-in-characters) 3)
	      ID GROUP PERSONAL-NAME HOST-NAME IDLE-TIME LOCATION))))


  ;;
;;;;;;  simple stream interface, datagram oriented
  ;;

(DEFFLAVOR SIMPLE-STREAM
	((INPUT-PACKET NIL))
	(INPUT-STREAM-MIXIN BASIC-STREAM SI:BUFFERED-INPUT-STREAM))

;;; This needs to work for broadcast too.
(DEFMETHOD (:FOREIGN-HOST SIMPLE-STREAM) ()
  (AND CONNECTION
       (if (eq (state connection) 'brd-sent-state)
	   (and input-packet
		(get-host-from-address (pkt-source-address input-packet) ':chaos))
	 (foreign-host-object connection))))

(DEFMETHOD (:NEXT-INPUT-BUFFER SIMPLE-STREAM) (&OPTIONAL NO-HANG-P)
  (LOOP WITH STATE = (STATE CONNECTION)
	DO (SETQ INPUT-PACKET (GET-NEXT-PKT CONNECTION NO-HANG-P))
	ALWAYS INPUT-PACKET
	WHEN (OR (NEQ STATE 'BRD-SENT-STATE)
		 (= (PKT-OPCODE INPUT-PACKET) ANS-OP))
	  ;; don't return CLS packets when in BRD-SENT-STATE for now
	  RETURN (VALUES (PKT-8B-ARRAY INPUT-PACKET)
			 0
			 (PKT-NBYTES INPUT-PACKET))
	ELSE DO (RETURN-PKT (PROG1 INPUT-PACKET (SETQ INPUT-PACKET NIL)))))

(DEFMETHOD (:CONNECTION-PENDING-P SIMPLE-STREAM) ()
  (or (EQ (STATE CONNECTION) 'RFC-SENT-STATE)
      (and (eq (state connection) 'brd-sent-state)
	   (null input-packet)
	   (not (data-available connection)))))

(DEFMETHOD (:CHECK-CONNECTION-STATE SIMPLE-STREAM) ()
  (CHECK-CONNECTION-STATE CONNECTION 'ANSWERED-STATE))

(DEFMETHOD (:NUMBER-OF-OUTSTANDING-CONNECTIONS SIMPLE-STREAM) () 8)

(COMPILE-FLAVOR-METHODS SIMPLE-STREAM) 

;;; This is mostly a copy of SIMPLE and should replace it someday perhaps.
;;;--- this needs real CHARACTERS support.
(DEFUN OPEN-SIMPLE-STREAM (HOST CONTACT-NAME
			   &KEY (TIMEOUT *HOST-CONNECT-TIMEOUT*) (FUTURE-P NIL) (CHARACTERS T)
			   &AUX (TRY 1) CONN COMPLETED-NORMALLY)
  (IGNORE CHARACTERS) 
  (NET:WITH-CONNECTION-RETRYING (HOST CONTACT-NAME TRY-REASON)
    (IF (EQ TRY-REASON ':LONGER-TIMEOUT) (SETQ TRY (* TRY 2)))
    (SETQ CONN NIL)
    (SETQ COMPLETED-NORMALLY NIL)
    (ASSURE-ENABLED)
    (UNWIND-PROTECT
	(PROGN
	  (SETQ CONN (OPEN-CONNECTION HOST CONTACT-NAME 5))
	  (LET ((STREAM
		  (IF FUTURE-P
		      (MAKE-INSTANCE 'SIMPLE-STREAM ':CONNECTION CONN)
		      (WAIT-FOR-CONNECT CONN 'ANSWERED-STATE
					(AND (NEQ TRY-REASON ':WAIT-INDEFINITELY)
					     TIMEOUT
					     (* TIMEOUT TRY)))
		      (MAKE-INSTANCE 'SIMPLE-STREAM ':CONNECTION CONN))))
	    (SETF (CONN-USER-STREAM CONN) STREAM)
	    (SETQ COMPLETED-NORMALLY T)
	    STREAM))
      (UNLESS COMPLETED-NORMALLY
	(WHEN CONN (REMOVE-CONN CONN))))))

(DEFUN OPEN-BROADCAST-SIMPLE-STREAM (CONTACT-NAME
				     &KEY (TIMEOUT *HOST-CONNECT-TIMEOUT*)
				     (FUTURE-P NIL) (CHARACTERS T)
				     &AUX (CONN NIL) (COMPLETED-NORMALLY NIL))
  ;; Since this does its own retransmission, it has to ignore the future-p keyword.
  FUTURE-P CHARACTERS
  (UNWIND-PROTECT
    (PROGN
      (SETQ CONN (WITH-STACK-LIST (FIRST-TRY MY-SUBNET)
		   (BROADCAST CONTACT-NAME FIRST-TRY)))
      ;; Weed out failing reponses
      (LOOP NAMED TOP
	    WITH START-TIME = (TIME)
	    AS FIRST = T THEN NIL
	    AND TMO = (// TIMEOUT 10.)
	    DO (WITHOUT-INTERRUPTS
		 (LOOP AS PKT = (READ-PKTS CONN)
		       WHILE PKT
		       WHEN (= (PKT-OPCODE PKT) ANS-OP)
		       DO (RETURN-FROM TOP)
		       DO (RETURN-PKT (GET-NEXT-PKT CONN))))
	       (PROCESS-WAIT-WITH-TIMEOUT "BRD Wait" TMO
		   #'DATA-AVAILABLE CONN)
	       1;; Try my subnet on the second try, otherwise try all the subnets.  This
	       ;; reduces the gateway traffic since the first request can generate a bunch of
	       ;; ARP requests that we need to respond to.
0	       (UNLESS (DATA-AVAILABLE CONN)
		 (WITH-STACK-LIST (SUBNETS MY-SUBNET)
		   (BROADCAST-AGAIN CONN CONTACT-NAME (IF FIRST SUBNETS :ALL)))
		 (PROCESS-WAIT-WITH-TIMEOUT "BRD Wait" TMO
		   #'DATA-AVAILABLE CONN))
	    UNTIL (> (TIME-DIFFERENCE (TIME) START-TIME) TIMEOUT))
	(CHECK-CONNECTION-STATE CONN NIL)
	(LET ((STREAM (MAKE-INSTANCE 'SIMPLE-STREAM ':CONNECTION CONN)))
	  (PUSH (LIST CONTACT-NAME (PKT-SOURCE-ADDRESS (READ-PKTS CONN))) *BRD-HISTORY*)
	  (SETF (CONN-USER-STREAM CONN) STREAM)
	  (SETQ COMPLETED-NORMALLY T)
	  STREAM))
    (UNLESS COMPLETED-NORMALLY
      (WHEN CONN
	(REMOVE-CONN CONN)))))

;;; Support for the new server system for the :CHAOS generic medium.

(DEFFLAVOR CHAOS-SERVER
	   (CONN)
  (NETI:BASIC-SERVER)
  :ABSTRACT-FLAVOR
  :GETTABLE-INSTANCE-VARIABLES
  (:INITABLE-INSTANCE-VARIABLES CONN))

(DEFMETHOD (:FOREIGN-HOST CHAOS-SERVER) ()
  (FOREIGN-HOST-OBJECT CONN))

(DEFMETHOD (:KILL CHAOS-SERVER) (REASON)
  (CLOSE-CONN CONN REASON))

(DEFMETHOD (:PEEK CHAOS-SERVER) ()
  (LIST ()
	(TV:SCROLL-PARSE-ITEM
	  :LEADER '(NIL NIL NIL NIL NIL NIL)
	  (FORMAT NIL "~41X")
	  `(:MOUSE-ITEM
	    (NIL :KBD (SEND :SERVER-CONNECTION-MENU ,(SEND SELF :NETWORK) ,CONN TV:ITEM)
		 :DOCUMENTATION "Menu of useful things to do to this connection.")
	    :STRING ,(FORMAT NIL "~S" CONN)))))

(COMPILE-FLAVOR-METHODS CHAOS-SERVER)

(DEFFLAVOR DEFAULT-CHAOS-SERVER () (CHAOS-SERVER)
  (:INIT-KEYWORDS :HOST :TRUSTED-P))

(DEFMETHOD (:SERVER-TOP-LEVEL DEFAULT-CHAOS-SERVER) ()
  (FERROR "This isn't a real server, you know."))

(COMPILE-FLAVOR-METHODS DEFAULT-CHAOS-SERVER)

(DEFPROP :CHAOS DEFAULT-CHAOS-SERVER NETI:SERVER-BASE-FLAVOR)

;;;

(DEFUN (:CHAOS NETI:INVOKE-SERVICE-FUNCTION)
       (SERVER MEDIUM-NAME MEDIUM-ARGS GENERAL-ARGUMENTS)
  MEDIUM-NAME
  (WITH-STACK-LIST* (ARGUMENTS :CONN (FIRST MEDIUM-ARGS) GENERAL-ARGUMENTS)
    (NETI:FUNCALL-SERVER-FUNCTION SERVER ARGUMENTS)))

;;;

(DEFUN (:CHAOS NETI:REJECT-FUNCTION) (REASON CONN)
  (REJECT CONN REASON))

(DEFUN (:CHAOS NETI:BYTE-STREAM-FUNCTION)
       (CONN &REST CONNECTION-ARGS &KEY BYTE-SIZE (CHARACTERS T) &ALLOW-OTHER-KEYS)
  (SETF CONNECTION-ARGS (SI:REM-KEYWORDS CONNECTION-ARGS '(:BYTE-SIZE)))
  (LEXPR-FUNCALL #'MAKE-STREAM CONN :ACCEPT-P NIL
		 :BYTE-SIZE (AND (NOT CHARACTERS) (OR BYTE-SIZE 8))
		 CONNECTION-ARGS))


(DEFUN (:PROPERTY :CHAOS-TOKEN-LIST NETI:BYTE-STREAM-FUNCTION)
       (CONN &REST CONNECTION-ARGS &KEY BYTE-SIZE (CHARACTERS T) &ALLOW-OTHER-KEYS)
  (LEXPR-FUNCALL #'MAKE-STREAM CONN :ACCEPT-P NIL
		 :TOKEN-LIST T
		 :BYTE-SIZE (AND (NOT CHARACTERS) (OR BYTE-SIZE 8))
		 CONNECTION-ARGS))

;;;

(DEFUN (:CHAOS-SIMPLE NETI:REJECT-FUNCTION) (REASON CONN)
  (REJECT CONN REASON))

(DEFUN (:CHAOS-SIMPLE NETI:DATAGRAM-FUNCTION) (SERVER GENERAL-ARGUMENTS CONN)
  (LET* ((PKT (IF (SI:PROCESS-SIMPLE-P SI:CURRENT-PROCESS)
		  (GET-PKT NIL)			1;Can't wait if we are a simple process.
0		  (GET-PKT T)))
	 RFC-STRING RFC-ARRAY RFC-START RFC-END)
      (UNWIND-PROTECT
	  (WHEN PKT
	    (LET ((RFC-PKT (READ-PKTS CONN)))
	      (SETQ RFC-STRING (PKT-STRING RFC-PKT)
		    RFC-ARRAY (PKT-8B-ARRAY RFC-PKT)
		    RFC-END (ARRAY-ACTIVE-LENGTH RFC-STRING)
		    RFC-START (STRING-SEARCH-CHAR #\SP RFC-STRING 0 RFC-END))
	      (IF RFC-START (INCF RFC-START) (SETQ RFC-START RFC-END)))
	    (MULTIPLE-VALUE-BIND (SUCCESS STRING-OR-BYTE-COUNT)
		(WITH-STACK-LIST* (ARGUMENTS :REQUEST-ARRAY RFC-ARRAY
					     :REQUEST-ARRAY-START RFC-START
					     :REQUEST-ARRAY-END RFC-END
					     :RESPONSE-ARRAY (PKT-8B-ARRAY PKT)
					     :RESPONSE-ARRAY-START 0
					     :RESPONSE-ARRAY-END MAX-DATA-BYTES-PER-PKT
					     GENERAL-ARGUMENTS)
		  (NETI:FUNCALL-SERVER-FUNCTION SERVER ARGUMENTS))
	      (IF (FIXP STRING-OR-BYTE-COUNT)
		  (SETF (PKT-NBYTES PKT) STRING-OR-BYTE-COUNT)
		  (SET-PKT-STRING PKT STRING-OR-BYTE-COUNT))
	      (FUNCALL (IF SUCCESS #'ANSWER #'REJECT-WITH-PKT)
		       (PROG1 CONN (SETQ CONN NIL))
		       (PROG1 PKT (SETQ PKT NIL)))))
	(WHEN PKT (CHAOS:RETURN-PKT PKT))
	(WHEN CONN (REJECT CONN "Error in server")))))


