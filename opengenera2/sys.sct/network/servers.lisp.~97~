;;; -*- Syntax: Zetalisp; Mode: LISP; Package: NETI; Base: 8 -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
;;; Generic server definition interface


;;; Global Security Flag

(CL:DEFPARAMETER NET:*SYSTEM-SECURED* NIL
  "If this flag is T, then the local system is operating as a secured server,
enforcing access requirements.")

;;; The process will start with *access-groups* of nil unless it does sonething
;;; about it.
(DEFUN PROCESS-RUN-FUNCTION-IN-SECURE-ENVIRONMENT
       (FUNCTION &REST PROCESS-RUN-FUNCTION-ARGS)
  (PROCESS-RUN-FUNCTION PROCESS-RUN-FUNCTION-ARGS
    #'(LAMBDA ()
	(IN-SECURE-SERVER-ENVIRONMENT
	  (FUNCALL FUNCTION)))))

;;;Don't turn them on until told to do so
(CL:DEFPARAMETER *STANDARD-SERVICES-ENABLED* ':all
  ":ALL to enable all services.  NIL to disable all services, or a list of enabled services.")

(DEFVAR *SERVICES-ENABLED* NIL
  "NIL if no services are enabled, otherwise a list of services enabled."
  )

(CL:DEFPARAMETER *STANDARD-NEW-SERVICES-ENABLE* T)
(CL:DEFPARAMETER *NEW-SERVICES-ENABLE* nil)

(DEFUN ENABLE-SERVICES (&OPTIONAL (SERVICES *STANDARD-SERVICES-ENABLED*) REPORT &AUX ALL?)
  (IF (MEMQ SERVICES '(T :ALL))
      (SETQ SERVICES
	    (LOOP FOR SERVER IN *SERVERS*
		  COLLECT (SERVER-PROTOCOL-NAME SERVER))
	    ALL? T)
      (UNLESS (LISTP SERVICES)
	(SETQ SERVICES (LIST SERVICES))))
  (LOOP FOR SERVICE-NAME IN SERVICES
	UNLESS (CL:MEMBER SERVICE-NAME *SERVICES-ENABLED*)
	  DO
	    (PUSH SERVICE-NAME *SERVICES-ENABLED*)
	    (LET ((ENABLE-FUNCTION (GET SERVICE-NAME 'ENABLE-SERVICES)))
	      (WHEN ENABLE-FUNCTION (FUNCALL ENABLE-FUNCTION SERVICE-NAME))
	      (WHEN (AND REPORT (NOT ALL?))
		(FORMAT T "~&~A service enabled." SERVICE-NAME))))
  (WHEN (AND REPORT ALL?)
    (FORMAT T "~&Services to other machines enabled globally."))
  (SETQ *NEW-SERVICES-ENABLE* *STANDARD-NEW-SERVICES-ENABLE*)
  (WHEN *SERVICES-ENABLED*
    ;; this is vestigal, retained only for the benefit of of customers.
    (INITIALIZATIONS 'SI:ENABLE-SERVICES-INITIALIZATION-LIST T)))

(DEFUN SERVICE-ENABLED-P (PROTOCOL-NAME)
  (CL:MEMBER PROTOCOL-NAME *SERVICES-ENABLED*))

(DEFUN DISABLE-SERVICES (&OPTIONAL (PARTICULAR-SERVICES ':ALL) REPORT DISABLE-SPECIAL-SERVICES)
  (LET ((SERVICES
	  (IF (EQ PARTICULAR-SERVICES ':ALL)
	      (IF (MEMQ *SERVICES-ENABLED* '(T :ALL))
		  (LOOP FOR SERVER IN *SERVERS*
			COLLECT (SERVER-PROTOCOL-NAME SERVER))
		  *SERVICES-ENABLED*)
	      (IF (LISTP PARTICULAR-SERVICES) PARTICULAR-SERVICES
		  (LIST PARTICULAR-SERVICES)))))
    (LOOP FOR SERVICE IN SERVICES
	  WHEN (CL:MEMBER SERVICE *SERVICES-ENABLED*)
	    DO
	      (LET ((DISABLE-FUNCTION (GET SERVICE 'DISABLE-SERVICES)))
		(WHEN DISABLE-FUNCTION (FUNCALL DISABLE-FUNCTION SERVICE))
		(WHEN (AND REPORT (NEQ PARTICULAR-SERVICES ':ALL))
		  (FORMAT T "~&~A service disabled." SERVICE))))
    (WHEN (AND REPORT (EQ PARTICULAR-SERVICES ':ALL))
      (FORMAT T "~&Services to other machines disabled globally."))
    (SETQ *SERVICES-ENABLED*
	  (IF (EQ PARTICULAR-SERVICES ':ALL) NIL
	      (CL:NSET-DIFFERENCE *SERVICES-ENABLED* SERVICES))))
  (SETQ *NEW-SERVICES-ENABLE* NIL)
  ;; Crock
  (UNLESS DISABLE-SPECIAL-SERVICES
    #+IMach
    (SYSTEM-CASE
      (Solstice
	;; Solstices need this service to get their consoles.  You
	;; might think this could be enabled solely for the
	;; *EMB-HOST*, if that were possible, but you would be
	;; wrong.  There's no rule that says Solstices can't be
	;; reached over the network.
	(ENABLE-SERVICES '(:RPC)))
      (Domino
	;; Domino needs this service to allow X terminals to ask for a console.
	;; Further, for sites without X terminals or with X terminals that do not
	;; speak XDMCP, we'll enable TELNET and 3600-LOGIN service to allow access.
	;; Finally, for sites with UX software, we'll enable RPC service to allow
	;; access via the Genera program.  Even more finally, we need to allow rsh and
	;; Unix-REXEC access so Unix machines can start X-screens.
	(ENABLE-SERVICES '(:XDMCP :TELNET :3600-LOGIN :RPC :UNIX-RSH :UNIX-REXEC)))
      (Otherwise NIL)))
  ;; vestigal
  (INITIALIZATIONS 'SI:DISABLE-SERVICES-INITIALIZATION-LIST T))

(ADD-INITIALIZATION "Disable Services" '(DISABLE-SERVICES) '(BEFORE-COLD))

(DEFSTRUCT (SERVER :NAMED :CONC-NAME)
  PROTOCOL-NAME
  MEDIUM-TYPE
  FUNCTION
  NUMBER-OF-ARGUMENTS
  ARGUMENT-DESCRIPTIONS
  PROPERTY-LIST
  )

(DEFSELECT ((SERVER NAMED-STRUCTURE-INVOKE))
  (:PRINT-SELF (SERVER STREAM &REST IGNORE)
   (SI:PRINTING-RANDOM-OBJECT (SERVER STREAM :TYPEP)
     (PRINC (PROTOCOL-NAME SERVER) STREAM))))

;;; A list of all active servers which may be examined by anybody,
;;; but modified only by this file.  Elements are instances based on BASIC-SERVER.
(DEFVAR *ACTIVE-SERVERS* ()
  "A list of all active server instances.")

;;; This variable contains the last (TIME) the above list was updated.
;;; The wholine uses this to determine when to redisplay.
(DEFVAR *ACTIVE-SERVERS-LAST-UPDATE-TIME* 0)

;;; The base flavors for active server instances.

;;; The base of all of them.
(DEFFLAVOR BASIC-SERVER
	   (PROCESS SERVER NETWORK ADDRESS MEDIUM)
	()
  (:INITABLE-INSTANCE-VARIABLES SERVER NETWORK ADDRESS MEDIUM)
  (:INIT-KEYWORDS HOST TRUSTED-P)
  :GETTABLE-INSTANCE-VARIABLES
  (:METHOD-COMBINATION :PEEK (:LIST :MOST-SPECIFIC-LAST))
  (:REQUIRED-METHODS :SERVER-TOP-LEVEL))

(DEFMETHOD (:INIT BASIC-SERVER :BEFORE) (IGNORE)
  (SETF PROCESS (IF (GET (LOCF (SERVER-PROPERTY-LIST SERVER)) :SIMPLE-P)
		    :SIMPLE
		    CURRENT-PROCESS)))

(DEFMETHOD (:FOREIGN-HOST BASIC-SERVER) ()
  (GET-HOST-FROM-ADDRESS ADDRESS NETWORK))

(DEFMETHOD (:KILL BASIC-SERVER) (REASON)
  REASON)

(DEFMETHOD (:PEEK BASIC-SERVER) ()
  (LIST ()
	(TV:SCROLL-PARSE-ITEM
	  `(:STRING ,(FORMAT NIL "~20A " (SERVER-PROTOCOL-NAME SERVER)))
	  `(:MOUSE-ITEM
	    (NIL :KBD (SEND :PEEK-HOST-MENU ,(SEND SELF :FOREIGN-HOST) ITEM)
		 :DOCUMENTATION "Menu of useful things to do to this host.")
	    :STRING ,(FORMAT NIL "~20A" (SEND SELF :FOREIGN-HOST)))
	  `(:MOUSE
	    (NIL :KBD (SEND :PROCESS-MENU ,PROCESS)
		 :DOCUMENTATION
		 "Menu of useful things to do to this process.")
	    :STRING ,(FORMAT NIL "~S" PROCESS))
	  "    "
	  `(:FUNCTION ,#'TV:PEEK-PROCESS-WHOSTATE ,(NCONS PROCESS)))
	))

(DEFMETHOD (:PROTOCOL BASIC-SERVER) ()
  (SERVER-PROTOCOL-NAME SERVER))

(DEFMETHOD (:TRUSTED-P BASIC-SERVER) ()
  (SEND NETWORK :ADDRESS-TRUSTED-P ADDRESS))

;;; "Commands"

(DEFUN DESCRIBE-SERVERS ()
  (LOOP FOR SERVER IN *ACTIVE-SERVERS*
	DO (FORMAT T "~%~A serving ~A~@[ in process ~A~]"
		   (SEND SERVER :PROTOCOL)
		   (SEND SERVER :FOREIGN-HOST)
		   (SEND SERVER :PROCESS))))

(DEFUN CLOSE-ALL-SERVERS (&OPTIONAL (REASON "closing all servers") SINGLE-NETWORK)
  (WHEN (AND SINGLE-NETWORK (SYMBOLP SINGLE-NETWORK))
    (SETQ SINGLE-NETWORK (LOCAL-NETWORK-OF-TYPE SINGLE-NETWORK)))
  (LOOP FOR SERVER IN *ACTIVE-SERVERS*
	WHEN (OR (NULL SINGLE-NETWORK)
		 (EQ SINGLE-NETWORK (SEND SERVER :NETWORK)))
	  DO (SEND SERVER :KILL REASON)))

;;; :ERROR-DISPOSITION, a property of servers, is normally NIL which causes
;;; a notification.  Other values can be :IGNORE, :NOTIFY and :DEBUGGER.  It
;;; is a valid keyword to define server and can be changed dynamically with
;;; CHANGE-SERVER-ERROR-DISPOSITION.

(DEFUN STANDARDIZE-SERVER-ERROR-DISPOSITION (DISPOSITION)
  (DECLARE (VALUES DISPOSITION FLAVORS))
  (COND ((NULL DISPOSITION) (VALUES ':NOTIFY '(ERROR)))
	((LISTP DISPOSITION) (VALUES (CAR DISPOSITION) (CDR DISPOSITION)))
	(T (VALUES DISPOSITION '(ERROR)))))

(DEFCONST *VALID-SERVER-ERROR-DISPOSITIONS* '(NIL :NOTIFY :DEBUGGER :IGNORE))

(DEFUN CHECK-SERVER-ERROR-DISPOSITION (POSSIBLE-VALUE)
  (UNLESS (MEMQ (STANDARDIZE-SERVER-ERROR-DISPOSITION POSSIBLE-VALUE)
		*VALID-SERVER-ERROR-DISPOSITIONS*)
    (FERROR "~A is not a valid server error disposition; expected one of ~S."
	    POSSIBLE-VALUE *VALID-SERVER-ERROR-DISPOSITIONS*)))

(DEFMACRO DEFINE-SERVER (PROTOCOL-NAME OPTIONS &BODY BODY)
  (DECLARE (ZWEI:INDENTATION 1 3 2 2)) 
  (LET ((MEDIUM-TYPE (GET (LOCF OPTIONS) ':MEDIUM))
	(FLAVOR NIL))
    (MULTIPLE-VALUE-BIND (ARGUMENT-LIST ARGUMENT-DESCRIPTIONS
			  PROPERTY-LIST MEDIUM-HANDLED)
	(LET ((FUNCTION (GET MEDIUM-TYPE 'DEFINE-SERVER)))
	  (WHEN (NULL FUNCTION)
	    (FERROR "Unknown medium type ~S in ~S" MEDIUM-TYPE OPTIONS))
	  (FUNCALL FUNCTION OPTIONS))
      (LET ((ADDITIONAL-ARGUMENTS NIL)
	    (ADDITIONAL-DESCRIPTIONS NIL))
	(LOOP FOR (INDICATOR VALUE) ON OPTIONS BY 'CDDR
	      DO (SELECTQ INDICATOR
		   ((:HOST :TRUSTED-P :NETWORK :ADDRESS)
		    (PUSH VALUE ADDITIONAL-ARGUMENTS)
		    (PUSH INDICATOR ADDITIONAL-DESCRIPTIONS))
		   ((:REJECT-UNLESS-TRUSTED :NO-HOST-IN-PROCESS-NAME
		     :PROCESS-NAME :PROCESS-PRIORITY :WHO-LINE :NO-EOF :NO-CLOSE :SIMPLE-P)
		    (PUTPROP (LOCF PROPERTY-LIST) VALUE INDICATOR))
		   (:ERROR-DISPOSITION
		    (CHECK-SERVER-ERROR-DISPOSITION VALUE)
		    (PUTPROP (LOCF PROPERTY-LIST) VALUE INDICATOR))
		   (:MEDIUM)
		   (:FLAVOR
		    (SETF FLAVOR VALUE))
		   (:PROPERTY
		    (PUTPROP (LOCF PROPERTY-LIST) (second value) (first value)))
		   (OTHERWISE
		    (UNLESS (MEMQ INDICATOR MEDIUM-HANDLED)
		      (FERROR "Unknown option ~S in ~S" INDICATOR OPTIONS)))))
	D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");; Force defaults for :reject-unless-trusted and :who-line if they haven't been
	;; defined.
0	(LOOP FOR INDICATOR IN '(:REJECT-UNLESS-TRUSTED :WHO-LINE) DO
	  (LOOP FOR (PROP NIL) ON PROPERTY-LIST BY #'CDDR
	      THEREIS (EQ PROP INDICATOR)
	      FINALLY (PUTPROP (LOCF PROPERTY-LIST) T INDICATOR)))
	(SETQ ARGUMENT-LIST (NCONC ARGUMENT-LIST (NREVERSE ADDITIONAL-ARGUMENTS))
	      ARGUMENT-DESCRIPTIONS (NCONC ARGUMENT-DESCRIPTIONS
					   (NREVERSE ADDITIONAL-DESCRIPTIONS))))
      (UNLESS (GET (LOCF PROPERTY-LIST) ':PROCESS-NAME)
	(PUTPROP (LOCF PROPERTY-LIST) (FORMAT NIL "~A server" PROTOCOL-NAME) ':PROCESS-NAME))
      (LET ((FUNCTION-NAME
	      (IF FLAVOR
		  `(,FLAVOR :SERVER-TOP-LEVEL)
		  (INTERN (FORMAT NIL "~A-SERVER-FUNCTION-INTERNAL" PROTOCOL-NAME)))))
	`(LOCAL-DECLARE ((FUNCTION-PARENT ,PROTOCOL-NAME DEFINE-SERVER))
	   ,(WHEN (NULL FLAVOR)
	      `(DEFUN ,FUNCTION-NAME ,ARGUMENT-LIST
		 ,@BODY))
	   (DEFINE-SERVER-1 ',PROTOCOL-NAME ',FUNCTION-NAME ',MEDIUM-TYPE
			    ',(LENGTH ARGUMENT-LIST) ',ARGUMENT-DESCRIPTIONS
			    ',PROPERTY-LIST))))))


(DEFVAR *SERVERS* NIL :LOCALIZE T)
(DEFVAR *SERVER-DEBUG-FLAG* NIL)

(DEFUN DEFINE-SERVER-1 (PROTOCOL-NAME FUNCTION-NAME MEDIUM-TYPE NUMBER-OF-ARGUMENTS
			ARGUMENT-DESCRIPTIONS PROPERTY-LIST)
  (WHEN (RECORD-SOURCE-FILE-NAME PROTOCOL-NAME 'DEFINE-SERVER)
    (LET ((SERVER (FIND-SERVER-NAMED PROTOCOL-NAME)))
      (WHEN (NULL SERVER)
	(SETQ SERVER (MAKE-SERVER PROTOCOL-NAME PROTOCOL-NAME))
	(PUSH SERVER *SERVERS*))
      (WHEN (AND *NEW-SERVICES-ENABLE* *SERVICES-ENABLED*)
	(PUSH PROTOCOL-NAME *SERVICES-ENABLED*))
      (WHEN (AND *STANDARD-NEW-SERVICES-ENABLE* (LISTP *STANDARD-NEW-SERVICES-ENABLE*))
	(PUSH PROTOCOL-NAME *STANDARD-SERVICES-ENABLED*))
      (ALTER-SERVER SERVER FUNCTION FUNCTION-NAME NUMBER-OF-ARGUMENTS NUMBER-OF-ARGUMENTS
		    MEDIUM-TYPE MEDIUM-TYPE ARGUMENT-DESCRIPTIONS ARGUMENT-DESCRIPTIONS
		    PROPERTY-LIST PROPERTY-LIST))))

(DEFUN FIND-SERVER-NAMED (PROTOCOL-NAME)
  (LOOP FOR SERVER IN *SERVERS*
	WHEN (EQ (SERVER-PROTOCOL-NAME SERVER) PROTOCOL-NAME)
	RETURN SERVER))

(DEFUN CHANGE-SERVER-ERROR-DISPOSITION (PROTOCOL-NAME NEW-DISPOSITION)
  (CHECK-SERVER-ERROR-DISPOSITION NEW-DISPOSITION)
  (LET ((SERVER (OR (FIND-SERVER-NAMED PROTOCOL-NAME)
		    (FERROR "No server for protocol ~S defined." PROTOCOL-NAME))))
    (PUTPROP (LOCF (SERVER-PROPERTY-LIST SERVER)) NEW-DISPOSITION ':ERROR-DISPOSITION)
    NEW-DISPOSITION))

(DEFMACRO WITH-SERVER-ERROR-DISPOSITION (SERVER &BODY BODY)
  `(LET ((.DISPOSITION. (GET (LOCF (SERVER-PROPERTY-LIST ,SERVER)) ':ERROR-DISPOSITION)))
     (BLOCK WITH-SERVER-ERROR-DISPOSITION
       (CONDITION-BIND ((ERROR
			  (LAMBDA (ERR)
			    (WHEN (SERVER-ERROR-HANDLE-ERROR-P ERR .DISPOSITION.)
			      (SERVER-ERROR-HANDLE-ERROR ERR .DISPOSITION.)
			      (RETURN-FROM WITH-SERVER-ERROR-DISPOSITION NIL)))))
	 ,@BODY))))

(DEFUN SERVER-ERROR-HANDLE-ERROR-P (ERROR &OPTIONAL (DISPOSITION
						      (CL:LOCALLY
							(DECLARE (SPECIAL .DISPOSITION.))
							.DISPOSITION.)))
  ;; .DISPOSITION. is there for compatibility with old versions of
  ;; WITH-SERVER-ERROR-DISPOSITION
  (WHEN (TYPEP ERROR 'ERROR)			;Only think about errors, not other conditions
    (UNLESS *SERVER-DEBUG-FLAG*
      (MULTIPLE-VALUE-BIND (DISPOSITION FLAVORS)
	  (STANDARDIZE-SERVER-ERROR-DISPOSITION DISPOSITION)
	(OR (NEQ DISPOSITION ':DEBUGGER)	;IGNORE or NOTIFY, handle it
	    ;; Return NIL if should enter DEBUGGER, i.e. not handle error.
	    (NOT (LOOP FOR FLAVOR IN FLAVORS
		       THEREIS (TYPEP ERROR FLAVOR))))))))

(DEFUN SERVER-ERROR-HANDLE-ERROR (ERROR DISPOSITION)
  (MULTIPLE-VALUE-BIND (DISPOSITION FLAVORS)
      (STANDARDIZE-SERVER-ERROR-DISPOSITION DISPOSITION)
    (WHEN (MEMQ DISPOSITION '(:IGNORE :NOTIFY))
      (LET ((MATCH-P (LOOP FOR FLAVOR IN FLAVORS
			   THEREIS (TYPEP ERROR FLAVOR))))
	(WHEN (EQ (EQ DISPOSITION ':NOTIFY) MATCH-P)
	  (TV:NOTIFY NIL "Error in network server process /"~A/":~%  ~~A~"
		     (SEND CURRENT-PROCESS ':NAME) ERROR))))))

(DEFUN GET-SERVER-STREAM (SERVER MEDIUM-NAME FUNCTION ARGS)
  (MULTIPLE-VALUE-BIND (ENCAPSULATIONS CONTAINED-P)
      (COMPUTE-MEDIUM-ENCAPSULATIONS MEDIUM-NAME (SERVER-MEDIUM-TYPE SERVER) NIL)
    (COND ((NOT CONTAINED-P)	
	   (FERROR "Can't match medium ~A with server medium type ~A."
		   MEDIUM-NAME (SERVER-MEDIUM-TYPE SERVER)))
	  ((NULL ENCAPSULATIONS)
	   (LEXPR-FUNCALL FUNCTION (APPEND ARGS (GET (LOCF (SERVER-PROPERTY-LIST SERVER))
						     :STREAM-OPTIONS))))
	  (T
	   ;; at each step, we ask the outside medium for the connection args, if any
	   (LOOP WITH BASE-STREAM =
		   (LEXPR-FUNCALL FUNCTION
				  (append
				    ARGS
				    (and (first ENCAPSULATIONS)
					 (medium-implementation-connection-args
					   (first ENCAPSULATIONS)))))
		 FOR ELIST ON ENCAPSULATIONS
		 for next-enc = (cadr elist)
		 DO (SETF BASE-STREAM
			  (LEXPR-FUNCALL (MEDIUM-IMPLEMENTATION-FUNCTION (FIRST ELIST))
					 NIL
					 BASE-STREAM
					 (append
					   (unless (REST1 ELIST)	; for the top one
					     (GET (LOCF (SERVER-PROPERTY-LIST SERVER))
						  :STREAM-OPTIONS))	; nil at the end
					   (and next-enc
						(medium-implementation-connection-args
						  next-enc)))))
		 FINALLY (RETURN BASE-STREAM))))))

(DEFUN INVOKE-SERVER (SERVER MEDIUM-NAME NETWORK ADDRESS &REST STREAM-ARGS)
  (LET ((PLIST (SERVER-PROPERTY-LIST SERVER)))
    (CONDITION-CASE (ERROR)
	 (IF (GET (LOCF PLIST) :SIMPLE-P)
	     (IN-SECURE-SERVER-ENVIRONMENT
	       (INVOKE-SERVER-INTERNAL SERVER MEDIUM-NAME NETWORK ADDRESS STREAM-ARGS))
	     (LET ((COPIED-STREAM-ARGS (COPYLIST STREAM-ARGS))
		   (PROCESS-NAME (GET (LOCF PLIST) :PROCESS-NAME)))
	       (PROCESS-RUN-FUNCTION-IN-SECURE-ENVIRONMENT
		 #'(LAMBDA ()
		     (INVOKE-SERVER-INTERNAL
		       SERVER MEDIUM-NAME NETWORK ADDRESS  COPIED-STREAM-ARGS))
		 :NAME PROCESS-NAME
		 :PRIORITY (CL:GETF PLIST :PROCESS-PRIORITY 0))))
       (ERROR
	 (CONDITION-CASE (ERROR)
	      (LEXPR-FUNCALL (GET MEDIUM-NAME 'REJECT-FUNCTION)
			     (DBG:REPORT-STRING ERROR)
			     STREAM-ARGS)
	    1;; Things must really be screwed up if we can't even reject this server.
0	    (ERROR
	      (TV:NOTIFY NIL "Error rejecting server ~A: ~A"
			 SERVER ERROR)
		  ))))))


;;; The LMFS bindings give each server no access to local files unless and until
;;; it specifically grants.
(DEFUN INVOKE-SERVER-INTERNAL (SERVER MEDIUM-NAME NETWORK ADDRESS STREAM-ARGS)
  (NETI:WITH-SERVER-ERROR-DISPOSITION SERVER
    (LET ((PROPERTY-LIST (NETI:SERVER-PROPERTY-LIST SERVER))
	  (NETI:*INHIBIT-OBSOLETE-INFORMATION-WARNING* T)
	  (SUCCESS NIL))
      (WHEN (AND (NULL (GET (LOCF PROPERTY-LIST) :SIMPLE-P))
		 (NULL (GET (LOCF PROPERTY-LIST) :NO-HOST-IN-PROCESS-NAME)))
	(SETF (PROCESS:PROCESS-NAME CURRENT-PROCESS)
	      (STRING-APPEND (GET (LOCF PROPERTY-LIST) :PROCESS-NAME)
			     " ("
			     (LET ((*INHIBIT-VALIDITY-CHECKING* T))
			       (SEND (GET-HOST-FROM-ADDRESS ADDRESS NETWORK)
				     :SHORT-NAME))
			     ")")))
      (UNWIND-PROTECT
	(BLOCK TOP
	  ;; If this could be one of several media, figure out which one.
	  (WHEN (LISTP MEDIUM-NAME)
	    (SETF MEDIUM-NAME
		  (LOOP WITH BASE-MEDIUM = (SERVER-MEDIUM-TYPE SERVER)
			FOR NAME IN MEDIUM-NAME
			DO (MULTIPLE-VALUE-BIND (NIL VALID)
			       (COMPUTE-MEDIUM-ENCAPSULATIONS NAME BASE-MEDIUM NIL)
			     (WHEN VALID
			       (RETURN NAME))))))
	  ;; Reject the connection if it needs it.
	  (UNLESS (AND *SERVICES-ENABLED*
		       (OR (EQ *SERVICES-ENABLED* 'T)
			   (CL:MEMBER (SERVER-PROTOCOL-NAME SERVER) *SERVICES-ENABLED*)))
	    (LEXPR-FUNCALL (GET MEDIUM-NAME 'REJECT-FUNCTION)
			   (IF (NULL *SERVICES-ENABLED*) "Services are not enabled."
			       (FORMAT NIL "Service ~S is not enabled."
				       (SERVER-PROTOCOL-NAME SERVER)))
			   STREAM-ARGS)
	    (SETF SUCCESS T)
	    (RETURN-FROM TOP))
	  (WHEN (AND (GET (LOCF PROPERTY-LIST) :REJECT-UNLESS-TRUSTED)
		     (NOT (SEND NETWORK :ADDRESS-TRUSTED-P ADDRESS)))
	    (LEXPR-FUNCALL (GET MEDIUM-NAME 'REJECT-FUNCTION)
			   "This service is not provided to untrusted hosts."
			   STREAM-ARGS)
	    (SETF SUCCESS T)
	    (RETURN-FROM TOP))
	  ;; Call the handler for this base medium.
	  (WITH-STACK-LIST (GENERAL-ARGUMENTS :NETWORK NETWORK
					      :ADDRESS ADDRESS
					      :MEDIUM MEDIUM-NAME)
	    ;;Deal with old servers compatibly.
	    (WHEN (SYMBOLP (SERVER-FUNCTION SERVER))
	      (LET ((ARG-DESCS (SERVER-ARGUMENT-DESCRIPTIONS SERVER)))
		(WHEN (MEMQ :HOST ARG-DESCS)
		  (PUSH (GET-HOST-FROM-ADDRESS ADDRESS NETWORK) GENERAL-ARGUMENTS)
		  (PUSH :HOST GENERAL-ARGUMENTS))
		(WHEN (MEMQ :TRUSTED-P ARG-DESCS)
		  (PUSH (SEND NETWORK :ADDRESS-TRUSTED-P ADDRESS) GENERAL-ARGUMENTS)
		  (PUSH :TRUSTED-P GENERAL-ARGUMENTS))))
	    (SETF SUCCESS T)
	    (FUNCALL (GET (SERVER-MEDIUM-TYPE SERVER) 'INVOKE-SERVICE-FUNCTION)
		     SERVER MEDIUM-NAME STREAM-ARGS GENERAL-ARGUMENTS)))
	;; Clean up if necessary.
	(UNLESS SUCCESS
	  (LEXPR-FUNCALL (GET MEDIUM-NAME 'REJECT-FUNCTION)
			 "Error setting up server."
			 STREAM-ARGS)))
      NIL)))

(DEFUN FUNCALL-SERVER-FUNCTION (SERVER ARGUMENTS)
  (LET* ((SERVER-FUNCTION (SERVER-FUNCTION SERVER))
	 (WHO-LINE-P (GET (LOCF (SERVER-PROPERTY-LIST SERVER)) :WHO-LINE))
	 (INSTANCE (COND ((LISTP SERVER-FUNCTION)
			  (LEXPR-FUNCALL #'MAKE-INSTANCE (FIRST SERVER-FUNCTION)
					 :SERVER SERVER ARGUMENTS))
			 (WHO-LINE-P
			  (LET ((BASE-FLAVOR (GET (SERVER-MEDIUM-TYPE SERVER)
						  'SERVER-BASE-FLAVOR)))
			    (WHEN BASE-FLAVOR
			      (LEXPR-FUNCALL #'MAKE-INSTANCE BASE-FLAVOR
					     :SERVER SERVER ARGUMENTS)))))))
    (COND ((NULL INSTANCE)
	   (CALL-FAST-SERVER-FUNCTION SERVER ARGUMENTS))
	  (WHO-LINE-P
	   (UNWIND-PROTECT
	     (PROGN (WITHOUT-INTERRUPTS
		      (PUSH INSTANCE *ACTIVE-SERVERS*)
		      (SETQ *ACTIVE-SERVERS-LAST-UPDATE-TIME* (TIME)))
		    (IF (LISTP SERVER-FUNCTION)
			(SEND INSTANCE :SERVER-TOP-LEVEL)
			(CALL-FAST-SERVER-FUNCTION SERVER ARGUMENTS)))
	     (WITHOUT-INTERRUPTS
	       (SETQ *ACTIVE-SERVERS* (DELQ INSTANCE *ACTIVE-SERVERS*))
	       (SETQ *ACTIVE-SERVERS-LAST-UPDATE-TIME* (TIME)))))
	  (T (SEND INSTANCE :SERVER-TOP-LEVEL)))))

(DEFUN CALL-FAST-SERVER-FUNCTION (SERVER ARGUMENTS)
  (LOOP WITH SERVER-FUNCTION = (SERVER-FUNCTION SERVER)
	WITH NUMBER-OF-ARGUMENTS = (SERVER-NUMBER-OF-ARGUMENTS SERVER)
	INITIALLY (%START-FUNCTION-CALL SERVER-FUNCTION RETURN NUMBER-OF-ARGUMENTS NIL)
	FOR ARGUMENT IN (SERVER-ARGUMENT-DESCRIPTIONS SERVER)
	DO (%PUSH (GET (LOCF ARGUMENTS) ARGUMENT))
	FINALLY (RETURN (%FINISH-FUNCTION-CALL SERVER-FUNCTION RETURN
					       NUMBER-OF-ARGUMENTS NIL))))



;;; Support for the :BYTE-STREAM generic medium

(DEFFLAVOR BYTE-STREAM-SERVER
	   (STREAM)
  (BASIC-SERVER)
  :ABSTRACT-FLAVOR
  :GETTABLE-INSTANCE-VARIABLES
  (:INITABLE-INSTANCE-VARIABLES STREAM))

(DEFMETHOD (:FOREIGN-HOST BYTE-STREAM-SERVER) ()
  (SEND STREAM :FOREIGN-HOST))

(DEFMETHOD (:KILL BYTE-STREAM-SERVER) (REASON)
  (SEND STREAM :CLOSE-WITH-REASON REASON :ABORT))

(DEFMETHOD (:PEEK BYTE-STREAM-SERVER) ()
  (LIST ()
	(TV:SCROLL-PARSE-ITEM
	  (FORMAT NIL "~41X")
	  `(:MOUSE
	    (NIL :KBD (SEND :SERVER-STREAM-MENU ,STREAM)
		 :DOCUMENTATION "Menu of useful things to do to this stream.")
	    :STRING ,(FORMAT NIL "~S" STREAM)))))

(COMPILE-FLAVOR-METHODS BYTE-STREAM-SERVER)

(DEFFLAVOR DEFAULT-BYTE-STREAM-SERVER () (BYTE-STREAM-SERVER)
  (:INIT-KEYWORDS :HOST :TRUSTED-P))

(DEFMETHOD (:SERVER-TOP-LEVEL DEFAULT-BYTE-STREAM-SERVER) ()
  (FERROR "This isn't a real server, you know."))

(COMPILE-FLAVOR-METHODS DEFAULT-BYTE-STREAM-SERVER)

(DEFPROP :BYTE-STREAM DEFAULT-BYTE-STREAM-SERVER SERVER-BASE-FLAVOR)

(DEFUN (:BYTE-STREAM DEFINE-SERVER) (OPTIONS)
  (LET ((ARGUMENT-LIST NIL)
	(ARGUMENT-DESCRIPTIONS NIL)
	(PROPERTY-LIST NIL))
    (LOOP FOR (INDICATOR VALUE) ON OPTIONS BY 'CDDR
	  DO (SELECTQ INDICATOR
	       (:STREAM
		(LET ((STREAM-VAR (IF (LISTP VALUE) (CAR VALUE) VALUE)))
		  (PUSH STREAM-VAR ARGUMENT-LIST))
		(PUSH ':STREAM ARGUMENT-DESCRIPTIONS)
		(IF (LISTP VALUE)
		    (PUTPROP (LOCF PROPERTY-LIST) (CDR VALUE) ':STREAM-OPTIONS)))))
    (VALUES (NREVERSE ARGUMENT-LIST) (NREVERSE ARGUMENT-DESCRIPTIONS)
	    PROPERTY-LIST '(:STREAM))))

(DEFPROP :BYTE-STREAM BYTE-STREAM-INVOKE-SERVICE-FUNCTION INVOKE-SERVICE-FUNCTION)

(DEFUN BYTE-STREAM-INVOKE-SERVICE-FUNCTION (SERVER MEDIUM-NAME MEDIUM-ARGS GENERAL-ARGUMENTS)
  (LET ((PLOC (LOCF (SERVER-PROPERTY-LIST SERVER)))
	(STREAM NIL))
    (UNWIND-PROTECT-CASE (ABORTED-P)
	(PROGN (SETF STREAM (GET-SERVER-STREAM SERVER MEDIUM-NAME
					       (GET MEDIUM-NAME 'BYTE-STREAM-FUNCTION)
					       MEDIUM-ARGS))
	       (LET ((ACCEPTL (GETL (LOCF (GET PLOC :STREAM-OPTIONS)) '(:ACCEPT-P))))
		 (WHEN (OR (NULL ACCEPTL)
			   (SECOND ACCEPTL))
		   (SEND STREAM :ACCEPT)))
	       (WITH-STACK-LIST* (ARGUMENTS :STREAM STREAM GENERAL-ARGUMENTS)
		 (FUNCALL-SERVER-FUNCTION SERVER ARGUMENTS)))
      (:ALWAYS (WHEN STREAM
		 (UNLESS (GET PLOC :NO-CLOSE)
		   (SEND STREAM :CLOSE (OR ABORTED-P (GET PLOC :NO-EOF)))))))))

;;; Support for the :DATAGRAM generic medium

(DEFUN (:DATAGRAM DEFINE-SERVER) (OPTIONS)
  (LET ((ARGUMENT-LIST NIL)
	(ARGUMENT-DESCRIPTIONS NIL)
	(PROPERTY-LIST NIL))
    (LOOP FOR (INDICATOR VALUE) ON OPTIONS BY 'CDDR
	  AS TEM = (ASSQ INDICATOR '((:REQUEST-ARRAY :REQUEST-ARRAY-START
				      :REQUEST-ARRAY-END)
				     (:RESPONSE-ARRAY :RESPONSE-ARRAY-START
				      :RESPONSE-ARRAY-END)))
	  WHEN TEM
	  DO (DESTRUCTURING-BIND (ARRAY START END) VALUE
	       (UNLESS (NULL ARRAY)
		 (PUSH ARRAY ARGUMENT-LIST)
		 (PUSH (FIRST TEM) ARGUMENT-DESCRIPTIONS))
	       (UNLESS (NULL START)
		 (PUSH START ARGUMENT-LIST)
		 (PUSH (SECOND TEM) ARGUMENT-DESCRIPTIONS))
	       (UNLESS (NULL END)
		 (PUSH END ARGUMENT-LIST)
		 (PUSH (THIRD TEM) ARGUMENT-DESCRIPTIONS))))
    (VALUES (NREVERSE ARGUMENT-LIST) (NREVERSE ARGUMENT-DESCRIPTIONS)
	    PROPERTY-LIST '(:REQUEST-ARRAY :RESPONSE-ARRAY))))

(DEFUN (:DATAGRAM INVOKE-SERVICE-FUNCTION)
       (SERVER MEDIUM-NAME MEDIUM-ARGS GENERAL-ARGUMENTS)
  (LEXPR-FUNCALL (GET MEDIUM-NAME 'DATAGRAM-FUNCTION) SERVER GENERAL-ARGUMENTS MEDIUM-ARGS))

;;; If the machine halts in a server, it will not run unwind-protects and not
;;; depart from *active-servers*.  This cleans up Peek.  Note that the rules are
;;; that all `servers' recorded on *ACTIVE-SERVERS* are killed by warm boot.
;;; It is not legitimate for an application to set one to stay around, since by
;;; definition any *ACTIVE-SERVERS* server is a response to a particular 
;;; network connection.

(DEFUN WARM-BOOT-FLUSH-DEAD-SERVERS ()
  (SETQ *ACTIVE-SERVERS* NIL))

(ADD-INITIALIZATION "Clean up NETI:*ACTIVE-SERVERS*" '(WARM-BOOT-FLUSH-DEAD-SERVERS)
		    '(:WARM))

(DEFVAR *REMOTE-TERMINALS* NIL)			;here since notifications look at it.
