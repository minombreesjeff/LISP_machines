;;; -*- Mode: LISP; Syntax: Zetalisp; Package: NETI; Base: 10; Lowercase: Yes -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;;; Automatic site changing stuff run at boot time

(defvar *expecting-who-am-i-response* nil)

D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");;; Set *EXPECTING-WHO-AM-I-RESPONSE* only when we are not a standalone site or a primary
;;; namespace server.
0(defun (2 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")set-expecting-who-am-i-response 0()
  (setq *expecting-who-am-i-response*
	(not 
	  (or (let ((standalone (send *local-site* :standalone)))
		(and standalone (string-equal standalone "YES")))
	      (eq (send *namespace* :local-server-p) :primary)))))

(add-initialization "Site expects WHO-AM-I"
		    '(set-expecting-who-am-i-response)
		    '(:site :normal))

(add-initialization "Host expects WHO-AM-I"
		    '(set-expecting-who-am-i-response)
		    ()
		    'local-name-initialization-list)

1;;; Validates the local host's identity at namespace initialization time
0(defun1 0check-local-host-identity ()
  (let ((*inhibit-validity-checking* t))	1;Don't use the network
0    (when *expecting-who-am-i-response*		1;Only do something when we expect an answer
0      (multiple-value-bind (namespace-name host-name server)
	  (get-who-am-i-from-network)
	(let* ((namespace (and namespace-name
			       (condition-case ()
				    (find-object-named ':namespace namespace-name)
				  (object-not-found nil))))
	       (host (and namespace
			  (not (symbolp host-name))
			  (condition-case ()
			       (find-object-named-in-namespace ':host host-name namespace)
			     (object-not-found nil)))))
	  (unless (eq host *local-host*)	1;Something has changed
0	    1;; Policy:  To avoid having machines come up as uninterned hosts and to avoid
	    ;; prompting the user, we make every effort to validate the local host without
0	    1;; prompting but if the host is uninterned and not in the distribution
	    ;; namespace, we change to the distribution namespace and notify the user.0  1Note,
	    ;; this should only happen under the most severe of circumstances.

0	    1;; Note:  We use CHANGE-LOCAL-SITE-AND-HOST instead of CHANGE-TO-DISTRIBUTION-SITE
	    ;; to avoid excess printing to error-output during booting.
0	    (cond ((eq host-name ':no-response)
		   1;; No one answered.  If *local-host* is uninterned, notfiy the user and
		   ;; change to the distribution site.
0		   (when (send *local-host* :uninterned-p)
		     (tv:notify
		       nil
		       "Unable to verify the identity of the local host from the network or the namespace information in the world, changing to distribution site.")
		     (change-local-site-and-host *distribution-site*)))
		  ((eq host-name ':unknown)
1		   ;; Server that answered did not know.  Again, if we are uniterned, punt.
		   ;; But, if we are interned, notify that something is amiss
0		   (if (not (send *local-host* :uninterned-p))
		       (tv:notify
			 nil
			 "Network server (~A) does not know identity of this machine.  Either the server is confused, the namespace is confused, or this machine has moved." server)
		       (tv:notify
			 nil
			 "Network server (~A) and the namespace information in this world do not know identity of this machine.  Changing to the distribution site." server)
		       (change-local-site-and-host *distribution-site*)))
		  ((or (null host)
		       (neq (send host ':system-type) ':lispm))
1		   ;; We didn't know enough about the host before to use the normal validation
		   ;; mechanisms, use this server for namespace.  A bit gross but we don't
		   ;; prompt the user anywhere.
0		   (let ((*inhibit-validity-checking* nil))
		     (cond ((null namespace)
			    (make-server-usable-for-namespace namespace-name namespace server)
			    (setq namespace (find-object-named ':namespace namespace-name)))
			   ((null (send namespace ':server-access-paths))
			    (make-server-usable-for-namespace namespace-name namespace server))
			   (t
			    (decache-object-named ':host (send namespace
							       ':intern-name host-name))))
		     (setq host (condition-case ()
				     (find-object-named-in-namespace ':host
								     host-name namespace)
				   (object-not-found nil)))
		     (cond
		       (host
			(change-local-host host)
1			;; Undo any possible temporary secondary namespace server.
0			(send namespace ':check-validity nil t))
		       ((send *local-host* :uninterned-p)
			1;; We failed at trying to find the new host and we are uninterned.
0			(tv:notify
			  nil
			  "Attempt to change local host to ~A failed because the host was not found in the ~A namespace.  Unable to verify the local host's identity.  Changing to the distribution site." host-name namespace)
			(change-local-site-and-host *distribution-site*))
		       (t
			1;; We failed but the local host is useable.  Just let the user know
			;; what happened.
0			(tv:notify
			  nil
			  "Attempt to change local host to ~A failed because the host was not found in the ~A namespace.  Local host not changed."  host-name namespace)))))
		  (t
		   ;; We have a host that can be the local host
		   (setq *inhibit-validity-checking* nil)
		   (change-local-host host)))))))))

(defun change-to-distribution-site ()
  (format error-output "~&Changing site to stand-alone distribution site.")
  (change-local-site-and-host *distribution-site*))

;;; Set the local site and change the local host to come from that site.
(defun change-local-site-and-host (site)
  (let-if (progn
	    #+IMach (sys:system-case ((Solstice Domino) t) (otherwise nil))
	    #-IMach nil)
	  ((debug-io "No console"))
    1;; Before we go creating any new objects, flush the cache of addresses we have accumulated
    ;; for networks in the current site.
0    (loop for net in *local-networks* do (send-if-handles net :clear-address-table))
    #+IMach
    (system-case
      ((Solstice Domino VLM)
	(when (and (not (null *main-console*))
		   (operation-handled-p *main-console* 'x-screen:x-console-shutdown)
		   #+VLM (not (eq (x-screen::x-console-protocol *main-console*) :VLM)))
	  ;; Make sure the console gets shut down.
	  (x-screen:x-console-shutdown *main-console*)))
      (otherwise nil))
    (let ((old-local-host-pretty-name (and *local-host*
					   (send *local-host* :pretty-name)))
	  (old-local-host-short-name (and *local-host*
					  (send *local-host* :get :short-name)
					  (send *local-host* :short-name))))
      (change-local-site site)
      ;; First get a local host on the right network so can find out correct name.
      ;; Also local host might be the only namespace server.
      (let ((*inhibit-validity-checking* t))
	(get-local-host))
      ;; Now make sure we have it for real.
      (get-local-host)
      (if (or *inhibit-namespace-notifications*
	      #+IMach (sys:system-case ((Solstice Domino) t) (otherwise nil)))
	  (tv:notify nil "The local host is now ~A" *local-host*)
	  (format error-output "~&The local host is now ~A.~%" *local-host*))
      (when old-local-host-pretty-name
	(dolist (console *consoles*)
	  (when (operation-handled-p console 'x-screen::x-console-note-host-name-change)
	    (x-screen::x-console-note-host-name-change console
						       old-local-host-pretty-name
						       old-local-host-short-name))))
      (change-local-site-2)
      #+IMach
      (system-case
	(solstice
	  ;; Restart the host applications, which will buy us a new console.
	  (setf (si:emb-restart-applications) 1))
	(otherwise nil)))))

(defun change-local-site (site)
  (setq *local-site* site)
  (inhibit-style-warnings
    (setq si:site-name (send *local-site* ':name)))	1;For obsolecents
0  (let ((new-namespace (send *local-site* ':local-namespace)))
    (when (null new-namespace)
      (ferror "The local site (~A) does not have a :LOCAL-NAMESPACE attribute"
	      (send *local-site* ':name)))
    (setq *namespace* new-namespace))
  (let ((new-search-list (send *namespace* ':search-rules)))
    (when (null new-search-list)
      (tv:notify nil "The local namespace (~A) does not have a :SEARCH-RULES attribute"
		 *namespace*)
      (setq new-search-list (list *namespace*)))
    (setq *namespace-search-list* new-search-list))
  (get-primary-network-address))

(defvar *sys-host-user* nil)			;remember this so it doesn't get GC'ed.

(defun change-local-site-2 ()
  ;; If you boot up as unknown in the distribution world, then set
  ;; the site from files, the local host and net:parse-host will have a different
  ;; host object than fs:get-pathname-host and the physical host for SYS:.
  ;; So, get rid of names for uninterned hosts.
  (dolist (host fs:*pathname-host-list*)
    (when (and (not (eq host *local-host*)) (send host ':send-if-handles ':uninterned-p))
      (send host ':set-names nil)))
  (reset-all-namespace-access-paths)
  (keeping-namespace-server
    (setq *sys-host-user*
	  (condition-case ()
	       (find-object-named ':user "LISP-MACHINE")
	     (object-not-found
	       (format
		 error-output
		 "~&The user LISP-MACHINE was not found, you will certainly lose later.")
	       nil)))
      (fs:with-automatic-login-to-sys-host
      (when (ns-eq *local-site* *distribution-site*)
	(fs:setup-distribution-sys-host))
      (fs:file-host-reset)			1;reset any cached access paths
0      (fs:maybe-invalidate-sys-translations t)	;Force this before running site inits
      (run-site-initialization-list))))


(defun run-site-initialization-list ()
  (catch-error-restart (error "Skip running site initializations.")
    (keeping-namespace-server
      (initializations 'si:site-initialization-list t))))

;;; Set the local host and maybe the local site from that host.
;;; Called with *INHIBIT-VALIDITY-CHECKING* bound.
(defun change-local-host (host)
  (let* ((site (send host ':site))
	 (site-changed (and site (not (ns-eq site *local-site*)))))
    (catch-error-restart-if
      site-changed
      (error "Skip changing the local host to ~A and change to the distribution site instead."
	     host)
      (cond ((neq (send host ':system-type) ':lispm)
	     (cl:cerror "Set the local host to DISTRIBUTION|DIS-LOCAL-HOST instead."
			"The host ~A is not a lisp machine."
			host)
	     t)
	    ((or (and (not (null *primary-network*))
		      (null (send host :address)))
		 (not (send host ':property-list-compare
			    `(:address ((,*primary-network*
					 ,*primary-network-address*))))))
	     (cl:cerror "Set the local host to DISTRIBUTION|DIS-LOCAL-HOST instead."
			"The host ~A is not on the ~A network at ~A."
			host *primary-network* *primary-network-address*) t)
	    (t
	     (when site-changed
	       (tv:notify nil "Changing site to ~A..." site)
	       (change-local-site site))
	     (set-local-host host)
	     (when site-changed
	       (change-local-site-2))
	     (return-from change-local-host)))))
  (change-to-distribution-site))

1;;; All we have to go on is some host, make sure we can use it as a namespace server.  Note:
;;; this is only used during site creation and changing and hacks uninterned hosts so we can't
;;; use UPDATE-OBJECT-PERMANENTLY even though we risk confused plists.  The hosts used are
;;; only temporary.
0(defun make-server-usable-for-namespace
       (namespace-name namespace server &key link-to-old-site)
  1;; Make sure the server has the right services for our primary network.  Note:  we hack
  ;; services in an illegal manner here since we aren't sure about the namespace yet so
  ;; :namespace-view might not work.
0  (cl:ecase (send *primary-network* :type)
    (:chaos
      (unless (member '(:namespace :chaos :namespace) (send server :get :service))
	(push '(:namespace :chaos :namespace) (send server :get :service)))
      (unless (member '(:namespace-timestamp :chaos-simple :namespace-timestamp)
		      (send server :get :service))
	(push '(:namespace-timestamp :chaos-simple :namespace-timestamp)
	      (send server :get :service))))
    (:internet
      (unless (member '(:namespace :tcp :namespace) (send server :get :service))
	(push '(:namespace :tcp :namespace) (send server :get :service)))
      (unless (member '(:namespace-timestamp :udp :namespace-timestamp)
		      (send server :get :service))
	(push '(:namespace-timestamp :udp :namespace-timestamp)
	      (send server :get :service)))))
1  ;; Make sure the namespace has it as a server host.
0  (multiple-value-bind (name plist)
      (if namespace
	  (send namespace :namespace-view namespace)
	  (values namespace-name (copytree '(:search-rules (**self**)))))
    (setf namespace (add-or-change-object :namespace name plist namespace)))
  ;; Link up the networks1, if necessary
0  (when link-to-old-site
    (add-view-for-local-network *primary-network* namespace))
1  ;; We didn't know before, but should now
0  (decache-object-named :site namespace-name)
1  ;; SERVER is a host on the old network.  It won't appear reachable later,
  ;; so find out what the real servers for this namespace are now
0  (let ((*temporary-namespace-server* (invoke-service-on-host :namespace server
							      :namespace namespace)))
    (keeping-namespace-server
      (send namespace :check-validity nil t)
1      ;; Cache any other sites in the local namespace in case they have asked to set site to
      ;; a site that is not the same name as the namespace.  This is a bit kludgy but the only
      ;; way we normally find the site is by a reference to it in the servers namespace object.
0      (find-objects-from-property-list-in-namespace :site namespace)
      (send namespace :change-of-attributes))))

(defun add-view-for-local-network (network namespace)
  (let ((primary-name (send network :primary-name *namespace*)))
    (update-object-permanently :network namespace
			       (parse-name (send primary-name :string) nil namespace)
			       `(:type ,(send network :type)
				 :nickname (,primary-name))
			       t)))

;;; Check again after local host is set for site inside it having changed.
(defun check-local-host-site ()
  (unless (ns-eq *local-site* (send *local-host* :site))
    (change-local-host *local-host*)))

(add-initialization "CHECK-LOCAL-HOST-SITE" '(check-local-host-site) nil
		    'local-name-initialization-list)

;;;; User functions for calling later to set site information

;;; :SERVER-NAME specified the string name of the primary server
;;; :SERVER-CHAOS-ADDRESS is its chaos address
;;; :FORCE-EXISTING-SITE indicates that a new site should never be created
;;;     as a result of this call.
;;;     supplying SERVER-NAME implies this.
;;; :IGNORE-EXISTING-SITE T means treat the site as unknown even if happen to have
;;;     a site by this name in the database.
;;;     supplying SERVER-NAME implies this.
(defun set-site (site-and-namespace-name &key 
		 attempt-broadcast
		 server-name server-chaos-address
		 force-existing-site		1;this is implied by 0SERVER-NAME
		 ignore-existing-site		1;this is implied by 0SERVER-NAME
		 )
  (unless attempt-broadcast
    (check-arg site-and-namespace-name keywordp "the name of a site (a keyword symbol)"))
  (cl:check-type server-name (or null cl:string))
  (cl:check-type server-chaos-address (or null (cl:integer #o401 #o177777)))
  (when (and server-name (cl:member server-name '("" "local") :test #'string-equal))
    (setq server-name nil server-chaos-address nil)
    (format t "~&:SERVER-NAME of Local not supported just yet."))
  (let ((remote-login-state remote-login-on))
    (unwind-protect
	(fs:with-automatic-login-to-sys-host
	  #+IMACH
	  (system-case
	    1;; Turn on Remote-login for the duration on NXP's
0	    (nxp1000 (remote-login-on))
	    (otherwise nil))
	  ;; This kludge is necessary because 7.4I UX400S machines might boot with
	  ;; their primary address on the Internet, but 7.4I Set Site requires a
	  ;; Chaosnet address.  Fixed in 7.5.
	  (let* ((chaos (local-network-of-type :chaos))
		 (primary-chaos-entry (get-primary-address-entry-of-type :chaos))
		 (chaos-address (when primary-chaos-entry
				  (primary-address-address-string primary-chaos-entry))))
	    (unless (assoc chaos (send net:*local-host* :address))
	      (unless chaos-address
		(setf chaos-address
		      (prompt-and-read '(:integer :base 8 :from #o401 :to #o177777)
				       "Chaosnet address for local host: ")))
	      (multiple-value-bind (primary-name property-list)
		  (send net:*local-host* :namespace-view net:*namespace*)
		(push (list chaos (format nil "~O" chaos-address))
		      (cl:getf property-list :address))
		(update-object-permanently :host net:*namespace*
					   primary-name property-list t))))
	  ;; Find the site
	  (let ((site
		  (loop doing
		    (when attempt-broadcast
		      (let ((site (find-local-site-via-broadcast)))
			(when site
			  (format t "~&Setting site to ~A.~%" site)
			  (return site)))
		      (format t "~&Could not get site via network broadcast.")
		      (unless (fquery `(:choices
					 (((t "Try again") #/T #\space #/Y)
					  ((nil "Specify site name") #/S #\rubout #/N)))
				      "Try again or specify site name? ")
			(setq attempt-broadcast nil)
			(setq site-and-namespace-name
			      (scl:accept 'cl:keyword :prompt "Site name"))))
		    (unless attempt-broadcast
		      (return
			(if server-name
			    (find-local-site-given-address
			      site-and-namespace-name
			      server-name
			      server-chaos-address)
			    (find-site site-and-namespace-name
				       :ignore-existing-site ignore-existing-site
				       :force-existing-site force-existing-site)))))))
	    ;; Change over to it.
	    (change-local-site-and-host site))
	  ;; Resynchronize
	  (send *namespace* :get-latest-timestamp))
      1;; Replace the value of net:remote-login-on on the NXP
0      #+Imach
      (system-case (nxp1000 (net:remote-login-on remote-login-state))
		    (otherwise nil))
      #+3600 nil))
  nil)

1;;; Policy:  No prompting or printing allowed.  Do everything from the callers.
0(defun find-local-site-via-broadcast ()
  (declare (values site host server))
  (multiple-value-bind (namespace-name host-name server)
		       (get-who-am-i-from-network)
    1;; We cannot assume that the site name and the namespace name are the same!
0    (cond ((null namespace-name)
	   1;; We lost
0	   (values nil nil nil))
	  ((not (stringp host-name))
	   1;; We have a namespace but the server doesn't know the local host.  Return what we
	   ;; have and let the caller figure things out.  [Isn't there something else we can
	   ;; do?]
0	   (values nil host-name server))
	  (t
	   1;; We have a hostname and a server, let's try to find the right site.
0	   (make-server-usable-for-namespace namespace-name nil server)
	   (let ((namespace (condition-case ()
				 (find-object-named ':namespace namespace-name)
			       (object-not-found nil))))
	     (when (null namespace)
	       1;; Upon further questioning, the server didn't know about this namespace.
	       ;; Sigh, return what we have again.
0	       (values nil host-name server))
	     1;; Disassociate from bootstrap environment now that we have the right object.
0	     (send namespace :change-of-attributes)
	     (let ((site (condition-case ()
			      (find-object-named-in-namespace ':site namespace-name namespace)
			    (object-not-found nil))))
	       (when (null site)
		 1;; The server doesn't know a site that matches the namespace name.
0		 (values nil host-name server))
	       1;; There may be more than one site in the namespace and our host may not be in
	       ;; the one that has the same name as the namespace.  Find all the sites
0	       (searching-one-namespace (namespace)
		 (find-objects-from-property-list :site))
	       1;; Try to find the host and return its real site
0	       (let ((host (condition-case ()
				(find-object-named-in-namespace ':host host-name namespace)
			      (object-not-found nil))))
		 (if host
		     (values (send host :site) host server)
		     1;; We couldn't find the host but that doesn't meand that the site isn't
0		     1;; OK.
0		     (values site host-name server)))))))))

1;;; These are specific functions to find a site given various parameters.  Most are only
;;; called from com-set-site.  They do no prompting since the args are known, correct, and
;;; complete.
0(defun 2find-site-given-server-address 0(namespace site server-name server-network
				       server-address)
  (let ((server (create-a-host-named server-name :lispm
				     :addresses (list (list server-network server-address)))))
    (make-server-usable-for-namespace namespace nil server)
    (send (find-object-named :namespace namespace) :change-of-attributes)
    (let ((base-site
	    (condition-case ()
		 (find-object-named :site namespace)
	       (object-not-found nil))))
    (when base-site
      (if (eq site namespace)
	  base-site
	  (condition-case ()
		 (find-object-named :site site)
	       (object-not-found nil)))))))

(defun 2get-host-name-from-descriptor-file 0(descriptor-file)
  (with-open-file (stream descriptor-file)
      (loop with (line eof)
	    do (multiple-value (line eof)
		 (send stream :line-in))
	    when (string-equal line "VERSION " 0 0 8 8)
	      do (let* ((start-idx (if (char= (aref line 8) #/") 9 8))
			(colon (string-search-char #/: line start-idx))
			(bar (string-search-char #/| line start-idx)))	1;0|
		   (when (or colon bar)
		     (return (substring line start-idx
					(if (and colon bar)
					    (if (< colon bar) colon bar)
					    (if colon colon bar))))))
	    until eof)))

(defun 2find-site-from-descriptor-file 0(namespace site descriptor-file server-name)
  (when (not server-name)
    (setq server-name (get-host-name-from-descriptor-file descriptor-file)))
    ;; Make it so that FOO: where FOO is the local host works in the declaration.
    (when server-name
      (unless (send *local-host* :pathname-host-namep server-name)
	(if (send *local-host* :uninterned-p)
	    (rplaca (send *local-host* :names) server-name)
	    (multiple-value-bind (name plist)
		(send *local-host* :namespace-view *namespace*)
	      (push (send *namespace* :intern-name server-name)
		    (getf plist :nickname))
	      (add-or-change-object :host name plist))))
      (let ((real-namespace (add-or-change-object :namespace namespace
					     (copytree	;` too smart about constants.
					       `(:primary-name-server (,*local-host*)
						 :search-rules (**self**)
						 :descriptor-file ,descriptor-file)))))
	(send real-namespace :set-unloaded "new site")
	(send real-namespace :get-latest-timestamp)
	(let ((base-site (condition-case ()
			      (find-object-named-in-namespace :site namespace real-namespace)
			    (object-not-found nil))))
	  (if (eq namespace site)
	      base-site
	      (condition-case ()
		   (find-object-named-in-namespace :site site real-namespace)
		 (object-not-found nil)))))))


;; --- replace this by merging it into the functions that follow.
(defun find-local-site-given-address
       (site-and-namespace-name server-name server-chaos-address
	)
  (let ((server (make-up-a-host-named server-name :host-chaos-address server-chaos-address)))
    (make-server-usable-for-namespace site-and-namespace-name nil server))
  ;; Disassociate from bootstrap environment
  (send (find-object-named :namespace site-and-namespace-name) :change-of-attributes)
  ;; Should now be in the database
  (find-object-named :site site-and-namespace-name))

(defun find-site (site-and-namespace-name &key ignore-existing-site link-to-old-site
		  force-existing-site)
  (check-arg site-and-namespace-name keywordp "the name of a site (a keyword symbol)")
  (let ((site (and (not ignore-existing-site)
		   (condition-case ()
		       (find-object-named :site site-and-namespace-name)
		     (object-not-found nil)))))
    (when (null site)
      (if (and (not force-existing-site)
	       ignore-existing-site)		1;defining a new site.
0	  (define-new-local-site site-and-namespace-name)
	  (find-local-site site-and-namespace-name :link-to-old-site link-to-old-site))
      ;; Disassociate from bootstrap environment
      (send (find-object-named :namespace site-and-namespace-name) :change-of-attributes)
      ;; Should now be in the database
      (setq site (find-object-named :site site-and-namespace-name)))
    site))

(defun find-local-site (site-and-namespace-name &key link-to-old-site)
  (let ((server (prompt-and-read
		  :string-trim
		  "What host is a namespace server for ~A (default: Local): "
		  site-and-namespace-name)))
    (if (member server '("" "local"))
	(let* ((descriptor-file
		 (prompt-and-read
		   :string-trim
  "Where is the descriptor file for ~A (default local:>sys>site>~A-namespace.text): "
		   site-and-namespace-name (string-downcase site-and-namespace-name)))
	       (file-host)
	       (colon (string-search-char #/: descriptor-file))
	       (bar (string-search-char #/| descriptor-file)))	1;0|
	  (when (or bar colon)
	    (setq file-host (substring descriptor-file 0
				       (if (and colon bar)
					   (if (< colon bar) colon bar)
					   (if colon colon bar))))
	    (if (equal file-host "local")
		(setq file-host nil)
		(setq file-host (make-up-a-host-named file-host :need-file-access t))))
	  (when (null file-host)
	    (fs:add-file-computer (setq file-host *local-host*)))	;Be safe
	  (let ((default (make-namespace-file-name
			   (fs:make-pathname :host file-host
					     :directory '("SYS" "SITE")
					     :canonical-type :text)
			   site-and-namespace-name :descriptor)))
	    (setq descriptor-file (fs:merge-pathnames descriptor-file default))
	    )
	  (when (eq file-host *local-host*)
	    (let (local-synonym)
	      ;; First try to guess what the pathname name of the local host is
	      (with-open-file (stream descriptor-file)
		(loop with (line eof)
		      do (multiple-value (line eof)
			   (send stream :line-in))
		      when (string-equal line "VERSION " 0 0 8 8)
		        do (let* ((start-idx (if (char= (aref line 8) #/") 9 8))
				  (colon (string-search-char #/: line start-idx))
				  (bar (string-search-char #/| line start-idx)))	1;0|
			     (when (or colon bar)
			       (setq local-synonym
				     (substring line start-idx
						(if (and colon bar)
						    (if (< colon bar) colon bar)
						    (if colon colon bar))))
			       (format t 
  "~&Assuming that ~A is the real pathname host name of the local host.~%"
				       local-synonym)
			       (return)))
		      until eof))
	      (when (null local-synonym)
		(setq local-synonym (prompt-and-read :string-trim 
  "What is the real name of the local host: ")))
	      ;; Make it so that FOO: where FOO is the local host works in the declaration.
	      (unless (send *local-host* :pathname-host-namep local-synonym)
		(if (send *local-host* :uninterned-p)
		    (rplaca (send *local-host* :names) local-synonym)
		    (format error-output 
  "Warning: the local host, ~A, was not known to have that name.~%" *local-host*)
		    (multiple-value-bind (name plist)
			(send *local-host* :namespace-view *namespace*)
		      (push (send *namespace* :intern-name local-synonym)
			    (getf plist :nickname))
		      (add-or-change-object :host name plist))))))
	  (let ((namespace (add-or-change-object :namespace
						 site-and-namespace-name
						 (copytree	;` too smart about constants.
						   `(:primary-name-server (,*local-host*)
						     :search-rules (**self**)
						     :descriptor-file ,descriptor-file)))))
	    (when link-to-old-site
	      (add-view-for-local-network chaos:*local-chaosnet* namespace))
	    (send namespace :set-unloaded "new site")
	    (send namespace :get-latest-timestamp)))
	(setq server (make-up-a-host-named server))
	(make-server-usable-for-namespace site-and-namespace-name nil server
					  :link-to-old-site link-to-old-site))))


1;;; Make a host up for hacking on during site setting and defining.  No prompting allowed!
0(defun 2create-a-host-named0 (host-name system-type &key addresses site machine-type
			    file-protocol embedded-in &aux plist)
  (setf (getf plist :system-type) system-type)
  (when machine-type
    (setf (getf plist :machine-type) machine-type))
  (when site
    (setf (getf plist :site) site))
  (when addresses				1;expected to be in the proper format
0    (setf (getf plist :address) addresses)
    (let ((services
	    (loop for network-pair in addresses 
		  append
		  (commonly-supported-services system-type (send (first network-pair) :type)))))
      (when file-protocol
	(dolist (medium (cl-neti::find-base-medium-for-medium
			  (protocol-base-medium-name (find-protocol-named file-protocol))))
	  (dolist (network-pair addresses)
	    (when (send (first network-pair)
			:possible-medium-for-protocol file-protocol medium)
	      (push (list :file medium file-protocol) services)))))
      (unless (null services)
	(setf (getf plist :service) services))))
  (when embedded-in
    (setf (getf plist :user-property) `((:embedded-in ,embedded-in))))
  (let ((host (make-object-from-property-list ':host host-name plist)))
    (when file-protocol
      (fs:add-file-computer host))
    host))

;;; This knows about the chaosnet
(defun make-up-a-host-named (host-name &key need-file-access system-type host-chaos-address
			     site just-return-plist need-system-type machine-type
			     &aux plist)
  (when machine-type
    (putprop (locf plist) machine-type ':machine-type))
  (when site
    (putprop (locf plist) site ':site))
  (unless host-chaos-address
    (loop doing
      (setq host-chaos-address (prompt-and-read '(:integer :base 8 :from #o401 :to #o177777)
						"Chaosnet address for ~A: " host-name))
      (when (condition-case (error)
		(fquery nil "Host responds as ~A, ok? "
			(get-response-from-status host-chaos-address))
	      (connection-error
		(fquery nil "~A, ok? " error)))
	(return t))
      (setq host-chaos-address nil)))
  (putprop (locf plist) `((,(local-network-of-type ':chaos)
			   ,(format nil "~O" host-chaos-address)))
	   ':address)
  (when (or system-type need-file-access need-system-type)
    (loop doing
      (unless system-type
	(setq system-type
	      (prompt-and-read
		':string-trim
		"What operating system runs on ~A? (e.g. LISPM, UNIX42)" host-name))
	(setq system-type (intern-global-name system-type)))
      (unless machine-type
	(setq machine-type
	      (intern-global-name
		(prompt-and-read
		  ':string-trim
		  "What machine type is ~A? (e.g. XL1200, MacIvory, Vax 8550)" host-name)))
	(putprop (locf plist) machine-type ':machine-type))
      (let ((services (assq :chaos (rest1 (assq system-type *supported-services*)))))
	(unless (null services)
	  (putprop (locf plist) (cdr services) ':service)
	  (putprop (locf plist) system-type ':system-type)
	  (return t)))
      (format t "~&~A is not a known system type.~%" system-type)
      (setq system-type nil)))
  (if just-return-plist plist
      (let ((host (make-object-from-property-list ':host host-name plist)))
	(when need-file-access
	  (fs:add-file-computer host)
	  (condition-bind ((fs:login-required
			     #'(lambda (error)
				 (format query-io 
					 "~&Need an account for logging in to ~A right now.~%"
					 (send (send error ':access-path) ':host))
				 nil)))
	    (fs:user-homedir host)))
	host))) 

(defun get-response-from-status (address &aux pkt)
  (unwind-protect
    (progn
      (setq pkt (chaos:simple address "STATUS"))
      (let ((string (chaos:pkt-string pkt)))
	(substring string 0 (string-search-char (code-char 0) string))))
    (and pkt (chaos:return-pkt pkt))))

;;; This function's new contract is to return a timezone string suitable for
;;; (accept 'time:timezone).  Thus the call to TIME:TIMEZONE-STRING.
;;; --- For 7.1, change TIME:TIMEZONE to take a presentation-argument 
;;; that controls whether or not daylight-savings-p should really be used
;;; in printing the timezone, and change this code to supply that presentation argument.
;;; The reason this hasn't been done yet is that these problems weren't discovered until
;;; 8/15/86 while Schatsky (the original author) was at AAAI.  -- Doughty
(defun get-valid-timezone-from-user ()
  (declare (values timezone-string))
  (time:timezone-string
    (scl:accept 'time:timezone :prompt "What is the local timezone" :default 5)
    nil))

;;; This defines a new site by writing a namespace file, and then reading it in to get
;;;  the objects interned.
(defun define-new-local-site (site-and-namespace-name)
  (let* ((descriptor-file (define-new-local-site-1 site-and-namespace-name))
	 (namespace (add-or-change-object :namespace site-and-namespace-name
					  `(:search-rules (**self**)
							  :primary-name-server (,*local-host*)
							  :descriptor-file
							  ,(string descriptor-file)))))
    (send namespace :set-unloaded "new site")
    (send namespace :get-latest-timestamp t)
    (deletef descriptor-file)))

;;; This queries the user and writes the appropriate files.  It returns a pathname for
;;; loading the namespace database.
(defun define-new-local-site-1 (site-and-namespace-name
				&aux namespace-server-name namespace-server-host
				sys-host-name sys-host sys-host-now
				sys-translations site-directory zippy-user
				timezone standalone-p host-for-bugs
				namespace-data-host-name namespace-data-host
				namespace-data-host-now data-directory)
  (setq namespace-server-name
	(string-upcase (prompt-and-read
			 :string-trim
			 "What host is to be a namespace server for ~A (default LOCAL): "
			 site-and-namespace-name)))
  (when (equal namespace-server-name "")
    (setq namespace-server-name "LOCAL"))
  (setq sys-host-name
	(string-upcase (prompt-and-read
			 :string-trim
			 "What host is to be the SYS host for ~A (default ~A): "
			 site-and-namespace-name namespace-server-name)))
  (when (equal sys-host-name "")
    (setq sys-host-name namespace-server-name))
  (setq namespace-data-host-name
	(string-upcase (prompt-and-read
			 :string-trim
			 "What Symbolics computer will store the namespace data files for ~A (default ~A): "
			 site-and-namespace-name namespace-server-name)))
  (when (equal namespace-data-host-name "")
    (setq namespace-data-host-name namespace-server-name))
  (setq host-for-bugs
	(string-upcase (prompt-and-read
			 :string-trim
			 "What host is to be used for bug reports for ~A (default ~A): "
			 site-and-namespace-name namespace-server-name)))
  (when (equal host-for-bugs "")
    (setq host-for-bugs namespace-server-name))
  (let (real-local-name fake-local-host)
    (when (or (equal sys-host-name "LOCAL")
	      (equal namespace-server-name "LOCAL"))
      (unless (and (not (null *primary-network*))
		   (eq (send *primary-network* :type) :chaos))
	(ferror "Local host must be on the chaosnet for now."))
      (setq real-local-name
	    (string-upcase (prompt-and-read :string-trim
					    "What is the real name of the local host: "))
	    fake-local-host (make-up-a-host-named real-local-name
			      :system-type :lispm
			      :machine-type (local-machine-type)
			      :host-chaos-address
			        (send *primary-network* :parse-address
							*primary-network-address*)
			      :site site-and-namespace-name)))
    (cond ((equal sys-host-name namespace-server-name)
	   (if (equal sys-host-name "LOCAL")
	       (setq sys-host-now *local-host*
		     sys-host fake-local-host
		     sys-host-name real-local-name
		     namespace-server-name real-local-name)
	       (setq sys-host (make-up-a-host-named sys-host-name :need-file-access t
						    :site site-and-namespace-name)
		     sys-host-now sys-host))
	   (setq namespace-server-host sys-host))
	  (t
	   (if (equal namespace-server-name "LOCAL")
	       (setq namespace-server-host fake-local-host
		     namespace-server-name real-local-name)
	       (setq namespace-server-host
		     (make-up-a-host-named namespace-server-name
					   :site site-and-namespace-name)))
	   (if (equal sys-host-name "LOCAL")
	       (setq sys-host-now *local-host*
		     sys-host fake-local-host)
	       (setq sys-host (make-up-a-host-named sys-host-name :need-file-access t
						    :site site-and-namespace-name)
		     sys-host-now sys-host))))
    (when (equal host-for-bugs "LOCAL")
      (setq host-for-bugs real-local-name))
    (cond ((equal namespace-data-host-name "LOCAL")
	   (setq namespace-data-host-name real-local-name)
	   (setq namespace-data-host fake-local-host)
	   (setq namespace-data-host-now *local-host*))
	  ((equal namespace-data-host-name sys-host-name)
	   (setq namespace-data-host sys-host)
	   (setq namespace-data-host-now sys-host-now))
	  (t
	   (setq namespace-data-host (make-up-a-host-named
				       namespace-data-host-name
				       :system-type :lispm
				       :need-file-access t
				       :site site-and-namespace-name))
	   (setq namespace-data-host-now namespace-data-host))))
  (loop doing
    (let* ((default (fs:make-pathname :host namespace-data-host :directory '("SYS" "SITE")))
	   (directory (prompt-and-read
			`(:pathname :default ,default)
			"What directory on ~A will hold the namespace data files (default ~A): "
			namespace-data-host-name (pathname-directory-only-string default))))
      (cond ((null (send directory :directory))
	     (format error-output "~%~A does not have a directory component at all.~@
				   Please type a pathname."
		     directory))
	    (t
	     (setq data-directory directory)
	     (return t)))))
  (loop doing
    (let* ((default (fs:make-pathname :host sys-host :directory '("SYS" "SITE")))
	   (directory (prompt-and-read
			`(:pathname :default ,default)
			"What directory on ~A corresponds to SYS: SITE; (default ~A): " 
			sys-host-name (pathname-directory-only-string default)))
	   (dir-1))
      (cond ((null (setq dir-1 (send directory :directory)))
	     (format error-output "~%~A does not have a directory component at all.~@
				   Please type a pathname."
		     directory))
	    ((not (equal (car (last dir-1)) "SITE"))
	     (format error-output "
~A does not have a structured directory component whose last sub-component is /"SITE/".
Please type such a pathname." directory))
	    (t
	     (let ((sys-logical-host (fs:get-pathname-host "SYS"))
		   (dir-2 (butlast dir-1)))
	       (setq sys-translations
		     (if (send directory :valid-directory-p '(:wild :wild-inferiors))
			 ;; Winning operating systems with :WILD-INFERIORS
			 `((,(fs:make-pathname :host sys-logical-host
					       :directory '(:wild-inferiors)
					       :name :wild
					       :type :wild
					       :version :wild)
			    ,(send directory :new-pathname
				   :directory (append dir-2 '(:wild-inferiors))
				   :name :wild :type :wild :version :wild)))
		       ;; losing operating systems without :WILD-INFERIORS (i.e. UNIX, TOPS20)
		       `((,(fs:make-pathname :host sys-logical-host
					     :directory '(:wild)
					     :name :wild
					     :type :wild
					     :version :wild)
			  ,(send directory :new-pathname
				 :directory (append dir-2 '(:wild))
				 :name :wild :type :wild :version :wild))
			 (,(fs:make-pathname :host sys-logical-host
					     :directory '(:wild :wild)
					     :name :wild
					     :type :wild
					     :version :wild)
			  ,(send directory :new-pathname
				 :directory (append dir-2 '(:wild :wild))
				 :name :wild :type :wild :version :wild))
			 (,(fs:make-pathname :host sys-logical-host
					     :directory '(:wild :wild :wild)
					     :name :wild
					     :type :wild
					     :version :wild)
			  ,(send directory :new-pathname
				 :directory (append dir-2 '(:wild :wild :wild))
				 :name :wild :type :wild :version :wild))))))
	     (setq site-directory directory)
	     (return t)))))
  (setq zippy-user (let* ((default (send sys-host-now :host-user-id))
			  (string (prompt-and-read
				    :string-trim
				    "What account should be used for the system to login to ~A (default: ~A): "
				    sys-host-name default)))
		     (if (equal string "") default string))
	timezone (get-valid-timezone-from-user)
	standalone-p (fquery nil 
			     "Is ~A a standalone site (there are no servers to respond to a Who-am-I request)? "
			     site-and-namespace-name))
  (let* ((base-file (send site-directory :new-pathname
			  :host sys-host-now
			  :canonical-type :text
			  :version :newest))
	 (base-data-file (send data-directory :new-pathname
			       :host namespace-data-host-now
			       :canonical-type :text
			       :version :newest))
	 (log-file (make-namespace-file-name base-data-file site-and-namespace-name :log))
	 (descriptor-file (make-namespace-file-name base-data-file site-and-namespace-name
						    :descriptor))
	 (temp-descriptor-file (send descriptor-file :new-type "TEMP"))
	 (object-file (make-namespace-file-name base-data-file site-and-namespace-name
						:objects))
	 (changes-file (make-namespace-file-name base-data-file site-and-namespace-name
						 :changes))
	 (translations-file
	   (send base-file :new-pathname :name "SYS" 		 
		 :canonical-type :logical-pathname-directory-translations))
	 (initial-timestamp))
    (fs:create-directories-recursively base-file)
    (fs:create-directories-recursively base-data-file)
    (with-open-file (stream log-file :direction :output)
      (format stream "~\DATIME\ ~A created by ~A~%" site-and-namespace-name user-id)
      (send stream :close)
      (setf initial-timestamp (let* ((info (send stream :info))
				     (version (send (car info) :version)))
				(if (eq version :unspecific)
				    (cdr info)
				    version))))
    (with-open-file (stream descriptor-file :direction :output)
      (format stream "VERSION /"~A:~A/"~%* /"~A:~A/"~%"
	      namespace-data-host-name (pathname-hostless-string log-file)
	      namespace-data-host-name (pathname-hostless-string object-file))
      (format stream "CHANGES /"~A:~A/"~%"
	      namespace-data-host-name (pathname-hostless-string changes-file)))
    (with-open-file (stream temp-descriptor-file :direction :output)
      (format stream "VERSION /"~A/"~%* /"~A/"~%" log-file object-file)
      (format stream "CHANGES /"~A/"~%" changes-file))
    (with-open-file (stream object-file :direction :output)
      (format stream ";-*- Mode: Text; Network-Namespace: ~A-*-
NAMESPACE ~A
PRIMARY-NAME-SERVER ~A
SEARCH-RULES ~A
DESCRIPTOR-FILE /"~A:~A/"

SITE ~A
PRETTY-NAME ~A
LOCAL-NAMESPACE ~A
SITE-DIRECTORY /"~A:~A/"
TIMEZONE ~A
HOST-FOR-BUG-REPORTS ~A
~:[~;STANDALONE YES
~]
NETWORK CHAOS
SITE ~A
TYPE CHAOS

"
	      site-and-namespace-name
	      site-and-namespace-name namespace-server-name site-and-namespace-name
	      namespace-data-host-name (pathname-hostless-string descriptor-file)
	      site-and-namespace-name (string-capitalize-words site-and-namespace-name t t)
	      site-and-namespace-name
	      sys-host-name (pathname-directory-only-string site-directory)
	      timezone host-for-bugs standalone-p
	      site-and-namespace-name)
      (print-host-attributes-for-new-site sys-host stream)
      (unless (eq sys-host namespace-server-host)
	(print-host-attributes-for-new-site namespace-server-host stream))
      (format stream "USER LISP-MACHINE~%HOME-HOST ~A~%" sys-host-name)
      (if (eq (send sys-host :system-type) :lispm)
	  (format stream "LISPM-NAME ~A~%" zippy-user)
	  (format stream "LISPM-NAME /"Lisp Machine/"~%LOGIN-NAME ~A ~A~%MAIL-ADDRESS ~A ~A~%"
		  zippy-user sys-host-name zippy-user sys-host-name))
      )
    (with-open-file (stream changes-file :direction :output)
      (format stream "TIMESTAMP ~D~%" initial-timestamp))
    (with-open-file (stream translations-file :direction :output)
      (scl:with-standard-io-environment
	(format stream ";;; -*- Mode: Lisp; Syntax: ~A; Package: FS; Base: ~D -*-~%"
		(cl:string-capitalize
		  (cl:symbol-name
		    (si:readtable-appropriate-file-syntax cl:*readtable*)))
		cl:*print-base*)
	(pkg-bind "FS"
	  (cl:pprint `(fs:set-logical-pathname-host
			"SYS"
			:translations
			',(loop for (logical physical) in sys-translations
				collect `(,(send logical :string-for-printing)
					  ,(send physical :string-for-printing))))
		     stream))))
    
    temp-descriptor-file))

;;; Mostly like (SEND HOST :PRINT-ATTRIBUTES STREAM), except that the network there is
;;; in the wrong namespace and would print with a |.
(defun print-host-attributes-for-new-site (host stream &optional site)
  (format stream "HOST ~A~%" (send host :primary-name))
  (loop for (ind val) on (send host :property-list) by 'cddr
	do (selectq ind
	     (:address
	      (loop for (network addr) in val do
		(format stream "ADDRESS ~A ~A~%" (send network :type) addr)))
	     (:site (format stream "SITE ~A~%" (or site val)))
	     (otherwise
	      (let ((template (class-get-template :host ind)))
		(condition-bind ((uninterned-object-in-attribute
				   #'(lambda (err) (send err :proceed :no-action))))
		  (unconvert-tokens ind nil template val stream))))))
  (terpri stream))

;;; :STRING-FOR-DIRECTORY doesn't have pathname delimiters.
;;; :STRING-FOR-PRINTING has the host name.
;;; :STRING-FOR-HOST isn't guaranteed for the user.
(defun pathname-directory-only-string (pathname)
  (pathname-hostless-string
    (send pathname :new-pathname
	  :name nil :type nil :version nil :vc-branch nil :vc-version nil)))

(defun pathname-hostless-string (pathname)
  (let* ((string (string pathname))
	 (colon (string-search-char #/: string)))
    (substring string (1+ colon))))

1;;; This is used by change-site-silently.  Heavily borrowed from find-local-site
;;; This goes through the craziness of changing the local host so it is a namespace
;;; server for the new site long enough to get the information we need.
0(defun 2find-local-site-without-prompting0 (site-and-namespace-name descriptor-file)
  (sys:enable-services '(:namespace :namespace-timestamp) nil)	1;Services are disabled at boot
0  (let ((file-host *local-host*))
    (fs:add-file-computer file-host)		1;Just in case
0    (let ((default (make-namespace-file-name
		     (fs:make-pathname :host file-host
				       :directory '("SYS" "SITE")
				       :canonical-type :text)
		     site-and-namespace-name :descriptor)))
      (setq descriptor-file (fs:merge-pathnames descriptor-file default)))
    (let (local-synonym)
      ;; First try to guess what the pathname name of the local host is
      (with-open-file (stream descriptor-file)
	(loop with (line eof)
	      do (multiple-value (line eof)
		   (send stream :line-in))
	      when (string-equal line "VERSION " 0 0 8 8)
		do (let* ((start-idx (if (char= (aref line 8) #/") 9 8))
			  (colon (string-search-char #/: line start-idx))
			  (bar (string-search-char #/| line start-idx)))
		     (when (or colon bar)
		       (setq local-synonym
			     (substring line start-idx
					(if (and colon bar)
					    (if (< colon bar) colon bar)
					    (if colon colon bar))))
		       (return)))
	      until eof))
      ;; Make it so that FOO: where FOO is the local host works in the declaration.
      (unless (send *local-host* :pathname-host-namep local-synonym)
	(if (send *local-host* :uninterned-p)
	    (rplaca (send *local-host* :names) local-synonym)
	    (multiple-value-bind (name plist)
		(send *local-host* :namespace-view *namespace*)
	      (push (send *namespace* :intern-name local-synonym)
		    (getf plist :nickname))
	      (add-or-change-object :host name plist)))))
    1;; Creat an object for the new namespace
0    (let ((namespace (add-or-change-object :namespace
					   site-and-namespace-name
					   (copytree	;` too smart about constants.
					     `(:primary-name-server (,*local-host*)
					       :search-rules (**self**)
					       :descriptor-file ,descriptor-file)))))
      (send namespace :set-unloaded "new site")
      (send namespace :get-latest-timestamp)))
1  ;; Should now be in the database
0  (find-object-named :site site-and-namespace-name))

1;;; This is for standalone hosts to boot without having to save a world.  The string
;;; in sys:*site-name* (set by the FEP) is compared to the local site and if they are
;;; different, the site is changed.  It is assumed that the site and the namespace share the
;;; same name.
0#+IMACH						1;When 3600's understand, this can go away.
0(defun 2change-site-silently 0()
  (when (and (variable-boundp sys:*site-name*)
	     sys:*site-name*
	     (not (string-equal sys:*site-name* "")))
    1;; Keep the namespace quiet while we do this
0    (let ((*inhibit-namespace-notifications* t)
	  (interned-site-name (intern-global-name sys:*site-name*))	1;Intern the string
0	  (*inhibit-validity-checking* nil)	1;Make sure we can do namespacing
0	  (*namespaces-initialized* t))		1;Let everyone believe the namespace is working.
0      (condition-case (error)			1;Protect against any problems.
0	   1;; The local site and the site from the FEP are different.
0	   (when (neq interned-site-name (send *local-site* :name))
	     (fs:with-automatic-login-to-sys-host
	       (let ((site 
		       (if (or (null sys:*namespace-descriptor-file*)
			       (string-equal sys:*namespace-descriptor-file* ""))
			   1;; They didn't give us a descriptor file so we will ask the network
0			   (find-local-site-via-broadcast)
			   1;; Try to get the local site from the files given.
0			   (find-local-site-without-prompting
			     interned-site-name
			     sys:*namespace-descriptor-file*))))
		 1;; Make sure we got something and it is what we asked for.
0		 (when (and site (eq interned-site-name (send site :name)))
		   (change-local-site-and-host site)	1;Go do it.
0		   (send *namespace* :get-latest-timestamp)))))
	 (error
	   (tv:notify nil
		   "~&Unable to change site to ~A.  ~A" sys:*site-name* error))))))

#+IMACH
(add-initialization "Maybe change local site" '(change-site-silently) nil
		    'after-network-initialization-list)

(comment

;;; Inverse function, write a hosts2 format file from the database.
(DEFUN WRITE-HOSTS.TEXT-FILE (OUTPUT-FILE &REST ARGS)
  (LEXPR-FUNCALL #'WRITE-HOST-TABLE-FILE OUTPUT-FILE
		 #'(LAMBDA (STREAM PRIMARY-NAME HOST OTHER-NAMES) 
		     (FORMAT STREAM "HOST ~A," PRIMARY-NAME)
		     (LOOP REPEAT (IF (< (STRING-LENGTH PRIMARY-NAME) 10.) 2 1)
			   DO (SEND STREAM ':TYO #\TAB))
		     (LET ((ADDRESSES (SEND HOST ':CHAOS-ADDRESSES)))
		       (IF (NULL (CDR ADDRESSES))
			   (FORMAT STREAM "CHAOS ~O" (CAR ADDRESSES))
			   (FORMAT STREAM "[~{CHAOS ~O~^,~}]" ADDRESSES)))
		     (FORMAT STREAM ",~A,~A,~A"
			     (IF (MEMQ (SEND HOST ':SYSTEM-TYPE) '(:ITS :TOPS-20 :TENEX :UNIX
								   :VMS :MAGICSIX :MULTICS))
				 ':SERVER ':USER)
			     (SEND HOST ':SYSTEM-TYPE) (SEND HOST ':MACHINE-TYPE))
		     (WHEN OTHER-NAMES
		       (FORMAT STREAM ",[~{~A~^,~}]" OTHER-NAMES))
		     (TERPRI STREAM))
		 ARGS))

(DEFUN WRITE-HOST-TABLE-FILE (OUTPUT-FILE FUNCTION
			      &KEY NAMESPACES (SUPPRESS-ONE-LETTER-NAMES T))
  (UNLESS NAMESPACES
    (SETQ NAMESPACES (LIST (SEND *NAMESPACE* ':NAME))))
  (LET ((HOSTS (GET-HOSTS-FOR-NAMESPACES NAMESPACES SUPPRESS-ONE-LETTER-NAMES)))
    (WITH-OPEN-FILE (STREAM OUTPUT-FILE ':DIRECTION ':OUTPUT)
      (FORMAT STREAM ";-*-Mode: Text; Nofill: Yes-*-
;Host table made from ~{~A~^,~} namespace~P at ~\DATIME\ (timestamp~P = ~{~D~^,~}) by ~A.~%"
	      NAMESPACES (LENGTH NAMESPACES) (LENGTH NAMESPACES)
	      (LOOP FOR NAMESPACE IN NAMESPACES
		    COLLECT (SEND (FIND-OBJECT-NAMED ':NAMESPACE NAMESPACE)
				  ':VALIDATION-TIMESTAMP))
	      USER-ID)
      (DOLIST (HOST HOSTS)
	(LEXPR-FUNCALL FUNCTION STREAM HOST))
      (CLOSE STREAM)
      (SEND STREAM ':TRUENAME))))

(DEFUN GET-HOSTS-FOR-NAMESPACES (NAMESPACES SUPPRESS-ONE-LETTER-NAMES)
  (LET ((HOSTS (LOOP FOR NAMESPACE IN NAMESPACES
		     WITH PROPERTY-LIST = `(:ADDRESS ((,(LOCAL-NETWORK-OF-TYPE :CHAOS) :*)))
		     DO (SETQ NAMESPACE (FIND-OBJECT-NAMED :NAMESPACE NAMESPACE))
		     APPEND (LEXPR-FUNCALL #'FIND-OBJECTS-FROM-PROPERTY-LIST-IN-NAMESPACE
					   :HOST NAMESPACE PROPERTY-LIST)
		     INTO LIST
		     FINALLY (RETURN (SI:ELIMINATE-DUPLICATES (COPYLIST LIST))))))
    (LOOP FOR L ON HOSTS
	  AS HOST = (CAR L)
	  AS PRIMARY-NAME = (SEND HOST :MAIL-NAME :NAMING-CONVENTION :LOCALNET)
	  DO (RPLACA L (LIST PRIMARY-NAME HOST
			     (LET ((OTHER-NAMES (SI:ELIMINATE-DUPLICATES
						  (DEL #'STRING-EQUAL PRIMARY-NAME
						       (LOOP FOR NAME IN (SEND HOST :NAMES)
							     COLLECT (SEND NAME :STRING)))
						  #'EQUAL)))
			       (WHEN SUPPRESS-ONE-LETTER-NAMES
				 (SETQ OTHER-NAMES (DEL-IF #'(LAMBDA (S)
							       (= (STRING-LENGTH S) 1))
							   OTHER-NAMES)))
			       OTHER-NAMES))))
    (SORTCAR HOSTS #'STRING-LESSP)))

)


;;; Accessor for *supported-services*
(defun commonly-supported-services (system-type network-type)
  (let ((services (assoc network-type (cdr (or (assoc system-type *supported-services*)
						(assoc :default *supported-services*))))))
    (when services (cdr services))))

;;; This is an alist of services normally supported by a host of a given operating system type.
(defconst *supported-services*
	  '((:default
	      (:chaos
		(:chaos-status :chaos-simple :chaos-status)
		(:uptime :chaos-simple :uptime-simple))
	      (:internet
		(:file :tcp :tcp-ftp) (:show-users :tcp :ascii-name) (:login :tcp :telnet)))
	    (:lispm
	      (:chaos
		(:chaos-status :chaos-simple :chaos-status) (:show-users :chaos :name)
		(:time :chaos-simple :time-simple) (:uptime :chaos-simple :uptime-simple)
		(:login :chaos :telnet) (:login :chaos :supdup) (:login :chaos :3600-login)
		(:send :chaos :send) (:send :chaos :converse) (:notify :chaos-simple :notify)
		(:namespace :chaos :namespace)
		(:namespace-timestamp :chaos-simple :namespace-timestamp)
		(:lispm-finger :chaos-simple :lispm-finger)
		(:file :chaos :qfile) (:file :chaos :nfile)
		(:configuration :chaos :configuration))
	      (:internet
		(:show-users :tcp :ascii-name) (:time :tcp :time-msb) (:login :tcp :telnet)
		(:send :tcp :smtp) (:file :tcp :tcp-ftp) (:file :tcp :nfile) 
		(:time :udp :time-simple-msb) (:login :tcp :3600-login) (:notify :udp :notify)
		(:namespace :tcp :namespace) (:namespace-timestamp :udp :namespace-timestamp)
		(:configuration :tcp :configuration) (:band-transfer :tcp :band-transfer)))
	    (:its
	      (:chaos
		(:source :chaos :babel) (:echo :chaos :echo) (:file :chaos :qfile)
		(:gensym :chaos-simple :gensym) (:gmsgs :chaos :gmsgs)
		(:mail-to-user :chaos :chaos-mail)
		(:store-and-forward-mail :chaos :chaos-mail) (:show-users :chaos :name)
		(:send :chaos :send) (:login :chaos :supdup) (:login :chaos :telnet)
		(:time :chaos-simple :time-simple)
		(:chaos-status :chaos-simple :chaos-status)))
	    (:tops-20
	      (:chaos
		(:source :chaos :babel) (:bye :chaos :bye) (:file :chaos :qfile)
		(:gmsgs :chaos :gmsgs) (:show-users :chaos :name)
		(:mail-to-user :chaos :chaos-mail)
		(:store-and-forward-mail :chaos :chaos-mail) (:tape :chaos :rtape)
		(:send :chaos :send) (:time :chaos-simple :time-simple)
		(:uptime :chaos-simple :uptime-simple) (:spell :chaos :spell)
		(:chaos-status :chaos-simple :chaos-status) (:login :chaos :supdup)
		(:login :chaos :telnet)))
	    (:tenex
	      (:chaos
		(:source :chaos :babel) (:bye :chaos :bye) (:file :chaos :qfile) 
		(:mail-to-user :chaos :chaos-mail)
		(:store-and-forward-mail :chaos :chaos-mail) (:show-users :chaos :name)
		(:tape :chaos :rtape) (:send :chaos :send)
		(:time :chaos-simple :time-simple) (:uptime :chaos-simple :uptime-simple)
		(:chaos-status :chaos-simple :chaos-status) (:login :chaos :telsup)
		(:login :chaos :telnet)))
	    (:unix
	      (:chaos
		(:file :chaos :qfile) (:time :chaos-simple :time-simple)
		(:mail-to-user :chaos :chaos-mail)
		(:store-and-forward-mail :chaos :chaos-mail) (:show-users :chaos :name)
		(:tape :chaos :rtape) (:send :chaos :send) (:login :chaos :supdup)
		(:login :chaos :telnet) (:namespace :chaos :namespace)
		(:namespace-timestamp :chaos-simple :namespace-timestamp)
		(:uptime :chaos-simple :uptime-simple)
		(:chaos-status :chaos-simple :chaos-status))
	      (:internet
		(:login :tcp :telnet) (:send :tcp :smtp) (:mail-to-user :tcp :smtp)
		(:file :tcp :tcp-ftp)))
	    (:unix42
	      (:chaos
		(:file :chaos :qfile) (:time :chaos-simple :time-simple)
		(:mail-to-user :chaos :chaos-mail)
		(:store-and-forward-mail :chaos :chaos-mail) (:show-users :chaos :name)
		(:tape :chaos :rtape) (:send :chaos :send) (:login :chaos :supdup)
		(:login :chaos :telnet) (:namespace :chaos :namespace)
		(:namespace-timestamp :chaos-simple :namespace-timestamp)
		(:uptime :chaos-simple :uptime-simple)
		(:chaos-status :chaos-simple :chaos-status))
	      (:internet
		(:login :tcp :telnet) (:send :tcp :smtp) (:mail-to-user :tcp :smtp)
		(:file :tcp :tcp-ftp) (:file :udp :nfs)
		(:rpc :tcp :tcp-rpc) (:rpc :udp :udp-rpc)
		(:time :udp :time-simple-msb) (:unix-rexec :tcp :unix-rexec)
		(:x-window-system :tcp :x-window-system)
		(:tape :tcp :unix-rexec) (:hardcopy :tcp :unix-lpd)
		(:printer-queue-control :tcp :unix-lpd)
		(:printer-control :tcp :unix-lpd)))
	    (:vms
	      (:chaos
		(:file :chaos :qfile) (:show-users :chaos :name)
		(:tape :chaos :rtape) (:uptime :chaos-simple :uptime-simple)
		(:time :chaos-simple :time-simple)
		(:chaos-status :chaos-simple :chaos-status) (:login :chaos :telnet)
		(:namespace :chaos :namespace)
		(:namespace-timestamp :chaos-simple :namespace-timestamp)
		(:send :chaos :send) (:mail-to-user :chaos :chaos-mail)))
	    (:vms4
	      (:chaos
		(:file :chaos :qfile) (:show-users :chaos :name)
		(:tape :chaos :rtape) (:uptime :chaos-simple :uptime-simple)
		(:time :chaos-simple :time-simple)
		(:chaos-status :chaos-simple :chaos-status) (:login :chaos :telnet)
		(:send :chaos :send) (:mail-to-user :chaos :chaos-mail))
	      (:dna
		(:file :dna :dap) (:login :dna :cterm) (:time :dna :dna-lmtime)
		(:mail-to-user :dna :dna-mail) (:uptime :dna :dna-lmuptime)
		(:show-users :dna :ascii-name) (:loopback :dna :dna-loopback-mirror)
		(:tape :dna :rtape)))
	    (:vms4.4
	      (:chaos
		(:file :chaos :qfile) (:show-users :chaos :name)
		(:tape :chaos :rtape) (:uptime :chaos-simple :uptime-simple)
		(:time :chaos-simple :time-simple)
		(:chaos-status :chaos-simple :chaos-status) (:login :chaos :telnet)
		(:send :chaos :send) (:mail-to-user :chaos :chaos-mail))
	      (:dna
		(:file :dna :dap) (:login :dna :cterm) (:time :dna :dna-lmtime)
		(:mail-to-user :dna :dna-mail) (:uptime :dna :dna-lmuptime)
		(:show-users :dna :ascii-name) (:loopback :dna :dna-loopback-mirror)
		(:tape :dna :rtape)))
	    (:chaos-gateway 
	      (:chaos
		(:chaos-status :chaos-simple :chaos-status)
		(:packet-gateway :chaos :pup-gateway)
		(:hardcopy :chaos :dover)))
	    (:minits 
	      (:chaos
		(:chaos-status :chaos-simple :chaos-status)
		(:uptime :chaos-simple :uptime-simple)
		(:time :chaos-simple :time-simple)))))

(COMMENT

(DEFCONST *SUPPORTED-PUP-SERVICES*
	  '((:SPRUCE
	     (:HARDCOPY :PUP-DATAGRAM :EFTP)
	     (:HARDCOPY-STATUS :PUP-DATAGRAM :EARS-STATUS))
	    (:IFS
	     (:LOGIN :PUP-BSP :CHAT)
	     (:FILE :PUP-BSP :PUP-FTP)
	     (:TIME :PUP-DATAGRAM :PUP-MISC-SERVICES))
	    (:TFTPSP
	     (:FILE :UDP :TFTP))
	    ))

;;; Convert the MIT HOSTS.TEXT and LMLOCS files into our interchange format.
;;; For now, only do the chaosnet part, the arpanet is controlled by the
;;; NIC and all the other networks we can't talk to (yet).
;;; Additionally, if the host is on the arpanet, its primary name is nicknamed
;;; to the corresponding name in the arpanet namespace, so that the object are
;;; properly shared.
;;; ALLOWED-PREFIXES is a list of strings that can start the primary name.  Give
;;; ("") to get everything, normally this would be ("MIT-").
;;; DESTINATION-NAMESPACE is put in the file attribute list.
(DEFUN TRANSLATE-HOSTS.TEXT-FILE (&KEY INPUT-HOST-FILE INPUT-LMLOCS-FILE OUTPUT-FILE
				  ALLOWED-PREFIXES DESTINATION-NAMESPACE
				  SHORT-NAMES FILE-CONTROL-LIFETIMES
				  SERVER-MACHINES TAPE-LISP-MACHINES
				  HOSTS-WITH-PRINTERS HOSTS-WITH-KANJI-TABLETS
				  HOSTS-WITH-PERIPHERALS PUP-HOSTS
				  HOSTS-WITH-OTHER-ENTRIES
				  &AUX HOSTS HOSTS-TRUENAME LMLOCS-TRUENAME)
  (OR INPUT-HOST-FILE (SETQ INPUT-HOST-FILE "SYS: SITE; HOSTS TEXT >"))
  (OR INPUT-LMLOCS-FILE (SETQ INPUT-LMLOCS-FILE "SYS: SITE; LMLOCS LISP >"))
  (OR OUTPUT-FILE (SETQ OUTPUT-FILE (FORMAT NIL "SYS:SITE;~A-HOSTS TEXT >" SITE-NAME)))
  (OR ALLOWED-PREFIXES (SETQ ALLOWED-PREFIXES (LIST (STRING-APPEND SITE-NAME #/-))))
  (OR DESTINATION-NAMESPACE (SETQ DESTINATION-NAMESPACE (STRING SI:SITE-NAME)))
  (WITH-OPEN-FILE (INPUT-STREAM INPUT-HOST-FILE)
    (SETQ HOSTS-TRUENAME (SEND INPUT-STREAM ':TRUENAME))
    (DO ((LINE) (EOF)
	 (I) (J)
	 (NI) (NJ)
	 (HOSTL) (DELIM))
	(EOF)
      (MULTIPLE-VALUE (LINE EOF)
	(FUNCALL INPUT-STREAM ':LINE-IN NIL))
      (MULTIPLE-VALUE (I J)
	(PARSE-HOSTS.TEXT-TOKEN LINE (IF (STRING-EQUAL LINE ";LM " 0 0 4 4) 4 0)))
      (COND ((AND I (STRING-EQUAL LINE "HOST" I 0 J NIL))
	     ;; Host name
	     (MULTIPLE-VALUE (NI NJ)
	       (PARSE-HOSTS.TEXT-TOKEN LINE (1+ J)))
	     (MULTIPLE-VALUE (I J DELIM)
	       (PARSE-HOSTS.TEXT-TOKEN LINE (1+ NJ)))
	     (SETQ HOSTL (NCONS (SUBSTRING LINE NI NJ)))
	     (IF (CHAR= DELIM #/[)
		 (DO ((L NIL)
		      (I1) (J1))
		     ((CHAR= DELIM #/])
		      (SETQ J (1+ J))		;,
		      (NREVERSE L))
		   (MULTIPLE-VALUE (I1 J1 DELIM)
		     (PARSE-HOSTS.TEXT-TOKEN LINE (1+ J)))
		   (IF (CHAR= DELIM #\SP)
		       (MULTIPLE-VALUE (I J DELIM)
			 (PARSE-HOSTS.TEXT-TOKEN LINE (1+ J1)))
		       (SETQ I I1 J J1 J1 I1))
		   (ADD-HOST-TABLE-ADDRESS LINE I1 J1 I J HOSTL))
		 (LET ((I1 I) (J1 J))
		   (IF (CHAR= DELIM #\SP)
		       (MULTIPLE-VALUE (I J)
			 (PARSE-HOSTS.TEXT-TOKEN LINE (1+ J)))
		       (SETQ I I1 J J1 J1 I1))
		   (ADD-HOST-TABLE-ADDRESS LINE I1 J1 I J HOSTL)))
	     (COND ((LOOP FOR PREFIX IN ALLOWED-PREFIXES
			  THEREIS (%STRING-EQUAL (CAR HOSTL) 0 PREFIX 0
						 (STRING-LENGTH PREFIX)))
		    (PUSH HOSTL HOSTS)
		    (DOTIMES (K 2)
		      (MULTIPLE-VALUE (I J DELIM)
			(PARSE-HOSTS.TEXT-TOKEN LINE (1+ J))))
		    (PUTPROP HOSTL (SUBSTRING LINE I J) ':SYSTEM-TYPE)
		    (MULTIPLE-VALUE (I J DELIM)
		      (PARSE-HOSTS.TEXT-TOKEN LINE (1+ J)))
		    (PUTPROP HOSTL (SUBSTRING LINE I J) ':MACHINE-TYPE)
		    (MULTIPLE-VALUE (I J DELIM)
		      (PARSE-HOSTS.TEXT-TOKEN LINE (1+ J)))
		    (OR I (SETQ DELIM -1))
		    (AND (CHAR= DELIM #/[)
			 (DO ((NICKNS NIL))
			     ((CHAR= DELIM #/])
			      (PUTPROP HOSTL (NREVERSE NICKNS) ':NICKNAME))
			   (MULTIPLE-VALUE (I J DELIM)
			     (PARSE-HOSTS.TEXT-TOKEN LINE (1+ J)))
			   (PUSH (SUBSTRING LINE I J) NICKNS)))))))))
  (SETQ HOSTS (NREVERSE HOSTS))
  (WITH-OPEN-FILE (INPUT-STREAM INPUT-LMLOCS-FILE)
    (SETQ LMLOCS-TRUENAME (SEND INPUT-STREAM ':TRUENAME))
    (LOOP FOR (NAME PRETTY-NAME FINGER-LOCATION LOCATION)
	  IN (SECOND (THIRD (READ INPUT-STREAM)))
	  AS ELEM = (ASSOC NAME HOSTS)
	  WHEN ELEM
	  DO (NCONC ELEM `(:PRETTY-NAME ,PRETTY-NAME
			   :FINGER-LOCATION ,FINGER-LOCATION
			   :LOCATION ,LOCATION))))
  (WITH-OPEN-FILE (OUTPUT-STREAM OUTPUT-FILE ':DIRECTION ':OUTPUT)
    (FORMAT OUTPUT-STREAM "~
;;; -*- Mode: Text; Network-Namespace: ~A -*-
;;; *** THIS FILE WAS AUTOMATICALLY GENERATED BY A PROGRAM, DO NOT EDIT IT ***
;;; Host table made from ~A and ~A by ~A at ~\DATIME\~%"
	    DESTINATION-NAMESPACE HOSTS-TRUENAME LMLOCS-TRUENAME USER-ID)
    (LOOP FOR HOSTL IN HOSTS DO
	  ;; MIT-MC is MIT|MC with MIT-MC as a nickname.
	  ;; MIT-LISPM-1 is MIT|CADR-1, with MIT-LISPM-1 as a nickname and LM1 as a
	  ;; short-name (ok for output).  MIT|APIARY-1 is short-name AP1.
	  (LOOP FOR NICKNAMES ON (GET HOSTL ':NICKNAME)
		AS NAME = (CAR NICKNAMES)
		WITH IDX
		DO (COND ((OR (AND (SETQ IDX (STRING-SEARCH-CHAR #/- (CAR HOSTL)))
				   (%STRING-EQUAL (CAR HOSTL) (1+ IDX) NAME 0 NIL)
				   (%STRING-EQUAL (CAR HOSTL) 0 DESTINATION-NAMESPACE 0 IDX))
			      (AND (%STRING-EQUAL (CAR HOSTL) 0 "MIT-LISPM-" 0 #o12)
				   (%STRING-EQUAL NAME 0 "CADR-" 0 5)))
			  (PUTPROP HOSTL NAME ':BETTER-NAME)
			  (SETF (CAR NICKNAMES) (CAR HOSTL)))
			 ((OR (AND (%STRING-EQUAL (CAR HOSTL) 0 "MIT-LISPM-" 0 #o12)
				   (%STRING-EQUAL NAME 0 "LM" 0 2))
			      (AND (%STRING-EQUAL (CAR HOSTL) 0 "MIT-APIARY-" 0 #o13)
				   (%STRING-EQUAL NAME 0 "AP" 0 2)
				   (%STRING-EQUAL (CAR HOSTL) #o13 NAME 2 NIL)))
			  (PUSH NAME (GET HOSTL ':SHORT-NAME))
			  (SETF (CAR NICKNAMES) NIL))))
	  (LOOP FOR (SHORT-NAME NAME) IN SHORT-NAMES
		WHEN (OR (EQUAL NAME (CAR HOSTL))
			 (EQUAL NAME (GET HOSTL ':BETTER-NAME))
			 (MEMBER NAME (GET HOSTL ':NICKNAME))
			 (MEMBER NAME (GET HOSTL ':SHORT-NAME)))
		DO
		(SETF (GET HOSTL ':SHORT-NAME)
		      (NCONC (GET HOSTL ':SHORT-NAME) (NCONS SHORT-NAME)))
		(SETF (GET HOSTL :NICKNAME)
		      (DEL #'STRING-EQUAL SHORT-NAME (GET HOSTL :NICKNAME))))
	  (LOOP FOR (NAME TIME) IN FILE-CONTROL-LIFETIMES
		WHEN (OR (EQUAL NAME (CAR HOSTL))
			 (EQUAL NAME (GET HOSTL ':BETTER-NAME))
			 (MEMBER NAME (GET HOSTL ':NICKNAME))
			 (MEMBER NAME (GET HOSTL ':SHORT-NAME)))
		RETURN (PUTPROP HOSTL (FORMAT NIL "~D" TIME) ':FILE-CONTROL-LIFETIME))
	  (LOOP FOR NAME IN SERVER-MACHINES
		WHEN (OR (EQUAL NAME (CAR HOSTL))
			 (EQUAL NAME (GET HOSTL ':BETTER-NAME))
			 (MEMBER NAME (GET HOSTL ':NICKNAME))
			 (MEMBER NAME (GET HOSTL ':SHORT-NAME)))
		RETURN (PUTPROP HOSTL "YES" ':SERVER-MACHINE))
	  (FORMAT OUTPUT-STREAM "HOST ~A~%SITE ~A~%"
		  (OR (GET HOSTL ':BETTER-NAME) (CAR HOSTL))
		  DESTINATION-NAMESPACE)
	  (WHEN (GETL HOSTL '(:ARPANET :LCS))
	    (FORMAT OUTPUT-STREAM "NICKNAME ARPANET|~A~%" (CAR HOSTL)))
	  (LOOP FOR (IND VAL) ON (CDR HOSTL) BY 'CDDR
		DO (SELECTQ IND
		     ((:NICKNAME :SHORT-NAME)
		      (SETQ VAL (SORT VAL #'(LAMBDA (X Y)
					      (< (STRING-LENGTH X) (STRING-LENGTH Y)))))
		      (LOOP FOR NAME IN VAL
			    WHEN NAME
			    DO (FORMAT OUTPUT-STREAM "~A ~A~%" IND NAME)))
		     ((:SYSTEM-TYPE :MACHINE-TYPE
		       :SERVER-MACHINE :FILE-CONTROL-LIFETIME)
		      (FORMAT OUTPUT-STREAM "~A ~A~%" IND VAL))
		     ((:PRETTY-NAME :FINGER-LOCATION)
		      (FORMAT OUTPUT-STREAM "~A ~S~%" IND VAL))
		     ((:LOCATION)
		      (FORMAT OUTPUT-STREAM "LOCATION ~A ~D~%" (FIRST VAL) (SECOND VAL)))
		     ((:CHAOS)
		      (LOOP FOR ADDR IN VAL
			    DO (FORMAT OUTPUT-STREAM "ADDRESS CHAOS ~O~%" ADDR)))
		     ((:LCS)
		      (LOOP FOR ADDR IN VAL
			    FOR I = (STRING-SEARCH-CHAR #// ADDR)
			    FOR SN = (PARSE-NUMBER ADDR 0 I 8 T)
			    FOR HN = (PARSE-NUMBER ADDR (1+ I) NIL 8 T)
			    DO (FORMAT OUTPUT-STREAM
				       "ADDRESS ARPANET|ARPANET 18.~D.0.~D~%" SN HN))
		      (WHEN (REST1 VAL)
			(FORMAT OUTPUT-STREAM "SERVICE GATEWAY IP INTERNET-GATEWAY~%")))
		     ((:ARPANET))))
	  (WHEN (MEM #'STRING-EQUAL (GET HOSTL ':SYSTEM-TYPE) '(:ITS :TENEX))
	    (FORMAT OUTPUT-STREAM "FILE-CONTROL-LIFETIME 108000~%"))
	  (LET ((SERVICES (CDR (OR (ASS #'STRING-EQUAL (GET HOSTL ':SYSTEM-TYPE)
					*SUPPORTED-SERVICES*)
				   (ASSQ ':DEFAULT *SUPPORTED-SERVICES*)))))
	    (WHEN (GET HOSTL ':CHAOS)
	      (LOOP FOR SERVICE IN (REST1 (ASSQ :CHAOS SERVICES))
		    DOING (FORMAT OUTPUT-STREAM "SERVICE ~A ~A ~A~%"
				  (FIRST SERVICE) (SECOND SERVICE) (THIRD SERVICE))))
	    (WHEN (GET HOSTL ':LCS)
	      (LOOP FOR SERVICE IN (REST1 (ASSQ :INTERNET SERVICES))
		    DOING (FORMAT OUTPUT-STREAM "SERVICE ~A ~A ~A~%"
				  (FIRST SERVICE) (SECOND SERVICE) (THIRD SERVICE)))))
	  (LOOP FOR (NAME ADDR) IN PUP-HOSTS
		WHEN (OR (EQUAL NAME (CAR HOSTL))
			 (EQUAL NAME (GET HOSTL ':BETTER-NAME))
			 (MEMBER NAME (GET HOSTL ':NICKNAME))
			 (MEMBER NAME (GET HOSTL ':SHORT-NAME)))
		DO
		(FORMAT OUTPUT-STREAM "ADDRESS PUP ~A~%" ADDR)
		(LET ((SERVICES (CDR (OR (ASS #'STRING-EQUAL (GET HOSTL ':SYSTEM-TYPE)
					      *SUPPORTED-PUP-SERVICES*)
					 (ASSQ ':DEFAULT *SUPPORTED-PUP-SERVICES*)))))
		  (LOOP FOR SERVICE IN SERVICES
			DOING (FORMAT OUTPUT-STREAM "SERVICE ~A ~A ~A~%"
				      (FIRST SERVICE) (SECOND SERVICE) (THIRD SERVICE))))
		AND RETURN)
	  (LOOP FOR NAME IN TAPE-LISP-MACHINES
		WHEN (OR (EQUAL NAME (CAR HOSTL))
			 (EQUAL NAME (GET HOSTL ':BETTER-NAME))
			 (MEMBER NAME (GET HOSTL ':NICKNAME))
			 (MEMBER NAME (GET HOSTL ':SHORT-NAME)))
		RETURN (FORMAT OUTPUT-STREAM "SERVICE TAPE CHAOS RTAPE~%"))
	  (LOOP FOR (HOST PRINTER-OPTION-LIST) IN HOSTS-WITH-PRINTERS
		WHEN (OR (EQUAL HOST (CAR HOSTL))
			 (EQUAL HOST (GET HOSTL ':BETTER-NAME))
			 (MEMBER HOST (GET HOSTL ':NICKNAME))
			 (MEMBER HOST (GET HOSTL ':SHORT-NAME)))
		DO
		(FORMAT OUTPUT-STREAM "SPOOLED-PRINTER ~A~{ ~A ~S~}~%"
			(CAR PRINTER-OPTION-LIST) (CDR PRINTER-OPTION-LIST))
		(SELECTOR  (GET PRINTER-OPTION-LIST ':PROTOCOL) STRING-EQUAL
		  ("LGP" (FORMAT OUTPUT-STREAM "SERVICE HARDCOPY CHAOS LGP~%~
                                                SERVICE HARDCOPY-STATUS CHAOS LGP-QUEUE~%"))
		  ("PRINTER" (FORMAT OUTPUT-STREAM "SERVICE HARDCOPY CHAOS PRINTER~%"))))
	  (LOOP FOR (HOST . OPTION-LIST) IN HOSTS-WITH-PERIPHERALS
		WHEN (OR (EQUAL HOST (CAR HOSTL))
			 (EQUAL HOST (GET HOSTL ':BETTER-NAME))
			 (MEMBER HOST (GET HOSTL ':NICKNAME))
			 (MEMBER HOST (GET HOSTL ':SHORT-NAME)))
		RETURN (LOOP FOR (TYPE . OPTIONS) IN OPTION-LIST
			     DO (FORMAT OUTPUT-STREAM
					"PERIPHERAL ~A~{ ~A ~S~}~%" TYPE OPTIONS)))
	  (LOOP FOR (HOST . OPTION-LIST) IN HOSTS-WITH-KANJI-TABLETS
		WHEN (OR (EQUAL HOST (CAR HOSTL))
			 (EQUAL HOST (GET HOSTL ':BETTER-NAME))
			 (MEMBER HOST (GET HOSTL ':NICKNAME))
			 (MEMBER HOST (GET HOSTL ':SHORT-NAME)))
		RETURN (LOOP FOR (IND VAL) ON OPTION-LIST BY 'CDDR
			     INITIALLY (FORMAT OUTPUT-STREAM "PERIPHERAL KANJI-TABLET")
			     DO (FORMAT OUTPUT-STREAM
					(TYPECASE VAL
					  (:FIXNUM " ~A ~D")	; e.g. BAUD 1200, not BAUD 2260
					  (:SYMBOL (SELECTQ VAL
						     ((T) " ~A YES")
						     ((NIL) " ~A NO")
						     (OTHERWISE " ~A ~A")))
					  (OTHERWISE " ~A ~A"))
					IND VAL)
			     FINALLY (FORMAT OUTPUT-STREAM "~%")))
	  (LOOP FOR (HOST . OPTION-LIST) IN HOSTS-WITH-OTHER-ENTRIES
		WHEN (OR (EQUAL HOST (CAR HOSTL))
			 (EQUAL HOST (GET HOSTL ':BETTER-NAME))
			 (MEMBER HOST (GET HOSTL ':NICKNAME))
			 (MEMBER HOST (GET HOSTL ':SHORT-NAME)))
		RETURN (LOOP FOR LINE IN OPTION-LIST
			     DO (SEND OUTPUT-STREAM :LINE-OUT LINE)))
	  (TERPRI OUTPUT-STREAM))
    (CLOSE OUTPUT-STREAM)
    (SEND OUTPUT-STREAM ':TRUENAME)))

(DEFUN PARSE-HOSTS.TEXT-TOKEN (STRING &OPTIONAL (START 0) END)
  (OR END (SETQ END (STRING-LENGTH STRING)))
  (DO ((IDX START (1+ IDX))
       (SIDX) (CH))
      (( IDX END)
       (VALUES SIDX IDX -1))
    (SETQ CH (AREF STRING IDX))
    (OR SIDX
	(MEMQ CH '(#\SP #\TAB))
	(SETQ SIDX IDX))
    (AND SIDX
	 (MEMQ CH '(#/, #\SP #\TAB #/[ #/]))
	 (RETURN (VALUES SIDX IDX CH)))))

(DEFUN ADD-HOST-TABLE-ADDRESS (LINE NET-START NET-END ADDRESS-START ADDRESS-END HOSTL)
  (LET ((SYMBOL (IF (= NET-START NET-END) ':ARPANET
		    (INTERN (SUBSTRING LINE NET-START NET-END) SI:PKG-KEYWORD-PACKAGE))))
    (SETF (GET HOSTL SYMBOL)
	  (NCONC (GET HOSTL SYMBOL)
		 (NCONS (SUBSTRING LINE ADDRESS-START ADDRESS-END))))))

)


(defun make-namespace-file-name (base-file site-and-namespace-name type)
  (let* ((host-type (send (send base-file :host) :system-type))
	 (name (or (make-namespace-file-name-1 host-type type)
		   (make-namespace-file-name-1 ':default type))))
    (if (atom name)
	(send base-file ':new-name (string-append site-and-namespace-name name))
	(send base-file :new-pathname
	      :name (car name) :type (cadr name)
	      :directory (append (send base-file :directory)
				 (ncons (string site-and-namespace-name)))))))


(defconst *namespace-file-name-system-alist*
  '((:default
     (:log "-NAMESPACE-LOG")			;e.g., >SYS>SITE>SCRC-NAMESPACE-LOG.TEXT
     (:changes "-NAMESPACE-CHANGES")
     (:descriptor "-NAMESPACE")
     (:objects "-OBJECTS")
     (:hosts "-HOSTS")
     (:users "-USERS"))
    (:unix
     (:log "-LOG")
     (:changes "-CHG")
     (:descriptor "-NS")
     (:objects "-OBJS")
     (:hosts "-HSTS")
     (:users "-USRS"))
    (:vms
     (:log ("NAMESPACE" "LOG"))			;e.g., [SYS.SITE.SCRC]NAMESPACE.LOG
     (:changes ("CHANGES" "TXT"))
     (:descriptor ("NAMEDESCR" "TXT"))
     (:objects ("NAMESPACE" "TXT"))
     (:hosts ("NAMEHOSTS" "TXT"))
     (:users ("NAMEUSERS" "TXT")))
    ))

(defun make-namespace-file-name-1 (system-type file-type)
  (let ((entry (assq system-type *namespace-file-name-system-alist*)))
    (when entry
      (let ((subentry (assq file-type (cdr entry))))
	(when subentry
	  (cadr subentry))))))


(defun get-distribution-local-host ()
  (make-distribution-host-internal
    "DIS-LOCAL-HOST"
    :lispm
    (local-machine-type)
    (loop for entry in *parsed-primary-network-data*
	  as net = (neti:local-network-of-type (primary-address-network-type entry) nil)
	  as address = (primary-address-address-string entry)
	  as interface = (primary-address-interface-name entry)
	  when net
	    collect (list net address (when interface (list interface))))
    (send *primary-network* :default-services)))


(defun make-distribution-host-internal (name
					system-type machine-type addresses services)
  (add-or-change-object
    :host (parse-name name nil *distribution-namespace*)
    `(
      :site ,*distribution-site*
      :machine-type ,machine-type
      :system-type ,system-type
      :address ,addresses
      :service ,services)
    *distribution-namespace*))

(defun make-distribution-host (name &key (system-type :lispm) (machine-type :|3600|) services
			       chaos-address
			       (chaos-network
				 (or (and (eq (send *primary-network* :type) :chaos)
					  *primary-network*)
				     (local-network-of-type :chaos nil)))
			       internet-address
			       (internet-network
				 (or (and (eq (send *primary-network* :type) :internet)
					  *primary-network*)
				     (local-network-of-type :internet nil))))
  (unless (or (and chaos-address chaos-network)
	      (and internet-address internet-network))
    (error "MAKE-DISTRIBUTION-HOST must be called with a network and address."))
  ;; add all the standard supported services for this system-type and network
  (when (and chaos-network chaos-address)
    (setq services (append services (commonly-supported-services system-type :chaos))))
  (when (and internet-network internet-address)
    (setq services (append services (commonly-supported-services system-type :internet))))
  (setq services (cl:remove-duplicates services :test #'equal))
  (let ((addresses (when (and chaos-address chaos-network)
		     (list (list chaos-network chaos-address)))))
    (when (and internet-address internet-network)
      (push (list internet-network internet-address) addresses))
    (make-distribution-host-internal name system-type machine-type addresses services)))
