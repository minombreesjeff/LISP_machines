;;; -*- Mode: LISP; Package: TELNET; Base: 8 -*-
;;; Lisp machine network virtual terminals
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; Special Variables

;;; The unix supdup server ignores the overstriking option.
(DEFCONST *SYSTEM-TYPES-THAT-REFUSE-OVERSTRIKING* '(:UNIX :UNIX42 :VMS :VMS4 :VMS4.4))

;;; WAITS because its supdup server refuses to work otherwise
;;; Multics because its Chaosnet interface is slow and it is said to be desirable
;;; to minimize the number of characters transmitted
;;; Everything else is not here because it makes Emacs slower
(DEFVAR *SYSTEM-TYPES-THAT-REQUIRE-CHARACTER-INSERT* '(:WAITS :MULTICS))

(DEFCONST *NVT-OVERSTRIKE-DEFAULT* T "Controls whether overstriking is permitted by default.")

(DEFVAR *COMMAND-TABLE*
	(CP:MAKE-COMMAND-TABLE "Telnet"
			       :INHERIT-FROM '("standard arguments"
					       "colon full command"
					       "unshifted arguments")))

(DEFVAR *TERMINAL-SIMULATOR-TYPES* NIL)

(DEFVAR *SUPDUP-%TOCID* NIL)

;;; These are bound by the Terminal processes.

(DEFVAR *TERMINAL-STREAM*)
(DEFVAR *TERMINAL-SCREEN*)
(DEFVAR *VIEWPORT-STREAM*)

;;; Macros

(DEFMACRO LOCK-OUTPUT ((WINDOW) &BODY BODY)
  `(PROCESS:WITH-LOCK (,(IF (EQ WINDOW 'SELF)
			    'NETWORK-OUTPUT-LOCK
			    `(NVT-WINDOW-NETWORK-OUTPUT-LOCK ,WINDOW)))
     ,@BODY))

;;; Utilities

(DEFUN PREFILL-ARRAY (LENGTH CONTENTS)
  (LOOP WITH ARRAY = (MAKE-ARRAY LENGTH)
	FOR I FROM 0
	FOR X IN CONTENTS
	DO (SETF (AREF ARRAY I) X)
	FINALLY (RETURN ARRAY)))

;;; Filter Streams

;;; These are like pipes, except that it is assumed that no TYO of several characters
;;; will cause a TYI back in the middle.
(DEFFLAVOR FILTER-STREAM
	(INPUT-STREAM
	 OUTPUT-STREAM
	 (UNTYIED-CHAR NIL))
	()
  :SETTABLE-INSTANCE-VARIABLES
  (:REQUIRED-METHODS :FILTER))

(DEFMETHOD (:LISTEN FILTER-STREAM) ()
  (OR UNTYIED-CHAR (SEND INPUT-STREAM ':LISTEN)))

(DEFMETHOD (:TYI-NO-HANG FILTER-STREAM) (&OPTIONAL EOF)
  (LOOP UNTIL UNTYIED-CHAR
	FOR CH = (SEND INPUT-STREAM ':TYI-NO-HANG EOF)
	WHILE CH
	DO (SETQ UNTYIED-CHAR (SEND SELF ':FILTER CH))
	FINALLY (RETURN (PROG1 UNTYIED-CHAR (SETQ UNTYIED-CHAR NIL)))))

(DEFMETHOD (:TYI FILTER-STREAM) (&OPTIONAL EOF)
  (LOOP FOR CH = (SEND SELF ':TYI-NO-HANG EOF)
	UNTIL CH
	DO (PROCESS-WAIT "Filter" #'SEND SELF ':LISTEN)
	FINALLY (RETURN CH)))

(DEFMETHOD (:UNTYI FILTER-STREAM) (CH)
  (SETQ UNTYIED-CHAR CH))

(DEFMETHOD (:TYO FILTER-STREAM) (CH)
  (WHEN UNTYIED-CHAR
    (SEND OUTPUT-STREAM ':TYO (PROG1 UNTYIED-CHAR (SETQ UNTYIED-CHAR NIL))))
  (COND ((SETQ CH (SEND SELF ':FILTER CH))
	 (SEND OUTPUT-STREAM ':TYO CH))))

(DEFMETHOD (:FORCE-OUTPUT FILTER-STREAM) ()
  (SEND OUTPUT-STREAM ':FORCE-OUTPUT))

(DEFMETHOD (:SETUP FILTER-STREAM) ())
(DEFMETHOD (:RESET FILTER-STREAM) ())

(DEFFLAVOR VIEWPORT-STREAM
	()
	(DW::NEW-COORDINATES-STREAM)
  )

(DEFMETHOD (:INIT VIEWPORT-STREAM :AFTER) (IGNORE)
  (SEND SELF :RECOMPUTE-SIZE-AND-POSITION))

(DEFMETHOD (:RECOMPUTE-SIZE-AND-POSITION VIEWPORT-STREAM) ()
  (MULTIPLE-VALUE-BIND (LEFT TOP RIGHT BOTTOM)
      (SEND DW::STREAM :VISIBLE-CURSORPOS-LIMITS)
    (SETQ DW::X-OFFSET LEFT DW::Y-OFFSET TOP
	  DW::WIDTH (- RIGHT LEFT) DW::HEIGHT (- BOTTOM TOP))))

(DEFMETHOD (:TERPRI-AND-WRAP VIEWPORT-STREAM) ()
  (MULTIPLE-VALUE-BIND (NIL Y)
      (SEND SELF :READ-CURSORPOS :CHARACTER)
    (MULTIPLE-VALUE-BIND (NIL HEIGHT)
	(SEND SELF :SIZE-IN-CHARACTERS)
      (SEND SELF :SET-CURSORPOS 0 (MOD (1+ Y) HEIGHT) :CHARACTER)))
  (SEND SELF :CLEAR-REST-OF-LINE))
;;; We don't want inherited version of this.  We only use the coordinates for actual
;;; cursor movement.
(DEFMETHOD (:TYO VIEWPORT-STREAM) (CHAR)
  (SEND DW::STREAM :TYO CHAR))

(DEFMETHOD (:CLEAR-WINDOW VIEWPORT-STREAM) ()
  (SEND SELF :HOME-CURSOR)
  (SEND SELF :CLEAR-REST-OF-WINDOW))

(COMPILE-FLAVOR-METHODS VIEWPORT-STREAM)

;;; The main windows

;;; The terminal screen is the pane which represents the screen of the virtual terminal.
;;; (Actually, it isn't a pane any more.  I sure hope this works. --Hornig)

(DEFFLAVOR TERMINAL-SCREEN
	((OVERSTRIKE-P T)			;overstriking or replacing
	 (CHARACTER-ATTRIBUTE NIL)		;Special output attributes.
	 (RECORD-OUTPUT-P T)			;Can disable for speed
	 (WALLPAPERING NIL)			;T if copying to a file
	 (WALLPAPER-FILE NIL)			;file to copy to
	 VIEWPORT-STREAM			;for graphics and other such operations
	 (ECHO-AREA-POSITION 0)			;for SUDS
	 (OUTPUT-PROCESS-TICK 0))		;for synchronization after changing options
	(#|TV:PANE-MIXIN|#
	 TV:STREAM-MIXIN TV:SELECT-MIXIN TV:GRAPHICS-MIXIN TV:MINIMUM-WINDOW)
  (:DEFAULT-INIT-PLIST :SAVE-BITS T :DEEXPOSED-TYPEOUT-ACTION :NOTIFY)
  :SETTABLE-INSTANCE-VARIABLES)

(DEFMETHOD (:INIT TERMINAL-SCREEN :AFTER) (IGNORE)
  (SEND SELF :SET-ASYNCHRONOUS-CHARACTERS NIL)
  (SETQ VIEWPORT-STREAM (MAKE-INSTANCE 'VIEWPORT-STREAM :STREAM SELF)))

(DEFMETHOD (:CHANGE-OF-SIZE-AND-MARGINS TERMINAL-SCREEN :AFTER) (&REST IGNORE)
  (SEND VIEWPORT-STREAM :RECOMPUTE-SIZE-AND-POSITION))

(DEFMETHOD (:NEW-SCROLL-POSITION TERMINAL-SCREEN :AFTER) ()
  (SEND VIEWPORT-STREAM :RECOMPUTE-SIZE-AND-POSITION))

(DEFMETHOD (:OPEN-WALLPAPER-FILE TERMINAL-SCREEN) (FILE)
  (SETF WALLPAPER-FILE FILE)
  (SETF WALLPAPERING T))

(DEFMETHOD (:CLOSE-WALLPAPER-FILE TERMINAL-SCREEN) ()
  (WHEN WALLPAPERING
    (SETQ WALLPAPERING NIL)
    (SEND WALLPAPER-FILE :CLOSE)))

(DEFUN-IN-FLAVOR (WALLPAPER-OPERATION TERMINAL-SCREEN) (MESSAGE &REST ARGS)
  (UNLESS (CATCH-ERROR-RESTART (ERROR "Close wallpaper file.")
	    (LETF ((WALLPAPERING NIL))
	      (LEXPR-SEND WALLPAPER-FILE MESSAGE ARGS))
	    T)
    (SEND SELF :CLOSE-WALLPAPER-FILE)))

(DEFSUBST-IN-FLAVOR (TYO-IF-WALLPAPERING TERMINAL-SCREEN) (CHAR)
  (WHEN WALLPAPERING
    (WALLPAPER-OPERATION :TYO CHAR)))

(DEFMACRO WITH-CHARACTER-ATTRIBUTE (&BODY BODY)
  `(SELECTQ CHARACTER-ATTRIBUTE
      ((NIL) . ,BODY)
      ((:BOLD) (WITH-CHARACTER-FACE (:BOLD SELF)
		 . ,BODY))
      (OTHERWISE
       (MULTIPLE-VALUE-BIND (START-X START-Y)
	   (SEND SELF :READ-CURSORPOS)
	 (PROGN . ,BODY)
	 (MULTIPLE-VALUE-BIND (END-X END-Y)
	     (SEND SELF :READ-CURSORPOS)
	   (WHEN (AND (= END-Y START-Y) (> END-X START-X))
	     (MULTIPLE-VALUE-BIND (HEIGHT OFFSET)
		 (SELECTQ CHARACTER-ATTRIBUTE
		   (:UNDERLINE
		    (VALUES 1 (SEND SELF :CURRENT-BASELINE)))
		   (:REVERSE-VIDEO
		    (VALUES (SEND SELF :CURRENT-LINE-HEIGHT) 0)))
	       (WHEN HEIGHT
		 (SEND SELF :DRAW-RECTANGLE (- END-X START-X) HEIGHT START-X (+ START-Y OFFSET)
		       :FLIP)))))))))

(DEFWHOPPER (:TYO TERMINAL-SCREEN) (CH &OPTIONAL IGNORE)
  (TYO-IF-WALLPAPERING CH)
  (IF (NOT (GRAPHIC-CHAR-P CH))
      (CONTINUE-WHOPPER CH)
    (UNLESS OVERSTRIKE-P
      (SEND SELF :CLEAR-CHAR))
    (WITH-CHARACTER-ATTRIBUTE
      (CONTINUE-WHOPPER CH))))

(DEFWHOPPER (:STRING-OUT TERMINAL-SCREEN) (STRING &OPTIONAL (FROM 0) TO)
  (WHEN WALLPAPERING
    (WALLPAPER-OPERATION :STRING-OUT STRING FROM TO))
  (WHEN (NOT OVERSTRIKE-P)
    (MULTIPLE-VALUE-BIND (CUR-X CUR-Y)
	(SEND SELF :READ-CURSORPOS)
      (MULTIPLE-VALUE-BIND (END-X END-Y POS)
	  (SEND SELF :COMPUTE-MOTION STRING FROM TO CUR-X CUR-Y)
	(WHEN POS
	  (MULTIPLE-VALUE (END-X END-Y POS)
	    (SEND SELF :COMPUTE-MOTION STRING POS TO 0 0)))
	(SEND SELF :CLEAR-BETWEEN-CURSORPOSES CUR-X CUR-Y END-X END-Y))))
  (WITH-CHARACTER-ATTRIBUTE
    (CONTINUE-WHOPPER STRING FROM TO)))

(DEFWHOPPER (:MORE-EXCEPTION TERMINAL-SCREEN) ()
  (LETF ((WALLPAPERING NIL))
    (CONTINUE-WHOPPER)))

(DEFMETHOD (:FORCE-OUTPUT TERMINAL-SCREEN) ())

(DEFMETHOD (:NEW-OUTPUT-PROCESS-TICK TERMINAL-SCREEN) ()
  (INCF OUTPUT-PROCESS-TICK))

(DEFMETHOD (:SET-ECHO-POSITION TERMINAL-SCREEN) (NEW-Y)
  (SETF ECHO-AREA-POSITION NEW-Y)
  (MULTIPLE-VALUE-BIND (NIL Y)
      (SEND SELF :READ-CURSORPOS)
    (WHEN (< Y NEW-Y)
      (SEND SELF :HOME-CURSOR))))

(DEFMETHOD (:HOME-CURSOR TERMINAL-SCREEN) ()
  (SEND SELF :SET-CURSORPOS 0 ECHO-AREA-POSITION))

(DEFMETHOD (:NEWLINE TERMINAL-SCREEN) (&OPTIONAL KIND)
  (TYO-IF-WALLPAPERING #\NEWLINE)
  (LETF ((WALLPAPERING NIL))
    (CL:CASE KIND
      (:WRAP
	(MULTIPLE-VALUE-BIND (NIL Y)
	    (SEND VIEWPORT-STREAM :READ-CURSORPOS :CHARACTER)
	  (MULTIPLE-VALUE-BIND (NIL HEIGHT)
	      (SEND VIEWPORT-STREAM :SIZE-IN-CHARACTERS)
	    (SEND VIEWPORT-STREAM :SET-CURSORPOS 0 (MOD (1+ Y) HEIGHT) :CHARACTER)))
	(SEND VIEWPORT-STREAM :CLEAR-REST-OF-LINE))
      (:SCROLL-AT-END
	;; Do not output to the viewport stream: we want to scroll at the end of the page.
	;; But we don't want the clear-eol that newline in the middle of the screen gives.
	;; That screws up some screen editors' cursor optimization.  But we do need that
	;; clear-eol when in end-of-page-mode wrap at the end of the virtual screen.
	(MULTIPLE-VALUE-BIND (NIL Y)
	(SEND SELF :READ-CURSORPOS)
	  (INCF Y (SEND SELF :LINE-HEIGHT))
	  (IF ( Y (SEND SELF :MAXIMUM-Y-POSITION))
	      (SEND SELF :TYO #\NEWLINE)
	    (SEND SELF :SET-CURSORPOS 0 Y)
	    (SEND SELF :HANDLE-EXCEPTIONS))))
      (OTHERWISE
	(SEND SELF :TYO #\NEWLINE)))))

;; Note the non-standard interpretation of cr and lf.
(DEFMETHOD (:VIEWPORT-FORMAT-EFFECTOR TERMINAL-SCREEN) (CHAR)
  (TYO-IF-WALLPAPERING CHAR)
  (SELECTOR CHAR CHAR-EQUAL
    (#\CR
     (SEND VIEWPORT-STREAM :SET-CURSORPOS 0 NIL))
    (#\LF
     (SEND VIEWPORT-STREAM :INCREMENT-CURSORPOS 0 1 :CHARACTER))
    (#\BS
     (SEND VIEWPORT-STREAM :INCREMENT-CURSORPOS -1 0 :CHARACTER))
    (#\FF
     (SEND VIEWPORT-STREAM :CLEAR-WINDOW))
    (OTHERWISE
     (LETF ((WALLPAPERING NIL)			;Already handled.
	    (OVERSTRIKE-P T))			;Non destructive.
       (SEND VIEWPORT-STREAM :TYO CHAR)))))

(DEFMETHOD (:SET-VIEWPORT-CHARACTER-POSITION TERMINAL-SCREEN) (X Y)
  (WHEN WALLPAPERING
    (MULTIPLE-VALUE-BIND (OX OY)
	(SEND VIEWPORT-STREAM :READ-CURSORPOS :CHARACTER)
      (IF (= Y OY)
	  (LET ((DX (- X OX)))
	    (IF (MINUSP DX)
		(DOTIMES (I (- DX))
		  (WALLPAPER-OPERATION :TYO #\BS))
		(DOTIMES (I DX)
		  (WALLPAPER-OPERATION :TYO #\SP))))
	(DOTIMES (I (MIN 1 (- Y OY)))
	  (WALLPAPER-OPERATION :TYO #\NEWLINE))
	(DOTIMES (I X)
	  (WALLPAPER-OPERATION :TYO #\SP)))))
  (SEND VIEWPORT-STREAM :SET-CURSORPOS X Y :CHARACTER))

#|(COMPILE-FLAVOR-METHODS TERMINAL-SCREEN)|#

;;; This is a total crock to get around a design flaw in typeout windows.  When the debugger
;;; is used, the typeout window is made complete, which causes it not to get selected when
;;; its superior is selected.  This makes you unable to then abort a connection retry because
;;; the nvt window does not have any asynchronous characters enabled.
(DEFFLAVOR TELNET-TYPEOUT-WINDOW ((DISABLE-MAKE-COMPLETE NIL)) (DW::DYNAMIC-TYPEOUT-WINDOW)
  (:LOCATABLE-INSTANCE-VARIABLES DISABLE-MAKE-COMPLETE))

(DEFWHOPPER-SUBST (:MAKE-COMPLETE TELNET-TYPEOUT-WINDOW) (&REST ARGS)
  (UNLESS DISABLE-MAKE-COMPLETE
    (LEXPR-CONTINUE-WHOPPER ARGS)))

(COMPILE-FLAVOR-METHODS TELNET-TYPEOUT-WINDOW)

;;; This is the actual NVT frame.

(DEFFLAVOR NVT-WINDOW
	((NETWORK-STREAM NIL)			;Byte stream to foreign host
	 (NETWORK-OUTPUT-LOCK (PROCESS:MAKE-LOCK "Output Lock"))	;Some typeout occurs in TYPEIN-PROCESS
	 (CONNECT-TO NIL)
	 (TYPEOUT-PROCESS NIL)			;Network to screen
	 TYPEOUT-FILTERS
	 (TYPEIN-PROCESS NIL)			;Keyboard to network
	 TYPEIN-FILTERS
	 (STATE-BLOCKS NIL)
	 (LABEL-TAG "-- Not connected")
	 ) 
	(TERMINAL-SCREEN DW::DYNAMIC-WINDOW-WITH-TYPEOUT)
  (:GETTABLE-INSTANCE-VARIABLES NETWORK-STREAM)
  (:INITABLE-INSTANCE-VARIABLES CONNECT-TO)
  (:READABLE-INSTANCE-VARIABLES NETWORK-OUTPUT-LOCK)
  (:DEFAULT-INIT-PLIST :MARGIN-COMPONENTS
		       `DW:((MARGIN-RAGGED-BORDERS )
			    (MARGIN-SCROLL-BAR )
			    (MARGIN-LABEL :MARGIN :BOTTOM :STYLE (:SWISS :BOLD :NORMAL))
			    (MARGIN-WHITE-BORDERS :THICKNESS 2))
		       :TYPEOUT-WINDOW '(TELNET-TYPEOUT-WINDOW 
					 :DEEXPOSED-TYPEOUT-ACTION (:EXPOSE-FOR-TYPEOUT)
					 :IO-BUFFER NIL)
		       :END-OF-PAGE-MODE :SCROLL)
  (:DOCUMENTATION :SPECIAL-PURPOSE "Terminal frames"))

;;; The official name of this program is "Terminal", since "nvt" doesn't
;;; make much sense to someone who isn't a network hacker.
(DEFVAR *TERMINAL-UNNAMED-WINDOW-COUNT* 0)

(DEFMETHOD (:INIT NVT-WINDOW :BEFORE) (IGNORE)
  (UNLESS TV:NAME
    (SETQ TV:NAME (FORMAT NIL "Terminal ~D"
			  (WITHOUT-INTERRUPTS
			    (INCF *TERMINAL-UNNAMED-WINDOW-COUNT*))))))

(DEFUN-IN-FLAVOR (RECOMPUTE-LABEL NVT-WINDOW) ()
  (SEND SELF ':SET-LABEL
	(WITH-OUTPUT-TO-STRING (STREAM)
	  (FORMAT STREAM "~A ~A" TV:NAME LABEL-TAG)
	  (LET ((SIMULATOR (AND (SEND *TERMINAL-SCREEN* :CONNECTED-P)
				(SEND *TERMINAL-SCREEN* :TERMINAL-SIMULATOR-TYPE))))
	    (WHEN (AND SIMULATOR (NEQ SIMULATOR 'NULL-TERMINAL-SIMULATOR))
	      (FORMAT STREAM " [~A]" (FLAVOR:FUNCALL-HANDLER SIMULATOR :NAME))))
	  (WHEN (SEND *TERMINAL-SCREEN* :WALLPAPERING)
	    (FORMAT STREAM " { ~A}"
		    (SEND (SEND *TERMINAL-SCREEN* :WALLPAPER-FILE) :TRUENAME))))))

;;; The following is just like TV:PROCESS-MIXIN except that there are two processes.
(DEFMETHOD (:INIT NVT-WINDOW :AFTER) (IGNORE)
  (UNLESS TYPEOUT-PROCESS
    (SETQ TYPEOUT-PROCESS (MAKE-PROCESS (STRING-APPEND TV:NAME " Typeout")))
    (PROCESS-PRESET TYPEOUT-PROCESS #'SEND SELF ':TYPEOUT-TOP-LEVEL))
  (UNLESS TYPEIN-PROCESS
    (SETQ TYPEIN-PROCESS (MAKE-PROCESS (STRING-APPEND TV:NAME " Typein")))
    (PROCESS-PRESET TYPEIN-PROCESS #'SEND SELF ':TYPEIN-TOP-LEVEL)))

(DEFMETHOD (:SELECT NVT-WINDOW :BEFORE) (&REST IGNORE)
  (TV:MAYBE-RESET-WINDOW-PROCESS SELF TYPEIN-PROCESS :SELECT T))

(DEFMETHOD (:EXPOSE NVT-WINDOW :BEFORE) (&REST IGNORE)
  (TV:MAYBE-RESET-WINDOW-PROCESS SELF TYPEIN-PROCESS))

;;; Don't kill the process until all methods
;;; and wrappers have run first.  This is because we might be
;;; executing inside the process that belongs to the window,
;;; and we don't want to go away before finishing.
(DEFMETHOD (:KILL NVT-WINDOW :AFTER) ()
  (WHEN TYPEOUT-PROCESS
    (PROCESS-KILL TYPEOUT-PROCESS) (PROCESS-ENABLE TYPEOUT-PROCESS))
  (WHEN TYPEIN-PROCESS
    (PROCESS-KILL TYPEIN-PROCESS) (PROCESS-ENABLE TYPEIN-PROCESS)))

(DEFWHOPPER (:DISPLAYED-PRESENTATION-AT-POSITION NVT-WINDOW) (&REST ARGS)
  (TV:PREPARE-SHEET (SELF)
    (LEXPR-CONTINUE-WHOPPER ARGS)))

(DEFMETHOD (:RESET-PROCESS NVT-WINDOW) ()
  (PROCESS-RESET TYPEOUT-PROCESS)
  (PROCESS-RESET TYPEIN-PROCESS))

(DEFMETHOD (:SHUTDOWN-ACTIVITY NVT-WINDOW) ()
  (TV:SHUTDOWN-WINDOW-PROCESS TYPEOUT-PROCESS)
  (TV:SHUTDOWN-WINDOW-PROCESS TYPEIN-PROCESS))

;;; This is suitable for use by remote login commands.
;;; It returns a window that when selected will connect to HOST
(DEFUN GET-NVT-WINDOW-TO-HOST (HOST)
  (LET ((WINDOW NIL))
    (WITHOUT-INTERRUPTS
      (LOOP FOR WIND BEING THE ARRAY-ELEMENTS OF TV:PREVIOUSLY-SELECTED-WINDOWS
	    WHEN (AND (TYPEP WIND 'NVT-WINDOW)
		      (NOT (SEND WIND ':IN-USE-P)))
	    DO (SETQ WINDOW WIND)
	       (SEND WINDOW ':SET-CONNECT-TO HOST)
	       (RETURN)))
    (WHEN (NULL WINDOW)
      (SETQ WINDOW (TV:MAKE-WINDOW 'NVT-WINDOW ':CONNECT-TO HOST)))
    WINDOW))

;;; Used to find a window not in use.
(DEFMETHOD (:IN-USE-P NVT-WINDOW) ()
  (OR NETWORK-STREAM CONNECT-TO))

;;; Set where to connect to, and arrange for the typein process to notice it when
;;; selected
(DEFMETHOD (:SET-CONNECT-TO NVT-WINDOW) (HOST)
  (PROCESS-FLUSH TYPEIN-PROCESS)
  (SETQ CONNECT-TO HOST))

(DEFMETHOD (:CONNECTED-P NVT-WINDOW) ()
  ;; +++ Check state when that is generic
  (NOT (NULL NETWORK-STREAM)))

;;; Add it to the system Create menu
(TV:ADD-TO-SYSTEM-MENU-CREATE-MENU "Terminal" 'NVT-WINDOW "Network remote login." T)

(DEFINE-PRESENTATION-TYPE TERMINAL-SIMULATOR-TYPE ()
   :ABBREVIATION-FOR `((DW:MENU-CHOOSE
			 :ALIST ,(LOOP FOR FLAVOR IN *TERMINAL-SIMULATOR-TYPES*
				       COLLECT (CONS
						 (FLAVOR:FUNCALL-HANDLER FLAVOR :NAME)
						 FLAVOR)))))

;;;+++ I wish I didn't have to put this in a command table just to be able to parse its
;;; arguments.  In fact, it's a little silly that I have to define a command at all just to
;;; get this template parser writer.
(CP:DEFINE-COMMAND (COM-TELNET-CONNECT :NAME "Connect" :COMMAND-TABLE "Telnet"
				       :PROVIDE-OUTPUT-DESTINATION-KEYWORD NIL)
		   ((HOST 'HOST
			  :DOCUMENTATION
 (WITH-OUTPUT-TO-STRING (STR)
   (LET ((EXIT-COMMAND (CL:FIND 'TV:KBD-BURY TV:*FUNCTION-KEYS* :KEY #'CADR))
	 (SELECT-KEY (BLOCK KEY
		       (MAPHASH #'(LAMBDA (KEY NAME)
				    (WHEN (STRING-EQUAL NAME "Terminal")
				      (RETURN-FROM KEY KEY)))
				CLI::*SELECT-KEY-TABLE*))))
     (FORMAT STR "This window is a `software terminal.'  It allows you to connect to~
		~%another host on the network and use that host remotely.~
	       ~2%Once connected, the Network key on your keyboard acts as an escape.~
		~%For example, while a connection is open, you can press Network D~
		~%to break the connection, or you can press Network Help to see a list~
		~%of other Terminal commands.~:[~;~:*~
	       ~2%To exit this window, you can press Function ~@:C at any time.~
		~%That command will bury this (or any) window, leaving its program state~
		~%undisturbed.  (If you have an open connection, the connection will~
		~%remain open.)~:[~;  You can press Select ~:*~@:C to return to this ~
		  window later.~]~]~
	       ~2%At this point, you are being asked to type the name of the host to~
		~%which you would like to connect.  If you would like to specify any~
		~%special options about how the connection should be achieved, terminate~
		~%the host name with a Space and you will be prompted for keyword options.~
		~%Otherwise, terminate the host name with a Return.~%"
	     (CAR EXIT-COMMAND) SELECT-KEY))))
		    &KEY (LOGIN-PROTOCOL `((NETI:PROTOCOL-NAME :SERVICE :LOGIN))
					 :DOCUMENTATION 
					 "Protocol to use for interpreting host output.")
			 (CONNECTION-PROTOCOL 'NETI:PROTOCOL-NAME
					      :DOCUMENTATION
					      "Protocol to use for establishing connection.")
			 (TERMINAL-SIMULATOR 'TERMINAL-SIMULATOR-TYPE
					     :DOCUMENTATION
					     "Standard terminal type to simulate.")
			 (ECHO 'SCL:BOOLEAN :DOCUMENTATION "Echo input locally.")
			 (OVERSTRIKE 'SCL:BOOLEAN
				     :DOCUMENTATION "Overprint output with backspaces.")
			 (RECORD-OUTPUT 'SCL:BOOLEAN :DEFAULT T
					:DOCUMENTATION "Allow scrolling and mousing.")
			 (WALLPAPER-FILE 'FS:PATHNAME
					 :DOCUMENTATION "File to journal output."))
  (IGNORE HOST LOGIN-PROTOCOL CONNECTION-PROTOCOL TERMINAL-SIMULATOR
	  ECHO OVERSTRIKE RECORD-OUTPUT WALLPAPER-FILE)
  (FERROR "This command is a dummy for parsing."))

(DEFUN PARSE-HOST-AND-OPTIONS ()
  (DESTRUCTURING-BIND (HOST &REST OPTIONS)
		      (CP:READ-COMMAND-ARGUMENTS 'COM-TELNET-CONNECT)
    (CL:NSUBSTITUTE :ECHO-P :ECHO OPTIONS)
    (CL:NSUBSTITUTE :OVERSTRIKE-P :OVERSTRIKE OPTIONS)
    (CL:NSUBSTITUTE :RECORD-OUTPUT-P :RECORD-OUTPUT OPTIONS)
    (VALUES HOST OPTIONS)))

(DEFINE-PRESENTATION-TYPE TERMINAL-INPUT () )

#||
(DEFVAR *SEND-MOUSE-POSITION-ENABLED* T)

(DEFINE-PRESENTATION-TRANSLATOR SEND-MOUSE-POSITION 
   (T TERMINAL-INPUT
      :BLANK-AREA T
      :GESTURE :LEFT
      :TESTER ((&REST IGNORE) *SEND-MOUSE-POSITION-ENABLED*)
      :DO-NOT-COMPOSE T
      :DOCUMENTATION "Send mouse position")
   (IGNORE &KEY WINDOW X Y)
  (MULTIPLE-VALUE-BIND (LEFT TOP)
      (SEND WINDOW :VISIBLE-CURSORPOS-LIMITS)
    (SETQ X (FLOOR (- X LEFT) (SEND WINDOW :CHAR-WIDTH))
	  Y (FLOOR (- Y TOP) (SEND WINDOW :LINE-HEIGHT))))
  (FORMAT NIL "/"Mouse left at ~D,~D/"" X Y))
||#

(DEFMETHOD (:TYPEIN-TOP-LEVEL NVT-WINDOW) ()
  (LET ((*TERMINAL-STREAM* SELF)
	(*VIEWPORT-STREAM* VIEWPORT-STREAM)
	(*TERMINAL-SCREEN* SELF #|(SEND SELF :GET-PANE 'TERMINAL-SCREEN)|#)
	(TERMINAL-IO (SEND SELF :TYPEOUT-WINDOW)))
    (LOOP DOING
      (SEND TERMINAL-IO :EXPOSE-FOR-TYPEOUT)
      (MULTIPLE-VALUE-BIND (HOST OPTIONS)
	  (IF CONNECT-TO
	      (PROG1 CONNECT-TO (SETQ CONNECT-TO NIL))
	      (PARSE-HOST-AND-OPTIONS))
	(LEXPR-SEND SELF :CONNECT HOST OPTIONS)
	(LET ((REASON
		(CATCH 'NVT-DONE
		  (CONDITION-CASE (ERROR)
		      (UNWIND-PROTECT
			  (ERROR-RESTART ((ERROR BREAK ABORT)
					  "Terminal Top Level to ~A" HOST)
			    (LOOP DOING
			      (UNLESS (SEND *TERMINAL-SCREEN* :LISTEN)
				(SEND TYPEIN-FILTERS :FORCE-OUTPUT))
			      (FLET ((PROCESS-NEXT-CHAR (PRESENTATION-P)
				       (LET ((CHAR (READ-CHARACTER *TERMINAL-SCREEN*
						     :FRESH-LINE NIL
						     :ANY-TYI T
						     :NOTIFICATION NIL
						     :REFRESH NIL
						     :SUSPEND NIL :ABORT NIL
						     :PRESENTATION-CONTEXT PRESENTATION-P)))
					 (WHEN (CL:TYPECASE CHAR
						 (CHARACTER T)
						 (CONS (KEYWORDP (CAR CHAR))))
					   (SEND TYPEIN-FILTERS :TYO CHAR)))))
				(IF RECORD-OUTPUT-P
				    (DW:WITH-PRESENTATION-INPUT-CONTEXT
				       ('((OR SI:INPUT-EDITOR TERMINAL-INPUT))
					:STREAM *TERMINAL-SCREEN*)
				       (BLIP)
					 (PROCESS-NEXT-CHAR T)
				       (OTHERWISE
					 (LOOP FOR CH BEING THE ARRAY-ELEMENTS
						   OF (DW:PRESENTATION-BLIP-OBJECT BLIP)
					       DO
					   (SEND TYPEIN-FILTERS :TYO CH))))
				    (PROCESS-NEXT-CHAR NIL)))))
			(WHEN NETWORK-STREAM
			  (SEND SELF :DISCONNECT)))
		    ((CONNECTION-CLOSED END-OF-FILE)
		     (FORMAT NIL "Connection closed by ~A." HOST))
		    (ERROR ERROR)))))
	  (COND ((EQ REASON :DESELECT)
		 (SEND SELF :DESELECT)
		 (PROCESS-DISABLE TYPEIN-PROCESS)
		 (PROCESS-ALLOW-SCHEDULE))
		(REASON
		 (SEND TERMINAL-IO :EXPOSE-FOR-TYPEOUT)
		 (FORMAT T "~%~A~%" REASON))))))))

;;; This is the output process
(DEFMETHOD (:TYPEOUT-TOP-LEVEL NVT-WINDOW) ()
  (LET ((*TERMINAL-STREAM* SELF)
	(*VIEWPORT-STREAM* VIEWPORT-STREAM)
	(*TERMINAL-SCREEN* SELF #|(SEND SELF :GET-PANE 'TERMINAL-SCREEN)|#))
    (WHEN (NULL NETWORK-STREAM)
      (PROCESS-DISABLE TYPEOUT-PROCESS)
      (PROCESS-ALLOW-SCHEDULE))
    (CONDITION-CASE (ERROR)
	(LOOP DOING
	  (LET* ((LAST-OUTPUT-PROCESS-TICK OUTPUT-PROCESS-TICK)
		 (ECHO-FILTER NIL)
		 (ECHO-STATE NIL)
		 (FAST-FILTERS (LOOP FOR FILTER FIRST TYPEOUT-FILTERS
						THEN (SEND FILTER :INPUT-STREAM)
				     UNTIL (EQ FILTER NETWORK-STREAM)
				     DO (WHEN (TYPEP FILTER 'ECHO-TYPEOUT-FILTER)
					  (SETQ ECHO-FILTER FILTER
						ECHO-STATE (SEND *TERMINAL-STREAM*
								 :GET-STATE-BLOCK :ECHO)))
				     AS FAST-FILTER = (SEND FILTER :SEND-IF-HANDLES
							    :FAST-FILTER-TEST)
				     WHEN (NULL FAST-FILTER) RETURN NIL
				     UNLESS (EQ FAST-FILTER T) COLLECT FAST-FILTER)))
	    (WHEN (NOT (SEND NETWORK-STREAM :OPERATION-HANDLED-P :READ-INPUT-BUFFER))
	      (SETQ FAST-FILTERS NIL))
	    (DW:WITH-OUTPUT-RECORDING-ENABLED (*TERMINAL-SCREEN* RECORD-OUTPUT-P)
	      ;; Since the only mouse commands are those that require the control key down,
	      ;; there's no need on getting an immediate update every time we do a
	      ;; :CLEAR-CHAR.
	      (TV:DELAYING-MOUSE-WAKEUP
		(IF (NULL FAST-FILTERS)
		    (LOOP WHILE (= LAST-OUTPUT-PROCESS-TICK OUTPUT-PROCESS-TICK)
			  DOING
		      (LOOP FOR CH = (SEND TYPEOUT-FILTERS :TYI T)
				   THEN (SEND TYPEOUT-FILTERS :TYI-NO-HANG T)
			    WHILE CH
			    DO (SEND *TERMINAL-SCREEN* :TYO CH))
		      (SEND *TERMINAL-SCREEN* :FORCE-OUTPUT))
		    (STACK-LET ((CHAR-BUFFER (MAKE-ARRAY 100. :TYPE 'ART-STRING
							      :FILL-POINTER 0)))
		      (LOOP WHILE (= LAST-OUTPUT-PROCESS-TICK OUTPUT-PROCESS-TICK)
			    DOING
			(LET ((REECHO NIL))	;Don't lose characters, even if wait function
						;called and value ignored, as it seems to be.
			  (SEND NETWORK-STREAM :INPUT-WAIT NIL
				#'(LAMBDA (ECHO-FILTER ECHO-STATE REECHO)
				    (OR (LOCATION-CONTENTS REECHO)
					(WHEN ECHO-STATE
					  (LET ((CH (SEND ECHO-STATE :GET-ECHO)))
					    (WHEN CH
					      (SEND ECHO-FILTER :UNTYI CH)
					      (SETF (LOCATION-CONTENTS REECHO) T)
					      T)))))
				ECHO-FILTER ECHO-STATE (LOCF REECHO)))
			(SETF (FILL-POINTER CHAR-BUFFER) 0)
			(LET ((SLOW-P NIL))
			  (MULTIPLE-VALUE-BIND (BUFFER START END)
			      (SEND NETWORK-STREAM :READ-INPUT-BUFFER T T)
			    (IF (NULL BUFFER)
				(SETQ SLOW-P T)	;Must be due to echo wakeup.
			      (LOOP FOR INDEX FROM START BELOW END
				    AS CH = (AREF BUFFER INDEX)
				    WHEN (LOOP FOR FAST-FILTER IN FAST-FILTERS
					       THEREIS (FUNCALL FAST-FILTER CH))
				      DO (SETQ SLOW-P T)
					 (LOOP-FINISH)
				    ELSE DO (ARRAY-PUSH-EXTEND CHAR-BUFFER (CODE-CHAR CH))
				    FINALLY (WHEN (> INDEX START)
					      (SEND *TERMINAL-SCREEN* :STRING-OUT CHAR-BUFFER)
					      (SEND NETWORK-STREAM :ADVANCE-INPUT-BUFFER
						    INDEX)))))
			  (WHEN SLOW-P
			    (LOOP DO (LET ((CH (SEND TYPEOUT-FILTERS :TYI T)))
				       (WHEN CH (SEND *TERMINAL-SCREEN* :TYO CH)))
				  ;; Keep reading echo the slow way until more network traffic.
				  UNTIL (SEND NETWORK-STREAM :LISTEN)
				  WHILE (SEND TYPEOUT-FILTERS :LISTEN)))))))))))
      ((NETWORK-ERROR END-OF-FILE)
       (SEND *TERMINAL-SCREEN* :FORCE-KBD-INPUT `(:ERROR ,ERROR))
       (PROCESS-DISABLE TYPEOUT-PROCESS)))))

(DEFMETHOD (:CONNECT NVT-WINDOW) (HOST &REST OPTIONS
				       &KEY ECHO-P (OVERSTRIKE-P NIL O-PP)
					    (RECORD-OUTPUT-P T)
					    (WALLPAPER-FILE NIL)
				       &ALLOW-OTHER-KEYS)
  (MULTIPLE-VALUE-BIND (STREAM TYPEIN-FLAVORS TYPEOUT-FLAVORS LABEL-ADDITION)
      (LETF (((TELNET-TYPEOUT-WINDOW-DISABLE-MAKE-COMPLETE TERMINAL-IO) T))
	(LEXPR-FUNCALL #'GET-LOGIN-CONNECTION HOST OPTIONS))
    (SETQ LABEL-TAG LABEL-ADDITION)
    (SEND *TERMINAL-SCREEN* :SET-OVERSTRIKE-P
	  (COND (O-PP OVERSTRIKE-P)
		((LET ((HOST (SEND-IF-HANDLES STREAM ':FOREIGN-HOST)))
		   (AND HOST
			(MEMQ (SEND HOST ':SYSTEM-TYPE)
			      *SYSTEM-TYPES-THAT-REFUSE-OVERSTRIKING*)))
		 NIL)
		(T *NVT-OVERSTRIKE-DEFAULT*)))
    (SEND *TERMINAL-SCREEN* :SET-RECORD-OUTPUT-P RECORD-OUTPUT-P)
    (SEND *TERMINAL-SCREEN* :SET-CHARACTER-ATTRIBUTE NIL)
    (SEND TERMINAL-IO :REMOVE-SELF)
    (SEND *TERMINAL-SCREEN* :SET-ECHO-POSITION 0)
    (SEND *TERMINAL-SCREEN* :CLEAR-HISTORY)
    (LOOP FOR FIRST-P = T THEN NIL
	  FOR PREVIOUS FIRST *TERMINAL-SCREEN* THEN NEXT
	  FOR FLAVOR IN TYPEIN-FLAVORS
	  AS NEXT = (MAKE-INSTANCE FLAVOR)
	  DO (SEND NEXT ':SET-INPUT-STREAM PREVIOUS)
	  WHEN FIRST-P
	    DO (SETQ TYPEIN-FILTERS NEXT)
	  ELSE DO (SEND PREVIOUS ':SET-OUTPUT-STREAM NEXT)
	  FINALLY (SEND PREVIOUS ':SET-OUTPUT-STREAM STREAM))
    (LOOP FOR FIRST-P = T THEN NIL
	  FOR PREVIOUS FIRST STREAM THEN NEXT
	  FOR FLAVOR IN TYPEOUT-FLAVORS
	  AS NEXT = (MAKE-INSTANCE FLAVOR)
	  DO (SEND NEXT ':SET-INPUT-STREAM PREVIOUS)
	  UNLESS FIRST-P
	    DO (SEND PREVIOUS ':SET-OUTPUT-STREAM NEXT)
	  FINALLY
	    (SEND PREVIOUS ':SET-OUTPUT-STREAM *TERMINAL-SCREEN*)
	    (SETQ TYPEOUT-FILTERS PREVIOUS))
    (SETQ NETWORK-STREAM STREAM)
    (RECOMPUTE-LABEL)
    ;; Now that the connection is setup, filters can be initialized,
    ;; doing things like setting up the SUPDUP TTY variables.
    (LOOP FOR FILTER FIRST TYPEIN-FILTERS THEN (SEND FILTER ':OUTPUT-STREAM)
	  UNTIL (EQ FILTER NETWORK-STREAM)
	  DO (SEND FILTER ':SETUP))
    (LOOP FOR FILTER FIRST TYPEOUT-FILTERS THEN (SEND FILTER ':INPUT-STREAM)
	  UNTIL (EQ FILTER NETWORK-STREAM)
	  DO (SEND FILTER ':SETUP))
    (LOOP FOR STATE-BLOCK IN STATE-BLOCKS
	  DOING (SEND STATE-BLOCK ':SETUP))
    (WHEN (AND ECHO-P
	       (LOOP FOR FILTER = TYPEIN-FILTERS THEN (SEND FILTER ':OUTPUT-STREAM)
		     UNTIL (EQ FILTER NETWORK-STREAM)
		     THEREIS (TYPEP FILTER 'ECHO-TYPEIN-FILTER)))
      (SEND (SEND SELF :GET-STATE-BLOCK :ECHO) :SET-ECHO-P T))
    (WHEN WALLPAPER-FILE
      (SEND SELF :SET-WALLPAPER-FILE WALLPAPER-FILE))
    (PROCESS-RESET-AND-ENABLE TYPEOUT-PROCESS)))

(DEFUN GET-LOGIN-CONNECTION (HOST &KEY LOGIN-PROTOCOL CONNECTION-PROTOCOL TERMINAL-SIMULATOR
				       ECHO-P OVERSTRIKE-P RECORD-OUTPUT-P WALLPAPER-FILE)
  ECHO-P OVERSTRIKE-P RECORD-OUTPUT-P WALLPAPER-FILE
  (LET ((SERVICE-ARGS (AND TERMINAL-SIMULATOR `(:TERMINAL-SIMULATOR ,TERMINAL-SIMULATOR))))
    (COND ((AND (NULL LOGIN-PROTOCOL) (NULL CONNECTION-PROTOCOL))
	   ;; Specifying nothing, use most desirable.
	   (CONDITION-BIND ((HOST-DOES-NOT-SUPPORT-SERVICE
			      #'NETI:HOST-DOES-NOT-SUPPORT-PROTOCOL-SPECIFY-PATH-HANDLER))
	     (LEXPR-FUNCALL #'INVOKE-SERVICE-ON-HOST ':LOGIN HOST SERVICE-ARGS)))
	  ((NULL CONNECTION-PROTOCOL)
	   ;; Specifying protocol, using its normal contact name.
	   (INVOKE-SERVICE-ACCESS-PATH
	     (FIND-PATH-TO-PROTOCOL-ON-HOST LOGIN-PROTOCOL HOST)
	     SERVICE-ARGS))
	  (T
	   ;; Specifying specific port (which may not normally have login service).
	   ;; Default to lisp machine character set.  (Or should it default to telnet?)
	   (WHEN (NULL LOGIN-PROTOCOL)
	     (SETQ LOGIN-PROTOCOL ':LISPM-NULL-TELNET))
	   (LET ((CONNECTION-PATH (FIND-PATH-TO-PROTOCOL-ON-HOST CONNECTION-PROTOCOL HOST))
		 (LOGIN-PROTOCOL (NETI:FIND-PROTOCOL-NAMED LOGIN-PROTOCOL ':LOGIN)))
	     (SETF (NETI:SERVICE-ACCESS-PATH-ARGS CONNECTION-PATH) SERVICE-ARGS)
	     (INVOKE-LOGIN-SERVICE-1 CONNECTION-PATH LOGIN-PROTOCOL))))))

;;; An alist of host, system type, or the symbol otherwise and simulator flavor names.
(DEFVAR *HOST-DEFAULT-TERMINAL-SIMULATORS*
  '((:VMS VT100-TERMINAL-SIMULATOR) (:VMS4 VT100-TERMINAL-SIMULATOR)
    (:VMS4.4 VT100-TERMINAL-SIMULATOR)
    (OTHERWISE AMBASSADOR-TERMINAL-SIMULATOR)))

(DEFUN HOST-DEFAULT-TERMINAL-SIMULATOR (HOST)
  (LOOP FOR (MATCH FLAVOR) IN *HOST-DEFAULT-TERMINAL-SIMULATORS*
	WHEN (CL:TYPECASE MATCH
	       ((CL:MEMBER OTHERWISE) T)
	       ((CL:KEYWORD) (EQ MATCH (SEND HOST :SYSTEM-TYPE)))
	       (OTHERWISE (EQ MATCH HOST)))
	  RETURN FLAVOR
	  FINALLY (RETURN 'NULL-TERMINAL-SIMULATOR)))

(DEFMETHOD (:DISCONNECT-AND-DESELECT NVT-WINDOW) ()
  (SEND SELF :DISCONNECT)
  (THROW 'NVT-DONE :DESELECT))

(DEFMETHOD (:DISCONNECT NVT-WINDOW) ()
  (PROCESS-DISABLE TYPEOUT-PROCESS)
  (SEND *TERMINAL-SCREEN* :CLOSE-WALLPAPER-FILE)
  (WHEN NETWORK-STREAM
    (SEND NETWORK-STREAM ':CLOSE ':ABORT)	;and abort the connection
    (LOOP FOR FILTER FIRST TYPEIN-FILTERS THEN (SEND FILTER ':OUTPUT-STREAM)
	  UNTIL (EQ FILTER NETWORK-STREAM)
	  DO (SEND FILTER ':RESET))
    (LOOP FOR FILTER FIRST TYPEOUT-FILTERS THEN (SEND FILTER ':INPUT-STREAM)
	  UNTIL (EQ FILTER NETWORK-STREAM)
	  DO (SEND FILTER ':RESET))
    (SETQ NETWORK-STREAM NIL))
  (LOOP FOR STATE-BLOCK IN STATE-BLOCKS
	DOING (SEND STATE-BLOCK ':RESET))
  (SETQ LABEL-TAG "-- Not connected")
  (RECOMPUTE-LABEL)
  (PROCESS-RESET-AND-ENABLE TYPEOUT-PROCESS))

;;; Output a set of characters directly to the network with interlocking.
(DEFMETHOD (:NETWORK-OUTPUT NVT-WINDOW) (FORCE-OUTPUT-P &REST CHARS)
  (LOCK-OUTPUT (SELF)
    (LOOP FOR CH IN CHARS
	  DO (COND ((ARRAYP CH)
		    (SEND NETWORK-STREAM ':STRING-OUT CH))
		   (T (SEND NETWORK-STREAM ':TYO CH))))
    (WHEN FORCE-OUTPUT-P
      (SEND NETWORK-STREAM ':FORCE-OUTPUT))))

(DEFMETHOD (:REMOTE-BEEP NVT-WINDOW) (STREAM BELL-CHAR)
  (UNLESS (ZEROP (TV:SHEET-EXCEPTIONS *TERMINAL-SCREEN*))		;Subject to output holding
    (SEND *TERMINAL-SCREEN* ':HANDLE-EXCEPTIONS))
  ;; If deexposed, but permitted, then avoid beeping and annoying the user.
  (WHEN (AND (SEND *TERMINAL-SCREEN* :EXPOSED-P)
	     (SEND *TERMINAL-STREAM* :EXPOSED-P))
    (SEND *TERMINAL-SCREEN* :BEEP))
  ;; To avoid gross obnoxosity, we merge multiple consecutive beeps into one.
  (LOOP AS CH = (SEND STREAM ':TYI-NO-HANG)
	WHILE (AND CH (EQL CH BELL-CHAR))
	FINALLY (AND CH (SEND STREAM ':UNTYI CH))))

;;; Suppress notification if we do not have a connection
(DEFMETHOD (:NOTICE NVT-WINDOW) (EVENT &REST IGNORE)
  (AND (MEMQ EVENT '(:INPUT :OUTPUT))
       (NOT (SEND SELF ':CONNECTED-P))))



;;; State blocks

;;; This holds hidden state that is protocol specific.
(DEFFLAVOR STATE-BLOCK
	(WINDOW
	 TYPE)
	()
  :GETTABLE-INSTANCE-VARIABLES
  :INITABLE-INSTANCE-VARIABLES)

(DEFMETHOD (:SETUP STATE-BLOCK) ())
(DEFMETHOD (:RESET STATE-BLOCK) ())

(DEFVAR *STATE-BLOCK-TYPES* NIL)

(DEFMACRO DEFINE-STATE-BLOCK-TYPE (TYPE FLAVOR)
  `(DEFINE-STATE-BLOCK-TYPE-1 ',TYPE ',FLAVOR))

(DEFUN DEFINE-STATE-BLOCK-TYPE-1 (TYPE FLAVOR)
  (LET ((ELEM (ASSQ TYPE *STATE-BLOCK-TYPES*)))
    (IF ELEM
	(SETF (CADR ELEM) FLAVOR)
	(PUSH (LIST TYPE FLAVOR) *STATE-BLOCK-TYPES*))))

(DEFMETHOD (:GET-STATE-BLOCK NVT-WINDOW) (TYPE)
  (LOOP FOR SB IN STATE-BLOCKS
	WHEN (EQ (SEND SB ':TYPE) TYPE)
	RETURN SB
	FINALLY (SETQ SB (MAKE-INSTANCE (CADR (ASSQ TYPE *STATE-BLOCK-TYPES*))
					':TYPE TYPE ':WINDOW SELF))
		(PUSH SB STATE-BLOCKS)
		(SEND SB ':SETUP)
		(RETURN SB)))

;;;; Typein process filters

(DEFMETHOD (:MORE-TYI NVT-WINDOW) ()
  (LET ((BLIP (LIST ':MORE NIL)))
    (SEND *TERMINAL-SCREEN* ':FORCE-KBD-INPUT BLIP)
    (PROCESS-WAIT "More" #'LOCATION-CONTENTS (LOCF (CADR BLIP)))))

(DEFVAR *ESCAPE-FILTER*)

;;; This is only called when we are connected.
(DEFMETHOD (:HANDLE-ESCAPE NVT-WINDOW) (ESCAPE-FILTER)
  (UNWIND-PROTECT
      (PROGN
	(SEND TERMINAL-IO :EXPOSE-FOR-TYPEOUT)
	(LOOP NAMED HANDLE-ESCAPE DOING
	  (MULTIPLE-VALUE-BIND (COMMAND ARGUMENTS)
	      (CP:READ-ACCELERATED-COMMAND
		:PROMPT "Terminal command: "
		:COMMAND-TABLE *COMMAND-TABLE*
		:UNKNOWN-ACCELERATOR-TESTER
		(LAMBDA (CHAR)
		  (COND ((CHAR-EQUAL CHAR (SEND ESCAPE-FILTER :ESCAPE-CHAR))
			 (RETURN-FROM HANDLE-ESCAPE
			   (SEND (SEND ESCAPE-FILTER :OUTPUT-STREAM) :TYO CHAR)))
			((CHAR-EQUAL CHAR #\RUBOUT)
			 (RETURN-FROM HANDLE-ESCAPE NIL)))))
	    (LET ((*ESCAPE-FILTER* ESCAPE-FILTER))
	      (WHEN COMMAND
		(APPLY COMMAND ARGUMENTS)))
	    (UNLESS (EQ COMMAND 'COM-CANNED-HELP)	;+++
	      (RETURN-FROM HANDLE-ESCAPE T)))))
    (SEND TERMINAL-IO :REMOVE-SELF)))

(CP:DEFINE-COMMAND (COM-SEND-INTERRUPT :COMMAND-TABLE "Telnet"
				       :PROVIDE-OUTPUT-DESTINATION-KEYWORD NIL)
    ()
  (SEND *ESCAPE-FILTER* :TYO '(:INTERRUPT)))

(CP:DEFINE-COMMAND-ACCELERATOR SEND-INTERRUPT "Telnet" (#\A) () ()
  `(COM-SEND-INTERRUPT))

(CP:DEFINE-COMMAND (COM-DISCONNECT :COMMAND-TABLE "Telnet"
				   :PROVIDE-OUTPUT-DESTINATION-KEYWORD NIL)
		   (&KEY (LOGOUT 'SCL:BOOLEAN)
			 (DESELECT 'SCL:BOOLEAN))
  (WHEN LOGOUT
    (SEND *ESCAPE-FILTER* :TYO '(:LOGOUT)))
  (SEND *TERMINAL-SCREEN* (IF DESELECT :DISCONNECT-AND-DESELECT :DISCONNECT))
  (THROW 'NVT-DONE "Disconnected"))

(CP:DEFINE-COMMAND-ACCELERATOR DISCONNECT "Telnet" (#\D) () ()
  `(COM-DISCONNECT))

(CP:DEFINE-COMMAND-ACCELERATOR LOGOUT "Telnet" (#\L) () ()
  `(COM-DISCONNECT :LOGOUT T))

(CP:DEFINE-COMMAND-ACCELERATOR DISCONNECT-AND-DESELECT "Telnet" (#\Q) () ()
  `(COM-DISCONNECT :DESELECT T))

(CP:DEFINE-COMMAND (COM-SET-MORE-PROCESSING :COMMAND-TABLE "Telnet"
					    :PROVIDE-OUTPUT-DESTINATION-KEYWORD NIL)
		   ((MORE-P 'SCL:BOOLEAN :DEFAULT T))
  (SEND *TERMINAL-SCREEN* :SET-MORE-P MORE-P))

(CP:DEFINE-COMMAND-ACCELERATOR TOGGLE-MORE "Telnet" (#\M) () (ARG-P ARG)
  `(COM-SET-MORE-PROCESSING ,(IF ARG-P
				 (NOT (ZEROP ARG))
				 (NOT (SEND *TERMINAL-SCREEN* :MORE-P)))))

(CP:DEFINE-COMMAND (COM-SET-OUTPUT-RECORDING :COMMAND-TABLE "Telnet"
					     :PROVIDE-OUTPUT-DESTINATION-KEYWORD NIL)
		   ((RECORD-OUTPUT-P 'SCL:BOOLEAN :DEFAULT T))
  (SEND *TERMINAL-SCREEN* :SET-RECORD-OUTPUT-P RECORD-OUTPUT-P)
  (SEND *TERMINAL-SCREEN* :NEW-OUTPUT-PROCESS-TICK))

#+ignore					;old version before serial file transfer
(CP:DEFINE-COMMAND (COM-SEND-FILE :COMMAND-TABLE "Telnet"
				  :PROVIDE-OUTPUT-DESTINATION-KEYWORD NIL)
    ((FILE 'FS:PATHNAME))
  (SEND *TERMINAL-SCREEN* :SEND-FILE FILE))

(DEFMETHOD (:SEND-FILE NVT-WINDOW) (PATHNAME)
  (WITH-OPEN-FILE-CASE (FILE PATHNAME)
    (FS:FILE-ERROR 
      (FORMAT T "~&File not sent: ~~A~~%" FILE))
    (:NO-ERROR
      (UNWIND-PROTECT
	  (LET ((LENGTH (SEND FILE :LENGTH))
		(TRUENAME (SEND FILE :TRUENAME))
		(FILTER TYPEIN-FILTERS))
	    (WHEN (TYPEP FILTER 'MORE-ESCAPE-FILTER)
	      (SETQ FILTER (SEND FILTER :OUTPUT-STREAM)))
	    (SEND SELF :SET-LABEL
		  (FORMAT NIL "Sending ~A~[ (~D characters)~]..." TRUENAME LENGTH))
	    (SEND TERMINAL-IO :REMOVE-SELF)
	    (TV:DOTIMES-NOTING-PROGRESS (I LENGTH (FORMAT NIL "Sending ~A" PATHNAME))
	      (LET ((CHAR (SEND FILE :TYI)))
		(WHEN (NULL CHAR)
		  (RETURN))
		(SEND FILTER :TYO CHAR))))
	(RECOMPUTE-LABEL)))))

(CP:DEFINE-COMMAND-ACCELERATOR SEND-FILE "Telnet" (#\F) (:ACTIVATE NIL) ()
  `(COM-SEND-FILE ))

;; This is the improved version of this command from MMcM's serial file transfer 
;; stuff -- Kalman

(CP:DEFINE-COMMAND-AND-PARSER (COM-SEND-FILE :COMMAND-TABLE "Telnet"
					     :PROVIDE-OUTPUT-DESTINATION-KEYWORD NIL)
    (FILE FORMAT &REST ARGS)
  (PROGN
    (CP:ASSIGN-ARGUMENT-VALUE FILE
			      (CP:READ-COMMAND-ARGUMENT 'CL:PATHNAME :PROMPT "file"
							:QUERY-IDENTIFIER 'FILE))
    (CP:ASSIGN-ARGUMENT-VALUE FORMAT
			      (CP:READ-COMMAND-ARGUMENT
				`((SYSTEM-APPLICATIONS::SERIAL-FILE-FORMAT :DIRECTION :OUTPUT))
				:PROMPT "format"
				:DEFAULT (SYSTEM-APPLICATIONS::FIND-SERIAL-FILE-FORMAT
					   :RAW-TEXT)
				:QUERY-IDENTIFIER 'FORMAT))
    (SYSTEM-APPLICATIONS::PARSE-SERIAL-FILE-FORMAT-KEYWORDS FORMAT CP::KEYWORD-PARSER-FUNCTION
						:OUTPUT (LIST FILE)
						(SEND *TERMINAL-STREAM* :NETWORK-STREAM)))
  (IF (EQ (SYSTEM-APPLICATIONS::SERIAL-FILE-FORMAT-NAME FORMAT) :RAW-TEXT)
      (SEND *TERMINAL-SCREEN* :SEND-FILE FILE)
      (LEXPR-SEND *TERMINAL-SCREEN* :SERIAL-FILE-NETWORK-STREAM-INTERNAL
		  #'SYSTEM-APPLICATIONS::SERIAL-FILE-FORMAT-SEND-FILES
		  FORMAT (LIST FILE) ARGS)))


(CP:DEFINE-COMMAND-AND-PARSER (COM-RECEIVE-FILE :COMMAND-TABLE "Telnet"
						:PROVIDE-OUTPUT-DESTINATION-KEYWORD NIL)
    (FILE FORMAT &REST ARGS)
  (PROGN
    (CP:ASSIGN-ARGUMENT-VALUE FILE
			      (CP:READ-COMMAND-ARGUMENT 'CL:PATHNAME :PROMPT "file"
							:QUERY-IDENTIFIER 'FILE))
    (CP:ASSIGN-ARGUMENT-VALUE FORMAT
			      (CP:READ-COMMAND-ARGUMENT
				`((SYSTEM-APPLICATIONS::SERIAL-FILE-FORMAT :DIRECTION :INPUT))
				:PROMPT "format"
				:DEFAULT (SYSTEM-APPLICATIONS::FIND-SERIAL-FILE-FORMAT
					   :XMODEM)
				:QUERY-IDENTIFIER 'FORMAT))
    (SYSTEM-APPLICATIONS::PARSE-SERIAL-FILE-FORMAT-KEYWORDS FORMAT CP::KEYWORD-PARSER-FUNCTION
						:INPUT (LIST FILE)
						(SEND *TERMINAL-STREAM* :NETWORK-STREAM)))
  (LEXPR-SEND *TERMINAL-SCREEN* :SERIAL-FILE-NETWORK-STREAM-INTERNAL
	      #'SYSTEM-APPLICATIONS::SERIAL-FILE-FORMAT-RECEIVE-FILES
	      FORMAT (LIST FILE) ARGS))

(DEFMETHOD (:SERIAL-FILE-NETWORK-STREAM-INTERNAL NVT-WINDOW) (FUNCTION FORMAT FILES &REST ARGS)
  ;; We are running in the typein process.  The typeout process needs to be stopped.
  (LET ((ERROR (CATCH 'SYSTEM-APPLICATIONS::SERIAL-FILE-CANCEL
		 (LET (done-flag seen-flag
		       (SYSTEM-APPLICATIONS::*SERIAL-FILE-CANCEL-MODE* 'THROW))
		   (UNWIND-PROTECT
		       (PROGN
			 (send typeout-process :interrupt 
			       (lambda (cell reply)
				 (process-wait "File Transfer"
				   'location-contents cell)
				 (setf (location-contents reply) t)
				 )
			       (locf done-flag)
			       (locf seen-flag)
			       )
			 #+ignore ;;This approach doesn't work because wait functions are
			 ;;run even for arrested processes.
			 (SEND TYPEOUT-PROCESS :ARREST-REASON FORMAT)
			 (CL:APPLY FUNCTION FORMAT FILES NETWORK-STREAM ARGS))
		     (setq done-flag t)
		     (process-wait "File transfer done" 'location-contents (locf seen-flag))
		     (cl::sleep 1 :sleep-reason "Avoid bug")
		     (process::process-wakeup typeout-process)
		     #+ignore ;;ditto
		     (SEND TYPEOUT-PROCESS :REVOKE-ARREST-REASON FORMAT)))
		 NIL)))
    (WHEN ERROR
      (FORMAT T "~&~A~%" ERROR))))


(CP:DEFINE-COMMAND (COM-SEND-STRING :COMMAND-TABLE "Telnet"
				    :PROVIDE-OUTPUT-DESTINATION-KEYWORD NIL)
    ((STRING 'STRING))
  (SEND *TERMINAL-SCREEN* :SEND-STRING STRING))

(CP:DEFINE-COMMAND-ACCELERATOR SEND-STRING "Telnet" (#\c-Y) (:ECHO NIL) ()
  (LET ((INTERVAL (SEND ZWEI:*KILL-HISTORY* :YANK)))
    (UNLESS (STRINGP INTERVAL)
      (SETQ INTERVAL (ZWEI:STRING-INTERVAL INTERVAL)))
    `(COM-SEND-STRING ,INTERVAL)))
(CP::ADD-COMMAND-ACCELERATOR "Telnet" 'CP::KILL-RING-PUSH-ALL-MARKED-TEXT-COMMAND-ACCELERATOR
			     '(#\m-W))

(DEFMETHOD (:SEND-STRING NVT-WINDOW) (STRING)
  (SEND TERMINAL-IO :REMOVE-SELF)
  (LET ((FILTER TYPEIN-FILTERS))
    (WHEN (TYPEP FILTER 'MORE-ESCAPE-FILTER)
      (SETQ FILTER (SEND FILTER :OUTPUT-STREAM)))
    (LOOP FOR CH BEING THE ARRAY-ELEMENTS OF STRING DO
      (SEND FILTER :TYO CH))))

(CP:DEFINE-COMMAND (COM-SET-TERMINAL-SIMULATOR-TYPE :COMMAND-TABLE "Telnet"
						    :PROVIDE-OUTPUT-DESTINATION-KEYWORD NIL)
		   ((TYPE 'TERMINAL-SIMULATOR-TYPE))
  (SEND *TERMINAL-SCREEN* :SET-TERMINAL-SIMULATOR-TYPE TYPE))

(DEFMETHOD (:TERMINAL-SIMULATOR-TYPE NVT-WINDOW) ()
  (LET ((TERMINAL-SIMULATOR-FILTER (LOOP FOR FILTER FIRST TYPEOUT-FILTERS
						    THEN (SEND FILTER ':INPUT-STREAM)
					 UNTIL (EQ FILTER NETWORK-STREAM)
					 WHEN (MEMQ (TYPEP FILTER)
						    *TERMINAL-SIMULATOR-TYPES*)
					   RETURN FILTER)))
    (AND TERMINAL-SIMULATOR-FILTER (TYPEP TERMINAL-SIMULATOR-FILTER))))

(DEFMETHOD (:SET-TERMINAL-SIMULATOR-TYPE NVT-WINDOW) (TYPE)
  (LET ((TERMINAL-SIMULATOR-FILTER (LOOP FOR FILTER FIRST TYPEOUT-FILTERS
						    THEN (SEND FILTER ':INPUT-STREAM)
					 UNTIL (EQ FILTER NETWORK-STREAM)
					 WHEN (MEMQ (TYPEP FILTER)
						    *TERMINAL-SIMULATOR-TYPES*)
					   RETURN FILTER)))
    (UNLESS TERMINAL-SIMULATOR-FILTER
      (FERROR "There is no terminal simulation possible."))
    (UNLESS (EQ TYPE (TYPEP TERMINAL-SIMULATOR-FILTER))
      (SETQ TYPEOUT-FILTERS
	    (SEND TERMINAL-SIMULATOR-FILTER :SET-TERMINAL-SIMULATOR-FLAVOR TYPE))
      (RECOMPUTE-LABEL))))

(CP:DEFINE-COMMAND (COM-SET-ESCAPE-CHARACTER :COMMAND-TABLE "Telnet"
					     :PROVIDE-OUTPUT-DESTINATION-KEYWORD NIL)
		   ((CHAR 'CL:CHARACTER))
  (SEND *ESCAPE-FILTER* :SET-ESCAPE-CHAR CHAR))

(CP:DEFINE-COMMAND (COM-SET-WALLPAPER-FILE :COMMAND-TABLE "Telnet"
					   :PROVIDE-OUTPUT-DESTINATION-KEYWORD NIL)
		   ((FILE '((SCL:TOKEN-OR-TYPE (NIL) FS:PATHNAME))))
  (SEND *TERMINAL-SCREEN* :SET-WALLPAPER-FILE FILE))

(DEFMETHOD (:SET-WALLPAPER-FILE NVT-WINDOW) (FILE)
  (WHEN (SEND SELF :WALLPAPERING)
    (SEND *TERMINAL-SCREEN* :CLOSE-WALLPAPER-FILE))
  (WHEN FILE
    (CONDITION-CASE (FILE)
	 (OPEN FILE :DIRECTION :OUTPUT)
       (FS:FILE-ERROR
	 (FORMAT T "~&Wallpapering not enabled: ~~A~~%" FILE)
	 (DW:REMOVE-WINDOW-TYPEOUT-WINDOW SELF))
       (:NO-ERROR (SEND SELF :OPEN-WALLPAPER-FILE FILE))))
  (RECOMPUTE-LABEL))

(CP:DEFINE-COMMAND (COM-SET-OVERSTRIKING :COMMAND-TABLE "Telnet"
					 :PROVIDE-OUTPUT-DESTINATION-KEYWORD NIL)
		   ((OVERSTRIKE-P 'SCL:BOOLEAN))
  (SEND *TERMINAL-SCREEN* :SET-OVERSTRIKE-P OVERSTRIKE-P)
  (SEND *TERMINAL-SCREEN* :NEW-OUTPUT-PROCESS-TICK))

(CP:DEFINE-COMMAND (COM-SET-LOCAL-ECHOING :COMMAND-TABLE "Telnet"
					  :PROVIDE-OUTPUT-DESTINATION-KEYWORD NIL)
		   ((ECHO-P 'SCL:BOOLEAN))
  (SEND (SEND *TERMINAL-SCREEN* :GET-STATE-BLOCK :ECHO) :SET-ECHO-P ECHO-P))

(CP:DEFINE-COMMAND (COM-SET-NVT-OPTIONS :NAME "Set NVT Options"
					:COMMAND-TABLE "Telnet"
					:PROVIDE-OUTPUT-DESTINATION-KEYWORD NIL)
    ()
  (LET* ((TERMINAL-SIMULATOR-TYPE (SEND *TERMINAL-SCREEN* :TERMINAL-SIMULATOR-TYPE))
	 (MORE-P (SEND *TERMINAL-SCREEN* :MORE-P))
	 (OVERSTRIKE-P (SEND *TERMINAL-SCREEN* :OVERSTRIKE-P))
	 (RECORD-OUTPUT-P (SEND *TERMINAL-SCREEN* :RECORD-OUTPUT-P))
	 (ESCAPE-CHAR (SEND *ESCAPE-FILTER* :ESCAPE-CHAR))
	 (WALLPAPER-P (SEND *TERMINAL-SCREEN* :WALLPAPERING))
	 (OLD-WALLPAPER-P WALLPAPER-P)
	 (OLD-WALLPAPER-PATH (IF (NULL (SEND *TERMINAL-SCREEN* :WALLPAPER-FILE))
				 (FS:DEFAULT-PATHNAME FS:*DEFAULT-PATHNAME-DEFAULTS*
						      NIL :TEXT)
				 (SEND (SEND *TERMINAL-SCREEN* :WALLPAPER-FILE) :PATHNAME)))
	 (WALLPAPER-PATH OLD-WALLPAPER-PATH)
	 (ECHO-STATE (SEND *TERMINAL-STREAM* :GET-STATE-BLOCK :ECHO))
	 (ECHO-P (AND ECHO-STATE (SEND ECHO-STATE :ECHO-P))))
    (DW:ACCEPTING-VALUES ()
      (SETQ ESCAPE-CHAR (ACCEPT 'CL:CHARACTER :PROMPT "Escape character"
				:DEFAULT ESCAPE-CHAR)
	    MORE-P (ACCEPT 'SCL:BOOLEAN :PROMPT "More processing" :DEFAULT MORE-P)
	    OVERSTRIKE-P (ACCEPT 'SCL:BOOLEAN :PROMPT "Overstrike" :DEFAULT OVERSTRIKE-P)
	    RECORD-OUTPUT-P (ACCEPT 'SCL:BOOLEAN :PROMPT "Record output"
				    :DEFAULT RECORD-OUTPUT-P)
	    WALLPAPER-P (ACCEPT 'SCL:BOOLEAN :PROMPT "Wallpapering" :DEFAULT WALLPAPER-P))
      (WHEN WALLPAPER-P
	(SETQ WALLPAPER-PATH (ACCEPT 'FS:PATHNAME :PROMPT "Wallpaper file"
				     :DEFAULT WALLPAPER-PATH)))
      (WHEN ECHO-STATE
	(SETQ ECHO-P (ACCEPT 'SCL:BOOLEAN :PROMPT "Local Echo" :DEFAULT ECHO-P)))
      (WHEN TERMINAL-SIMULATOR-TYPE
	(SETQ TERMINAL-SIMULATOR-TYPE (ACCEPT 'TERMINAL-SIMULATOR-TYPE
					      :PROMPT "Terminal simulator"
					      :DEFAULT TERMINAL-SIMULATOR-TYPE))))
    (WHEN (OR (NEQ OLD-WALLPAPER-P WALLPAPER-P)
	      (NOT (EQUAL WALLPAPER-PATH OLD-WALLPAPER-PATH)))
      (SEND *TERMINAL-SCREEN* :SET-WALLPAPER-FILE (AND WALLPAPER-P WALLPAPER-PATH)))
    (SEND *ESCAPE-FILTER* :SET-ESCAPE-CHAR ESCAPE-CHAR)
    (SEND *TERMINAL-SCREEN* :SET-MORE-P MORE-P)
    (SEND *TERMINAL-SCREEN* :SET-OVERSTRIKE-P OVERSTRIKE-P)
    (SEND *TERMINAL-SCREEN* :SET-RECORD-OUTPUT-P RECORD-OUTPUT-P)
    (WHEN ECHO-STATE
      (SEND ECHO-STATE :SET-ECHO-P ECHO-P))
    (WHEN TERMINAL-SIMULATOR-TYPE
      (SEND *TERMINAL-SCREEN* :SET-TERMINAL-SIMULATOR-TYPE TERMINAL-SIMULATOR-TYPE))
    (SEND *TERMINAL-SCREEN* :NEW-OUTPUT-PROCESS-TICK)))

(CP:DEFINE-COMMAND-ACCELERATOR SET-OPTIONS "Telnet" (#\X) () ()
  `(COM-SET-NVT-OPTIONS))

(DEFCONST *CANNED-ACCELERATOR-HELP*
  `((#\A "Interrupt remote host" (COM-SEND-INTERRUPT))
    (#\B "Bury this window (leaving connection intact)" (COM-BURY-WINDOW))
    (#\D "Disconnect" (COM-DISCONNECT))
    (#\L "Disconnect and tell remote host to logout" (COM-DISCONNECT :LOGOUT T))
    (#\Q "Disconnect and deselect this window" (COM-DISCONNECT :DESELECT T))
    (#\M "Toggle local more processing")
    (#\X "Set NVT options" (COM-SET-NVT-OPTIONS))
    (#\c-Y "Send top of kill ring" (COM-SEND-STRING))
    (#\m-W "Push marked text onto kill ring")
    (#\: "Extended commands")))

(DEFCONST *CANNED-EXTENDED-COMMANDS*
  '(COM-SET-TERMINAL-SIMULATOR-TYPE COM-SET-ESCAPE-CHARACTER COM-SET-WALLPAPER-FILE
    COM-SET-OVERSTRIKING
    COM-SEND-FILE COM-SEND-STRING))

(CP:DEFINE-COMMAND (COM-CANNED-HELP :COMMAND-TABLE "Telnet")
		   ()
  (FORMAT T "~&Single character commands:~%")
  (LOOP FOR (CHAR DESC COMMAND) IN *CANNED-ACCELERATOR-HELP*
	DO (FORMAT T "~&~C    " CHAR)
	   (IF COMMAND
	       (DW:WITH-OUTPUT-AS-PRESENTATION (:TYPE `((SI:COMMAND
							  :COMMAND-TABLE ,*COMMAND-TABLE*))
						      :OBJECT COMMAND)
		 (PRINC DESC))
	       (PRINC DESC)))
  (FORMAT T "~2&Extended commands:~%")
  (SCL:FORMAT-ITEM-LIST *CANNED-EXTENDED-COMMANDS*
			:PRESENTATION-TYPE `((CP:COMMAND-NAME
					       :COMMAND-TABLE ,*COMMAND-TABLE*))))

(CP:DEFINE-COMMAND-ACCELERATOR CANNED-HELP "Telnet" (#\Help) () ()
  `(COM-CANNED-HELP))

(CP:DEFINE-COMMAND (COM-BURY-WINDOW :COMMAND-TABLE "Telnet") ()
   (SEND *TERMINAL-SCREEN* :BURY)
   ;; This next sequence should avoid notifications of "wants typein" and "wants typeout"
   (PROCESS-WAIT "Await deexposed" ;Avoid timing error due 
     #'(LAMBDA (W) (EQ (SEND W :STATUS) :DEEXPOSED)) *TERMINAL-SCREEN*)
   (PROCESS-WAIT "Await exposed"
     #'(LAMBDA (W) (EQ (SEND W :STATUS) :EXPOSED)) *TERMINAL-SCREEN*))

(CP:DEFINE-COMMAND-ACCELERATOR BURY-WINDOW "Telnet" (#\B) () ()
  `(COM-BURY-WINDOW))


;;; Various login protocols.

(DEFPROP DEFINE-LOGIN-PROTOCOL DEFINE-PROTOCOL ZWEI:DEFINITION-FUNCTION-SPEC-TYPE)

(DEFMACRO DEFINE-LOGIN-PROTOCOL (PROTOCOL-NAME &BODY OPTIONS)
  (LET ((TYPEIN-FILTERS NIL)
	(TYPEOUT-FILTERS NIL)
	(CHARACTERS NIL)
	(SAVED-OPTIONS))
    (LOOP FOR OPTION IN OPTIONS
	  UNLESS (SELECTQ (CAR OPTION)
		   (:TYPEIN-FILTERS
		    (SETQ TYPEIN-FILTERS (CDR OPTION)))
		   (:TYPEOUT-FILTERS
		    (SETQ TYPEOUT-FILTERS (CDR OPTION)))
		   (:CHARACTERS
		    (SETQ CHARACTERS (CADR OPTION))))
	  COLLECT OPTION INTO SAVED
	  FINALLY (SETQ SAVED-OPTIONS SAVED))
    `(PROGN 'COMPILE
       (DEFINE-PROTOCOL ,PROTOCOL-NAME (:LOGIN :BYTE-STREAM)
	 (:INVOKE INVOKE-LOGIN-SERVICE)
	 (:PROPERTY :TYPEIN-FILTERS ,TYPEIN-FILTERS)
	 (:PROPERTY :TYPEOUT-FILTERS ,TYPEOUT-FILTERS)
	 (:PROPERTY :CHARACTERS ,CHARACTERS)
	 . ,SAVED-OPTIONS))))

(DEFUN INVOKE-LOGIN-SERVICE (SERVICE)
  (INVOKE-LOGIN-SERVICE-1 SERVICE (NETI:SERVICE-ACCESS-PATH-PROTOCOL SERVICE)))

(DEFUN INVOKE-LOGIN-SERVICE-1 (SERVICE PROTOCOL)
  (DESTRUCTURING-BIND (&KEY CHARACTERS TYPEIN-FILTERS TYPEOUT-FILTERS &ALLOW-OTHER-KEYS)
      (NETI:PROTOCOL-PROPERTY-LIST PROTOCOL)
    (WHEN CHARACTERS
      ;; I'm pretty sure that it is a bug in get-connection-for-service-on-medium
      ;; that is explicitly overrides to :characters nil.  For this reason, we cannot
      ;; make the stream be a character one.  So, instead, make the filters do the translation.
      (SETQ TYPEIN-FILTERS (APPEND TYPEIN-FILTERS (LIST 'CHAR-CODE-FILTER))
	    TYPEOUT-FILTERS (PUSH 'CODE-CHAR-FILTER TYPEOUT-FILTERS)
	    CHARACTERS NIL))
    (LET ((STREAM (GET-CONNECTION-FOR-SERVICE SERVICE :CHARACTERS CHARACTERS)))
      ;; This check can probably be removed if the bug that causes the
      ;; above if all fixed.  For now, give a more comprehensible error
      ;; earlier.
      (UNLESS (EQ (NOT (NULL CHARACTERS))
		  (NOT (NULL (SEND STREAM :CHARACTERS))))
	(CL:CERROR "Try to go on"
		   "The connection stream was not of the requested sort."))
      (LET ((TERMINAL-SIMULATOR (CL:GETF (NETI:SERVICE-ACCESS-PATH-ARGS SERVICE)
					 ':TERMINAL-SIMULATOR
					 (HOST-DEFAULT-TERMINAL-SIMULATOR
					   (NETI:SERVICE-ACCESS-PATH-HOST SERVICE)))))
	(WHEN TERMINAL-SIMULATOR
	  (WHEN (STRINGP TERMINAL-SIMULATOR)
	    (DOLIST (FLAVOR *TERMINAL-SIMULATOR-TYPES*)
	      (WHEN (EQUAL TERMINAL-SIMULATOR (FLAVOR:FUNCALL-HANDLER FLAVOR :NAME))
		(RETURN (SETQ TERMINAL-SIMULATOR FLAVOR)))))
	  (WHEN (MEMQ TERMINAL-SIMULATOR *TERMINAL-SIMULATOR-TYPES*)
	    (SETQ TYPEOUT-FILTERS (SUBST TERMINAL-SIMULATOR 'NULL-TERMINAL-SIMULATOR
					 TYPEOUT-FILTERS)))))
      (VALUES STREAM
	      TYPEIN-FILTERS
	      TYPEOUT-FILTERS
	      (WITH-OUTPUT-TO-STRING (STREAM)
		(PRINT-SERVICE-ACCESS-PATH SERVICE STREAM ':PRINT-SERVICE-NAME NIL))))))

;;; The protocols themselves.

(DEFINE-LOGIN-PROTOCOL :TELNET
  (:TYPEIN-FILTERS MORE-ESCAPE-FILTER TELNET-FILTER NVT-ASCII-TYPEIN-FILTER
                   ECHO-TYPEIN-FILTER)
  (:TYPEOUT-FILTERS IAC-HANDLER-FILTER ECHO-TYPEOUT-FILTER NULL-TERMINAL-SIMULATOR)
  (:DESIRABILITY .7))

(DEFINE-LOGIN-PROTOCOL :SUPDUP
  (:TYPEIN-FILTERS MORE-ESCAPE-FILTER ITP-FILTER)
  (:TYPEOUT-FILTERS SUPDUP-FILTER)
  (:DESIRABILITY .8))

(DEFINE-LOGIN-PROTOCOL :TELSUP
  (:TYPEIN-FILTERS MORE-ESCAPE-FILTER TELSUP-ITP-FILTER NVT-ASCII-TYPEIN-FILTER)
  (:TYPEOUT-FILTERS IAC-HANDLER-FILTER IMLAC-TERMINAL-SIMULATOR)
  (:DESIRABILITY .75))

;;; Called "3600" because the character set is defined by the 3600 keyboard
(DEFINE-LOGIN-PROTOCOL :3600-LOGIN
  (:TYPEIN-FILTERS MORE-ESCAPE-FILTER 3600-TYPEIN-FILTER)
  (:TYPEOUT-FILTERS 3600-TYPEOUT-FILTER)
  (:DESIRABILITY .85))

;;; TTY LOGIN, as with a normal dialup terminal.  No network escapes at all
(DEFINE-LOGIN-PROTOCOL :TTY-LOGIN
  (:TYPEIN-FILTERS MORE-ESCAPE-FILTER TELNET-FILTER ECHO-TYPEIN-FILTER SERIAL-FILTER)
  (:TYPEOUT-FILTERS PARITY-STRIPPING-FILTER ECHO-TYPEOUT-FILTER NULL-TERMINAL-SIMULATOR)
  (:DESIRABILITY .5))

;;; PUP TELNET, uses PUP BSP marks instead of IAC's.
(DEFINE-LOGIN-PROTOCOL :CHAT
  (:TYPEIN-FILTERS MORE-ESCAPE-FILTER TELNET-FILTER CHAT-CANNOT-INTERRUPT-FILTER)
  (:TYPEOUT-FILTERS CHAT-MARK-TYPEOUT-FILTER NULL-TERMINAL-SIMULATOR)
  (:DESIRABILITY .7))

;;; The network stream here is :CHARACTERS, things don't convert to fixnums in either
;;; direction.
(DEFINE-LOGIN-PROTOCOL :LISPM-NULL-TELNET
  (:TYPEIN-FILTERS MORE-ESCAPE-FILTER ECHO-TYPEIN-FILTER)
  (:TYPEOUT-FILTERS ECHO-TYPEOUT-FILTER)
  (:CHARACTERS T)
  (:DESIRABILITY 0))

;;; Filters

;;; This filter sits closest to the keyboard in the typein process.
;;; It handles blips from the typeout process for more or error, and the escape
;;; character.
;;; Typein stays as characters through here.
(DEFFLAVOR MORE-ESCAPE-FILTER
	((ESCAPE-CHAR #\NETWORK)
	 (IN-MORE-BREAK NIL))
	(FILTER-STREAM)
  (:SETTABLE-INSTANCE-VARIABLES ESCAPE-CHAR))

(DEFMETHOD (:FILTER MORE-ESCAPE-FILTER) (CH)
  (COND ((CL:LISTP CH)
	 (SELECTQ (FIRST CH)
	   (:ERROR (THROW 'NVT-DONE (SECOND CH)))
	   (:MORE
	    (SETF IN-MORE-BREAK CH)
	    NIL)
	   (OTHERWISE CH)))
	((CHAR CH ESCAPE-CHAR)
	 (IF IN-MORE-BREAK
	     (PROGN (SETF (SECOND IN-MORE-BREAK) T)
		    (SETF IN-MORE-BREAK NIL))
	     CH))
	(T (SEND OUTPUT-STREAM ':FORCE-OUTPUT)
	   (SEND *TERMINAL-STREAM* ':HANDLE-ESCAPE SELF)
	   NIL)))

;;; Already a fixnum through here.
(DEFFLAVOR SERIAL-FILTER () (FILTER-STREAM))

(DEFMETHOD (:FILTER SERIAL-FILTER) (CH)
  (COND ((LISTP CH) (PROGN (SEND OUTPUT-STREAM ':FINISH)
			   (SELECTQ (CAR CH)
			     (:INTERRUPT (SEND OUTPUT-STREAM ':SEND-BREAK))
			     (OTHERWISE (SEND *TERMINAL-SCREEN* ':BEEP)))
			   NIL))
	;; Should just send 8 bits, if we know output-stream is 8 bits
	(( CH #O200)
	 (SEND OUTPUT-STREAM :TYO #O033)
	 (LOGAND CH #O177))
	(T CH)))

;;; Still a fixnum through here.
(DEFFLAVOR PARITY-STRIPPING-FILTER () (FILTER-STREAM))

(DEFMETHOD (:FILTER PARITY-STRIPPING-FILTER) (CH)
  (IF (LISTP CH)
      CH
      (LOGAND CH #O177)))

(DEFMETHOD (:FAST-FILTER-TEST PARITY-STRIPPING-FILTER) ()
  #'(LAMBDA (CH) (NOT (OR (LISTP CH) (= CH (LOGAND CH #O177))))))

;;;

(DEFFLAVOR CHAT-MARK-TYPEOUT-FILTER () (FILTER-STREAM))

(DEFMETHOD (:FILTER CHAT-MARK-TYPEOUT-FILTER) (CH)
  (IF (AND (LISTP CH)
	   (EQ (CAR CH) ':MARK))
      (SELECTQ (CADR CH)
	(1 NIL)					;Data Mark
	(5 (SEND *TERMINAL-STREAM* ':NETWORK-OUTPUT T '(:MARK 6)) NIL)	;Timing mark
	(OTHERWISE NIL))
      CH))

;;;

(DEFFLAVOR CHAT-CANNOT-INTERRUPT-FILTER () (FILTER-STREAM))

(DEFMETHOD (:FILTER CHAT-CANNOT-INTERRUPT-FILTER) (CH)
  (COND ((LISTP CH)
	 (SEND *TERMINAL-SCREEN* :BEEP)
	 NIL)
	(T
	 CH)))

;;; Simulation of local echoing.  This takes two filters, one for input and one for output.
;;; Characters are taken just before being handed to the network and placed back as if from
;;; the network.  For most things, that means they are stored as fixnums and converted back
;;; and forth.  When the network stream is in characters, they stay characters of course.
(DEFINE-STATE-BLOCK-TYPE :ECHO ECHO-STATE-BLOCK)

(DEFFLAVOR ECHO-STATE-BLOCK
	((ECHO-P)
	 (ECHO-BUFFER (MAKE-ARRAY 8 :FILL-POINTER 0))
	 (EMPTY 0))
	(STATE-BLOCK)
  (:SETTABLE-INSTANCE-VARIABLES ECHO-P))

(DEFMETHOD (:SETUP ECHO-STATE-BLOCK) ()
  (SETQ ECHO-P NIL)
  (SETF (FILL-POINTER ECHO-BUFFER) 0)
  (SETQ EMPTY 0))

(DEFMETHOD (:ECHO ECHO-STATE-BLOCK) (CH)
  (WHEN ECHO-P
    (WITHOUT-INTERRUPTS
      (ARRAY-PUSH-EXTEND ECHO-BUFFER CH))))

(DEFMETHOD (:GET-ECHO ECHO-STATE-BLOCK) ()
  (WITHOUT-INTERRUPTS
    (UNLESS (ZEROP (FILL-POINTER ECHO-BUFFER))
      (LET ((CH (AREF ECHO-BUFFER EMPTY)))
	(INCF EMPTY)
	(WHEN (= EMPTY (FILL-POINTER ECHO-BUFFER))
	  (SETF (FILL-POINTER ECHO-BUFFER) 0)
	  (SETQ EMPTY 0))
	CH))))

(DEFFLAVOR ECHO-TYPEIN-FILTER (ECHO-STATE) (FILTER-STREAM))

(DEFMETHOD (:SETUP ECHO-TYPEIN-FILTER) ()
  (SETQ ECHO-STATE (SEND *TERMINAL-STREAM* ':GET-STATE-BLOCK ':ECHO)))

(DEFMETHOD (:FILTER ECHO-TYPEIN-FILTER) (CH)
  (UNLESS (LISTP CH) (SEND ECHO-STATE ':ECHO CH))
  CH)

(DEFFLAVOR ECHO-TYPEOUT-FILTER (ECHO-STATE) (FILTER-STREAM))

(DEFMETHOD (:SETUP ECHO-TYPEOUT-FILTER) ()
  (SETQ ECHO-STATE (SEND *TERMINAL-STREAM* ':GET-STATE-BLOCK ':ECHO)))

(DEFMETHOD (:FILTER ECHO-TYPEOUT-FILTER) (CH)
  (OR (SEND ECHO-STATE ':GET-ECHO) CH))

(DEFMETHOD (:LISTEN ECHO-TYPEOUT-FILTER :BEFORE) ()
  (UNLESS UNTYIED-CHAR (SETQ UNTYIED-CHAR (SEND ECHO-STATE ':GET-ECHO))))

(DEFMETHOD (:FAST-FILTER-TEST ECHO-TYPEOUT-FILTER) ()
  ;; Stop when other character available.
  #'(LAMBDA (IGNORE) (NOT (NULL (SETQ UNTYIED-CHAR (SEND ECHO-STATE :GET-ECHO))))))

;; TELNET protocol

;; Moved to SYS:NETWORK;NETWORK-TERMINAL
;(DEFCONSTANT NVT-IP #O364)
;(DEFCONSTANT NVT-DM #O362)
;(DEFCONSTANT NVT-AO #O365)
;(DEFCONSTANT NVT-AYT #O366)
;(DEFCONSTANT NVT-ERASE-LINE #O370)
;(DEFCONSTANT NVT-IAC #O377)
;(DEFCONSTANT NVT-DONT #O376)
;(DEFCONSTANT NVT-DO #O375)
;(DEFCONSTANT NVT-WONT #O374)
;(DEFCONSTANT NVT-WILL #O373)
;(DEFCONSTANT NVT-SUBNEGOTIATION-BEGIN #O372)
;(DEFCONSTANT NVT-SUBNEGOTIATION-END #O360)
;
;(DEFCONSTANT NVT-SUPDUP-OUTPUT #O26)
;(DEFCONSTANT NVT-TIMING-MARK #O6)
;(DEFCONSTANT NVT-SUPPRESS-GO-AHEAD #O3)
;(DEFCONSTANT NVT-ECHO #O1)
;(DEFCONSTANT NVT-TRANSMIT-BINARY #O0)
;(DEFCONSTANT NVT-LOGOUT #O22)

;(DEFVAR *TELNET-KEYS* (PREFILL-ARRAY #O200
;				       ;;null, break, clear, call
;				     `(NIL NIL (:ERASE-LINE) (:INTERRUPT)
;				       ;;esc, back-next, help, rubout, bs, tab, lf
;				       NIL #O037 #O037 #O177 #O010 #O011 #O012
;				       ;;refresh, form, return, quote, hold-output
;				       #O014 #O014 #O015 #O021 NIL
;				       ;;stop-output, abort, resume, status
;				       (:STOP-OUTPUT) (:INTERRUPT) NIL (:ARE-YOU-THERE)
;				       ;;end, ...
;				       NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL
;				       ;;network, escape, complete
;				       NIL #O033 #O033 NIL)))

(DEFVAR *TELNET-KEYS* 
	(LET ((KEYS (MAKE-ARRAY 256.)))
	  ;; set up standard ascii codes
	  (LOOP FOR CODE FROM 0 BELOW 128.
		DO (SETF (AREF KEYS CODE) CODE))
	  ;; set up some popular lispm chars
	  (LOOP FOR (LISPM-CHAR ASCII-CODE) IN 
		    '((#\CLEAR (:ERASE-LINE))
		      ;; what's #\call?  no such thing?
		      ;; #\back-next?
		      (#\HELP #O037)
		      (#\RUBOUT #O177)
		      (#\BACKSPACE #O010)
		      (#\TAB #O011)
		      (#\LINE #O012)
		      (#\REFRESH #O014)
		      ;; #\form ??
		      (#\RETURN #O015)
		      ;; #\quote???  #\hold-output???  #\stop-output?
		      (#\ABORT (:INTERRUPT))
		      (#\ESCAPE #O033)
		      (#\COMPLETE #O033))
		DO (SETF (AREF KEYS (CHAR-CODE LISPM-CHAR)) ASCII-CODE))
	  KEYS))

(DEFINE-STATE-BLOCK-TYPE :INPUT-TRANSLATION TELNET-INPUT-TRANSLATION-STATE-BLOCK)

(DEFFLAVOR TELNET-INPUT-TRANSLATION-STATE-BLOCK
	((INPUT-CHARACTERS NIL)
	 (OUTPUT-CHARACTERS NIL))
	(STATE-BLOCK))

(DEFMETHOD (:SET-TRANSLATION-ALIST TELNET-INPUT-TRANSLATION-STATE-BLOCK) (ALIST)
  (IF (NULL ALIST)
      (SETQ INPUT-CHARACTERS NIL)
      (SETQ INPUT-CHARACTERS (CL:MAP 'CL:STRING #'FIRST ALIST)
	    OUTPUT-CHARACTERS (CL:MAP 'CL:VECTOR #'(LAMBDA (THING)
						     (SETQ THING (SECOND THING))
						     (CL:TYPECASE THING
						       (CL:CHARACTER (CHAR-TO-ASCII THING))
						       (CL:STRING (STRING-TO-ASCII THING))
						       (OTHERWISE THING)))
				      ALIST))))

(DEFMETHOD (:TRANSLATE-INPUT-CHAR TELNET-INPUT-TRANSLATION-STATE-BLOCK) (CHAR)
  (WHEN INPUT-CHARACTERS
    (LET ((ENTRY (%STRING-SEARCH-EXACT-CHAR CHAR INPUT-CHARACTERS
					    0 (ARRAY-ACTIVE-LENGTH INPUT-CHARACTERS))))
      (WHEN ENTRY
	(AREF OUTPUT-CHARACTERS ENTRY)))))

;;; For ordinary telnet, this sits between above and the IAC quoter.
;;; It the does normal character set translation.  It doesn't know from
;;; IAC's.
;;; Typein enters as characters, exits as fixnums.
(DEFFLAVOR TELNET-FILTER (INPUT-TRANSLATION-STATE) (FILTER-STREAM))

(DEFMETHOD (:SETUP TELNET-FILTER) ()
  (SETQ INPUT-TRANSLATION-STATE (SEND *TERMINAL-STREAM* :GET-STATE-BLOCK :INPUT-TRANSLATION))
  ;; In case no typeout filter does this.
  (SEND INPUT-TRANSLATION-STATE :SET-TRANSLATION-ALIST NIL))

(DEFMETHOD (:FILTER TELNET-FILTER) (CH)
  (COND ((LISTP CH)
	 CH)
	((CL:MEMBER CH '(#\SCROLL #\META-SCROLL #\KEYBOARD:BACK-SCROLL) :TEST #'CHAR-EQUAL)
	 (CP::SCROLL-WINDOW-COMMAND-INTERNAL
	   :SCREEN
	   (SELECTOR CH CHAR-EQUAL
	     (#\SCROLL +1)
	     (#\META-SCROLL -1)
	     (#\KEYBOARD:BACK-SCROLL -1))
	   :Y *TERMINAL-STREAM*)
	 NIL)
	(T
	 (LET ((CODE (SEND INPUT-TRANSLATION-STATE :TRANSLATE-INPUT-CHAR CH)))
	   (WHEN (NULL CODE)
	     (SETQ CODE (CHAR-CODE CH))
	     (WHEN (CHAR-BIT CH :CONTROL)
	       (SETQ CODE (LDB (BYTE 5 0) CODE)))	;Controlify
	     (COND ((> CODE #O400)		; outside standard charset?
		    (SETQ CODE NIL))		; not handled. 
		   (T
		    (SETQ CODE (AREF *TELNET-KEYS* CODE))))
	     (WHEN (AND (FIXP CODE) (CHAR-BIT CH :META))
	       (WHEN (OR ( (CHAR-CODE #/A) CODE (CHAR-CODE #/Z))
			 ( (CHAR-CODE #/a) CODE (CHAR-CODE #/z)))
		 (SETQ CODE (LOGXOR CODE #O40)))	;Flip case (m-A  m-a).
	       (SETQ CODE (LOGIOR CODE #O200))))
	   (IF (ARRAYP CODE)
	       (LOOP FOR CODE BEING THE ARRAY-ELEMENTS OF CODE
		     DO (SEND OUTPUT-STREAM :TYO CODE))
	       CODE)))))

;;; This defines Internet NVT ASCII, IAC's are quoted with IAC's and the 15 character
;;; is translated into NVT newline (CRLF).
;;; Characters are fixnums at this point.
(DEFFLAVOR NVT-ASCII-TYPEIN-FILTER (TELNET-STATE) (FILTER-STREAM))

(DEFMETHOD (:SETUP NVT-ASCII-TYPEIN-FILTER) ()
  (SETQ TELNET-STATE (SEND *TERMINAL-STREAM* ':GET-STATE-BLOCK ':TELNET)))

(DEFMETHOD (:FILTER NVT-ASCII-TYPEIN-FILTER) (CH)
  (IF (LISTP CH)
      (SELECTQ (CAR CH)
	(:INTERRUPT
	 (SEND *TERMINAL-STREAM* ':NETWORK-OUTPUT NIL NVT-IAC NVT-IP NVT-IAC NVT-DM)
	 NIL)
	(:ERASE-LINE
	 (SEND *TERMINAL-STREAM* ':NETWORK-OUTPUT NIL NVT-IAC NVT-ERASE-LINE)
	 NIL)
	(:ARE-YOU-THERE
	 (SEND *TERMINAL-STREAM* ':NETWORK-OUTPUT NIL NVT-IAC NVT-AYT)
	 NIL)
	(:STOP-OUTPUT
	 (SEND *TERMINAL-STREAM* ':NETWORK-OUTPUT NIL NVT-IAC NVT-AO)
	 NIL)
	(:LOGOUT
	 (SEND *TERMINAL-STREAM* ':NETWORK-OUTPUT T NVT-IAC NVT-DO NVT-LOGOUT)
	 NIL))
      (COND ((= CH #O015)
	     (SEND OUTPUT-STREAM ':TYO #O015)
	     (unless (send telnet-state ':binary-input-flag)	; only send LF if ascii mode
	       #O012))
	    ((= CH NVT-IAC)
	     (SEND *TERMINAL-STREAM* ':NETWORK-OUTPUT NIL NVT-IAC NVT-IAC)
	     NIL)
	    (T CH))))

;;; This sits next to the above in telnet and handles IAC's
;;; Characters are all fixnums here.
(DEFFLAVOR IAC-HANDLER-FILTER (TELNET-STATE) (FILTER-STREAM))

(DEFMETHOD (:SETUP IAC-HANDLER-FILTER) ()
  (SETQ TELNET-STATE (SEND *TERMINAL-STREAM* ':GET-STATE-BLOCK ':TELNET)))

(DEFMETHOD (:FILTER IAC-HANDLER-FILTER) (CH)
  (IF (= CH NVT-IAC)
      (SEND TELNET-STATE ':HANDLE-IAC INPUT-STREAM OUTPUT-STREAM)
      CH))

(DEFMETHOD (:FAST-FILTER-TEST IAC-HANDLER-FILTER) ()
  #'(LAMBDA (CH) (= CH NVT-IAC)))

(DEFINE-STATE-BLOCK-TYPE :TELNET TELNET-STATE-BLOCK)

(DEFFLAVOR TELNET-STATE-BLOCK
	((NEW-TELNET-P NIL)
	 (ECHO-FLAG NIL)
	 (BINARY-INPUT-FLAG NIL)		; if we're transmitting binary
	 (BINARY-OUTPUT-FLAG NIL)		; if we're receiving binary
	 (SUPDUP-OUTPUT-FLAG NIL))
	(STATE-BLOCK)
  (:GETTABLE-INSTANCE-VARIABLES BINARY-INPUT-FLAG BINARY-OUTPUT-FLAG))

(DEFMETHOD (:SETUP TELNET-STATE-BLOCK) ()
  (SETQ NEW-TELNET-P NIL
	ECHO-FLAG NIL
	BINARY-INPUT-FLAG NIL			; we expect to receive ascii
	BINARY-OUTPUT-FLAG NIL			;  ... and transmit same...
	SUPDUP-OUTPUT-FLAG NIL))

(DEFVAR *TELNET-BINARY-MODE-ENABLED* NIL 
  "Whether TELNET will accept a request to TRANSMIT-BINARY")

;;;New telnet protocol IAC handler
(DEFMETHOD (:HANDLE-IAC TELNET-STATE-BLOCK) (INPUT-STREAM OUTPUT-STREAM &AUX COMMAND OPTION)
  (COND ((NULL NEW-TELNET-P)
	 (SEND SELF ':TELNET-SEND-OPTION NVT-DO NVT-ECHO)
	 (SEND SELF ':TELNET-SEND-OPTION NVT-DO NVT-SUPPRESS-GO-AHEAD)
	 (SETQ NEW-TELNET-P T)))
  (SETQ COMMAND (SEND INPUT-STREAM ':TYI))
  (IF (= COMMAND NVT-IAC)
      NVT-IAC
    (AND ( COMMAND NVT-WILL) ( COMMAND NVT-DONT)
	 (SETQ OPTION (SEND INPUT-STREAM ':TYI)))
    (SELECT COMMAND
      (NVT-WILL
       (SELECT OPTION
	 (NVT-ECHO
	  (SEND SELF ':TELNET-ECHO T))
	 (NVT-SUPPRESS-GO-AHEAD)		;ignore things we requested
	 (NVT-TRANSMIT-BINARY
	  (SETQ BINARY-OUTPUT-FLAG T)
	  (SEND SELF ':TELNET-SEND-OPTION NVT-DO OPTION))
	 (NVT-SUPDUP-OUTPUT
	  (SEND SELF ':TELNET-START-SUPDUP-OUTPUT))
	 (OTHERWISE
	  (SEND SELF ':TELNET-SEND-OPTION NVT-DONT OPTION))))
      (NVT-DO
       (COND ((= OPTION NVT-ECHO)
	      (SEND SELF ':TELNET-SEND-OPTION NVT-WONT NVT-ECHO))
	     ((and (= OPTION NVT-TRANSMIT-BINARY) *telnet-binary-mode-enabled*)
	      (setq binary-input-flag t)
	      (SEND SELF ':TELNET-SEND-OPTION NVT-WILL OPTION))
	     ((OR (= OPTION NVT-SUPPRESS-GO-AHEAD) (= OPTION NVT-TIMING-MARK))
	      (SEND SELF ':TELNET-SEND-OPTION NVT-WILL OPTION))
	     (T (SEND SELF ':TELNET-SEND-OPTION NVT-WONT OPTION))))
      (NVT-DONT
       (COND ((= OPTION NVT-ECHO)
	      (SEND SELF ':TELNET-SEND-OPTION NVT-WONT OPTION))
	     ((= OPTION NVT-TRANSMIT-BINARY)
	      (setq binary-input-flag nil)
	      (SEND SELF ':TELNET-SEND-OPTION NVT-WONT OPTION))))
      (NVT-WONT
       (COND ((= OPTION NVT-ECHO) (SEND SELF ':TELNET-ECHO NIL))
	     ((= OPTION NVT-TRANSMIT-BINARY)
	      (SETQ BINARY-OUTPUT-FLAG NIL)
	      (SEND SELF ':TELNET-SEND-OPTION NVT-DONT OPTION))))
      (NVT-SUBNEGOTIATION-BEGIN
       (SEND SELF ':TELNET-HANDLE-SUBNEGOTIATION INPUT-STREAM OUTPUT-STREAM)))
    NIL))

;;; Set our idea of who is echoing, and send a DO or DONT,
;;; unless the state is already this way.
;;; The argument to TELNET-ECHO is the new value of ECHO-FLAG,
;;; which is NIL for local echo (the official default) and T for remote echo.
;;; So (SEND SELF ':TELNET-ECHO T) means that we want remote echoing.
(DEFMETHOD (:TELNET-ECHO TELNET-STATE-BLOCK) (ON-P)
  (LET ((ECHO-STATE (SEND *TERMINAL-STREAM* ':GET-STATE-BLOCK ':ECHO)))
    (WHEN ECHO-STATE (SEND ECHO-STATE ':SET-ECHO-P (NOT ON-P))))
  (COND ((NEQ ECHO-FLAG ON-P)		;If not the right way already
	 (SETQ ECHO-FLAG ON-P)
	 (SEND SELF ':TELNET-SEND-OPTION (IF ON-P NVT-DO NVT-DONT) NVT-ECHO))))

(DEFMETHOD (:TELNET-SEND-OPTION TELNET-STATE-BLOCK) (COMMAND OPTION)
  (SEND WINDOW ':NETWORK-OUTPUT T NVT-IAC COMMAND OPTION))

(DEFMETHOD (:TELNET-HANDLE-SUBNEGOTIATION TELNET-STATE-BLOCK) (INPUT-STREAM OUTPUT-STREAM)
  (IF (AND (= (SEND INPUT-STREAM ':TYI) NVT-SUPDUP-OUTPUT)
	   (= (SEND INPUT-STREAM ':TYI) 2))
      (SEND SELF ':TELNET-SUPDUP-OUTPUT-SUBNEGOTIATION INPUT-STREAM OUTPUT-STREAM)
      (LOOP AS CH = (SEND INPUT-STREAM ':TYI)
	    WITH IAC-P = NIL
	    WHEN IAC-P
	      DO (WHEN (= CH NVT-SUBNEGOTIATION-END)
		   (LOOP-FINISH))
		 (SETQ IAC-P NIL)
	    ELSE WHEN (= CH NVT-IAC)
	    DO (SETQ IAC-P T))))

(DEFMETHOD (:TELNET-START-SUPDUP-OUTPUT TELNET-STATE-BLOCK) ()
  (SETQ SUPDUP-OUTPUT-FLAG T)
  (LOCK-OUTPUT (WINDOW)
    (LET ((STREAM (SEND WINDOW ':NETWORK-STREAM))
	  (SUPDUP-STATE (SEND WINDOW ':GET-STATE-BLOCK ':SUPDUP)))
      (SEND STREAM ':TYO NVT-IAC)
      (SEND STREAM ':TYO NVT-SUBNEGOTIATION-BEGIN)
      (SEND STREAM ':TYO NVT-SUPDUP-OUTPUT)
      (SEND STREAM ':TYO 1)
      (LET ((*SUPDUP-%TOCID* T))
	(SEND SUPDUP-STATE ':SEND-TTY-VARIABLES))
      (SEND STREAM ':TYO NVT-IAC)
      (SEND STREAM ':TYO NVT-SUBNEGOTIATION-END)
      (SEND STREAM ':FORCE-OUTPUT))))

;;; This defines the ITS intelligent terminal protocol, used in the typein process by
;;; SUPDUP (and TELSUP).
(DEFVAR *SUPDUP-KEYS*
	(PREFILL-ARRAY
	  #O200 #O
	  #+CADR '((  ) 4102 4103 0032		;null, break, clear, call
		   4101 0037 4110 0177		;esc, backnext, help, rubout
		   0010 0011 0012 0014		;bs, tab, lf, refresh
		   0014 0015 4102 0323		;page, cr, quote, hold-output
		   0037 0032 0310 (  )		;stop-output, abort, resume, status
		   0233 4061 4062 4063		;end, I, II, III
		   4064 4165 4144 4154		;IV, up, down, left,
		   4162 (  ) 4102 0033		;right, system, network, altmode
		   0033 (  ))			;complete, top-help
	  #-CADR '((  ) 4102 4103 (  )		;null, suspend, clear-input, (reserved)
		   4101 0037 4110 0177		;function, macro, help, rubout
		   0010 0011 0012 0014		;backspace, tab, line, refresh
		   0014 0015 (  ) (  )		;page, return, (quote), (hold-output)
		   (  ) 0032 0350 (  )		;(stop-output), abort, resume, (status)
		   0233 4061 4062 4063		;end, square, circle, triangle
		   (  ) (  ) 0037 (  )		;(roman-IV), (up), scroll, (left)
		   (  ) (  ) 4102 0033		;(right), select, network, escape
		   0033 (  ))			;complete, symbol-help
	  ))

;;; In as characters, out as fixnums.
(DEFFLAVOR ITP-FILTER () (FILTER-STREAM))

(DEFMETHOD (:FILTER ITP-FILTER) (CH)
  (IF (LISTP CH)
      (SELECTQ (FIRST CH)
	(:INTERRUPT
	 (SEND SELF ':FILTER #+CADR #\CALL #-CADR #\ABORT))
	(:LOGOUT
	 (SEND *TERMINAL-STREAM* ':NETWORK-OUTPUT T #O300 #O301)
	 NIL))
      (ITP-FILTER-INTERNAL CH NIL)))

(DEFFLAVOR TELSUP-ITP-FILTER () (FILTER-STREAM))

(DEFMETHOD (:FILTER TELSUP-ITP-FILTER) (CH)
  (IF (LISTP CH) CH
      (ITP-FILTER-INTERNAL CH T)))

(DEFVAR *ITP-SHIFT-BUCKY-CHARS* T)

(DEFUN ITP-FILTER-INTERNAL (CH TELSUP-P)
  (WHEN (CL:MEMBER CH '(#\SCROLL #\META-SCROLL) :TEST #'CHAR-EQUAL)
    (CP::SCROLL-WINDOW-COMMAND-INTERNAL :SCREEN (IF (CHAR-EQUAL CH #\SCROLL) +1 -1) :Y
					*TERMINAL-STREAM*)
    (RETURN-FROM ITP-FILTER-INTERNAL NIL))
  ;; The previous clause pre-empted the useful treatment of Scroll as _.
  ;; Give that feature back, but on Control-Scroll.
  (IF (CHAR-EQUAL CH #\Control-Scroll) (SETQ CH #\Scroll))
  (LET ((BITS (CHAR-BITS CH))
	(CODE (CHAR-CODE CH)))
    (WHEN (AND *ITP-SHIFT-BUCKY-CHARS*
	       (NOT (ZEROP BITS))
	       (OR ( #o101 CODE #o132)
		   ( #o141 CODE #o172)))
      ;; The keyboard driver converts holding down control and a to c-A and control and shift
      ;; and a to c-sh-A, whose char code is that for a.  The ITP protocol uses the bits
      ;; for what's held down, so we need to convert back.  This doesn't quite work if you
      ;; have shift-lock down, I suppose.
      (SETQ CODE (LOGXOR CODE #o40)))
    (SETQ CODE (COND ((OR (AND (< CODE #O040) ( CODE #O033))
			  (= CODE #O177))
		      (SETQ BITS (LOGIOR BITS #O020))	;TOP
		      CODE)
		     ((< CODE #O200)
		      CODE)
		     (T
		      (LET ((XCD (IF (NOT TELSUP-P)
				     (AREF *SUPDUP-KEYS* (- CODE #O200))
				   (LET ((XCD (AREF *TELNET-KEYS* (- CODE #O200))))
				     ;; If this translates into a special command, use that
				     ;; in preference to ITP quoting.  POS doesn't know about
				     ;; [CALL].
				     (IF (LISTP XCD) XCD
					 (AREF *SUPDUP-KEYS* (- CODE #O200)))))))
			(IF (OR (NULL XCD) (LISTP XCD))
			    XCD
			  (SETQ BITS (LOGIOR BITS (LDB (BYTE 5 7) XCD)))
			  (LDB (BYTE 7 0) XCD))))))
    (COND ((OR (NULL CODE) (LISTP CODE))
	   CODE)
	  ((NOT (ZEROP BITS))
	   (SEND *TERMINAL-STREAM* ':NETWORK-OUTPUT NIL #O034 (LOGIOR #O100 BITS) CODE)
	   NIL)
	  ((= CODE #O034)
	   (SEND *TERMINAL-STREAM* ':NETWORK-OUTPUT NIL #O034 #O034)
	   NIL)
	  (T
	   (SEND *TERMINAL-STREAM* ':NETWORK-OUTPUT NIL CODE)
	   NIL))))

;;; In as characters, out as fixnums.
(DEFFLAVOR 3600-TYPEIN-FILTER () (FILTER-STREAM))

(DEFMETHOD (:FILTER 3600-TYPEIN-FILTER) (CH)
  (IF (LISTP CH)
      (SELECTQ (FIRST CH)
	(:LOGOUT
	 (SEND *TERMINAL-STREAM* :NETWORK-OUTPUT T 0)
	 NIL))
      (LET ((BITS (CHAR-BITS CH))
	    (CODE (CHAR-CODE CH)))
	(SEND *TERMINAL-STREAM* :NETWORK-OUTPUT NIL 3 BITS CODE))))

;;;; SUPDUP stuff

(DEFVAR *SUPDUP-%TD-DISPATCH* (PREFILL-ARRAY #O200
   '(:SUPDUP-TDMOV :SUPDUP-TDMV0 :SUPDUP-CLEAR-REST-OF-WINDOW :SUPDUP-CLEAR-REST-OF-LINE
;;;  %TDMOV        %TDMV0        %TDEOF			      %TDEOL

     :SUPDUP-CLEAR-CHAR
;;;  %TDDLF

     :SUPDUP-NOTHING :SUPDUP-GT40 :SUPDUP-CRLF :SUPDUP-NOTHING :SUPDUP-BS    :SUPDUP-LF
;;;  %TDMTF	     %TDMTN       %TDCRL       %TDNOP          %TDBS           %TDLF

     :SUPDUP-CR     :SUPDUP-TDORS :SUPDUP-TDQOT :SUPDUP-SPACE :SUPDUP-TDMV0 :SUPDUP-CLEAR
;;;  %TDCR	     %TDORS        %TDQOT        %TDFS         %TDMV0        %TDCLR

     :SUPDUP-BEEP    :SUPDUP-NOTHING :SUPDUP-INSERT-LINE :SUPDUP-DELETE-LINE
;;;  %TDBEL	     %TDINI	     %TDILP	         %TDDLP

     :SUPDUP-INSERT-CHAR :SUPDUP-DELETE-CHAR :SUPDUP-BOW :SUPDUP-RESET :SUPDUP-GRAPHICS 
;;;  %TDICP	    	 %TDDCP		     %TDBOW	     %TDRST	   %TDGRF

     :SUPDUP-REGION-UP :SUPDUP-REGION-DOWN
;;;  %TDRSU	       %TDRSD

;;; PTV compatibility hacks (ARDS, etc.)
     :SUPDUP-NOTHING :SUPDUP-ARDS-SET
;;;  %TDGXT          %TDLNG

     :SUPDUP-ARDS-LONG  :SUPDUP-ARDS-SHORT	:SUPDUP-SUDS
;;;  %TDLV              %TDSV                   %TDGRF
     )))

;;; In as fixnums, out as characters.
(DEFFLAVOR SUPDUP-FILTER (SUPDUP-STATE) (FILTER-STREAM))

(DEFMETHOD (:SETUP SUPDUP-FILTER) ()
  (SETQ SUPDUP-STATE (SEND *TERMINAL-STREAM* ':GET-STATE-BLOCK ':SUPDUP))
  (LET ((*SUPDUP-%TOCID* (IF (MEMQ (SEND (SEND (SEND *TERMINAL-STREAM* ':NETWORK-STREAM)
					       ':FOREIGN-HOST)
					 ':SYSTEM-TYPE)
				   *SYSTEM-TYPES-THAT-REQUIRE-CHARACTER-INSERT*)
			     T
			     *SUPDUP-%TOCID*)))
    (SEND SUPDUP-STATE ':SEND-TTY-VARIABLES))
  (SEND SUPDUP-STATE ':SEND-FINGER-STRING)
  ;;Print out the greeting message: ITS sends in ASCII.
  (DO ((CH #O015 (SEND INPUT-STREAM ':TYI)))
      ((OR (NULL CH) (= CH #O210)))		;The end is marked with a %TDNOP, NIL is eof
    (UNLESS (= CH #O012)			;Don't type linefeeds (ITS sends CRLFs).
      (SEND OUTPUT-STREAM ':TYO (ASCII-TO-CHAR CH)))))

(DEFMETHOD (:FILTER SUPDUP-FILTER) (CH)
  (IF (< CH #O200)
      (CODE-CHAR CH)
      (SEND OUTPUT-STREAM ':FORCE-OUTPUT)
      (LET ((MESSAGE (AREF *SUPDUP-%TD-DISPATCH* (- CH #O200))))
	(IF (NULL MESSAGE)
	    NIL
	    (SEND SUPDUP-STATE MESSAGE INPUT-STREAM)))))

(DEFMETHOD (:FAST-FILTER-TEST SUPDUP-FILTER) ()
  #'(LAMBDA (CH) ( CH #O200)))

(DEFINE-STATE-BLOCK-TYPE :SUPDUP SUPDUP-STATE-BLOCK)

(DEFFLAVOR SUPDUP-STATE-BLOCK
	((SUPDUP-GRAPHICS-STATE NIL)
	 WIDTH HEIGHT LINE-HEIGHT)
	(STATE-BLOCK))

(DEFMETHOD (:SETUP SUPDUP-STATE-BLOCK) ()
  (SETQ SUPDUP-GRAPHICS-STATE (SEND WINDOW ':GET-STATE-BLOCK ':SUPDUP-GRAPHICS))
  (MULTIPLE-VALUE (WIDTH HEIGHT) (SEND *VIEWPORT-STREAM* :INSIDE-SIZE))
  (SETF LINE-HEIGHT (SEND *TERMINAL-SCREEN* :LINE-HEIGHT)))

(DEFMETHOD (:RESET SUPDUP-STATE-BLOCK) ()
  (SEND SELF ':SUPDUP-RESET))

;;;This "null function" is used for codes which we should ignore.
(DEFMETHOD (:SUPDUP-NOTHING SUPDUP-STATE-BLOCK) (IGNORE) NIL)

;;;Handle %TDMOV by ignoring two characters and then acting as if it were a %TDMV0.
(DEFMETHOD (:SUPDUP-TDMOV SUPDUP-STATE-BLOCK) (INPUT-STREAM)
  (SEND INPUT-STREAM ':TYI)
  (SEND INPUT-STREAM ':TYI)
  (SEND SELF ':SUPDUP-TDMV0 INPUT-STREAM))

;;;Handle %TDMV0 or %TDMV1 by moving the cursor.
;;;ITS sends out positions as VPOS followed by HPOS.
(DEFMETHOD (:SUPDUP-TDMV0 SUPDUP-STATE-BLOCK) (INPUT-STREAM)
  (LET* ((YPOS (SEND INPUT-STREAM ':TYI))
	 (XPOS (SEND INPUT-STREAM ':TYI)))
    (SEND *TERMINAL-STREAM* :SET-VIEWPORT-CHARACTER-POSITION XPOS YPOS))
  NIL)

(DEFMETHOD (:SUPDUP-CLEAR-REST-OF-WINDOW SUPDUP-STATE-BLOCK) (IGNORE)
  (SEND *VIEWPORT-STREAM* ':CLEAR-REST-OF-WINDOW)
  NIL)

(DEFMETHOD (:SUPDUP-CLEAR-REST-OF-LINE SUPDUP-STATE-BLOCK) (IGNORE)
  (SEND *VIEWPORT-STREAM* ':CLEAR-REST-OF-LINE)
  NIL)

(DEFMETHOD (:SUPDUP-CLEAR-CHAR SUPDUP-STATE-BLOCK) (IGNORE)
  (SEND *VIEWPORT-STREAM* ':CLEAR-CHAR)
  NIL)

(DEFMETHOD (:SUPDUP-CRLF SUPDUP-STATE-BLOCK) (IGNORE)
  (SEND *TERMINAL-STREAM* :NEWLINE :WRAP)
  NIL)

(DEFMETHOD (:SUPDUP-CR SUPDUP-STATE-BLOCK) (IGNORE)
  (SEND *TERMINAL-STREAM* :VIEWPORT-FORMAT-EFFECTOR #\CR)
  NIL)

(DEFMETHOD (:SUPDUP-LF SUPDUP-STATE-BLOCK) (IGNORE)
  (SEND *TERMINAL-STREAM* :VIEWPORT-FORMAT-EFFECTOR #\LF)
  NIL)

(DEFMETHOD (:SUPDUP-BS SUPDUP-STATE-BLOCK) (IGNORE)
  (SEND *TERMINAL-STREAM* :VIEWPORT-FORMAT-EFFECTOR #\BS)
  NIL)

(DEFMETHOD (:SUPDUP-SPACE SUPDUP-STATE-BLOCK) (IGNORE)
  (SEND *TERMINAL-STREAM* :VIEWPORT-FORMAT-EFFECTOR #\SP)
  NIL)

;;;Handle %TDORS.  Just tell ITS where the cursor position is, using the
;;;Intelligent Terminal Protocol's ^\ ^P command.
(DEFMETHOD (:SUPDUP-TDORS SUPDUP-STATE-BLOCK) (IGNORE)
  (MULTIPLE-VALUE-BIND (HPOS VPOS)
      (SEND *VIEWPORT-STREAM* ':READ-CURSORPOS ':CHARACTER)
    (SEND WINDOW ':NETWORK-OUTPUT T #O034 #O020 VPOS HPOS))
  NIL)

;;;%TDQOT means the next character should be quoted.
(DEFMETHOD (:SUPDUP-TDQOT SUPDUP-STATE-BLOCK) (INPUT-STREAM)
  (CODE-CHAR (SEND INPUT-STREAM :TYI)))

;;;%TDBEL means to ring the "bell".
(DEFMETHOD (:SUPDUP-BEEP SUPDUP-STATE-BLOCK) (INPUT-STREAM)
  (SEND WINDOW ':REMOTE-BEEP INPUT-STREAM #O221)
  NIL)

;;;%TDCLR
(DEFMETHOD (:SUPDUP-CLEAR SUPDUP-STATE-BLOCK) (&OPTIONAL IGNORE)
  ;;; Clear the display lists in the various kludges
  (LOOP FOR BLOCK-TYPE IN '(:GT40 :SUDS)
	DO (SEND (SEND WINDOW ':GET-STATE-BLOCK BLOCK-TYPE) ':CLEAR-DISPLAY-LISTS))
  (SEND *VIEWPORT-STREAM* ':CLEAR-WINDOW)
  NIL)
    
;;;%TDILP means to insert lines, takes one arg from stream which is number of lines to insert
;;;Lines are inserted at current VPOS.  The current line is affected.
(DEFMETHOD (:SUPDUP-INSERT-LINE SUPDUP-STATE-BLOCK) (INPUT-STREAM)
  (SEND *VIEWPORT-STREAM* ':INSERT-LINE (SEND INPUT-STREAM ':TYI))
  NIL)

;;;%TDDLP means to delete lines, takes one arg from stream which is the number of lines.
;;;Affects the current line.
(DEFMETHOD (:SUPDUP-DELETE-LINE SUPDUP-STATE-BLOCK) (INPUT-STREAM)
  (SEND *VIEWPORT-STREAM* ':DELETE-LINE (SEND INPUT-STREAM ':TYI))
  NIL)

;;;%TDICP insert character positions, takes an arg.
(DEFMETHOD (:SUPDUP-INSERT-CHAR SUPDUP-STATE-BLOCK) (INPUT-STREAM)
  (SEND *VIEWPORT-STREAM* ':INSERT-CHAR (SEND INPUT-STREAM ':TYI))
  NIL)

;;;%TDDCP delete character positions, takes an arg.
(DEFMETHOD (:SUPDUP-DELETE-CHAR SUPDUP-STATE-BLOCK) (INPUT-STREAM)
  (SEND *VIEWPORT-STREAM* ':DELETE-CHAR (SEND INPUT-STREAM ':TYI))
  NIL)

;;;%TDRSU, %TDRSD followed by height, n-lines
(DEFMETHOD (:SUPDUP-REGION-UP SUPDUP-STATE-BLOCK) (INPUT-STREAM)
  (MULTIPLE-VALUE-BIND (IGNORE Y-POS)
      (SEND *VIEWPORT-STREAM* :READ-CURSORPOS)
    (LET* ((REGION-HEIGHT (* (SEND INPUT-STREAM ':TYI) LINE-HEIGHT))
	   (SCROLL-AMOUNT (* (SEND INPUT-STREAM ':TYI) LINE-HEIGHT))
	   (REGION-BOTTOM (MIN (+ Y-POS REGION-HEIGHT) HEIGHT)))
      (SETF REGION-HEIGHT (- REGION-BOTTOM Y-POS))
      (SETF SCROLL-AMOUNT (MIN SCROLL-AMOUNT REGION-HEIGHT))
      (SEND *VIEWPORT-STREAM* :MOVE-REGION WIDTH (- REGION-HEIGHT SCROLL-AMOUNT)
	    0 (+ Y-POS SCROLL-AMOUNT) 0 Y-POS)))
  NIL)

(DEFMETHOD (:SUPDUP-REGION-DOWN SUPDUP-STATE-BLOCK) (INPUT-STREAM)
  (MULTIPLE-VALUE-BIND (IGNORE Y-POS)
      (SEND *VIEWPORT-STREAM* :READ-CURSORPOS)
    (LET* ((REGION-HEIGHT (* (SEND INPUT-STREAM ':TYI) LINE-HEIGHT))
	   (SCROLL-AMOUNT (* (SEND INPUT-STREAM ':TYI) LINE-HEIGHT))
	   (REGION-BOTTOM (MIN (+ Y-POS REGION-HEIGHT) HEIGHT)))
      (SETF REGION-HEIGHT (- REGION-BOTTOM Y-POS))
      (SETF SCROLL-AMOUNT (MIN SCROLL-AMOUNT REGION-HEIGHT))
      (SEND *VIEWPORT-STREAM* :MOVE-REGION WIDTH (- REGION-HEIGHT SCROLL-AMOUNT)
	    0 Y-POS 0 (+ Y-POS SCROLL-AMOUNT))))
  NIL)

(DEFMETHOD (:SUPDUP-GRAPHICS SUPDUP-STATE-BLOCK) (INPUT-STREAM)
  (SEND SUPDUP-GRAPHICS-STATE ':SUPDUP-GRAPHICS INPUT-STREAM))

(DEFVAR *SUPDUP-BOLD* NIL)

(DEFMETHOD (:SUPDUP-RESET SUPDUP-STATE-BLOCK) (&OPTIONAL IGNORE)
  (SEND *TERMINAL-SCREEN* :SET-CHARACTER-ATTRIBUTE NIL)
  (WHEN SUPDUP-GRAPHICS-STATE
    (SEND SUPDUP-GRAPHICS-STATE ':GRAPHICS-RESET))
  NIL)

(DEFMETHOD (:SUPDUP-BOW SUPDUP-STATE-BLOCK) (IGNORE)
  (SEND *TERMINAL-SCREEN* :SET-CHARACTER-ATTRIBUTE (IF *SUPDUP-BOLD* :BOLD :REVERSE-VIDEO))
  NIL)

;;; Send the initial information describing the Lisp Machine as an
;;; intelligent terminal.  The TTYOPT word contains the following:
;;; %TOERS+%TOMVB+%TOSAI+%TOMVU+%TOLWR+%TOFCI+%TOMOR+%TOLID,,%TPCBS+%TPORS+%TPRSC
;;; %TOOVR is included if the *NVT-OVERSTRIKE-DEFAULT* is on (default).
;;; Furthermore, if SUPDUP-%TOCID is non-NIL, then %TOCID will be on as well.
;;; It is off by default, because the Lispm is so fast at outputting characters
;;; that EMACS is effectively faster for the user without CID capability.
;;; SUPDUPing to SAIL and using SUPDUP-OUTPUT are kludged to bind this to T.
(DEFMETHOD (:SEND-TTY-VARIABLES SUPDUP-STATE-BLOCK) ()
  (MULTIPLE-VALUE-BIND (C-WIDTH C-HEIGHT)
      (SEND *VIEWPORT-STREAM* :SIZE-IN-CHARACTERS)
    (LOCK-OUTPUT (WINDOW)
      (LET ((STREAM (SEND WINDOW ':NETWORK-STREAM)))
	(18BIT-OUT STREAM -6)			;First word LH has minus the count of following wds.
	(18BIT-OUT STREAM 0)
	(18BIT-OUT STREAM 0)			;TCTYP word must be %TNSFW: 0,,7
	(18BIT-OUT STREAM #O000007)
	(18BIT-OUT STREAM (LOGIOR #O054632
				  (IF *SUPDUP-%TOCID* 1 0)
				  (IF (SEND *TERMINAL-SCREEN* ':OVERSTRIKE-P) #O001000 0)))
						;TTYOPT word explained above.
	(18BIT-OUT STREAM #O000054)
	(18BIT-OUT STREAM 0)			;TCMXV
	(18BIT-OUT STREAM (1- C-HEIGHT))
	(18BIT-OUT STREAM 0)			;TCMXH
	(18BIT-OUT STREAM (1- C-WIDTH))
	(18BIT-OUT STREAM 0)			;TTYROL
	(18BIT-OUT STREAM 0)			;No scrolling
	(18BIT-OUT STREAM (+ (ASH LINE-HEIGHT 10.)	;TTYSMT
			     (ASH (TV:SHEET-CHAR-WIDTH *TERMINAL-SCREEN*) 6)
			     #O000055))
	(18BIT-OUT STREAM #O040000)
	(SEND STREAM ':FORCE-OUTPUT)))))

(DEFUN 18BIT-OUT (STREAM N)
  (FUNCALL STREAM ':TYO (LDB (BYTE 6 12.) N))
  (FUNCALL STREAM ':TYO (LDB (BYTE 6 6) N))
  (FUNCALL STREAM ':TYO (LDB (BYTE 6 0) N)))

;;;Send the string to TELSER saying where we are, so that NAME can find it inside
;;;the TELSER and print it.  Boy, what a kludge.
(DEFMETHOD (:SEND-FINGER-STRING SUPDUP-STATE-BLOCK) ()
  (SEND WINDOW ':NETWORK-OUTPUT T
	#O300 #O302 (STRING-TO-ASCII (OR NET:FINGER-LOCATION SI:LOCAL-FINGER-LOCATION)) 0))

;;; In as fixnums, out as characters.
(DEFFLAVOR 3600-TYPEOUT-FILTER () (FILTER-STREAM))

;; Figure out how to turn off more processing, and then replace (1- HEIGHT) with HEIGHT.
(DEFMETHOD (:SETUP 3600-TYPEOUT-FILTER) ()
  (MULTIPLE-VALUE-BIND (WIDTH HEIGHT)
      (SEND *VIEWPORT-STREAM* :SIZE-IN-CHARACTERS)
    (SEND *TERMINAL-STREAM* :NETWORK-OUTPUT T 1 WIDTH (1- HEIGHT)))
  (LET ((STRING (STRING-TO-ASCII (OR NET:FINGER-LOCATION SI:LOCAL-FINGER-LOCATION))))
    (SEND *TERMINAL-STREAM* :NETWORK-OUTPUT T 2 (ARRAY-LENGTH STRING) STRING)))

(DEFVAR *3600-TYPEOUT-DISPATCH*
	(PREFILL-ARRAY 8 '(:BEEP
			   :NEW-LINE
			   :CLEAR-WINDOW
			   :CLEAR-REST-OF-WINDOW
			   :CLEAR-REST-OF-LINE
			   :INSERT-CHAR
			   :DELETE-CHAR
			   :SET-CURSORPOS)))

(DEFMETHOD (:FILTER 3600-TYPEOUT-FILTER) (CH)
  (IF (< CH #O200)
      (CODE-CHAR CH)
      (LET ((INDEX (- CH #O200)))
	(WHEN (< INDEX (ARRAY-ACTIVE-LENGTH *3600-TYPEOUT-DISPATCH*))
	  (LET ((MESSAGE (AREF *3600-TYPEOUT-DISPATCH* INDEX)))
	    (WHEN MESSAGE
	      (SEND OUTPUT-STREAM :FORCE-OUTPUT)
	      (SEND SELF MESSAGE))))
	NIL)))

(DEFMETHOD (:FAST-FILTER-TEST 3600-TYPEOUT-FILTER) ()
  #'(LAMBDA (CH) ( CH #O200)))

(DEFMETHOD (:BEEP 3600-TYPEOUT-FILTER) ()
  (SEND *TERMINAL-STREAM* :REMOTE-BEEP INPUT-STREAM #O200))

(DEFMETHOD (:NEW-LINE 3600-TYPEOUT-FILTER) ()
  (SEND *TERMINAL-STREAM* :NEWLINE :WRAP))

(DEFMETHOD (:CLEAR-WINDOW 3600-TYPEOUT-FILTER) ()
  (SEND *VIEWPORT-STREAM* :CLEAR-WINDOW))

(DEFMETHOD (:CLEAR-REST-OF-WINDOW 3600-TYPEOUT-FILTER) ()
  (SEND *VIEWPORT-STREAM* :CLEAR-REST-OF-WINDOW))

(DEFMETHOD (:CLEAR-REST-OF-LINE 3600-TYPEOUT-FILTER) ()
  (SEND *VIEWPORT-STREAM* :CLEAR-REST-OF-LINE))

(DEFMETHOD (:INSERT-CHAR 3600-TYPEOUT-FILTER) ()
  (SEND *VIEWPORT-STREAM* :INSERT-CHAR (SEND INPUT-STREAM :TYI)))

(DEFMETHOD (:DELETE-CHAR 3600-TYPEOUT-FILTER) ()
  (SEND *VIEWPORT-STREAM* :DELETE-CHAR (SEND INPUT-STREAM :TYI)))

(DEFMETHOD (:SET-CURSORPOS 3600-TYPEOUT-FILTER) ()
  (LET ((X (SEND INPUT-STREAM :TYI))
	(Y (SEND INPUT-STREAM :TYI)))
    (MULTIPLE-VALUE-BIND (OX OY)
	(SEND *VIEWPORT-STREAM* :READ-CURSORPOS :CHARACTER)
      (IF (AND (= Y OY) (= X (1+ OX)))
	  (SEND *TERMINAL-STREAM* :VIEWPORT-FORMAT-EFFECTOR #\SP)
	  (SEND *TERMINAL-STREAM* :SET-VIEWPORT-CHARACTER-POSITION X Y)))))

(DEFFLAVOR CHAR-CODE-FILTER () (FILTER-STREAM))

(DEFMETHOD (:FILTER CHAR-CODE-FILTER) (CHAR) (CHAR-CODE CHAR))

(DEFFLAVOR CODE-CHAR-FILTER () (FILTER-STREAM))

(DEFMETHOD (:FILTER CODE-CHAR-FILTER) (CODE) (CODE-CHAR CODE))


;; Terminal Simulators
;; Characters come in as fixnums, leave as characters.

(DEFFLAVOR TERMINAL-SIMULATOR () (FILTER-STREAM)
  (:REQUIRED-METHODS :NAME))

(DEFMETHOD (:SET-TERMINAL-SIMULATOR-FLAVOR TERMINAL-SIMULATOR) (FLAVOR)
  (SEND (SEND *TERMINAL-STREAM* :GET-STATE-BLOCK :INPUT-TRANSLATION)
	:SET-TRANSLATION-ALIST NIL)
  (LET ((NEW (MAKE-INSTANCE FLAVOR ':INPUT-STREAM INPUT-STREAM
				   ':OUTPUT-STREAM OUTPUT-STREAM)))
    (SEND INPUT-STREAM ':SET-OUTPUT-STREAM NEW)
    (SEND NEW ':SETUP)
    NEW))

(DEFUN ADD-TERMINAL-SIMULATOR-TYPE (FLAVOR)
  (SI:PUSH* FLAVOR *TERMINAL-SIMULATOR-TYPES*))

(DEFFLAVOR NULL-TERMINAL-SIMULATOR () (TERMINAL-SIMULATOR))

(DEFUN-IN-FLAVOR (DEFAULT-TERMINAL-SIMULATOR TERMINAL-SIMULATOR) (CH)
  ;; Mask the supposed ASCII or NVT character to seven bits
  ;; The Unix telnet server sends "parity bits" in the login prompt
  ;; An old Lisp Machine telnet server sends 215 instead of 15 12 sometimes--too bad
  (SETF CH (LOGAND CH #O177))
  (SELECTOR CH =
    (((ASCII-CODE 'BEL))
     (SEND OUTPUT-STREAM :FORCE-OUTPUT)
     (SEND *TERMINAL-STREAM* :REMOTE-BEEP INPUT-STREAM CH)	;^G rings the bell.
     NIL)
    (((ASCII-CODE 'LF))
     (SEND OUTPUT-STREAM :FORCE-OUTPUT)
     (SEND SELF :LINE-FEED)
     NIL)
    (((ASCII-CODE 'CR))
     ;; By the protocol, only two things are allowed to follow a CR: LF
     ;; and NUL.  Various servers have various bugs, so we try to get
     ;; around them.
     (LOOP DOING
       (SEND OUTPUT-STREAM :FORCE-OUTPUT)
       (LET ((CH1 (LET ((START-TIME (TIME)))
		    (LOOP DOING
		      ;; Cannot rely on Unix hosts to obey protocol and send the NUL after
		      ;; the CR.
		      (LET ((CH (SEND INPUT-STREAM :TYI-NO-HANG)))
			(WHEN CH (RETURN CH)))
		      (WHEN (TIME-ELAPSED-P 60 START-TIME)
			(RETURN 0))
		      (PROCESS-WAIT "Maybe LF available"
			#'(LAMBDA (STREAM START-TIME)
			    (OR (SEND STREAM :LISTEN)
				(TIME-ELAPSED-P 60 START-TIME)))	;One second
			INPUT-STREAM START-TIME)))))
	 (COND ((= CH1 (ASCII-CODE 'LF))	;CRLF gets 15#\RETURN conversion below
		(SEND SELF :NEXT-LINE)
		(RETURN NIL))
	       (T
		;; CR not followed by LF, move carriage to left margin.
		(SEND *TERMINAL-STREAM* :VIEWPORT-FORMAT-EFFECTOR #\CR)
		(WHEN (= CH1 (ASCII-CODE 'NUL))	;CR NUL does nothing more.
		  (RETURN NIL))
		(WHEN ( CH1 (ASCII-CODE 'CR))
		  ;; Other garbage recurses, outputting it eventually.  CR requires check for
		  ;; CR CR LF.
		  (RETURN (SEND SELF :FILTER CH1))))))))
    (((ASCII-CODE 'BS) (ASCII-CODE 'TAB) (ASCII-CODE 'FF))
     (SEND OUTPUT-STREAM :FORCE-OUTPUT)	;to Lisp machine char set.
     (SEND *TERMINAL-STREAM* :VIEWPORT-FORMAT-EFFECTOR (ASCII-TO-CHAR CH))
     NIL)
    (((ASCII-CODE 'SI))
     (SEND SELF :SHIFT-IN)
     NIL)
    (((ASCII-CODE 'SO))
     (SEND SELF :SHIFT-OUT)
     NIL)
    (T
     (SEND SELF :TRANSLATE-GRAPHIC-CHAR CH))))

;;; Next few exist for the sake of VT100 emulation, in which they do funny things.
(DEFMETHOD (:LINE-FEED TERMINAL-SIMULATOR :DEFAULT) (&OPTIONAL (LINE-COUNT 1))
  (IF (= LINE-COUNT 1)
      (SEND *TERMINAL-STREAM* :VIEWPORT-FORMAT-EFFECTOR #\LF)
      (MULTIPLE-VALUE-BIND (X Y)
	  (SEND *VIEWPORT-STREAM* :READ-CURSORPOS :CHARACTER)
	(SEND *TERMINAL-STREAM* :SET-VIEWPORT-CHARACTER-POSITION X (+ Y LINE-COUNT)))))

(DEFMETHOD (:NEXT-LINE TERMINAL-SIMULATOR :DEFAULT) ()
  (SEND *TERMINAL-STREAM* :NEWLINE))

(DEFMETHOD (:LINE-STARVE TERMINAL-SIMULATOR :DEFAULT) (&OPTIONAL (LINE-COUNT 1))
  (MULTIPLE-VALUE-BIND (X Y)
      (SEND *VIEWPORT-STREAM* :READ-CURSORPOS :CHARACTER)
    (SEND *TERMINAL-STREAM* :SET-VIEWPORT-CHARACTER-POSITION X (- Y LINE-COUNT))))

(DEFMETHOD (:SHIFT-IN TERMINAL-SIMULATOR :DEFAULT) () )
(DEFMETHOD (:SHIFT-OUT TERMINAL-SIMULATOR :DEFAULT) () )

(DEFMETHOD (:TRANSLATE-GRAPHIC-CHAR TERMINAL-SIMULATOR :DEFAULT) (CODE)
  (CODE-CHAR CODE))

(DEFMETHOD (:FILTER NULL-TERMINAL-SIMULATOR) (CH)
  (DEFAULT-TERMINAL-SIMULATOR CH))

(DEFMETHOD (:NAME NULL-TERMINAL-SIMULATOR) () "Glass TTY")

(ADD-TERMINAL-SIMULATOR-TYPE 'NULL-TERMINAL-SIMULATOR)

;;; Imlac simulator
(DEFFLAVOR IMLAC-TERMINAL-SIMULATOR
	(SUPDUP-STATE
	 BINARY-OUTPUT-P-P)
	(TERMINAL-SIMULATOR))

(DEFMETHOD (:SETUP IMLAC-TERMINAL-SIMULATOR) ()
  (SETQ SUPDUP-STATE (SEND *TERMINAL-STREAM* ':GET-STATE-BLOCK ':SUPDUP))
  (SETQ BINARY-OUTPUT-P-P (LOCATE-IN-INSTANCE (SEND *TERMINAL-STREAM* ':GET-STATE-BLOCK
						    ':TELNET)
					      'BINARY-OUTPUT-FLAG)))

(DEFMETHOD (:FILTER IMLAC-TERMINAL-SIMULATOR) (CH)
  (COND ((= CH #O177) (SEND SELF ':HANDLE-IMLAC-ESCAPE))
	((AND (CDR BINARY-OUTPUT-P-P) (NOT (= CH #O015))) (CODE-CHAR CH))
	(T (DEFAULT-TERMINAL-SIMULATOR CH))))

(DEFMETHOD (:HANDLE-IMLAC-ESCAPE IMLAC-TERMINAL-SIMULATOR) ()
  (LET ((CH (+ (SEND INPUT-STREAM ':TYI) #O176)))
    (IF (= CH #O177)
	(CODE-CHAR CH)
      (SEND OUTPUT-STREAM ':FORCE-OUTPUT)
      (LET ((MESSAGE (AREF *SUPDUP-%TD-DISPATCH* (- CH #O200))))
	(IF (NULL MESSAGE)
	    NIL
	    (SEND SUPDUP-STATE MESSAGE INPUT-STREAM))))))

(DEFMETHOD (:NAME IMLAC-TERMINAL-SIMULATOR) () "Imlac")

(ADD-TERMINAL-SIMULATOR-TYPE 'IMLAC-TERMINAL-SIMULATOR)

;;; TELNET Supdup output
(DEFMETHOD (:TELNET-SUPDUP-OUTPUT-SUBNEGOTIATION TELNET-STATE-BLOCK)
	   (SUPDUP-OUTPUT-INPUT-STREAM OUTPUT-STREAM)
  (DECLARE (SPECIAL SUPDUP-OUTPUT-INPUT-STREAM))
  (LET ((SUPDUP-OUTPUT-BYTE-COUNT (SEND SUPDUP-OUTPUT-INPUT-STREAM ':TYI))
	(SUPDUP-STATE (SEND WINDOW ':GET-STATE-BLOCK ':SUPDUP)))
    (DECLARE (SPECIAL SUPDUP-OUTPUT-BYTE-COUNT))
    (LOOP UNTIL ( SUPDUP-OUTPUT-BYTE-COUNT 0)
	  AS CH = (SUPDUP-OUTPUT-COUNTING-STREAM ':TYI)
	  WHEN (< CH #O200)
	    DO (SEND OUTPUT-STREAM ':TYO CH)
	  ELSE DO (SEND OUTPUT-STREAM ':FORCE-OUTPUT)
		  (LET ((MESSAGE (AREF *SUPDUP-%TD-DISPATCH* (- CH #O200))))
		    (UNLESS (NULL MESSAGE)
		      (SEND SUPDUP-STATE MESSAGE 'SUPDUP-OUTPUT-COUNTING-STREAM))))
    (UNLESS (COND (( SUPDUP-OUTPUT-BYTE-COUNT 0) NIL)
		  (T
		   (SEND SUPDUP-OUTPUT-INPUT-STREAM ':TYI)
		   (SEND SUPDUP-OUTPUT-INPUT-STREAM ':TYI)
		   (AND (= (SEND SUPDUP-OUTPUT-INPUT-STREAM ':TYI) NVT-IAC)
			(= (SEND SUPDUP-OUTPUT-INPUT-STREAM ':TYI)
			   NVT-SUBNEGOTIATION-END))))
      (FERROR "SUPDUP-OUTPUT subnegotiation out of phase"))))

(DEFUN SUPDUP-OUTPUT-COUNTING-STREAM (OP &REST ARGS)
  (DECLARE (SPECIAL SUPDUP-OUTPUT-INPUT-STREAM SUPDUP-OUTPUT-BYTE-COUNT))
  (PROG1 (LEXPR-FUNCALL SUPDUP-OUTPUT-INPUT-STREAM OP ARGS)
	 (AND (EQ OP ':TYI)
	      (SETQ SUPDUP-OUTPUT-BYTE-COUNT (1- SUPDUP-OUTPUT-BYTE-COUNT)))))

;;;; SUPDUP Graphics Protocol

(DEFINE-STATE-BLOCK-TYPE :SUPDUP-GRAPHICS SUPDUP-GRAPHICS-STATE)

;;; Note that ALL four edge coordinates are INCLUSIVE:
;;; they are values corresponding to points which actually exist.
;;; This is in contrast to the window system,
;;; in which the lower limits are inclusive and the upper are exclusive.
(DEFFLAVOR SUPDUP-GRAPHICS-STATE
	(GRAPHICS-X-OFFSET GRAPHICS-Y-OFFSET
	 GRAPHICS-VIRT-SCALE
	 GRAPHICS-XPOS GRAPHICS-YPOS
	 GRAPHICS-LEFT GRAPHICS-TOP
	 GRAPHICS-RIGHT GRAPHICS-BOTTOM
	 GRAPHICS-XOR-MODE GRAPHICS-VIRTUAL-MODE)
	(STATE-BLOCK))

;;; Initialize all the variables used for graphics commands.
(DEFMETHOD (:GRAPHICS-RESET SUPDUP-GRAPHICS-STATE) ()
  (LET ((CORRECTED-RIGHT (+ (TV:SHEET-INSIDE-LEFT *TERMINAL-SCREEN*)
			    (* (TV:SHEET-CHAR-WIDTH *TERMINAL-SCREEN*)
			       (// (TV:SHEET-INSIDE-WIDTH *TERMINAL-SCREEN*)
				   (TV:SHEET-CHAR-WIDTH *TERMINAL-SCREEN*)))))
	(CORRECTED-BOTTOM (+ (TV:SHEET-INSIDE-TOP *TERMINAL-SCREEN*)
			     (* (TV:SHEET-LINE-HEIGHT *TERMINAL-SCREEN*)
				(// (TV:SHEET-INSIDE-HEIGHT *TERMINAL-SCREEN*)
				    (TV:SHEET-LINE-HEIGHT *TERMINAL-SCREEN*))))))
    (SETQ GRAPHICS-X-OFFSET (// (+ (TV:SHEET-INSIDE-LEFT *TERMINAL-SCREEN*) CORRECTED-RIGHT)
				2)
	  GRAPHICS-Y-OFFSET (// (+ (TV:SHEET-INSIDE-TOP *TERMINAL-SCREEN*) CORRECTED-BOTTOM)
				2)
	  GRAPHICS-XPOS 0
	  GRAPHICS-YPOS 0
	  GRAPHICS-VIRT-SCALE (// (MIN (- CORRECTED-RIGHT
					  (TV:SHEET-INSIDE-LEFT *TERMINAL-SCREEN*))
				       (- CORRECTED-BOTTOM
					  (TV:SHEET-INSIDE-TOP *TERMINAL-SCREEN*)))
				  2.0S0
				  #O4000)
	  GRAPHICS-XOR-MODE NIL
	  GRAPHICS-VIRTUAL-MODE NIL
	  GRAPHICS-LEFT (- (TV:SHEET-INSIDE-LEFT *TERMINAL-SCREEN*) GRAPHICS-X-OFFSET)
	  GRAPHICS-RIGHT (- (TV:SHEET-INSIDE-RIGHT *TERMINAL-SCREEN*) GRAPHICS-X-OFFSET 1)
	  GRAPHICS-BOTTOM (- GRAPHICS-Y-OFFSET
			     (1- (TV:SHEET-INSIDE-BOTTOM *TERMINAL-SCREEN*)))
	  GRAPHICS-TOP (- GRAPHICS-Y-OFFSET (TV:SHEET-INSIDE-TOP *TERMINAL-SCREEN*)))))

(DEFMETHOD (:SETUP SUPDUP-GRAPHICS-STATE) ()
  (SEND SELF ':GRAPHICS-RESET))

(DEFVAR *GRAPHICS-DISPATCH* (PREFILL-ARRAY #O100
  '(:GRAPHICS-NOTHING :GRAPHICS-MOVE :GRAPHICS-XOR :GRAPHICS-NOTHING
    :GRAPHICS-NOTHING :GRAPHICS-NOTHING :GRAPHICS-NOTHING :GRAPHICS-NOTHING
    :GRAPHICS-ERASE-SCREEN :GRAPHICS-PUSH :GRAPHICS-VIRTUAL :GRAPHICS-NOTHING
    :GRAPHICS-NOTHING :GRAPHICS-LIMIT :GRAPHICS-NOTHING :GRAPHICS-NOTHING
    :GRAPHICS-NOTHING :GRAPHICS-MOVE :GRAPHICS-IOR :GRAPHICS-NOTHING
    :GRAPHICS-NOTHING :GRAPHICS-NOTHING :GRAPHICS-NOTHING :GRAPHICS-NOTHING
    :GRAPHICS-NOTHING :GRAPHICS-NOTHING :GRAPHICS-PHYSICAL :GRAPHICS-NOTHING
    :GRAPHICS-NOTHING :GRAPHICS-NOTHING :GRAPHICS-NOTHING :GRAPHICS-NOTHING)))

(DEFVAR *DRAW-DISPATCH* (PREFILL-ARRAY #O20
  '(:GRAPHICS-NOTHING :GRAPHICS-DRAW-LINE :GRAPHICS-DRAW-POINT :GRAPHICS-DRAW-RECT
    :GRAPHICS-DRAW-STRING :GRAPHICS-DRAW-BITS :GRAPHICS-DRAW-RUNS :GRAPHICS-NOTHING
    :GRAPHICS-NOTHING :GRAPHICS-NOTHING :GRAPHICS-NOTHING :GRAPHICS-NOTHING
    :GRAPHICS-NOTHING :GRAPHICS-NOTHING :GRAPHICS-NOTHING :GRAPHICS-NOTHING)))

(DEFMETHOD (:SUPDUP-GRAPHICS SUPDUP-GRAPHICS-STATE) (SUPDUP-GRAPHICS-INPUT-STREAM)
  (DECLARE (SPECIAL SUPDUP-GRAPHICS-INPUT-STREAM))
  (CATCH 'SUPDUP-GRAPHICS
    (LOOP DOING
      (LET ((CH (SEND SELF ':GRAPHICS-NETI)))
	(LET ((COMMAND (IF (BIT-TEST CH #O100)
			   (AREF *DRAW-DISPATCH* (LOGAND CH #O017))
			   (AREF *GRAPHICS-DISPATCH* CH))))
	  (WHEN COMMAND (SEND SELF COMMAND CH))))))
  NIL)

;;; Subroutines for graphics commands.
(DEFMETHOD (:GRAPHICS-NETI SUPDUP-GRAPHICS-STATE) ()
  (DECLARE (SPECIAL SUPDUP-GRAPHICS-INPUT-STREAM))
  (LET ((CH (SEND SUPDUP-GRAPHICS-INPUT-STREAM ':TYI)))
    (WHEN (BIT-TEST CH #O200)
      (SEND SUPDUP-GRAPHICS-INPUT-STREAM ':UNTYI CH)
      (THROW 'SUPDUP-GRAPHICS T))
    CH))

(DEFMETHOD (:GRAPHICS-READ-POINT SUPDUP-GRAPHICS-STATE) (CH &AUX CH1 CH2 CH3 CH4)
  (COND ((BIT-TEST CH #O20)
	 (SETQ GRAPHICS-XPOS (14-BIT-SIGN-EXTEND (+ (SETQ CH1 (SEND SELF ':GRAPHICS-NETI))
						    (LSH (SETQ CH2
							       (SEND SELF ':GRAPHICS-NETI))
							 7))))
	 (SETQ GRAPHICS-YPOS (14-BIT-SIGN-EXTEND (+ (SETQ CH3 (SEND SELF ':GRAPHICS-NETI))
						    (LSH (SETQ CH4
							       (SEND SELF ':GRAPHICS-NETI))
							 7)))))
	(T
	 (INCF GRAPHICS-XPOS (SETQ CH1 (7-BIT-SIGN-EXTEND (SEND SELF ':GRAPHICS-NETI))))
	 (INCF GRAPHICS-YPOS (SETQ CH2 (7-BIT-SIGN-EXTEND (SEND SELF ':GRAPHICS-NETI)))))))

(DEFUN 7-BIT-SIGN-EXTEND (NUMBER)
  (COND ((BIT-TEST NUMBER #O100)
	 (- NUMBER #O200))
	(T NUMBER)))
  
(DEFUN 14-BIT-SIGN-EXTEND (NUMBER)
  (COND ((BIT-TEST NUMBER #O20000)
	 (- NUMBER #O40000))
	(T NUMBER)))

(DEFMACRO GRAPHICS-ALU (CH)
  `(COND (GRAPHICS-XOR-MODE :FLIP)
	 ((BIT-TEST ,CH #O40) :ERASE)
	 (T :DRAW)))

(DEFMACRO GRAPHICS-X-COORD (COORD)
  `(LET ((.COORD. ,COORD))
     (AND GRAPHICS-VIRTUAL-MODE
	  (SETQ .COORD. (FIXR (* .COORD. GRAPHICS-VIRT-SCALE))))
     (+ GRAPHICS-X-OFFSET (MIN GRAPHICS-RIGHT (MAX GRAPHICS-LEFT .COORD.)))))

(DEFMACRO GRAPHICS-Y-COORD (COORD)
  `(LET ((.COORD. ,COORD))
     (AND GRAPHICS-VIRTUAL-MODE
	  (SETQ .COORD. (FIXR (* .COORD. GRAPHICS-VIRT-SCALE))))
     (- GRAPHICS-Y-OFFSET (MIN GRAPHICS-TOP (MAX GRAPHICS-BOTTOM .COORD.)))))

(DEFMACRO GRAPHICS-Y-IN-RANGE ()
  `(LET ((.COORD. GRAPHICS-YPOS))
     (AND GRAPHICS-VIRTUAL-MODE
	  (SETQ .COORD. (FIXR (* .COORD. GRAPHICS-VIRT-SCALE))))
     ( GRAPHICS-BOTTOM .COORD. GRAPHICS-TOP)))

;Graphics commands.

(DEFMETHOD (:GRAPHICS-NOTHING SUPDUP-GRAPHICS-STATE) (IGNORE)
  NIL)

(DEFMETHOD (:GRAPHICS-XOR SUPDUP-GRAPHICS-STATE) (IGNORE)
  (SETQ GRAPHICS-XOR-MODE T))

(DEFMETHOD (:GRAPHICS-IOR SUPDUP-GRAPHICS-STATE) (IGNORE)
  (SETQ GRAPHICS-XOR-MODE NIL))

(DEFMETHOD (:GRAPHICS-VIRTUAL SUPDUP-GRAPHICS-STATE) (IGNORE)
  (SETQ GRAPHICS-VIRTUAL-MODE T))

(DEFMETHOD (:GRAPHICS-PHYSICAL SUPDUP-GRAPHICS-STATE) (IGNORE)
  (SETQ GRAPHICS-VIRTUAL-MODE NIL))

(DEFMETHOD (:GRAPHICS-MOVE SUPDUP-GRAPHICS-STATE) (CH)
  (SEND SELF ':GRAPHICS-READ-POINT CH))

(DEFMETHOD (:GRAPHICS-PUSH SUPDUP-GRAPHICS-STATE) (IGNORE)
  (LET-GLOBALLY ((GRAPHICS-XPOS GRAPHICS-XPOS)
		 (GRAPHICS-YPOS GRAPHICS-YPOS)
		 (GRAPHICS-RIGHT GRAPHICS-RIGHT)
		 (GRAPHICS-LEFT GRAPHICS-LEFT)
		 (GRAPHICS-TOP GRAPHICS-TOP)
		 (GRAPHICS-BOTTOM GRAPHICS-BOTTOM)
		 (GRAPHICS-XOR-MODE GRAPHICS-XOR-MODE)
		 (GRAPHICS-VIRTUAL-MODE GRAPHICS-VIRTUAL-MODE))
    (DO (CH) (())
      (SETQ CH (SEND SELF ':GRAPHICS-NETI))
      (LET ((COMMAND (IF (BIT-TEST CH #O100)
			 (AREF *DRAW-DISPATCH* (LOGAND CH #O017))
			 (AREF *GRAPHICS-DISPATCH* CH))))
	(WHEN COMMAND (SEND SELF COMMAND CH))))))

(DEFMETHOD (:GRAPHICS-LIMIT SUPDUP-GRAPHICS-STATE) (CH)
  (SEND SELF ':GRAPHICS-READ-POINT CH)
  (LET ((OXPOS GRAPHICS-XPOS) (OYPOS GRAPHICS-YPOS))
    (SEND SELF ':GRAPHICS-READ-POINT CH)
    (SETQ GRAPHICS-LEFT (MIN GRAPHICS-XPOS OXPOS)
	  GRAPHICS-RIGHT (MAX GRAPHICS-XPOS OXPOS)
	  GRAPHICS-BOTTOM (MIN GRAPHICS-YPOS OYPOS)
	  GRAPHICS-TOP (MAX GRAPHICS-YPOS OYPOS))))

;Drawing commands.

(DEFMETHOD (:GRAPHICS-DRAW-LINE SUPDUP-GRAPHICS-STATE) (CH)
  (LET ((OXPOS GRAPHICS-XPOS)
	(OYPOS GRAPHICS-YPOS))
    (SEND SELF ':GRAPHICS-READ-POINT CH)
    (SEND *VIEWPORT-STREAM* :DRAW-LINE
	  (GRAPHICS-X-COORD OXPOS) (GRAPHICS-Y-COORD OYPOS)
	  (GRAPHICS-X-COORD GRAPHICS-XPOS) (GRAPHICS-Y-COORD GRAPHICS-YPOS)
	  (GRAPHICS-ALU CH))))

(DEFMETHOD (:GRAPHICS-DRAW-POINT SUPDUP-GRAPHICS-STATE) (CH)
  (SEND SELF ':GRAPHICS-READ-POINT CH)
  (SEND *VIEWPORT-STREAM* :DRAW-POINT
	(GRAPHICS-X-COORD GRAPHICS-XPOS) (GRAPHICS-Y-COORD GRAPHICS-YPOS)
	(GRAPHICS-ALU CH)))

(DEFMETHOD (:GRAPHICS-DRAW-RECT SUPDUP-GRAPHICS-STATE) (CH)
  (LET ((OXPOS GRAPHICS-XPOS)
	(OYPOS GRAPHICS-YPOS))
    (SEND SELF ':GRAPHICS-READ-POINT CH)
    (SEND *VIEWPORT-STREAM* :DRAW-RECTANGLE
	  (ABS (1+ (- (GRAPHICS-X-COORD GRAPHICS-XPOS) (GRAPHICS-X-COORD OXPOS))))
	  (ABS (1+ (- (GRAPHICS-Y-COORD GRAPHICS-YPOS) (GRAPHICS-Y-COORD OYPOS))))
	  (MIN (GRAPHICS-X-COORD GRAPHICS-XPOS) (GRAPHICS-X-COORD OXPOS))
	  (MIN (GRAPHICS-Y-COORD GRAPHICS-YPOS) (GRAPHICS-Y-COORD OYPOS))
	  (GRAPHICS-ALU CH))))

(DEFMETHOD (:GRAPHICS-ERASE-SCREEN SUPDUP-GRAPHICS-STATE) (IGNORE)
  (SEND *VIEWPORT-STREAM* :CLEAR-REGION
	(GRAPHICS-X-COORD GRAPHICS-LEFT) (GRAPHICS-Y-COORD GRAPHICS-TOP)
	(1+ (GRAPHICS-X-COORD GRAPHICS-RIGHT)) (1+ (GRAPHICS-Y-COORD GRAPHICS-BOTTOM))))

(DEFMETHOD (:GRAPHICS-DRAW-STRING SUPDUP-GRAPHICS-STATE) (CH)
  (LET ((STRING (MAKE-ARRAY 64. ':TYPE 'ART-STRING ':FILL-POINTER 0)))
    (LOOP AS CH = (SEND SELF ':GRAPHICS-NETI)
	  UNTIL (ZEROP CH)
	  DOING (ARRAY-PUSH-EXTEND STRING (CODE-CHAR CH)))
    (SEND *VIEWPORT-STREAM* :DRAW-STRING STRING
	  (GRAPHICS-X-COORD GRAPHICS-XPOS) (GRAPHICS-Y-COORD GRAPHICS-YPOS)
	  (1+ (GRAPHICS-X-COORD GRAPHICS-XPOS)) (GRAPHICS-Y-COORD GRAPHICS-YPOS)
	  NIL NIL (GRAPHICS-ALU CH) )
    (RETURN-ARRAY STRING)))

(DEFMETHOD (:GRAPHICS-DRAW-BITS SUPDUP-GRAPHICS-STATE) (ALU-CH)
  (LOOP WITH BIT-CHANGE-FUNCTION = (GRAPHICS-ALU ALU-CH)
	FOR I FROM 1
	FOR CH = (SEND SELF ':GRAPHICS-NETI)
	UNTIL (BIT-TEST CH #O100)
	FOR NBITS = (IF (ZEROP (\ I 3)) 4 6)
	FOR X = (GRAPHICS-X-COORD GRAPHICS-XPOS)
	FOR Y = (GRAPHICS-Y-COORD GRAPHICS-YPOS)
	WHEN (GRAPHICS-Y-IN-RANGE)
	DO (DOTIMES (BIT NBITS)
	     (UNLESS ( GRAPHICS-XPOS GRAPHICS-RIGHT)
	       (WHEN (BIT-TEST (LSH 1 (- NBITS 1 BIT)) CH)
		 (SEND *VIEWPORT-STREAM* :DRAW-POINT (+ BIT X) Y BIT-CHANGE-FUNCTION 1))))
	DO (INCF GRAPHICS-XPOS NBITS)))

(DEFMETHOD (:GRAPHICS-DRAW-RUNS SUPDUP-GRAPHICS-STATE) (ALU-CH)
  (DO ((BIT-CHANGE-FUNCTION (GRAPHICS-ALU ALU-CH))
       (CH (SEND SELF :GRAPHICS-NETI) (SEND SELF :GRAPHICS-NETI)))
      ((ZEROP CH))
    (LET ((OLDX (GRAPHICS-X-COORD GRAPHICS-XPOS))
	  (Y (GRAPHICS-Y-COORD GRAPHICS-YPOS)))
      (INCF GRAPHICS-XPOS (LOGAND CH #O077))
      (WHEN (AND (BIT-TEST CH #O100)
		 (GRAPHICS-Y-IN-RANGE))
	(SEND *VIEWPORT-STREAM* :DRAW-LINE
	      OLDX Y
	      (MAX OLDX (1- (GRAPHICS-X-COORD GRAPHICS-XPOS))) Y
	      BIT-CHANGE-FUNCTION)))))

;;;; Various inferior substitutes for supdup graphics
;;; used by various suds crocks and macsyma.
;;; Don't say I didn't warn you.

;;; GT40 Simulator (used with the DEC simulator on I.T.S. for running SUDS)

;;; This crock maintains a display list for writing, erasing, and moving display objects
;;; consisting of characters, vectors, and points.  This protocol is not documented
;;; anywhere except in the code for DECUUO.

;; Dispatch table for the GT40 simulator.  These functions take one argument, the pc-ppr.
(DEFVAR *GT40-DISPATCH* (PREFILL-ARRAY 16.
	   '(:GT40-INSERT-OR-DELETE
	     :GT40-INSERT
	     :GT40-DELETE
;	     :GT40-RESET
;	     :GT40-TURN-ON
;	     :GT40-TURN-OFF
;	     :GT40-COPY
;	     :GT40-MOVE
;	     :GT40-MODE
;	     :GT40-APPEND
;	     :GT40-SUBROUTINIZE
;	     :GT40-UNSUBROUTINIZE
	     )))

;;; %TDMTN is a crock for simulating GT-40's, used by DECUUO on ITS for Imlacs...

(DEFMETHOD (:SUPDUP-GT40 SUPDUP-STATE-BLOCK) (GT40-INPUT-STREAM)
  (DECLARE (SPECIAL GT40-INPUT-STREAM))
  (LET ((BYTE (- (SEND GT40-INPUT-STREAM ':TYI) #O100)))
    (UNLESS (< BYTE 0)
      (LET ((MESSAGE (AREF *GT40-DISPATCH* (LOGAND #O017 BYTE))))
	(AND MESSAGE (SEND (SEND WINDOW ':GET-STATE-BLOCK ':GT40) MESSAGE)))))
  NIL)

(DEFINE-STATE-BLOCK-TYPE :GT40 GT40-STATE-BLOCK)

(DEFFLAVOR GT40-STATE-BLOCK
	((GT40-DISPLAY-LIST (MAKE-ARRAY 10. ':TYPE 'ART-Q-LIST))
	 (GT40-BLINKER NIL)
	 (GT40-CURRENT-ITEM-NUMBER NIL))
	(STATE-BLOCK))

(DEFMETHOD (:CLEAR-DISPLAY-LISTS GT40-STATE-BLOCK) ()
  (FILLARRAY GT40-DISPLAY-LIST '(NIL)))

;;; Macros used below to pack characters into words, decode vector formats, etc.

;;; Make a 16-bit "word" from 3 chars in 6-4-6 format
(DEFMACRO GT40-WORD ()
  '(LOCAL-DECLARE ((SPECIAL GT40-INPUT-STREAM))
     (DPB (SEND GT40-INPUT-STREAM ':TYI) (BYTE 6 0)
	  (DPB (SEND GT40-INPUT-STREAM ':TYI) (BYTE 4 6)
	       (DPB (SEND GT40-INPUT-STREAM ':TYI) (BYTE 6 10.) 0)))))

;;; Get a word count
(DEFMACRO GT40-COUNT () '(LSH (- (GT40-WORD) 5) -1))

;;; Used in constructing display objects - used only in GT40-INSERT.
(DEFMACRO APUSH (DOB ITEM) `(ARRAY-PUSH-EXTEND ,DOB ,ITEM 500.))

;;; Compute the index of the last thing pushed
(DEFMACRO GT40-LAST-INDEX (DOB) `(1- (ARRAY-ACTIVE-LENGTH ,DOB)))

;;; Get the last item pushed onto a display object
(DEFMACRO GT40-LAST-ITEM (DOB) `(AREF ,DOB (GT40-LAST-INDEX ,DOB)))

;;; Short vector format
(DEFMACRO GT40-SHORT (DOB WORD)
  `(PROGN
     (APUSH ,DOB (* (LDB (BYTE 6 7) ,WORD) (IF (BIT-TEST #O20000 ,WORD) -1 1)))
     (APUSH ,DOB (* (LDB (BYTE 6 0) ,WORD) (IF (BIT-TEST #O100 ,WORD) -1 1)))
     (APUSH ,DOB (BIT-TEST #O40000 ,WORD))))

;;; Long vector format
(DEFMACRO GT40-LONG (DOB WORD1 WORD2)
   `(LET ((WORD2 ,WORD2))
      (APUSH ,DOB (* (LOGAND #O1777 ,WORD1) (IF (BIT-TEST #O20000 ,WORD1) -1 1)))
      (APUSH ,DOB (* (LOGAND #O1777 WORD2) (IF (BIT-TEST #O20000 WORD2) -1 1)))
      (APUSH ,DOB (BIT-TEST #O40000 ,WORD1))))

;;; Coordinate scaling macro
(DEFMACRO GT40-COORD (X) `(MAX 0 (// (* 7 ,X) 10.)))

;;; Draw a string.  Note special end of line hackery.  XPOS and YPOS must be symbols.
(DEFMACRO GT40-DRAW-STRING (STRING XPOS YPOS STREAM)
  `(LET* ((MAX-Y (SEND ,STREAM :INSIDE-HEIGHT))
	  (X (GT40-COORD ,XPOS))
	  (Y (- MAX-Y (GT40-COORD ,YPOS) 11.)))
     (SEND ,STREAM :DRAW-STRING ,STRING X Y (1+ X) Y NIL NIL :FLIP)))

;;; Draw a vector.  XPOS and YPOS must be symbols
(DEFMACRO GT40-DRAW-VECTOR (XPOS YPOS X Y FLAG STREAM)
  `(LET ((MAX-Y (SEND ,STREAM :INSIDE-HEIGHT))
	 (OXPOS ,XPOS) (OYPOS ,YPOS))
     (SETQ ,XPOS (+ ,XPOS ,X) ,YPOS (+ ,YPOS ,Y))
     (WHEN ,FLAG
       (SEND ,STREAM :DRAW-LINE
	     (GT40-COORD OXPOS) (- MAX-Y (GT40-COORD OYPOS))
	     (GT40-COORD ,XPOS) (- MAX-Y (GT40-COORD ,YPOS))
	     :FLIP NIL))))

;;; Read a vector out of the display list and draw it
(DEFMACRO GT40-VECTOR (DOB XPOS YPOS STREAM)
  `(LET ((I (GT40-LAST-INDEX ,DOB)))
     (GT40-DRAW-VECTOR
      ,XPOS ,YPOS
      (AREF ,DOB (- I 2)) (AREF ,DOB (- I 1))	;new x y
      (AREF ,DOB I) ,STREAM)))			;visibility flag

;;; Display list format:  The display list is an ART-Q array of display objects, each of
;;; which is, in turn, an ART-Q array.  The format of display objects is a sequence of
;;; display items.  A display item is either a single string of characters or an in-line
;;; subsequence consisting of a symbol describing the item-type followed by 2 numbers (x,y)
;;; and a visibility flag.  Numbers and flags are repeated until a new symbol is encountered
;;; indicating a type change.

;;; GT40 Command 0 - Insert or delete display items
(DEFMETHOD (:GT40-INSERT-OR-DELETE GT40-STATE-BLOCK) ()
  (SELECTQ (LOGAND 3 (GT40-WORD))		;only 1 and 2 are recognized for now
    (1 (SEND SELF ':GT40-INSERT))		;insert a new display item
    (2 (SEND SELF ':GT40-DELETE (1+ (GT40-COUNT))))))	;delete n items

;;; GT40 Command 1 - Insert a display item into the display list.
(DEFMETHOD (:GT40-INSERT GT40-STATE-BLOCK) (&AUX (WORD-COUNT (GT40-COUNT)))
  (SEND SELF ':GT40-DELETE 1 NIL)	;Delete the item we are about to insert
  (DO ((I 0 (1+ I))			;Loop over words, contructing a display list
       (WORD) (MODE -1)			;Mode is initially undefined.
       (XPOS 0) (YPOS 0) (BLINK-THIS)
       (DOB				;Display OBject
	(OR (AREF GT40-DISPLAY-LIST GT40-CURRENT-ITEM-NUMBER)	;Already an array or cons an
	    (ASET (MAKE-ARRAY 200. ':LEADER-LENGTH 2 ':FILL-POINTER 0)	;array with leader
		  GT40-DISPLAY-LIST GT40-CURRENT-ITEM-NUMBER))))	;and install it
      (( I WORD-COUNT)
       (IF (= 0 MODE)			; was char mode, display the string
	   (GT40-DRAW-STRING (GT40-LAST-ITEM DOB) XPOS YPOS *VIEWPORT-STREAM*))
       (IF BLINK-THIS (STORE-ARRAY-LEADER 'ON DOB 1)))
    (SETQ WORD (GT40-WORD))
    (COND ((BIT-TEST #O100000 WORD)	;If command, only look at blink bit and mode
	   (IF (NOT (BIT-TEST #O40000 WORD))	;ignore words with the 40000 bit on
	       (LET ((NMODE (LDB (BYTE 3 11.) WORD))
		     (BLINK-FLAG (AND (BIT-TEST #O20 WORD) (BIT-TEST #O10 WORD))))
		  (COND ((NOT (= MODE NMODE))	;get the new datatype mode
			 (IF (= 0 MODE)	; was char mode, display the string
			     (GT40-DRAW-STRING (GT40-LAST-ITEM DOB) XPOS YPOS
					       *VIEWPORT-STREAM*))
			 (SETQ MODE NMODE)
			 (APUSH DOB (SELECTQ MODE	;initializings
				      (0 (MAKE-ARRAY 10. ':TYPE 'ART-STRING ':FILL-POINTER 0))
				      (1 'VECTOR)
				      (2 'VECTOR)
				      (3 'POINT)
				      (6 'RPOINT)
				      ((4 5 7) 'UNKNOWN)))))
		  (COND (BLINK-FLAG
			 (OR GT40-BLINKER
			     (SETQ GT40-BLINKER (TV:MAKE-BLINKER *TERMINAL-SCREEN*
								 'GT40-BLINKER
								 ':GT40-DISPLAY-LIST
								   GT40-DISPLAY-LIST)))
			 (SETQ BLINK-THIS T))))))
	  (T (SELECTQ MODE
	       (0 (DO ((CHAR (LDB (BYTE 7 0) WORD) (LDB (BYTE 7 8) WORD))	;character mode
		       (STRING (GT40-LAST-ITEM DOB))
		       (I 0 (1+ I)))
		      ((= I 2))
		      (OR (= 0 CHAR) (= #O017 CHAR)
			  (ARRAY-PUSH-EXTEND STRING (CODE-CHAR CHAR)))))
	       (1 (GT40-SHORT DOB WORD)	;short vector
		  (GT40-VECTOR DOB XPOS YPOS *VIEWPORT-STREAM*))
	       (2 (SETQ I (1+ I))	;long vector
		  (GT40-LONG DOB WORD (GT40-WORD))
		  (GT40-VECTOR DOB XPOS YPOS *VIEWPORT-STREAM*))
	       (3 (SETQ I (1+ I))	;point data
		  (GT40-LONG DOB WORD (GT40-WORD))
		  (LET ((I (GT40-LAST-INDEX DOB)))
		       (SETQ XPOS (AREF DOB (- I 2))
			     YPOS (AREF DOB (- I 1)))
		       (GT40-DRAW-VECTOR XPOS YPOS 0 0 (AREF DOB I) *VIEWPORT-STREAM*)))
	       (4)			;graphplot x data (not used)
	       (5)			;graphplot y data (not used)
	       (6 (GT40-SHORT DOB WORD)	;relative point data
		  (LET ((I (GT40-LAST-INDEX DOB)))
		       (SETQ XPOS (+ XPOS (AREF DOB (- I 2)))
			     YPOS (+ YPOS (AREF DOB (- I 1))))
		       (GT40-DRAW-VECTOR XPOS YPOS 0 0 (AREF DOB I) *VIEWPORT-STREAM*)))
	       (7)))))			;not used
  (GT40-WORD))				;gobble the checksum

;;; GT40 Command 2 - Delete a display item from the display list
(DEFMETHOD (:GT40-DELETE GT40-STATE-BLOCK) (&OPTIONAL (NITEMS 1) (CHECKSUM-FLAG T))
  (DO ((I 0 (1+ I)) (DOB) (ITEM-NUMBER))
      (( I NITEMS))
    (SETQ ITEM-NUMBER (GT40-WORD)
	  GT40-CURRENT-ITEM-NUMBER ITEM-NUMBER	;record item # being hacked
	  DOB (AREF GT40-DISPLAY-LIST ITEM-NUMBER))
    (IF DOB (PROGN (OR (EQ 'OFF (ARRAY-LEADER DOB 1))	;don't erase if its already off
		       (GT40-DISPLAY-ITEM DOB *VIEWPORT-STREAM*))
		   (FILLARRAY DOB '(NIL))
		   (STORE-ARRAY-LEADER 0 DOB 0)	;zero the fill pointer
		   (STORE-ARRAY-LEADER NIL DOB 1))))	;blinking is off
  (IF CHECKSUM-FLAG (GT40-WORD)))		;gobble the checksum

;;; Display a display item.
(DEFUN GT40-DISPLAY-ITEM (DOB STREAM)
  (DO ((I 0 (1+ I))
       (END (ARRAY-ACTIVE-LENGTH DOB))
       (ITEM) (X) (Y) (FLAG) (XPOS 0) (YPOS 0))
      ((>= I END))
    (SETQ ITEM (AREF DOB I))
    (COND ((STRINGP ITEM) (GT40-DRAW-STRING ITEM XPOS YPOS STREAM))
	  ((EQ 'UNKNOWN ITEM))		;ignore
	  (T (DO NIL
		 ((OR (<= (- END I) 3)
		      (SYMBOLP (AREF DOB (1+ I)))
		      (STRINGP (AREF DOB (1+ I)))))
		 (SETQ I (+ 3 I)
		       X    (AREF DOB (- I 2))
		       Y    (AREF DOB (- I 1))
		       FLAG (AREF DOB I))
		 (SELECTQ ITEM
		   (VECTOR (GT40-DRAW-VECTOR XPOS YPOS X Y FLAG STREAM))
		   (POINT (SETQ XPOS X YPOS Y)
			  (GT40-DRAW-VECTOR XPOS YPOS 0 0 FLAG STREAM))
		   (RPOINT (SETQ XPOS (+ XPOS X) YPOS (+ YPOS Y))
			   (GT40-DRAW-VECTOR XPOS YPOS 0 0 FLAG STREAM))))))))

(DEFFLAVOR GT40-BLINKER (GT40-DISPLAY-LIST) (TV:BLINKER)
  (:INITABLE-INSTANCE-VARIABLES GT40-DISPLAY-LIST))

;;; Blink a display item
(DEFMETHOD (:BLINK GT40-BLINKER) ()
  (LET-GLOBALLY ((TV:PHASE NIL))
    (DO ((ITEM (G-L-P GT40-DISPLAY-LIST) (CDR ITEM))
	 (BLINK-FLAG NIL NIL)
	 (DITEM))
	((NULL ITEM))
      (SETQ DITEM (CAR ITEM))
      (IF DITEM (SETQ BLINK-FLAG (ARRAY-LEADER DITEM 1)))
      (IF (MEMQ BLINK-FLAG '(ON OFF))
	  (PROGN (GT40-DISPLAY-ITEM DITEM (SEND TV:SHEET :VIEWPORT-STREAM))
		 (STORE-ARRAY-LEADER (SELECTQ BLINK-FLAG (ON 'OFF) (OFF 'ON)) DITEM 1))))))

(DEFMETHOD (:SIZE GT40-BLINKER) ()
  (VALUES (TV:SHEET-INSIDE-WIDTH TV:SHEET) (TV:SHEET-INSIDE-HEIGHT TV:SHEET)))

;;; ARDS simulator (for compatibility with PTV's)

;;; Todo: scaling and offset doesn't work right in this version...
;;;       SHOULD SEND LINE DRAWING MESSAGES RATHER THAN CALLING %DRAW-LINE

(DEFMETHOD (:SUPDUP-ARDS-SET SUPDUP-STATE-BLOCK) (ARDS-INPUT-STREAM)
  (DECLARE (SPECIAL ARDS-INPUT-STREAM))
  (SEND (SEND WINDOW ':GET-STATE-BLOCK ':ARDS) ':ARDS-SET)
  NIL)

(DEFMETHOD (:SUPDUP-ARDS-LONG SUPDUP-STATE-BLOCK) (ARDS-INPUT-STREAM)
  (DECLARE (SPECIAL ARDS-INPUT-STREAM))
  (SEND (SEND WINDOW ':GET-STATE-BLOCK ':ARDS) ':ARDS-LONG)
  NIL)

(DEFMETHOD (:SUPDUP-ARDS-SHORT SUPDUP-STATE-BLOCK) (ARDS-INPUT-STREAM)
  (DECLARE (SPECIAL ARDS-INPUT-STREAM))
  (SEND (SEND WINDOW ':GET-STATE-BLOCK ':ARDS) ':ARDS-SHORT)
  NIL)

(DEFINE-STATE-BLOCK-TYPE :ARDS ARDS-STATE-BLOCK)

(DEFFLAVOR ARDS-STATE-BLOCK
	((ARDS-XPOS 0)				;current pos in ARDS coordinates
	 (ARDS-YPOS 0)
	 (ARDS-SCALE 1.0)
	 (ARDS-SCR-XPOS 0)			;current pos in screen coordinates
	 (ARDS-SCR-YPOS 0))
	(STATE-BLOCK))

;;; Setup scaling and offsets, then loop until exit condition
(DEFMACRO ARDS-LOOP (&REST BODY)
  `(LET* ((ARDS-MAX-X (TV:SHEET-INSIDE-RIGHT *TERMINAL-SCREEN*))
	  (ARDS-MAX-Y (TV:SHEET-INSIDE-BOTTOM *TERMINAL-SCREEN*))
	  (ARDS-X-OFFSET 0)
	  (ARDS-Y-OFFSET 0)
	  (ARDS-SCR-SCALE (* ARDS-SCALE (// (MIN (TV:SHEET-INSIDE-WIDTH *TERMINAL-SCREEN*)
						 (TV:SHEET-INSIDE-HEIGHT *TERMINAL-SCREEN*))
					    1023.0)))
	  (ARDS-CENTER-OFFSET (// (1+ (- (MAX (TV:SHEET-INSIDE-WIDTH *TERMINAL-SCREEN*)
					      (TV:SHEET-INSIDE-HEIGHT *TERMINAL-SCREEN*))
					 (MIN (TV:SHEET-INSIDE-WIDTH *TERMINAL-SCREEN*)
					      (TV:SHEET-INSIDE-HEIGHT *TERMINAL-SCREEN*))))
				  2))
	  (ARDS-FLAG NIL))
     (IF (< (TV:SHEET-INSIDE-WIDTH *TERMINAL-SCREEN*)
	    (TV:SHEET-INSIDE-HEIGHT *TERMINAL-SCREEN*))
	 (SETQ ARDS-MAX-Y (- ARDS-MAX-Y ARDS-CENTER-OFFSET))
	 (SETQ ARDS-X-OFFSET (+ ARDS-X-OFFSET ARDS-CENTER-OFFSET)))
     (CATCH 'ARDS-RETURN
       (DO NIL (NIL) ,@BODY))))

;;; Convert -512./511. to 0/1023. and scale if the user wants it.
(DEFMACRO ARDS-COORD (X)
  `(MAX 1 (FIX (+ .5 (* ARDS-SCR-SCALE (+ 512. ,X))))))

;;; Get a character and punt out of graphics mode if it is a control char or %TD code
(DEFMACRO ARDS-GET ()
  `(LOCAL-DECLARE ((SPECIAL ARDS-INPUT-STREAM))
     (LET ((X (SEND ARDS-INPUT-STREAM ':TYI)))
       (IF (OR (< X #O100) (> X #O177))
	   (THROW 'ARDS-RETURN
		   (PROGN (FUNCALL ARDS-INPUT-STREAM ':UNTYI X)
			  (SEND *VIEWPORT-STREAM* ':SET-CURSORPOS
				ARDS-SCR-XPOS (- ARDS-SCR-YPOS 11.)))))
       X)))

;;; Unpack long and short format coordinates
(DEFMACRO ARDS-LONG (F)
  `(LET ((A (ARDS-GET)) (B (ARDS-GET)))
     ,(IF F '(SETQ ARDS-FLAG (NOT (BIT-TEST B #O40))))
     (* (IF (BIT-TEST A 1) -1 1)
	(LOGIOR (LSH (LOGAND #O77 A) -1) (LSH (LOGAND #O37 B) 5)))))

(DEFMACRO ARDS-SHORT ()
  `(LET ((A (ARDS-GET)))
     (SETQ ARDS-FLAG T)
     (* (IF (BIT-TEST A 1) -1 1)
	(LSH (LOGAND #O77 A) -1))))

;;; Draw a vector
(DEFMACRO ARDS-VECTOR (DX DY)
  `(LET ((X0 ARDS-XPOS) (Y0 ARDS-YPOS))
     (SETQ ARDS-XPOS (+ ARDS-XPOS ,DX)
	   ARDS-YPOS (+ ARDS-YPOS ,DY)
	   ARDS-SCR-XPOS (MIN ARDS-MAX-X (+ ARDS-X-OFFSET (ARDS-COORD ARDS-XPOS)))
	   ARDS-SCR-YPOS (MAX ARDS-Y-OFFSET (- ARDS-MAX-Y (ARDS-COORD ARDS-YPOS))))
     (IF ARDS-FLAG
	 (SEND *VIEWPORT-STREAM* :DRAW-LINE
	       (MIN ARDS-MAX-X (+ ARDS-X-OFFSET (ARDS-COORD X0)))
	       (MAX ARDS-Y-OFFSET (- ARDS-MAX-Y (ARDS-COORD Y0)))
	       ARDS-SCR-XPOS ARDS-SCR-YPOS
	       TV:ALU-IOR))))

(DEFMETHOD (:ARDS-SET ARDS-STATE-BLOCK) ()
  (ARDS-LOOP
    (SETQ ARDS-XPOS (ARDS-LONG T) ARDS-YPOS (ARDS-LONG NIL))
    (ARDS-VECTOR 0 0)))		;for plotting points

(DEFMETHOD (:ARDS-LONG ARDS-STATE-BLOCK) ()
  (ARDS-LOOP (ARDS-VECTOR (ARDS-LONG T) (ARDS-LONG NIL))))

(DEFMETHOD (:ARDS-SHORT ARDS-STATE-BLOCK) ()
  (ARDS-LOOP (ARDS-VECTOR (ARDS-SHORT) (ARDS-SHORT))))

;;; Kludge for Foonex SUDS output

;; %TDGFX==240			;Enter graphics mode
;; Next byte display item number (pog) in low 7 bits
;; 0 => no display item (i.e. not remembered)
;; 100 bit => delete this item
;; 200 bit => blink this item

;; Following bytes <opcode> <args> ...
;; ended by %GREND (below)

;; %GRCMD==200			;On means this is command char, off is regular
;;				;char
;; %GRDCM==100			;This is a draw command
;;				; if off, interpreted via bit mask of visible,
;;				; absolute, point, etc.
;; %GRVIS==040			;This is visible
;; %GRABS==020			;Absolute addressing
;; %GRVEC==010			;Vector rather than point
;;
;; These take four following bytes of <DXL> <DXH> <DYL> <DYH>
;;
;; Draw commands
;; %GRSSZ==300			;Set size <SIZE> in next byte, 0 origin
;;				;0 => infinitely small
;; %GRSIN==301			;Set intensity <SIZE> in next byte, 0 origin
;;				;0 => invisible
;; %GREND==302			;End of display mode
;; %GRCLR==303			;Clear display

(DEFMETHOD (:SUPDUP-SUDS SUPDUP-STATE-BLOCK) (INPUT-STREAM)
  (SEND (SEND WINDOW ':GET-STATE-BLOCK ':SUDS) ':SUDS INPUT-STREAM)
  NIL)

(DEFINE-STATE-BLOCK-TYPE :SUDS SUDS-STATE-BLOCK)

(DEFFLAVOR SUDS-STATE-BLOCK
	((SUDS-DISPLAY-LIST (MAKE-ARRAY 10. ':TYPE 'ART-Q-LIST))
	 (SUDS-BLINKER NIL))
	(STATE-BLOCK))

;;; Foonex SUDS assumes TV's with a 576. x 454. pixel grid and assumes chars which are 10. x 6
;;; On LM-2's, we use .5x scaling and offset the picture from the top left corner by
;;; SUDS-X-OFFSET and SUDS-Y-OFFSET.  The echo area is whatever is left on the screen
;;; below this.  There is no attempt to automatically compensate for window size
;;; changes (this kludge only works really if you have a full screen width window
;;; and it must be at least 500. pixels high.  On the 3600 we should have .5x and 1x
;;; scale options with appropriate fonts and offsets.

(DEFVAR SUDS-X-MAX (- (TV:SHEET-INSIDE-RIGHT TV:MAIN-SCREEN)
		      (TV:SHEET-INSIDE-LEFT TV:MAIN-SCREEN)))
(DEFVAR SUDS-Y-MAX (- (TV:SHEET-INSIDE-BOTTOM TV:MAIN-SCREEN)
		      (TV:SHEET-INSIDE-TOP TV:MAIN-SCREEN)))
(DEFVAR SUDS-X-OFFSET #+CADR 86. #-CADR 256.)
(DEFVAR SUDS-Y-OFFSET 50.)
(DEFVAR SUDS-MAX-Y-OFFSET 50.)
(DEFVAR SUDS-SCALE-SHIFT -1)			;must be -1 (.5x) or 0 (1x)
(DEFVAR SUDS-STYLE '(:FIX :ROMAN :SMALL))
(DEFVAR SUDS-BLINKER-LOCK NIL)

(DEFMACRO SUDS-X (X)
  `(MIN SUDS-X-MAX (MAX 0 (+ SUDS-X-OFFSET (ASH (1+ (+ ,X 512.)) SUDS-SCALE-SHIFT)))))

(DEFMACRO SUDS-Y (Y)
  `(MIN SUDS-Y-MAX (MAX 0 (+ SUDS-Y-OFFSET (ASH (1+ (- 512. ,Y)) SUDS-SCALE-SHIFT)))))

;;; Gobble 2 bytes to make a single 16-bit signed number, open code for speed.
(DEFMACRO SUDS-ARG ()
  '(LET ((LOW (SEND SUDS-INPUT-STREAM ':TYI)))
     (LET ((HI (SEND SUDS-INPUT-STREAM ':TYI)))
       (LET ((X (DPB HI (BYTE 8 8) LOW)))
	 (IF (BIT-TEST #O100000 X) (- X #O200000)
	     X)))))

(DEFMETHOD (:SETUP SUDS-STATE-BLOCK) ()
  (SEND *TERMINAL-SCREEN* ':SET-ECHO-POSITION 0)
  (SETQ SUDS-X-OFFSET (MAX 0 (ASH (- (TV:SHEET-INSIDE-RIGHT *TERMINAL-SCREEN*)
				     (TV:SHEET-INSIDE-LEFT *TERMINAL-SCREEN*) 576.) -1))
	SUDS-Y-OFFSET (MIN SUDS-MAX-Y-OFFSET
			   (MAX 0 (ASH (- (TV:SHEET-INSIDE-BOTTOM *TERMINAL-SCREEN*)
					  (TV:SHEET-INSIDE-TOP *TERMINAL-SCREEN*) 512.) -1)))
	SUDS-X-MAX (- (TV:SHEET-INSIDE-RIGHT *TERMINAL-SCREEN*)
		      (TV:SHEET-INSIDE-LEFT *TERMINAL-SCREEN*))
	SUDS-Y-MAX (- (TV:SHEET-INSIDE-BOTTOM *TERMINAL-SCREEN*)
		      (TV:SHEET-INSIDE-TOP *TERMINAL-SCREEN*))))

;;; display commands
(DEFCONSTANT %GRSIZ #O300)			;set character size for a string (not used)
(DEFCONSTANT %GRSIN #O301)			;set character intensity for a string (not used)
(DEFCONSTANT %GREND #O302)			;end of display protocol bytes
(DEFCONSTANT %GRCLR #O303)			;clear the screen
(DEFCONSTANT %GRECH #O304)			;set the y position of the top of the echo or type-in area

(DEFMETHOD (:SUDS SUDS-STATE-BLOCK) (SUDS-INPUT-STREAM)
  (DECLARE (SPECIAL SUDS-INPUT-STREAM))
  (LOOP WITH SUDS-BLINKER-LOCK = T
	WITH FIRST-BYTE = (SEND SUDS-INPUT-STREAM ':TYI)
	WITH BLINK-P = (BIT-TEST #O200 FIRST-BYTE)	;should item be a blinker
	WITH DELETE-P = (BIT-TEST #O100 FIRST-BYTE)	;should item be deleted
	WITH ITEM-NUMBER = (LOGAND #O077 FIRST-BYTE)	;item being sent
	WITH DOB = (AND BLINK-P			;if to be saved, get one or make one
			(OR (AREF SUDS-DISPLAY-LIST ITEM-NUMBER)
			    (ASET (MAKE-ARRAY 200. ':LEADER-LENGTH 2 ':FILL-POINTER 0)
				  SUDS-DISPLAY-LIST ITEM-NUMBER)))
	INITIALLY
	  (IF (= %GREND FIRST-BYTE) (RETURN))	;punt immediately if we get this
	  (IF (AND DELETE-P BLINK-P)
	      (RETURN (SUDS-DELETE DOB *TERMINAL-SCREEN*)))	;if deleting, go do that
	  (WHEN DOB
	    (FILLARRAY DOB '(NIL))		;clear out the array
	    (STORE-ARRAY-LEADER 0 DOB 0))	;zero the fill pointer

	WITH XPOS = 0
	WITH YPOS = 0
	WITH SIZE = 0
	WITH INTENSITY = 0

	;; Now that the environment is set up, loop over opcode,arg groups
	FOR OPCODE = (SEND SUDS-INPUT-STREAM ':TYI)	;first byte is an opcode
	UNTIL (= %GREND OPCODE)			;keep going until the end command is received
	DO (COND ((NOT (BIT-TEST #O200 OPCODE))	;regular character if 200 bit not on
		  (LOOP WITH STRING = (MAKE-ARRAY 10. ':TYPE 'ART-STRING ':FILL-POINTER 0)
			FOR CHAR = OPCODE THEN (SEND SUDS-INPUT-STREAM ':TYI)
			UNTIL (BIT-TEST #O200 CHAR)	;loop until a non-character appears
			DO (OR (= 0 CHAR) (= #O017 CHAR)
			       (ARRAY-PUSH-EXTEND STRING (CODE-CHAR CHAR) 10.))
			FINALLY
			  (FUNCALL SUDS-INPUT-STREAM ':UNTYI CHAR)
			  (WHEN DOB
			    (APUSH DOB STRING)	;save the string and position
			    (APUSH DOB XPOS)
			    (APUSH DOB YPOS)
			    (APUSH DOB SIZE)
			    (APUSH DOB INTENSITY))
			  (SUDS-DRAW-STRING STRING XPOS YPOS SIZE INTENSITY
					    *VIEWPORT-STREAM*)
			  (SETQ XPOS (+ XPOS (* (* (1+ SIZE) 6) (STRING-LENGTH STRING))))))
		 ((NOT (BIT-TEST #O100 OPCODE))
		  (LET ((VISIBLE (BIT-TEST #O040 OPCODE))
			(ABSOLUTE (BIT-TEST #O020 OPCODE))
			(VECTOR (BIT-TEST #O010 OPCODE))
			(X (SUDS-ARG))
			(Y (SUDS-ARG)))
		    (IF (NOT ABSOLUTE)
			(SETQ X (+ X XPOS) Y (+ Y YPOS)))	;make X,Y the target	
		    (IF (NOT VECTOR) (SETQ XPOS X YPOS Y))	;just plot a point
		    (WHEN VISIBLE
		      (SUDS-DRAW-LINE XPOS X YPOS Y *VIEWPORT-STREAM*)
		      (WHEN DOB
			(APUSH DOB 'LINE)
			(APUSH DOB X)
			(APUSH DOB XPOS)
			(APUSH DOB Y)
			(APUSH DOB YPOS)))
		    (SETQ XPOS X YPOS Y)))
		 ((= %GRCLR OPCODE)		;just clear the screen
		  (SEND (SEND WINDOW ':GET-STATE-BLOCK ':SUPDUP) ':SUPDUP-CLEAR))
		 ((= %GRSIN OPCODE)		;set the current char intensity
		  (SETQ INTENSITY (LOGAND #O077 (SEND SUDS-INPUT-STREAM ':TYI))))
		 ((= %GRSIZ OPCODE)		;set the current char size
		  (SETQ SIZE (LOGAND #O007 (SEND SUDS-INPUT-STREAM ':TYI))))
		 ((= %GRECH OPCODE)		;set echo area size
		  (SEND *TERMINAL-SCREEN* ':SET-ECHO-POSITION
			(LET ((Y (SUDS-Y (SUDS-ARG))))
			  (IF ( Y SUDS-Y-OFFSET) 0 (MIN (- SUDS-Y-MAX 20.)
							 (+ SUDS-Y-OFFSET Y)))))))
	FINALLY (WHEN BLINK-P
		  (STORE-ARRAY-LEADER 'ON DOB 1)
		  (UNLESS SUDS-BLINKER
		    (SETQ SUDS-BLINKER (TV:MAKE-BLINKER *TERMINAL-SCREEN* 'SUDS-BLINKER
							':SUDS-DISPLAY-LIST
							SUDS-DISPLAY-LIST)))))
  NIL)

(DEFUN SUDS-DELETE (DOB WINDOW &AUX (BLINK-FLAG (ARRAY-LEADER DOB 1)))
  (DECLARE (SPECIAL SUDS-INPUT-STREAM))
  (STORE-ARRAY-LEADER NIL DOB 1)		;blinking is off immediately, in case the blinker blinks
  (UNLESS (EQ 'OFF BLINK-FLAG)			;unless it was already turned off,
    (SUDS-DISPLAY-ITEM DOB WINDOW))		;erase by displaying again with xor
  (FILLARRAY DOB '(NIL))			;clear out the array
  (STORE-ARRAY-LEADER 0 DOB 0)			;zero the fill pointer
  (LOOP UNTIL (= (SEND SUDS-INPUT-STREAM ':TYI) %GREND))
  )
  
(DEFUN SUDS-DISPLAY-ITEM (DOB STREAM)
  (LOOP WITH END = (ARRAY-ACTIVE-LENGTH DOB)
	FOR I FROM 0 BY 5 BELOW END
	FOR ITEM = (AREF DOB I)
	DO (COND ((NULL ITEM) (RETURN T))	;stop as soon as we hit a null entry
		 ((STRINGP ITEM)
		  (SUDS-DRAW-STRING ITEM (AREF DOB (1+ I)) (AREF DOB (+ 2 I))
				    (AREF DOB (+ 3 I)) (AREF DOB (+ 4 I)) STREAM))
		 ((EQ 'LINE ITEM)
		  (SUDS-DRAW-LINE (AREF DOB (1+ I)) (AREF DOB (+ 2 I)) (AREF DOB (+ 3 I))
				  (AREF DOB (+ 4 I)) STREAM))
		 (T (FERROR "~&Unrecognized display list item in SUDS display list: ~S"
			    ITEM)))))

(DEFUN SUDS-DRAW-STRING (STRING X Y SIZE INTENSITY STREAM)
  SIZE INTENSITY
  (LET ((X (SUDS-X X)) (Y (MAX 0 (- (SUDS-Y Y) 9.))))
    (SEND STREAM :DRAW-STRING STRING X Y (1+ X) Y NIL SUDS-STYLE :FLIP)))

(DEFUN SUDS-DRAW-LINE (X1 X2 Y1 Y2 STREAM)
  (SEND STREAM :DRAW-LINE (SUDS-X X1) (SUDS-Y Y1) (SUDS-X X2) (SUDS-Y Y2) :FLIP))

(DEFFLAVOR SUDS-BLINKER (SUDS-DISPLAY-LIST) (TV:BLINKER)
  (:INITABLE-INSTANCE-VARIABLES SUDS-DISPLAY-LIST))

;;; Blink a display item
(DEFMETHOD (:BLINK SUDS-BLINKER) ()
  (AND (NOT SUDS-BLINKER-LOCK)
       (LET-GLOBALLY ((TV:PHASE NIL))
	 (LOOP FOR ITEM IN (G-L-P SUDS-DISPLAY-LIST)
	       FOR BLINK-FLAG = (AND ITEM (ARRAY-LEADER ITEM 1))
	       WHEN (MEMQ BLINK-FLAG '(ON OFF))
	       DO (SUDS-DISPLAY-ITEM ITEM (SEND TV:SHEET :VIEWPORT-STREAM))
	       (STORE-ARRAY-LEADER (SELECTQ BLINK-FLAG (ON 'OFF) (OFF 'ON)) ITEM 1)))))

(DEFMETHOD (:SIZE SUDS-BLINKER) ()
  (VALUES (TV:SHEET-INSIDE-WIDTH TV:SHEET) (TV:SHEET-INSIDE-HEIGHT TV:SHEET)))

(DEFMETHOD (:CLEAR-DISPLAY-LISTS SUDS-STATE-BLOCK) ()
  (FILLARRAY SUDS-DISPLAY-LIST '(NIL)))

;;; Terminals based on ANSI X3.64 (ISO DP 6429).
;;; An escape sequence is of the form
;;;  ESC (1/11) I...I F where I are intermediate codes between SP (2/0) and / (2/15),
;;;   and F is the final code between 0 (3/0) and ~ (7/14).
;;; A control sequence is an escape sequence using final code [ (CSI 5/11)
;;;  ESC CSI P...P I...I F where P are parameter codes between 0 (3/0) and ? (3/15),
;;;  and F is the final code between @ (4/0) and ~ (7/14).

;;; We parse a subset of this by checking for the standard parameter format introduced by
;;; a code between 3/0 and 3/11.  We do not check for intermediate codes in any special way.
;;; We do not attempt to parse private parameters introduced by codes from 3/12 to 3/15.
;;; These are passed as commands which must be handled by the specific flavor.  For instance,
;;; the VT100 ? parameters and the Ann Arbor > parameters.  The alternative would be to
;;; parse them into strings, or assume that the format is still the same and the additional
;;; character is only used to widen the parameter number space, or to have the default handler
;;; parse and discard.

;;; Defined but unimplemented sequences are noted in the comments.

(DEFFLAVOR ANSI-TERMINAL-SIMULATOR
	;; Character set stuff from ISO 6937/2, used by Ann Arbor and VT100.
	((CHARACTER-SETS (LET ((SETS (MAKE-ARRAY 4)))
			   (SETF (AREF SETS 1)
				 (SI:PARSE-CHARACTER-STYLE
				   '(:DEVICE-FONT FONTS:VT100 :NORMAL)))
			   SETS))
	 (SELECTED-CHARACTER-SET 0))
	(TERMINAL-SIMULATOR))

(DEFMETHOD (:FILTER ANSI-TERMINAL-SIMULATOR) (CH)
  (COND ((= CH #o033)
	 (SEND SELF :HANDLE-ESCAPE))
	((OR (= CH 0) (= CH #o177))
	 NIL)					;Ignore padding
	(T
	 (DEFAULT-TERMINAL-SIMULATOR CH))))

(DEFMETHOD (:FAST-FILTER-TEST ANSI-TERMINAL-SIMULATOR) ()
  #'(LAMBDA (CH)
      ;; This is a condensation of the characters that
      ;; DEFAULT-TERMINAL-SIMULATOR will actually do anything about
      ;; (note that non-zero selected char set means all chars are
      ;; subject to translation; with the old filter you would lose if
      ;; you selected another char set and were in fast mode); plus the
      ;; three characters called out by the ANSI-TERMINAL-SIMULATOR
      ;; :FILER method.  If there were a way to compose filter
      ;; construction, the selector clause should really come from the
      ;; fast-filter test of the NULL-TERMINAL-SIMULATOR.
      (SELECTOR (LOGAND CH #O177) =
	(((ASCII-CODE :BEL)
	  (ASCII-CODE :LF)
	  (ASCII-CODE :CR)
	  (ASCII-CODE :BS)
	  (ASCII-CODE :TAB)
	  (ASCII-CODE :FF)
	  (ASCII-CODE :SI)
	  (ASCII-CODE :SO)
	  (ASCII-CODE :ESC)
	  (ASCII-CODE :NUL)
	  (ASCII-CODE :DEL)) T)
	(T 
	  ;; if current selected character set is non-nil, might have to
	  ;; treat this char special, so return T
	  (AND (AREF CHARACTER-SETS SELECTED-CHARACTER-SET)
	       T)))))

(DEFMETHOD (:SHIFT-IN ANSI-TERMINAL-SIMULATOR) ()
  (SETQ SELECTED-CHARACTER-SET 0))

(DEFMETHOD (:SHIFT-OUT ANSI-TERMINAL-SIMULATOR) ()
  (SETQ SELECTED-CHARACTER-SET 1))

(DEFMETHOD (:TRANSLATE-GRAPHIC-CHAR ANSI-TERMINAL-SIMULATOR) (CODE)
  (LET ((SET (AREF CHARACTER-SETS SELECTED-CHARACTER-SET)))
    (IF (NULL SET)
	(CODE-CHAR CODE)
	;;+++ Really, this should use an alternate character set, but that's much harder
	;;than this style.
	(SI:MAKE-MERGED-CHAR (CODE-CHAR CODE) SET))))

(DEFMETHOD (:HANDLE-ESCAPE ANSI-TERMINAL-SIMULATOR) ()
  (SEND OUTPUT-STREAM :FORCE-OUTPUT)
  (LET ((CH (ASCII-TO-CHAR (SEND INPUT-STREAM :TYI)))
	(CSI-P NIL)
	(PARAMS NIL))
    (WHEN (CHAR= CH #/[)	;CSI control sequence introducer
      (SETQ CSI-P T)
      (MULTIPLE-VALUE (CH PARAMS)
	(SEND SELF :PARSE-PARAMETERS)))
    (LEXPR-SEND SELF :HANDLE-ESCAPE-COMMAND CSI-P CH PARAMS))
  NIL)

(DEFMETHOD (:PARSE-PARAMETERS ANSI-TERMINAL-SIMULATOR) (&AUX CH PARAM PARAMS DIGIT)
  (LOOP DOING
    (SETQ CH (ASCII-TO-CHAR (SEND INPUT-STREAM ':TYI)))
    (COND ((CHAR= CH #/;)
	   (PUSH PARAM PARAMS)
	   (SETQ PARAM NIL))
	  ((SETQ DIGIT (DIGIT-CHAR-P CH))
	   (SETQ PARAM (+ (IF PARAM (* PARAM 10.) 0) DIGIT)))
	  ;; < thru ? would also be part of a general parameter set.
	  (T
	   (RETURN (VALUES CH (NREVERSE (CONS PARAM PARAMS))))))))

(DEFMETHOD (:HANDLE-OFFICIAL-ESCAPE-COMMAND ANSI-TERMINAL-SIMULATOR) (CH)
  (SELECTOR CH CHAR=
    ((#/( #/) #/* #/+)				;SCS select character set
     (SETF (AREF CHARACTER-SETS (- (CHAR-CODE CH) (CHAR-CODE #/()))
	   (SELECTQ (CODE-CHAR (SEND INPUT-STREAM :TYI))
	     ((#/A #/B) NIL)
	     ((#/0) (SI:PARSE-CHARACTER-STYLE
		      '(:DEVICE-FONT FONTS:VT100 :NORMAL))))))
    (#/D	;IND index
     (SEND SELF :LINE-FEED))
    (#/E	;NEL next line
     (SEND SELF :NEXT-LINE))
    ;; F         SSA start of selected area
    ;; G         ESA end of selected area
    ;; H         HTS horizontal tabulation set
    ;; I         HTJ horizontal tabulation with justification
    ;; J         VTS vertical tabulation set
    ;; K         PLD partial line down
    ;; L         PLU partial line up
    (#/M	;RI reverse index
     (SEND SELF :LINE-STARVE))
    ((#/N #/O)	;SS2/3 single shift 2/3
     (SEND OUTPUT-STREAM :TYO
	   (SI:MAKE-MERGED-CHAR (CODE-CHAR (SEND INPUT-STREAM :TYI))
				(AREF CHARACTER-SETS
				      (- (CHAR-CODE CH) (- (CHAR-CODE #/N) 2))))))
    (#/P	;DCS device control string
     ;; Read until ST
     (LOOP UNTIL (AND (= (SEND INPUT-STREAM :TYI) (ASCII-CODE 'ESC))
		      (= (SEND INPUT-STREAM :TYI) (CHAR-TO-ASCII #/\)))))
    ;; Q         PU1 private use 1
    ;; R         PU2 private use 2
    ;; S         STS set transmit state
    ;; T         CCH cancel character
    ;; U         MW message waiting
    ;; V         SPA start of guarded protected area
    ;; W         EPA end of guarded protected area
    ;; [         CSI control sequence introducer
    ;; \         ST string terminator
    ;; ]         OSC operating system command
    ;; ^         PM privacy message
    ;; _         APC application program command
    ;; `         DMI disable manual input
    ;; a         INT interrupt
    ;; b         EMI enable manual input
    ;; c         RIS reset to initial state
    ((#\n #\o)	;LS2/3 locking shift 2/3
     (SETQ SELECTED-CHARACTER-SET (- (CHAR-CODE CH) (- (CHAR-CODE #/n) 2))))
    ))

(DEFMETHOD (:HANDLE-OFFICIAL-ESCAPE-CSI-COMMAND ANSI-TERMINAL-SIMULATOR) (CH &REST PARAMS)
  ;; CHAR-X and CHAR-Y are often needed
  (MULTIPLE-VALUE-BIND (CHAR-X CHAR-Y) (SEND *VIEWPORT-STREAM* :READ-CURSORPOS :CHARACTER)
    (MACROLET ((SET-CURSORPOS (X Y)
		 `(SEND *TERMINAL-STREAM* :SET-VIEWPORT-CHARACTER-POSITION ,X ,Y))
	       (DEFAULT-PARAMETER (THING)
		 `(IF (MEMQ ,THING '(0 1 NIL)) ,1 ,THING)))
      (SELECTOR CH CHAR=
	(#/@	;ICH insert character
	 (LET ((COUNT (FIRST PARAMS)))
	   (SEND *VIEWPORT-STREAM* :INSERT-CHAR (DEFAULT-PARAMETER COUNT))))
	(#/A	;CUU cursor up
	 (LET ((COUNT (FIRST PARAMS)))
	   (SET-CURSORPOS CHAR-X (- CHAR-Y (DEFAULT-PARAMETER COUNT)))))
	(#/B	;CUD cursor down
	 (LET ((COUNT (FIRST PARAMS)))
	   (SET-CURSORPOS CHAR-X (+ CHAR-Y (DEFAULT-PARAMETER COUNT)))))
	(#/C	;CUF cursor forward
	 (LET ((COUNT (FIRST PARAMS)))
	   (SET-CURSORPOS (+ CHAR-X (DEFAULT-PARAMETER COUNT)) CHAR-Y)))
	(#/D	;CUB cursor backward
	 (LET ((COUNT (FIRST PARAMS)))
	   (SET-CURSORPOS (- CHAR-X (DEFAULT-PARAMETER COUNT)) CHAR-Y)))
	(#/E	;CNL cursor next line
	 (LET ((COUNT (FIRST PARAMS)))
	   (SET-CURSORPOS 0 (+ CHAR-Y (DEFAULT-PARAMETER COUNT)))))
	(#/F 	;CPL cursor preceding line
	 (LET ((COUNT (FIRST PARAMS)))
	   (SET-CURSORPOS 0 (- CHAR-Y (DEFAULT-PARAMETER COUNT)))))
	(#/G	;CHA cursor horizontal absolute
	 (LET ((NEW-X (FIRST PARAMS)))
	   (SET-CURSORPOS (1- (DEFAULT-PARAMETER NEW-X)) CHAR-Y)))
	(#/H	;CUP cursor position
	 (LET ((NEW-Y (FIRST PARAMS))
	       (NEW-X (SECOND PARAMS)))
	   (SET-CURSORPOS (1- (DEFAULT-PARAMETER NEW-X))
			  (1- (DEFAULT-PARAMETER NEW-Y)))))
	;; I     CHT cursor horizontal tabulation
	(#/J	;ED erase in display
	 (SELECTQ (FIRST PARAMS)
	   ((0 NIL)
	    (SEND *VIEWPORT-STREAM* :CLEAR-REST-OF-WINDOW))
	   (1
	    (SEND *VIEWPORT-STREAM* :CLEAR-BETWEEN-CURSORPOSES 0 0 CHAR-X CHAR-Y
							       :CHARACTER))
	   (2
	    (SEND *VIEWPORT-STREAM* :CLEAR-WINDOW))))
	(#/K	;EL erase in line
	 (SELECTQ (FIRST PARAMS)
	   ((0 NIL)
	    (SEND *VIEWPORT-STREAM* :CLEAR-REST-OF-LINE))
	   (1
	    (SEND *VIEWPORT-STREAM* :CLEAR-BETWEEN-CURSORPOSES 0 CHAR-Y CHAR-X CHAR-Y
							       :CHARACTER))
	   (2
	    (SEND *VIEWPORT-STREAM* :CLEAR-BETWEEN-CURSORPOSES 0 CHAR-Y
		  (SEND *VIEWPORT-STREAM* :SIZE-IN-CHARACTERS) CHAR-Y
		  :CHARACTER))))
	(#/L	;IL insert line
	 (LET ((COUNT (FIRST PARAMS)))
	   (SEND *VIEWPORT-STREAM* :INSERT-LINE (DEFAULT-PARAMETER COUNT))))
	(#/M	;DL delete line
	 (LET ((COUNT (FIRST PARAMS)))
	   (SEND *VIEWPORT-STREAM* :DELETE-LINE (DEFAULT-PARAMETER COUNT))))
	;; N     EF erase in field
	;; O     EA erase in area
	(#/P	;DCH delete character
	 (LET ((COUNT (FIRST PARAMS)))
	   (SEND *VIEWPORT-STREAM* :DELETE-CHAR (DEFAULT-PARAMETER COUNT))))
	;; Q     SEE select editing extent
	;; R     CPR cursor position report
	;; S     SU scroll up
	;; T     SD scroll down
	;; U     NP next page
	;; V     PP preceding page
	;; W     CTC cursor tabulation control
	(#/X	;ECH erase character
	 (LET ((COUNT (FIRST PARAMS)))
	   (SEND *VIEWPORT-STREAM* :CLEAR-BETWEEN-CURSORPOSES CHAR-X CHAR-Y
		 (+ CHAR-X (DEFAULT-PARAMETER COUNT)) CHAR-Y)))
	;; Y     CVT cursor vertical tabulation
	;; Z     CBT cursor backward tabulation

	(#/` 	;HPA horizontal position absolute
	 (LET ((NEW-X (FIRST PARAMS)))
	   (SET-CURSORPOS (1- (DEFAULT-PARAMETER NEW-X)) CHAR-Y)))
	(#/a	;HPR horizontal position relative
	 (LET ((COUNT (FIRST PARAMS)))
	   (SET-CURSORPOS (+ CHAR-X (DEFAULT-PARAMETER COUNT)) CHAR-Y)))
	;; b     REP repeat
	;; c     DA device attributes
	(#/d	;VPA vertical position absolute
	 (LET ((NEW-Y (FIRST PARAMS)))
	   (SET-CURSORPOS CHAR-X (1- (DEFAULT-PARAMETER NEW-Y)))))
	(#/e	;VPR vertical position relative
	 (LET ((COUNT (FIRST PARAMS)))
	   (SET-CURSORPOS CHAR-X (+ CHAR-Y (DEFAULT-PARAMETER COUNT)))))
	(#/f	;HVP horizontal and vertical position
	 (LET ((NEW-Y (FIRST PARAMS))
	       (NEW-X (SECOND PARAMS)))
	   (SET-CURSORPOS (1- (DEFAULT-PARAMETER NEW-X))
			  (1- (DEFAULT-PARAMETER NEW-Y)))))
	;; g     TBC tabulation clear
	;; h     SM set mode
	;; i     MC media copy
	;; j     HPB horizontal position backward
	;; k     VPB vertical position backward
	;; l     RM reset mode
	(#/m	;SGR select graphic rendition
	 (SEND *TERMINAL-STREAM* :SET-CHARACTER-ATTRIBUTE 
	       (SELECTQ (FIRST PARAMS)
		 ((0 NIL) NIL)
		 (1 :BOLD)
		 (4 :UNDERLINE)
		 (5 :BLINK)
		 (7 :REVERSE-VIDEO))))
	;; n     DSR device status report
	;; o     DAQ define area qualification
	))))

(DEFFLAVOR AMBASSADOR-TERMINAL-SIMULATOR
	    ((SCREEN-NLINES NIL))
	    (ANSI-TERMINAL-SIMULATOR))

(DEFMETHOD (:NAME AMBASSADOR-TERMINAL-SIMULATOR) () "Ambassador")

(DEFMETHOD (:HANDLE-ESCAPE-COMMAND AMBASSADOR-TERMINAL-SIMULATOR) (CSI-P CH &REST PARAMS)
  (IF (NOT CSI-P)
      (SELECTOR CH CHAR=
	;; 5 zTFC toggle fast-blink cursor
	;; 6 zTI toggle IRM
	;; 7 zSC save cursor
	;; 8 zRC restore cursor
	;; 9 zCGR change graphic rendition
	;; : zGUA guard unprotected areas
	(OTHERWISE
	  (SEND SELF :HANDLE-OFFICIAL-ESCAPE-COMMAND CH)))
      (SELECTOR CH CHAR=
	(#/>	;Extended parameters to (re)set mode.  Just ignore them.
	 (SEND SELF :PARSE-PARAMETERS))
	(#/p	;zSDP set display parameters
	 (WHEN (FOURTH PARAMS)
	   (SETQ SCREEN-NLINES (FOURTH PARAMS))))
	;; s zPSH push line
	;; t zPOP pop line
	;; u zSTP set transfer pointer
	;; v zSRC start remote copy
	;; w zSPF set print format
	;; z zSTE set transfer end
	(OTHERWISE
	  (LEXPR-SEND SELF :HANDLE-OFFICIAL-ESCAPE-CSI-COMMAND CH PARAMS)))))
(DEFMETHOD (:LINE-FEED AMBASSADOR-TERMINAL-SIMULATOR) (&OPTIONAL (LINE-COUNT 1))
  (MULTIPLE-VALUE-BIND (NIL Y)
      (SEND *VIEWPORT-STREAM* :READ-CURSORPOS :CHARACTER)
    (IF (OR (NULL SCREEN-NLINES)
	    ( (1+ Y) SCREEN-NLINES))
	(SEND *VIEWPORT-STREAM* :SET-CURSORPOS NIL (+ Y LINE-COUNT) :CHARACTER)
	(LET* ((AMOUNT-TO-MOVE LINE-COUNT)
	       (LINES-TO-MOVE (- SCREEN-NLINES AMOUNT-TO-MOVE))
	       (WIDTH (SEND *VIEWPORT-STREAM* :INSIDE-WIDTH))
	       (LINE-HEIGHT (SEND *VIEWPORT-STREAM* :LINE-HEIGHT)))
	  (SEND *VIEWPORT-STREAM* :MOVE-REGION WIDTH (* LINES-TO-MOVE LINE-HEIGHT)
		0 (* AMOUNT-TO-MOVE LINE-HEIGHT)
		0 0)))))

(ADD-TERMINAL-SIMULATOR-TYPE 'AMBASSADOR-TERMINAL-SIMULATOR)

(DEFFLAVOR VT100-TERMINAL-SIMULATOR
	((REGION-TOP-LINE NIL)
	 (REGION-BOTTOM-LINE NIL)
	 (KEYPAD-MODE :NUMERIC))
	(ANSI-TERMINAL-SIMULATOR))

(DEFMETHOD (:NAME VT100-TERMINAL-SIMULATOR) () "VT100")

(DEFCONST *VT100-INPUT-TRANSLATION-ALIST* 
  '((#\ "[A") (#\ "[B") (#\ "[C") (#\ "[D")))

(DEFMETHOD (:SETUP VT100-TERMINAL-SIMULATOR) ()
  (SEND (SEND *TERMINAL-STREAM* :GET-STATE-BLOCK :INPUT-TRANSLATION)
	:SET-TRANSLATION-ALIST *VT100-INPUT-TRANSLATION-ALIST*))

(DEFMETHOD (:HANDLE-ESCAPE-COMMAND VT100-TERMINAL-SIMULATOR) (CSI-P CH &REST PARAMS)
  (IF (NOT CSI-P)
      (SELECTOR CH CHAR=
	;; # 3   DECDHL double-height top half
	;; # 4   DECDHL double-height bottom half
	;; # 5   DECSWL single-width single-height
	;; # 6   DECDWL double-width single-height
	;; # 8   DECALN screen alignment display
	;; 5     DECXMIT transmit
	;; 7     DECSC save cursor
	;; 8     DECRC restore cursor
	(#/=	;DECPAM alternative keypad
	 (SETQ KEYPAD-MODE :ALTERNATE))
	(#/>	;DECPNM numeric keypad
	 (SETQ KEYPAD-MODE :NUMERIC))
	;; <     VT52 enter ANSI mode
	;; F     VT52 graphics character set
	;; G     VT52 standard character set
	;; A     VT52 cursor up
	;; B     VT52 cursor down
	;; C     VT52 cursor right
	;; D     VT52 cursor left
	;; H     VT52 home cursor
	;; |     VT52 line starve
	;; K     VT52 clear eol
	;; J     VT52 clear eos
	;; ^     VT52 enter auto print mode
	;; _     VT52 exit auto print mode
	;; W     VT52 enter printer controller mode
	;; X     VT52 exit printer controller mode
	;; ]     VT52 print screen
	;; V     VT52 print cursor line
	(#/Y	;VT52 direct cursor address
	 (LET* ((Y (SEND INPUT-STREAM :TYI))
		(X (SEND INPUT-STREAM :TYI)))
	   (SEND *TERMINAL-STREAM* :SET-VIEWPORT-CHARACTER-POSITION (- X #o040) (- Y #o040))))
	;; Z     DECID identify terminal
	(OTHERWISE
	  (SEND SELF :HANDLE-OFFICIAL-ESCAPE-COMMAND CH)))
      (SELECTOR CH CHAR=
	(#/?	;Extended parameters to (re)set mode.  Just ignore them.
	 (SEND SELF :PARSE-PARAMETERS))
	(#/r	;DECSTBM set top and bottom margins
	 (SETQ REGION-TOP-LINE (IF (FIRST PARAMS) (1- (FIRST PARAMS)) 0)
	       REGION-BOTTOM-LINE (IF (SECOND PARAMS) (SECOND PARAMS) 0))
	 (SEND *VIEWPORT-STREAM* :HOME-CURSOR))
	;; y    DECTST invoke confidence test
	;; |    DECTTC transmit termination character
	;; }    DECPRO protected field attributes
	(OTHERWISE
	  (LEXPR-SEND SELF :HANDLE-OFFICIAL-ESCAPE-CSI-COMMAND CH PARAMS)))))

(DEFMETHOD (:LINE-FEED VT100-TERMINAL-SIMULATOR) (&OPTIONAL (LINE-COUNT 1))
  (MULTIPLE-VALUE-BIND (NIL Y)
      (SEND *VIEWPORT-STREAM* :READ-CURSORPOS :CHARACTER)
    (IF (OR (NULL REGION-BOTTOM-LINE)
	    ( (1+ Y) REGION-BOTTOM-LINE))
	(SEND *VIEWPORT-STREAM* :SET-CURSORPOS NIL (+ Y LINE-COUNT) :CHARACTER)
	(LET* ((AMOUNT-TO-MOVE LINE-COUNT)
	       (LINES-TO-MOVE (- (- REGION-BOTTOM-LINE REGION-TOP-LINE) AMOUNT-TO-MOVE))
	       (WIDTH (SEND *VIEWPORT-STREAM* :INSIDE-WIDTH))
	       (LINE-HEIGHT (SEND *VIEWPORT-STREAM* :LINE-HEIGHT)))
	  (SEND *VIEWPORT-STREAM* :MOVE-REGION WIDTH (* LINES-TO-MOVE LINE-HEIGHT)
		0 (* (+ REGION-TOP-LINE AMOUNT-TO-MOVE) LINE-HEIGHT)
		0 (* REGION-TOP-LINE LINE-HEIGHT))))))

(DEFMETHOD (:LINE-STARVE VT100-TERMINAL-SIMULATOR) (&OPTIONAL (LINE-COUNT 1))
  (MULTIPLE-VALUE-BIND (NIL Y)
      (SEND *VIEWPORT-STREAM* :READ-CURSORPOS :CHARACTER)
    (IF (OR (NULL REGION-TOP-LINE)
	    ( Y REGION-TOP-LINE))
	(SEND *VIEWPORT-STREAM* :SET-CURSORPOS NIL (- Y LINE-COUNT) :CHARACTER)
	(LET* ((AMOUNT-TO-MOVE LINE-COUNT)
	       (LINES-TO-MOVE (- (- REGION-BOTTOM-LINE REGION-TOP-LINE) AMOUNT-TO-MOVE))
	       (WIDTH (SEND *VIEWPORT-STREAM* :INSIDE-WIDTH))
	       (LINE-HEIGHT (SEND *VIEWPORT-STREAM* :LINE-HEIGHT)))
	  (SEND *VIEWPORT-STREAM* :MOVE-REGION WIDTH (* LINES-TO-MOVE LINE-HEIGHT)
		0 (* REGION-TOP-LINE LINE-HEIGHT)
		0 (* (+ REGION-TOP-LINE AMOUNT-TO-MOVE) LINE-HEIGHT))))))

(DEFMETHOD (:NEXT-LINE VT100-TERMINAL-SIMULATOR) ()
  (LET ((YPOS (MULTIPLE-VALUE-BIND (NIL Y)
		  (SEND OUTPUT-STREAM ':READ-CURSORPOS ':CHARACTER)
		Y)))
    (IF (AND REGION-BOTTOM-LINE (= (1+ YPOS) REGION-BOTTOM-LINE))
	(PROGN
	  (SEND SELF ':LINE-FEED)
	  (SEND *VIEWPORT-STREAM* ':SET-CURSORPOS 0
		(* YPOS (SEND *VIEWPORT-STREAM* :LINE-HEIGHT)))
	  )
	(SEND *TERMINAL-STREAM* :NEWLINE :SCROLL-AT-END))))

(ADD-TERMINAL-SIMULATOR-TYPE 'VT100-TERMINAL-SIMULATOR)

(COMPILE-FLAVOR-METHODS NVT-WINDOW MORE-ESCAPE-FILTER
			ECHO-TYPEIN-FILTER ECHO-TYPEOUT-FILTER ECHO-STATE-BLOCK
			TELNET-FILTER NVT-ASCII-TYPEIN-FILTER ITP-FILTER
			IAC-HANDLER-FILTER TELNET-STATE-BLOCK
			SUPDUP-FILTER SUPDUP-STATE-BLOCK
			SUPDUP-GRAPHICS-STATE GT40-STATE-BLOCK
			GT40-BLINKER ARDS-STATE-BLOCK SUDS-STATE-BLOCK SUDS-BLINKER
			TELSUP-ITP-FILTER CHAT-MARK-TYPEOUT-FILTER
			3600-TYPEIN-FILTER 3600-TYPEOUT-FILTER)

(COMPILE-FLAVOR-METHODS NULL-TERMINAL-SIMULATOR IMLAC-TERMINAL-SIMULATOR
			AMBASSADOR-TERMINAL-SIMULATOR VT100-TERMINAL-SIMULATOR)

(TV:ADD-SELECT-KEY #/T 'TELNET:NVT-WINDOW "Terminal" T)
