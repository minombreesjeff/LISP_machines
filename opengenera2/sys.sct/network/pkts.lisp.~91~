;;; -*- Mode: LISP; Package: NETWORK-INTERNALS; Base: 10 -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; This file is part of the cold load.

#+IMACH
(PROGN
;; Bits in EPACKET-STATUS
(DEFSYSBYTE %%PACKET-STATUS-WIRED 1 4)

;;; These are in SYSDF1 on the L machine
(DEFWIREDVAR %NET-FREE-LIST)			;List of packets available to be received into
(DEFWIREDVAR %NET-RECEIVED-LIST)		;List of packets received
(DEFWIREDVAR %NET-RECEIVED-LIST-TAIL)		;Most recently received packet
(DEFWIREDVAR %NET-TRANSMIT-LIST)		;List of packets to be transmitted
(DEFWIREDVAR %NET-TRANSMIT-LIST-TAIL)		;Most recently enqueued packet for tranmit

;;; These meters (in L machine's SYSDF1) will probably be useful
(DEFWIREDVAR %NET-COLLISIONS)			;Number of collisions seen by network
(DEFWIREDVAR %NET-TRANSMIT-ABORTS)		;Number of packets totally punted by
						;retransmission 
(DEFWIREDVAR %NET-CRC-ERRORS)			;Number of CRC errors from network
(DEFWIREDVAR %NET-ALIGNMENT-ERRORS)		;Number of Alignment errors from network
(DEFWIREDVAR %NET-DATA-OVERFLOWS)		;Number of data overflowed ether packet
(DEFWIREDVAR %NET-BUFFER-OVERFLOWS)		;Number of times microcode was too slow
(DEFWIREDVAR %NET-IGNORED)			;Number of packets ignored

;;; Additional I machine meters
(DEFWIREDVAR *TRANSMIT-LATENCY* 0)
(DEFWIREDVAR *QUEUED-EPACKETS* 0)
(DEFWIREDVAR *TRANSMITTED-EPACKETS* 0)
(DEFWIREDVAR *RECEIVE-LATENCY* 0)
(DEFWIREDVAR *RECEIVED-EPACKETS* 0)
(DEFWIREDVAR *PROCESSED-EPACKETS* 0)

); End #+IMACH

(DEFCONSTANT %NET-NULL #+3600 -1 #+IMACH NIL)

(SI:DEFINE-WIRED-METERS *PACKET-ALLOCATION-METERS*
  *PKTS-ALLOCATED*
  *PKTS-DEALLOCATED*
  *PKTS-COPIED-DUE-TO-MISALIGNMENT*
  *PACKET-BUFFER-PANICS*
  *COUNT-NET-MICROCODE-HANGS*
  )

(DEFCONST *UNRESET-PACKET-ALLOCATION-METERS*
	  '(*MAXIMUM-NUMBER-OF-WIRED-PACKET-BUFFERS*
	    *ACTUAL-NUMBER-OF-WIRED-PACKET-BUFFERS*
	    *TARGET-NUMBER-OF-WIRED-PACKET-BUFFERS*
	    *N-FREE-WIRED-PACKET-BUFFERS*
	    *NUMBER-OF-UNWIRED-PACKET-BUFFERS*
	    *N-FREE-UNWIRED-PACKET-BUFFERS*
	    ))

(DEFUN RESET-PACKET-ALLOCATION-METERS ()
  (DOLIST (SYM *PACKET-ALLOCATION-METERS*)
    (SET SYM 0)))

(RESET-PACKET-ALLOCATION-METERS)

(ADD-INITIALIZATION "Microcode meters" '(RESET-PACKET-ALLOCATION-METERS) '(ONCE))
(ADD-INITIALIZATION "Microcode meters" '(RESET-PACKET-ALLOCATION-METERS) '(COLD))

(DEFVAR NETWORK-CONS-AREA (MAKE-AREA :NAME 'NETWORK-CONS-AREA))

(DEFMACRO WITH-NETWORK-CONS-AREA (&BODY BODY)
  `(LET ((DEFAULT-CONS-AREA NETWORK-CONS-AREA))
     ,@BODY))

(DEFVAR ETHER-BUFFER-AREA (MAKE-AREA :NAME 'ETHER-BUFFER-AREA
				     :REPRESENTATION :STRUCTURE
				     :GC :SAFEGUARDED
				     '%%REGION-SCAVENGE-ENABLE 1))

#+VLM
(DEFWIREDVAR %ETHER-BUFFER-AREA-REGION NIL)

(DEFSTRUCT (SUB-PACKET (:TYPE :ARRAY-LEADER) (:MAKE-ARRAY (:AREA NETWORK-CONS-AREA))
		       :CONC-NAME :SIZE-SYMBOL)
  RESERVED-1					;Reserved for fill pointer
  RESERVED-2					;Reserved for named structure symbol
  PACKET					;The PACKET into which this points
  BYTE-OFFSET					;The number of 8-bit bytes of offset
  SPARE-1					;For expansion
  )

(DEFSTRUCT (PACKET (:INCLUDE SUB-PACKET) (:make-array (:area network-cons-area))
		   :CONC-NAME (:SIZE-SYMBOL PACKET-LEADER-SIZE))
  SUB-PACKETS					;A list of SUB-PACKET-ENTRY's
  )

(DEFSTRUCT (SUB-PACKET-ENTRY (:TYPE :GROUPED-ARRAY) (:CONC-NAME)
			     (:SIZE-SYMBOL SUB-PACKET-ENTRY-SIZE)
			     (:CONSTRUCTOR NIL) (:ALTERANT NIL))
  SUB-PACKET
  BYTE-OFFSET
  ARRAY-TYPE					;ART-something symbol
  LEADER-LENGTH
  NAMED-STRUCTURE-SYMBOL			;or NIL
  )

;;; Given a PACKET or SUB-PACKET, return an array of type ARRAY-TYPE offset an additional
;;; NBYTES from PACKET.
(DEFUN GET-SUB-PACKET (SUB-PACKET ARRAY-TYPE NBYTES
		       &OPTIONAL (LEADER-LENGTH SUB-PACKET-SIZE)
		       (NAMED-STRUCTURE-SYMBOL NIL))
  (DECLARE (VALUES SUB-PACKET NEW-P))
  (CHECK-ARG-TYPE ARRAY-TYPE :SYMBOL)    
  (LET* ((PACKET (SUB-PACKET-PACKET SUB-PACKET))
	 (BYTE-OFFSET (+ NBYTES (SUB-PACKET-BYTE-OFFSET SUB-PACKET)))
	 (SUB-PACKETS (PACKET-SUB-PACKETS PACKET)))
    (DECLARE (SYS:ARRAY-REGISTER SUB-PACKETS))
    ;; Search for a suitable already existing subpacket 
    (LOOP FOR I FROM 0 BY SUB-PACKET-ENTRY-SIZE BELOW (FILL-POINTER SUB-PACKETS) DO
      (WHEN (AND (= (SUB-PACKET-ENTRY-BYTE-OFFSET I SUB-PACKETS) BYTE-OFFSET)
		 (EQ (SUB-PACKET-ENTRY-ARRAY-TYPE I SUB-PACKETS) ARRAY-TYPE)
		 (= (SUB-PACKET-ENTRY-LEADER-LENGTH I SUB-PACKETS) LEADER-LENGTH)
		 (EQ (SUB-PACKET-ENTRY-NAMED-STRUCTURE-SYMBOL I SUB-PACKETS)
		     NAMED-STRUCTURE-SYMBOL))
	(RETURN-FROM GET-SUB-PACKET (SUB-PACKET-ENTRY-SUB-PACKET I SUB-PACKETS))))
    ;; Have to create a new one
    (WHEN (MINUSP BYTE-OFFSET)
      (ERROR "Attempt to get packet with negative byte offset."))
    ;; If it won't fit, grow it
    (UNLESS ( (- (ARRAY-LENGTH SUB-PACKETS) (FILL-POINTER SUB-PACKETS))
	       (+ SUB-PACKET-ENTRY-SIZE (DEFSTORAGE-SIZE ARRAY)	;long-indirect format
		  LEADER-LENGTH
		  #+IMACH 3			;leader header,1 length and multiplier
		  ))
      (LET ((NEW (MAKE-ARRAY (- (* (CEILING (+ (MAX (+ (ARRAY-LENGTH SUB-PACKETS) PAGE-SIZE)
						    (+ (FILL-POINTER SUB-PACKETS)
						       SUB-PACKET-ENTRY-SIZE
						       (DEFSTORAGE-SIZE ARRAY)
						       LEADER-LENGTH
						       #+IMACH 3
						       ))
					       #+3600 2	;Array header for this
					       #+IMACH 3
					       )
					    PAGE-SIZE)
				   PAGE-SIZE)
				#+3600 2
				#+IMACH 3
				)
			     :FILL-POINTER (FILL-POINTER SUB-PACKETS)
			     :AREA ETHER-BUFFER-AREA)))
	(COPY-ARRAY-CONTENTS SUB-PACKETS NEW)
	(SETF (PACKET-SUB-PACKETS PACKET) (SETQ SUB-PACKETS NEW))))
    (LET ((SUB-PACKET (LET ((BIT-OFFSET (* BYTE-OFFSET 8))
			    (DISPLACED-TO PACKET)
			    (BITS-PER-ELEM (OR (ARRAY-BITS-PER-ELEMENT
						 (SYMEVAL ARRAY-TYPE))
					       32)))	;++kludge for art-q
			(WHEN (ARRAY-INDEXED-P PACKET)
			  (SETQ DISPLACED-TO (SI:ARRAY-INDIRECT-TO PACKET))
			  (INCF BIT-OFFSET (* (SI:ARRAY-INDEX-OFFSET PACKET) 8)))
			(UNLESS (ZEROP (\ BIT-OFFSET BITS-PER-ELEM))
			  (ERROR "Attempt to get packet with unaligned elements."))
			;; Try to put it on the same page as SUB-PACKETS and to keep
			;; everything aligned on page boundaries.  The idea is that
			;; GET-SUB-PACKET should take at most one page fault.
			;; Some gross knowledge of what MAKE-ARRAY does here.
			(BLOCK MAKE
			  (WITHOUT-INTERRUPTS	;protect machinations against GC
			    (WHEN ( (- (ARRAY-LENGTH SUB-PACKETS)
					(FILL-POINTER SUB-PACKETS))
				     (+ SUB-PACKET-ENTRY-SIZE
					(DEFSTORAGE-SIZE ARRAY)	;long-indirect format
					LEADER-LENGTH
					#+IMACH 3
					))
			      (LET* ((N (+ (DEFSTORAGE-SIZE ARRAY)
					   LEADER-LENGTH
					   #+IMACH 3
					   ))
				     (A (LOCF (AREF SUB-PACKETS
						    (- (ARRAY-LENGTH SUB-PACKETS) N))))
				     (B (PROGN
					  #+3600 (%MAKE-POINTER DTP-ARRAY A)
					  #+IMACH (%MAKE-POINTER-OFFSET
						    (IF (OR (EQ ARRAY-TYPE 'SYS:ART-STRING)
							    (EQ ARRAY-TYPE
								'SYS:ART-FAT-STRING))
							DTP-STRING
							DTP-ARRAY)
						    A
						    (+ 1 LEADER-LENGTH)))))
				#+3600
				(PROGN
				  ;; Shorten the sub-packets array to
				  ;; make room for a new sub-packet
				  ;; struct.  This frees up the storage
				  ;; that's immediately off the end of
				  ;; the array; the new struct will be
				  ;; built there.  This is all inside a
				  ;; without-interrupts in a static
				  ;; area, so this practice that would
				  ;; normally be verboten will work in
				  ;; this case.
				  (DECF (ARRAY-SHORT-LENGTH-FIELD SUB-PACKETS) N)
				  (%P-STORE-CDR-TYPE-AND-POINTER
				    A %HEADER-TYPE-ARRAY
				    DTP-HEADER-I
				    (SI:BUILD-DEFSTORAGE-WORD
				      ARRAY-NAMED-STRUCTURE-BIT
				      (IF NAMED-STRUCTURE-SYMBOL 1 0)
				      ARRAY-DISPATCH-FIELD %ARRAY-DISPATCH-LONG
				      ARRAY-TYPE-FIELD (SYMEVAL ARRAY-TYPE)
				      ARRAY-LONG-PREFIX-LENGTH-FIELD (DEFSTORAGE-SIZE ARRAY)
				      ARRAY-LONG-LEADER-LENGTH-FIELD LEADER-LENGTH
				      ARRAY-DIMENSIONS-FIELD 1))
				  (%P-STORE-CONTENTS-INCREMENT-POINTER DISPLACED-TO A)
				  (%P-STORE-CONTENTS-INCREMENT-POINTER
				    (// (* (- (ARRAY-LENGTH PACKET) BYTE-OFFSET) 8)
					BITS-PER-ELEM)
				    A)		;ARRAY-LONG-LENGTH-FIELD
				  (%P-STORE-CONTENTS-INCREMENT-POINTER
				    (// BIT-OFFSET BITS-PER-ELEM)
				    A)		;ARRAY-INDEX-OFFSET-FIELD
				  (%P-STORE-CONTENTS-INCREMENT-POINTER NIL A)	;FILL-POINTER
				  (%P-STORE-CONTENTS-INCREMENT-POINTER
				    NAMED-STRUCTURE-SYMBOL A)
				  (LOOP REPEAT (- LEADER-LENGTH 2) DO
				    (%P-STORE-CONTENTS-INCREMENT-POINTER NIL A)))
				#+IMACH
				(LET ((LENGTH (// (* (- (ARRAY-LENGTH PACKET) BYTE-OFFSET) 8)
						  BITS-PER-ELEM)))
				  (DECF (ARRAY-SHORT-LENGTH-FIELD SUB-PACKETS) N)
				  (WITH-SYSTEM-BLOCK-REGISTERS (1)
				    ;; Shorten the SUB-PACKETS array
				    (SETF (%BLOCK-REGISTER 1) A)
				    (SI:PREPARE-FOR-BLOCK-WRITE)
				    ;; Leader's header
				    (%BLOCK-WRITE
				      1
				      (%SET-TAG B (DPB %HEADER-TYPE-LEADER
						       %%Q-CDR-CODE-WITHIN-TAG
						       (DPB DTP-HEADER-P
							    %%Q-TYPE-WITHIN-TAG 0))))
				    ;; Leader elements, except NSS and fill pointer
				    (LOOP REPEAT (- LEADER-LENGTH 2) DOING
				      (%BLOCK-WRITE 1 NIL))
				    ;; Named structure symbol in leader
				    (%BLOCK-WRITE 1 NAMED-STRUCTURE-SYMBOL)
				    ;; Fill pointer
				    (%BLOCK-WRITE 1 length)
				    ;; Array header
				    (%BLOCK-WRITE
				      1
				      (PROG1 (%SET-TAG
					       (SI:BUILD-DEFSTORAGE-WORD
						 ARRAY-NAMED-STRUCTURE-BIT
						 (IF NAMED-STRUCTURE-SYMBOL 1 0)
						 ARRAY-TYPE-FIELD (SYMEVAL ARRAY-TYPE)
						 ARRAY-LONG-PREFIX-BIT 1
						 ARRAY-DISPLACED-BIT 1
						 ARRAY-LEADER-LENGTH-FIELD LEADER-LENGTH
						 ARRAY-LONG-DIMENSIONS-FIELD 1)
					       (DPB %HEADER-TYPE-ARRAY
						    %%Q-CDR-CODE-WITHIN-TAG
						    (DPB DTP-HEADER-I %%Q-TYPE-WITHIN-TAG 0)))
					     (SI:PREPARE-FOR-BLOCK-WRITE)))
				    ;; Array-long-length-field
				    (%BLOCK-WRITE 1 LENGTH)
				    ;; Array-index-offset-field
				    (%BLOCK-WRITE 1 (// BIT-OFFSET BITS-PER-ELEM))
				    ;; Array-indirect-pointer
				    (%BLOCK-WRITE 1 DISPLACED-TO)
				    ;; Length
				    (%BLOCK-WRITE 1 LENGTH)
				    ;; Multiplier
				    (%BLOCK-WRITE 1 1)))
				(RETURN-FROM MAKE B))))
			  ;; Won't fit, just make an array the ordinary way.
			  ;; Can only get here if there is some kind of timing error.
			  ;; This code is useful as documentation of what the subprimitives
			  ;; above are supposed to accomplish.
			  ;; In this case the sub-packet goes into NETWORK-CONS-AREA
			  ;; instead of ETHER-BUFFER-AREA, because the latter area requires
			  ;; that everything be page-aligned.
			  (MAKE-ARRAY (// (* (- (ARRAY-LENGTH PACKET) BYTE-OFFSET) 8)
					  BITS-PER-ELEM)
				      :TYPE ARRAY-TYPE :LEADER-LENGTH LEADER-LENGTH
				      :AREA NETWORK-CONS-AREA
				      :NAMED-STRUCTURE-SYMBOL NAMED-STRUCTURE-SYMBOL
				      :DISPLACED-TO DISPLACED-TO
				      :DISPLACED-INDEX-OFFSET
					(// BIT-OFFSET BITS-PER-ELEM))))))
	    (SETF (SUB-PACKET-PACKET SUB-PACKET) PACKET)
	    (SETF (SUB-PACKET-BYTE-OFFSET SUB-PACKET) BYTE-OFFSET)
	    (LET ((I (FILL-POINTER SUB-PACKETS)))
	      (SETF (FILL-POINTER SUB-PACKETS) (+ I SUB-PACKET-ENTRY-SIZE))
	      (SETF (SUB-PACKET-ENTRY-SUB-PACKET I SUB-PACKETS) SUB-PACKET)
	      (SETF (SUB-PACKET-ENTRY-BYTE-OFFSET I SUB-PACKETS) BYTE-OFFSET)
	      (SETF (SUB-PACKET-ENTRY-ARRAY-TYPE I SUB-PACKETS) ARRAY-TYPE)
	      (SETF (SUB-PACKET-ENTRY-LEADER-LENGTH I SUB-PACKETS) LEADER-LENGTH)
	      (SETF (SUB-PACKET-ENTRY-NAMED-STRUCTURE-SYMBOL I SUB-PACKETS)
		    NAMED-STRUCTURE-SYMBOL))
	    (VALUES SUB-PACKET T))))

;;; This entry is like the above but is allowed to copy the packet if needed.
;;; It should be used if the byte offset is negative.
(DEFUN GET-SUB-PACKET-MAYBE-COPYING (FREE-FLAG LENGTH SUB-PACKET ARRAY-TYPE NBYTES
				     &OPTIONAL (LEADER-LENGTH SUB-PACKET-SIZE)
				     (NAMED-STRUCTURE-SYMBOL NIL))
  (DECLARE (VALUES SUB-PACKET FREE-FLAG))
  (COND ((MINUSP (+ NBYTES (SUB-PACKET-BYTE-OFFSET SUB-PACKET)))
	 (INCF *PKTS-COPIED-DUE-TO-MISALIGNMENT*)
	 (LET ((NEW-PACKET (ALLOCATE-PACKET-BUFFER NIL)))
	   (WHEN NEW-PACKET
	     (COPY-ARRAY-PORTION SUB-PACKET 0 LENGTH
				 NEW-PACKET (- NBYTES) (- LENGTH NBYTES)))
	   (WHEN FREE-FLAG
	     (DEALLOCATE-PACKET-BUFFER SUB-PACKET))
	   (WHEN NEW-PACKET
	     (VALUES (GET-SUB-PACKET NEW-PACKET ARRAY-TYPE 0
				     LEADER-LENGTH NAMED-STRUCTURE-SYMBOL)
		     T))))
	(T (VALUES (GET-SUB-PACKET SUB-PACKET ARRAY-TYPE NBYTES
				   LEADER-LENGTH NAMED-STRUCTURE-SYMBOL)
		   FREE-FLAG))))

(DEFUN MAP-SUB-PACKETS (FUNCTION &REST OTHER-FUNCTION-ARGS)
  (DECLARE (SYS:DOWNWARD-FUNARG FUNCTION))
  "FUNCTION is called for every sub-packet of every packet, with arguments
sub-packet, named-structure-symbol, and whatever other-function-args were passed."
  (MAP-PACKET-BUFFERS
    #'(LAMBDA (PACKET)
	(LET ((SUB-PACKETS (PACKET-SUB-PACKETS PACKET)))
	  (LOOP FOR I FROM 0 BY SUB-PACKET-ENTRY-SIZE BELOW (FILL-POINTER SUB-PACKETS) DO
	    (LEXPR-FUNCALL FUNCTION (SUB-PACKET-ENTRY-SUB-PACKET I SUB-PACKETS)
			   (SUB-PACKET-ENTRY-NAMED-STRUCTURE-SYMBOL I SUB-PACKETS)
			   OTHER-FUNCTION-ARGS))))))


;;; Get SUB-PACKET's PACKET if it is offset by BYTE-OFFSET.  Otherwise, make a
;;; copy with correct offset.  FREE-FLAG means that the packet can be freed if
;;; a copy is made.  We return our own FREE-FLAG which is T if we did copy.
;;; NBYTES is the active length used for copying.
(DEFUN GET-SUB-PACKET-PACKET-WITH-BYTE-OFFSET (SUB-PACKET FREE-FLAG BYTE-OFFSET NBYTES)
  (DECLARE (VALUES PACKET FREE-FLAG))
  (LET ((PACKET (SUB-PACKET-PACKET SUB-PACKET))
	(REAL-BYTE-OFFSET (SUB-PACKET-BYTE-OFFSET SUB-PACKET)))
    (IF (= BYTE-OFFSET REAL-BYTE-OFFSET)
	(VALUES PACKET FREE-FLAG)
      (INCF *PKTS-COPIED-DUE-TO-MISALIGNMENT*)
      (LET ((NEW-PACKET (ALLOCATE-PACKET-BUFFER NIL)))
	(UNLESS (NULL NEW-PACKET)
	  (COPY-ARRAY-PORTION PACKET REAL-BYTE-OFFSET (+ REAL-BYTE-OFFSET NBYTES)
			      NEW-PACKET BYTE-OFFSET (+ BYTE-OFFSET NBYTES)))
	(WHEN FREE-FLAG
	  (DEALLOCATE-PACKET-BUFFER PACKET))
	(VALUES NEW-PACKET T)))))



  ;;
;;;;;; Packet management, definitions
  ;;

;;; This structure is known about by the microcode
#+3600
(DEFSTRUCT (EPACKET :NAMED :ARRAY :CONC-NAME)
  LINK
  STATUS					;Status of this packet
  FINAL-POINTER					;pointer to last location read by ucode
  DEST-HIGH					;Destination high 32 bits
  ((ADDRESS-WORD-2)
   (DEST-LOW (BYTE 16 0))			;Destination low 16 bits
   ;(SRC-HIGH (BYTE 16 16))			;Source high 16 bits (defined below)
   )
  SRC-LOW					;Source low 32 bits
  ((ENTIRE-FIRST-WORD)
   (TYPE (BYTE 16 0))				;packet type 
   ;(FIRST-WORD (BYTE 16 16))			;define below
   )
  RCV-0-ADDRESS					;First block address
  RCV-0-LENGTH					;block length
  RCV-1-ADDRESS
  RCV-1-LENGTH
  RCV-TERMINATOR				;-1
  XMT-0-ADDRESS					;First block address
  XMT-0-LENGTH					;block length
  XMT-1-ADDRESS
  XMT-1-LENGTH
  XMT-TERMINATOR				;-1
  SOFTWARE-PACKET				;Back pointer to the software structure
  )

;;; This is extra stuff used by the software
#+3600
(DEFSTRUCT (SOFTWARE-EPACKET (:INCLUDE EPACKET) (:CONC-NAME EPACKET-)
			     :SIZE-SYMBOL)
  DATA-LENGTH					;Data length of the ether packet in octets
  PHYSICAL-ADDRESS				;Physical address of the EPACKET part
  SUB-PACKET					;A PACKET
  THREAD					;Threads all ether packets together
  REF-COUNT					;so we don't accidentally free a packet twice
  SPARE-1
  ;;; NOTE WELL!!!  This MUST be last.
  DUPLICATE-FIRST-WORD				;Duplicates the type word
  )

#+3600
(DEFSUBST EPACKET-WIRED-P (EPACKET)
  (NOT (EQL (EPACKET-PHYSICAL-ADDRESS EPACKET) -1)))

#+3600
;;; Storing the physical address will set this to T, so only set it for the false
;;; case.
(CL:DEFSETF EPACKET-WIRED-P (EPACKET) (VALUE)
  `(OR ,VALUE
       (PROGN (SETF (EPACKET-PHYSICAL-ADDRESS ,EPACKET) -1)
	      NIL)))

;;; The following two structure definitions are convoluted in an effort
;;; to keep the naming the same as on the 3600, while at the same time
;;; allowing the SOFTWARE-EPACKET to be "wrapped around" the actual
;;; ethernet packet.  The ethernet driver code can simply copy the
;;; packet into the EPACKET portion of the SOFTWARE-EPACKET.

#+IMACH
;;; N.B.  This is D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")included in0 the EPACKET definition!
(DEFSTRUCT (SOFTWARE-EPACKET :NAMED-ARRAY-LEADER
			     (:CONC-NAME EPACKET-)
			     (:SIZE-SYMBOL SOFTWARE-EPACKET-SIZE))
  DATA-LENGTH					;length of the ether packet in octets
  LINK
  STATUS					;Status of this packet
  SUB-PACKET					;A PACKET
  THREAD					;Threads all ether packets together
  REF-COUNT					;so we don't accidentally free a packet twice
  ROUTING-WORD
  TIME
  )

(DEFSYSBYTE %%ROUTING-ADDRESS 8. 0.)
(DEFSYSBYTE %%ROUTING-INTERFACE 8. 8.)

#+IMACH
;; This is exactly the header of the packet
(DEFSTRUCT (EPACKET :ARRAY :CONC-NAME (:SIZE-SYMBOL EPACKET-HEADER-SIZE))
  DEST-HIGH					;Destination high 32 bits
  ((ADDRESS-WORD-2)
   (DEST-LOW (BYTE 16 0))			;Destination low 16 bits
   ;(SRC-HIGH (BYTE 16 16))			;Source high 16 bits (defined below)
   )
  SRC-LOW					;Source low 32 bits
  ((ENTIRE-FIRST-WORD)
   (TYPE (BYTE 16 0))				;packet type 
   ;(FIRST-WORD (BYTE 16 16))			;defined below
   )
  )

;;; These two have to be done by hand because DEFSTRUCT uses LDB instead of %LOGLDB.
(DEFSUBST EPACKET-FIRST-WORD (EPACKET)
  (%LOGLDB (BYTE 16 16) (EPACKET-ENTIRE-FIRST-WORD EPACKET)))

(DEFSUBST EPACKET-SRC-HIGH (EPACKET)
  (%LOGLDB (BYTE 16 16) (EPACKET-ADDRESS-WORD-2 EPACKET)))

#+IMACH
(DEFSUBST EPACKET-WIRED-P (EPACKET)
  (NOT (ZEROP (%LOGLDB %%PACKET-STATUS-WIRED (EPACKET-STATUS EPACKET)))))

#+IMACH
;;; Storing the physical address will do the word, so this is just a no-op.
;(CL:DEFSETF EPACKET-WIRED-P (EPACKET) (VALUE)
;  (ONCE-ONLY (VALUE)
;    `(PROGN
;       (SETF (%LOGLDB %%PACKET-STATUS-WIRED (EPACKET-STATUS ,EPACKET))
;	     (IF ,VALUE 1 0))
;       ,VALUE)))
(CL:DEFSETF EPACKET-WIRED-P (EPACKET) (VALUE)
  ;; The compiler is too stupid to do the efficient thing with the above, correct,
  ;; definition.
  `(PROGN
     (SETF (%LOGLDB %%PACKET-STATUS-WIRED (EPACKET-STATUS ,EPACKET))
	   (IF ,VALUE 1 0))
     ,VALUE))

#+3600
;;; a 3600 packet needs one more leader slot to point to the Ether packet
(DEFSTRUCT (3600-PACKET (:INCLUDE NETI:PACKET) (:SIZE-SYMBOL 3600-PACKET-LEADER-SIZE))
  PACKET-ETHER-PACKET				;the software epacket
  )

#+IMACH
;;; an IMACH packet needs one more leader slot to point to the Ether packet
(DEFSTRUCT (IMACH-PACKET (:INCLUDE NETI:PACKET) (:SIZE-SYMBOL IMACH-PACKET-LEADER-SIZE))
  PACKET-ETHER-PACKET				;the software epacket
  )

;;; ++ maybe this wants to be PACKET-BEING-TRANSMITTED-P
;;; takes a packet or any of its subpackets 
(DEFUN PACKET-BEING-TRANSMITTED (SUB-PACKET)
  #+3600
  (LET ((STATUS (EPACKET-STATUS (PACKET-ETHER-PACKET (SUB-PACKET-PACKET SUB-PACKET)))))
    (AND (LDB-TEST %%PACKET-STATUS-DO-NOT-FREE STATUS)
	 (NOT (LDB-TEST %%PACKET-STATUS-TRANSMIT-DONE STATUS))))
  #+IMACH
  (< 1 (EPACKET-REF-COUNT (PACKET-ETHER-PACKET (SUB-PACKET-PACKET SUB-PACKET)))))


  ;;
;;;;;;  Packet creation, wiring, etc
  ;;

;;; This knows that the array header will only be one word.
#+3600
(DEFCONSTANT ETHER-PACKET-DATA-SIZE (- (* SYS:PAGE-SIZE 2) SOFTWARE-EPACKET-SIZE 1))

#+IMACH
;;; This knows that the array will be short form, and that there will be two headers,
;;; one for the leader and one for the array.
(DEFCONSTANT ETHER-PACKET-DATA-SIZE (- (* SYS:PAGE-SIZE 2)
				       SOFTWARE-EPACKET-SIZE
				       EPACKET-HEADER-SIZE
				       2))

(DEFCONSTANT RAW-PACKET-BUFFER-SIZE (* (1+ (* 2 ETHER-PACKET-DATA-SIZE)) 2))

(DEFVAR *PACKET-BUFFERS* NIL
  "epackets (arrays), linked through epacket-thread")

(DEFVAR *UNWIRED-PACKET-BUFFERS* %NET-NULL
  "epackets (arrays), linked through epacket-link, similar to
   %net-free-list (which uses physical address linked through
   ether-packet-link)")

(DEFCONST *MAXIMUM-NUMBER-OF-WIRED-PACKET-BUFFERS* 192.)
(DEFCONST *TARGET-NUMBER-OF-WIRED-PACKET-BUFFERS* 64)

(DEFVAR *ACTUAL-NUMBER-OF-WIRED-PACKET-BUFFERS* 0)
(DEFVAR *NUMBER-OF-UNWIRED-PACKET-BUFFERS* 0)

#+IMACH
(DEFWIREDVAR *N-FREE-WIRED-PACKET-BUFFERS* 0)

#+3600
(DEFVAR *N-FREE-WIRED-PACKET-BUFFERS* 0)

(DEFVAR *N-FREE-UNWIRED-PACKET-BUFFERS* 0)

(DEFMACRO WITH-EXTRA-PACKET-BUFFERS ((EXTRA-PACKETS) &BODY BODY &ENVIRONMENT ENV)
  (ONCE-ONLY (EXTRA-PACKETS &ENVIRONMENT ENV)
    `(UNWIND-PROTECT
	 (PROGN (INCF *TARGET-NUMBER-OF-WIRED-PACKET-BUFFERS* ,EXTRA-PACKETS)
		,@BODY)
       (DECF *TARGET-NUMBER-OF-WIRED-PACKET-BUFFERS* ,EXTRA-PACKETS))))

#+3600
(DEFUN ALLOCATE-WIRED-PACKET-BUFFER-INTERNAL ()
  (WITHOUT-INTERRUPTS
    (LOOP FOR ETHER-PACKET = %NET-FREE-LIST
	  UNTIL (EQL ETHER-PACKET %NET-NULL)
	  WHEN (STORE-CONDITIONAL (LOCF %NET-FREE-LIST)
				  ETHER-PACKET (ETHER-PACKET-LINK ETHER-PACKET))
	    DO (DECF *N-FREE-WIRED-PACKET-BUFFERS*)
	       (LET ((EPACKET (ETHER-PACKET-SOFTWARE-PACKET ETHER-PACKET)))
		 (SETF (EPACKET-LINK EPACKET) %NET-NULL)
		 (RETURN EPACKET)))))


1;;; Known to be called in interrupt mode so we are safe from contention
0#+IMACH
(DEFWIREDFUN ALLOCATE-WIRED-PACKET-BUFFER-VERY-INTERNAL ()
  (LET ((EPACKET %NET-FREE-LIST))
    (WHEN EPACKET
      (SETQ %NET-FREE-LIST (EPACKET-LINK EPACKET))
      (DECF *N-FREE-WIRED-PACKET-BUFFERS*)
      (SETF (EPACKET-LINK EPACKET) %NET-NULL)
      EPACKET)))

#+IMach
(defsubst ALLOCATE-WIRED-PACKET-BUFFER-INTERNAL ()
  (%FUNCALL-IN-TRAP-MODE (%SET-TRAP-MODE TRAP-MODE-IO)
			 #'ALLOCATE-WIRED-PACKET-BUFFER-VERY-INTERNAL))

#+3600
(DEFUN DEALLOCATE-WIRED-PACKET-BUFFER-INTERNAL (EPACKET &OPTIONAL (WAKEUP-IF-NECESSARY T))
  (WITHOUT-INTERRUPTS
    (LOOP WITH ETHER-PACKET = (EPACKET-PHYSICAL-ADDRESS EPACKET)
	  FOR OLD-LIST = %NET-FREE-LIST
	  DO (SETF (EPACKET-LINK EPACKET) OLD-LIST)
	  UNTIL (STORE-CONDITIONAL (LOCF %NET-FREE-LIST) OLD-LIST ETHER-PACKET)
	  FINALLY (WHEN (AND WAKEUP-IF-NECESSARY (EQL OLD-LIST %NET-NULL))
		    (WHEN (EQ *IO-BOARD-TYPE* :OBS)
		      ;; --- NBS ucode should provide a no-op stub
		      (%NET-WAKEUP))))
    (INCF *N-FREE-WIRED-PACKET-BUFFERS*)
    NIL))

1;;; Known to be called in interrupt mode (really without-interrupts!)
0#+IMACH
(DEFWIREDFUN DEALLOCATE-WIRED-PACKET-BUFFER-VERY-INTERNAL
	     (EPACKET)
  (SETF (EPACKET-LINK EPACKET) %NET-FREE-LIST)
  (SETQ %NET-FREE-LIST EPACKET)
  (INCF *N-FREE-WIRED-PACKET-BUFFERS*))

#+IMach
(DEFSUBST DEALLOCATE-WIRED-PACKET-BUFFER-INTERNAL (EPACKET)
  (%FUNCALL-IN-TRAP-MODE (%SET-TRAP-MODE TRAP-MODE-IO)
			 #'DEALLOCATE-WIRED-PACKET-BUFFER-VERY-INTERNAL
			 EPACKET))

;;;

(DEFUN ALLOCATE-UNWIRED-PACKET-BUFFER-INTERNAL ()
  (WITHOUT-INTERRUPTS
    (LET ((EPACKET *UNWIRED-PACKET-BUFFERS*))
      (IF (EQL EPACKET %NET-NULL)
	  (SETF EPACKET (MAKE-ETHER-PACKET))
	  (PROGN (SETF *UNWIRED-PACKET-BUFFERS* (EPACKET-LINK EPACKET))
		 (DECF *N-FREE-UNWIRED-PACKET-BUFFERS*)))
      ;; [Maybe look at this flag someday.]
      (SETF (EPACKET-LINK EPACKET) %NET-NULL)
      EPACKET)))

(DEFUN DEALLOCATE-UNWIRED-PACKET-BUFFER-INTERNAL (EPACKET)
  (WITHOUT-INTERRUPTS
    (WHEN (EPACKET-WIRED-P EPACKET)
      (FERROR "Attempt to free a wired packet buffer as an unwired packet buffer."))
    (SETF (EPACKET-LINK EPACKET) *UNWIRED-PACKET-BUFFERS*)
    (SETF *UNWIRED-PACKET-BUFFERS* EPACKET)
    (INCF *N-FREE-UNWIRED-PACKET-BUFFERS*)
    NIL))

;;;

(DEFVAR *PACKET-BUFFERS-ENABLED* NIL)

(DEFUN RESET-PACKET-BUFFERS ()
  (SETQ *PACKET-BUFFERS-ENABLED* NIL)
  (MAP-PACKET-BUFFERS
    #'(LAMBDA (PACKET)
	(LET ((EPACKET (PACKET-ETHER-PACKET PACKET)))
	  (UNWIRE-ETHER-PACKET EPACKET))))
  (SETQ %NET-FREE-LIST %NET-NULL
	*ACTUAL-NUMBER-OF-WIRED-PACKET-BUFFERS* 0
	*N-FREE-WIRED-PACKET-BUFFERS* 0)
  (SETQ *UNWIRED-PACKET-BUFFERS* %NET-NULL
	*NUMBER-OF-UNWIRED-PACKET-BUFFERS* 0
	*N-FREE-UNWIRED-PACKET-BUFFERS* 0)
  NIL)

(DEFUN COUNT-WIRED-EPACKETS ()
  (LOOP FOR EPACKET FIRST *PACKET-BUFFERS* THEN (EPACKET-THREAD EPACKET)
	WHILE EPACKET
	COUNT (EPACKET-WIRED-P EPACKET)))

(DEFUN ENABLE-PACKET-BUFFERS ()
  (WHEN (NOT *PACKET-BUFFERS-ENABLED*)
    (UNLESS *PACKET-BUFFERS*
      (CREATE-PACKET-BUFFERS))
    ;; get the entire area paged in, we are likely to touch everything in it.
    (PAGE-IN-AREA ETHER-BUFFER-AREA :HANG-P NIL)
    ;; reset all the counters, since we're going to be starting from scratch
    (SETQ %NET-FREE-LIST %NET-NULL
	  *ACTUAL-NUMBER-OF-WIRED-PACKET-BUFFERS* 0
	  *N-FREE-WIRED-PACKET-BUFFERS* 0)
    (SETQ *UNWIRED-PACKET-BUFFERS* %NET-NULL
	  *NUMBER-OF-UNWIRED-PACKET-BUFFERS* 0
	  *N-FREE-UNWIRED-PACKET-BUFFERS* 0)
    ;; put the packets on the free lists.
    (LOOP FOR EPACKET FIRST *PACKET-BUFFERS* THEN (EPACKET-THREAD EPACKET)
	  WHILE EPACKET
	  DO (SETF (EPACKET-REF-COUNT EPACKET) 0) 
	     (INCF *NUMBER-OF-UNWIRED-PACKET-BUFFERS*)
	     (IF (< *ACTUAL-NUMBER-OF-WIRED-PACKET-BUFFERS*
		    *TARGET-NUMBER-OF-WIRED-PACKET-BUFFERS*)
		 (DEALLOCATE-WIRED-PACKET-BUFFER-INTERNAL
		   (WIRE-ETHER-PACKET EPACKET)
		   #+3600 NIL)
		 (DEALLOCATE-UNWIRED-PACKET-BUFFER-INTERNAL
		   EPACKET)))
    (SETQ *PACKET-BUFFERS-ENABLED* T)))

(DEFUN CREATE-PACKET-BUFFERS (&OPTIONAL (N *TARGET-NUMBER-OF-WIRED-PACKET-BUFFERS*))
  ;; just create.  Don't link or anything else
  (WHEN (NULL *PACKET-BUFFERS*)			;Haven't made the packets yet
    (LOOP REPEAT N DO (MAKE-ETHER-PACKET)))
  NIL)

(DEFUN MAP-PACKET-BUFFERS (FUNCTION &REST OTHER-FUNCTION-ARGS)
  (DECLARE (SYS:DOWNWARD-FUNARG FUNCTION))
  (LOOP FOR EPACKET FIRST *PACKET-BUFFERS* THEN (EPACKET-THREAD EPACKET)
	WHILE EPACKET
	DO (LEXPR-FUNCALL FUNCTION (EPACKET-SUB-PACKET EPACKET) OTHER-FUNCTION-ARGS)))

;;; One of the half-words from the data overlaps the software array.
(DEFUN MAKE-ETHER-PACKET (&OPTIONAL (AREA ETHER-BUFFER-AREA))
  (LET* ((ETHER-PACKET
	   (PROGN #+3600
		  (MAKE-ARRAY (+ SOFTWARE-EPACKET-SIZE ETHER-PACKET-DATA-SIZE)
			      :AREA AREA
			      :NAMED-STRUCTURE-SYMBOL 'SOFTWARE-EPACKET
			      :INITIAL-VALUE 0)
		  #+IMACH
		  (MAKE-ARRAY (+ ETHER-PACKET-DATA-SIZE EPACKET-HEADER-SIZE)
			      :LEADER-LENGTH SOFTWARE-EPACKET-SIZE
			      :AREA AREA
			      :NAMED-STRUCTURE-SYMBOL 'SOFTWARE-EPACKET
			      :INITIAL-VALUE 0)))
	 (SUB-PACKET (MAKE-ARRAY RAW-PACKET-BUFFER-SIZE
				 :TYPE 'ART-8B
				 :AREA AREA
				 :LEADER-LENGTH (PROGN #+3600 3600-PACKET-LEADER-SIZE
						       #+IMACH IMACH-PACKET-LEADER-SIZE)
				 :DISPLACED-TO ETHER-PACKET
				 :DISPLACED-INDEX-OFFSET
				   (* (1- (* 2 (PROGN
						 #+3600 SOFTWARE-EPACKET-SIZE
						 #+IMACH EPACKET-HEADER-SIZE)))
				      2)))
	 (SUB-PACKET-ENTRY (MAKE-ARRAY (- PAGE-SIZE
					  (%STRUCTURE-TOTAL-SIZE SUB-PACKET)
					  (PROGN #+3600 2
						 #+IMACH 3))
				       :FILL-POINTER 0
				       :AREA AREA)))
    #+IMACH
    (SETF (EPACKET-ROUTING-WORD ETHER-PACKET) 0)
    ;; Everything in ETHER-BUFFER-AREA has to be page-aligned because the packet
    ;; buffers can be accessed by physical address.  This error check is only
    ;; looking for programming mistakes and should never go off.
    #+3600
    (UNLESS (ZEROP (LDB %%VMA-WORD-OFFSET (%POINTER ETHER-PACKET)))
      (ERROR "Page alignment failure ~O in ETHER-BUFFER-AREA" (%POINTER ETHER-PACKET)))
    #+(and IMACH (not vlm))
    (UNLESS (EQL (LDB %%VMA-WORD-OFFSET (%POINTER ETHER-PACKET))
		 (+ SOFTWARE-EPACKET-SIZE 1))
      (ERROR "Page alignment failure ~O in ETHER-BUFFER-AREA" (%POINTER ETHER-PACKET)))

    (SETF (SUB-PACKET-PACKET SUB-PACKET) SUB-PACKET)
    (SETF (SUB-PACKET-BYTE-OFFSET SUB-PACKET) 0)
    (SETF (EPACKET-SUB-PACKET ETHER-PACKET) SUB-PACKET)
    (SETF (PACKET-ETHER-PACKET SUB-PACKET) ETHER-PACKET)
    (SETF (PACKET-SUB-PACKETS SUB-PACKET) SUB-PACKET-ENTRY)
    (SETF (EPACKET-LINK ETHER-PACKET) %NET-NULL)
    #+3600
    (PROGN
      (SETF (EPACKET-RCV-TERMINATOR ETHER-PACKET) %NET-NULL)
      (SETF (EPACKET-XMT-TERMINATOR ETHER-PACKET) %NET-NULL))
    #+3600
    (SETF (EPACKET-SOFTWARE-PACKET ETHER-PACKET) ETHER-PACKET)
    (SETF (EPACKET-REF-COUNT ETHER-PACKET) 0)
    #+3600
    (SETF (EPACKET-PHYSICAL-ADDRESS ETHER-PACKET) %NET-NULL)	;not wired yet
    #+IMACH
    (SETF (EPACKET-STATUS ETHER-PACKET) 0)
    (WITHOUT-INTERRUPTS
      (SETF (EPACKET-THREAD ETHER-PACKET) *PACKET-BUFFERS*)
      (SETF *PACKET-BUFFERS* ETHER-PACKET)	    
      (INCF *NUMBER-OF-UNWIRED-PACKET-BUFFERS*))
    ETHER-PACKET))

;;;

;;; This gets called again on cold boot to update physical addresses of wired structures.
(DEFUN WIRE-ETHER-PACKET (PACKET)
  (UNLESS (EPACKET-WIRED-P PACKET)
    ;;+++ There is still a bug in wiring pages that are still being
    ;;prefetched.  Avoid this for now by actually touching the pages
    ;;before doing the actual wiring.
    (AREF PACKET 0)
    (AREF PACKET SYS:PAGE-SIZE)			;known to be two pages
    ;;
    (SI:WIRE-STRUCTURE PACKET)
    #+3600
    (LET* ((OFFSET (LOGAND (1- SYS:PAGE-SIZE)
			   (%POINTER (LOCF (AREF PACKET SOFTWARE-EPACKET-SIZE)))))
	   (LENGTH-0 (- SYS:PAGE-SIZE OFFSET)))
      (SETF (EPACKET-RCV-0-ADDRESS PACKET)
	    (OR (SI:%VMA-TO-WIRED-PMA (%POINTER (LOCF (AREF PACKET SOFTWARE-EPACKET-SIZE))))
		(FERROR "Packet not wired?")))
      (COND (( LENGTH-0 ETHER-PACKET-DATA-SIZE)
	     (SETF (EPACKET-RCV-0-LENGTH PACKET) ETHER-PACKET-DATA-SIZE)
	     (SETF (EPACKET-RCV-1-ADDRESS PACKET) %NET-NULL))
	    (T
	     (SETF (EPACKET-RCV-0-LENGTH PACKET) LENGTH-0)
	     (SETF (EPACKET-RCV-1-ADDRESS PACKET)
		   (OR (SI:%VMA-TO-WIRED-PMA
			 (%POINTER (LOCF (AREF PACKET (+ SOFTWARE-EPACKET-SIZE LENGTH-0)))))
		       (FERROR "Packet not wired?")))
	     (SETF (EPACKET-RCV-1-LENGTH PACKET)
		   (- ETHER-PACKET-DATA-SIZE LENGTH-0))))
      (SETF (EPACKET-XMT-0-ADDRESS PACKET)
	    (EPACKET-RCV-0-ADDRESS PACKET))
      (SETF (EPACKET-XMT-0-LENGTH PACKET)
	    (EPACKET-RCV-0-LENGTH PACKET))
      (SETF (EPACKET-XMT-1-ADDRESS PACKET)
	    (EPACKET-RCV-1-ADDRESS PACKET))
      (SETF (EPACKET-XMT-1-LENGTH PACKET)
	    (EPACKET-RCV-1-LENGTH PACKET))
      (SETF (EPACKET-PHYSICAL-ADDRESS PACKET)
	    (OR (SI:%VMA-TO-WIRED-PMA (%POINTER (LOCF (EPACKET-LINK PACKET))))
		(FERROR "Packet not wired?"))))
    (SETF (EPACKET-WIRED-P PACKET) T)
    #+IMACH
    (PROGN
      (LOOP FOR NUMBER-OF-UNWIRED-PACKET-BUFFERS = *NUMBER-OF-UNWIRED-PACKET-BUFFERS*
	    UNTIL
	      (STORE-CONDITIONAL
		(LOCF *NUMBER-OF-UNWIRED-PACKET-BUFFERS*)
		NUMBER-OF-UNWIRED-PACKET-BUFFERS
		(1- NUMBER-OF-UNWIRED-PACKET-BUFFERS)))
      (LOOP FOR ACTUAL-NUMBER-OF-WIRED-PACKET-BUFFERS = *ACTUAL-NUMBER-OF-WIRED-PACKET-BUFFERS*
	    UNTIL
	      (STORE-CONDITIONAL
		(LOCF *ACTUAL-NUMBER-OF-WIRED-PACKET-BUFFERS*)
		ACTUAL-NUMBER-OF-WIRED-PACKET-BUFFERS
		(1+ ACTUAL-NUMBER-OF-WIRED-PACKET-BUFFERS))))
    #+3600
    (PROGN
      (DECF *NUMBER-OF-UNWIRED-PACKET-BUFFERS*)
      (INCF *ACTUAL-NUMBER-OF-WIRED-PACKET-BUFFERS*)))
  PACKET)

(DEFUN UNWIRE-ETHER-PACKET (PACKET)
  (WHEN (EPACKET-WIRED-P PACKET)
    (SETF (EPACKET-WIRED-P PACKET) NIL)
    (SI:UNWIRE-STRUCTURE PACKET)
    #+IMACH
    (PROGN
      (LOOP FOR ACTUAL-NUMBER-OF-WIRED-PACKET-BUFFERS = *ACTUAL-NUMBER-OF-WIRED-PACKET-BUFFERS*
	    UNTIL
	      (STORE-CONDITIONAL
		(LOCF *ACTUAL-NUMBER-OF-WIRED-PACKET-BUFFERS*)
		ACTUAL-NUMBER-OF-WIRED-PACKET-BUFFERS
		(1- ACTUAL-NUMBER-OF-WIRED-PACKET-BUFFERS)))
      (LOOP FOR NUMBER-OF-UNWIRED-PACKET-BUFFERS = *NUMBER-OF-UNWIRED-PACKET-BUFFERS*
	    UNTIL
	      (STORE-CONDITIONAL
		(LOCF *NUMBER-OF-UNWIRED-PACKET-BUFFERS*)
		NUMBER-OF-UNWIRED-PACKET-BUFFERS
		(1+ NUMBER-OF-UNWIRED-PACKET-BUFFERS))))
    #+3600
    (PROGN
      (DECF *ACTUAL-NUMBER-OF-WIRED-PACKET-BUFFERS*)
      (INCF *NUMBER-OF-UNWIRED-PACKET-BUFFERS*)))
  PACKET)


1;;; Big Packets

0(defvar (2 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")*big-packet-size* 0nil
  :documentation "Bound to desired packet size inside a with-big-packets for packets > 1990.")

(defmacro 2with-big-packets 0((&optional (size 8192.)) &body body)
  `(let ((*big-packet-size* ,size))
     ,@body))

(defmacro 2without-big-packets 0(&body body)
  `(let ((*big-packet-size* nil))
     ,@body))

(defvar 2big-packet-cons-area0 (make-area :name 'big-packet-cons-area))

(defconstant 2*big-packet-sub-packet-offset* 0#+3600 104 #+IMach 16)

(defsubst2 compute-big-packet-software-epacket-size0 (bytes)
  (let ((words (sys:%fixnum-ceiling (+ *big-packet-sub-packet-offset* bytes) 4)))
    (* (max (sys:%fixnum-ceiling words page-size) 2) page-size)))

1;;; Minimum size for a big-packet is 1024 bytes
0(defun 2make-big-packet0 (&optional (size 8192) (area big-packet-cons-area))
  (let* ((word-size				;words
	   (compute-big-packet-software-epacket-size size))
	 (ether-packet
	   (progn #+3600
		  (make-array word-size
			      :area area
			      :named-structure-symbol 'software-epacket
			      :initial-value 0)
		  #+imach
		  (make-array word-size
			      :leader-length software-epacket-size
			      :area area
			      :named-structure-symbol 'software-epacket
			      :initial-value 0)))
	 (sub-packet (make-array (- (* word-size 4) *big-packet-sub-packet-offset*)
				 :type 'art-8b
				 :area area
				 :leader-length (progn #+3600 3600-packet-leader-size
						       #+imach imach-packet-leader-size)
				 :displaced-to ether-packet
				 :displaced-index-offset *big-packet-sub-packet-offset*))
	 (sub-packet-entry (make-array (- page-size
					  (%structure-total-size sub-packet)
					  (progn #+3600 2
						 #+imach 3))
				       :fill-pointer 0
				       :area area)))
    #+imach
    (setf (epacket-routing-word ether-packet) 0)
    (setf (sub-packet-packet sub-packet) sub-packet)
    (setf (sub-packet-byte-offset sub-packet) 0)
    (setf (epacket-sub-packet ether-packet) sub-packet)
    (setf (packet-ether-packet sub-packet) ether-packet)
    (setf (packet-sub-packets sub-packet) sub-packet-entry)
    (setf (epacket-link ether-packet) %net-null)
    #+3600
    (progn
      (setf (epacket-rcv-terminator ether-packet) %net-null)
      (setf (epacket-xmt-terminator ether-packet) %net-null))
    #+3600
    (setf (epacket-software-packet ether-packet) ether-packet)
    (setf (epacket-ref-count ether-packet) 0)
    #+3600
    (setf (epacket-physical-address ether-packet) %net-null)	;not wired yet
    #+imach
    (setf (epacket-status ether-packet) 0)
    ether-packet))


(defresource 2big-network-packet 0(&optional (size 8192.))
  :constructor (epacket-sub-packet (make-big-packet size))
  :initial-copies 0.
  1;; Match to something the same number of pages in size
0  :matcher (= (array-total-size (packet-ether-packet object))
	      (compute-big-packet-software-epacket-size size)))

1;;; This is really the number currently in use
0(defvar 2*maximum-number-of-big-packets* 0256.)

(defvar 2*actual-number-of-big-packets* 00)

(defun 2allocate-big-packet 0(&optional (size 8192.) (wait-p t))
  (when (> *actual-number-of-big-packets* *maximum-number-of-big-packets*)
    (packet-buffer-panic))
  (when (and wait-p (> *actual-number-of-big-packets* *maximum-number-of-big-packets*))
    (block normal
      (catch-error-restart (sys:break "Allow more big packet buffers")
	(return-from normal
	  (process-wait "Big Packet buffer"
	    #'(lambda () ( *actual-number-of-big-packets* *maximum-number-of-big-packets*)))))
      (setq *maximum-number-of-big-packets*
	    (ceiling (* *maximum-number-of-big-packets* 1.5)))))
  (incf *actual-number-of-big-packets*)
  (allocate-resource 'big-network-packet size))

(defun 2deallocate-big-packet 0(buffer)
  (deallocate-resource
    'big-network-packet
    #+IMach
    (epacket-sub-packet (packet-ether-packet (sub-packet-packet buffer)))
    #+3600
    (sub-packet-packet buffer))
  (decf *actual-number-of-big-packets*))


(defun 2big-packet-p 0(buffer)
  (= (si:array-index-offset
       #+IMach
       (epacket-sub-packet (packet-ether-packet (sub-packet-packet buffer)))
       #+3600
       (sub-packet-packet buffer))
     *big-packet-sub-packet-offset*))


;;;



;; packet buffer (panic) policy: 

;; Somebody may occasionally call maybe-packet-buffer-panic, which is
;; responsible for determining if things are winning or losing.  If they
;; are losing, it calls packet-buffer-panic.  If things are still
;; losing, it calls create-more-wired-packet-buffers with a numeric
;; argument (currently 8) to create some more (wired) packet buffers.

;; If create-more-wired-packet-buffers can reuse
;; existing unwired buffers, it does.  If not, it creates the number
;; requested, unless the maximum is already exceeded or too many wired
;; pages would exist.

;; To allocate a packet buffer, the user calls ALLOCATE-PACKET-BUFFER.
;; This tries to get a wired packet buffer.  If that fails, it tries to
;; panic.  If that fails, it tries wiring some packets from the unwired
;; pool.  If that fails, it tries creating some new wired packets.  If
;; that fails, it process-waits.  A restart handler is set up so that if
;; the user hits c-m-Suspend, she will be offered with an option to
;; allow more.  Doing so ups the allowed number by 50% and tries again.

(DEFUN MAYBE-PACKET-BUFFER-PANIC ()
  #+3600
  (WHEN (EQ SYS:*IO-BOARD-TYPE* :OBS)
    ;; --- NBS microcode should define a no-op stub for this.
    (%NET-WAKEUP))
  (WHEN (EQL %NET-FREE-LIST %NET-NULL)
    (PACKET-BUFFER-PANIC))
  (WHEN (EQL %NET-FREE-LIST %NET-NULL)
    (CREATE-MORE-WIRED-PACKET-BUFFERS 8)))

(DEFUN PACKET-BUFFER-PANIC ()
  (DECLARE (SPECIAL *LOCAL-NETWORKS* *INTERFACES*))
  (WITHOUT-INTERRUPTS
    (INCF *PACKET-BUFFER-PANICS*)
    (DOLIST (NETWORK *LOCAL-NETWORKS*)
      (SEND NETWORK ':SEND-IF-HANDLES ':PACKET-BUFFER-PANIC))
    (DOLIST (INTERFACE *INTERFACES*)
      (SEND INTERFACE ':PACKET-BUFFER-PANIC))))

(DEFUN CREATE-MORE-WIRED-PACKET-BUFFERS (NUMBER)
  (DECLARE (ARGLIST NUMBER-OR-NIL-TO-USE-EXISTING-UNWIRED-PACKETS))
  (WITHOUT-INTERRUPTS
    (LOOP REPEAT (COND ((OR (NOT NUMBER)
			    (<= NUMBER *NUMBER-OF-UNWIRED-PACKET-BUFFERS*))
			;; can use existing packets for entire request.
			;; Move at least half, on the grounds that we're
			;; out of wired packets and somebody probably
			;; wants more anyway.
			(CEILING *NUMBER-OF-UNWIRED-PACKET-BUFFERS* 2))
		       ((> (+ *ACTUAL-NUMBER-OF-WIRED-PACKET-BUFFERS* NUMBER)
			   *MAXIMUM-NUMBER-OF-WIRED-PACKET-BUFFERS*)
			;; Creating new ones would exceed max
			0)
		       #-vlm
		       (( SI:*COUNT-WIRED-PAGES* (TRUNCATE SI:*COUNT-NORMAL-PAGES* 4))
			;; Creating new ones could wire too much memory
			0)
		       (T ;; no other reason not to...
			NUMBER))
	  DO
      (DEALLOCATE-WIRED-PACKET-BUFFER-INTERNAL (WIRE-ETHER-PACKET
						 (ALLOCATE-UNWIRED-PACKET-BUFFER-INTERNAL))))))


(DEFUN ALLOCATE-PACKET-BUFFER (&OPTIONAL (WAIT-P T))
  (if (and (numberp *big-packet-size*)
	   (> *big-packet-size* raw-packet-buffer-size))
      (allocate-big-packet *big-packet-size* wait-p)
      (LOOP WITH TRY-CREATING-TO-TARGET-LEVEL = T
	    WITH TRY-PANIC = T
	    WITH TRY-WIRING-FROM-UNWIRED-POOL = T 
	    WITH TRY-CREATING-MORE = T
	    DO
	(LET ((EPACKET (ALLOCATE-WIRED-PACKET-BUFFER-INTERNAL)))
	  (COND (EPACKET
		 (WITHOUT-INTERRUPTS
		   (LET ((REF-COUNT (EPACKET-REF-COUNT EPACKET)))
		     (UNLESS (= REF-COUNT 0)
		       (FERROR "About to allocate packet ~S which has a non-zero ref-count"
			       EPACKET))
		     (SETF (EPACKET-REF-COUNT EPACKET) (1+ REF-COUNT)))
		   #+3600 (SETF (EPACKET-STATUS EPACKET) 0)
		   (INCF *PKTS-ALLOCATED*)
		   (RETURN (EPACKET-SUB-PACKET EPACKET))))
		((AND TRY-CREATING-TO-TARGET-LEVEL
		      (< *ACTUAL-NUMBER-OF-WIRED-PACKET-BUFFERS*
			 *TARGET-NUMBER-OF-WIRED-PACKET-BUFFERS*))
		 (SETQ TRY-CREATING-TO-TARGET-LEVEL NIL)
		 (CREATE-MORE-WIRED-PACKET-BUFFERS
		   (- *TARGET-NUMBER-OF-WIRED-PACKET-BUFFERS*
		      *ACTUAL-NUMBER-OF-WIRED-PACKET-BUFFERS*)))
		((NOT WAIT-P)
		 (COND (TRY-WIRING-FROM-UNWIRED-POOL
			(SETQ TRY-WIRING-FROM-UNWIRED-POOL NIL)
			(CREATE-MORE-WIRED-PACKET-BUFFERS NIL))
		       ;; no packet, not more options, return NIL.
		       (T (RETURN NIL))))
		(TRY-PANIC
		 (SETQ TRY-PANIC NIL)
		 (PACKET-BUFFER-PANIC))
		(TRY-WIRING-FROM-UNWIRED-POOL
		 (SETQ TRY-WIRING-FROM-UNWIRED-POOL NIL)
		 (CREATE-MORE-WIRED-PACKET-BUFFERS NIL))
		(TRY-CREATING-MORE
		 (SETQ TRY-CREATING-MORE NIL)
		 (CREATE-MORE-WIRED-PACKET-BUFFERS 8))
		(T (BLOCK NORMAL
		     (CATCH-ERROR-RESTART (SYS:BREAK "Allow more packet buffers")
		       (RETURN-FROM NORMAL
			 (PROCESS-WAIT "Packet buffer"
			   #'(LAMBDA () (NOT (EQL %NET-FREE-LIST %NET-NULL))))))
		     (SETQ *MAXIMUM-NUMBER-OF-WIRED-PACKET-BUFFERS*
			   (CEILING (* *MAXIMUM-NUMBER-OF-WIRED-PACKET-BUFFERS* 1.5)))
		     (SETQ TRY-CREATING-TO-TARGET-LEVEL T
			   TRY-CREATING-MORE T))))))))

;;; This takes a packet or any of its subpackets
#+3600
(DEFUN DEALLOCATE-PACKET-BUFFER (BUFFER)
  (WITHOUT-INTERRUPTS ;; mostly for (incf *pkts-deallocated*)
    (LET* ((EPACKET (PACKET-ETHER-PACKET (SUB-PACKET-PACKET BUFFER)))
	   (REF-COUNT (EPACKET-REF-COUNT EPACKET)))
      (if (big-packet-p buffer)
	  (deallocate-big-packet buffer)
	  (WHEN (> REF-COUNT 0)
	    (SETF (EPACKET-REF-COUNT EPACKET) (1- REF-COUNT)))
	  (WHEN (= REF-COUNT 1)
	    (PROG ((STATUS-LOC (LOCF (EPACKET-STATUS EPACKET)))
		   STATUS)
	       TEST-AGAIN
		  (SETQ STATUS (LOCATION-CONTENTS STATUS-LOC))
		  (UNLESS (LDB-TEST %%PACKET-STATUS-DO-NOT-FREE STATUS)
		    (GO DEALLOCATE-IT))
		  (WHEN (LDB-TEST %%PACKET-STATUS-TRANSMIT-DONE STATUS)
		    (GO DEALLOCATE-IT))
		  (WHEN (STORE-CONDITIONAL STATUS-LOC STATUS
					   (DPB 0 %%PACKET-STATUS-DO-NOT-FREE STATUS))
		    (INCF *N-FREE-WIRED-PACKET-BUFFERS*)
		    (GO DONT-DEALLOCATE-IT))
		  (GO TEST-AGAIN)
	       DEALLOCATE-IT
		  ;; policy: If the current number of wired buffers is more
		  ;; than the target, and if at least half of the target
		  ;; ones are free, then there is enough hystersis to unwire
		  ;; this one.
		  (IF (AND (> *ACTUAL-NUMBER-OF-WIRED-PACKET-BUFFERS*
			      *TARGET-NUMBER-OF-WIRED-PACKET-BUFFERS*)
			   (> *N-FREE-WIRED-PACKET-BUFFERS*
			      (CEILING *TARGET-NUMBER-OF-WIRED-PACKET-BUFFERS* 2)))
		      (DEALLOCATE-UNWIRED-PACKET-BUFFER-INTERNAL (UNWIRE-ETHER-PACKET EPACKET))
		      (DEALLOCATE-WIRED-PACKET-BUFFER-INTERNAL EPACKET))
		  (INCF *PKTS-DEALLOCATED*)
	       DONT-DEALLOCATE-IT)
	    )))))

#+IMACH
(DEFUN DEALLOCATE-PACKET-BUFFER (BUFFER)
  (LET* ((EPACKET (PACKET-ETHER-PACKET (SUB-PACKET-PACKET BUFFER)))
	 (REF-COUNT (EPACKET-REF-COUNT EPACKET)))
    (if (big-packet-p buffer)
	(deallocate-big-packet buffer)
	(LOOP UNTIL (OR (NOT (> REF-COUNT 0))
			(STORE-CONDITIONAL (LOCF (EPACKET-REF-COUNT EPACKET))
					   REF-COUNT (1- REF-COUNT)))
	      DO (SETQ REF-COUNT (EPACKET-REF-COUNT EPACKET)))	; try again
	;;
	(WHEN (= REF-COUNT 1)
	  ;; policy: If the current number of wired buffers is more than the
	  ;; target, and if at least half of the target ones are free, then
	  ;; there is enough hystersis to unwire this one.
	  (IF (AND (> *ACTUAL-NUMBER-OF-WIRED-PACKET-BUFFERS*
		      *TARGET-NUMBER-OF-WIRED-PACKET-BUFFERS*)
		   (> *N-FREE-WIRED-PACKET-BUFFERS*
		      (CEILING *TARGET-NUMBER-OF-WIRED-PACKET-BUFFERS* 2)))
	      (DEALLOCATE-UNWIRED-PACKET-BUFFER-INTERNAL (UNWIRE-ETHER-PACKET EPACKET))
	      (DEALLOCATE-WIRED-PACKET-BUFFER-INTERNAL EPACKET))
	  (LOOP WITH PKTS-DEALLOCATED-LOC = (LOCF *PKTS-DEALLOCATED*)
		FOR PKTS-DEALLOCATED = *PKTS-DEALLOCATED*
		UNTIL (STORE-CONDITIONAL
			PKTS-DEALLOCATED-LOC
			PKTS-DEALLOCATED
			(1+ PKTS-DEALLOCATED)))))))

#+IMACH
(DEFWIREDFUN WIRED-DEALLOCATE-EPACKET (EPACKET)
  (LET ((REF-LOC (LOCF (EPACKET-REF-COUNT EPACKET))))
    (LOOP DO
      (LET ((REF-COUNT (LOCATION-CONTENTS REF-LOC)))
	(COND ((= 1 REF-COUNT)
	       (WHEN (STORE-CONDITIONAL REF-LOC REF-COUNT 0)
		 (DEALLOCATE-WIRED-PACKET-BUFFER-INTERNAL EPACKET)
		 (PROCESS:ATOMIC-INCF *PKTS-DEALLOCATED*)
		 (RETURN)))
	      ((PLUSP REF-COUNT)
	       (WHEN (STORE-CONDITIONAL REF-LOC REF-COUNT (1- REF-COUNT))
		 (RETURN)))
	      (T
	       (WIRED-FERROR :PROCEEDABLE-HALT "Packet is already free.")))))
    NIL))

#+3600
(DEFUN DEALLOCATE-PACKET-BUFFER-INTERNAL (EPACKET)
  (DEALLOCATE-WIRED-PACKET-BUFFER-INTERNAL EPACKET))


;;; This is only needed when sending a packet to one's self
;;; This is only needed when sending a packet to one's self
(DEFUN COPY-PACKET-BUFFER (PACKET-BUFFER NBYTES &OPTIONAL (WAIT-P T))
  (LET ((NEW-BUFFER (if (big-packet-p packet-buffer)
			(with-big-packets (nbytes)
			  (allocate-packet-buffer wait-p))
			(ALLOCATE-PACKET-BUFFER WAIT-P))))
    (WHEN NEW-BUFFER
      (COPY-ARRAY-PORTION PACKET-BUFFER 0 NBYTES
			  NEW-BUFFER	0 NBYTES))
    NEW-BUFFER))


;;;
;;; This macro should not have to exist, but does, because of the
;;; Ivory's slowness accessing indirect arrays.  In essence, this just
;;; makes a new copy of the packet handle (because you can't declare an
;;; arg to be an array-reg) and declares it an array-reg, around the
;;; body.  Doing this results in about 20X performance per aref on
;;; Ivory, and about 3X on Lmach, at a cost of a little more than an
;;; aref up front.  This should be used anyplace you do two or more
;;; arefs on a packet buffer.  This macro should be taken out when the
;;; compiler is able to recognize situations that call for array regs,
;;; and generate them automatically.
;;;
(defmacro with-network-packet ((packet) &body body)
  `(let ((,packet ,packet))
     (declare (sys:array-register ,packet))
     ,@body))
