;;; -*- Mode: LISP; Package: neti; Base: 10; Lowercase: Yes; Syntax: zetalisp -*-
;; Internet Domain stuff
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;;
;;; Notes on time.  All internal times-to-live are represented as universal-time in minutes.
;;; This keeps the size down under 32 bits.  
;;; In order not to cons a bignum every time we talk about time, we borrow from the internals
;;; of TIME:GET-UNIVERSAL-TIME here, strategically altered so as not to cons.  
;;;
;;; NOTE!!!  This calls internal bignum arithmetic rtns.  Compatibility alert!
;;;
(defun universal-time-in-minutes ()
  (declare (values minutes-since-january-1-1900-gmt))
  #||
  ;;
  ;; the effect here wants to be same as (// (time:get-universal-time)60.)
  ;;
  (si:%divide-bignum-step time:*last-time-fixnum-universal-time-low* 
			  time:*last-time-fixnum-universal-time-high* 60.)
  ||#
  ;; Don't borrow until we figure out the right thing again.
  (values (truncate (time:get-universal-time) 60.))
  )

;;;
;;; Given an internal expiration-tim-in-minutes, return an external interval-in-seconds
;;;
(defun external-from-internal-time-to-live (internal-ttl)
  (if (null internal-ttl) 0
      (typecase internal-ttl
	(:symbol 99999999.)
	(otherwise (* (max (- internal-ttl (universal-time-in-minutes)) 0) 60.)))))

;;; 
;;; General test for still-alive resource record.
;;;
(defun expired-p (expiration-time)
  (cond ((null expiration-time) t)
	((symbolp expiration-time) ())		; later, case off symbols here
	(t
	 (>= (universal-time-in-minutes) expiration-time))))

;;;

;;; Parsing replies

(defvar *domain-pkt*)
(defvar *domain-start*)
(defvar *domain-index-offset*)
(defvar *domain-index*)
(defvar *domain-end*)

(defmacro with-domain-parsing (accessor &body body)
  `(multiple-value-bind (*domain-pkt* *domain-start* *domain-end*)
       ,accessor
     (let ((*domain-index* *domain-start*))
       ,@body)))

(defun domain-parse-message (stream &aux plist)
  (with-domain-parsing (send stream :read-input-buffer)
    (when *domain-pkt*
      (let ((*domain-index-offset* *domain-start*))
	(setf (zl:get (locf plist) :id) (byte-load-16 *domain-pkt* *domain-index*))
	(incf *domain-index* 2)
	(let ((b2 (aref *domain-pkt* *domain-index*)))
	  (setf (zl:get (locf plist) :query) (not (zl:bit-test b2 #X+80)))
	  (let ((n (ldb (byte 4 3) b2)))
	    (setf (zl:get (locf plist) :opcode) (or (cdr (assq n *domain-opcodes*)) n)))
	  (setf (zl:get (locf plist) :authoritative) (zl:bit-test b2 #X+04))
	  (setf (zl:get (locf plist) :truncated) (zl:bit-test b2 #X+02))
	  (setf (zl:get (locf plist) :recursion-desired) (zl:bit-test b2 #X+01)))
	(incf *domain-index*)
	(let ((b3 (aref *domain-pkt* *domain-index*)))
	  (setf (zl:get (locf plist) :recursion-available) (zl:bit-test b3 #X+80))
	  (let ((n (ldb (byte 4 0) b3)))
	    (setf (zl:get (locf plist) :rcode) (or (cdr (assq n *domain-rcodes*)) n))))
	(incf *domain-index*)
	(let* ((qdcount (byte-load-16 *domain-pkt* *domain-index*))
	       (ancount (byte-load-16 *domain-pkt* (incf *domain-index* 2)))
	       (nscount (byte-load-16 *domain-pkt* (incf *domain-index* 2)))
	       (arcount (byte-load-16 *domain-pkt* (incf *domain-index* 2))))
	  (incf *domain-index* 2)
	  (when *debug-domain-requests*
	    (format zl:trace-output "~&-- Parse-msg: ~D question~:p" qdcount))
	  (setf (zl:get (locf plist) :questions)
		(loop repeat qdcount
		      collect (domain-parse-rr t)))
	  (when *debug-domain-requests*
	    (format zl:trace-output "~&-- Parse-msg: ~D answer~:p" ancount))
	  (setf (zl:get (locf plist) :answers)
		(loop repeat ancount
		      collect (domain-parse-rr nil)))
	  (when *debug-domain-requests*
	    (format zl:trace-output "~&-- Parse-msg: ~D ~:*~[authorities~;authority~:;authorities~]" nscount))
	  (setf (zl:get (locf plist) :authorities)
		(loop repeat nscount
		      collect (domain-parse-rr nil)))
	  (when *debug-domain-requests*
	    (format zl:trace-output "~&-- Parse-msg: ~D additional" arcount))
	  (setf (zl:get (locf plist) :additional)
		(loop repeat arcount
		      collect (domain-parse-rr nil))))
	(unless (= *domain-index* *domain-end*)
	  (when *debug-domain-requests*
	    (format t "~&~% Packet didn't end when it was supposed to: ~D vs ~D." 
		    *domain-index* *domain-end*)
            ;;(dbg)
	    )
	  (when *log-domain-requests*
	    (su:log-event ':normal "Remote server error, packet size mismatch, ~D vs ~D"
			  *domain-end* *domain-index*))
	  (signal 'domain-packet-format-error :error-reason
		  "Packet length error: expected ~D, got ~D"
		  :error-args `(,*domain-end* ,*domain-index*))
	  ))
      (send stream :advance-input-buffer))
    ;;(format zl:trace-output "~&-> ~S " plist)
    plist))

(defun dump-packet (&optional (from-i *domain-index*) (to-j (+ *domain-index* 32)))
  (condition-case (error)
       (if (< from-i (zl:array-dimension-n 1 *domain-pkt*))
	   (loop for i from from-i below to-j by 16 do
	     (zl:format zl:trace-output "~&      ")
	     (loop for ii from i to (+ i 15) do
	       (cl:format zl:trace-output "~2X " (aref *domain-pkt* ii)))
	     (loop for ii from i to (+ i 15) do
	       (zl:format zl:trace-output "~C " (int-char (aref *domain-pkt* ii)))))
	   (format zl:trace-output "~&??? ~D" from-i))
     (sys:subscript-out-of-bounds nil)))

(defun domain-parse-name ()
  ;;(when *debug-domain-requests*
  ;;  (format zl:trace-output "~&-- Domain-parse-name: start ~D idx ~D end ~D" 
  ;;	    *domain-start* *domain-index* *domain-end*))
  ;;(when *debug-domain-requests*
  ;;  (dump-packet))
  (let ((returned-name
	  (loop with index = *domain-index*
		with indirect = nil
		until (= index *domain-end*)
		for len = (aref *domain-pkt* index)
		do (incf index)
		   ;;(when *debug-domain-requests*
		   ;;  (format zl:trace-output "~&  **  len ~D at idx ~D" len index))
		until (zerop len)
		when (< len 64)
		  collect ;(substring (ascii-to-string *domain-pkt*) index (incf index len))
		    (prog1 
		      (loop repeat len 
			    for i from index
			    collecting (int-char (aref *domain-pkt* i)) into chars
			    finally (return (zl:lexpr-funcall #'string-append chars)))
		      (incf index len))
		else when (= (ldb (byte 2 6) len) #b11)
		       ;;
		       ;; we have an 'indirect'  the bottom 6 bits of len and the 
		       ;; next 8 bits are a pointer to where in the packet the rest
		       ;; of the name is
		       ;;
		       do (unless indirect (setf indirect
						 (1+ index)))	;where to pick up again
			  ;; (setf index (+ *domain-start*
			  ;;		 (dpb (ldb (byte 6 0) len)
			  ;;		      (byte 6 8) (aref *domain-pkt* index))))
			  (setf index (+ (* (ldb (byte 6 0) len) 256.) 
					 (aref *domain-pkt* index)
					 *domain-index-offset*))	; start idx, or fudge factor??
		else do (when *log-domain-requests*
			  (su:log-event ':normal "Remote server error: Bad name code ~D" len))
			(signal 'domain-packet-format-error :error-reason "Bad name code ~D"
							    :error-args `(,len))
		finally (setf *domain-index* (or indirect index)))))
    ;;(when *debug-domain-requests*
    ;;  (zl:grind-top-level returned-name nil zl:trace-output))
    returned-name))

;;;
;;; pull a record out of the packet, incrementing index.  Note that ttl is the raw value,
;;; ie seconds here
;;;
(defun domain-parse-rr (query-p &aux name type class ttl rdata)
  (setf name (domain-parse-name))
  (let ((type-code (byte-load-16 *domain-pkt* *domain-index*)))
    (setf type (cadr (assq (byte-load-16 *domain-pkt* *domain-index*) *domain-types*)))
    (incf *domain-index* 2)
    (when (null type)
      (when *log-domain-requests*
	(su:log-event ':normal "Remote server error: Unknown type code ~D" type-code))
      (signal 'domain-packet-format-error :error-reason "Unknown type code ~D"
					  :error-args `(,type-code))))
  (setf class (cadr (assq (byte-load-16 *domain-pkt* *domain-index*) *domain-classes*)))
  (incf *domain-index* 2)
  (unless query-p
    (setf ttl (byte-load-32 *domain-pkt* *domain-index*))
    (incf *domain-index* 4)
    (let* ((rdlength (byte-load-16 *domain-pkt* *domain-index*)))
      (incf *domain-index* 2)
      ;;
      ;; sanity check for data length
      ;;
      (when (> (+ rdlength *domain-index*) *domain-end*)	; rdlen off end of buffer??
	(when *log-domain-requests*
	  (su:log-event ':normal "Remote server error, data length bogus, ~D" rdlength))
	(signal 'domain-packet-format-error :error-reason
		"Packet length error: RDlength ~D"
		:error-args `(,rdlength)))
      (setf rdata (domain-convert-rdata
		    type class *domain-pkt* *domain-index* (incf *domain-index* rdlength)))))
  (make-rr name-list name type type class class ttl ttl rdata rdata))	

;;;
;;; Message packing/unpacking code here.  This is a bit reminiscent of Zwei major modes.
;;; There's a flavor instance for each of (pack-datum, unpack-datum, dump-to-file)
;;; for each defined class.  Send that the type name as a message.
;;;

(defflavor basic-domain-packet-unpacker
	()
	())
(defflavor internet-domain-packet-unpacker ()
	   (basic-domain-packet-unpacker))
(defflavor chaos-domain-packet-unpacker ()
	   (basic-domain-packet-unpacker))
(defflavor dial-domain-packet-unpacker ()
	   (basic-domain-packet-unpacker))

(defflavor basic-domain-packet-packer
	()
	())
(defflavor internet-domain-packet-packer ()
	   (basic-domain-packet-packer))
(defflavor chaos-domain-packet-packer ()
	   (basic-domain-packet-packer))
(defflavor dial-domain-packet-packer ()
	   (basic-domain-packet-packer))

(defflavor basic-domain-packet-dumper
	()
	())
(defflavor internet-domain-packet-dumper ()
	   (basic-domain-packet-dumper))
(defflavor chaos-domain-packet-dumper ()
	   (basic-domain-packet-dumper))
(defflavor dial-domain-packet-dumper ()
	   (basic-domain-packet-dumper))


;;;
;;; The format here is (class unpacker packer dumper)
;;;
(defvar *domain-class-to-instance-alist* ())

(defun rebuild-class-to-instance-alist ()
  (setq *domain-class-to-instance-alist*
	(loop for class in '(:internet :chaos :dial)
	      collect
		(append (list class)
			(loop for base-flavor-name in '("-DOMAIN-PACKET-UNPACKER" 
							"-DOMAIN-PACKET-PACKER"
							"-DOMAIN-PACKET-DUMPER")
			      collect (make-instance
					(intern (string-append (cl:symbol-name class)
							       base-flavor-name)
						(pkg-find-package 'neti))))))))

(defun domain-convert-rdata (type class pkt start end)
  (with-domain-parsing (values pkt start end)
    ;;(dump-packet)
    ;;(format t "~&Converting type ~S start ~D end ~D" type start end)
    (let ((class-instance (or (second (assq class *domain-class-to-instance-alist*))
			      (and (eq class ':*)
				   (second (assq ':internet
						 *domain-class-to-instance-alist*))))))
      (if class-instance 
	(send class-instance type)		;yuck, use a :case generic-function someday
	(let ((val (CL:make-array (- end start) :ELEMENT-type 'CL:(UNSIGNED-BYTE 8))))
	  ;;(format t "~&!! No convert fun for type ~S" type)
	  (copy-array-portion pkt start end val 0 (- end start))
	  val)))))

(defun domain-parse-name-for-rdata (&rest ignore)
  (domain-parse-name))

(defmethod  (:canonical-name basic-domain-packet-unpacker) (&rest ignore)
  (domain-parse-name-for-rdata))
(defmethod  (:mailbox-for-user basic-domain-packet-unpacker) (&rest ignore)
  (domain-parse-name-for-rdata))
(defmethod  (:mail-delivery basic-domain-packet-unpacker) (&rest ignore)
  (domain-parse-name-for-rdata))
(defmethod  (:mail-forwarding basic-domain-packet-unpacker) (&rest ignore)
  (domain-parse-name-for-rdata))
(defmethod  (:mail-group basic-domain-packet-unpacker) (&rest ignore)
  (domain-parse-name-for-rdata))
(defmethod  (:mail-rename basic-domain-packet-unpacker) (&rest ignore)
  (domain-parse-name-for-rdata))
(defmethod  (:name-server basic-domain-packet-unpacker) (&rest ignore)
  (domain-parse-name-for-rdata))
(defmethod  (:pointer basic-domain-packet-unpacker) (&rest ignore)
  (domain-parse-name-for-rdata))

;; This is something of a crock.
(defmethod  (:host-info basic-domain-packet-unpacker) (&rest ignore)
  (domain-parse-name-for-rdata))

(defmethod (:mail-x basic-domain-packet-unpacker) (&rest ignore)
  (let (preference name)
    (setq preference (byte-load-16 *domain-pkt* *domain-index*))
    (incf *domain-index* 2)
    (setq name (domain-parse-name))
    (list preference name)))

(defmethod (:mail-info basic-domain-packet-unpacker) (&rest ignore)
  (list (domain-parse-name) (domain-parse-name)))

(defmethod (:start-of-authority basic-domain-packet-unpacker) (&rest ignore)
  (list (domain-parse-name)
	(domain-parse-name)
	(prog1 (byte-load-32 *domain-pkt* *domain-index*) (incf *domain-index* 4))
	(prog1 (byte-load-32 *domain-pkt* *domain-index*) (incf *domain-index* 4))
	(prog1 (byte-load-32 *domain-pkt* *domain-index*) (incf *domain-index* 4))
	(prog1 (byte-load-32 *domain-pkt* *domain-index*) (incf *domain-index* 4))
	(prog1 (byte-load-32 *domain-pkt* *domain-index*) (incf *domain-index* 4))))


;;;
;;; class specific unpackers
;;;

;;;
;;; address
;;;
(defmethod (:address internet-domain-packet-unpacker) (&rest ignore)
  (unparse-internet-address
    (load-internet-address *domain-pkt* *domain-index*)))

(defmethod (:address chaos-domain-packet-unpacker) (&rest ignore)
  (list (domain-parse-name)
	(format nil "~O"
		(prog1 (byte-load-16 *domain-pkt* *domain-index*) (incf *domain-index* 2)))))

(defmethod (:address dial-domain-packet-unpacker) (&rest ignore)
  (car (domain-parse-name)))

;;;
;;; services
;;;
(defun protocol-name-to-port-number (name)
  (let ((internet-name (or (car (rassq name *tcp-service-to-lispm-protocol-alist*)) name)))
    (car (rassq internet-name *tcp-port-to-service-alist*))))

(defun port-number-to-protocol-name (n)
  (let ((name (cdr (assq n *tcp-port-to-service-alist*))))	
    (or (cdr (assq name *tcp-service-to-lispm-protocol-alist*)) name)))

(defmethod (:well-known-services internet-domain-packet-unpacker) (&rest ignore)
  (let* ((tnum (aref *domain-pkt* (+ *domain-index* 4)))
	 (interface-address (unparse-internet-address
			      (load-internet-address *domain-pkt* *domain-index*)))
	 (ip-protocol-name (cdr (assq tnum *internet-protocol-number-to-name-alist*)))
	 (service-protocol-names
	   (si:eliminate-duplicates
	     (loop for i from (+ *domain-index* 5) below *domain-end*
		   for port from 0 by 8
		   for byte = (aref *domain-pkt* i)
		   unless (zerop byte)
		     append (loop for bit downfrom 7 to 0
				  when (ldb-test (byte 1 bit) byte)
				  for p = 
				      (port-number-to-protocol-name
					(+ port (- 7 bit)))
				  when p
				    collect 
				    ;; special case kludge.  For reasons not worth going into
				    ;; here, :domain protocol is called :domain-simple over
				    ;; udp, but has the same port number.  Check for that
				    ;; here.
				      (if (and (eq ip-protocol-name ':udp)
					       (eq p ':domain))
					  ':domain-simple
					  p))))))
    (list interface-address ip-protocol-name service-protocol-names)))


(defmethod (:well-known-services chaos-domain-packet-unpacker) (&rest ignore)
  (let ((service-entry-count 
	  (prog1 (byte-load-16 *domain-pkt* *domain-index*) (incf *domain-index* 2))))
    (loop repeat service-entry-count 
	  collect
	    (domain-parse-name))))

(defmethod (:well-known-services dial-domain-packet-unpacker) (&rest ignore)
  (let ((service-entry-count 
	  (prog1 (byte-load-16 *domain-pkt* *domain-index*) (incf *domain-index* 2))))
    (loop repeat service-entry-count 
	  collect
	    (domain-parse-name))))

;;;
;;; packing messages
;;;

(defun domain-unconvert-rdata (rr)
  (incf *domain-index* 2)
  (let ((old-domain-index *domain-index*)
	(packer-instance (or (third (assq (rr-class rr) *domain-class-to-instance-alist*))
			     (and (eq (rr-class rr) ':*)
				  (third (assq ':internet
					       *domain-class-to-instance-alist*))))))
    (if packer-instance
	(send packer-instance (rr-type rr) rr)
	(let ((rdlength (if (arrayp (rr-rdata rr))	; array-active-length  ?
			    (fill-pointer (rr-rdata rr))
			    0)))
	  (writing-to-domain (rdlength)
	    (copy-array-portion (rr-rdata rr) 0 rdlength
				*domain-pkt* *domain-index* (+ *domain-index* rdlength)))))
    (byte-store-16 (- *domain-index* old-domain-index) *domain-pkt* (- old-domain-index 2))))

(defun domain-send-name-for-rdata (rr)
  (domain-send-name (rr-rdata rr)))

(defmethod (:canonical-name basic-domain-packet-packer) (&rest args)
  (lexpr-funcall #'domain-send-name-for-rdata args))
(defmethod (:mailbox-for-user basic-domain-packet-packer) (&rest args)
  (lexpr-funcall #'domain-send-name-for-rdata args))
(defmethod (:mail-delivery basic-domain-packet-packer) (&rest args)
  (lexpr-funcall #'domain-send-name-for-rdata args))
(defmethod (:mail-forwarding basic-domain-packet-packer) (&rest args)
  (lexpr-funcall #'domain-send-name-for-rdata args))
(defmethod (:mail-group basic-domain-packet-packer) (&rest args)
  (lexpr-funcall #'domain-send-name-for-rdata args))
(defmethod (:mail-rename basic-domain-packet-packer) (&rest args)
  (lexpr-funcall #'domain-send-name-for-rdata args))
(defmethod (:name-server basic-domain-packet-packer) (&rest args)
  (lexpr-funcall #'domain-send-name-for-rdata args))
(defmethod (:pointer basic-domain-packet-packer) (&rest args)
  (lexpr-funcall #'domain-send-name-for-rdata args))

(defmethod (:host-info basic-domain-packet-packer) (rr)
  (flet ((one-word (word)
	   (let ((len (string-length word)))
	     (writing-to-domain (1)
	       (setf (aref *domain-pkt* *domain-index*) len))
	     (writing-to-domain (len)
;	       (copy-array-portion word 0 len
;				   *domain-pkt* *domain-index* (+ *domain-index* len))
	       (loop for i from 0 below len 
		     for j from *domain-index*
		     do
		 (setf (aref *domain-pkt* j) (char-int (aref word i))))))))
    (one-word (first (rr-rdata rr)))
    (one-word (second (rr-rdata rr)))))

(defmethod (:mail-info basic-domain-packet-packer) (rr)
  (domain-send-name (first (rr-rdata rr)))
  (domain-send-name (second (rr-rdata rr))))

(defmethod (:mail-x basic-domain-packet-packer) (rr)
  (byte-store-16 (car (rr-rdata rr)) *domain-pkt* *domain-index*)
  (incf *domain-index* 2)
  (domain-send-name (cadr (rr-rdata rr))))

(defmethod (:start-of-authority basic-domain-packet-packer) (rr)
  (let ((rdata (rr-rdata rr)))
    (domain-send-name (first rdata))
    (domain-send-name (second rdata))
    (writing-to-domain (4)
      (byte-store-32 (third rdata) *domain-pkt* *domain-index*))
    (writing-to-domain (4)
      (byte-store-32 (fourth rdata) *domain-pkt* *domain-index*))
    (writing-to-domain (4)
      (byte-store-32 (fifth rdata) *domain-pkt* *domain-index*))
    (writing-to-domain (4)
      (byte-store-32 (sixth rdata) *domain-pkt* *domain-index*))
    (writing-to-domain (4)
      (byte-store-32 (seventh rdata) *domain-pkt* *domain-index*))))

;;;
;;; class specific packers
;;;

;;;
;;; address
(defmethod (:address internet-domain-packet-packer) (rr)
  (writing-to-domain (4)
    (store-internet-address (parse-internet-address (rr-rdata rr))
			    *domain-pkt* *domain-index*)))

(defmethod (:address chaos-domain-packet-packer) (rr)
  (domain-send-name (first (rr-rdata rr)))
  (writing-to-domain (2)
    (byte-store-16 (cl:parse-integer (second (rr-rdata rr)) ':radix 8.)
		   *domain-pkt* *domain-index*)))

(defmethod (:address dial-domain-packet-packer) (rr)
  (domain-send-name (list (rr-rdata rr))))

;;;
;;; services
;;;

(defmethod (:well-known-services internet-domain-packet-packer) (rr)
  (let ((rdata (rr-rdata rr)))
    (select (rr-class rr)
      (:internet
       (writing-to-domain (4)
	 (store-internet-address (parse-internet-address (first rdata))
				 *domain-pkt* *domain-index*))
       (writing-to-domain (1)
	 (setf (aref *domain-pkt* *domain-index*) 
	       (or (car (rassq (second rdata)  *internet-protocol-number-to-name-alist*))
		   0)))
       ;;
       ;; generate the big bit array
       ;;
       (let* ((max-port-number (loop for protocol in (third (rr-rdata rr))
				     as port-number = (protocol-name-to-port-number protocol)
					 when port-number maximize port-number))
	      (byte-count (and max-port-number (ceiling max-port-number 8.))))
	 (writing-to-domain (byte-count)
	   (loop for byte-idx from 0 below byte-count do
	     (setf (aref *domain-pkt* (+ *domain-index* byte-idx)) 0.))
	   (loop for protocol in (third (rr-rdata rr))
		 as port-number = (protocol-name-to-port-number protocol)
		 when port-number 
		   do
		     (multiple-value-bind (byte bit) (floor port-number 8)
		       (setf (aref *domain-pkt* (+ *domain-index* byte))
			     (dpb 1 (byte 1 (- 7 bit)) (aref *domain-pkt*
							     (+ *domain-index* byte))))))
	   ;;(dbg)
	   ))
       ))))

(defmethod (:well-known-services chaos-domain-packet-packer) (rr)
  (let ((service-entries (rr-rdata rr)))
    (byte-store-16 (length service-entries) *domain-pkt* *domain-index*)
    (incf *domain-index* 2)
    (loop for service-entry in service-entries do
      (domain-send-name (mapcar #'string service-entry)))))

(defmethod (:well-known-services dial-domain-packet-packer) (rr)
  (let ((service-entries (rr-rdata rr)))
    (byte-store-16 (length service-entries) *domain-pkt* *domain-index*)
    (incf *domain-index* 2)
    (loop for service-entry in service-entries do
      (domain-send-name (loop for symbol in service-entry	; crude, but effective
				  collect (string symbol))))))

;;;****************************************************************
;;; Unparsing

(defflavor domain-packet-full () (error))
(defmethod (:report domain-packet-full) (stream)
  stream
  ())

(compile-flavor-methods domain-packet-full)  

(defvar *domain-name-cache*)

(defmethod (:transaction domain-access-path) (plist &optional (expect-multiple-responses nil))
  (domain-get-stream self)
  (cond ((domain-send-message
	   stream plist 8
	   (host-short-name (service-access-path-host service-access-path)))
	 (let ((answers (loop with first-answer = (domain-parse-message stream)
			      while (or (send stream ':listen)
					(and expect-multiple-responses 
					     (send stream ':reliable-p)
					     (process-wait-with-timeout "Domain Response" 600.
					       #'send stream ':listen)))
			      as one-answer = (domain-parse-message stream)
			      while one-answer
			      collect one-answer into other-answers
			      finally (return (cons first-answer other-answers)))))
	   (when *debug-domain-requests*
	     (zl:grind-top-level answers nil zl:trace-output)
	     )
	   answers))
	(t
	 (send-if-handles stream :report-connection-error nil)
	 nil)))


(defun domain-send-message (stream plist retransmit host)
  (when *debug-domain-requests*
    (format zl:trace-output "~&<- ~S" plist))
  (loop with message-acked = ()
	doing
    (multiple-value-bind (*domain-pkt* *domain-start* *domain-end*)
  	(send stream :get-output-buffer)
      (let ((*domain-name-cache* ())
	    (*domain-index* (+ *domain-start* 12))
	    (questions 0) (answers 0) (authorities 0) (additionals 0)
	    (truncated nil))
	(condition-case ()
	    (progn (loop for question in (zl:get (locf plist) :questions)
			 do (domain-send-rr question t)
			    (incf questions))
		   (loop for answer in (zl:get (locf plist) :answers)
			 do (domain-send-rr answer nil)
			    (incf answers))
		   (loop for authority in (zl:get (locf plist) :authorities)
			 do (domain-send-rr authority nil)
			    (incf authorities))
		   (loop for additional in (zl:get (locf plist) :additional)
			 do (domain-send-rr additional nil)
			    (incf additionals)))
	  (domain-packet-full (setf truncated t)))
	(let ((end *domain-index*))
	  (setf *domain-index* *domain-start*)
	  (byte-store-16 (or (zl:get (locf plist) :id) 0) *domain-pkt* *domain-index*)
	  (incf *domain-index* 2)
	  (setf (aref *domain-pkt* *domain-index*)
		(dpb (car (rassq (zl:get (locf plist) :opcode) *domain-opcodes*))
		     (byte 3 4)
		     (+ (if (zl:get (locf plist) :query) 0 #X+80)
			(if (zl:get (locf plist) :authoritative) #X+04 0)
			(if truncated #X+02 0)
			(if (or (zl:get (locf plist) :recursion-desired)
				*domain-default-recursion-request*)
			    #X+01 0))))
	  (incf *domain-index*)
	  (setf (aref *domain-pkt* *domain-index*)
		(+ (if (zl:get (locf plist) :recursion-available) #X+80 0)
		   (or (car (rassq (zl:get (locf plist) :rcode) *domain-rcodes*)) 0)))
	  (incf *domain-index*)
	  (byte-store-16 questions *domain-pkt* *domain-index*)
	  (incf *domain-index* 2)
	  (byte-store-16 answers *domain-pkt* *domain-index*)
	  (incf *domain-index* 2)
	  (byte-store-16 authorities *domain-pkt* *domain-index*)
	  (incf *domain-index* 2)
	  (byte-store-16 additionals *domain-pkt* *domain-index*)
	  (incf *domain-index* 2)
	  (send stream :advance-output-buffer end)
	  (send stream :force-output ;*domain-pkt* end
		)
	  )))
	until (cond ((not retransmit))
		    ((send stream :reliable-p)
		     (setq message-acked t) 
		     )
		    ((< (setq retransmit (- retransmit 1)) 0))
		    (t
		     (setq message-acked
			   (process-wait-with-timeout 
			       (if host (format () "Domain Response ~A" host)
				   "Domain Response")
			       (* 2 60)	; Retransmit after 2 sec
			     #'send stream :listen))))
	finally (return message-acked)))

(defmacro writing-to-domain ((length) &body body)
  `(let ((.new-index. (+ *domain-index* ,length)))
     (when (> .new-index. 512.)
       (signal 'domain-packet-full))
     (progn ,@body)
     (setf *domain-index* .new-index.)))

(defun domain-send-rr (rr query-p)
  (let ((rr-start *domain-index*))
    (condition-case ()
	 (progn (domain-send-name (rr-name-list rr))
		(writing-to-domain (2)
		  (byte-store-16 (car (rass #'(lambda (x y) (eq x (car y)))
					    (rr-type rr) *domain-types*))
				 *domain-pkt* *domain-index*))
		(writing-to-domain (2)
		  (byte-store-16 (car (rass #'(lambda (x y) (eq x (car y)))
					    (rr-class rr) *domain-classes*))
				 *domain-pkt* *domain-index*))
		(unless query-p
		  (writing-to-domain (4)
		    (byte-store-32 (if (fixnump (rr-ttl rr))
				       (rr-ttl rr)
				       3600.)
				   *domain-pkt* *domain-index*))
		  (domain-unconvert-rdata rr)))
       (domain-packet-full
	 (setf *domain-index* rr-start)
	 (signal 'domain-packet-full)))))

(defun domain-send-name (name)
  (loop for tail on name
	for cache = (assoc tail *domain-name-cache*)
	do (cond (cache
		  (writing-to-domain (2)
		    (setf (aref *domain-pkt* *domain-index*)
			  (dpb #b11 (byte 2 6) (ash (cdr cache) -8)))
		    (setf (aref *domain-pkt* (1+ *domain-index*))
			  (ldb (byte 8 0) (cdr cache))))
		  (return ()))
		 (t (push (cons tail (- *domain-index* *domain-start*))
			  *domain-name-cache*)
		    (let ((len (string-length (first tail))))
		      (writing-to-domain (1)
			(setf (aref *domain-pkt* *domain-index*) len))
		      (writing-to-domain (len)
			(copy-array-portion (string-to-ascii (first tail)) 0 len
					    *domain-pkt* *domain-index* (+ *domain-index* len))))))
	finally (writing-to-domain (1)
		  (setf (aref *domain-pkt* *domain-index*) 0))))





;;; Namespace tools

(defflavor domain-file
	((origin nil)
	 (last-loc nil)
	 stream)
	()
  (:initable-instance-variables origin stream))

(defmethod (:init domain-file :after) (&rest ignore)
  (let ((real-origin origin))
    (letf ((origin nil))
      (send stream :string-out ";; Domain file dump of ")
      (send self :format-name real-origin)
      (send stream :fresh-line))))

(defmethod (:close domain-file) (&optional abortp)
  (send stream :close abortp))

(defmethod (:force-output domain-file) ()
  (send stream :force-output))

(defmethod (domain-file-tag domain-file) (name)
  (cond ((equal name last-loc) "")
	((equal name origin) "@")
	((null name) "..")
	(t (loop with partial = nil
		 for common on name
		 when (equal common origin)
		   return partial
		 do (if partial
			(array-push-extend partial #/.)
			;;(vector-push-extend partial #/.)
			(setf partial (zl:make-array 64 :type 'zl:art-string :fill-pointer 0)))
		    (setf partial (string-nconc partial (first name)))))))

(defmethod (:dump-rr domain-file) (rr)
  (format stream "~A ~@[~D ~]~A ~A "
	  (domain-file-tag self (rr-name-list rr)) nil 
	  (third (rass #'(lambda (x y) (eq x (car y))) (rr-class rr) *domain-classes*))
	  (third (rass #'(lambda (x y) (eq x (car y))) (rr-type rr) *domain-types*)))
  (if (operation-handled-p self (rr-type rr))
      (send self (rr-type rr) (rr-rdata rr))
      (princ (rr-rdata rr) stream))
  (send stream :tyo #\cr)
  (setf last-loc (rr-name-list rr)))

(defmethod (:format-name domain-file) (name-list)
  (cond ((null name-list) (send stream :string-out ".."))
	((equal name-list origin)
	 (send stream :tyo #/@))
	(t (send stream :string-out (first name-list))
	   (loop for list on (cdr name-list)	; rest1
		 when (equal list origin)
		   return nil
		 do (send stream :tyo #/.)
		    (send stream :string-out (first list))
		 finally (send stream :tyo #/.)))))

(defmethod (:canonical-name domain-file) (rdata) (send self :format-name rdata))
(defmethod (:mailbox-for-user domain-file) (rdata) (send self :format-name rdata))
(defmethod (:mail-delivery domain-file) (rdata) (send self :format-name rdata))
(defmethod (:mail-forwarding domain-file) (rdata) (send self :format-name rdata))
(defmethod (:mail-rename domain-file) (rdata) (send self :format-name rdata))
(defmethod (:name-server domain-file) (rdata) (send self :format-name rdata))
(defmethod (:pointer domain-file) (rdata) (send self :format-name rdata))

(defmethod (:host-info domain-file) (rdata)
  (format stream "~{~A ~A~}" rdata))

(defmethod (:mail-info domain-file) (rdata)
  (send self :format-name (first rdata))
  (send stream :tyo #\space)
  (send self :format-name (second rdata)))

(defmethod (:well-known-services domain-file) (rdata)
  (format stream "~{~A ~A~{ ~A~}~}" rdata))

(defmethod (:start-of-authority domain-file) (rdata)
  (send self :format-name (first rdata))
  (send stream :tyo #\space)
  (send self :format-name (second rdata))
  (format stream " (~{~% ~D~} )" (cddr rdata)))	;rest2

;;;






(defun protocol-to-nic (protocol)
  (loop for (nil nil svcs) in *nic-services*
	thereis (loop for (name pname) in svcs
		      when (eq pname protocol)
		      return name)))

(defun nic-to-protocol (medium protocol)
  (let ((m-entry (zl:ass #'string-equal medium *nic-services*)))
    (when m-entry
      (let ((p-entry (zl:ass #'string-equal protocol (third m-entry))))
	(when p-entry
	  (values (second m-entry) (third p-entry)))))))

(defun system-type-to-nic (system-type)
  (loop for (name sname) in *nic-system-types*
	when (eq system-type sname)
	return name
	finally (return (string system-type))))

(defun nic-to-system-type (nic)
  (let ((e (zl:ass #'string-equal nic *nic-system-types*)))
    (if e (second e) (neti:intern-global-name nic))))

(defun machine-type-to-nic (host-or-machine-type)
  (cl:typecase host-or-machine-type
    (fs:lispm-host
      (format nil "SYMBOLICS-~A" (send host-or-machine-type :machine-type)))
    (net:host
      (machine-type-to-nic (send host-or-machine-type :machine-type)))
    (t
      (or (car (cl:rassoc host-or-machine-type *nic-machine-types* :key #'car))
	  (string host-or-machine-type)))))

(defun nic-to-machine-type (nic)
  (let ((e (cl:assoc nic *nic-machine-types* :test #'cl:string-equal))
	(l #.(string-length "SYMBOLICS-")))
    (cond (e (second e))
	  ((and (cl:string-equal nic "SYMBOLICS-" :end1 l)
		(> (string-length nic) l))
	   (neti:intern-global-name (substring nic l)))
	  (t (neti:intern-global-name nic)))))



;;; Domains themselves

(defvar *domain-hash-table* (cl:make-hash-table :test #'equal))


(defflavor basic-domain 
	()
	()
  )

(defmethod (:print-self basic-domain) (stream ignore slashify)
  (if slashify
      (si:printing-random-object (self stream :typep)
	(princ self stream))
      (princ (make-dotname (name-list self)) stream)
      ))

(defmethod (:init basic-domain :after) (&rest ignore)
  (puthash (name-list self) self *domain-hash-table*))

(defmethod (local-host-is-primary-server basic-domain :default) ()
  t)

(defmethod (set-local-host-is-primary-server basic-domain :default) (new-value)
  (ignore new-value))

(defmethod (authoritative basic-domain :default) ()
  t)

(defmethod (set-authoritative basic-domain :default) (new-value)
  (ignore new-value))


(defmethod (:iquery basic-domain :default) (rr)
  rr
  nil)

;;;

(defflavor named-domain
	((name-list ()))
	(basic-domain)
  :gettable-instance-variables
  :settable-instance-variables
  :initable-instance-variables)

(defmethod (name-list named-domain) ()
  name-list)

;;;

;;;
;;; this flavor of domain gets created when some server tells :name-error
;;;
(defflavor nonexistent-domain
	(time-in-minutes-to-forget-self		; when to forget the domain, and try again 
						;  name doesn't exist, in minutes
	 (error-server ())			; the server that said we don't exist
	 (error-answer ()))			; the answer that caused the error
	(named-domain)
  :initable-instance-variables
  :gettable-instance-variables)

(defmethod (:init nonexistent-domain :after) (&rest ignore)
  (setf time-in-minutes-to-forget-self 
	(+ (universal-time-in-minutes) 360.)))	; + 6 hr.

(defmethod (local-host-is-primary-server nonexistent-domain) ()
  nil)

(defmethod (domain-query-internal nonexistent-domain) (&rest ignore)
  (signal 'domain-resolver-error :error-server error-server :error-rr error-answer)
  (values nil nil nil))

(defmethod (domain-rrs nonexistent-domain) (&rest ignore)
  (values nil nil nil))

;;;

;;; We create one of these when queried for any fully qualified INTERNET address corresponding
;;; to a host in one of our namespaces.  The domain file should contain appropriate SOA and
;;; NS records for our assigned network number as we don't attempt to construct those on the
;;; fly.  With this mechanism in place, we support PTR queries ...

(defflavor address-domain
	(host)
	(basic-domain)
  (:initable-instance-variables host))

(defmethod (name-list address-domain) ()
  (dolist (address-pair (send host :network-addresses))
    (when (eq (send (first address-pair) :type) :internet)
      (macrolet ((make (n)
		   `(format nil "~D" ,n)))
	(multiple-value-bind (a b c d)
	    (explode-internet-address (second address-pair))
	  (return-from name-list `(,(make d) ,(make c) ,(make b) ,(make a)
				   "IN-ADDR" "ARPA")))))))

(defmethod (domain-rrs address-domain) (&optional (type ':*) (class ':*) 
						  &rest ignore)
  (declare (values (answers return-code authoritative-p additional-records)))
  (when (and (domain-type-match-p type :pointer)
	     (domain-type-match-p class :internet))
    (values
      (list (make-rr name-list (name-list self)
		     type :pointer
		     class :internet
		     rdata (domain-cvt-primary-name host
						    (send (send host :primary-name) :namespace)
						    )))
      nil
      (multiple-value-bind (then now)
	  (send host :check-validity)
	(or then now))
      nil)))

(defmethod (domain-query-internal address-domain) (&optional (rr-type ':*)
							     (rr-class ':*)
							     (ask-server-if-not-in-cache t))
  (ignore ask-server-if-not-in-cache)
  (domain-rrs self rr-type rr-class))

;;;

;;; There is one of these for each namespace object that we ever went looking for
;;; by way of the domain system.   When we get domain information we can find our way
;;; back to the right object by looking up the object name (as D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")both0 a host and a user.)

(defflavor namespace-domain
	((namespace ())				; namespace obj, if corresponds to local
	 (object-name ""))			; the name of the object in the namespace
	(basic-domain)
  (:initable-instance-variables namespace object-name))

(defmethod (host-object-in-domain-named namespace-domain) (namestring)
  (find-object-named-in-namespace ':host (parse-name namestring nil namespace) namespace nil))

(defmethod (name-list namespace-domain) ()
  (cons object-name (domain-cvt-namespace-name namespace)))

(defun domain-rrs-for-object (object namespace class type)
  (let ((*domain-rrs* nil) (*domain-additional-rrs* nil) (*domain-rrs-examined* nil))
    (domain-rrs-for-object-internal object namespace class type)
    (values *domain-rrs* *domain-additional-rrs* *domain-rrs-examined*)))

(defun domain-find-additional-rrs (name-list class type)
  (unless *domain-suppress-additional-records*
    (let ((*domain-suppress-additional-records* t))
      (let ((domain (find-namespace-domain name-list :create)))
	(when domain
	  (loop for rr in (domain-rrs domain type class)
		when (and (eq type (rr-type rr))
			  (not (member rr *domain-additional-rrs*)))
		  do (push rr *domain-additional-rrs*)))))))

(defun domain-rrs-for-object-internal (object namespace class type)
  (setf *domain-rrs-examined* t)
  (let ((primary-name (domain-cvt-primary-name object namespace)))
    (macrolet ((maybe-add-rr (this-class this-type rdata &optional aname atype)
		 `(when (and (or (eq ,this-class :*)
				 (eq class :*)
				 (eq class ,this-class))
			     (domain-type-match-p type ,this-type))
		    (let ((new-rr (make-rr name-list primary-name 
					   class ,(if (eq this-class ':*)
						      'class
						      this-class)
					   type ,(if (eq this-type ':*)
						     'type
						     this-type)
					   rdata ,rdata)))
		      (push new-rr *domain-rrs*)
		      (setf *domain-additional-rrs*
			    (delete new-rr *domain-additional-rrs*))
		      ,@(when atype
			  `((domain-find-additional-rrs ,aname class ,atype)))))))
      (select (send object :class)
	(:host
	 (maybe-add-rr :* :host-info
		       (list (machine-type-to-nic object)
			     (system-type-to-nic (send object :system-type))))
	 (when (domain-type-match-p type :mail-x)	;Avoid infinite recursion.
	   (loop for (mailer preference) in (domain-find-appropriate-mxs class object)
		 do (let ((mname (domain-cvt-primary-name mailer namespace)))
		      (maybe-add-rr :* :mail-x (list preference mname) mname :address))))
	 (loop for (network address) in (send object :address)
	       as network-type = (send network ':type)
	       do (select network-type
		    (:internet
		     (maybe-add-rr :internet :address address)
		     (loop for medium in '(:tcp :udp)
			   for protocols = (si:eliminate-duplicates
					     (loop for (nil mname protocol)
						       in (send object :service)
						   when (and (eq mname medium)
							     protocol)
						     collect protocol))
			   when protocols
			     do (maybe-add-rr :internet :well-known-services
					      (list address medium protocols))))
		    (:chaos
		     ;;
		     ;; and now, in the spirit of gross special cases, we have a kludge
		     ;; intended to prevent us confusing the rest of the world.  We don't
		     ;; want to advertise chaos addresses without sending the name of
		     ;; the network along with it, so we only return chaos data when
		     ;; the network that this host has an address on has a global name.
		     ;; This will want to be re-thought when we do this right.
		     ;; So what else is new?
		     ;;
		     (when (send network ':global-network-name)
		       (maybe-add-rr network-type ':address 
				     (list (parse-domain-style-name 
					     (string (send network ':global-network-name)))
					   address))
		       (maybe-add-rr
			 network-type ':well-known-services
			 (loop for (service medium protocol) in
				   (send object ':service)
			       when (eq medium network-type)
				 collect (list (string service) (string protocol))))))
		    (:dial
		     (maybe-add-rr network-type ':address address)
		     (maybe-add-rr
		       network-type ':well-known-services
		       (loop for (service medium protocol) in
				 (send object ':service)
			     when (eq medium network-type)
			       collect (list (string service) (string protocol)))))
		    )))
	
	(:user
	 (let ((ma (send object :mail-address)))
	   (when (string-equal (first ma)
			       (send object :primary-name-string namespace))
	     (let ((mname (domain-cvt-primary-name (second ma) namespace)))
	       (maybe-add-rr :* :mailbox-for-user mname mname :address))))))))
  (setq *domain-rrs* (nreverse *domain-rrs*)
	*domain-additional-rrs* (nreverse *domain-additional-rrs*)))

(defmethod (domain-rrs namespace-domain) (&optional (type ':*) (class ':*) 
						    &rest ignore)
  (declare (values (answers return-code authoritative-p additional-records)))
  (keeping-namespace-server
    (loop with ns-name = (neti:parse-name object-name nil namespace)
	  with authoritative-p = t
	  with *domain-rrs* = nil
	  with *domain-additional-rrs* = nil
	  with *domain-rrs-examined* = nil
	  with name-exists = nil
	  for ns-class in '(:host :user)
	  as object = (condition-case ()	; needed, as f-o-n-i-n ignores ERROR-P
			   (neti:find-object-named-in-namespace ns-class
								ns-name namespace nil)
			 (error nil))
	  when object
	    do (setq name-exists t)
	       (setq authoritative-p 
		     (and authoritative-p (multiple-value-bind (then now)
					      (send object ':check-validity)
					    (or then now))))	; we'll accept either
	       (domain-rrs-for-object-internal object namespace class type)
	       (when (and (not (eq ns-name (send object :primary-name namespace)))
			  (or *domain-rrs-examined*
			      (eq type :canonical-name)))
		 (push (make-rr name-list (name-list self)
				type ':canonical-name
				class class
				rdata (domain-cvt-primary-name object namespace))
		       *domain-rrs*))
	  finally (return (values *domain-rrs*	; the data
				  (when (and (null *domain-rrs*)	
					     (null name-exists)
					     authoritative-p)
				    :name-error)
				  authoritative-p	; authoritative flag for caller
				  *domain-additional-rrs*)))))


(defmethod (domain-query-internal namespace-domain) (&optional 
						      (rr-type ':*)
						      (rr-class ':*)
						      (ask-server-if-not-in-cache t))
  (ignore ask-server-if-not-in-cache)			; not used currently
  (domain-rrs self rr-type rr-class))

(defmethod (:host-object namespace-domain) ()
  (find-object-named-in-namespace ':host (parse-name object-name nil namespace)
				  namespace nil))

(defmethod (:set-host-object namespace-domain) (&rest ignore)
  )

(defun domain-cvt-namespace-name (namespace)
  (if (typep namespace 'neti:namespace)
      (let ((dname (or (send namespace :internet-domain-name)
		       (string (send namespace :name)))))
	(loop for done = 0 then (1+ i)
	      for i = (string-search-char #/. dname done)
	      collect (substring dname done i)
	      while i))
      namespace))

(defun domain-cvt-primary-name (object namespace)
  (let ((name (send object :primary-name namespace)))
    (list* (send name :string) (domain-cvt-namespace-name (send name :namespace)))))

(defvar *domain-suppress-additional-records* nil)

(defvar *domain-rrs-examined*)
(defvar *domain-rrs*)
(defvar *domain-additional-rrs*)

(defun domain-find-appropriate-mxs (class object)
  (let ((site (send object :site)))
    (when site
      (let* ((mailers (or (find-mailers-for-site class site)
			  (let ((other-sites (get-other-sites-in-mail-area site)))
			    (when other-sites
			      (loop for other-site in other-sites
				    append (find-mailers-for-site class other-site))))))
	     (namespace (send (send object :primary-name) :namespace))
	     (site-domain-name
	       (parse-domain-style-name (send namespace :internet-domain-name)))
	     (site-mxs
	       (loop for answer in (domain-query site-domain-name :mail-x class)
		     as host = (condition-case (error)
				    (parse-host (format nil "~{~A~@{.~A~}~}"
							(second (rr-rdata answer))))
				  (error nil))
		     when host
		       collect (list host (first (rr-rdata answer)))))
	     (highest-site-preference (cl:reduce #'max
						 (cl:map 'list #'second site-mxs)
						 :initial-value 0)))
	(flet ((select-preference (mailer)
		 (cond ((eq mailer object) 0)
		       ((second (cl:assoc mailer site-mxs)))
		       (t (+ highest-site-preference 10)))))
	  (cl:sort (cl:delete-duplicates (nconc
					   (loop for mailer in mailers
						 collect (list mailer
							       (select-preference mailer)))
					   site-mxs)
					 :from-end t
					 :key #'first)
		   #'< :key #'second))))))

(defun find-mailers-for-site (class site)
  (searching-one-site (site)
    (cl:apply #'find-objects-from-property-list :host
      :site site
      :service '((:store-and-forward-mail :* :*))
      (when (neq class :*)
	(let ((network (local-network-of-type class nil)))
	  (when network
	    `(:address ((,network :*)))))))))


;;;

(defun make-dotname (dname &optional (sep #/.))
  (loop with dotname = (first dname)
	for elem in (cdr dname)			; rest1
	do (setf dotname (string-append dotname sep elem))
	finally (return dotname)))



;;;
;;; caching domains
;;; Currently, this is a base flavor of dial-domains and native-domains.
;;;
;;; The resource-record-cache is an equal-hash-table, indexed by a list of (type class).
;;; contents is a list of (time-to-live data)
;;;
(defflavor domain-with-cache
	((resource-record-cache (cl:make-hash-table :test #'equal :size 6))
	 (host-object ()))			; if any
	(named-domain)
  :initable-instance-variables  
  (:gettable-instance-variables host-object)
  (:settable-instance-variables host-object))

;;;
;;; return the host object that goes with this name, if we have one
;;;
(defmethod (host-object-in-domain-named domain-with-cache) (ignore)
  host-object)

;;;

(defflavor dialnet-domain
	()
	(domain-with-cache)
  )

(defmethod (:init dialnet-domain) (&rest ignore)
  ;;(setf mail-host (or (mailer:arpanet-mail-gateway-host mail-host) mail-host))
  ;;(setf mail-host-name (domain-cvt-primary-name mail-host net:*namespace*))
  )

(defmethod (domain-query-internal dialnet-domain) (type &optional (class ':*) 
							(ask-server-if-not-in-cache t))
  ;;
  ;; We want to suply our own timeouts for returned info here, as the cache will have
  ;; large values.
  ;;
  (multiple-value-bind (answers return-code)
      (domain-rrs self type class ':up-to-date ask-server-if-not-in-cache)
    (loop for answer in answers 
	  do (setf (rr-ttl answer) 3600)	; one hour
	     )
    (values answers return-code t)))


(defmethod (:authorities dialnet-domain) (class)
  class
  nil)

;;;

(defflavor native-domain 
	((authoritative-p ())			; if info here is authoritative
	 (local-host-is-primary-server-p nil))	; default nil
	(domain-with-cache)
  :settable-instance-variables)

(defmethod (make-instance native-domain) (&key &allow-other-keys)
  (loop for parent-name on (rest1 name-list)
	for parent = (find-native-domain (list* "*" parent-name) nil)
	when parent
	  do (maphash #'(lambda (key value)
			  (setf (gethash key resource-record-cache)
				(cl:remove-duplicates
				  (append (gethash key resource-record-cache)
					  value)
				  :test #'equal :key #'second)))
		      (symeval-in-instance parent 'resource-record-cache))))

(defmethod (authoritative native-domain) ()
  authoritative-p)

(defmethod (local-host-is-primary-server native-domain) ()
  (and authoritative-p local-host-is-primary-server-p))

(defmethod (set-local-host-is-primary-server native-domain) (new-value)
  (setf local-host-is-primary-server-p new-value))

(defmethod (set-authoritative native-domain) (new-value)
  (setf authoritative-p new-value))



(defvar *remote-domain-initial-rrs*  
	(loop for (num prop) in *domain-types* 
	      when (< num 200.)			; hack to exclude query-only types
		collect `(,prop . :unknown)))

(defun find-native-domain (name-list &optional (if-not-found ()))
  (let ((d (send *domain-hash-table* :get-hash name-list)))
    (cond ((and d (memq (typep d) '(native-domain dialnet-domain))) d)
	  (t (select if-not-found
	       (:create
		(setq d (make-instance 'native-domain :name-list name-list))
		(send *domain-hash-table* :put-hash name-list d))
	       (:nearest
		(loop for parent-name on name-list
		      thereis (send *domain-hash-table* 
				    :get-hash parent-name))))))))

(defun find-namespace-domain (name-list &optional (if-not-found ()))
  (let ((object-name (first name-list))
	(namespace-name (cdr name-list)))
    ;;
    ;; More kludgery.  If the Internet namespace is around, we don't want to find it here
    ;; so we must check for tail ("arpa"), and filter it out.  Worse yet, if the
    ;; DIAL namespace is around, we don't want to find that one either, so check for
    ;; '("dialnet" "symbolics" "com") and filter that one out.
    ;;
    (when (and namespace-name 
	       (null (and (= (length namespace-name) 1)
			  (equal namespace-name '("ARPA"))))
	       (null (and ( (length namespace-name) 3)
			  (equal (last namespace-name 3) '("Dialnet" "Symbolics" "COM")))))
      (let ((domain-object (send *domain-hash-table* :get-hash name-list)))
	(if (and domain-object (typep domain-object 'namespace-domain))
	    domain-object
	    (selectq if-not-found
	      (:create
	       (let ((ns (find-object-from-property-list :namespace
			   :internet-domain-name (make-dotname namespace-name))))
		 (when ns 
		   (let ((new-domain-object (make-instance 'namespace-domain
							   ':namespace ns
							   ':object-name object-name)))
		     new-domain-object))))))))))

(defun find-nonexistent-domain (name-list &rest ignore)
  (let ((d (gethash name-list *domain-hash-table*)))
    (and d
	 (typep d 'nonexistent-domain)
	 (< (universal-time-in-minutes) (send d ':time-in-minutes-to-forget-self))
	 d)))

(defun find-dialnet-domain (name-list &rest ignore)
  (when (and (>= (length name-list) 3)
	     (loop for name in (reverse name-list)
		   for test-name in '("com" "symbolics" "dialnet")
		   when (null (string-equal name test-name))
		     do (return nil)
		   finally (return t)))
    (gethash name-list *domain-hash-table*)))

(defun find-address-domain (name-list &optional (if-not-found ()))
  (when (and (< 2 (length name-list) 7)
	     (equal (last name-list 2) '("IN-ADDR" "ARPA")))
    (let ((domain-object (gethash name-list *domain-hash-table*)))
      (if (and domain-object (typep domain-object 'address-domain))
	  domain-object
	  (selectq if-not-found
	    (:create
	     (when (= (length name-list) 6)
	       (without-internet-namespace
		 (let* ((internet (local-network-of-type :internet nil))
			(host
			  (and internet
			       (find-object-from-property-list :host
				 :address `((,internet
					     ,(format nil "~{~A~@{.~A~}~}"
						      (reverse (butlast name-list 2)))))))))
		   (when host
		     (make-instance 'address-domain :host host)))))))))))

(defun find-domain (name-list &optional (if-not-found ()) ignore-nonexistant-domains)
  (or (and (not ignore-nonexistant-domains) (find-nonexistent-domain name-list))
      (find-dialnet-domain name-list if-not-found)
      (find-address-domain name-list if-not-found)
      (find-namespace-domain name-list if-not-found)
      (find-native-domain name-list if-not-found)))

;;;
;;; Predicate indicating whether we are the root domain ("")
;;;
(defmethod (root-domain-p native-domain) ()
  (or (null name-list)
      (string-equal (car name-list) "")))

(comment
(defmethod (remove-timed-out-rrs native-domain) ()
  (loop for prop-and-rrs in resource-records
	do
    (when (listp (cdr prop-and-rrs))
      (loop for rr in (cdr prop-and-rrs) do 
	(when (and (neq rr ':unknown) (expired-p (rr-ttl rr)))
	  (when *debug-domain-requests*
	    (format t "~&~S timed out, deleted" rr))
	  (delq rr prop-and-rrs))))
    (unless (cdr prop-and-rrs)			; all timed out?
      (setf (cdr prop-and-rrs) ':unknown))))
)

(defmethod (domain-rrs domain-with-cache) (&optional (rr-type ':*) (rr-class ':*)
						     &key (up-to-date nil))
  (declare (values answers return-code authoritative))
  ;;(format t "~&~S got a request for ~S" self rr-type)
  ;;(remove-timed-out-rrs self)
  (let ((testing-classes (or (and (eq rr-class ':*)
				  (loop for (nil class-name nil) in *domain-classes*
					unless (eq class-name ':*)
					  collect class-name))
			     (and (symbolp rr-class) (list rr-class))
			     rr-class))
	(return-code nil))			; means all returned info fine.
    (values
      ;;
      ;; Loop thru all classes, doing the collection of various types.  It's done this way
      ;; to deal with the case of different canonical-names for different classes!
      ;;
      (loop for index-class in testing-classes
	    append
	    ;;
	    ;; First order of business is to see if there's a cname for this thing.  If so,
	    ;; simply return that.
	    ;;
	      (let ((real-name (when (and (neq rr-type ':canonical-name)
					  (neq rr-type ':*))
				 ;; only look for CNAME override if not asking for CNAME or *
				 (gethash `(:canonical-name ,index-class)
					  resource-record-cache))))
		(if (and real-name
			 (let* ((ttls-and-rdata real-name)
				(ttl-and-rdata (first ttls-and-rdata))
				(rdata (second ttl-and-rdata))
				(cname rdata))
			   ;; ignore negatively cached cname records, or records to the root.
			   (not (null cname))))
		    (list (make-rr name-list name-list 
				   type ':canonical-name 
				   class index-class
				   ttl (external-from-internal-time-to-live 
					 (caar real-name))
				   rdata (cadar real-name)))
		    ;;
		    ;; No alias, so do the real query
		    ;;
		    (let ((testing-types (or (and (eq rr-type ':*)
						  (loop for (nil type-name) in *domain-types*
							collect type-name))
					     (and (symbolp rr-type) (list rr-type))
					     rr-type)))
		      (loop for index-type in testing-types 
			    as cached-data = (gethash `(,index-type ,index-class)
						      resource-record-cache)
			    when cached-data
       			    append 
			      (loop for (cached-ttl cached-resource-data) in cached-data
				    as expired-p = (expired-p cached-ttl)
				    when (and (or (null up-to-date)
						  (null expired-p))
					      ;; kludge filter out negatively cached CNAME
					      (not (and (eq index-type :canonical-name)
							(null cached-resource-data))))
				    collect (progn
					      (when expired-p
						(setq return-code ':unknown))
					      (make-rr name-list name-list
						       type index-type
						       class index-class
						       ttl (external-from-internal-time-to-live 
							     cached-ttl)
						       rdata cached-resource-data)))
			      into inner-loop-returned-rrs
			    finally
			      (when (and (null return-code) (null inner-loop-returned-rrs)
					 (null (local-host-is-primary-server self)))
				(setq return-code ':unknown))
			      (return inner-loop-returned-rrs)
			      )))))
      return-code
      (authoritative self))))


	
(defmethod (set-domain-rrs domain-with-cache) (index-type index-class ttls-and-data)
  (when (null (and (symbolp index-type) (neq index-type ':*)))
    (ferror "Attempt to set invalid data type ~A in ~A" index-type self))
  (if (eq index-class ':*)
      (setq index-class (loop for (nil name nil) in *domain-classes*
			      unless (eq name ':*)
				do (set-domain-rrs self index-type name ttls-and-data)))
      (puthash `(,index-type ,index-class) ttls-and-data 
	       resource-record-cache)))

(defmethod (set-domain-rrs namespace-domain) (&rest ignore)
  ;;
  ;; perhaps this should signal an error, perhaps not.  In any case, we ignore these attempts
  ;; for now.
  )

(defmethod (set-domain-rrs address-domain) (&rest ignore)
  ;;
  ;; perhaps this should signal an error, perhaps not.  In any case, we ignore these attempts
  ;; for now.
  )

;;;
;;; The domain whose name is (cdr ours).  That's our parent.
;;;
(defmethod (domain-parent native-domain) ()
  (if (root-domain-p self) self
      (find-native-domain (cdr name-list) t)))



(defun find-all-known-server-rrs ()
  (declare (special *all-domains*))
  (loop for domain in *all-domains* 
	with returned-servers = ()
	as servers = (domain-rrs domain ':name-server)	; Get all servers, even timed out ones
	when servers do
	  (loop for server in servers
		as server-domain = (find-native-domain (rr-rdata server))
		do
		(when (and server-domain (domain-rrs server-domain ':address))
		  (push server returned-servers)))
	finally (return (si:eliminate-duplicates
			       returned-servers
			       #'rr-equal-p))))

;;;
;;; this generic function is intended to return records whose data portions 
;;; are names of servers that might be reasonable to contact.
;;; the only method that actually does anything interesting is the one for native domains.
;;;
(defmethod (find-reasonable-server-rrs basic-domain) (&rest ignore)
  (declare (values rrs authoritative))
  (values nil t))

(defmethod (find-reasonable-server-rrs domain-with-cache) 
	   (&optional (class ':internet) &key (up-to-date ()))
  (declare (values rrs authoritative))
  (find-reasonable-server-rrs-internal (name-list self) class ':up-to-date up-to-date))



;;;
;;; look up the tree from the passed name-list, collecting server-rr names.
;;; if we get to a domain that we're authoritative for, stop right there and return 
;;; what names we have.
;;;
(defun find-reasonable-server-rrs-internal (name-list &optional (class ':internet)
					    &key (up-to-date ()))
  (declare (values rrs authoritative))
  (loop with found-rrs
	for partial-name-list on name-list 
	as domain = (find-domain partial-name-list)
	as its-one-of-mine = (and domain (authoritative domain)
				  (local-host-is-primary-server domain))
	do
    (when its-one-of-mine
      (return
	(values found-rrs t)))
    (when domain
      (setq found-rrs 
	    (append found-rrs
		    (loop for name-server-rr in (domain-rrs domain ':name-server class
							    ':up-to-date up-to-date)
					   when (rr-rdata name-server-rr)
					     collect name-server-rr))))
    	finally
	  ;;
	  ;; NOTE!!!  This is the place to check for root server info timing out, and signal 
	  ;; appropriate condition!!!
	  ;;
	  (return
	    (values (append found-rrs
			    (domain-rrs (find-domain () ':create) ':name-server class))
		    nil))))



;(defun domain-name-distance (name1 name2)	; this is not accurate, good enuf for now
;  (if (null name1) 999
;      (loop with ordered-names1 = (reverse name1)
;	    with ordered-names2 = (reverse name2)
;	    for i from 0 below (min (length name2) (length name1))
;	    for n1 in ordered-names1
;	    for n2 in ordered-names2
;	    when (not (string-equal n1 n2))
;	      do (return (- 100 i))
;	    finally (return 0))))

;;;
;;; some measure of 'distance' in the domain name tree.  up-jumps cost 1, down-jumps
;;; cost twenty.  name1 is the name we are testing, name2 is the one we are trying to get to.
;;;
(defun domain-name-distance (name1 name2)	
  (loop with distance = 0
	with nl1 = (reverse name1)
	with nl2 = (reverse name2) 
	while (or nl1 nl2)
	as n1 = (pop nl1)
	as n2 = (pop nl2)
	do
    (when (or (not (string-equal n1 n2)) (> distance 0))
      (setq distance (+ distance (if n1 20 0) (if n2 1 0))))
    finally (return distance)))
      
(defun sort-by-distance (server-rr-list name-list)
  (sort server-rr-list 
	#'(lambda (rr1 rr2)
	    (let ((d1 (domain-name-distance (rr-name-list rr1) name-list))
		  (d2 (domain-name-distance (rr-name-list rr2) name-list)))
	      (< d1 d2)))))

;; rename this someday to be something like sort-server-rr-list-by-availability
;;
(defun sort-by-availability (server-rr-list)
  (flet ((availability (server-rr)
	   (let* ((domain (find-native-domain server-rr))
		  (host-object (and domain (send domain ':host-object))))
	     (cond ((null domain) .7)		; we'll try it, but would rather have a real 
						; one
		   ((null host-object) .8)	; no host, better, but still not as good as
						; if we have a real one
		   (t (let ((availability
			      (send host-object ':available ':service ':domain)))
			(if (fixnump availability) availability
			    (if availability 1 0))))))))
    (sort (loop for server-name-record in server-rr-list
		when (rr-rdata server-name-record)
		  collect server-name-record)
	#'(lambda (rr1 rr2)
	    (> (availability rr1)
	       (availability rr2))))))


;;;
;;; call this when we get a failure trying to contact a host for domain service.  this
;;; will only happen for byte-stream style connections.  It returns t if we should 
;;; restart the query
;;;
(defun domain-connection-failure-handler (host-or-error)
  (let ((host (if (typep host-or-error 'error)
		  (send host-or-error ':error-server)
		  host-or-error)))
    (when (and (typep host 'host)
	       (memq host *domain-site-servers*))
      (when (and (null (loop for server in *domain-site-servers*
			     thereis (> (send server ':availability ':service ':domain) 0.6)))
		 *domain-site-resolver-error-implies-standalone*)
	;;
	;; Oops!  All site servers have failed to respond.  
	;; set us up for standalone
	;;
	(setq *domain-default-recursion-request* nil
	      *domain-site-servers* nil		; now we're standalone!
	      *domain-resolver-status* ':initialized)
	(reinitialize-domain-resolver)))))
  
(defun domain-query (domain-object-or-name-list &optional (query-type ':*) (query-class ':*)
		     (ask-server-if-not-in-cache t))
  (declare (values answers rcode authoritative-p))
  (if (listp domain-object-or-name-list)
      (domain-query (find-domain domain-object-or-name-list ':create)
		    query-type query-class ask-server-if-not-in-cache)
      (let* ((domain-object domain-object-or-name-list))
	;; Check QUERY-TYPE and QUERY-CLASS before doing anything further.
	;; Necessary because this is occasionally used for debugging.
	(unless (lisp:member query-type *domain-types* :key #'second)
	  (error "~S is not a known domain query type" query-type))
	(unless (lisp:member query-class *domain-classes* :key #'second)
	  (error "~S is not a known domain query class" query-class))
	(loop doing 
	  (when *debug-domain-requests* 
	    (format t "~&~%Starting query on ~A" domain-object))
	      as (rrs rcode authoritative-p additional) =
		 (catch 'restart-domain-query
		   (noting-network-progress ((format nil "Domain query for ~A ~A ~A"
						     domain-object query-type query-class))
		     (multiple-value-list 
		       (domain-query-internal domain-object
					      query-type query-class 
					      ask-server-if-not-in-cache))))
	      do
	  (cond ((eq rcode ':restart-query))
		((and (neq query-type ':*)	;don't redirect if asking for * ...
		      (neq query-type ':canonical-name)	;... or CNAME
		      (eq (rr-type (car rrs)) ':canonical-name)
		      (not (null (rr-rdata (car rrs))))	;don't cname to the root (e.g.,
						; via a negatively cached cname)
		      (null (typep domain-object 'namespace-domain)))	; hack, need to think
						; more about flavor structure
		 (let ((new-domain-object (find-domain (rr-rdata (car rrs)) ':create)))
		   (if (eql domain-object new-domain-object)
		       ;;should really be checking for generalized cycles here...
		       (return-from domain-query
			 (values rrs rcode authoritative-p additional))
		       (setq domain-object new-domain-object))))
		(t
		 (return-from domain-query
		   (values rrs rcode authoritative-p additional)))))))) 
  
(defmethod (domain-query-internal domain-with-cache)
	   (query-type query-class &optional (ask-server-if-not-in-cache t)
		       &rest ignore)
  ;;(format t "~&Querying domain ~S for ~S ~S" self query-type query-class)
  (when (and (neq query-type ':*)		;don't jump the gun if asking for * ...
	     (neq query-type ':canonical-name))	;... or CNAME
    (let ((cname (domain-rrs self ':canonical-name query-class ':up-to-date t)))
      (when (and cname
		 (let* ((rrs cname)
			(rr (first rrs))
			(rdata (rr-rdata rr)))
		   ;; ignore negative caching
		   (not (null rdata))))
	(return-from domain-query-internal (values cname nil)))))
  (multiple-value-bind (initial-rrs initial-error-code initial-query-authoritative) 
      (domain-rrs self query-type query-class ':up-to-date ask-server-if-not-in-cache)
    ;;
    ;; More hair that shouldn't have to be in here.  Screw case:  We're a secondary server
    ;; for some lump of stuff, but our latest info's out of date, for whatever reason.
    ;; When we go to ask something (like the address of the server so we can go snarf a new
    ;; zone) we get to here with no answers, and authoritative, even if asked to talk
    ;; to servers if necessary.  So: If we detect that case, treat it as if we weren't 
    ;; authoritative.  Yech.
    ;;
    (if (or (not ask-server-if-not-in-cache)
	    (and (or (neq initial-error-code ':unknown)
		     (and (authoritative self)
			  (not (local-host-is-primary-server self))))
		 (or initial-query-authoritative
		     (authoritative self))))
	(progn 
	  ;;
	  ;; If we were asked for a local query only, and any of the info is timed out
	  ;; (indicated by ttl 0) set the return code to ':unknown
	  ;;
	  (loop for rr in initial-rrs 
		when (zerop (rr-ttl rr))
		  do (setq initial-error-code ':unknown))
	  (values initial-rrs initial-error-code initial-query-authoritative))
	(let* ((minimum-distance 999.)
	       (candidates (or (sort-by-availability
				 (domain-rrs self ':name-server query-class))
			       (and *domain-default-recursion-request* *domain-site-servers*)
			       (multiple-value-bind (server-rrs authoritative)
				   (find-reasonable-server-rrs self query-class
							       ':up-to-date t)
				 (cond (server-rrs server-rrs)
				       (authoritative
					(signal 'domain-resolver-error
						:error-rr '(:rcode :name-error)
						:error-server *local-host*))
				       (t
					(find-root-domain-servers)
					))))
			   )
	       (candidates-tried ()))
	  (catch 'answer
	    (loop as candidate = (car candidates) 
		  ;;
		  ;; minimum-distance here is the 'distance' from the server to the name
		  ;; 
		  as candidate-distance = (if (listp candidate)
					      (domain-name-distance (rr-name-list candidate)
								    name-list)
					      minimum-distance)
		  when (<= candidate-distance minimum-distance)
		    do (setq minimum-distance candidate-distance)
		       ;;
		       ;; Availability is judged here.  If we have a host object already,
		       ;; we use its availability measure, otherwise, assume 1 until we
		       ;; actually try and fail.
		       ;; An availability number of 0.6 works out to about 15 minutes,
		       ;; ie if we fail talking to someone, we'll wait at least 15 min
		       ;; before trying again.
		       ;;
		  as candidate-available = 
		     (> (let ((server-host
				(cond ((typep candidate 'host) candidate)
				      ((typep candidate ':list)
				       (let* ((server-domain (find-domain 
							       (rr-rdata candidate))))
					 (and server-domain 
					      ;; well, this is stupid.  turns out we can
					      ;; get cases where one server told us the name
					      ;; of a host to use as a server, but somebody
					      ;; else told us there was no such host.  Great...
					      (not (typep server-domain 'nonexistent-domain))
					      (host-object-in-domain-named
						server-domain (car (rr-rdata candidate)))))
				       ))))
			  ;;
			  ;; see if the host object we got is ourselves.  if we are proposing
			  ;; to ask ourselves, then return 
			  (if server-host (send server-host ':availability
						':service ':domain)
			      1))
			0.6)
		  ;;
		  ;; Now make the request, and hope for answers
		  ;;
		  as answer-packets = 
		     (cond 
		       ((> candidate-distance minimum-distance) nil)
		       (candidate-available
			(when *debug-domain-requests*
			  (format t "~&Asking ~A" (if (listp candidate)
						      (make-dotname 
							(rr-rdata candidate))
						      candidate)))
			(let ((server-domain (if (listp candidate)
						 (find-domain 
						   (rr-rdata candidate))
						 candidate)))
			  (when server-domain	; should make sure have address too
			    (condition-case (error)
				 (domain-query-host server-domain	
						    name-list
						    query-type query-class)
			       (domain-site-resolver-error
				 (when (domain-connection-failure-handler error)
				   (throw 'restart-domain-query
				     '(nil :restart-query nil))))))))
		       ;;
		       ;; not available, eh?  ok, pretend we actually tried and got a
		       ;; failure, and invoke the connection failure handler.
		       ;;
		       (t (when (domain-connection-failure-handler candidate)
			    (throw 'restart-domain-query '(nil :restart-query nil)))))
		  
		  do
	      (push candidate candidates-tried)
	      (when *debug-domain-requests*
		(format t "~&Tried= ~S" candidates-tried))
	      (loop for answer-packet in answer-packets  do
		(when (neq (zl:get (locf answer-packet) ':rcode) ':no-error)
		  (setq initial-error-code (zl:get (locf answer-packet) ':rcode))
		  (when (eq initial-error-code ':name-error)
		    ;;
		    ;; remember that it doesn't exist.  The instance will put itself
		    ;; in the hash table
		    ;;
		    (make-instance 'nonexistent-domain 
				   ':name-list (name-list self)	
				   ':error-server (if (listp candidate)
						      (find-domain 
							(rr-rdata candidate))
						      candidate)
				   ':error-answer answer-packet))
		  (signal 'domain-resolver-error :error-server
			  (if (listp candidate)
			      (find-domain 
				(rr-rdata candidate))
			      candidate)
			  :error-rr answer-packet))
		(when (or *domain-default-recursion-request*
			  (zl:get (locf answer-packet) ':authoritative))
		  (throw 'answer 
		    (domain-rrs self query-type query-class))))
	      (setq candidates 
		    (loop with new-candidate-list =
			    (si:eliminate-duplicates
			      (append
				(loop for answer-packet in answer-packets
				      as new-authorities = (zl:get (locf answer-packet)
								   ':authorities)
				      do (loop for new-auth in new-authorities
					       for new-auth-name =
					       (if (eq (rr-type new-auth) ':start-of-authority)
						   (rr-name-list new-auth)
						   (rr-rdata new-auth))
					       as new-distance = (domain-name-distance
								   new-auth-name
								   name-list)
					       do (when (> new-distance minimum-distance)
						    (setq minimum-distance new-distance)))
				      append new-authorities)
				candidates)
			      #'(lambda (candidate-1 candidate-2)
				  (if (and (listp candidate-1) (listp candidate-2))
				      (rr-equal-p candidate-1 candidate-2)
				      (eq candidate-1 candidate-2))))
			  for tried-candidate in candidates-tried
			  do 
		      (when *debug-domain-requests* 
			(format t "~&New cand = ~S" new-candidate-list))
		      ;;
		      ;; now remove the one we tried
		      ;;
		      (setq new-candidate-list
			    (loop for new-candidate in new-candidate-list 
				  unless (or (not candidate)
					     (eq tried-candidate new-candidate)
					     (and (listp tried-candidate) 
						  (listp new-candidate)
						  (rr-equal-p tried-candidate
							      new-candidate)))
				    collect new-candidate))
			    finally (return new-candidate-list)))
	      (when *debug-domain-requests*
		(format t "~&~%Cand = ~S" candidates))
		  until (or (null candidates)
			    (multiple-value-bind (answers return-code)
				(domain-rrs self query-type query-class ':up-to-date t)
			      (or answers (null return-code))))))
	  (if (eq initial-error-code ':unknown)
	      (domain-rrs self query-type query-class ':up-to-date nil)
	      (values initial-rrs initial-error-code (authoritative self)))
	  ))))






;;;
;;; given some rr-lists (assumed to be authoritative) process them into rrs in the
;;; right domains
;;;
(defun process-domain-answers (answer-rr-lists &optional (authoritative-p nil) 
			       (local-host-is-server-p nil))
  (flet ((convert-ttl (rr)
	   ;; Convert a TTL to the expiration time (in minutes) with a 1 minute minimum TTL.
	   (+ (max (round (rr-ttl rr) 60.) 1) (universal-time-in-minutes))))
    (dolist (answer answer-rr-lists)
      (let* ((name-list (rr-name-list answer))
	     (domain (find-domain name-list :create :ignore-nonexistant-domains))
	     (internal-ttl (convert-ttl answer))
	     (internal-data (rr-rdata answer)))
	(when *debug-domain-requests*
	  (format t "~&Processing ~S" answer))
	(when domain
	  ;; Record the new RRs in the domain.
	  (when authoritative-p
	    (set-authoritative domain t))
	  (when local-host-is-server-p
	    (set-local-host-is-primary-server domain t))
	  (when (and (eq (rr-type answer) :address)
		     (eq (rr-class answer) :internet)
		     internal-data		;I've seen answers with NIL -- Kalman
		     )
	    (process-domain-answers
	      (list (make-rr name-list (append (reverse (parse-domain-style-name internal-data))
					       '("IN-ADDR" "ARPA"))
			     type :pointer class :internet ttl (rr-ttl answer) rdata name-list))
	      authoritative-p local-host-is-server-p))
	  (flet ((update-domain (domain)
		   (let ((old-rrs (domain-rrs domain (rr-type answer) (rr-class answer)
					      :up-to-date t)))
		     ;;
		     ;; Note that this returns only the up-to-date ones!
		     ;; This has the effect of
		     ;; timing out dead records when we have a replacement.
		     ;;
		     ;; Now push the new datum into the resource-record cache of the domain.
		     ;; If we had previously gotten a NIL answer about something, and now we
		     ;; are entering a real datum, we want to flush the old empty one.  It
		     ;; will be identifiable by NIL rdata, so if we see one, we'll say it's the
		     ;; same as a duplicate.
		     ;;
		     (set-domain-rrs domain (rr-type answer)
				     (rr-class answer)
				     (si:eliminate-duplicates
				       (cons (list internal-ttl internal-data)
					     (loop for old-rr in old-rrs
						   collect `(,(convert-ttl old-rr)
							     ,(rr-rdata old-rr))))
				       #'(lambda (first-internal-rr second-internal-rr)
					   (or (null (second second-internal-rr))
					       (equal (second first-internal-rr) 
						      (second second-internal-rr)))))))))
	    (update-domain domain)
	    (when (equal (first name-list) "*")
	      (maphash #'(lambda (key value)
			   (let ((diff (1+ (- (length key) (length name-list)))))
			     (when (and (plusp diff)
					(equal (nthcdr 1 name-list) (nthcdr diff key))
					(typep value 'native-domain))
			       (update-domain value))))
		       *domain-hash-table*))))))))


(defun domain-query-host (host rr-name query-type query-class)
  (let ((real-host host)
	(*inhibit-validity-checking* t))	; needed if validate-once-per-boot is off
    ;; Check QUERY-TYPE and QUERY-CLASS before doing anything further.
    ;; Necessary because this is occasionally used for debugging.
    (unless (lisp:member query-type *domain-types* :key #'second)
      (error "~S is not a known domain query type" query-type))
    (unless (lisp:member query-class *domain-classes* :key #'second)
      (error "~S is not a known domain query class" query-class))
    (when (not (typep real-host 'net:host))
      (setq real-host 
	    (or (condition-case (e)
		     (and (domain-rrs (if (listp host) (find-domain host t) host)
				      ':address query-class ':up-to-date nil)
			  (neti:find-object-named ':host 
						  (if (listp host) (car host)
						      (format () "DOMAIN|~{~A~@{.~A~}~}" 
							      (name-list host))))
			  )
		   (net:object-not-found ()))
		;; Modularity 'r us.  In the case where there's a host
		;; which isn't in a namespace, whose authoritative
		;; server is in a namespace, we end up here trying to
		;; create a domain host when there's already one by that
		;; name in a real namespace, thus creating two hosts of
		;; the "same" name and causing lots of confusion.  Check
		;; for a namespace domain, and just use that object if
		;; we get on.
		(and (typep host 'namespace-domain)
		     (let ((*inhibit-validity-checking* nil))	; in case host object stale
		       (host-object-in-domain-named host (first (name-list host)))))
		(make-native-domain-host host))
	    ))
    (when real-host
      (when (typep host 'basic-domain)		; a domain?
	(send host ':set-host-object real-host))	; remember this host for next time
      (setq real-host (ensure-domain-service-entries real-host))
      (unless real-host				; e-d-s-e refused to add services?
	(return-from domain-query-host nil))
      ;;(format t "  ~A" real-host)
      (when (listp host)
	(setq host (find-domain host)))
      (multiple-value-bind (answers error)
	  (condition-case (signalled-error)
	       (let* ((access-path (net:invoke-service-on-host :domain real-host)))
		 (unwind-protect 
		     (multiple-value-prog1
		       (values 
			 (send access-path ':transaction 
			       `(:id ,(next-request-number)
				 :query t :opcode :query 
				 :questions ((,rr-name ,query-type ,query-class))))
			 nil)
		       (send access-path ':close))
		   (send access-path ':close)))
	     (domain-packet-format-error (values nil signalled-error))
	     (network-error
	       (send real-host ':set-unavailable ':service ':domain) 
	       (if (memq host *domain-site-servers*)
		   (signal 'domain-site-resolver-error
			   :error-server host
			   :error-site *local-site*))
	       (values nil signalled-error)))
	;;
	;; Adjust the host availability.  If we got answers, say it's available now.
	;; Otherwise, leave it alone.  If we errored out, signalling 
	;; domain-site-resolver-error will have zapped the availability of this host.
	;;
	(if (and answers (null error))
	    (send real-host ':set-available ':service ':domain)
	    (send real-host ':set-unavailable ':service ':domain))
	;;
	;; Now process the answers
	;;
	(loop for ans in answers do
	  (when (eq (get (locf ans) ':rcode) ':no-error)
	    ;;
	    ;; Yet another wierd special case.  If the question asked contains a wildcard
	    ;; class, we assume that the answers given are all the answers there are.
	    ;; That means that we must generate numm records for the classes that weren't
	    ;; answered.  NOTE!!! It's done this way because the servers this code is
	    ;; likely to talk to are Symbolics, which will return all the answers it can,
	    ;; and random unix/20 stuff which will only return internet.
	    ;; This will  almost certainly change later on.
	    ;;
;	    (let ((question (first (get (locf ans) ':questions))))
;	      (when (and (get (locf ans) ':authoritative) 
;			 (eq (rr-class question) ':*))
;		(process-domain-answers `(,(make-rr name-list (rr-name-list question)
;						    type (rr-type question)
;						    class ':*
;						    ttl (* 60 60 6))))))
	    ;;
	    ;; now get on with the real answers, if any
	    ;;
	    (loop for tag in '(:authorities :additional :answers) do
	      (process-domain-answers (get (locf ans) tag)))
	    ;;
	    ;; If we got no answers, but authoritative, make up a record that will live
	    ;; one day, that says no data
	    ;;
	    (when (and (get (locf ans) ':authoritative)
		       (null (get (locf ans) ':answers))
		       (neq (rr-type (car (get (locf ans) ':questions))) ':*)
		       (neq (rr-class (car (get (locf ans) ':questions))) ':*))
	      (process-domain-answers `(,(let ((old-rr (car (get (locf ans) ':questions))))
					   (make-rr name-list (rr-name-list old-rr)
						    type (rr-type old-rr)
						    class (rr-class old-rr)
						    ttl (* 60 60 6))))))
	    ))
	answers)))) 

;;;
;;; a list of things for converting port 'names' to services
;;;
(defvar *protocol-to-service-alist*
	'((:ftp . :file)
	  (:tftp . :file)
	  (:tcp-ftp . :file)
	  (:nfile . :file)
	  (:3600-login . :login)
	  (:supdup . :login)
	  (:telnet . :login)
	  (:time-msb . :time)
	  (:time-simple-msb . :time)
	  (:ascii-name . :show-users)
	  (:smtp :send :mail-to-user :expand-mail-recipient :store-and-forward-mail)
	  (:domain . :domain)
	  (:domain-simple . :domain))
  )
	  
(defun service-from-protocol (p)
  (cdr (assq p *protocol-to-service-alist*)))



;;;
;;; A little ditty to make network-finding a bit easier.  In most cases, saying
;;; find-object-named :network foo would be sufficient, but the Dial network is
;;; special, and sometimes won't be found by that incant, as, by default, it's not in
;;; the local namespace.
;;;
(defun find-network-named (network-name)
  (setq network-name (string network-name))
  (or (find-object-named ':network network-name nil)	; try the normal way
      (when (cl:equalp network-name "DIAL")
	dial:*dialnet-dial-network*)))


(defun partial-host-plist-from-domain (host-domain)
  (declare (values partial-host-plist))
  (let* ((host-info (domain-rrs host-domain ':host-info ':* ':up-to-date nil))
	 (host-addresses (domain-rrs host-domain
				     ':address :* ':up-to-date nil))
	 (host-services (domain-rrs host-domain ':well-known-services :* ':up-to-date nil)))
    `(,@(when (cadr (rr-rdata (car host-info))) 
	  `(:system-type ,(nic-to-system-type (cadr (rr-rdata (car host-info))))))
      :address 
      ,(loop for address in host-addresses
	     for network-class = (rr-class address)
	     for rdata = (rr-rdata address)
	     with address-string
	     for network = (and rdata
				(cl:case network-class
				      ((:internet :dial)
				       (setq address-string rdata)
				       (find-network-named network-class))
				      (:chaos
					(setq address-string (second rdata))
					(let* ((name-string (format () "~{~A~@{.~A~}~}" 
								    (first rdata)))
					       (name-symbol (intern (string-upcase name-string)
								    ':keyword)))
					  (find-object-from-property-list 
					    ':network ':global-network-name name-symbol)))))
	     when network
	       collect (list network address-string))
      :service 
      ,(loop for (nil nil class nil encoded-services)
		 in host-services
	     append
	       (selectq class
		 (:internet
		  (destructuring-bind (() ip-protocol service-protocols) 
				      encoded-services
		    (loop for service-protocol in service-protocols
			  for services = (or (service-from-protocol service-protocol)
					     ':unknown)
			  nconc
			    (if (listp services)
				(loop for service in services
				      collect 
					(list service
					      ip-protocol
					      service-protocol))
				(list (list services ip-protocol 
					    service-protocol))))))
		 ;; 
		 ;; may change if ever figure out what NIC thinks the representation of
		 ;; chaos services is!
		 ;;
		 ((:chaos :dial)
		  (loop for (service protocol) in encoded-services
			collect `(,(intern service 'keyword)
				  ,class
				  ,(intern protocol 'keyword))))))
      :domain-host-info
      ,(make-domain-host-info expiration
			      (+ (universal-time-in-minutes)
				 (// (loop for (nil nil nil ttl rdata) in
					       (append host-info 
						       host-addresses
						       host-services)
					   when rdata
					     minimize ttl)
				     60.))))))

;;;
;;; Most weenix sysadmin types don't bother to provide service entries,
;;; as they don't need 'em.  We, however, do, so we must do something
;;; about providing plausible defaults in the case where there were no
;;; WKS records.
;;;
;;; This structure allows the list to be tweaked, or new system types to
;;; be added with a minimum of fuss.  Note that we use host flavor here,
;;; rather than system-type, to try to be upward compatible when people
;;; invent new ones.
;;;
(defvar *default-domain-host-services*		; alist of (type-name services)
	'((fs:unix-host
	    ((:file :tcp :tcp-ftp)
	     (:show-users :tcp :ascii-name)
	     (:login :tcp :telnet)
	     (:mail-to-user :tcp :smtp)
	     (:store-and-forward-mail :tcp :smtp)))
	  ;; most basic kind of host
	  (host
	    ;; maybe just ((:file :tcp :tcp-ftp)) ?
	    )))

;;;
;;; handed a host, return some plausible service entries for it.
;;;
(defun plausible-service-entries (host)
  (loop for (type entries) in *default-domain-host-services*
	when (typep host type) do (return entries)
	finally (error "~A is not a host" host)))

;;;
;;; make a (namespace style) host object from a domain; host-domain must be a caching-domain.
;;; if the host spec we're given is a domain, stuff the host object back into the domain
;;; for later.
;;;
(defun make-native-domain-host (original-host-domain 
				&optional (ask-server-if-not-in-cache nil))
  (let* ((host-aliases (domain-rrs original-host-domain ':canonical-name ':*))
	 (host-domain (if host-aliases
			  (find-domain (rr-rdata (car host-aliases)))
			  original-host-domain))
	 ;;
	 ;; NOTE!!!  This does not deal with the case of a canonical name that is an
	 ;; alias for different hosts in different classes.  I don't know what to do about
	 ;; that, so I'm ignoring it and just taking the first.
	 ;;
	 (host-name-list (name-list host-domain))
	 (host-name (format () "~{~A~@{.~A~}~}" host-name-list))
	 (host (send host-domain ':host-object))
	 (plist-from-domain
	   (partial-host-plist-from-domain host-domain))
	 (complete-plist nil))
    ;; query for the stuff we nned to make a host.  This refreshes the stuff cached in
    ;; the domain if necessary
    (domain-query host-domain ':address ':* ask-server-if-not-in-cache)
    (domain-query host-domain ':host-info ':* ask-server-if-not-in-cache)
    (domain-query host-domain ':well-known-services ':* ask-server-if-not-in-cache)
    ;;
    ;; merge plists in this order so as to preserve any old props that aren't getting 
    ;; refreshed this time around
    ;;
    (when host
      (multiple-value-bind (name plist) 
	  (send host ':namespace-view *domain-namespace*)
	(ignore name)
	(loop for (tag value) on plist by #'cddr do
	  (setf (cl:getf complete-plist tag) value))))
    (loop for (tag value) on plist-from-domain by #'cddr do
      (setf (cl:getf complete-plist tag) value))
    (when (cl:getf complete-plist ':address)
      (setq host
	    (neti:update-object-permanently 
	      ':host
	      *domain-namespace*
	      (neti:parse-name (format () "DOMAIN|~A" host-name) ())
	      complete-plist
	      t))
      ;; Per Charlie:  This isn't really the right way to do this, but it's too late to
      ;; fix it now.  In the Devo world, use a different mechanism for determining
      ;; if a host's timed out.
      (send host ':putprop (cl:getf complete-plist ':domain-host-info)
	    ':domain-host-info))
    
    (when host
      ;;
      ;; If this host has no service entries, use the defaulting
      ;; mechanism.  Not that this probably isn't really quite right, as
      ;; we will take this path even if there was an empty WKS record, ie
      ;; telling us there are no services, as opposed to not telling us
      ;; anything.  Tough.
      ;;
      (unless (send host ':service)
	(let ((services (plausible-service-entries host)))
	  (when services			; no default???  forget it
	    (multiple-value-bind (name plist)
		(send host ':namespace-view *domain-namespace*)
	      (setf (cl:getf plist ':service) services)
	      (update-object-permanently ':host *domain-namespace* name plist t))))))

    (send host-domain ':set-host-object host)
    host))

(defun ensure-domain-service-entries (host)
  (let* ((host-services (send host :get :service))
	 (host-domain-services (loop for (service medium protocol) in host-services
				     thereis (and (eq service :domain)
						  (or (and (member medium '(:tcp :chaos))
							   (eq protocol :domain))
						      (and (eq medium :udp)
							   (eq protocol :domain-simple)))))))
    (when
      (or host-domain-services
	  (let* ((uninterned (send host :uninterned-p))
		 (primary-name (send host :primary-name))
		 (primary-namespace (and (not uninterned) (send primary-name :namespace))))
	    1;; Don't change the services of just any host --
0	    1;;   We can update the services of hosts in the 0Domain1 namespace as they are
	    ;;   created from remote server answers and most servers don't maintain proper
	    ;;   0WKS1 records.  Also, we can update uninterned hosts as they are created
	    ;;   out of whole cloth and aren't created with any useful service entries.
0	    (when (or uninterned
		      (ns-eq primary-namespace *domain-namespace*))
	      (send host :putprop
		    (append host-services '((:domain :udp :domain-simple))) :service)
	      (unless uninterned
		1;; Don't use (2 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")update-object-permanently1 on uninterned hosts as it will
		;; intern the host which can cause all sorts of problems later on ...
0		(update-object-permanently :host primary-namespace primary-name
					   (send host :property-list)
					   t))
	      t)))
      host)))

(defun ensure-mail-service-entries (host-object)
  (let* ((host-services (send host-object :get :service))
	 (host-mail-services (loop for (service nil nil) in host-services
				   thereis (memq service '(:store-and-forward-mail
							   :mail-to-user)))))
    (when
      (or host-mail-services
	  (let* ((uninterned (send host-object :uninterned-p))
		 (primary-name (send host-object :primary-name))
		 (primary-namespace (and (not uninterned) (send primary-name :namespace))))
	    1;; Don't change the services of just any host --
0	    1;;   We can update the services of hosts in the 0Domain1 namespace as they are
	    ;;   created from remote server answers and most servers don't maintain proper
	    ;;   0WKS1 records.  Also, we can update uninterned hosts as they are created
	    ;;   out of whole cloth and aren't created with any useful service entries.
0	    (when (or uninterned
		      (ns-eq primary-namespace *domain-namespace*))
	      (let* ((host-addresses (send host-object :get :address))
		     (best-medium
		       (block find-best-medium
			 (dolist (type '(:internet :chaos :dial))
			   (let* ((my-network (local-network-of-type type nil))
				  (my-network-name (and my-network
							(send my-network :global-network-name))
						   ))
			     (when my-network
			       (loop for (his-network nil) in host-addresses
				     when (or (eq his-network my-network)
					      (let ((his-network-name
						      (send his-network :global-network-name)))
						(and my-network-name
						     his-network-name
						     (eq my-network-name his-network-name))))
				       do (return-from find-best-medium
					    (if (eq type :internet)
						:tcp
						type)))))))))
		(send host-object :putprop
		      (append host-services
			      (selectq best-medium
				((:tcp :dial)
				 `((:store-and-forward-mail ,best-medium :smtp)
				   (:mail-to-user ,best-medium :smtp)))
				(:chaos
				 `((:store-and-forward-mail ,best-medium :chaos-mail)
				   (:mail-to-user ,best-medium :chaos-mail)))))
		      `:service)
		(unless uninterned
		  1;; Don't use 2update-object-permanently1 on uninterned hosts as it will
		  ;; intern the host which can cause all sorts of problems later on ...
0		  (update-object-permanently :host primary-namespace primary-name
					     (send host-object :property-list)
					     t)))
	      t)))
      host-object)))

(defun kludge-sort (address-rr-list)
  (sort address-rr-list (lambda (rr1 rr2) rr2
			  (or (string-equal 
				(nsubstring (rr-rdata rr1) 0 3)
				"10.")
			      (string-equal
				(nsubstring (rr-rdata rr1) 0 4)
				"192.")))))


;;;****************************************************************
;;;
;;; hack code
;;;
;;;****************************************************************

(defvar *request-number* 0)

(defun next-request-number ()
  (if (> *request-number* 65535.)
      (setq *request-number* 0)
      (incf *request-number*)))

(defun parse-domain-style-name (name)
  (let ((names ()))
    (loop with i = 0
	  with j 
	  do
      (setq j i)
      (push (loop for k from j below (string-length name)
		  until (char-equal (aref name k) #\.)
		  finally 
		    (progn 
		      (setq i (+ k 1))
		      (return (substring name j k))))
	    names)
	  until (> i (string-length name)))
    (reverse names)))

(defun find-some-mail-destination (domain-name mail-destination-type)
  (let ((domain (find-domain domain-name ':create)))
    (when domain
      (multiple-value-bind (records code)	; records will be the resource-record 
						;  representing best mail-routing or
						;  delivery to this host
	  (domain-query domain mail-destination-type ':internet)
	(if (or records (null code))
	    (loop for record in records
		  when (rr-rdata record) 
		    collect record)		; only return something if theres real data
	    (if (and (symbolp code) (eq code ':unknown)) () 
		(error "Resolver error ~S" code) ()))))))

(defun find-domain-mail-hosts-internal (for-mail-destination-name 
					&optional (query-local-cache-only ()))
  (declare (values host-objects valid-p costs))
  (unless (stringp for-mail-destination-name)
    (setq for-mail-destination-name (string for-mail-destination-name)))
  (let* ((*domain-site-resolver-error-implies-standalone* nil)
	 (destination-name-list (parse-domain-style-name for-mail-destination-name))
	 (host-name-lists) (name-error) (authoritative-p t))
    (flet ((local-query (query-type)
	     (let ((answers nil))
	       (loop for class in '(:internet :chaos :dial)
		     with return-code
		     ;; only try a particular class if the local host can use it.
		     when (let ((network (local-network-of-type class nil)))
			    (and network
				 (cl:assoc network (send *local-host* ':address))))
		       do
		 ;; If we get a name error back, assume the name doesn't exist.
		 ;; If we get ANY valid answer, override previous :UNKNOWN answers.
		 ;; -- Chucko 16 Apr 90
			 (multiple-value-bind (these-answers this-return-code)
			     (condition-case (error)
				  (if query-local-cache-only
				      (let ((domain-object
					      (find-domain destination-name-list)))
					(when domain-object
					  (if (typep domain-object 'domain-with-cache)
					      (domain-rrs domain-object query-type class)
					      (domain-query destination-name-list
							    query-type class))))
				      (domain-query destination-name-list 
						    query-type class))
				(domain-resolver-error
				  ;; if the error-rr has a return-code of :name-error,
				  ;; we have a bogus name --
				  ;; :NAME-ERROR implies we should return (values NIL T).
				  (let ((error-rr (send error ':error-rr)))
				    (selectq (getf error-rr ':rcode)
				      (:name-error (setq name-error t)
				       nil)
				      (:format-error)
				      ;; other error???
				      ))))
			   (loop for answer in these-answers 
				 when (> (rr-ttl answer) 0)
				   do (setq return-code nil))
			   (setq answers (append these-answers answers))
			   ;; Don't invalidate info if we have any valid answers.
			   ;; -- Chucko 16 Apr 90
			   (unless (and answers (eq this-return-code ':unknown))
			     (setq return-code this-return-code)))
		 ;; This invalidates ALL queries if ANY query is :UNKNOWN.
		 ;; Not wise. -- Chucko 16 Apr 90
;			 (selectq return-code
;			   (:unknown (setq authoritative-p nil)))
		 ;; stop if get any kind of error
		     until (or name-error (and return-code (neq return-code ':unknown)))
		     finally
		       (progn
			 ;; Invalidate the result if we got no answer at all.
			 (when (eq return-code ':unknown)
			   (setq authoritative-p nil))
			 (return answers)))
	       )))
      (setq host-name-lists
	    (or (loop for mail-x-record in (sortcar 	
					     (loop for record in (local-query ':mail-x)
						   as mail-x-datum = (rr-rdata record)
						   ;; internal function, sorry about that
						   when mail-x-datum collect mail-x-datum)
					     #'<)
		      when (second mail-x-record) 
			collect mail-x-record)
		(list (list 0 destination-name-list)))))
    (if name-error
	(values nil name-error)
	(loop with cumulative-valid-p = t
	      for (nil host-name-list) in host-name-lists
	      as host-object = nil
	      as host-object-valid-p = nil
	      do (multiple-value (host-object host-object-valid-p)
		   (condition-case (error)
			(parse-host (format () "~{~A~@{.~A~}~}" host-name-list) t
				    (null query-local-cache-only))
		      (error
			(values nil nil))))
		 (setq cumulative-valid-p (and cumulative-valid-p host-object-valid-p))
	      when (and host-object
			(ensure-mail-service-entries host-object))
		collect host-object into hosts
	      finally (return (values hosts 
				      (and cumulative-valid-p 
					   (and authoritative-p
						(not query-local-cache-only)))
				      (loop for (cost nil) in host-name-lists
					    collect cost)))))))

(defun find-domain-mail-hosts (for-mail-destination-name 
			       &optional (query-local-cache-only ()))
  (declare (values host-objects valid-p costs))
  (multiple-value-bind (hosts valid-p costs)
      (find-domain-mail-hosts-internal for-mail-destination-name query-local-cache-only)
    (unless hosts
      ;; 
      ;; don't care about valid-p here, cause sometimes we'll be trying
      ;; to find out about a name that's not accessable via the regular
      ;; domain system, and thus will get (nil nil) back here.
      ;;
      (let ((for-mail-destination-name-components	; Nope, try the name one level up
	      (if (stringp for-mail-destination-name)	; Parse off first piece
		  (parse-domain-style-name for-mail-destination-name)
		  for-mail-destination-name)))
	(when (> (length for-mail-destination-name-components) 1)	;make sure we
						; haven't walked up to a top level domain
	  (multiple-value (hosts valid-p costs)	; Make the same set up queries about
	    (find-domain-mail-hosts-internal	; the 'parent'
	      (format nil "~{~A~@{.~A~}~}" (cdr for-mail-destination-name-components))
	      query-local-cache-only)))))
    (values hosts valid-p costs)))



(defun domain-find-and-validate-host (domain-host-name-list
				      &optional (ask-server-if-not-in-cache t))
  (declare (values host valid-p))
  (let* ((host (let ((domain (find-domain domain-host-name-list)))
		 (when (and domain (typep domain 'domain-with-cache))
		   (host-object-in-domain-named domain (first domain-host-name-list)))))
	 )
    (cond ((null host)
	   (values nil t))
	  ((not (expired-p (or (dhi-expiration (send host ':get ':domain-host-info)) 0)))
	   (values host t))
	  (t
	   ;; there is a host, but we don't know what it's validity is.  
	   ;; make-native-domain-host will refresh it for us.
	   (condition-case (error)
		(let* ((d (find-native-domain domain-host-name-list
					      :create)))
		(values (make-native-domain-host d ask-server-if-not-in-cache) t))
	      (domain-resolver-error (values nil nil))
	      (object-not-found-in-namespace (values nil t)))
	   ))))
    
(defun domain-parse-host (domain-host-spec &optional (ask-resolver-if-necessary t))
  (declare (values host valid-p))
  (let (host-name-list host valid-p (address-records-p nil))
    (setq host-name-list domain-host-spec)	; for now.
    (when (stringp domain-host-spec)
      (let ((bar (string-search-char #/| domain-host-spec)))
	(when bar (setq domain-host-spec (substring domain-host-spec (+ bar 1)))))
      (setq host-name-list (parse-domain-style-name domain-host-spec)))
    (multiple-value (host valid-p)
      (domain-find-and-validate-host host-name-list ask-resolver-if-necessary))
    (unless host
      (setq host 
	    (condition-case (error)
		 (when (> (length host-name-list) 1)	; top-level domains are NEVER hosts
		   (multiple-value-bind (address-records return-code)
		       (domain-query host-name-list ':address ':*
				     ask-resolver-if-necessary)	; try to get addrs
		     (selectq return-code
		       (:unknown		; couldn't tell?
			(setq valid-p nil))
		       (nil (setq valid-p t)))
		     (when (or address-records valid-p)
		       (setq address-records-p t)
		       (domain-query host-name-list ':host-info ':*
				     ask-resolver-if-necessary)	; refresh other
		       (domain-query host-name-list ':well-known-services ':*
				     ask-resolver-if-necessary))) ; data
		   (make-native-domain-host (find-domain host-name-list))
		   )
	       (domain-resolver-error
		 (let ((answer (send error ':error-rr)))
		   (when (and answer
			      (eq (get (locf answer) ':rcode) ':name-error)
			      (get (locf answer) ':authoritative))
		     (setq valid-p t)))
		 (when address-records-p
		   (make-native-domain-host (find-domain host-name-list)))))))
    (values host valid-p)))



(compile-flavor-methods namespace-domain dialnet-domain native-domain nonexistent-domain
			address-domain)
(compile-flavor-methods byte-stream-domain-access-path)
(compile-flavor-methods domain-byte-stream-record-stream)

;;;
;;; initialize some stuff
;;;
(cl:defparameter *initial-domain-query-host-name*
		 '("INTERNET|INTERNET|10.0.0.51"	; sri-nic
		   "INTERNET|INTERNET|10.3.0.52"	; usc-isib
		   "INTERNET|INTERNET|10.0.0.52"	; usc-isic
		   "INTERNET|INTERNET|192.5.22.82"	; brl-aos
		   ))

;(defun find-root-domain-servers
;       (&optional (root-server-names nil root-server-names-p))
;  (declare (values root-servers-found))
;  (let ((root-server-hosts 
;	  (cond (root-server-names-p
;		 root-server-names)
;		(t (loop for (network address) in 
;			     (send *local-site* ':get ':root-domain-server-address)
;			 collect
;			 (parse-host (format () "~A|~A" network address) nil nil))))))
;  (loop for initial-server-candidate in root-server-hosts
;	as init-rrs =
;	   (when (and initial-server-candidate
;		      (>= (send initial-server-candidate
;				':availability ':service ':domain) 0.6))
;	     (domain-query-host initial-server-candidate
;				nil		; the root domain
;				':name-server 
;				':*))
;	unless init-rrs
;	  do
;	    (send initial-server-candidate ':set-unavailable ':service ':domain)
;	when init-rrs
;	  do
;	    (return (domain-rrs (find-domain nil) ':name-server ':*)))))

(defun find-root-domain-servers (&optional (root-server-names nil root-server-names-p))
  (declare (values server-host-objects))
  (if root-server-names-p
      (loop for host-name in root-server-names
	    as host-object = (parse-host host-name t nil)
	    when host-object 
	      collect host-object)
      (loop for (network address) in 
		(send *local-site* ':get ':root-domain-server-address)
	    collect
	      (parse-host (format () "~A|~A" network address) nil nil))))

;;;
;;; Set things up at request time.  Careful!  The value returned from here is used by
;;; domain-resolver-on-p, maybe others.
;;;
(defun reinitialize-domain-resolver ()
  ;;
  ;; If we are not in :initialized state, just return T
  ;;
  (cond ((memq *domain-resolver-status* '(:initialized nil))	; need to look around
	 (cond (*domain-site-servers*		; can we ask someone to do it for us?
		(setq *domain-resolver-reset* nil	; this is obsolete; leave for now
		      *domain-resolver-on* t	; ditto
		      *domain-resolver-status* ':enabled)
		t)
	       (t
		;; we are initialized, but aren't asking for recursion.  That means
		;; we'll do it standalone.
		;;
		(if (find-root-domain-servers)	; anyone for us to talk to?
		    (setq *domain-resolver-on* t
			  *domain-resolver-reset* nil
			  *domain-resolver-status* ':enabled)
		    (setq *domain-resolver-on* nil
			  *domain-resolver-reset* t
			  *domain-resolver-status* ':disabled))
		(memq *domain-resolver-status* '(:enabled :enabled-within-site)))
	       ))
	((memq *domain-resolver-status* '(:enabled :enabled-within-site)) t)
	((memq *domain-resolver-status* '(:disabled :permanently-disabled)) nil)
	(t t)))

(defun rebuild-domain-site-server-list (&optional (init-time ()))
  init-time
  (setq *domain-site-servers*
	(loop for access-path in (find-paths-to-service ':domain `(:site ,*local-site*))
	      as host = (service-access-path-host access-path)
	      collect host))
  ;;
  ;; if there are no machines at the local site who claim to offer :DOMAIN service, then
  ;; we'll try to do it standalone.  In that case, set up state to go beat on
  ;; SRI-NIC when we need to.  If the local-host is one of the site resolvers, then
  ;; set up so that recursion is off.  Otherwise, if there are local-to-the-site
  ;; resolvers, but we're not one of them, set recursion on, and assume that
  ;; the resolver will deal with everything for us.
  ;;
  (cond ((memq *local-host* *domain-site-servers*)
	 (setq *domain-site-servers* nil)
	 (setq *domain-default-recursion-request* nil))
	(*domain-site-servers* 
	 (setq *domain-default-recursion-request* t))
	(t 
	 (setq *domain-default-recursion-request* nil))))

(defun initialize-domain-resolver ()
  (when (neq *domain-resolver-status* ':permanently-disabled)
    (rebuild-domain-site-server-list t)
    (rebuild-class-to-instance-alist)
    (setq *domain-resolver-reset* t		; leave this around for now...
	  *domain-resolver-on* nil
	  )
    (setq *domain-resolver-status* ':initialized)))

;;;
;;; This gets called by anyone who wants to ensure that the resolver is working
;;; and enabled in preparation for trying to find something out.  Sure, it's a kludge,
;;; but at this stage, I'm not trying for anything overly clever...
;;;
(defun domain-resolver-on-p ()
  (prog1
    (selectq *domain-resolver-status*
      ((:initialized nil)
       (reinitialize-domain-resolver))
      ((:enabled :disabled)
       ;;
       ;; if the host availability number has changed, rebuild the site-servers list.
       ;; we may end going from standalone mode to using a site server, or vice
       ;; versa because of this
       ;;
       (cond (( *domain-host-availability-boot-count* *host-availability-boot-count*)
	      (rebuild-domain-site-server-list)
	      (cond (*domain-site-servers* t)
		    (t (setq *domain-resolver-status* ':initialized) 
		       (reinitialize-domain-resolver))))
	     (t (memq *domain-resolver-status* '(:enabled :enabled-within-site)))))
      (:enabled-within-site t)			; we are a server with local stuff loaded
      (:permanently-disabled nil))
    (setq *domain-host-availability-boot-count* *host-availability-boot-count*)))
;
;(cl:defparameter *initial-domain-query-host-name* "INTERNET|SRI-NIC")
;
;(defun initialize-domain-resolver ()
;  (condition-case (error)
;       (progn
;	 (domain-query-host (si:parse-host *initial-domain-query-host-name*)
;			    () :name-server :internet)
;	 (setq *domain-resolver-on* t)
;	 (unless *domain-namespace* 
;	   (setq *domain-namespace* (update-object-permanently ':namespace () ':domain () t)
;		 *namespace-search-list* (append *namespace-search-list*
;						 (list *domain-namespace*)))))
;     (host-does-not-support-service		;no way to get there
;       (setq *domain-resolver-on* ()))))

(add-initialization "Initialize Domain Resolver" 
		    '(initialize-domain-resolver)
		    nil
		    'after-network-initialization-list)

(add-initialization "Initialize Domain Resolver" 
		    '(initialize-domain-resolver)
		    nil
		    'after-all-networks-initialization-list)

