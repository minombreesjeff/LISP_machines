;;; -*- Syntax: Zetalisp; Mode: LISP; Package: NETI; Base: 8 -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; Host objects:

;;; Host objects have two major uses.  One, they identify a "file
;;; computer" to use inside a pathname.  Two, they serve to canonicalize
;;; name and address mapping on networks.  A comment at the start of SYS:
;;; IO; PATHNM > describes in more detail the pathname parsing
;;; interaction with host objects.

;;; The flavor NET:BASIC-HOST is included in host objects of all types.
;;; The flavor NET:HOST is for hosts which actually correspond to a
;;; particular machine on some network (as opposed to a logical host in
;;; the pathname sense); they are objects in the network namespace database.
;;; The flavor NETI:PATHNAME-HOST-MIXIN should be mixed in with any host which
;;; is capable of supporting a file system.

;;; Interesting messages on all hosts
;;; :NAME - returns the whole name of the host
;;; :NAME-AS-FILE-COMPUTER - returns what should be printed before the : in pathnames
;;; :PATHNAME-HOST-NAMEP name - is name the name of this host before the : in a pathname?

;;; Interesting messages on network hosts
;;; :SHORT-NAME - returns the shortest nickname from the host table
;;; :SYSTEM-TYPE - returns the operating system type, a symbol in the keyword package, e.g.
;;;                :LISPM, :ITS, :TENEX, :TOPS-20, :UNIX, :VMS, :MINITS, :UNIX42
;;; :MACHINE-TYPE - returns the machine type, a symbol in the keyword package, e.g.
;;;		    :|3600|, :PDP10, :VAX, :PDP11
;;; :NETWORK-TYPEP network - is this host connected to network, a keyword, e.g. :CHAOS?
;;; :NETWORK-TYPE - returns the major network this host is connected to (i.e. prefers
;;;                :CHAOS)

;;; Relevant functions
;;; NET:PARSE-HOST thing - takes a string and returns a host object corresponding to the
;;;		          network host with that name.  NOT the function used with pathnames.
;;; NET:GET-HOST-FROM-ADDRESS address network - returns a host object for address on network.
;;;	E.g. (NET:GET-HOST-FROM-ADDRESS 17402 :CHAOS) => #<TENEX-HOST SCRC 66006351>.

;;; Base flavor, for network and special hosts.
(DEFFLAVOR BASIC-HOST () (PROPERTY-LIST-MIXIN)
  (:REQUIRED-METHODS :NAME)
  (:METHOD-COMBINATION :PATHNAME-HOST-NAMEP :OR
                       :PEEK-FILE-SYSTEM-P :OR
                       :PEEK-FILE-SYSTEM-HEADER (:LIST :MOST-SPECIFIC-LAST)
                       :PEEK-FILE-SYSTEM (:LIST :MOST-SPECIFIC-LAST)))

;;; STRING of a host is its name
(DEFMETHOD (:STRING-FOR-PRINTING BASIC-HOST) ()
  (STRING (SEND SELF ':NAME)))

(DEFMETHOD (:PRINT-SELF BASIC-HOST :DEFAULT) (STREAM IGNORE SLASHIFY-P)
  (IF SLASHIFY-P
      (SI:PRINTING-RANDOM-OBJECT (SELF STREAM :TYPEP :NO-POINTER)
	(PRINC SELF STREAM))
      (PRINC (SEND SELF ':NAME) STREAM)))

(DEFMETHOD (:SHORT-NAME BASIC-HOST) ()
  (SEND SELF ':NAME))

(DEFMETHOD (:LOCAL-NAME BASIC-HOST) ()
  (SEND SELF ':NAME))

(DEFMETHOD (:ATTRIBUTES BASIC-HOST) ()
  (GET (SEND SELF ':SYSTEM-TYPE) 'FS:ATTRIBUTES))

(DEFFLAVOR PATHNAME-HOST-MIXIN
	((PATHNAME-HASH-TABLE NIL)
	 (SAMPLE-PATHNAME NIL)
	 (LAST-NAME-AS-FILE-COMPUTER NIL))
	()
  (:REQUIRED-FLAVORS BASIC-HOST))

(DEFMETHOD (HOST-UNIX-VERSIONS-ENABLED PATHNAME-HOST-MIXIN)
	   (&KEY DIRECTORY)
  (DECLARE (IGNORE DIRECTORY))
  NIL)

(DEFMETHOD (:PATHNAME-HASH-TABLE-INITIAL-SIZE PATHNAME-HOST-MIXIN) ()
  200.)

;; PATHNAME-HOST-MAKE-PATHNAME is responsible for ensuring that its components
;; are in the pathname area.  Until this point, they may even be stack consed!
;; This is one of the only places which needs to fudge file version numbers when
;; VC pathname parsing is disabled, but we have to assume that the pathname GC
;; did its job right and really flushed all VC pathnames from the world.
(DEFMETHOD (NETI:PATHNAME-HOST-MAKE-PATHNAME PATHNAME-HOST-MIXIN)
	   (DEVICE DIRECTORY NAME TYPE VERSION OTHERS VC-BRANCH VC-VERSION)
  (MULTIPLE-VALUE-BIND (FLAVOR-NAME OPTIONS)
      (SEND SELF ':PATHNAME-FLAVOR)
    (LET ((VERSION (IF (OR FS:*VC-PATHNAME-PARSING-ENABLED*
			   (NULL (OR VC-BRANCH VC-VERSION)))
		       ;; If VC pathname parsing is enabled or if the pathname we 
		       ;; are about to create is not a VC pathname, just use the
		       ;; supplied version.
		       VERSION
		     ;; VC pathname parsing is disabled, but we have been asked to
		     ;; create a VC pathname.  Fudge the file version number, and
		     ;; flush the VC branch and version.
		     (PROG1
		       (FS:FLAT-VERSION-FROM-VC-VERSION-AND-VERSION VC-VERSION VERSION)
		       (SETQ VC-BRANCH NIL VC-VERSION NIL)))))
      (LEXPR-FUNCALL #'MAKE-INSTANCE
		     FLAVOR-NAME
		     :HOST       SELF
		     :DEVICE     (FS:COPY-INTO-PATHNAME-AREA DEVICE)
		     :DIRECTORY  (FS:COPY-INTO-PATHNAME-AREA DIRECTORY)
		     :NAME       (FS:COPY-INTO-PATHNAME-AREA NAME)
		     :TYPE       (FS:COPY-INTO-PATHNAME-AREA TYPE)
		     :VERSION    (FS:COPY-INTO-PATHNAME-AREA VERSION)
		     :VC-BRANCH  (FS:COPY-INTO-PATHNAME-AREA VC-BRANCH)
		     :VC-VERSION (FS:COPY-INTO-PATHNAME-AREA VC-VERSION)
		     :OTHER-COMPONENTS (FS:COPY-INTO-PATHNAME-AREA OTHERS)
		     OPTIONS)))) 

;; Compatibility stub
(DEFMETHOD (:MAKE-PATHNAME PATHNAME-HOST-MIXIN) (DEVICE DIRECTORY NAME TYPE VERSION OTHERS)
  (NETI:PATHNAME-HOST-MAKE-PATHNAME SELF DEVICE DIRECTORY NAME TYPE VERSION OTHERS NIL NIL))

(DEFMETHOD (:GET-PATHNAME PATHNAME-HOST-MIXIN) (DEV DIR NAM TYP VRS OTHERS)
  (PATHNAME-HOST-GET-PATHNAME SELF DEV DIR NAM TYP VRS OTHERS NIL NIL))

(DEFMETHOD (:MAYBE-DECACHE-NAME-AS-FILE-COMPUTER PATHNAME-HOST-MIXIN) ()
  (UNLESS (EQUAL LAST-NAME-AS-FILE-COMPUTER (SEND SELF ':NAME-AS-FILE-COMPUTER))
    (LET ((HT (SEND SELF ':PATHNAME-HASH-TABLE NIL)))
      (WHEN HT
	(SEND HT ':MAP-HASH #'(LAMBDA (IGNORE PATHNAME)
				(SEND PATHNAME ':DECACHE-HOST-NAME)))))
    (SETQ LAST-NAME-AS-FILE-COMPUTER (SEND SELF ':NAME-AS-FILE-COMPUTER))))

(DEFUN CHECK-PATHNAME-HOST-NAMES ()
  ;; Get rid of anything that isn't any good as a file computer any more.
  (SETQ FS:*PATHNAME-HOST-LIST*
	(DEL-IF #'(LAMBDA (HOST)
		    (NOT (OPERATION-HANDLED-P HOST ':MAYBE-DECACHE-NAME-AS-FILE-COMPUTER)))
		FS:*PATHNAME-HOST-LIST*))
  (DOLIST (HOST FS:*PATHNAME-HOST-LIST*)
    (SEND HOST ':MAYBE-DECACHE-NAME-AS-FILE-COMPUTER)))

(ADD-INITIALIZATION "Maybe decache pathname host names" '(CHECK-PATHNAME-HOST-NAMES)
		    NIL 'LOCAL-NAME-INITIALIZATION-LIST)

(DEFMETHOD (:CHANGE-OF-ATTRIBUTES PATHNAME-HOST-MIXIN) ()
  (SEND SELF ':MAYBE-DECACHE-NAME-AS-FILE-COMPUTER)
  (WHEN (AND SAMPLE-PATHNAME
	     (NEQ (TYPEP SAMPLE-PATHNAME) (SEND SELF :PATHNAME-FLAVOR)))
    ;; Trying to change the system type of a host that already has some pathnames
    ;; interned, in such a way that the old pathnames are the wrong flavor now.
    ;; I guess the only thing that is likely to work at all is to discard the pathnames.
    ;; Otherwise the problems noted below (see "NOTE WELL:") might occur.
    ;; Should this really be an FSIGNAL?
    (NAMESPACE-WARNING "Interned pathnames on host ~A are being forgotten because the
pathname flavor for this host has changed from ~S to ~S.
This may cause problems when accessing files on this host."
		       SELF (TYPEP SAMPLE-PATHNAME) (SEND SELF :PATHNAME-FLAVOR))
    (SETQ PATHNAME-HASH-TABLE NIL
	  SAMPLE-PATHNAME NIL)
    (SETF FS:*PATHNAME-HOST-LIST* (DELQ SELF FS:*PATHNAME-HOST-LIST*))))

(DEFMETHOD (:COPY-OBJECT PATHNAME-HOST-MIXIN) (NEW-OBJECT)
  (IGNORE NEW-OBJECT)
  (WHEN (AND PATHNAME-HASH-TABLE
	     (NOT (ZEROP (SEND PATHNAME-HASH-TABLE :FILLED-ELEMENTS))))
    ;; Should this really be an FSIGNAL?
    ;; Or should it really try to copy the two instance variables into NEW-OBJECT,
    ;; if the pathname flavor isn't being changed?
    (NAMESPACE-WARNING "Interned pathnames on host ~A are being forgotten because of
an incompatible change in the host's attributes.
This may cause problems when accessing files on this host."
		       SELF)
    (SETF FS:*PATHNAME-HOST-LIST* (DELQ SELF FS:*PATHNAME-HOST-LIST*))))

;;; NOTE WELL:  The use of these modified-:GET-PATHNAME mixins with a host
;;; must correspond exactly with the use of the corresponding mixins with
;;; that host's flavor of pathnames, or a lot of non-obvious problems will
;;; occur, especially large amounts of extra consing in pathname-area.

(DEFFLAVOR NO-DEVICE-HOST-MIXIN () ())

(DEFMETHOD (:GET-PATHNAME NO-DEVICE-HOST-MIXIN) (DEV DIR NAM TYP VRS OTHERS)
  (PATHNAME-HOST-GET-PATHNAME SELF DEV DIR NAM TYP VRS OTHERS NIL NIL))

(DEFFLAVOR NO-VERSION-HOST-MIXIN () ())

(DEFMETHOD (:GET-PATHNAME NO-VERSION-HOST-MIXIN) (DEV DIR NAM TYP VRS OTHERS)
  (PATHNAME-HOST-GET-PATHNAME SELF DEV DIR NAM TYP VRS OTHERS NIL NIL))

(DEFFLAVOR NO-TYPE-HOST-MIXIN () ())

(DEFMETHOD (:GET-PATHNAME NO-TYPE-HOST-MIXIN) (DEV DIR NAM TYP VRS OTHERS)
  (PATHNAME-HOST-GET-PATHNAME SELF DEV DIR NAM TYP VRS OTHERS NIL NIL))

(DEFFLAVOR NO-DEVICE-OR-VERSION-HOST-MIXIN () ())

(DEFMETHOD (:GET-PATHNAME NO-DEVICE-OR-VERSION-HOST-MIXIN) (DEV DIR NAM TYP OTHERS VRS)
  (PATHNAME-HOST-GET-PATHNAME SELF DEV DIR NAM TYP VRS OTHERS NIL NIL))

(DEFFLAVOR NO-DIRECTORY-OR-VERSION-HOST-MIXIN () ())

(DEFMETHOD (:GET-PATHNAME NO-DIRECTORY-OR-VERSION-HOST-MIXIN) (DEV DIR NAM TYP OTHERS VRS)
  (PATHNAME-HOST-GET-PATHNAME SELF DEV DIR NAM TYP VRS OTHERS NIL NIL))

(DEFFLAVOR NO-DEVICE-OR-TYPE-OR-VERSION-HOST-MIXIN () ())

(DEFMETHOD (:GET-PATHNAME NO-DEVICE-OR-TYPE-OR-VERSION-HOST-MIXIN)
	   (DEV DIR NAM TYP OTHERS VRS)
  (PATHNAME-HOST-GET-PATHNAME SELF DEV DIR NAM TYP VRS OTHERS NIL NIL))

(DEFMETHOD (:PEEK-FILE-SYSTEM-HEADER PATHNAME-HOST-MIXIN :DEFAULT) ()
  NIL)

(DEFMETHOD (:PEEK-FILE-SYSTEM PATHNAME-HOST-MIXIN :DEFAULT) ()
  NIL)

(DEFMETHOD (:PEEK-FILE-SYSTEM-P PATHNAME-HOST-MIXIN :DEFAULT) ()
  NIL)

(DEFMETHOD (:NAME-AS-FILE-COMPUTER PATHNAME-HOST-MIXIN :DEFAULT) ()
  (SEND SELF ':SHORT-NAME))

(DEFMETHOD (:PATHNAME-HOST-NAMEP PATHNAME-HOST-MIXIN :DEFAULT) (NAME)
  (STRING-EQUAL NAME (SEND SELF ':NAME)))

(DEFMETHOD (:OPEN-STREAMS PATHNAME-HOST-MIXIN :DEFAULT) () NIL)

(DEFMETHOD (:CLOSE-ALL-FILES PATHNAME-HOST-MIXIN) (&KEY (MODE :ABORT)
							(QUERY-EACH NIL)
							(VERBOSE T))
  (LOOP FOR STREAM IN (SEND SELF ':OPEN-STREAMS)
	NCONC (SI:CLOSE-OPEN-FILE STREAM :MODE MODE :QUERY QUERY-EACH :VERBOSE VERBOSE)))

(DEFUN PATHNAME-KEY-HASH-FUNCTION (KEY)
  (DECLARE LT:(SIDE-EFFECTS READER REDUCIBLE))
  (FLET ((MALFORMED-KEY-ERROR (ATOM)
	   (ERROR "Pathname hash key ~S was dotted with final CDR ~S."
		  (CL:COPY-LIST KEY)
		  ATOM)))
    (IF (NULL KEY)
	0
	(CLI::MAP-LIST-ACCUMULATING-HASH (KEY K :IGNORE-GC T :ATOM-HASH MALFORMED-KEY-ERROR)
	  (CL:TYPECASE K
	    (NULL 11)
	    (CL:CONS (PATHNAME-KEY-HASH-FUNCTION K))
	    D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");;use arrayp to find strings, it's cheaper.
0	    (CL:ARRAY (SYS:SXHASH-STRING K))
	    (CL:NUMBER (CLI::NUMBER-EQL-HASH K))
	    (CL:SYMBOL
	      (CL:CASE K
		(:ROOT 52525252)
		(:NEWEST 3007)
		(:OLDEST 10021)
		(:WILD 606060)
		(:UNSPECIFIC 4444)
		(:RELATIVE 332291)
		(:UP 8765)
		(:WILD-INFERIORS 34343434)
		(OTHERWISE 11)))
	    (T 7654321))))))

(DEFUN CASE-INSENSITIVE-PATHNAME-HASH-TEST-FUNCTION (X Y)
  (DECLARE LT:(SIDE-EFFECTS READER REDUCIBLE))
  (COND ((EQL X Y)				1;catch NIL case
0	 (RETURN-FROM CASE-INSENSITIVE-PATHNAME-HASH-TEST-FUNCTION T))
	((NOT (= (SYS:%DATA-TYPE X) (SYS:%DATA-TYPE Y)))
	 (RETURN-FROM CASE-INSENSITIVE-PATHNAME-HASH-TEST-FUNCTION NIL))
	((CL:CONSP X)
	 (LOOP AS TX = (CAR X)
	       AS TY = (CAR Y)
	       DO
	   (UNLESS (AND (= (SYS:%DATA-TYPE TX) (SYS:%DATA-TYPE TY))
			(OR (EQL TX TY)
			    (AND (CL:CONSP TX)
				 (CASE-INSENSITIVE-PATHNAME-HASH-TEST-FUNCTION TX TY))
			    (AND (ARRAYP TX) ; stringp, only cheaper.
				 (LET ((LENX (ARRAY-ACTIVE-LENGTH TX)))
				   (AND (= LENX (ARRAY-ACTIVE-LENGTH TY))
					(SYS:%STRING-EQUAL TX 0 TY 0 LENX))))))
	     (RETURN-FROM CASE-INSENSITIVE-PATHNAME-HASH-TEST-FUNCTION NIL))
	   (SETQ X (CDR X) Y (CDR Y))
	   (UNLESS (OR X Y)
	     (RETURN-FROM CASE-INSENSITIVE-PATHNAME-HASH-TEST-FUNCTION T))
	   (UNLESS (AND (CL:CONSP X) (CL:CONSP Y))
	     (RETURN-FROM CASE-INSENSITIVE-PATHNAME-HASH-TEST-FUNCTION NIL))
	   ))
	(T (RETURN-FROM CASE-INSENSITIVE-PATHNAME-HASH-TEST-FUNCTION NIL))))

(DEFMETHOD (MAKE-PATHNAME-HASH-TABLE PATHNAME-HOST-MIXIN) (&KEY SIZE)
  (CL:MAKE-HASH-TABLE :TEST #'CASE-INSENSITIVE-PATHNAME-HASH-TEST-FUNCTION
		      :HASH-FUNCTION #'PATHNAME-KEY-HASH-FUNCTION
		      :STORE-HASH-CODE T
		      :IGNORE-GC T
		      :AREA FS:PATHNAME-AREA
		      :GROWTH-THRESHOLD .67
		      :SIZE (OR SIZE (SEND SELF :PATHNAME-HASH-TABLE-INITIAL-SIZE))))

(DEFMETHOD (:PATHNAME-HASH-TABLE PATHNAME-HOST-MIXIN) (&OPTIONAL (CREATE-P T)
								 FORCE-CREATE
								 INITIAL-SIZE)
  (OR (AND (NOT FORCE-CREATE) PATHNAME-HASH-TABLE)
      (AND (OR FORCE-CREATE CREATE-P)
	   (SETQ PATHNAME-HASH-TABLE (MAKE-PATHNAME-HASH-TABLE SELF :SIZE INITIAL-SIZE))))) 

(DEFMETHOD (:SAMPLE-PATHNAME PATHNAME-HOST-MIXIN) ()
  (OR SAMPLE-PATHNAME
      (WITHOUT-INTERRUPTS
	(SETQ SAMPLE-PATHNAME (NETI:PATHNAME-HOST-GET-PATHNAME
				SELF
				 NIL NIL NIL NIL NIL NIL NIL NIL))
	(SETQ SAMPLE-PATHNAME
	      (NETI:PATHNAME-HOST-GET-PATHNAME SELF
		    (SEND SAMPLE-PATHNAME :VALID-DEVICE
			  (SEND SAMPLE-PATHNAME :UNCASE-DEVICE "DEV"))
		    (SEND SAMPLE-PATHNAME :VALID-DIRECTORY
			  (SEND SAMPLE-PATHNAME :UNCASE-DIRECTORY '("FOO")))
		    (SEND SAMPLE-PATHNAME :VALID-NAME
			  (SEND SAMPLE-PATHNAME :UNCASE-NAME "FOO"))
		    (SEND SAMPLE-PATHNAME :VALID-TYPE	;In case someone screws up
			  (SEND SAMPLE-PATHNAME :UNCASE-TYPE
				(FIRST (SEND SAMPLE-PATHNAME
					     :TYPES-FOR-CANONICAL-TYPE :LISP))))
		    (SEND SAMPLE-PATHNAME :VALID-VERSION :NEWEST)
		    NIL
		    NIL				;no vc by default
		    NIL				;ditto.
		    ))))) 

(DEFFLAVOR NO-DIRECTORY-HOST-MIXIN () ())

;;; These are hosts of the host table sort
(DEFFLAVOR HOST
	(ADDRESSES
	 SYSTEM-TYPE
	 (AVAILABILITY NIL))
	(BASIC-HOST OWN-FLAVOR-OBJECT)
  ;; :SYSTEM-TYPE would work normally, but this cache provides some pathname speedup.
  (:GETTABLE-INSTANCE-VARIABLES SYSTEM-TYPE)
  (:METHOD-COMBINATION :PROTOCOL-DESIRABILITY :CASE))

(DEFMETHOD (:CHANGE-OF-ATTRIBUTES HOST) ()
  (SETQ ADDRESSES (COPYLIST (LOOP FOR (NET STRING) IN (CL:GETF FLAVOR:PROPERTY-LIST ':ADDRESS)
				  COLLECT (LIST NET (SEND NET ':PARSE-ADDRESS STRING)))))
  (SETQ SYSTEM-TYPE (CL:GETF FLAVOR:PROPERTY-LIST ':SYSTEM-TYPE))
  (DECACHE-HOST-PERIPHERALS SELF)
  (UPDATE-HOST-TO-ADDRESS-TABLES SELF)
  (WHEN (NS-EQ SELF *LOCAL-HOST*)
    ;; Check for site changing, update pretty names, hardcopy devices, etc.
    (INITIALIZATIONS 'LOCAL-NAME-INITIALIZATION-LIST T)))


(DEFUN UPDATE-LOCAL-HOST-NETWORKS ()
  ;; Reconstitute the local network list.
  (LET ((NEW-NETWORKS (SI:ELIMINATE-DUPLICATES
			(MAPCAR #'FIRST (SEND *LOCAL-HOST* :ADDRESS)))))
    (WHEN (AND (VARIABLE-BOUNDP SI:*FBAND-NETWORK*)
	       (CL:MEMBER :CHAOS NEW-NETWORKS
			  :KEY (LAMBDA (NET) (SEND NET :TYPE))))
      (SETF NEW-NETWORKS (NCONC NEW-NETWORKS (NCONS SI:*FBAND-NETWORK*))))
    (WHEN (VARIABLE-BOUNDP *SLAP-NETWORK*)
      (SI:PUSH* *SLAP-NETWORK* NEW-NETWORKS))
    (LOOP FOR OLD-NET IN *LOCAL-NETWORKS*
	  WHEN (NOT (MEMQ OLD-NET NEW-NETWORKS))
	    DO (SEND OLD-NET :RESET))
    (SETF *LOCAL-NETWORKS* (COPYLIST NEW-NETWORKS)))
  ;; Make sure any new networks are enabled.
  (WHEN *NETWORK-ENABLED*
    (LOOP FOR NETWORK IN *LOCAL-NETWORKS*
	  WHEN (OR (EQ *NETWORK-ENABLED* T)
		   (EQ NETWORK *PRIMARY-NETWORK*))
	  DO (SEND NETWORK :ENABLE))))

(ADD-INITIALIZATION "Update Local Networks" '(UPDATE-LOCAL-HOST-NETWORKS) ()
		    'LOCAL-NAME-INITIALIZATION-LIST)

;;; This is called by the update encacher, make sure that our namespaces know that
;;; we are at this address.  Saves a server query for this information later.
(DEFMETHOD (:INFORM-NAMESPACE-OF-ADDRESSES HOST) (NAMESPACE CLASS-OBJ)
  (WITH-STACK-LIST (HOSTS SELF)
    (LET ((HOSTS (IF (LOOP FOR NAME IN NAMES
			   THEREIS (AND (TYPEP NAME 'NAME)
					(EQ (SEND NAME ':NAMESPACE) NAMESPACE)))
		     HOSTS NIL)))
      (LOOP FOR ADDRESS IN (CL:GETF FLAVOR:PROPERTY-LIST ':ADDRESS)
	    DO (WITH-STACK-LIST (ADDRESS-LIST ADDRESS)
		 (WITH-STACK-LIST (PROPERTY-LIST ':ADDRESS ADDRESS-LIST)
		   (SEND NAMESPACE ':MAKE-OBJECT-PROPERTY-LIST-ENTRY-VALID
			 CLASS-OBJ PROPERTY-LIST HOSTS)))))))

(DEFMETHOD (:HOST-NAMES HOST) () NAMES)

(DEFMETHOD (:NAME-AS-FILE-COMPUTER HOST) ()
  (BLOCK TOP
    (LET ((NAME (SEND SELF ':SHORT-NAME)))
      ;; This is the best candidate, unless it is shadowed by a logical host
      (UNLESS (LOOP FOR HOST IN FS:*LOGICAL-PATHNAME-HOST-LIST*
		    THEREIS (EQUAL (SEND HOST ':NAME) NAME))
	(RETURN-FROM TOP NAME))
      ;; If uninterned, hope for the best
      (WHEN (SEND SELF ':UNINTERNED-P)
	(RETURN-FROM TOP NAME))
      ;; Find an unshadowed nickname
      (DOLIST (NAME NAMES)
	(LET ((STRING (SEND NAME ':STRING)))
	  (UNLESS (LOOP FOR HOST IN FS:*LOGICAL-PATHNAME-HOST-LIST*
			THEREIS (EQUAL (SEND HOST ':NAME) STRING))
	    (UNLESS (SEND NAME ':SHADOWED-P CLASS)
	      (RETURN-FROM TOP STRING)))))
      ;; Use a name with a | in it
      (SEND (OR (FIRST (SEND SELF ':GET ':SHORT-NAME))
		(SEND SELF ':PRIMARY-NAME))
	    ':QUALIFIED-STRING T))))

(DEFMETHOD (:PATHNAME-HOST-NAMEP HOST) (NAME)
  ;; Allow |'s even if they wouldn't appear in output.  But don't make qualified names
  ;; when we don't need them.
  (IF (SEND SELF ':UNINTERNED-P)
      (MEM #'STRING-EQUAL NAME NAMES)
    (LOOP WITH BAR-P = (%STRING-SEARCH-CHAR #/| NAME 0 (STRING-LENGTH NAME))
	  FOR MY-NAME IN NAMES
	  THEREIS (IF BAR-P
		      (STRING-EQUAL NAME (SEND MY-NAME ':QUALIFIED-STRING))
		      (AND (STRING-EQUAL NAME (SEND MY-NAME ':STRING))
			   (NOT (SEND MY-NAME ':SHADOWED-P CLASS)))))))

;;; All these -NAME messages can use obsolete information, since otherwise debugging is
;;; very difficult when the name server is down.
(DEFMETHOD (:NAME HOST) (&AUX (*INHIBIT-VALIDITY-CHECKING* T))
  (IF (SEND SELF ':UNINTERNED-P)
      (STRING (FIRST NAMES))
      (SEND SELF :PRIMARY-NAME-STRING)))

(DEFMETHOD (:SHORT-NAME HOST) (&AUX (*INHIBIT-VALIDITY-CHECKING* T))
  (IF (SEND SELF ':UNINTERNED-P)
      (STRING (FIRST NAMES))
    ;; SHORT-NAMES are usable here for output.  NICKNAMES are not.  Pick the first one
    ;; that isn't shadowed, else the first one period.
    (LOOP NAMED TOP
	  AS FIRST-P = T THEN NIL
	  DO (LOOP FOR NAME IN (SEND SELF ':GET ':SHORT-NAME)
		   DO (COND ((NOT (SEND NAME ':SHADOWED-P CLASS))
			     (RETURN-FROM TOP (SEND NAME ':STRING)))
			    ((NOT FIRST-P)
			     (RETURN-FROM TOP (SEND NAME ':QUALIFIED-STRING T)))))
	     (LET ((NAME (SEND SELF ':PRIMARY-NAME)))
	       (COND ((NOT (SEND NAME ':SHADOWED-P CLASS))
		      (RETURN (SEND NAME ':STRING)))
		     ((NOT FIRST-P)
		      (RETURN (SEND NAME ':QUALIFIED-STRING T)))))
	     (WHEN (NOT FIRST-P)
	       (FERROR "Fell off the end, ~S doesn't have a name." SELF)))))

(DEFMETHOD (:PRETTY-NAME HOST) (&AUX (*INHIBIT-VALIDITY-CHECKING* T))
  (OR (SEND SELF ':GET ':PRETTY-NAME)
      (SEND SELF ':NAME)))

(DEFUN HOST-SHORT-NAME (HOST)
  (SEND (PARSE-HOST HOST) ':SHORT-NAME))

(DEFUN HOST-SYSTEM-TYPE (HOST)
  (SEND (PARSE-HOST HOST) ':SYSTEM-TYPE))

(DEFUN HOST-MACHINE-TYPE (HOST)
  (SEND (PARSE-HOST HOST) ':MACHINE-TYPE))

(DEFMETHOD (:NETWORK-TYPE HOST) ()
  (SEND (CAAR ADDRESSES) ':TYPE))

(DEFMETHOD (:NETWORK-TYPEP HOST) (TYPE)
  (LOOP FOR (NETWORK) IN ADDRESSES
	THEREIS (EQ TYPE (SEND NETWORK ':TYPE))))

(DEFMETHOD (:NETWORK-ADDRESSES HOST) () ADDRESSES)

(DEFMETHOD (:NETWORK-SERVICES HOST) ()
  (SEND SELF ':GET ':SERVICE))

;;;; Desirability and availability stuff

(DEFMETHOD (:PROTOCOL-DESIRABILITY HOST :OTHERWISE) (IGNORE) 1)

;;; Availability scheme.

;;; Function called with format args when state changes occur.
;;; A good one is '(LAMBDA (&REST ARGS) (LEXPR-FUNCALL #'TV:NOTIFY NIL ARGS)).
(DEFVAR *HOST-AVAILABILITY-LOG-FUNCTION* NIL)

(DEFVAR *HOST-AVAILABILITY-BOOT-COUNT* 0)

(DEFUN RESET-ALL-HOST-AVAILABILITIES ()
  (INCF *HOST-AVAILABILITY-BOOT-COUNT*))

(ADD-INITIALIZATION "Reset host availabilities" '(RESET-ALL-HOST-AVAILABILITIES)
		    '(:SYSTEM-SHUTDOWN))

;;; AVAILABILITY instance variables are this format.
(DEFSTRUCT (HOST-AVAILABILITY (:TYPE :LIST) :CONC-NAME)
  (BOOT-COUNT *HOST-AVAILABILITY-BOOT-COUNT*)	;Value when this was valid
  SERVER-UNAVAILABLE	;One entry
  NETWORK-DOWN		;Alist of NETWORK . entry
  SERVICE-FAILING	;Alist of SERVICE-NAME . entry
  )

;;; All entries above are this format.
(DEFSTRUCT (HOST-AVAILABILITY-SUBENTRY (:TYPE :LIST) :CONC-NAME)
  TIME			;Timestamp of this failure or :PERMANENTLY
  STATE			;T = losing, NIL = ok.
  )

(DEFMETHOD (:AVAILABLE HOST) (&KEY NETWORK SERVICE)
  (OR (LOCAL-HOST-P SELF)
      (WITHOUT-INTERRUPTS
	(WHEN (AND AVAILABILITY
		   ( (HOST-AVAILABILITY-BOOT-COUNT AVAILABILITY)
		      *HOST-AVAILABILITY-BOOT-COUNT*))
	  (SETQ AVAILABILITY NIL))  
	(LET ((LOSING-SUBENTRY NIL))
	  (WHEN AVAILABILITY
	    (SETF LOSING-SUBENTRY
		  (MERGE-HOST-AVAILABILITY
		    (HOST-AVAILABILITY-SERVER-UNAVAILABLE AVAILABILITY)
		    (CDR (ASSQ SERVICE (HOST-AVAILABILITY-SERVICE-FAILING AVAILABILITY)))))
	    (LOOP FOR ENTRY IN (HOST-AVAILABILITY-NETWORK-DOWN AVAILABILITY)
		  WHEN (OR (EQ (CAR ENTRY) NETWORK) (NULL NETWORK))
		    DO (SETF LOSING-SUBENTRY (MERGE-HOST-AVAILABILITY LOSING-SUBENTRY
								      (CDR ENTRY)))))
	  (WHEN LOSING-SUBENTRY
	    (UNLESS (HOST-AVAILABILITY-SUBENTRY-STATE LOSING-SUBENTRY)
	      (SETF LOSING-SUBENTRY NIL)))
	  (IF LOSING-SUBENTRY
	      (VALUES NIL (HOST-AVAILABILITY-SUBENTRY-TIME LOSING-SUBENTRY))
	      T)))))

(DEFUN MERGE-HOST-AVAILABILITY (SUBENTRY-1 SUBENTRY-2)
  (COND ((NULL SUBENTRY-1) SUBENTRY-2)
	((NULL SUBENTRY-2) SUBENTRY-1)
	((NEQ (HOST-AVAILABILITY-SUBENTRY-STATE SUBENTRY-1)
	      (HOST-AVAILABILITY-SUBENTRY-STATE SUBENTRY-1))
	 (IF (HOST-AVAILABILITY-SUBENTRY-STATE SUBENTRY-1)
	     SUBENTRY-1
	   SUBENTRY-2))
	((SYMBOLP (HOST-AVAILABILITY-SUBENTRY-TIME SUBENTRY-1)) SUBENTRY-1)
	((SYMBOLP (HOST-AVAILABILITY-SUBENTRY-TIME SUBENTRY-2)) SUBENTRY-2)
	((TIME-LESSP (HOST-AVAILABILITY-SUBENTRY-TIME SUBENTRY-1)
		     (HOST-AVAILABILITY-SUBENTRY-TIME SUBENTRY-2))
	 SUBENTRY-2)
	(T SUBENTRY-1)))

(DEFMETHOD (:AVAILABILITY HOST) (&REST ARGS)
  (MULTIPLE-VALUE-BIND (AVAILABLE TIME)
      (LEXPR-SEND SELF ':AVAILABLE ARGS)
    (COND (AVAILABLE 1)
	  ((EQ TIME ':PERMANENTLY) 0)
	  (T (LET ((DIFF (TIME-DIFFERENCE (TIME) TIME)))
	       ;; Logarithmic time since failure:
	       ;;  1 min is 0.2, 15 mins is 0.6, 1 hr is 0.8, 4 hours is 1.0
	       (* (MAX (MIN (- (HAULONG DIFF) 10.) 10.) 0) 0.1))))))

(DEFMETHOD (:SET-AVAILABLE HOST) (&KEY SERVER NETWORK SERVICE
				       &AUX LOG-SERVER LOG-NETWORK LOG-SERVICE)
  (WITHOUT-INTERRUPTS
    (WHEN (AND AVAILABILITY
	       ( (HOST-AVAILABILITY-BOOT-COUNT AVAILABILITY)
		  *HOST-AVAILABILITY-BOOT-COUNT*))
      (SETQ AVAILABILITY NIL))  
    (UNLESS (NULL AVAILABILITY)
      (WHEN SERVER
	(LET ((LOSING-ENTRY (HOST-AVAILABILITY-SERVER-UNAVAILABLE AVAILABILITY)))
	  (WHEN (AND LOSING-ENTRY (HOST-AVAILABILITY-SUBENTRY-STATE LOSING-ENTRY))
	    (SETQ LOG-SERVER T)
	    (SETF (HOST-AVAILABILITY-SUBENTRY-STATE LOSING-ENTRY) NIL))))
      (WHEN NETWORK
	(LET ((LOSING-ENTRY (CDR (ASSQ NETWORK
				       (HOST-AVAILABILITY-NETWORK-DOWN AVAILABILITY)))))
	  (WHEN (AND LOSING-ENTRY (HOST-AVAILABILITY-SUBENTRY-STATE LOSING-ENTRY))
	    (SETQ LOG-NETWORK T)
	    (SETF (HOST-AVAILABILITY-SUBENTRY-STATE LOSING-ENTRY) NIL))))
      (WHEN SERVICE
	(LET ((LOSING-ENTRY (CDR (ASSQ SERVICE
				       (HOST-AVAILABILITY-SERVICE-FAILING AVAILABILITY)))))
	  (WHEN (AND LOSING-ENTRY (HOST-AVAILABILITY-SUBENTRY-STATE LOSING-ENTRY))
	    (SETQ LOG-SERVICE T)
	    (SETF (HOST-AVAILABILITY-SUBENTRY-STATE LOSING-ENTRY) NIL))))))
  ;; small kludge here to unencache the namespace s-a-p when new servers turn up.
  (WHEN (OR LOG-SERVER
	    (AND LOG-SERVICE (MEMQ SERVICE '(:NAMESPACE-TIMESTAMP :NAMESPACE))))
    (LOOP FOR NAMESPACE IN
	      (LET ((*INHIBIT-VALIDITY-CHECKING* T))
		(FIND-OBJECTS-FROM-PROPERTY-LIST :NAMESPACE))
	  1;; Don't check namespaces that have no real namespace servers0 1or are uninterned
0	  AS NAME = (UNLESS (SEND NAMESPACE :UNINTERNED-P) (SEND NAMESPACE :NAME))
	  WHEN (AND NAME
		    (NOT (MEMQ NAME '(:DIAL :DOMAIN :DISTRIBUTION)))
		    (OR (MEMQ SELF (SEND NAMESPACE :GET ':PRIMARY-NAME-SERVER))
			(MEMQ SELF (SEND NAMESPACE :GET ':SECONDARY-NAME-SERVER))))
	    DO (RESET-NAMESPACE-SERVER-ACCESS-PATH NAMESPACE)))
  (WHEN *HOST-AVAILABILITY-LOG-FUNCTION*
    (WHEN LOG-SERVER
      (FUNCALL *HOST-AVAILABILITY-LOG-FUNCTION* "~A is now available as a server." SELF))
    (WHEN LOG-NETWORK
      (FUNCALL *HOST-AVAILABILITY-LOG-FUNCTION* "~A is now available on the ~A network."
	       SELF NETWORK))
    (WHEN LOG-SERVICE
      (FUNCALL *HOST-AVAILABILITY-LOG-FUNCTION* "~A is now available as a ~A server."
	       SELF SERVICE))))

(DEFMETHOD (:SET-UNAVAILABLE HOST) (HOW &OPTIONAL HOW-ARG &KEY PERMANENTLY REASON)
  (LET (LOSING-ENTRY FORMAT-STRING)
    (WHEN
      (WITHOUT-INTERRUPTS
	(UNLESS (AND AVAILABILITY
		     (= (HOST-AVAILABILITY-BOOT-COUNT AVAILABILITY)
			*HOST-AVAILABILITY-BOOT-COUNT*))
	  (SETQ AVAILABILITY (MAKE-HOST-AVAILABILITY)))
	(SELECTQ HOW
	  (:SERVER
	   (SETQ FORMAT-STRING "as a server")
	   (LET ((TEM (HOST-AVAILABILITY-SERVER-UNAVAILABLE AVAILABILITY)))
	     (WHEN (NULL TEM)
	       (SETQ TEM (MAKE-HOST-AVAILABILITY-SUBENTRY))
	       (SETF (HOST-AVAILABILITY-SERVER-UNAVAILABLE AVAILABILITY) TEM))
	     (SETQ LOSING-ENTRY TEM)))
	  (:NETWORK
	   (SETQ FORMAT-STRING "on the ~A network")
	   (LET ((TEM (ASSQ HOW-ARG
			    (HOST-AVAILABILITY-NETWORK-DOWN AVAILABILITY))))
	     (WHEN (NULL TEM)
	       (SETQ TEM (LIST HOW-ARG NIL NIL))
	       (PUSH TEM (HOST-AVAILABILITY-NETWORK-DOWN AVAILABILITY)))
	     (SETQ LOSING-ENTRY (CDR TEM))))
	  (:SERVICE
	   (SETQ FORMAT-STRING "as a ~A server")
	   (LET ((TEM (ASSQ HOW-ARG
			    (HOST-AVAILABILITY-SERVICE-FAILING AVAILABILITY))))
	     (WHEN (NULL TEM)
	       (SETQ TEM (LIST HOW-ARG NIL NIL))
	       (PUSH TEM (HOST-AVAILABILITY-SERVICE-FAILING AVAILABILITY)))
	     (SETQ LOSING-ENTRY (CDR TEM))))
	  (OTHERWISE
	   (FERROR "Unknown availability type: ~S" HOW)))
	(PROG1
	  ;; If it's a state change.
	  (NOT (HOST-AVAILABILITY-SUBENTRY-STATE LOSING-ENTRY))
	  (SETF (HOST-AVAILABILITY-SUBENTRY-STATE LOSING-ENTRY)
		(IF PERMANENTLY ':PERMANENTLY T))
	  (SETF (HOST-AVAILABILITY-SUBENTRY-TIME LOSING-ENTRY) (TIME))))
      (WHEN *HOST-AVAILABILITY-LOG-FUNCTION*
	(WITH-STACK-LIST (ARGS HOW-ARG)
	  (FUNCALL *HOST-AVAILABILITY-LOG-FUNCTION*
		   "~A is now unavailable ~1{~:}~@[:~%~2X~~A~~]."
		   SELF FORMAT-STRING ARGS REASON))))))

(DEFUN HOST-NETWORK-TYPE (HOST)
  (SEND (PARSE-HOST HOST) ':NETWORK-TYPE))

(DEFUN HOST-NETWORK-TYPEP (HOST TYPE)
  (SEND (PARSE-HOST HOST) ':NETWORK-TYPEP TYPE))

(DEFUN HOST-NETWORK-ADDRESSES (HOST)
  (SEND (PARSE-HOST HOST) ':NETWORK-ADDRESSES))

(DEFINE-NAMESPACE-CLASS-OBJECT-FLAVOR-FUNCTION :HOST NET:HOST (PLIST)
  (CL:GET (CL:GETF PLIST :SYSTEM-TYPE) 'HOST-TYPE-FLAVOR 'RANDOM-HOST))


(DEFVAR *ALLOW-DOTTED-HOST-NAMES-IN-NAMESPACES* NIL
  "Allow searches for host objects with dots in their names")

(DEFVAR *HEURISTICATE-PARTIAL-DOMAIN-NAMES* NIL
  "Allow searches for domain names with common tail omitted")

;;; 
;;; The third arg here, which used to be IGNORE, and before that ALLOW-UNKNOWN
;;; has been resurrected to help deal with the case of parsing hosts that aren't known
;;; and aren't quickly accessable.  When t, parse-domain-host will ask the domain
;;; resolver if necessary.
;;;
(DEFUN PARSE-HOST (HOST &OPTIONAL NO-ERROR-P (ASK-RESOLVER-IF-NECESSARY 
					       (NOT *INHIBIT-VALIDITY-CHECKING*))
		   &AUX (VALID-P T) EMB-HOST EMB-HOST-VALID-P)
  (DECLARE (VALUES HOST VALID-P))
  (FLET ((ERROR-OR-RETURN-VALUES (HOST-ERROR)
	   (UNLESS NO-ERROR-P 
	     (ERROR
	       'UNKNOWN-HOST-NAME
	       :NAME HOST :VALID-P (SEND HOST-ERROR :VALID-P)))
	   (VALUES NIL (SEND HOST-ERROR :VALID-P))))
    (COND ((CL:EQUALP HOST "LOCAL") 
	   (VALUES NET:*LOCAL-HOST* T))
	  ;; HOST for embedded machines that know their emb host
	  #+IMach
	  ((AND (CL:EQUALP HOST "HOST") (BOUNDP '*EMB-HOST*))
	   (VALUES *EMB-HOST* T))
	  ;; <guest>|HOST for embedded machines with an EMBEDDED-IN Namespace user property
	  ((LET ((LENGTH (STRING-LENGTH HOST)))
	     (WHEN (AND (> LENGTH 5)
			(CL:STRING-EQUAL HOST "|HOST" :START1 (- LENGTH 5)))
	       (CL:MULTIPLE-VALUE-SETQ (EMB-HOST EMB-HOST-VALID-P)
		 (PARSE-HOST (SUBSTRING HOST 0 (- LENGTH 5)) T
			     ASK-RESOLVER-IF-NECESSARY))
	       (WHEN EMB-HOST
		 (SEND EMB-HOST :USER-GET :EMBEDDED-IN))))
	   (MULTIPLE-VALUE-BIND (HOST VALID-P)
	       (PARSE-HOST (SEND EMB-HOST :USER-GET :EMBEDDED-IN) NO-ERROR-P
		       ASK-RESOLVER-IF-NECESSARY)
	     (VALUES HOST (AND VALID-P EMB-HOST-VALID-P))))
	  (T
	   (CONDITION-CASE-IF NO-ERROR-P ()
		(COLLECTING-NAMESPACE-ERRORS-IF (NOT NO-ERROR-P)
		  (ARGUMENT-TYPECASE HOST
		    (:STRING
		      (SETQ HOST (STRING HOST))
		      (LET ((BAR-IDX (STRING-REVERSE-SEARCH-CHAR #/| HOST))
			    (DOT-IDX (STRING-SEARCH-CHAR #/. HOST)))
			(COND 
			  ;;
			  ;; this clause is here for places like MIT who want to have
			  ;; dotted host names in their namespaces.
			  ;; Do this search if there's dots and no bar, and the flag
			  ;; that says we're allowed to do it is set.  If we fail here,
			  ;; try the rest of the tests as usual
			  ;;
			  ((AND *ALLOW-DOTTED-HOST-NAMES-IN-NAMESPACES*	; ok to try?
				DOT-IDX		; is there a dot?
				(NOT BAR-IDX)	; and no bar?
				(CONDITION-CASE (HOST-ERROR)
				     (FIND-OBJECT-NAMED :HOST HOST)
				   (OBJECT-NOT-FOUND NIL))))
			  ;;
			  ;; vanilla namespace lookup; namespace is current default, its
			  ;; search list applies.
			  ;;
			  ((NOT (OR BAR-IDX DOT-IDX))
			   (CONDITION-CASE (HOST-ERROR)
				(FIND-OBJECT-NAMED :HOST HOST)
			      (OBJECT-NOT-FOUND 
				(ERROR-OR-RETURN-VALUES HOST-ERROR))))
			  ;;
			  ;; name of the form foo|bar.  Look for a namespace named "foo"
			  ;;
			  (BAR-IDX
			   (FLET ((NETWORK-SEARCH ()
				    (DECLARE (VALUES (HOST VALID-P)))
				    (CONDITION-CASE (NETWORK-ERROR)
					 (MULTIPLE-VALUE-BIND (NETWORK NETWORK-VALID-P)
					     (FIND-OBJECT-NAMED :NETWORK 
								(NSUBSTRING HOST 0 BAR-IDX))
					   (VALUES 
					     (GET-HOST-FROM-ADDRESS
					       (SEND NETWORK :PARSE-ADDRESS 
						     (NSUBSTRING HOST (1+ BAR-IDX)))
					       NETWORK)
					     NETWORK-VALID-P))
				       (OBJECT-NOT-FOUND
					 ;; name is not the name of a network
					 (ERROR-OR-RETURN-VALUES NETWORK-ERROR)))))
			     (CONDITION-CASE (NAMESPACE-ERROR)
				  (MULTIPLE-VALUE-BIND (NAMESPACE NAMESPACE-VALID-P)
				      (FIND-OBJECT-NAMED :NAMESPACE 
							 (NSUBSTRING HOST 0 BAR-IDX)
							 T)
				    (DECLARE (IGNORE NAMESPACE-VALID-P))
				    ;; namespace was found, look in it for the host
				    (CONDITION-CASE (HOST-ERROR)
					 (FIND-OBJECT-NAMED-IN-NAMESPACE 
					   :HOST (NSUBSTRING HOST (1+ BAR-IDX)) 
					   NAMESPACE)
				       (OBJECT-NOT-FOUND
					 ;; we may still win with network|address form
					 (MULTIPLE-VALUE-BIND (HOST-OBJECT HOST-OBJECT-VALID-P)
					     (NETWORK-SEARCH)
					   (IF HOST-OBJECT
					       (VALUES HOST-OBJECT HOST-OBJECT-VALID-P)
					       (UNLESS NO-ERROR-P
						 (ERROR
						   'UNKNOWN-HOST-NAME
						   :NAME HOST :VALID-P HOST-OBJECT-VALID-P))
					       (VALUES NIL T))))))
				;;
				((NAMESPACE-NOT-FOUND OBJECT-NOT-FOUND-IN-SEARCH-LIST)
				 ;; Try to find a network of that name
				 (MULTIPLE-VALUE-BIND (HOST-OBJECT HOST-OBJECT-VALID-P)
				     (NETWORK-SEARCH)
				   (IF HOST-OBJECT
				       (VALUES HOST-OBJECT HOST-OBJECT-VALID-P)
				       ;; name is not the name of a namespace or network
				       (ERROR
					 'UNKNOWN-NETWORK-OR-NAMESPACE-IN-HOST-NAME
					 :NETWORK-NAME (SEND NAMESPACE-ERROR :NAME)
					 :NAME HOST :VALID-P (SEND NAMESPACE-ERROR :VALID-P)
					 :INVALID-NAMESPACES (SEND NAMESPACE-ERROR
								   :INVALID-NAMESPACES))))))))
		       
			  ;;
			  ;; Name in domain form.  Ask the domain system.
			  ;;
			  (DOT-IDX 
			   (MULTIPLE-VALUE-BIND (DOMAIN-HOST VALID-P)
			       (PARSE-DOMAIN-HOST HOST ASK-RESOLVER-IF-NECESSARY)
			     (UNLESS DOMAIN-HOST 
			       (UNLESS NO-ERROR-P
				 (ERROR
				   'UNKNOWN-HOST-NAME
				   :NAME HOST :VALID-P VALID-P)))
			     (VALUES DOMAIN-HOST VALID-P)))
			  )))
		    (:SYMBOL (PARSE-HOST (STRING HOST)))
		    (HOST HOST)))
	      (ERROR (VALUES NIL VALID-P)))))))


;;; 
;;; If host not found by namespace system, try to ask the domain resolver
;;;
(DEFUN PARSE-DOMAIN-HOST (HOST-NAME-STRING-OR-LIST
			  &OPTIONAL (ASK-RESOLVER-IF-NECESSARY T))
  (LET* ((HOST-NAME-STRING
	   (IF (LISTP HOST-NAME-STRING-OR-LIST) 
	       (FORMAT NIL "~{~A~@{.~A~}~}" HOST-NAME-STRING-OR-LIST)
	       HOST-NAME-STRING-OR-LIST))
	 
	 (DOT-INDEX (STRING-SEARCH-CHAR #/. HOST-NAME-STRING))
	 (HOST-PARENT-DOMAIN-NAME-STRING 
	   (WHEN DOT-INDEX (SUBSTRING HOST-NAME-STRING (1+ DOT-INDEX))))
	 (HOST-NAME-FIRST-COMPONENT
	   (COND ((LISTP HOST-NAME-STRING-OR-LIST)
		  (FIRST HOST-NAME-STRING-OR-LIST))
		 (DOT-INDEX (SUBSTRING HOST-NAME-STRING 0 DOT-INDEX))
		 (T HOST-NAME-STRING)))
	 (ACCUMULATED-VALID-P T))
    ;;
    ;; The algorithm here is as follows:  For name x.y.z, in succession, ask the
    ;; namespace for host x in namespace y.z, the resolver for host x.y.z, and the
    ;; namespace for a host with an internet-domain-name x.y.z.  At any time, 
    ;; finding a host object ends the search, and it and its valid-p are returned.
    ;; If no host is found, we return NIL, and the anded-together valid-p's.
    ;;
    (MULTIPLE-VALUE-BIND (HOST-OBJECT VALID-P)
	;;
	;; First look for one in a namespace.
	;;
	(MULTIPLE-VALUE-BIND (NAMESPACE NAMESPACE-VALID-P)
	    (IF HOST-PARENT-DOMAIN-NAME-STRING	; name have a tail that looks like a ns?
		(FIND-OBJECT-FROM-PROPERTY-LIST	; look for it
		  :NAMESPACE
		  :INTERNET-DOMAIN-NAME HOST-PARENT-DOMAIN-NAME-STRING)
		(VALUES NIL T))			; no obvious namespace name, return "NO!"
	  (MULTIPLE-VALUE-BIND (HOST-OBJECT HOST-OBJECT-VALID-P)
	      (IF NAMESPACE			; did we find a namespace?
		  (CONDITION-CASE (ERROR)	; yes, search it for host 
		       (FIND-OBJECT-NAMED-IN-NAMESPACE 
			 ':HOST HOST-NAME-FIRST-COMPONENT NAMESPACE)
		     (OBJECT-NOT-FOUND		; if no host found, return the valid-p from
		       (VALUES NIL (SEND ERROR :VALID-P))))	; the error
		  (VALUES NIL T))		; no namespace, return "No host!"

						; there is a host.  return it, with cumulative
						;  validness from itself and its containing
						;  namespace.
	    (VALUES HOST-OBJECT (AND NAMESPACE-VALID-P HOST-OBJECT-VALID-P))))
      (WHEN HOST-OBJECT
	(RETURN-FROM PARSE-DOMAIN-HOST (VALUES HOST-OBJECT VALID-P)))
      (SETQ ACCUMULATED-VALID-P (AND ACCUMULATED-VALID-P VALID-P)))
    ;;
    ;; Not in any namespace.  If allowed, try the resolver.
    ;;
    (WHEN (AND DOT-INDEX
	       (VARIABLE-BOUNDP #'REINITIALIZE-DOMAIN-RESOLVER)	; --- Sigh, for the cold-load
	       (DOMAIN-RESOLVER-ON-P))
      (MULTIPLE-VALUE-BIND (HOST-OBJECT VALID-P)
	  (DOMAIN-PARSE-HOST HOST-NAME-STRING-OR-LIST ASK-RESOLVER-IF-NECESSARY)
	(WHEN HOST-OBJECT
	  (RETURN-FROM PARSE-DOMAIN-HOST (VALUES HOST-OBJECT VALID-P)))
	(SETQ ACCUMULATED-VALID-P (AND ACCUMULATED-VALID-P VALID-P)))
      (WHEN *HEURISTICATE-PARTIAL-DOMAIN-NAMES*
	(LET* ((HOST-NAME-LIST (IF (LISTP HOST-NAME-STRING-OR-LIST) 
				   HOST-NAME-STRING-OR-LIST
				   (PARSE-DOMAIN-STYLE-NAME HOST-NAME-STRING-OR-LIST)))
	       (LOCAL-DOMAIN-NAME (OR (SEND NET:*LOCAL-HOST* :INTERNET-DOMAIN-NAME)
				      (SEND NET:*NAMESPACE* :INTERNET-DOMAIN-NAME)))
	       (LOCAL-DOMAIN-NAME-LIST (WHEN LOCAL-DOMAIN-NAME
					 (PARSE-DOMAIN-STYLE-NAME LOCAL-DOMAIN-NAME))))
	  (WHEN LOCAL-DOMAIN-NAME-LIST
	    (LOOP FOR DOMAIN-TAIL ON LOCAL-DOMAIN-NAME-LIST
		  DO
	      (MULTIPLE-VALUE-BIND (HOST-OBJECT VALID-P)
		  (DOMAIN-PARSE-HOST (APPEND HOST-NAME-LIST DOMAIN-TAIL)
				     ASK-RESOLVER-IF-NECESSARY)
		(WHEN HOST-OBJECT
		  (RETURN-FROM PARSE-DOMAIN-HOST (VALUES HOST-OBJECT VALID-P)))
		(SETQ ACCUMULATED-VALID-P (AND ACCUMULATED-VALID-P VALID-P))))))))
    ;;
    ;; Resolver doesn't know either, eh?  Ok, look for one that has an explicit domain
    ;; internet-domain-name attribute
    ;;
    (WHEN ASK-RESOLVER-IF-NECESSARY
      ;;
      ;; Note!  The above WHEN has the effect of stopping the lookup
      ;; immediately if the caller said don't ask servers, and we didn't
      ;; find the information in the local domain cache.  The real right
      ;; thing here would be to find some way to get the namespace
      ;; system to look in its cache for the answer, but stop short of
      ;; asking namespace servers (ie just what the domain system does)
      ;; but there seems to be no good way to make that happen.
      ;;
      (MULTIPLE-VALUE-BIND (HOST-OBJECT VALID-P)
	  (FIND-OBJECT-FROM-PROPERTY-LIST :HOST :INTERNET-DOMAIN-NAME HOST-NAME-STRING)
	(WHEN HOST-OBJECT
	  (RETURN-FROM PARSE-DOMAIN-HOST (VALUES HOST-OBJECT VALID-P)))
	(SETQ ACCUMULATED-VALID-P (AND ACCUMULATED-VALID-P VALID-P))))
    ;;
    ;; No ones knows -- give up
    ;;
    (VALUES NIL ACCUMULATED-VALID-P)))


(DEFFLAVOR RANDOM-HOST-MIXIN () (PATHNAME-HOST-MIXIN)
  (:REQUIRED-FLAVORS BASIC-HOST))

(DEFMETHOD (:GET-PATHNAME RANDOM-HOST-MIXIN) (DEV DIR NAM TYP VRS OTHERS)
  (PATHNAME-HOST-GET-PATHNAME SELF DEV DIR NAM TYP VRS OTHERS NIL NIL))

(DEFFLAVOR CASE-SENSITIVE-PATHNAME-HOST-MIXIN () ())

(DEFUN CASE-SENSITIVE-PATHNAME-HASH-TEST-FUNCTION (X Y)
  (DECLARE LT:(SIDE-EFFECTS READER REDUCIBLE))
  (COND ((EQL X Y)				1;catch NIL case
0	 (RETURN-FROM CASE-SENSITIVE-PATHNAME-HASH-TEST-FUNCTION T))
	((NOT (= (SYS:%DATA-TYPE X) (SYS:%DATA-TYPE Y)))
	 (RETURN-FROM CASE-SENSITIVE-PATHNAME-HASH-TEST-FUNCTION NIL))
	((CL:CONSP X)
	 (LOOP AS TX = (CAR X)
	       AS TY = (CAR Y)
	       DO
	    (UNLESS (AND (= (SYS:%DATA-TYPE TX) (SYS:%DATA-TYPE TY))
			 (OR (EQL TX TY)
			     (AND (CL:CONSP TX)
				  (CASE-SENSITIVE-PATHNAME-HASH-TEST-FUNCTION
				    TX
				    TY))
			     (AND (ARRAYP TX)    ; stringp, only cheaper.
				  (LET ((LENX (ARRAY-ACTIVE-LENGTH TX)))
				    (AND (= LENX (ARRAY-ACTIVE-LENGTH TY))
					 (SYS:%STRING= TX 0 TY 0 LENX))))))
	      (RETURN-FROM CASE-SENSITIVE-PATHNAME-HASH-TEST-FUNCTION NIL))
	    (SETQ X (CDR X) Y (CDR Y))
	    (UNLESS (OR X Y)
	      (RETURN-FROM CASE-SENSITIVE-PATHNAME-HASH-TEST-FUNCTION T))
	    (UNLESS (AND (CL:CONSP X) (CL:CONSP Y))
	      (RETURN-FROM CASE-SENSITIVE-PATHNAME-HASH-TEST-FUNCTION NIL))
	    ))
	(T (RETURN-FROM CASE-SENSITIVE-PATHNAME-HASH-TEST-FUNCTION NIL)))) 1;;; pathname hash keys are required to be lists.0 

(DEFMETHOD (MAKE-PATHNAME-HASH-TABLE CASE-SENSITIVE-PATHNAME-HOST-MIXIN) (&KEY SIZE)
  (CL:MAKE-HASH-TABLE :TEST #'CASE-SENSITIVE-PATHNAME-HASH-TEST-FUNCTION
		      :HASH-FUNCTION #'PATHNAME-KEY-HASH-FUNCTION
		      :STORE-HASH-CODE T
		      :IGNORE-GC T
		      :AREA FS:PATHNAME-AREA
		      :GROWTH-THRESHOLD .67
		      :SIZE (OR SIZE (SEND SELF :PATHNAME-HASH-TABLE-INITIAL-SIZE))))

(DEFFLAVOR HOST-ITS-MIXIN () (PATHNAME-HOST-MIXIN)
  (:REQUIRED-FLAVORS HOST))

(DEFMETHOD (:GET-PATHNAME HOST-ITS-MIXIN) (DEV DIR NAM TYP VRS OTHERS)
  (PATHNAME-HOST-GET-PATHNAME SELF DEV DIR NAM TYP VRS OTHERS NIL NIL))

(DEFMETHOD (:PICK-TYPE-AND-VERSION HOST-ITS-MIXIN) (TYP VRS)
  (COND ((AND (NULL TYP) (NULL VRS)))
	((AND (EQ TYP ':UNSPECIFIC) (EQ VRS ':UNSPECIFIC))
	 (SETQ TYP ':ERROR VRS ':ERROR))
	;; Either both are wild, or neither.
	((OR (EQ TYP ':WILD) (EQ VRS ':WILD))
	 (IF (AND (OR (MEMQ TYP '(NIL :UNSPECIFIC :WILD))
		      (MEMBER TYP FS:*ITS-UNINTERESTING-TYPES*))
		  (MEMQ VRS '(NIL :UNSPECIFIC :WILD)))
	     (SETQ TYP ':WILD VRS ':WILD)
	   (IF (EQ TYP ':WILD)
	       (SETQ TYP ':UNSPECIFIC)
	     (SETQ VRS ':UNSPECIFIC))))
	((OR (EQ TYP ':UNSPECIFIC) (EQ VRS ':UNSPECIFIC))	;One of them must be!
	 (WHEN (OR (NULL TYP) (NULL VRS))	;If one is null, the other :UNSPECIFIC
	   (SETQ TYP NIL VRS NIL)))	;Both are null.
	((AND (MEMBER TYP FS:*ITS-UNINTERESTING-TYPES*)
	      (NOT (MEMQ VRS '(NIL :UNSPECIFIC))))
	 (SETQ TYP ':UNSPECIFIC))
	(T (SETQ VRS ':UNSPECIFIC)))
  (VALUES TYP VRS))

(DEFMETHOD (:PICK-FN2 HOST-ITS-MIXIN) (TYP VRS)
  (MULTIPLE-VALUE (TYP VRS)
    (SEND SELF ':PICK-TYPE-AND-VERSION TYP VRS))
  (IF (NEQ TYP ':UNSPECIFIC)
      TYP
    VRS))

(DEFFLAVOR TENEX-FAMILY-HOST-MIXIN ()
	   (CASE-SENSITIVE-PATHNAME-HOST-MIXIN PATHNAME-HOST-MIXIN)
  (:REQUIRED-FLAVORS HOST))

(DEFFLAVOR HOST-TOPS20-MIXIN ()
	   (TENEX-FAMILY-HOST-MIXIN PATHNAME-HOST-MIXIN))

(DEFFLAVOR HOST-TENEX-MIXIN ()
	   (TENEX-FAMILY-HOST-MIXIN PATHNAME-HOST-MIXIN))

(DEFFLAVOR HOST-ALTO-MIXIN ()
	   (TENEX-FAMILY-HOST-MIXIN PATHNAME-HOST-MIXIN))

(DEFFLAVOR HOST-MSDOS-MIXIN ()
	   (NO-VERSION-HOST-MIXIN PATHNAME-HOST-MIXIN))

(DEFCONST *DEFAULT-UNIX-VERSIONS-ENABLED* NIL
  "NIL means versions on UNIX pathnames are not enabled.
T means versions on UNIX pathnames are enabled for any pathname with a directory 
  component that has a name with a canonical type that has a non-NULL property
  :UNIX-NEWEST-VERSION-SHOULD-BE-EXPLICIT.  (for example foo.sct)
:ALL means versions on UNIX pathnames are enabled for all UNIX pathnames.

This is all overridden on a per-host basis by any UNIX-VERSIONS-ENABLED
  HOST USER-PROPERTY.")

(DEFFLAVOR HOST-UNIX-MIXIN
	((UNIX-VERSIONS-ENABLED *DEFAULT-UNIX-VERSIONS-ENABLED*))
	(NO-DEVICE-HOST-MIXIN CASE-SENSITIVE-PATHNAME-HOST-MIXIN PATHNAME-HOST-MIXIN)
  (:REQUIRED-FLAVORS HOST))

(DEFUN-IN-FLAVOR (UPDATE-UNIX-VERSIONS-ENABLED HOST-UNIX-MIXIN) ()
  (LET ((STRING (SEND SELF :USER-GET :UNIX-VERSIONS-ENABLED)))
    (SETQ UNIX-VERSIONS-ENABLED
	  (IF STRING
	      (COND ((ZEROP (STRING-LENGTH STRING)) T)
		    ((CHAR-EQUAL (AREF STRING 0) #\N) NIL)
		    ((STRING-EQUAL STRING "All") :ALL)
		    (T))
	    *DEFAULT-UNIX-VERSIONS-ENABLED*))
    (WHEN SAMPLE-PATHNAME
      (LET ((OLD-SAMPLE-PATHNAME SAMPLE-PATHNAME))
	(SETQ SAMPLE-PATHNAME NIL)
	(UNLESS (EQ OLD-SAMPLE-PATHNAME (SEND SELF :SAMPLE-PATHNAME))
	  (SEND SELF :FILE-RESET))))))

(DEFUN ENABLE-UNIX-VERSIONS (&OPTIONAL (VALUE T))
  "NIL means versions on UNIX pathnames are not to be enabled.
T means versions on UNIX pathnames are to be enabled for any pathname with a directory 
  component that has a name with a canonical type that has a non-NULL property
  :UNIX-NEWEST-VERSION-SHOULD-BE-EXPLICIT.  (for example foo.sct)
:ALL means versions on UNIX pathnames are to be enabled for all UNIX pathnames.

This is all overridden on a per-host basis by any UNIX-VERSIONS-ENABLED
  HOST USER-PROPERTY."
  (SETQ *DEFAULT-UNIX-VERSIONS-ENABLED* VALUE)
  ;;; Make sure that all existing UNIX hosts objects are initialized correctly.
  (LOOP WITH *INHIBIT-VALIDITY-CHECKING* = T
	FOR HOST IN (FIND-OBJECTS-FROM-PROPERTY-LIST :HOST)
	WHEN (TYPEP HOST 'HOST-UNIX-MIXIN)
	  DO (SEND HOST :CHANGE-OF-ATTRIBUTES)))

(DEFMETHOD (:CHANGE-OF-ATTRIBUTES HOST-UNIX-MIXIN) ()
  (UPDATE-UNIX-VERSIONS-ENABLED))

(DEFMETHOD (:SET-PROPERTY-LIST HOST-UNIX-MIXIN :AFTER) (IGNORE)
  (UPDATE-UNIX-VERSIONS-ENABLED))

(DEFUN UNIX-DIRECTORY-VERSIONS-ENABLED (DIRECTORY)
  (AND (LISTP DIRECTORY)
       (LOOP WITH DOT = NIL
	     WITH TYP = NIL
	     WITH KEY = NIL
	     FOR NAME IN DIRECTORY
	     THEREIS
	       (AND (STRINGP NAME)
		    (SETQ DOT (STRING-REVERSE-SEARCH-EXACT-CHAR #\. NAME))
		    (SETQ TYP (STRING-FLIPCASE (SUBSTRING NAME (1+ DOT))))
		    (SETQ KEY (LISP:FIND-SYMBOL TYP "KEYWORD"))
		    (GET KEY :UNIX-NEWEST-VERSION-SHOULD-BE-EXPLICIT)))))

(DEFMETHOD (HOST-UNIX-VERSIONS-ENABLED HOST-UNIX-MIXIN) (&KEY DIRECTORY)
  (OR (EQ UNIX-VERSIONS-ENABLED :ALL)
      (AND UNIX-VERSIONS-ENABLED
	   (UNIX-DIRECTORY-VERSIONS-ENABLED DIRECTORY))))

(DEFMETHOD (:DEFAULT-HOMEDIR HOST-UNIX-MIXIN) (USER-NAME)
  (SEND (SEND SELF :SAMPLE-PATHNAME) :NEW-PATHNAME
	:RAW-DIRECTORY `("usr" ,USER-NAME) :NAME NIL :TYPE NIL :VERSION NIL))

(DEFWHOPPER (NETI:PATHNAME-HOST-MAKE-PATHNAME HOST-UNIX-MIXIN)
	    (DEVICE DIRECTORY NAME TYPE VERSION OTHERS VC-BRANCH VC-VERSION)
  (LET ((VERSION
	  (IF (HOST-UNIX-VERSIONS-ENABLED SELF :DIRECTORY DIRECTORY)
	      (IF (EQ VERSION :UNSPECIFIC)
		  (IF (AND (NULL NAME) (NULL TYPE)) NIL :NEWEST)
		VERSION)
	    :UNSPECIFIC)))
    (CONTINUE-WHOPPER DEVICE DIRECTORY NAME TYPE VERSION OTHERS VC-BRANCH VC-VERSION)))

(DEFWHOPPER (PATHNAME-HOST-GET-PATHNAME HOST-UNIX-MIXIN)
	    (DEVICE DIRECTORY NAME TYPE VERSION OTHERS VC-BRANCH VC-VERSION)
  (LET ((VERSION
	  (IF (HOST-UNIX-VERSIONS-ENABLED SELF :DIRECTORY DIRECTORY)
	      (IF (EQ VERSION :UNSPECIFIC)
		  (IF (AND (NULL NAME) (NULL TYPE)) NIL :NEWEST)
		VERSION)
	    :UNSPECIFIC)))
    (CONTINUE-WHOPPER DEVICE DIRECTORY NAME TYPE VERSION OTHERS VC-BRANCH VC-VERSION)))

(DEFFLAVOR HOST-MULTICS-MIXIN ()
	   (NO-DEVICE-OR-VERSION-HOST-MIXIN CASE-SENSITIVE-PATHNAME-HOST-MIXIN
	    PATHNAME-HOST-MIXIN)
  (:REQUIRED-FLAVORS HOST))

(DEFMETHOD (:DEFAULT-HOMEDIR HOST-MULTICS-MIXIN) (USER-NAME)
  (SEND (SEND SELF :SAMPLE-PATHNAME) :NEW-PATHNAME
	:RAW-DIRECTORY `("udd" "Project" ,USER-NAME) :NAME NIL :TYPE NIL :VERSION NIL))

(DEFFLAVOR HOST-VM370-MIXIN ()
	   (NO-DIRECTORY-OR-VERSION-HOST-MIXIN PATHNAME-HOST-MIXIN))

(DEFFLAVOR HOST-VMS-MIXIN () (PATHNAME-HOST-MIXIN)
  (:REQUIRED-FLAVORS HOST))

(DEFFLAVOR HOST-LISPM-MIXIN () (NO-DEVICE-HOST-MIXIN PATHNAME-HOST-MIXIN)
  (:REQUIRED-FLAVORS HOST))

;;; Dummy hosts for use with logtran

(DEFCONST ALL-SYSTEM-TYPES
	  '(:LISPM :VMS :VMS4 :VMS4.4 :UNIX :XENIX :UNIX42 :ULTRIX :ITS :TOPS-20 :TENEX
	    :MULTICS :MSDOS :OS//2 :VM370 :ISO9660
	    :FEP :LOGICAL))

(DEFUN SETUP-SAMPLE-HOSTS ()
  (LOOP FOR TYPE IN ALL-SYSTEM-TYPES
	AS HOST = (MAKE-OBJECT-FROM-PROPERTY-LIST ':HOST (FORMAT NIL "Dummy ~A" TYPE)
						  `(:SYSTEM-TYPE ,TYPE))
	DO (PUTPROP TYPE HOST 'SAMPLE-HOST)))

;;; LISPM Location stuff
;;--- This should be obsoleted, use *local-host* and local-host-p
(DEFVAR LOCAL-HOST NIL)
(DEFVAR LOCAL-HOST-NAME)
(DEFVAR LOCAL-PRETTY-HOST-NAME)
(DEFVAR LOCAL-BUILDING-LOCATION)
(DEFVAR LOCAL-FLOOR-LOCATION)
(DEFVAR LOCAL-FINGER-LOCATION)

(DEFUN SET-LOCAL-HOST-VARIABLES ()
  (SETQ LOCAL-HOST *LOCAL-HOST*
	LOCAL-HOST-NAME (STRING (SEND LOCAL-HOST :NAME))
	LOCAL-PRETTY-HOST-NAME (STRING (SEND LOCAL-HOST :PRETTY-NAME))
	LOCAL-BUILDING-LOCATION (FIRST (SEND LOCAL-HOST :CONSOLE-LOCATION))
	LOCAL-FLOOR-LOCATION (SECOND (SEND LOCAL-HOST :CONSOLE-LOCATION))
	LOCAL-FINGER-LOCATION (OR (THIRD (SEND LOCAL-HOST :CONSOLE-LOCATION))
				  "Unknown"))
  (NETI:COMPUTE-FINGER-STRING))

(DEFUN LOCAL-HOST-P (HOST)
  (NS-EQ HOST *LOCAL-HOST*))

(ADD-INITIALIZATION "SET-LOCAL-HOST-VARIABLES" '(SET-LOCAL-HOST-VARIABLES) NIL
		    'LOCAL-NAME-INITIALIZATION-LIST)

;;;; Peripheral stuff

(DEFSTRUCT (PERIPHERAL :NAMED :CONC-NAME)
  NAME
  DEVICE-TYPE
  DEVICE-OPTIONS
  INTERFACE-TYPE
  INTERFACE-OPTIONS
  )

(DEFSELECT ((:PROPERTY PERIPHERAL NAMED-STRUCTURE-INVOKE))
  (:PRINT-SELF (PERIPHERAL STREAM &REST IGNORE)
   (SI:PRINTING-RANDOM-OBJECT (PERIPHERAL STREAM :TYPEP)
     (FORMAT STREAM "~A~@[ ~A~]" (PERIPHERAL-DEVICE-TYPE PERIPHERAL)
				 (PERIPHERAL-NAME PERIPHERAL)))))

(DEFVAR *PERIPHERAL-INTERFACE-TYPES* NIL)
(DEFVAR *PERIPHERAL-DEVICE-TYPES* NIL)

(DEFSTRUCT (PERIPHERAL-INTERFACE-TYPE :LIST* :CONC-NAME)
  NAME
  BASIC-TYPE
  ALLOWED-OPTIONS
  )

(DEFSTRUCT (PERIPHERAL-DEVICE-TYPE :LIST* :CONC-NAME)
  NAME
  ALLOWED-OPTIONS
  )

(DEFMACRO DEFINE-PERIPHERAL-INTERFACE-TYPE (NAME BASIC-TYPE . ALLOWED-OPTIONS)
  `(DEFINE-PERIPHERAL-INTERFACE-TYPE-1 ',NAME ',BASIC-TYPE ',(COPYLIST ALLOWED-OPTIONS)))

(DEFMACRO DEFINE-PERIPHERAL-DEVICE-TYPE (NAME . ALLOWED-OPTIONS)
  `(DEFINE-PERIPHERAL-DEVICE-TYPE-1 ',NAME ',(COPYLIST ALLOWED-OPTIONS)))

(DEFUN UNDEFINE-PERIPHERAL-DEVICE-TYPE (NAME)
  (LOOP FOR DEVICE IN *PERIPHERAL-DEVICE-TYPES* DO
    (WHEN (EQ (FIRST DEVICE) NAME)
      (SETF *PERIPHERAL-DEVICE-TYPES* (REMOVE DEVICE *PERIPHERAL-DEVICE-TYPES*)))))

(DEFUN UNDEFINE-PERIPHERAL-INTERFACE-TYPE (NAME)
  (LOOP FOR INTERFACE IN *PERIPHERAL-INTERFACE-TYPES* DO
    (WHEN (EQ (FIRST INTERFACE) NAME)
      (SETF *PERIPHERAL-INTERFACE-TYPES* (REMOVE INTERFACE *PERIPHERAL-INTERFACE-TYPES*)))))

(DEFUN DEFINE-PERIPHERAL-INTERFACE-TYPE-1 (NAME BASIC-TYPE ALLOWED-OPTIONS)
  (WHEN (RECORD-SOURCE-FILE-NAME NAME 'DEFINE-PERIPHERAL-INTERFACE-TYPE)
    (LOOP FOR DEVICE IN *PERIPHERAL-DEVICE-TYPES*
	  DO (LOOP FOR (OPTION) IN (PERIPHERAL-DEVICE-TYPE-ALLOWED-OPTIONS DEVICE)
		   DO (WHEN (EQ NAME OPTION)
			(FORMAT ERROR-OUTPUT
  "Warning: conflict in ~A interface type and ~A option to device type ~A.
These two cannot be used together."
				NAME NAME (PERIPHERAL-DEVICE-TYPE-NAME DEVICE)))
		      (LOOP FOR (OTHER-OPTION) IN ALLOWED-OPTIONS
			    DO (WHEN (EQ OTHER-OPTION OPTION)
				 (FORMAT ERROR-OUTPUT
  "Warning: conflict in ~A option between device type ~A and interface type ~A.
These two cannot be used together."
					 OPTION (PERIPHERAL-DEVICE-TYPE-NAME DEVICE) NAME)))))
    (LET ((TEM (ASSQ NAME *PERIPHERAL-INTERFACE-TYPES*)))
      (WHEN (NULL TEM)
	(SETQ TEM (MAKE-PERIPHERAL-INTERFACE-TYPE NAME NAME))
	(PUSH TEM *PERIPHERAL-INTERFACE-TYPES*))
      (SETF (PERIPHERAL-INTERFACE-TYPE-BASIC-TYPE TEM) BASIC-TYPE)
      (SETF (PERIPHERAL-INTERFACE-TYPE-ALLOWED-OPTIONS TEM) ALLOWED-OPTIONS))
    (DECACHE-HOST-PERIPHERALS)
    NAME))

(DEFUN DEFINE-PERIPHERAL-DEVICE-TYPE-1 (NAME ALLOWED-OPTIONS)
  (WHEN (RECORD-SOURCE-FILE-NAME NAME 'DEFINE-PERIPHERAL-DEVICE-TYPE)
    (LOOP FOR INTERFACE IN *PERIPHERAL-INTERFACE-TYPES*
	  DO (LOOP FOR (OPTION) IN (PERIPHERAL-INTERFACE-TYPE-ALLOWED-OPTIONS INTERFACE)
		   DO (LOOP FOR (OTHER-OPTION) IN ALLOWED-OPTIONS
			    DO (WHEN (EQ OTHER-OPTION OPTION)
				 (FORMAT ERROR-OUTPUT
  "Warning: conflict in ~A option between interface type ~A and device type ~A.
These two cannot be used together."
					 OPTION
					 (PERIPHERAL-INTERFACE-TYPE-NAME INTERFACE) NAME)))))
    (LET ((TEM (ASSQ NAME *PERIPHERAL-DEVICE-TYPES*)))
      (WHEN (NULL TEM)
	(SETQ TEM (MAKE-PERIPHERAL-DEVICE-TYPE NAME NAME))
	(PUSH TEM *PERIPHERAL-DEVICE-TYPES*))
      (SETF (PERIPHERAL-DEVICE-TYPE-ALLOWED-OPTIONS TEM) ALLOWED-OPTIONS))
    (DECACHE-HOST-PERIPHERALS)
    NAME))

(DEFMACRO DEFINE-PERIPHERAL-OPTION-PARSER (NAME ARGLIST &BODY BODY)
  `(DEFUN (:PROPERTY ,NAME PERIPHERAL-OPTION-PARSER) ,ARGLIST
     . ,BODY))

(DEFUN PARSE-PERIPHERAL-OPTION (OPTION-TYPE VALUE)
  (LET ((ARGS NIL))
    (WHEN (LISTP OPTION-TYPE)
      (PSETQ OPTION-TYPE (CAR OPTION-TYPE)
	     ARGS (CDR OPTION-TYPE)))
    (LET ((FUNCTION (GET OPTION-TYPE 'PERIPHERAL-OPTION-PARSER)))
      (IF (NULL FUNCTION)
	  VALUE
	(LEXPR-FUNCALL FUNCTION VALUE ARGS)))))

(DEFINE-PERIPHERAL-OPTION-PARSER :INTEGER (VALUE &KEY (RADIX 10.) RANGE MEMBER)
  (LET ((NUMBER (PARSE-NUMBER VALUE 0 NIL RADIX T)))
    (WHEN (NULL NUMBER)
      (FERROR "~A is not an integer." VALUE))
    (WHEN RANGE
      (UNLESS (AND (OR (NULL (FIRST RANGE))
		       ( (FIRST RANGE) NUMBER))
		   (OR (NULL (SECOND RANGE))
		       ( (SECOND RANGE) NUMBER)))
	(FERROR "~D is not in the range ~S" NUMBER RANGE)))
    (WHEN MEMBER
      (UNLESS (MEMBER NUMBER MEMBER)
	(FERROR "~D is not in ~S" NUMBER MEMBER)))
    NUMBER))

(DEFINE-PERIPHERAL-OPTION-PARSER :KEYWORD (VALUE)
  (INTERN (STRING-UPCASE VALUE) PKG-KEYWORD-PACKAGE))

;;; This isn't really needed, but for completeness it's here.
(DEFINE-PERIPHERAL-OPTION-PARSER :STRING (VALUE)
  VALUE)

;;; Alist of (host . peripherals).  Used as a cache
(DEFVAR *HOST-PERIPHERALS* NIL)

(DEFMETHOD (:PERIPHERALS HOST) ()
  (LET ((UNPARSED (SEND SELF ':GET ':PERIPHERAL))	;Always do this to validity check
	(ELEM (ASSQ SELF *HOST-PERIPHERALS*)))
    (IF (OR (NOT (NULL (CDR ELEM)))
	    (NULL UNPARSED))
	(CDR ELEM)
      (WHEN (NULL ELEM)
	(SETQ ELEM (NCONS SELF))
	(PUSH ELEM *HOST-PERIPHERALS*))
      (LET ((PARSED (PARSE-HOST-PERIPHERALS UNPARSED SELF)))
	(SETF (CDR ELEM) PARSED)
	PARSED))))

;;; This is called at boot time; get rid of parsed peripherals for other than
;;; the local host so that the list doesn't grow without bounds.
(DEFUN COMPUTE-LOCAL-HOST-PERIPHERALS ()
  (SETQ *HOST-PERIPHERALS* (DEL-IF-NOT #'(LAMBDA (X) (LOCAL-HOST-P (CAR X)))
				       *HOST-PERIPHERALS*))
  (SEND *LOCAL-HOST* ':PERIPHERALS))

(ADD-INITIALIZATION "Get local host peripherals" '(COMPUTE-LOCAL-HOST-PERIPHERALS)
		    NIL 'LOCAL-NAME-INITIALIZATION-LIST)

;;; This is called when host attributes change; get rid of cache for the host
(DEFUN DECACHE-HOST-PERIPHERALS (&OPTIONAL SINGLE-HOST)
  (IF (NOT SINGLE-HOST)
      (SETQ *HOST-PERIPHERALS* NIL)
      (LET ((ELEM (ASSQ SINGLE-HOST *HOST-PERIPHERALS*)))
	(WHEN ELEM
	  (SETF (CDR ELEM) NIL)))))

;;; FOR-HOST is just for error message.
(DEFUN PARSE-HOST-PERIPHERALS (PERIPHERALS FOR-HOST)
  (LET ((PARSED-PERIPHERALS NIL))
    (LOOP FOR (DEVICE-TYPE OPTIONS) IN PERIPHERALS DOING
      (LET ((PERIPHERAL-DEVICE-TYPE (ASSQ DEVICE-TYPE *PERIPHERAL-DEVICE-TYPES*)))
	(WHEN (NULL PERIPHERAL-DEVICE-TYPE)
	  (SETQ PERIPHERAL-DEVICE-TYPE '(NIL (:ALLOW-OTHER-OPTIONS))))
	(LET ((PERIPHERAL-INTERFACE-TYPE NIL))
	  (LOOP FOR (OPTION VALUE) IN OPTIONS
		DO (IGNORE VALUE)
		   (LET ((PIT (ASSQ OPTION *PERIPHERAL-INTERFACE-TYPES*)))
		     (WHEN PIT
		       (IF PERIPHERAL-INTERFACE-TYPE
			   (FORMAT ERROR-OUTPUT
  "Warning: host ~A's ~A peripheral, ~S, specify both ~A and ~A as interface types.
The second will be ignored."
				   FOR-HOST DEVICE-TYPE OPTIONS
				   (PERIPHERAL-INTERFACE-TYPE-NAME PERIPHERAL-INTERFACE-TYPE)
				   OPTION)
			   (SETQ PERIPHERAL-INTERFACE-TYPE PIT)))))
	  (WHEN (NULL PERIPHERAL-INTERFACE-TYPE)
	    (FORMAT ERROR-OUTPUT
  "Warning: host ~A's ~A peripheral, ~S, does not specify an interface type."
		    FOR-HOST DEVICE-TYPE OPTIONS))
	  (LET ((NAME NIL)
		(DEVICE-OPTIONS NIL)
		(INTERFACE-OPTIONS NIL))
	    (LOOP FOR (OPTION VALUE) IN OPTIONS DOING
	      (LET (TEM)
		(CONDITION-CASE (ERROR)
		    (COND ((EQ OPTION ':NAME)
			   (SETQ NAME VALUE))
			  ((SETQ TEM (ASSQ OPTION
					   (PERIPHERAL-INTERFACE-TYPE-ALLOWED-OPTIONS
					     PERIPHERAL-INTERFACE-TYPE)))
			   (LET ((PVALUE (PARSE-PERIPHERAL-OPTION (CDR TEM) VALUE)))
			     (DOLIST (OTHER-PERI PARSED-PERIPHERALS)
			       (WHEN
				 (AND (NEQ OPTION :BAUD)	1;Special case for baud rates
0				      (EQ PVALUE
					 (GET (LOCF (PERIPHERAL-INTERFACE-OPTIONS
						      OTHER-PERI))
					      OPTION)))
				 (FORMAT ERROR-OUTPUT 
  "Warning: host ~A has more than one peripheral assigned to ~A ~A." FOR-HOST OPTION VALUE)))
			     (PUTPROP (LOCF INTERFACE-OPTIONS) PVALUE OPTION)))
			  ((SETQ TEM (OR (ASSQ OPTION 
					       (PERIPHERAL-DEVICE-TYPE-ALLOWED-OPTIONS
						 PERIPHERAL-DEVICE-TYPE))
					 (ASSQ ':ALLOW-OTHER-OPTIONS
					       (PERIPHERAL-DEVICE-TYPE-ALLOWED-OPTIONS
						 PERIPHERAL-DEVICE-TYPE))))
			   (PUTPROP (LOCF DEVICE-OPTIONS)
				    (PARSE-PERIPHERAL-OPTION (CDR TEM) VALUE)
				    OPTION))
			  (T
			   (FORMAT ERROR-OUTPUT
  "Warning: host ~A's ~A peripheral, ~S, contains the unknown option ~A.
It will be ignored."
				   FOR-HOST DEVICE-TYPE OPTIONS OPTION)))
		  (ERROR (FORMAT ERROR-OUTPUT
  "Warning: host ~A's ~A peripheral, ~S, got an error in the ~A option: ~A.
It will be ignored."
				 FOR-HOST DEVICE-TYPE OPTIONS OPTION ERROR)))))
	    (PUSH (MAKE-PERIPHERAL NAME NAME
				   DEVICE-TYPE DEVICE-TYPE
				   DEVICE-OPTIONS DEVICE-OPTIONS
				   INTERFACE-TYPE (PERIPHERAL-INTERFACE-TYPE-BASIC-TYPE
						    PERIPHERAL-INTERFACE-TYPE)
				   INTERFACE-OPTIONS INTERFACE-OPTIONS)
		  PARSED-PERIPHERALS)))))
    (NREVERSE PARSED-PERIPHERALS)))

;;; This is the normal interface function.
(DEFUN FIND-PERIPHERAL (DEVICE-TYPE &OPTIONAL (ON-HOST *LOCAL-HOST*) &REST OTHER-OPTIONS)
  (DOLIST (PERIPHERAL (SEND ON-HOST ':PERIPHERALS))
    (WHEN (AND (EQ (PERIPHERAL-DEVICE-TYPE PERIPHERAL) DEVICE-TYPE)
	       (LOOP FOR (OPTION VALUE) ON OTHER-OPTIONS BY 'CDDR
		     ALWAYS (IF (EQ OPTION ':NAME)
				(EQUAL VALUE (PERIPHERAL-NAME PERIPHERAL))
				(OR (EQUAL VALUE (GET (LOCF (PERIPHERAL-INTERFACE-OPTIONS
							      PERIPHERAL))
						      OPTION))
				    (EQUAL VALUE (GET (LOCF (PERIPHERAL-DEVICE-OPTIONS
							      PERIPHERAL))
						      OPTION))))))
      (RETURN PERIPHERAL))))

(DEFUN PERIPHERALS-EQUAL (P1 P2)
  (OR (EQ P1 P2)
      (AND (EQUAL (PERIPHERAL-NAME P1)
		  (PERIPHERAL-NAME P2))
	   (EQUAL (PERIPHERAL-DEVICE-TYPE P1)
		  (PERIPHERAL-DEVICE-TYPE P2))
	   (EQUAL (PERIPHERAL-INTERFACE-TYPE P1)
		  (PERIPHERAL-INTERFACE-TYPE P2))
	   (EQUAL (PERIPHERAL-INTERFACE-OPTIONS P1)
		  (PERIPHERAL-INTERFACE-OPTIONS P2)))))
