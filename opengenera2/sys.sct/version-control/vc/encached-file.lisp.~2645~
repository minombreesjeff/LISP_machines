;;; -*- Mode: LISP; Package: D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")vci0; Base: 10; Lowercase: Yes; Syntax: Common-lisp; -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

1;;;--- To Do: 
;;;--- *Encached "which definitions in this section." information.
;;;--- *More error checking on parameters.
;;;--- *protection against interrupts here on the non-locked case.

;;; Italic Disease removed 1 december, a few days too late.

;;; Encached File Representation
;;;
;;; The encached file, and the brains to both turn it into plaintext and
;;; recreate the file format.  One might imagine that the latter belongs
;;; with the parser, but there is no real reason to put it there. it
;;; being a toothpaste into tube type of problem).
;;;
;;; Terminology:
;;;
;;;  A ç (delta) is a change from one version of a section to another.
;;;  Each ç is composed of one or two  (partial-deltas): a delete  of
;;;  the text deleted, and/or an insert  for the text inserted.
;;;
0;;; The encached file representation stored all of the versions of the
;;; file.  To avoid massive storage usage, it stores the sequence of
;;; text and deltas rather than the reconstituted text.
;;;
;;; The cache is made of three part:
;;;
;;; 1) Version information.  
;;;      a) the information from the file header is stored.  
;;;      b) A bitmap is that has a 1 for each of the lower-numbered versions which is an
;;;	    ancestor.  To construct the text of any particular version, the encached text
;;;         is scanned, processing per-version changes as per the bitmap.
;;;      c) The list of sections that are present in this version, in order. 
;;;
;;;
;;; 2) Section information.
;;;      All of the text and delta control records are stored per-section, in arrays.
;;;      If the section order changes from one version of the file to another,
;;;      the ordered list of sections in the version information keeps track.
;;;      The text and control records are just concatenated.   In the case of a moved
;;;      section, there will be two copies of the basic text:  the copy from the
;;;      original position, covered by a delete , and the copy from the new position,
;;;      under an insert.  Optimizing this out would be too much work, and would
;;;      complicate recreating the file format.
;;;
;;;
;;; 3) The reconstruct path.
;;;      A list of entries.  Each entry is a section number, and a count of 
;;;      ocurrences of the section.  Each time that a BFS turns up in the file,
;;;      an entry is pushed onto the reconstruct list.  To reconstruct the file,
;;;      the entries are processed in sequences.  The index-1 number of BFS's for 
;;;      the section are skipped in the section array, and all of the text up to
;;;      the next BFS are output to the file.
(defvar *user-guarantees-branch-merge-records-are-valid* nil)
1;;; The Per-Version information.  Too bad we don't have the concept of a defstruct
;;; onto a two-dimensional array.

0(defstruct (per-version
	     (:conc-name pv-)
	     (:constructor make-per-version-1)	1; make-per-version makes bitmaps
0	     )
  (internal-version 0)				1; our position in the array of versions
0  (parent-version 0)				; 1immediately previous
0  (branch-name "")				; 1name of system version of which this is a
0  (branch-version 0)				; 1externally advertised number
0						; 1part.
0  (ancestor-bitmap nil)				; 1bitmap per version smaller numbered than us.
0  (leaf-p t)
  (trailer nil)
  (version-info nil)				1;encached copy of structure for the
0						1;outside world.
0  (version-reconstruct-path nil))		1;ditto.

0(defun make-per-version (internal-version
			 parent-version
			 branch-name
			 branch-version
			 length
			 author
			 creation-date)
  (make-per-version-1 :internal-version internal-version
		      :parent-version parent-version
		      :branch-name branch-name
		      :branch-version branch-version
		      :version-info (make-file-version-info
				      :branch-name branch-name
				      :branch-version branch-version
				      :length length
				      :author author
				      :creation-date creation-date)))


1;;; pseudo-defstruct for the table of all of the above.

0(defun make-version-table (n-versions)
  (make-array (+ 1 n-versions)1 ;; there is no version number 0, the slot is unused.
0	      :fill-pointer 1  1;; ditto.
0	      :leader-length 2
	      :named-structure-symbol 'version-table))
(deftype version-table () `(structure version-table))

(defsubst version-table-n-versions (vt)
  (- (fill-pointer vt) 1))

(defsetf version-table-n-versions (vt) (new-n-v)
  `(setf (fill-pointer ,vt) (+ 1 ,new-n-v)))

(defsubst version-table-max-n-version (vt)
  (array-dimension vt 0))


(zl:defselect ((:property version-table zl:named-structure-invoke))
  (:print-self (vt stream ignore ignore)
	       (si:printing-random-object (vt stream :typep)
		 (format stream "~D entries" (version-table-n-versions vt)))))
1;;; The Per Section information. Another pseudo-defstruct.

0(defsubst section-table-max-n-sections (st)
  (array-dimension st 0))

(defun section-table-n-sections (st)
  (loop for si being the array-elements of st
	counting si))

(defun make-section-table (n-sections)
  (let ((st 
	  (make-array n-sections :initial-element nil :leader-length 2 
		      :named-structure-symbol 'section-table)))
    (setf (fill-pointer st) n-sections)
    st))
(deftype section-table () `(structure section-table))

(zl:defselect ((:property section-table zl:named-structure-invoke))
  (:print-self (st stream ignore ignore)
	       (si:printing-random-object (st stream :typep)
		 (format stream "~D entr~:@P"
			 (section-table-max-n-sections st)))))

(defsubst section-info-n-records (si)
  (fill-pointer si))

(defsubst section-info-occurence-count (si)
  (array-leader si 2))

(defun make-section-info (n-records)
  (let ((si
	  (make-array n-records :fill-pointer 0 :leader-length 3
		      :adjustable t
		      :named-structure-symbol 'section-info)))
    (setf (section-info-occurence-count si) 0)
    si))

(deftype section-info () `(structure section-info))

(defsubst push-section-record (si record)
  (vector-push-extend record si (section-info-n-records si))) ; double when we grow.

(zl:defselect ((:property section-info zl:named-structure-invoke))
  (:print-self (si stream ignore ignore)
	       (si:printing-random-object (si stream :typep)
		 (format stream "~:[empty~;number ~D~] ~3D records ~3D occurrence~:P"
		       (plusp (section-info-n-records si))
		       (cr-section (aref si 0))
		       (section-info-n-records si)
		       (section-info-occurence-count si)))))
1;;; The reconstruct path information.

0(defstruct (reconstruct-entry
	     (:conc-name re-)
	     )
  (section-number 0)
  (occurence 0))

(defun make-reconstruct-table (n-section-blocks)
  (make-array n-section-blocks :fill-pointer 0 :adjustable t))

(defsubst push-reconstruct-entry (table section-info section-number)
  (let ((o (incf (section-info-occurence-count section-info))))
    (vector-push-extend (make-reconstruct-entry :section-number section-number
						:occurence o)
			table
			(array-dimension table 0) ; double the size.
			)))
;;; A flavor which owns and maintains an encached file

(defparameter *trace-encached-files* nil "Trace all encached file operations.")

(defmacro trace-encached-file (selector format-string &rest format-args)
  `(when (or (eq *trace-encached-files* t) (eq *trace-encached-files* ,selector))
     (trace-encached-file-1 ,format-string ,@format-args)))

(defun trace-encached-file-1 (format-string &rest format-args-list)
  (let ((*print-array* t)
	(*print-pretty* t))
    (with-character-style ('(nil :bold nil) *trace-output*)
      (format *trace-output* "~& VC ")
      (apply #'format *trace-output* format-string format-args-list))))

(defflavor encached-file-header
	(version-table
	 (stored-property-list nil)
	 ;; Special hack to get around a bug whereby VC put some bad
	 ;; branch-merge records into edition 2 VC files
	 ;;--- Remove this code someday
	 (ignore-branch-merge-records nil))
	()
  (:writable-instance-variables
   (encached-file-stored-property-list stored-property-list)
   (encached-file-ignore-branch-merge-records ignore-branch-merge-records)))

(defflavor encached-file
	(
	 section-table
	 reconstruct-table
	 (queue nil)
	 (name "")
	 (pathname nil)
	 (truename nil)
	 )
	(encached-file-header si:property-list-mixin)
  (:functions make-internal-delete-array delete-reconstruct-entries
	      make-new-occurence make-section-from-ç-section
	      delete-text-records delete-text-records-1-section)
  (:writable-instance-variables name pathname truename)
  (:initable-instance-variables name pathname)
  (:documentation "Encached representation of a version controlled file."))

(defmethod (make-instance encached-file) (&rest ignore)
  (when pathname (setq name (format nil "~A" pathname)))
  (setq queue (si:make-process-queue (format nil "~S" self) 5)))
(defmethod (encached-file-pathname encached-file-header) () nil)

(defmethod (sys:print-self encached-file) (stream ignore slashify-p)
  (if slashify-p (sys:printing-random-object (self stream :typep)
		   (format stream "~A" name))
      (format stream "~A" name)))

(defmacro-in-flavor (with-encached-file-lock encached-file) (&body body)
  `(unwind-protect
       (progn
	 (si:process-enqueue queue)
	 ,@body)
     (si:process-dequeue queue)))

(defparameter *initial-section-size* 25 "Section arrays start this big.")

(defmethod (:number-of-sections encached-file) ()
  (section-table-n-sections section-table))
(defmacro-in-flavor (consing-with-instance encached-file-header) (&body body)
  `(let ((sys:default-cons-area (sys:%area-number self)))
     ,@body))

1;;; This method abandons any existing contents of the encached file and reads a new one.

0(defmethod (encached-file-read-header-from-parsed-header encached-file-header) (header)
  (consing-with-instance
    (setq stored-property-list (copy-list (pf-header-properties header)))
    (when ignore-branch-merge-records
      ;;--- Remove this code someday
      (setf (cl:getf stored-property-list 'zwei:branch-merge-record) nil)))
  ;; cons the version array.
  (setq version-table (make-version-table (pf-header-n-versions header)))
  ;; fill in each of the entries.
  (loop for pfvi being the array-elements of (pf-header-version-info-array header)
	    from 1				; no version 0
		 using (index idx)
	as pv = (and (not (pf-version-info-deleted-p pfvi))
		     (consing-with-instance
		       (make-per-version
			 idx
			 (pf-version-info-parent-version pfvi)
			 (if (and
			       (string-equal
				 (pf-version-info-branch-name pfvi) "")
			       (plusp (pf-version-info-parent-version pfvi)))
			     (pv-branch-name
			       (aref version-table
				     (pf-version-info-parent-version pfvi)))
			     (pf-version-info-branch-name pfvi))
			 (pf-version-info-branch-version pfvi)
			 (pf-version-info-length pfvi)
			 (pf-version-info-author pfvi)
			 (pf-version-info-creation-date pfvi)
			 )))
	do
    (when (and pv
	       (not (zerop (pv-parent-version pv)))
	       (string-equal (pv-branch-name
			  (aref version-table (pv-parent-version pv)))
			(pv-branch-name pv)))
      (setf (pv-leaf-p (aref version-table (pv-parent-version pv))) nil))
    ;; fill-pointer will follow idx, but just in case
    (vector-push-carefully pv version-table)
    (assert (= idx (version-table-n-versions version-table)) nil
	    "Version table out of synch with version read loop.")
    (trace-encached-file t "Version ~D: ~S" idx pv)))

(defmethod (read-in-file encached-file) (stream)
  (with-encached-file-lock
    (trace-encached-file t ":read-file from ~A" stream)
    (send stream :set-pointer 0)		1; rewind the stream since someone else
0						1; may have read the attribute list.
0    (let* ((attributes (fs:read-attribute-list nil stream :dont-reset-stream t))
	   (file-version (getf attributes :version-control))
	   (old-return-diagrams (send-if-handles stream :return-diagrams-as-lines)))
      (unless file-version
	(signal 'non-version-controlled-file :pathname (or (send-if-handles stream :pathname)
							   stream)))
      (unwind-protect
	  (let*
	    ((parser (make-instance
		       'parser
		       :area (sys:%area-number self)
		       :file-version file-version :stream stream))
	     (header (send parser :read-header)))
	    (trace-encached-file t "Header read: ~S" header)
	    ;; Here is where we check for bad branch-merge records.  Unfortunately,
	    ;; we have to assume that all such records in version 2 VC files are
	    ;; bad, but *user-guarantees-branch-merge-records-are-valid* can be
	    ;; used to tell VC that the records are really OK (for Moon)
	    ;;--- Remove this code someday
	    (when (= (parser-file-version parser) 2)
	      (setf (parser-file-version parser) *latest-encached-file-edition*)
	      (unless *user-guarantees-branch-merge-records-are-valid*
		(setq ignore-branch-merge-records t)))
	    (encached-file-read-header-from-parsed-header self header)
	    (trace-encached-file t "Done reading versions.")
	    1;; 
0	    1;; Authorize stream to give us back instances for diagram lines.
0	    1;;
0	    (send-if-handles stream :set-return-diagrams-as-lines t)
	    
	    1;; Now read in all of the text, building the section info and the
0	    1;; reconstruct info.
0	    1;;
0	    1;; Cons initial-size section and reconsruct tables.
0	    (consing-with-instance
	      (setq section-table (make-section-table (pf-header-n-sections header)))
	      (setq reconstruct-table (make-reconstruct-table (pf-header-n-sections header))))
	    (loop named read-text with state = 'inter-section
		  with section-number = nil
		  with section-info = nil
		  with current-version-number = nil
		  for item = (send parser :read-text-item)
		  do
	      (typecase item
		(symbol (if (eq item :end-of-text) (return-from read-text nil)
			    (error "Unexpected symbol item ~S" item)))
		(encached-control-record 1;; control record
0		  (case state
		    (inter-section
		      (control-record-case item
			(BS 1;; the only one we like!
0			  (setq section-number (cr-section item))
			  (setq section-info 
				(or (aref section-table section-number)
				    (let ((new-section-info
					    (consing-with-instance
					      (make-section-info *initial-section-size*))))	1; a guess
0				      (setf (aref section-table section-number)
					    new-section-info)
				      new-section-info)))
			  (consing-with-instance
			    (push-reconstruct-entry reconstruct-table section-info section-number))
			  (trace-encached-file t "Begin section ~D" section-number)
			  (consing-with-instance
			    (push-section-record section-info item))
			  (setq current-version-number 1)	1; text in each section is version 1
0						1; until a record informs us otherwise.
0			  (setq state 'in-section))			
			(? (error "Unknown control record returned from parser."))
			((BI EI BD ED)
			 (error "Insert/Delete control outside of section."))
			(ES (error "End section outside of section."))))
		    (in-section
		      (control-record-case item
			(BS (error "Begin section ~D before end of section ~D."
				    (cr-section item)
				    section-number))
			(ES (trace-encached-file t "End section ~D, ~D records" section-number
						  (section-info-n-records section-info))
			     (push-section-record section-info item)
			     (setq section-number nil section-info nil
				   state 'inter-section))
			((BI EI BD ED)
			 1;; record the relevant version number
0			 (setq current-version-number (cr-version item))
			 (trace-encached-file t "~A" (-string item))
			 (push-section-record section-info item))))))
		((or instance string) 1;; a simple line or a diagram instance
0		 (unless (eq state 'in-section)
		   (error "Text ~A outside of any section." item))
		 (trace-encached-file t "~A" item)
		 1;; record the section mark in the array.
0		 (push-section-record
		   section-info
		   (if (instancep item)
		       item
		       (let ((new-record
			       1;; cribbed from copy-seq.  
0			       1;; always copy, since the parser returns the same
0			       1;; line over and over again.
0			       1;;--- is this good? should the parser be consing
0			       1;;--- new ones every time, or is it avoiding an allocation
0			       1;;--- in the stream?
0			       (zl:make-array (zl:array-active-length item)
					      :type (1s0ys:array-type-field item)
					      :area (sys:%area-number self))))
			 (copy-array-contents item new-record)
			 new-record))))
		(otherwise 1;; oh dear. What ever is this? (There is no assert of a typep
0		  1;; because the parser does return symbols.)
0		  (error "~S is of type ~S, which the parser should never return."
			 item (type-of item)))))
	    1;; well, everything is now read in up to the end of the text.
0	    (trace-encached-file t "Done reading text.")
	    (read-trailer self parser)
	    (loop for pvi being the array-elements of version-table from 1
		  when pvi
		    do
		      (when (plusp (pv-parent-version pvi))
			(setf (file-version-info-parent-version (pv-version-info pvi))
			      (pv-version-info (aref version-table (pv-parent-version pvi)))))
		      (setf (file-version-info-trailer (pv-version-info pvi))
			    (pv-trailer pvi)))			  
	    (trace-encached-file t "Done reading file."))
	(send-if-handles stream :set-return-diagrams-as-lines old-return-diagrams)))))
(defmethod (read-trailer encached-file) (parser)
  (catch-error-restart ((file-format-error) "Go ahead using the information read so far.")
    (loop named read-trailer for p-trailer = (send parser :read-trailer-item)
	  when (eq p-trailer :end-of-trailers)
	    do (return-from read-trailer nil)
	  do
      (check-type p-trailer parsed-file-trailer)
      (setf (pv-trailer (aref version-table (pf-trailer-version-number p-trailer)))
	    (consing-with-instance
	      (make-file-version-trailer
		:description (pf-trailer-description p-trailer)
		:per-section-array
		(let ((array
			(make-array (length (pf-trailer-per-section-list p-trailer)))))
		  (loop for ps in (pf-trailer-per-section-list p-trailer)
			for x from 0
			do
		    (setf (aref array x)
			  (make-file-version-trailer-ps
			    :section-id (pf-trailer-ps-section-id ps)
			    :description (pf-trailer-ps-description ps))))
		  array)))))))

(defun print- (-record &optional (stream t))
  (format stream "~A ~D~%"
	  (selector (cr-type -record) eql
	    (BI  "BIN")
	    (EI  "EIN")
	    (BD  "BDL")
	    (ED  "EDL")
	    (BS  "BFS")
	    (ES  "EFS")
	    (t (error "Unknown record type ~D" (cr-type -record))))
	  (cr-version -record)))

1;;; Reconsruct the original file from the encached form.

0(defmethod (reconstruct-text encached-file) (stream)
  (format stream "B TEXT ~D~%" (section-table-n-sections section-table))
  (loop for re being the array-elements of reconstruct-table
	as this-section-number = (re-section-number re)
	as this-section-info = (aref section-table this-section-number)
	as this-occurence = (re-occurence re)
	do
    (trace-encached-file :reconstruct-text "Section ~D Occurence ~D~%" this-section-number
			 this-occurence)
    (assert ( this-occurence (section-info-occurence-count this-section-info))
	    (re)
	    "The reconstruct entry ~S has an out-of-bounds occurence reference." re)
    (loop named out-section
	  with efs-record = (make-control-record :type ES :section this-section-number)
	  for record being the array-elements of this-section-info from
	      (find-section-occurence this-section-number this-section-info this-occurence)
	  do
      (assert (typep record 'encached-record) (record)
	      "~S is not a valid record." record)
      (typecase record
	(encached-control-record
	  (print- record stream)
	  (when (-equal-p record efs-record)
	    (return-from out-section nil)))
	(instance (send stream :line-out record))
	(string (format stream "~A~%" record)))))
  (format stream "E TEXT~%"))

(defun find-section-occurence (section-number section-info occurence)
  (loop with bfs-record = 
	  (make-control-record
	    :type BS
	    :section section-number)
	for times from 1 to occurence
	for start = (position bfs-record section-info)
		  then (position bfs-record section-info :start (+ start 1))
	finally (return start)))

(defmethod (reconstruct-version-table encached-file) (stream)
  (format stream "B VTB ~D~%" (version-table-n-versions version-table))
  (loop for pv being the array-elements of version-table from 1
	do
    (if pv
	(format stream "~D ~S ~D ~D ~S ~D~%"
		(pv-parent-version pv)
		(if (and (plusp (pv-parent-version pv))
			 (string-equal		;save space, store "" for non-root entries.
			   (pv-branch-name pv)
			   (pv-branch-name (aref version-table (pv-parent-version pv)))))
		    ""
		    (pv-branch-name pv))
		(pv-branch-version pv)
		(file-version-info-length (pv-version-info pv))
		(file-version-info-author (pv-version-info pv))
		(file-version-info-creation-date (pv-version-info pv))
		)
	(format stream "* (deleted)~%")))
    (format stream "E VTB~%")
  (format stream "* PROPERTIES")
  (with-standard-io-environment
    (print (make-encached-file-properties-1 :properties stored-property-list)
	   stream)
    (format stream "~%")))			; always write that CR, its always read.

(defmethod (reconstruct-trailers encached-file) (stream)
  (format stream "B FTR~%")
  (with-standard-io-environment
    (loop with long-string = (make-array 128. :element-type 'character :fill-pointer 0
					   :adjustable t)
	    for pv being the array-elements of version-table from 1
		   using (index v)
	    as trailer = (and pv (pv-trailer pv))
	    when trailer
	      do
		(setf (fill-pointer long-string) 0)
		(catch-error-restart ((error) "Drop trailer information for version ~A."
				      (pv-version-info pv))
		  (with-output-to-string (string-stream long-string)	
		    (format string-stream "~S " v)
		    (format string-stream "~%")
		    (format string-stream "~S " (or (file-version-trailer-description trailer)
						    ""))
		    (format string-stream "~%")
		    (format string-stream "~S "
			    (length (file-version-trailer-per-section-array trailer)))
		    (format string-stream "~%")
		    (loop for ps being the array-elements of
			      (file-version-trailer-per-section-array trailer)
			  do
		      (unless (numberp (file-version-trailer-ps-section-id ps))
			(error "Non-numeric section id ~S in trailer per section block."
			       (file-version-trailer-ps-section-id ps)))
		      (format string-stream "~S " (file-version-trailer-ps-section-id ps))
		      (format string-stream "~S" (or (file-version-trailer-ps-description ps)
						     ""))
		      (format string-stream "~%")))
		  (format stream "~D~%~A*~%" (length long-string) long-string)))
    (format stream "E FTR~%")))

(defmethod (:reconstruct-file encached-file) (stream)
  (with-encached-file-lock
    (format stream " -*- Version-Control: ~D; -*-~%" *latest-encached-file-edition*)
    (reconstruct-version-table self stream)
    (reconstruct-text self stream)
    (reconstruct-trailers self stream)))

(defmethod (lookup-external-version encached-file-header) (version &key error-p)
  (unless (variable-boundp version-table)
    (if error-p
	(signal 'undefined-file-version :encached-file self :undefined-version version
		:pathname (encached-file-pathname self))
	(return-from lookup-external-version 0)))	
  (loop for pvi being the array-elements of version-table from 1
	when (and pvi
		  (eql (file-version-branch-version version) (pv-branch-version pvi))
		  (string-equal (file-version-branch-name version)
				(pv-branch-name pvi)))
	  do (return (pv-internal-version pvi))
	finally
	  (if error-p
	      (signal 'undefined-file-version :encached-file self :undefined-version version)
	      (return 0))))
(defmethod (encached-file-branch-parent-version encached-file-header) (branch-name)
  (and (variable-boundp version-table)
       (let ((bottom-of-branch
	       (loop for pvi being the array-elements of version-table from 1
		     with min = nil
		     do
		 (when (and pvi
			    (string-equal branch-name (pv-branch-name pvi))
			    (or (null min)
				(< (pv-branch-version pvi)
				   (pv-branch-version min))))
		   (setq min pvi))
		     finally (return min))))
	 (and (plusp (pv-parent-version bottom-of-branch))
	      (pv-version-info (aref version-table (pv-parent-version bottom-of-branch)))))))
;;; Returns the previous version to version.  If version is the root
;;; version of the file or version is undefined, return nil.  If the
;;; branch version is 0, we must be looking at the first version in a
;;; public or private branch.  The previous version of that version is
;;; the parent version of that branch.  If neither of the above is true,
;;; subtract 1 from the version number and return that version.

;;; If version is a file-version-info, return one.  If it is a
;;; file-version, return that

(defmethod (encached-file-previous-version encached-file-header) (version)
  (let ((version-is-a-fvi (eql (type-of version) 'file-version-info))
	(version-array (encached-file-versions self)))
    (cond ((null (version-defined-p self version))	;no such version
	   nil)
	  ((root-version-p self version) nil)	;root version
	  ((= 0 (file-version-branch-version version))	;first version in a branch
	   (let ((parent (encached-file-branch-parent-version
			   self (file-version-branch-name version))))
	     (if version-is-a-fvi
		 (loop for v being the array-elements of version-array
		       until (file-versions-equal v parent)
		       finally (return v))
		 (make-file-version
		   :branch-name (vci::file-version-info-branch-name parent)
		   :branch-version (vci::file-version-info-branch-version parent)))))
	  (t (if version-is-a-fvi
		 (let ((prev-version
			 (make-file-version
			   :branch-name (file-version-branch-name version)
			   :branch-version (1- (file-version-branch-version version)))))
		   (loop for v being the array-elements of version-array
			 until (file-versions-equal v prev-version)
			 finally (return v)))
		 (make-file-version
		   :branch-name (file-version-branch-name version)
		   :branch-version (1- (file-version-branch-version version))))))))
;;; Return a list of file-version-infos that represent the versions of
;;; section-id that have been modified.  If saved-versions is t, return
;;; the version that was created, otherwise, return the version that was
;;; modified to create the new version.  If for-branch is supplied,
;;; return file-version-infos only for that branch.

(defmethod (encached-file-modified-version-list encached-file-header)
	   (section-id &key (saved-versions t) for-branch)
  (let* ((version-array (encached-file-versions self))
	 mod-version)
    
    (loop for version being the array-elements of version-array
		      using (index version-no)
	  as fvi = (make-instance 'encached-file-version-info
				  :encached-file self
				  :version version)
	  as changed-sections = (encached-file-version-info-changed-sections fvi)
	  when (and (aref changed-sections section-id)
		    (if for-branch
			(string-equal (file-version-branch-name version) for-branch)
			t)
		    (setq mod-version (if saved-versions
					  version
					  (encached-file-previous-version self version)))
		    (not (file-versions-equal mod-version (original-version self section-id)))
		    (encached-file-section-not-empty-for-version self section-id mod-version))
	    collect mod-version)))
;;; This code was intended to be called by Show Section Authors which
;;; would produce something along the lines of:
;;;
;;; Function ONE
;;;  was modified by Widzinski on 7/30/87 at 15:09:43 to create version Initial.11
;;;  was merged by Widzinski on 7/30/87 at 15:09:16 to create version Initial.9
;;;  was deleted by Widzinski on 7/30/87 at 15:08:18 to create version Initial.5
;;;  was modified by Widzinski on 7/30/87 at 15:07:59 to create version Initial.4
;;;  was modified by Widzinski on 7/30/87 at 15:07:51 to create version Initial.3
;;;  was created by Widzinski on 7/29/87 at 20:34:02 to create version Initial.0
;;;
;;; There are still problems with merged and modified hard sections.

(defmethod (encached-file-section-history-list encached-file-header)
	   (section-id &key (saved-versions t) for-branch)
  (let* ((version-array (encached-file-versions self)))
    (loop for version being the array-elements of version-array
		      using (index version-no)
	  as fvi = (make-instance 'encached-file-version-info
				  :encached-file self
				  :version version)
	  as changed-sections = (encached-file-version-info-changed-sections fvi)
	  as mod-version = (if saved-versions
					  version
					  (encached-file-previous-version self version))
	  as section-not-empty-for-version =
	     (encached-file-section-not-empty-for-version self section-id mod-version)
	  with section-exists-p = nil
	  with created-or-merged = "created"
	  as verb = (cond ((and (null section-exists-p) section-not-empty-for-version)
			   (setq section-exists-p t) created-or-merged)
			  ((and section-exists-p (null section-not-empty-for-version))
			   (setq section-exists-p nil)
			   (setq created-or-merged "merged")
			   "deleted")
			  ((and section-exists-p section-not-empty-for-version)
			   "modified"))
	  when (and (or (aref changed-sections section-id)
			(string= verb "created"))
		    (if for-branch
			(string-equal (file-version-branch-name version) for-branch)
			t)
		    mod-version)
	    collect (cons verb mod-version))))
1;;; Returns the version in which hard section section-id was last
;;; modified.  If start-version, look for a modified version previous
;;; to this one.  If saved-version, return the version that was created
;;; (saved on disk).  Otherwise, return the version that was modified to
;;; create the version that was saved on disk.

;;; Todos: file-version-lessp does not work right here since it does a
;;; textual comaprison o the branch names and does not look for a branch
;;; that is an ancestor of the start-version branch.  This is wrong.
;;; file-version-lessp should be replaced by something that finds the
;;; nearest branch on the route from start-version to the root node.

0(defmethod (encached-file-last-modified-version encached-file-header)
	   (start-version section-id &key saved-version)
  (let* ((modified-version-list
	   (encached-file-modified-version-list
	     self section-id :saved-versions saved-version))
	 (start-version (loop for v being the array-elements of version-table
			      as fvi = (when v (pv-version-info v))
			      when (and v (file-versions-equal fvi start-version))
				do (return fvi))))

    (loop for version in (reverse modified-version-list)
	  1;; If we find a version that is less than start-version, or if
	  ;; we find a version that is the parent of start-version,
	  ;; return that.
0	  when (or (file-version-lessp version start-version)
		   (file-versions-equal
		     version
		     (file-version-info-parent-version start-version)))
	    do (return version)
	  when found do (return version)
			
          ;; If we find a version equal to start-version, return the next version in the list
	  as found = (file-versions-equal version start-version)
	  finally (return nil))))
(defmethod (original-version encached-file-header) (section-id)
  (loop for version being the array-elements of (encached-file-versions self)
			     when  (encached-file-section-not-empty-for-version
				     self section-id version)
			       do (return version)))

(defmethod (encached-file-header-merge-version encached-file-header) (version)
  (when (null (file-version-branch-name version))
    (setf (file-version-branch-name version)
	  *default-initial-branch-name*		;should be a plist option, but
						;this will do for now.
	  ))
  (unless (numberp (file-version-branch-version version))
    (setf (file-version-branch-version version)
	  (if (not (variable-boundp version-table)) 1	;new file
	      (ecase (file-version-branch-version version)
		((:parent)
		 (return-from encached-file-header-merge-version
		   (or (encached-file-branch-parent-version
			 self
			 (file-version-branch-name version))
		       ;; if no parent, just resort to oldest.
		       (encached-file-header-merge-version 
			 self
			 (make-file-version :branch-name (file-version-branch-name version)
					    :branch-version ':oldest)))))
		((:newest nil)
		 (loop for pvi being the array-elements of version-table from 1
		       when (and pvi
				 (string-equal (file-version-branch-name version)
					       (pv-branch-name pvi)))
			 maximize (pv-branch-version pvi)))
		((:oldest)
		 (loop for pvi being the array-elements of version-table from 1
		       when (and pvi
				 (string-equal (file-version-branch-name version)
					       (pv-branch-name pvi)))
			 minimize (pv-branch-version pvi)))))))
  version)

1;; This method should only be called from the loop macro.

0(defmethod (make-retrieve-continuation encached-file)
	   (version &key
		    (section-marks nil)
		    (one-section nil)
		    (start-section nil start-section-mentioned)
		    (end-section nil end-section-mentioned)
		    )
  (check-type version file-version)
  (let ((i-v (lookup-external-version self version :error-p t)))
    (setq version i-v))
  (when (and one-section
	     (or start-section-mentioned end-section-mentioned section-marks))
    (error "Section boundaries cannot be returned when processing a single section."))
  (flet ((check-section (section)
	   (assert ( 0 section)
		   (section)
		   "The section requested is out of bounds.")))
    (when one-section (check-section one-section))
    (when start-section
      (check-section start-section))
    (when end-section
      (check-section end-section)))
1  ;; calculate the reconstruct path for this version.
0  1;; it will, with any luck, be cached.
0  (let ((reconstruct-path (version-reconstruct-path self version)))
    1;; so much for the preliminaries.  Now on to the hard part, making the closure.
0    1;; We invent one of two different closures.
0    (if one-section
	1;; let ourselves state for this.
0	(let* ((index 0)
	       (ancestor-bitmap (pv-ancestor-bitmap (aref version-table version)))
	       (this-section (aref section-table one-section))
	       (section-bound (section-info-n-records this-section))
	       (this-re (find one-section reconstruct-path :test #'=
			      :key #'re-section-number)))
	  1;; advance index to the correct occurence
0	  (unless this-re (error "Version ~S section ~D not defined in file ~S."
				 version one-section self))
	  (setq index
		(find-section-occurence one-section this-section (re-occurence this-re)))
	  #'(lambda ()
	      (with-encached-file-lock
		(block find-record
		  (when ( index section-bound) (return-from find-record :eof))
		  1;; Return the next live record for this version, or :eof
0		  (loop
              do 1;; this loop provides restart of the inner loop after a skip
0		 (block re-find-record
		   (trace-encached-file
		     :make-retrieve-continuation "re-find-record index: ~D" index)
		   (loop 
			 for record being the array-elements of this-section
			     from index below section-bound using (index idx)
			 do
		     (macrolet
		       ((skip-to (cr)  
			  `(loop 
		              for s-record being the array-elements of this-section
				  from idx using (index s-idx)
			      do
			     (when (eql s-record ,cr)
			       (setq index (+ 1 s-idx))
			       (return-from re-find-record nil))
			      finally (return-from find-record :eof))))
		       (typecase record
			 (encached-control-record
			   (control-record-case (record version)
			     ((BS ES)) 1;; we can ignore these.
0			     (BI  1;; if the inserted region is not an ancestor, skip it.
0			       (trace-encached-file
				 :make-retrieve-continuation
				 "Insert ~D, ancestor: ~S"
				 (cr-version record)
				 (boolean-member-p ancestor-bitmap version))
			       (when 
				 (not (boolean-member-p ancestor-bitmap version))
				 (skip-to
				   (make-control-record
				     :type EI
				     :version version))))
			     (EI) 1;; we can ignore these
0			     (BD
			       (trace-encached-file
				 :make-retrieve-continuation
				 "Delete ~D, ancestor: ~S"
				 (cr-version record)
				 (boolean-member-p ancestor-bitmap version))
			       (when 
				 (boolean-member-p ancestor-bitmap version)
				 (skip-to
				   (make-control-record
				     :type ED
				     :version version))))
			     (ED) 1;; we can ignore these.
0			     (otherwise
			       (error "Unknown control record ~D in encached file." record))))
			 ((or string instance)
			   1;; if we arrive here, we encountered a real record when in a region
0			   1;; that belongs to us. So we return it.
0			   (setq index (+ 1 idx))	1; leave state for the next time
0						1; around.
0			   (return-from find-record record))))
			 finally
			   (setq index section-bound)
			   (return-from find-record :eof)	1; no more records found.
0			   )))))))
	1;; here comes the continuation for the multi-section case.
0	(let* (
	       (returned-first-record (not start-section-mentioned))
	       (ancestor-bitmap (pv-ancestor-bitmap (aref version-table version)))
	       (current-section-number -1) 1;; advanced at first call.
0	       (current-occurence nil)
	       (current-section-info nil)
	       (current-record-index -1)
	       (at-end-of-section t) 1;; so that we bump along.
0	       (reconstruct-point -1) 1;; advanced at first call.
0	       (current-reconstruct-entry nil)
	       (stop-record (and end-section-mentioned
				 (make-control-record :type ES :section end-section)))
	       (efs-record nil)		      
	       (deferred-bfs nil)
	       1;; when this is non-null, return this if we find an0 1actual
0	       1;; record in the section.
0	       )
	  #'(lambda ()
	      (with-encached-file-lock		1; holding the lock for the entire retrieve
0						1; would be safer, performance nasty without multi-reader locking.
0		(loop named return-record
		      do
		  (trace-encached-file
		    :make-retrieve-continuation
		    "return-record: returned-first-record: ~S current-section-number ~D current-occurence ~D reconstruct-point ~D reconstruct table length ~D at-end-of-section ~S"
		    returned-first-record
		    current-section-number
		    current-occurence
		    reconstruct-point
		    (length reconstruct-path)
		    at-end-of-section)
		  (block restart-find 1;; return from this to find the next section.
0		    1;; or to restart the record loop after a skip.
0		    (when at-end-of-section
		      1;; when we have returned no records, we have to keep
0		      1;; winding the reconstruct0 1array until we get the
0		      1;; right section 0and 1its nonempty.
0		      (incf reconstruct-point)
		      (when ( reconstruct-point (length reconstruct-path))
			(trace-encached-file
			  :make-retrieve-continuation
			  "reconstruct-point ~D out of reconstruct-path (length ~D)"
			  reconstruct-point (length reconstruct-path))
			(unless returned-first-record
			  (error "Never found specified section."))
			(return-from return-record :eof))
		      (setq current-reconstruct-entry
			    (aref reconstruct-path reconstruct-point)
			    current-section-number (re-section-number current-reconstruct-entry)
			    current-section-info (aref section-table current-section-number)
			    current-occurence (re-occurence current-reconstruct-entry))
		      (unless (or returned-first-record
				  (= current-section-number start-section))
			(return-from restart-find nil))
		      1;; now we have found ourselves at the first section. Now we hunt
0		      1;; up the current occurrence.
0		      (assert ( current-occurence
				 (section-info-occurence-count current-section-info))
			      (current-reconstruct-entry) 
			      "The reconstruct entry ~S has an out-of-bounds occurence reference."
			      current-reconstruct-entry)
		      (setq current-record-index
			    (find-section-occurence current-section-number
						    current-section-info current-occurence))
		      (trace-encached-file
			:make-retrieve-continuation
			"new section ~D occurence ~D index ~D"
			current-section-number current-occurence current-record-index)
		      (setq at-end-of-section nil)
		      (when section-marks
			(setq deferred-bfs (make-section-boundary-blip
					      :begin-section-id current-section-number)))
		      (setq efs-record
			    (make-control-record :type ES :section current-section-number))
		      )
		    
		    1;; ok, we are looking at some record.0  1if we haven't
0		    1;; returned the first record, its guaranteed to be0 1a
0		    1;; begin section mark.0  1we start looking for a record to
0		    1;; return.0  1If we hit the end of the section before
0		    1;; returning0 1a record, we 0return-from1 0restart-find1 to
0		    1;; try the next reconstruct0 1entry.0 
		    
		    (loop for record being the array-elements of current-section-info
			      from current-record-index
				     using (index current-record-idx)
			  do
		      (macrolet
			((skip-to (cr)
			   `(loop 
   		          for s-record being the array-elements of current-section-info
			      from current-record-idx
				       using (index s-idx)
			  do
			      (when (eql s-record ,cr)
				(setq current-record-index (+ 1 s-idx))
				(return-from restart-find nil))
			  finally
			    (trace-encached-file
			      :make-retrieve-continuation "skip-to failed to find ~A"
			      (-string ,cr))
			    (return-from return-record :eof))))
			(assert (typep record 'encached-record) (record)
				"~S is not a valid record." record)
			(typecase record
			  (encached-control-record
			    (trace-encached-file
			      :make-retrieve-continuation "control record ~A" (-string record))
			    1;; pick up some special terminating cases.
0			    (when (and stop-record (-equal-p record stop-record))
			      (trace-encached-file
				:make-retrieve-continuation "Found stop-record ~A" (-string stop-record))
			      (return-from return-record :eof))
			    (when (-equal-p record efs-record)
			      (setq at-end-of-section t)
			      (return-from restart-find nil))
			    1;; not special, just check out the ordinary circumstances.
0			    (control-record-case (record version)
			      (BS) 1;; we can ignore these.
0			      (ES
				(error "ES for the wrong section."))
			      (BI  1;; if the inserted region is not an ancestor, skip it.
0				(trace-encached-file
				  :make-retrieve-continuation
				  "~A ancestor: ~S" (-string record)
				  (boolean-member-p ancestor-bitmap version))
				(when 
				  (not (boolean-member-p ancestor-bitmap version))
				  (skip-to
				    (make-control-record
				      :type EI
				      :version version))))
			      (EI) 1;; we can ignore these
0			      (BD	
				(when 
				  (boolean-member-p ancestor-bitmap version)
				  (skip-to
				    (make-control-record
				      :type ED
				      :version version))))
			      (ED) 1;; we can ignore these.
0			      (otherwise
				(error "Unknown control record ~D in encached file." record))))
			  ((or string instance) 1;; its a vanilla string
0			    1;; if we held off returning a section boundary to see if there would
0			    1;; be anything in the section, return it now and return the string
0			    1;; the next time.
0			    (when deferred-bfs
			      (return-from return-record (shiftf deferred-bfs nil)))
			    1;; otherwise, advance our idea of where we are, and then
0			    1;; return the record.
0			    (setq current-record-index (+ 1 current-record-idx))
			    (when ( current-record-index (length current-section-info))
			      (error
				"Ran off of the end of the section without encountering ES"))
			    (setq returned-first-record t)	1; we returned at least one.
0			    (return-from return-record record)))))))))))))

(defun section-not-empty-for-version-internal (ancestor-bitmap
					       section-number
					       section-info
					       occurence)
  (assert ancestor-bitmap () "section-not-empty-for-version with nil ancestor-bitmap")
  (loop named section-not-empty-for-version
	with efs-record = (make-control-record :type ES :section section-number)
	with skipping-to = nil
	for record being the array-elements of section-info
	    from (+ 1 (find-section-occurence section-number section-info occurence))
	         ; skip the BS record.
	until (and (typep record 'encached-control-record) (-equal-p record efs-record))
	do
    (if skipping-to (when (and (typep record 'encached-control-record)
			       (-equal-p record skipping-to))
		      (setq skipping-to nil))
	(typecase record
	  (encached-control-record
	    (control-record-case (record version)
	      ((BS ES)
	       (error "~A invalid where found." (-string record)))
	      ((EI ED)) ;; these are ignored here, caught by skip-case.
	      (BI
		(unless (boolean-member-p ancestor-bitmap version)
		  (setq skipping-to (make-control-record :type EI
							 :version version))))
	      (BD
		(when (boolean-member-p ancestor-bitmap version)
		  (setq skipping-to (make-control-record :type ED
							 :version version))))))
	  (string ;; we only get here if there was a real-live text line for this version in
	    ;; the section.
	    (return-from section-not-empty-for-version t))))
	finally (return nil)))
1;;; Method that figures out the path for reconstructing a particular version.

0(defmethod (version-reconstruct-path encached-file) (version)
  (let ((pvi (aref version-table version)))
    (or (pv-version-reconstruct-path pvi)
	(let ((re-array (make-array
			  (section-table-n-sections section-table)
			  :area (sys:%area-number self)
			  :fill-pointer 0)))
	  (ensure-ancestor-bitmap self pvi)
	  (loop with sections-seen = (make-array (section-table-max-n-sections section-table)
						 :element-type 'boolean :initial-element nil)
		with ancestor-bitmap = (pv-ancestor-bitmap pvi)
		for re being the array-elements of reconstruct-table
		as section-number = (re-section-number re)
		as section-info = (aref section-table section-number)
		as occurence = (re-occurence re)
		when (and (not (aref sections-seen section-number))
			  (section-not-empty-for-version-internal
			    ancestor-bitmap section-number section-info occurence))
		  do
		    (vector-push-carefully re re-array)
		    (setf (aref sections-seen section-number) t))
	  (setf (pv-version-reconstruct-path pvi)
		re-array)))))

(defmethod (encached-file-section-not-empty-for-version encached-file)
	   (section-number version)
  (when ( section-number (zl:array-length section-table))
    (let ((internal-version (lookup-external-version self version :error-p t)))
      (let ((pvi (aref version-table internal-version))
	    (section-info (aref section-table section-number)))
	(ensure-ancestor-bitmap self pvi)
	(some
	  #'(lambda (re)
	      (and (= (re-section-number re) section-number)
		   (section-not-empty-for-version-internal
		     (pv-ancestor-bitmap pvi)
		     section-number
		     section-info
		     (re-occurence re))))
	  reconstruct-table)))))

(defmethod (encached-file-per-version-info encached-file-header) (internal-version)
  (aref version-table internal-version))

(defmethod (encached-file-per-section-info encached-file) (section-x)
  (aref section-table section-x))
(defmethod (encached-file-parent-version-p encached-file-header)
	   (version putative-parent-version)
  (let ((internal-version (lookup-external-version self version :error-p t))
	(internal-pa-version
	  (lookup-external-version self putative-parent-version :error-p t)))
    (= internal-pa-version
       (pv-parent-version (aref version-table internal-version)))))
(defmethod (encached-file-ancestor-version-p encached-file-header)
	   (version putative-ancestor-version)
  (let ((internal-version (lookup-external-version self version :error-p t))
	(internal-pa-version
	  (lookup-external-version self putative-ancestor-version :error-p t)))
    (loop with pa-pv = (aref version-table internal-pa-version)
	  for version = (pv-parent-version (aref version-table internal-version))
		      then (pv-parent-version pv)
	  as pv = (and (plusp version) (aref version-table version))
	  while pv
	  when (eq pv pa-pv)
	    do (return-from encached-file-ancestor-version-p t)
	  finally (return-from encached-file-ancestor-version-p nil))))

(defmethod (encached-file-find-common-ancestor encached-file) (v1 v2)
  1;; list the ancestors of each, intersect, and find the latest.
0  (let ((v1-i (lookup-external-version self v1))
	(v2-i (lookup-external-version self v2)))
    (let ((v1-a (loop for v = v1-i then (pv-parent-version pv)
		      as pv = (and (plusp v) (aref version-table v))
		      while pv collect v)))
      (loop for v = v2-i then (pv-parent-version pv)
	    as pv = (and (plusp v) (aref version-table v))
	    when (and pv (member v v1-a :test #'=))
	      do (return (make-file-version
			   :branch-name (pv-branch-name pv)
			   :branch-version (pv-branch-version pv)))
	    finally (return nil)))))
(defmethod (encached-file-version-section-order encached-file) (version)
  (setq version (lookup-external-version self version :error-p t))
  (let ((reconstruct-path (version-reconstruct-path self version)))
    (loop for re being the array-elements of reconstruct-path
	  collect (re-section-number re)))) 
1;;; For merging and other purposes, it is necessary to calculate the reconstruct information
;;; for a version (and possibly some of its ancestors) and hang on to it for multiple
;;; references.  This flavor also contains methods to answer necessary queries based
;;; on the data in it.

0(defflavor encached-file-version-info
	(encached-file
	 version-pv
	 relevant-ancestor-version-pv1	;all versions between this and version are needed
0	 this-reconstruct-path
	 sections-changed-since-relevant-ancestor
	 ancestor-version-list			1;list of internal version numbers,
0						1;in order
0	 )	 
	()
  (:init-keywords :version :relevant-ancestor-version)
  (:initable-instance-variables encached-file)
  (:readable-instance-variables
   (encached-file-version-info-changed-sections
     sections-changed-since-relevant-ancestor)
   (encached-file-version-info-reconstruct-path this-reconstruct-path))
  (:documentation "Flavor used as the official datum handed out to optimize
repeated operations on the same version of the file.  This needs a timestamp
at some point, for now the caller must be sure not to hang on across modifications."))

(defmethod (make-instance encached-file-version-info)
	   (&key ((:version a-version))
		 ((:relevant-ancestor-version a-relevant-ancestor-version))
		 &allow-other-keys)
  (check-type a-version file-version)
  (check-type a-relevant-ancestor-version (or null file-version))
  (setq version-pv (lookup-external-version encached-file a-version :error-p t))
  (setq version-pv (encached-file-per-version-info encached-file version-pv))
  (setq relevant-ancestor-version-pv
	(and a-relevant-ancestor-version
	     (lookup-external-version encached-file a-relevant-ancestor-version)))
  (when relevant-ancestor-version-pv
    (if (plusp relevant-ancestor-version-pv)
	(setq relevant-ancestor-version-pv
	      (encached-file-per-version-info encached-file relevant-ancestor-version-pv))
	(error "Version ~A is not defined." a-relevant-ancestor-version)))
  (setq ancestor-version-list (list (pv-internal-version version-pv)))
  1;; chase back up ancestors
0  (when relevant-ancestor-version-pv
    (loop with got-to-the-bottom-of-this = nil
	  for version = (pv-parent-version version-pv) then (pv-parent-version pv)
	  as pv = (and (plusp version) (encached-file-per-version-info encached-file version))
	  while pv
	  until got-to-the-bottom-of-this
	  do
      (if (eq pv relevant-ancestor-version-pv)
	  (setq got-to-the-bottom-of-this t)
	  (push (pv-internal-version pv) ancestor-version-list))
	  finally (unless got-to-the-bottom-of-this
		    (error "~A is not an ancestor of ~A."
			   a-relevant-ancestor-version a-version))))
  (setq ancestor-version-list (nreverse ancestor-version-list))
  1;; the single most useful fact that one of these things knows is the identity
0  1;; of all sections changed in the version from relevant-ancestor through this one.
0  1;; a change in a section is detected via the presence of delete or insert control
0  1;; records for the version in question in the section.  Note that 
0  1;; moving a section appears to change it, because the entire text is deleted from the
0  1;; old location and inserted in the new one.  No substructure is maintained.  We could 
0  1;; distinguish this be doing actual string comparisons, but that is just the same
0  1;; work as compare-merge will do if we report it as modified.
0  (setq sections-changed-since-relevant-ancestor
	(make-array (send encached-file :number-of-sections) :element-type 'boolean
		    :initial-element nil))
  1;; reconstruct-paths is the list, in order, of parent versions.
0  (loop for prev-reconstruct-array = nil then reconstruct-array
	for version in ancestor-version-list
	as reconstruct-array = (version-reconstruct-path encached-file version)
	do
    (loop for section-x from 0 below (send encached-file :number-of-sections)
	  as section-info = (and
			      (not
				(aref sections-changed-since-relevant-ancestor section-x))
			      (encached-file-per-section-info encached-file section-x))
	     when section-info
	       do
		 (loop for record being the array-elements of section-info
		       when (and (typep record 'encached-control-record)
				 (= (cr-version record) version)
				 1;; the following isn't optimized.
0				 1;;0(member (cr-type record) `(,BI ,1BD0) :test #'=)
				 (let ((type (cr-type record)))
				   (or (= type BI)
				       (= type BD))))
			 do
			   (setf (aref sections-changed-since-relevant-ancestor section-x) t)
			   (return nil)))))

1;;;--- flush this in favor of the method on encached-file above.
0(defmethod (encached-file-version-info-section-order encached-file-version-info)
	   (&key version)
  (when (null version)
    (setq version (pv-version-info version-pv)))
  (unless (numberp version)
    (setq version (lookup-external-version encached-file version :error-p t)))
  (let ((reconstruct-path (version-reconstruct-path encached-file version)))
    (loop for re being the array-elements of reconstruct-path
	  collect (re-section-number re))))

(defmethod (encached-file-version-info-section-order-changed-p encached-file-version-info)
	   (&key version)
  (when (null version)
    (setq version (pv-version-info version-pv)))
  (unless (numberp version)
    (setq version (lookup-external-version encached-file version :error-p t)))
  (when relevant-ancestor-version-pv
    (not (equal (encached-file-version-info-section-order
		  self :version (pv-internal-version relevant-ancestor-version-pv))
		(encached-file-version-info-section-order self :version version)))))
(defmethod (encached-file-version-info-defined-sections-map encached-file-version-info)
	   (&key version)
  (when (null version)
    (setq version (pv-version-info version-pv)))
  (unless (numberp version)
    (setq version (lookup-external-version encached-file version :error-p t)))
  (let ((max-s (reduce #'max (encached-file-version-info-section-order self :version version)
		       :initial-value 0)))
    (let ((bitmap (make-array (1+ max-s) :element-type 'boolean :initial-element nil)))
      (loop for x in (encached-file-version-info-section-order self :version version)
	    do (setf (aref bitmap x) t))
      bitmap)))
1;;; ç-making, or, making a new version.  To make a new version, the user
;;; of the0 1encached file supplies the parent version of the new version
;;; and a data structure0 1describing the changes.  The data structure
;;; must be an array with as least as many elements0 1as there are
;;; sections0 1in the parent version0.   1Each element in the array
;;; specifies the disposition0 1of that section.0  1This insists that the
;;; new version have a parent.  We do not support0 1multiple completely
;;; independent texts in a file, at least yet.

0(defmethod (add-new-version encached-file) (parent-version
					     external-version
					     ç-section-array
					     trailer)
  (declare (values new-version))
  (check-type parent-version file-version)
  (check-structure-type trailer file-version-trailer)
  (check-type external-version file-version-info)
  (with-encached-file-lock
    (when (plusp (lookup-external-version self external-version))
      (error "Attempt to make duplicate version ~A" external-version))
    (setq parent-version
	  (let ((internal-parent-version
		  (lookup-external-version self parent-version :error-p t)))
	    internal-parent-version))
    (ensure-ancestor-bitmap self (aref version-table parent-version))
    (let* ((new-version
	     (allocate-new-version self parent-version external-version))
	   (new-version-number (pv-internal-version new-version))
	   (parent-reconstruct-path (version-reconstruct-path self parent-version))
	   (ç-restart 0)
	   (parent-restart 0)
	   (deferred-insertion-q nil)
	   (deferred-deletion-q nil)
	   )
      (setf (pv-trailer new-version) (copy-file-version-trailer trailer))
      (setf (file-version-info-trailer
	      (pv-version-info new-version)) (pv-trailer new-version))
      (loop named make-new-version
	    do
	(block restart-loop
	  (loop for ç being the array-elements of ç-section-array
		    from ç-restart using (index ç-index)
		and for pre being the array-elements of parent-reconstruct-path
		    from parent-restart using (index parent-index)
		as ç-sid = (ç-section-section-id ç)
		as new-p = (eq :new ç-sid)
		as p-sid = (re-section-number pre)
		as ç-old-occurence = (and (not new-p)
					  (let ((old-re
						  (if (= p-sid ç-sid)
						      pre
						      (find ç-sid parent-reconstruct-path
							    :key #'re-section-number
							    :test #'=))))
					    (if old-re
						(re-occurence old-re)
						:resurrection)))
		as deferred-pre = nil
		do
	    (trace-encached-file 'add-new-version "ç-sid ~S p-sid ~S" ç-sid p-sid)
	    (when (and (ç-section-new-version-interval ç)
		       1;; not :deleted
0		       (typep (ç-section-new-version-interval ç) 'zwei:interval)
		       (zwei:bp-= (zwei:interval-first-bp (ç-section-new-version-interval ç))
				  (zwei:interval-last-bp (ç-section-new-version-interval ç))))
	      (error "Null interval supplied for new-version-interval. This isn't valid."))
	    (cond
	      ((eq ç-old-occurence :resurrection)
	       ;;we need a new occurence because this section wasn't in the parent at all.
	       ;;so it is effectively deleted from the parent already, we just add it back.
	       (trace-encached-file
		 'add-new-version "Resurrection: making a new occurence of section ~D" ç-sid)
	       (unless (eq (ç-section-new-version-interval ç) :deleted)
		 (let ((si (make-new-occurence
			     (aref section-table ç-sid)
			     nil		; no occurence that needs deleting.
			     ç-sid
			     new-version
			     (ç-section-new-version-interval ç))))
		   (setf (aref section-table ç-sid) si)
		   (consing-with-instance
		     (insert-into-vector
		       (make-reconstruct-entry :section-number ç-sid
					       :occurence (section-info-occurence-count si))
		       (if pre (position pre reconstruct-table :test #'eq)
			   (length reconstruct-table)	; at the end
			   )
		       reconstruct-table))))
	       (setq ç-restart (+ ç-index 1)	; we used up that one
		     parent-restart parent-index)
	       (return-from restart-loop nil))
	      
	      ((and (not new-p) (= p-sid ç-sid))
	       ;; section numbers are in-synch
	       (trace-encached-file 'add-new-version "In synch.")
	       (when (ç-section-new-version-interval ç)	; only bother if munged
		 (ç-one-section self (aref version-table parent-version)
				new-version-number pre ç)))
	      
	      (new-p
	       (trace-encached-file 'add-new-version "Inserting new section")
	       (insert-new-section self new-version-number pre ç)
	       (setq ç-restart (+ ç-index 1)	; we used up that one
		     parent-restart parent-index)	; but we haven't used that one up.
	       (return-from restart-loop nil))	; and try again.
	      
	      
	      ((setq deferred-pre
		     (car (member ç-sid deferred-insertion-q
				  :test #'= :key #'re-section-number)))
	       (trace-encached-file 'add-new-version
				    "on deferred insert q")
	       (if (eq (ç-section-new-version-interval ç) :deleted)
		   (delete-section self new-version-number deferred-pre)
		   (move-section self new-version (re-occurence deferred-pre) pre ç))
	       (setq deferred-insertion-q
		     (delete ç-sid deferred-insertion-q
			     :test #'= :key #'re-section-number))
	       (setq ç-restart (+ 1 ç-index)
		     parent-restart parent-index)
	       (return-from restart-loop nil))
	      
	      ((member p-sid deferred-deletion-q :test #'=)
	       ;; this parent section was previously seen on the ç side
	       ;; and inserted or deleted.  The new occurence has already been built,
	       ;; if one was needed (not a deletion).
	       ;; so all we have to do is to delete it from the queue and
	       ;; skip it.
	       (trace-encached-file 'add-new-version "on deferred deletion q")
	       (setq deferred-deletion-q
		     (delete ç-sid deferred-deletion-q :test #'=))
	       (setq ç-restart ç-index
		     parent-restart (+ 1 parent-index))
	       (return-from restart-loop nil))
	      
	      ;; so much for the easy cases. Here we have to analyze a difference.	    
	      (t	    
	       (trace-encached-file 'add-new-version "Out of synch")
	       (let ((parent-in-new 
		       (position p-sid ç-section-array :key #'ç-section-section-id
				 :start (+ 1 ç-index)))
		     (new-in-parent 
		       (position ç-sid parent-reconstruct-path :key #'re-section-number
				 :test #'=
				 :start (+ 1 parent-index))))
		 (trace-encached-file 'add-new-version "new-in-parent ~S parent-in-new ~S"
				      parent-in-new new-in-parent)
		 
		 (cond ((and parent-in-new
			     (eq (ç-section-new-version-interval
				   (aref ç-section-array parent-in-new))
				 :deleted))	; we found it, but its going thataway
			;; wait for the kid to come around later to do the delete.
			(push pre deferred-insertion-q) 
			(setq ç-restart ç-index
			      parent-restart (+ parent-index 1))
			(return-from restart-loop nil))
		       ((null parent-in-new)
			;; this section has disappeared altogether,
			;; since if it appeared previously we would have
			;; pushed it onto the deferred list.
			(delete-section self new-version-number pre)
			(setq ç-restart ç-index
			      parent-restart (+ parent-index 1))
			(return-from restart-loop nil))
		       ((null new-in-parent)
			;; This section has no business not being found.  If it 
			;; turned up earlier in the parent, then we should have
			;; skipped along the parent until we got to it.
			(error "Section ~D in new version not found in parent." ç-sid))
		       (( (- parent-in-new ç-index)
			   (- new-in-parent parent-index))
			;;
			;;  P    ç
			;;----------
			;;      A
			;;  ...  ...
			;;  ...  
			;;  A    ...
			;;
			;; We have to skip less to get to  on the ç side
			;; than to get to A on the P(arent) side.  So we create less
			;; disruption if we insert A-> into the sequence here
			;; and delete them wherever else they turn up
			;; than if we delete ->A here and insert them later.
			(if (eq (ç-section-new-version-interval ç) :deleted)
			    (delete-section self new-version-number pre)
			    (move-section self new-version ç-old-occurence pre ç))
			(push ç-sid deferred-deletion-q)	; this section is all
						; taken care of. It can be
						; skipped when encountered.
			(setq ç-restart (+ 1 ç-index)
			      parent-restart parent-index)
			(return-from restart-loop nil))
		       (t
			;; the section on the parent side is moving forward,
			;; but we don't know where yet. push it onto the
			;; deferred insertion list, and skip it.
			(push pre deferred-insertion-q)
			(setq ç-restart ç-index
			      parent-restart (+ 1 parent-index))
			(return-from restart-loop nil))))))
		finally
		  (if (< ç-index (length ç-section-array))
		      (progn
			(trace-encached-file
			  'add-new-version "Processing tail of ç-section-array")
			(loop for ç being the array-elements of ç-section-array
				  from ç-index
			      as ç-sid = (ç-section-section-id ç)
			      as pre = nil
			      do
			  ;;; a bunch of ç entries with no corresponding old entries.  all
			  ;;; of these must either be on the deferred Q, be :new, or were
			  ;;; added in the source branch during its evolution
			  
			  (trace-encached-file 'add-new-version "~S" ç)
			  (cond
			    ((eq ç-sid :new)
			     (insert-new-section self new-version-number nil ç))
			    ((setq pre
				   (car (member ç-sid deferred-insertion-q
						:test #'= :key #'re-section-number)))
			     (trace-encached-file 'add-new-version
						  "on deferred insert q")
			     (if (eq (ç-section-new-version-interval ç) :deleted)
				 (delete-section self new-version-number pre)
				 (move-section self new-version (re-occurence pre)
					       nil ç))
			     (setq deferred-insertion-q
				   (delete ç-sid deferred-insertion-q 
					   :test #'= :key #'re-section-number)))
			    ((neq (ç-section-new-version-interval ç) :deleted)
			     ;; Section must have been added and evolved in source branch
			     (let ((si (make-new-occurence
					 (aref section-table ç-sid)
					 nil	; no occurence that needs deleting.
					 ç-sid
					 new-version
					 (ç-section-new-version-interval ç))))
			       (setf (aref section-table ç-sid) si)
			       (consing-with-instance
				 (insert-into-vector
				   (make-reconstruct-entry
				     :section-number ç-sid
				     :occurence (section-info-occurence-count si))
				   (length reconstruct-table)	; at the end
				   reconstruct-table))))
			    (t
			     (trace-encached-file
			       'add-new-version
			       "Resurrection: making a new occurence of section ~D" ç-sid)
			     
			     (error "Section ~D neither new nor in parent." ç-sid)))))
		      
		      (when (< parent-index (length parent-reconstruct-path))
			;; some number of parents never turned up in the new version.
			;; If they are in the deferred deletion Q, fine.
			;; If not, they have to be deleted.
			(trace-encached-file 'add-new-version
					     "Processing tail of parent path.")
			(loop for pre being the array-elements of
				  parent-reconstruct-path
				  from parent-index
			      do
			  (trace-encached-file 'add-new-version "~S" pre)
			  (if (member (re-section-number pre)
				      deferred-deletion-q
				      :test #'=)
			      (progn
				(trace-encached-file 'add-new-version
						     "on deferred delete q")
				(setq deferred-deletion-q (delete (re-section-number pre)
								  deferred-deletion-q
								  :test #'=)))
			      (trace-encached-file 'add-new-version
						   "deleting explicitly")
			      (delete-section self new-version-number pre)))))
		  (return-from make-new-version nil))))
      (loop for ps being the array-elements of (file-version-trailer-per-section-array
						 (pv-trailer new-version))
	    do (setf (file-version-trailer-ps-section-id ps)
		     (ç-section-section-id (file-version-trailer-ps-section-id ps))))
      (consing-with-instance
	(make-file-version :branch-name (pv-branch-name new-version)
			   :branch-version (pv-branch-version new-version))))))
(defsubst full-string= (s1 s2)
  (if (or (instancep s1) (instancep s2))
      (and (instancep s1) (instancep s2)
	   (string= (or (send-if-handles s1 :string-for-file) "")
		    (or (send-if-handles s2 :string-for-file) "")))
      (string= s1 s2)))
1;;; Create a new section-info array for this section, copy the occurences other
;;; than the relevant one, compute ç's for the relevant one.

;;; The following is a slight cons-pig.

;;; First, it finds the occurence of note in the encached copy of the section.
;;; Then, it begins to compare the old version to the new version.
;;; As soon as it finds a discrepancy, it conses a list of all of the records
;;; from the beginning of the occurence to the discrepancy.  It then collects
;;; onto the end of that list the remainder of the occurence, including
;;; new ç control records as needed.  Then it makes a new section-info array,
;;; copies the records into it, and abandons the old one as garbage. 
;;; Perhaps there should be an ephemeral area around for all of this?
;;;
;;; A further complication, of course, is walking the ç records in the occurence.
;;; which was completely screwed up.0						

(defun search-in-interval (search-for search-from end-line include-end-line)
  1;;; returns LINE that matches. is there a ZWEI primitive for this?
0  (trace-encached-file t "for ~A from ~A before ~A" search-for search-from end-line)
  (loop with returned-last-line = (not include-end-line)
	for test-line = search-from then (zwei:line-next test-line)
	for depth from 0
	never (and returned-last-line (eq test-line end-line))
	do
    (trace-encached-file t "search-in-interval: int test: ~A" test-line)
    (when (eq test-line end-line)
      (setq returned-last-line t))
    (when (full-string= search-for (or (zwei:line-diagram test-line) test-line))
      (return (values test-line depth)))
    1;; If we have searched for the last line, we are really done.
0	never (eq test-line end-line)))

(defun search-in-section-info (search-for search-from section-info section-info-ES
			       parent-version-ancestors)
  (loop with tindex = search-from
	as test-line = (aref section-info tindex)
	for depth from 0
	never ( tindex section-info-ES)
	do
    (block found-cr-restart-loop
      (when (typep test-line 'encached-control-record)
	(flet ((skip-to (cr)
		 (declare (sys:downward-function))
		 (loop for x from (+ 1 tindex)
		       when ( tindex section-info-ES)
			 do (error "Ran off of the end of ~S looking for ~A."
				   section-info (-string cr))
		       when (eql cr (aref section-info x))
			 do
			   (setq tindex (+ 1 x))
			   (return-from found-cr-restart-loop)))
	       (skip-this ()
		 (declare (sys:downward-function))
		 (incf tindex)
		 (return-from found-cr-restart-loop)))
	  (control-record-case (test-line cr-version)
	    ((BS ES EI ED) (skip-this))
	    (BI (if (boolean-member-p parent-version-ancestors cr-version)
		     (skip-this)
		     (skip-to (make-control-record :type EI :version cr-version))))
	    (BD (if (boolean-member-p parent-version-ancestors cr-version)
		     (skip-to (make-control-record :type ED :version cr-version))
		     (skip-this))))))
      (when (full-string= search-for test-line)
	(return (values tindex depth)))
      (incf tindex))
	finally (return nil)))

(defun search-for-matches (parent-version-ancestors section-info
			   start-recordx section-info-ES
			   start-line end-line include-end-line)
  (declare (values last-record-to-delete-x last-line-to-insert))
  1;; working progressively down in depth, look for an entry on one side that turns
0  1;; up on the other.  If only one side provides such a match at a given level,
0  1;; take it.  If both sides do, compare size of the ç.
0  (loop with returned-last-line = (not include-end-line)
	with oldx = start-recordx
	with new-line = start-line
	never ( oldx section-info-ES)
	never (and (eq new-line end-line) returned-last-line)
	as old-record = (aref section-info oldx)
	do
    (when (eq new-line end-line) (setq returned-last-line t))	1;note that is has been used.
0    (block found-cr-restart-loop
      1;; we have to do  record analysis on old-record, which can indeed be control
0      1;; record.  We have to do the usual skipping kinds of things.
0      (when (typep old-record 'encached-control-record)
	(flet ((skip-to (cr)
		 (declare (sys:downward-function))
		 (loop for x from (+ 1 oldx)
		       when ( oldx section-info-ES)
			 do (error "Ran off of the end of ~S looking for ~A."
				   section-info (-string cr))
		       when (eql cr (aref section-info x))
			 do
			   (setq oldx (+ 1 x))
			   (return-from found-cr-restart-loop)))
	       (skip-this ()
		 (declare (sys:downward-function))
		 (incf oldx)
		 (return-from found-cr-restart-loop)))
	  (control-record-case (old-record cr-version)
	    ((BS ES EI ED) (skip-this))
	    (BI (if (boolean-member-p parent-version-ancestors cr-version)
		     (skip-this)
		     (skip-to (make-control-record :type EI :version cr-version))))
	    (BD (if (boolean-member-p parent-version-ancestors cr-version)
		     (skip-to (make-control-record :type ED :version cr-version))
		     (skip-this))))))
      1;; at this point, we are about to make use of new-line.  We only can make use
0      1;; of it once in the search-in-interval below (or zero times if
0      1;; include-end-line was nil.)
0      (setq returned-last-line (eq new-line end-line))
      (trace-encached-file t "searching: old: ~S (~S) new: ~S"
			   oldx old-record new-line)
      (multiple-value-bind (old-in-new old-in-new-depth)
	  (search-in-interval old-record new-line end-line include-end-line)
	(multiple-value-bind (new-in-old new-in-old-depth)
	    (search-in-section-info new-line oldx section-info section-info-ES
				    parent-version-ancestors)
	  (cond ((and (null old-in-new) (null new-in-old))	1; no match at all
0		 (unless (eq new-line end-line)
		   (setq new-line (zwei:line-next new-line)))	1;the top of the loop catches the termination
0		 (incf oldx))					1;ditto.
0		((and old-in-new (or (null new-in-old) ( old-in-new-depth new-in-old-depth)))
		 (return-from search-for-matches
		   (values
		     (if (= oldx start-recordx) nil (- oldx 1))
		     (if (eq old-in-new start-line) nil
			 (zwei:line-previous old-in-new)))))
		(t
		 (return-from search-for-matches
		   (values
		     (if (= new-in-old start-recordx) nil
			 (- new-in-old 1))
		     (if (eq new-line start-line) nil
			 (zwei:line-previous new-line))))))))))
  1;; if we arrive here, then we ran out of text without matching at all.
0  (return-from search-for-matches (values (- section-info-ES 1)
					  (if include-end-line
					      end-line
					      (if (neq start-line end-line)
						  (zwei:line-previous end-line)
						  nil)))))

(defmethod (ç-one-section encached-file) (parent-version
					   new-version
					   parent-re
					   ç-section-info)
  (block ç-one-section
    (when (eq (ç-section-new-version-interval ç-section-info) :deleted)
      (delete-section self new-version parent-re)
      (return-from ç-one-section nil))
    (let* ((old-si (aref section-table (re-section-number parent-re)))
	   (occurence (re-occurence parent-re))
	   (new-interval (ç-section-new-version-interval ç-section-info))
	   (new-line (zwei:bp-line (zwei:interval-first-bp new-interval)))
	   1;; the to index of the last bp must be 0, and so we stop with
0	   1;; the line before.
0	   (last-new-line (zwei:line-previous
			    (zwei:bp-line (zwei:interval-last-bp new-interval))))
	   (returned-last-line-contents nil)
	   (first-record
	     (find-section-occurence (re-section-number parent-re) old-si occurence))
	   (cur-record first-record)	    ; skip the BS, since (next-record) increments
	   (last-record 
	     (position (make-control-record :type ES :section (re-section-number parent-re))
		       old-si
		       :start first-record
		       :test #'eql))
	   (new-copy nil)   1; non-nil at first difference.
0	   (new-copy-endp nil)	    1; ditto
0	   (ancestors (pv-ancestor-bitmap parent-version))
	   )
      (trace-encached-file t "ç-one-section ~S" (re-section-number parent-re))

      (labels
	((collect-record (record)
	   (declare (sys:downward-function))
	   (unless new-copy (return-from collect-record nil))
	   (rplacd new-copy-endp
		   (setq new-copy-endp (cons record nil))))
	 (next-new-line ()
	   (declare (sys:downward-function))
	   (if (eq new-line last-new-line)
	       (if returned-last-line-contents :eof
		   (setq returned-last-line-contents t)
		   last-new-line)   1; end-bp had better be the end, indeed,
0	    1; since nothing will
0	    1; stop at the index.
0	       (prog1 new-line (and (not returned-last-line-contents)
				    (setq new-line (zwei:line-next new-line))))))
	 (next-record ()
	   (declare (sys:downward-function))
	   (if ( cur-record (- last-record 1))
	       :eof
	       (incf cur-record)
	       (aref old-si cur-record)))
	 (skip-to (type version)
	   (declare (sys:downward-function))
	   (trace-encached-file t "skip-to ~A ~D" (-string type) version)
	   (let ((control-record (make-control-record :type type :version version)))
	     (loop for record = (next-record)
		   do
	       (trace-encached-file t "skip-to: record ~A"
				    (if (typep record 'encached-control-record)
					(-string record) record))
	       (assert (neq record :eof) () "Ran off of the end skipping to ~A"
		       (-string control-record))
	       (collect-record record)
	       (when (and (not (stringp record)) (-equal-p record control-record))
		 (return nil)))))
	 (first-discrepancy () 1;; get set up to really collect records.
0	   (declare (sys:downward-function))
	   (unless new-copy
	     (setq new-copy
		   (loop for rec being the array-elements of old-si from first-record
				 below cur-record
			 collect rec))
	     (setq new-copy-endp (last new-copy))))
	 (process-control-record (record)
	   (declare (sys:downward-function))
	   (trace-encached-file t "process-control-record ~A" (-string record))
	   (collect-record record)
	   (control-record-case (record version)
	     ((BS ES)
	      (error "Section boundary ~A found in midst of ç-one-section."
		     (-string record)))
	     ((EI ED))    1; ignore these
0	     (BD
	       (when (boolean-member-p ancestors version)
		 (skip-to ED (cr-version record))))
	     (BI
	       (unless (boolean-member-p ancestors version)
		 (skip-to EI (cr-version record))))))
	 )

	(let ((new (next-new-line)))
	  (loop named make-ç with old-record = (next-record)
		until (eq old-record :eof)
		do
	    (typecase old-record
	      (encached-control-record
		(process-control-record old-record)
		(setq old-record (next-record))
		(go si:next-loop))
	      (string
		1;; ok, we have real text to deal with
0		(trace-encached-file t "make-ç old: ~S new: ~S" old-record new)
		(cond
		  ((eq new :eof)
		   (first-discrepancy)	    1; ran out of new first
0		   (collect-record
		     (make-control-record :type BD :version new-version))
		   (loop for drec being the array-elements of old-si
			     from cur-record below last-record
			 do (collect-record drec) 1;; collect  records just the same.
0			    )
		   (collect-record
		     (make-control-record :type ED :version new-version))
		   (loop-finish))				1;no need to advance the cur-record, leaving this
0								1;loop is equivalent to leaving it at the end.
0		  ((full-string= old-record new)
		   (trace-encached-file t "make-ç: lines equal")
		   (collect-record old-record)
		   (setq old-record (next-record))  1; use up the record.
0		   (setq new (next-new-line))	    1; use up a line.
0		   )
		  (t
		   1;; there is a discrepancy. We have to find the first record
0		   1;; of the old text that occurs in the new text.
0		   (trace-encached-file t "make-ç: lines different")
		   (first-discrepancy) 1;; set up if needed.
0		   1;; run the standard comparison sequence.  Find the
0		   1;; first line0 1of each side that occurs in the other,
0		   1;; and the depth at which it0 1occurs.0 
		   (multiple-value-bind
		     (last-record-to-delete 1; an index into old-si, or null
0		      last-line-to-insert   1; a line object, or null
0		      )
		       (search-for-matches
			 ancestors
			 old-si
			 cur-record
			 last-record
			 new
			 last-new-line
			 (plusp (zwei:bp-index (zwei:interval-last-bp new-interval))))
		     (assert (or last-record-to-delete last-line-to-insert) ()
			     "Searched for matches when the top lines were string=")
		     (trace-encached-file t "Delete to ~S (~S) insert to ~S"
					  last-record-to-delete
					  (if last-record-to-delete
					      (aref old-si last-record-to-delete)
					      nil)
					  last-line-to-insert)
		     (when last-record-to-delete
		       (collect-record (make-control-record
					 :type BD :version new-version))
		       (loop for oindex from cur-record	    1; initially the index
0								1; of old-record
0					to last-record-to-delete
			     do (collect-record (aref old-si oindex)))
		       (collect-record (make-control-record
					 :type ED :version new-version))
		       (setq cur-record last-record-to-delete)
		       (setq old-record (next-record))
		       )
		     (when last-line-to-insert
		       (collect-record (make-control-record
					 :type BI :version new-version))
		       (loop for nrec = new then (next-new-line)
			     do
			 (collect-record (or (zwei:line-diagram nrec) nrec))
			 (when (eq nrec last-line-to-insert)
			   (loop-finish))
			 (assert (neq nrec ':eof)
				 ()
				 "Ran off the end looking for last-line-to-insert.")
			 )
		       (collect-record (make-control-record
					 :type EI :version new-version))
		       (setq new-line last-line-to-insert)  1; so it would be returned next
0		       (next-new-line)	    1; use up 0last-line-to-insert
		       (setq new (next-new-line))   1; and leave the next for the top of the loop
0		       )
		     ))))))
	  1;; when we exit this loop, the old text is definitely used up.
0	  1;; however, there may be a tail of appended text.
0	  (when (neq new :eof)	
	    (trace-encached-file t "ç-one-section: processing new tail.")
	    (setq cur-record last-record)			1;since we fell out of the loop,
0								1;cur-record is not updated
0	    (first-discrepancy)	    1; might be the only change
0	    (collect-record
	      (make-control-record :type BI :version new-version))
	    (loop for irec = new then (next-new-line)
		  do
	      (when (eq irec :eof) (return nil))
	      (trace-encached-file t "~S" irec)
	      (collect-record (or (zwei:line-diagram irec) irec)))
	    (trace-encached-file t "Done new tail.")
	    (collect-record
	      (make-control-record :type EI :version new-version)))))
      1;;; okay, did anything happen?
0      (when new-copy 1;; yes, we have to re-invent the section info
0	(let* ((n-records-now (+ (- (section-info-n-records old-si)
				    (- last-record first-record))
				 (length new-copy)))
	       (new-si (consing-with-instance (make-section-info n-records-now))))
	  (setf (section-info-occurence-count new-si)
		(section-info-occurence-count old-si))
	  (loop for orec being the array-elements of old-si below first-record
		do (vector-push-carefully orec new-si))
	  1;; --- this need a copy protocol for the diagrams.
0	  (loop for nrec in new-copy
		do (vector-push-carefully
		     (if (stringp nrec) 
			 (si:copy-into-area-if-not-there nrec (sys:%area-number self))
			 nrec)
		     new-si))
	  (loop for orec being the array-elements of old-si from last-record
		    1;; pick up the ES
0		do (vector-push-carefully orec new-si))
	  (setf (aref section-table (re-section-number parent-re)) new-si)))
      )))
(defun insert-into-vector (element index array)
  (cond (( index (length array))		1; easy case, its an extension
0	 (assert (= index (length array)) ()
		 "Attempt to insert past the element after the last element of the array.")
	 (vector-push-extend element array))
	(t
	 (when (= (length array) (array-dimension array 0))
	   (adjust-array array (+ 10 (array-dimension array 0)))) 1;; grow it a reasonable amt.
0	 
	 (let ((a array))
	   (declare (sys:array-register a))
	   (loop for x from (1- (fill-pointer a)) downto index
		 do
	     (setf (aref a (+ 1 x)) (aref a x)))
	   (setf (aref a index) element))
	 (incf (fill-pointer array)))))

						
1;;; This function was originally invented to compensate for file-buffer's
;;; omitting the last line transition at the end of a section.
;;; The buffers don't do this any more, but this is still a useful
;;; abstraction.  In fact, we are guaranteed that the last line is an
;;; uninteresting blank line, and that the last index is zero.
;;; This is a good thing, because the stored file format cannot represent
;;; section breaks in mid-line.  Note that in the editor buffers there is
;;; funny business with title lines at the beginning of sections.
;;; the editor has to worry about not feeding those into here.

0(defun map-over-interval-lines (interval function)
  (declare (sys:downward-funarg function))
  (zwei:linemap-interval (interval)
    (unless zwei:*this-is-the-last-line*
      (funcall function (zwei:linemap-line)))))


1;;; This method invents a brand new section and splices into the
;;; reconstruct list as needed.

0(defmethod (insert-new-section encached-file) (new-version parent-re ç-section-info)
  (let* ((re-x (if parent-re
		   (position parent-re reconstruct-table :test #'eq)
		   (length reconstruct-table)	; at the end
		   ))
	 (new-sx (section-table-n-sections section-table))	; incremented in the v-p-e
	 (new-si (consing-with-instance
		   (make-section-info
		     (+ 4
			(zwei:count-lines
			  (ç-section-new-version-interval ç-section-info)))))))
    (vector-push-extend new-si section-table)
    (setf (ç-section-section-id ç-section-info) new-sx)
    (vector-push-carefully (make-control-record :type BS :section new-sx) new-si)
    (vector-push-carefully (make-control-record :type BI :version new-version) new-si)

    ;; This is a kludge.  If the interval is empty, write out an empty line to the 
    ;; encached file so loop for record being the text-and-section-records does not ignore
    ;; this empty section.  Obviously, loop for record being the text-and-section-records
    ;; is what should be fixed.
    
    (if (zwei:bp-= (zwei:node-first-bp (ç-section-new-version-interval ç-section-info))
		   (zwei:node-last-bp (ç-section-new-version-interval ç-section-info)))
	(vector-push-carefully (si:copy-into-area-if-not-there
				 "" (sys:%area-number self))
			       new-si)
	(map-over-interval-lines (ç-section-new-version-interval ç-section-info)
				 1;; this dosen't trim off the leaders.  No harm, I think.
0				 #'(lambda (line)
				     (vector-push-carefully
				       (si:copy-into-area-if-not-there
					 line (sys:%area-number self))
				       new-si))))
    (vector-push-carefully (make-control-record :type EI :version new-version) new-si)
    (vector-push-carefully (make-control-record :type ES :section new-sx) new-si)
    (incf (section-info-occurence-count new-si))
    (insert-into-vector
      (consing-with-instance (make-reconstruct-entry :section-number new-sx :occurence 1))
      re-x reconstruct-table)))


#| This routine can accomplish two tasks:
    1) It can change a section-info to represent an existing section moving
       from place to place in the file unchanged. In this case, there will be
       no new-text-interval, and an occurence integer to specify which existing
       occurence was moved.
    2) It can add a brand new occurence when a section is modified and moved,
       or when a section is resurrected (it didn't exist at all in the parent.
       In this case, occurence will be NIL, and new-text-interval non-NIL.
|#

(defun-in-flavor (make-new-occurence encached-file)
		 (section-info occurence
			       section-number new-version new-text-interval)
  (when (and (null occurence) (null new-text-interval))
    (error "make-new-occurence with no occurence and no new text."))
  ;; the first few here are only used when new-text-interval is nil.1 But we need
0  1;; to-copy in order to calculate the size of the new section-info, so that's
0  1;; why all of the cumbersome (and) clauses.
0  (let* ((old-start (and occurence
			 (find-section-occurence section-number section-info occurence)))
	 (old-stop (and occurence
			(position (make-control-record :type ES :section section-number)
			     section-info :start old-start)))
	 (to-copy (and occurence (- old-stop old-start 1)))
	 ;; ok, now for things used always.
	 (new-line-count
	   (if occurence
	       (+ 4					1; BS BI EI ES
0		  (* 2 (section-info-occurence-count section-info))	1; BD ED in each
0		  (if new-text-interval
		      (zwei:count-lines new-text-interval)	1; all the new text.
0		      to-copy))
	       1;;BI and EI, that's it. Nothing to delete.
0	       (+ (zwei:count-lines new-text-interval) 2)))
	 (new-si (consing-with-instance
		   (make-section-info
		     (+ new-line-count
			(section-info-n-records section-info)
			)))))
    (setf (section-info-occurence-count new-si)
	  (+ 1 (section-info-occurence-count section-info)))
    1;; -- this next could probably be speedier ..
0    (loop for old-record being the array-elements of section-info
	  do
      (typecase old-record
	(string (vector-push-carefully old-record new-si))
	(encached-control-record
	  (control-record-case (old-record ignore)
	    ((BI BD EI ED)
	     (vector-push-carefully old-record new-si))
	    (BS
	      (vector-push-carefully old-record new-si)
	      (when occurence
		(vector-push-carefully (make-control-record
					 :type BD
					 :version (pv-internal-version new-version))
				       new-si)))
	    (ES
	      (when occurence
		(vector-push-carefully (make-control-record
					 :type ED
					 :version (pv-internal-version new-version))
				       new-si))
	      (vector-push-carefully old-record new-si))))))
    (vector-push-carefully (make-control-record :type BS :section section-number)
			   new-si)
    (vector-push-carefully (make-control-record
			     :type BI
			     :version (pv-internal-version new-version))
			   new-si)
    (if new-text-interval
	(map-over-interval-lines new-text-interval
				 #'(lambda (line)
				     (vector-push-carefully
				       (si:copy-into-area-if-not-there
					 line (sys:%area-number self)) new-si)))
	(let ((new-start (fill-pointer new-si)))
	  (incf (fill-pointer new-si) to-copy)
	  (copy-array-portion section-info (+ 1 old-start) old-stop
			      new-si new-start (+ new-start to-copy))))
    (vector-push-carefully (make-control-record
			     :type EI
			     :version (pv-internal-version new-version))
			   new-si)
    (vector-push-carefully (make-control-record :type ES :section section-number)
			   new-si)
    new-si))

1;;; Make a new occurence of the section on the ç0 1side,0 1insert it before
;;; the section on the0 1parent side,0 1mark it already taken care of, and
;;; skip it.

0(defmethod (move-section encached-file) (new-version old-occurence parent-re ç-section-info)
  (if (eq (ç-section-section-id ç-section-info) :deleted)
      (delete-section self new-version parent-re)
      (let* ((old-sx (ç-section-section-id ç-section-info))
	     (old-si (aref section-table old-sx))
	     (old-rx (if parent-re
			 (position parent-re reconstruct-table :test #'eq)
			 (length reconstruct-table)))
	     (new-si (make-new-occurence old-si old-occurence old-sx new-version
					 (ç-section-new-version-interval ç-section-info))))
	(setf (aref section-table old-sx) new-si)
	(insert-into-vector
	  (consing-with-instance
	    (make-reconstruct-entry :section-number old-sx
				    :occurence (section-info-occurence-count new-si)))
	  old-rx reconstruct-table))))
(defmethod (allocate-new-version encached-file) (parent external)
  (let* ((new-x (+ 1 (version-table-n-versions version-table)))
	 (new-pvi (consing-with-instance
		    (make-per-version new-x parent
				      (file-version-branch-name external)
				      (file-version-branch-version external)
				      (file-version-info-length external)
				      (file-version-info-author external)
				      (file-version-info-creation-date external)))))
    (setf (file-version-info-parent-version (pv-version-info new-pvi))
	  (and (plusp parent)
	       (pv-version-info (aref version-table parent))))
    (vector-push-extend new-pvi version-table)
1    ;; a new version has got to be a leaf, but it may make something else into a non-leaf
0    (setf (pv-leaf-p new-pvi) t)
    (when (and 
	    (plusp parent)
	    (string-equal (pv-branch-name (aref version-table parent))
		     (pv-branch-name new-pvi)))
      (setf (pv-leaf-p (aref version-table parent)) nil))
    new-pvi))

(defmethod (delete-section encached-file) (in-version re)
  (let* ((section-number (re-section-number re))
	 (section-info (aref section-table section-number))
	 (occurence (re-occurence re))
	 (start (find-section-occurence section-number section-info occurence))
	 (stop (make-control-record :type ES :section section-number))
	 (new-section-info
	   (consing-with-instance
	     (make-section-info (+ 2 (section-info-n-records section-info))))))
    1;; this is not a new occurence, its just the emptying out of the old one.
0    (setf (section-info-occurence-count new-section-info)
	  (section-info-occurence-count section-info))
    1;; hang a DL around the entire contents of this occurence.
    ;; note that the loop is inclusive -- that takes the 0BFS
    (loop for orec being the array-elements of section-info from 0 to start
	  do (vector-push-carefully orec new-section-info))
    (vector-push-carefully (make-control-record :type BD :version in-version)
			   new-section-info)
    (loop for orec being the array-elements of section-info from (+ 1 start)
	  with inserted-EDL = nil
	  when (and (typep orec 'encached-control-record)
		    (-equal-p orec stop)
		    (not inserted-EDL))
	    do (vector-push-carefully (make-control-record :type ED :version in-version)
				      new-section-info)
	       (setq inserted-EDL t)
	  do (vector-push-carefully orec new-section-info))
    (setf (aref section-table section-number) new-section-info)))

(defmethod (leaf-file-version-p encached-file-header) (version)
  (check-type version file-version)
  (let ((internal-version (lookup-external-version self version :error-p t)))
    (let ((pvi (aref version-table internal-version)))
      (pv-leaf-p pvi))))

(defmethod (branch-defined-p encached-file-header) (branch-name)
  (check-type branch-name string)
  (loop for pv being the array-elements of version-table from 1
	when (and pv (string-equal (pv-branch-name pv) branch-name))
	  do (return t)))

(defmethod (version-defined-p encached-file-header) (version)
  (check-type version file-version)
  (let ((internal-version (lookup-external-version self version)))
    (if (plusp internal-version) t nil)))

(defmethod (branch-last-version encached-file-header) (branch-name)
  1;; this code is pretty marginal, and could be replaced if the
0  1;; encached data structure maintained a successor.  In the interim,
0  1;; though, this gets the answer. (and avoids having to maintain
0  1;; successor info as versions are added, etc.)
0  (let ((pvi
	  (loop with max-pvi = nil with max-v = -1
		for pvi being the array-elements of version-table from 1
		when (and pvi (string-equal (pv-branch-name pvi) branch-name)
			  (> (pv-branch-version pvi) max-v))
		  do (setq max-pvi pvi max-v (pv-branch-version pvi))
		 finally (return max-pvi))))
    (unless pvi (error "No branch ~A" branch-name))
    (pv-version-info pvi)))
(defmethod (root-version-p encached-file-header) (version)
  (and (null (encached-file-branch-parent-version self
	       (vci:file-version-branch-name version)))
       (= 0 (file-version-branch-version version))))
(defmethod (root-branch encached-file-header) ()
  (loop for branch in (get-file-branches self)
	while (file-branch-parent-file-version branch)
	finally (return branch)))

(defmethod (:section-table-length encached-file) ()
  "An array of this length is guaranteed to accomodate all of the section in the file."
  (length section-table))
1;;; This method resembles read-file, but initializes from a ç-section array.

0(defun-in-flavor (make-section-from-ç-section encached-file) (ç)
  (let* ((n-lines
	   (+ 2 (zwei:count-lines (ç-section-new-version-interval ç))))
	 (si (make-section-info n-lines)))
    (setf (section-info-occurence-count si) 1)
    (vector-push-carefully
      (make-control-record :type BS :section (ç-section-section-id ç))
      si)

    ;; This is a kludge.  If the interval is empty, write out an empty
    ;; line to the encached file so loop for record being the
    ;; text-and-section-records does not ignore this empty section. 
    ;; Obviously, loop for record being the text-and-section-records is
    ;; what should be fixed.

    (if (zwei:bp-= (zwei:node-first-bp (ç-section-new-version-interval ç))
		   (zwei:node-last-bp (ç-section-new-version-interval ç)))
	(vector-push-carefully (si:copy-into-area-if-not-there
				 "" (sys:%area-number self)) si)
	(map-over-interval-lines (ç-section-new-version-interval ç)
				 #'(lambda (line)
				     (vector-push-carefully
				       (or (zwei:line-diagram line) 
					   (si:copy-into-area-if-not-there
					     line (sys:%area-number self)))
				       si))))
    (vector-push-carefully
      (make-control-record :type ES :section (ç-section-section-id ç))
      si)
    si))

(defmethod (:initialize-from-ç-section encached-file)
	   (ç-section-array
	     version
	     trailer)
  (check-structure-type trailer file-version-trailer)
  (with-encached-file-lock
    (consing-with-instance
1      ;; cons the version array.
0      (setq version-table (make-version-table 1))	1; One version, number 1
0      1;; fill in each of the entries.
0      (vector-push-carefully
	(make-per-version 1 0 (file-version-branch-name version)
			  (file-version-branch-version version)
			  (file-version-info-length version)
			  (file-version-info-author version)
			  (file-version-info-creation-date version)
			  )
	version-table)
      (let ((pvi (aref version-table 1)))
	(setf (pv-trailer pvi) (copy-file-version-trailer trailer))	1; protect 
0	(setf (file-version-info-trailer (pv-version-info pvi)) (pv-trailer pvi))
	(setq section-table (make-section-table (length ç-section-array)))
	(setq reconstruct-table (make-reconstruct-table (length ç-section-array)))
	(loop for ç-section being the array-elements of ç-section-array
			    using (index ç-index)
	      do
	  (setf (ç-section-section-id ç-section) ç-index)
	  (setf (aref section-table ç-index)
		(make-section-from-ç-section ç-section))
	  (vector-push-carefully
	    (make-reconstruct-entry :section-number ç-index :occurence 1)
	    reconstruct-table)
	  )
	(loop for ps being the array-elements of (file-version-trailer-per-section-array
						   (pv-trailer pvi))
	      do (setf (file-version-trailer-ps-section-id ps)
		       (ç-section-section-id (file-version-trailer-ps-section-id ps))))
	version
	))))

(defmethod (ensure-ancestor-bitmap encached-file) (version-pv)
  (unless (pv-ancestor-bitmap version-pv)
    (make-ancestor-bitmap self version-pv)))

(defmethod (make-ancestor-bitmap encached-file) (pv)
  (setf (pv-ancestor-bitmap pv)
	(make-array (+ 1 (pv-internal-version pv))	1; 0,1,...I-V
0		    :element-type 'boolean
		    :area (sys:%area-number self)
		    :initial-element nil))
  1;; we can construct the ancestor bitmap be scanning backwards.
0  1;; First, we're our own granpa
0  (setf (aref (pv-ancestor-bitmap pv) (pv-internal-version pv)) t)
  1;; Now, scan back over older versions
0  (loop for ancestorx = (pv-parent-version pv)
		      then (pv-parent-version (aref version-table ancestorx))
	until (zerop ancestorx)
	do (setf (aref (pv-ancestor-bitmap pv) ancestorx) t)))

#|| 

(2 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")Removing dead things from encached files0.

(3 0 (NIL 0) (:DUTCH NIL NIL) "TR12")Versions are deleted from encached files to remove records of obsolete and/or
temporary branches and temporary versions.  

I. The single successor rule.  For a version to be deleted from a file, no more
than one other version0 3can claim it as a direct ancestor.  If more that one
versions claims it as a direct ancestor, than the version must be retained to
provide the common base from which the two descendents descended.

II. Strategy:  Deleting a version is takes place at two levels of modularity:  text
records and reconstruct path/section blocks.

A. Text Records:  To delete a version, first find all of the versions that are its
direct descendents.  If there are more than 1, abort.

Scan all of the section-info arrays of records.  When a delete or insert group is
found for the version to be deleted, act as follows:

If the version has no descendents, remove the group (if it is an insert,
remove the 03 records and the text in between.  For a delete, just flush the 0
3records) and0 3compress the section-info array.

If more than one version is being deleted in one throw, make a list of all the
versions0 3to be deleted, together with the identity (or non-existence) of each
one's single not-to-be-deleted descendent, and use that in the above strategy.

B. Reconstruct path: When the section order changes from version to version,
additional section-info blocks are inserted.  When such a version is deleted, it
will leave behind completely empty section info occurences. These will be
represented by the sequence 0BFS X EFS X3 in the section info, and will0 3be
pointed to by reconstruct table entries.  During part (A), the0 3identity of any
such occurences "emptied" must be collected, and the 0xFS3 records removed.
Then, after all of the text records have been scanned, the0 3reconstruct table can
be searched for entries that point to the section info block0 3(by section ID and
occurence number) and removed from the reconstruct table.

||#

(defstruct (version-to-delete (:conc-name vd-))
  version					1;the internal version number
0  successor					1;the one successor or nil
0  ) 

(defmethod (delete-versions encached-file) (version-list)
  (multiple-value-bind (internal-deletes undeletable-versions)
      (make-internal-delete-array version-list)
    (delete-reconstruct-entries
      (delete-text-records internal-deletes))
    1; remove these from the version table
0    (loop for vd being the array-elements of internal-deletes
	  do (setf (aref version-table (vd-version vd)) nil))
    1; invalidate the ancestor bitmaps, rather than bother with repairs
0    (loop for pvi being the array-elements of version-table from 1
	      do
      (when pvi (setf (pv-ancestor-bitmap pvi) nil)))
    undeletable-versions))

(defun-in-flavor (make-internal-delete-array encached-file) (version-list)
  (let ((vd-array (make-array (length version-list) :fill-pointer 0)))
    (loop for v in version-list
	  as vx = (lookup-external-version self v :error-p t)
          when (= 1 vx) do (error "You cannot delete the base version of the file.")
	  do
      (vector-push (make-version-to-delete :version vx) vd-array))
    (delete-duplicates vd-array :key #'vd-version :test #'=)
    (values vd-array
	    (loop for vd being the array-elements of vd-array
		  as pvi = (aref version-table (vd-version vd))
		  as successors =
		     (loop for pvi being the array-elements of version-table from 1
			   when (and pvi
				     (= (pv-parent-version pvi) (vd-version vd))
				     (not (find (pv-parent-version pvi)
						vd-array
						:key #'vd-version
						:test #'=)))
			     collect pvi)
		  when (> (length successors) 1)
		    collect (make-file-version :branch-name (copy-seq (pv-branch-name pvi))
						  :branch-version (pv-branch-version pvi))
		    and do (delete vd vd-array :test #'eq :count 1)
		  when (= (length successors) 1)
		    do (setf (vd-successor vd) (car successors))))))

(defstruct deleted-occurence
  section
  occurence)

(defun-in-flavor (delete-text-records encached-file) (vd-array)
  (loop for si being the array-elements of section-table using (index sx)
	append (delete-text-records-1-section si sx vd-array)))

1;;; for now, record deletion and processing and empty occurence detection is 
;;; are done in two passes.
0(defun-in-flavor (delete-text-records-1-section encached-file)
		 (section-info section-index vd-array)
  (let ((new-copy)
	(new-copy-endp)
	(restart-x 0))
    (flet ((collect-record (record)
	     (declare (sys:downward-function))
	     (unless new-copy (return-from collect-record nil))
	     (rplacd new-copy-endp
		     (setq new-copy-endp (cons record nil))))
	   (first-discrepancy (to-x) 
	     (declare (sys:downward-function))
	     (unless new-copy
	       (setq new-copy
		     (loop for rec being the array-elements of section-info 
				   below to-x
			   collect rec))
	       (setq new-copy-endp (last new-copy)))))
      (loop named process do
	(block restart
	  (loop
            with vd 
	    for r being the array-elements of section-info from restart-x
		  using (index rx)
	    finally (return-from process nil)
	    do
	    (if (and (typep r 'encached-control-record)
		     (member (cr-type r) '(#.BD #.BI #.ED #.EI) :test #'=)
		     (setq vd (find (cr-version r)
				    vd-array :key #'vd-version :test #'=)))
		(progn
		  (first-discrepancy rx)	1;fire up the copy department
0		  (if (vd-successor vd)		1; successor inherits this change.
0		      (collect-record
			(make-control-record :type (cr-type r)
					     :version (vd-successor vd)))
		      1;; no successor
0		      (control-record-case (r r-version)
			(BI			1; insert, flush this and everything to EI
0						1; it is guaranteed that there is nothing
0						1; in between of interest, since 
0			  
			  (setq restart-x (1+ (position
						(make-control-record
						  :type EI :version r-version)
						section-info
						:start (1+ rx))))
			  (return-from restart nil))
			(EI (error "EI for deleted version."))
			((BD ED)
			 1;; delete, just flush it. We'll get the ED later.
0			 (setq restart-x (1+ rx))
			 (return-from restart nil)))))
		(collect-record r)))))
      1;; ok, new-copy shows what we got.
0      (if (null new-copy) nil			1; no changes, no deleted occurences
0	  (multiple-value-bind (new-copy deleted-occurences n-occurences)
	      (loop with occurence-x = 0 with skip = nil
		    for r-cons on new-copy
		    as r = (car r-cons)
		    when skip do (go si:next-loop)
		    when (and (typep r 'encached-control-record)
			      (= (cr-type r) BS)
			      (typep (second r-cons) 'encached-control-record)
			      (= (cr-type (second r-cons)) ES))
		      collect (make-deleted-occurence :section section-index
						      :occurence occurence-x) into deleted
		      and do (setq skip t)
			     (incf occurence-x)
			     (go si:next-loop)
		    when (and (typep r 'encached-control-record)
			      (= (cr-type r) BS))
		      do (incf occurence-x)
		    collect r into new-copy
		    finally (return (values new-copy deleted occurence-x)))
	    (setf (aref section-table section-index)
		  (if (zerop n-occurences) nil
		      (let* ((n-records-now (length new-copy))
			     (new-si (make-section-info n-records-now)))
			(setf (section-info-occurence-count new-si)
			      n-occurences)
			(loop for nrec in new-copy
			      do (vector-push-carefully nrec new-si))
			new-si)))
	    deleted-occurences)))))

(defun-in-flavor (delete-reconstruct-entries encached-file) (delete-occurence-list)
  (delete-if #'(lambda (re)
		 (find-if #'(lambda (d-o)
			      (and (= (re-section-number re) (deleted-occurence-section d-o))
				   (= (re-occurence re) (deleted-occurence-occurence d-o))))
			  delete-occurence-list))
	     reconstruct-table))
(defmethod (encached-file-versions encached-file-header) ()
  (let ((versions (make-array (1- (length version-table)) :fill-pointer 0)))
    (loop for pv being the array-elements of version-table from 1
	  when pv
	    do (vector-push-carefully (pv-version-info pv) versions))
    versions))

(defmethod (encached-file-version-info encached-file-header) (version)
  (let ((pvi (lookup-external-version self version :error-p t)))
    (pv-version-info (aref version-table pvi))))
1      
0(defmethod (delete-encached-file-branch encached-file) (branch-name)
  (let ((versions-to-delete
	  (loop for pvi being the array-elements of version-table from 1
		when (and pvi (string-equal (pv-branch-name pvi) branch-name))
		  collect (make-file-version
			    :branch-name branch-name
			    :branch-version (pv-branch-version pvi)))))
    (delete-versions self versions-to-delete)))


(defun read-in-encached-file (pathname &key area encached-file)
  (declare (values file file-info))
  (setq pathname (pathname pathname))
  (let ((ef (or encached-file (make-instance 'encached-file :area area :name pathname))))
    (loop named retry-read with info = nil
	  do
      (catch-error-restart (error "Retry reading VC file ~A" pathname)
	(with-open-file (stream pathname :direction :input)
	  (read-in-file ef stream)
	  (setq info (send stream :info)))
	(return-from retry-read (values ef info))))))


1;;; self-contained unit that can read in and store a file header.

0(defflavor header-pseudo-encached-file
	(header
	 (file-info nil)
	 (pathname)
	 (name ""))
	(parser encached-file-header)
  (:initable-instance-variables name pathname)
  (:writable-instance-variables (encached-file-name name) header
				(encached-file-file-info file-info))
  (:readable-instance-variables
   (encached-file-pathname pathname)))

(defmethod (make-instance header-pseudo-encached-file :after) (&rest ignore)
  (setq file-info (send-if-handles input-stream :info))
  (setq header (send self :read-header))
  (encached-file-read-header-from-parsed-header self header))

(defmethod (sys:print-self header-pseudo-encached-file) (stream ignore slashify-p)
  (if slashify-p (sys:printing-random-object (self stream)
		   (format stream "VCI:ENCACHED-FILE-HEADER ~A" (or pathname name)))
      (format stream "~A" (or pathname name))))

(defun read-file-header (&key pathname stream area header)
  (when (and stream (null pathname))
    (setq pathname (send stream :pathname)))
  (flet ((do-it (i)
	   (send i :set-pointer 0)
	   (let ((file-version (cl:getf (fs:read-attribute-list nil i :dont-reset-stream t)
				     ':version-control)))
	     (return-from read-file-header
	       (if header
		   (reinitialize-parser header :stream i :file-version file-version)
		   (make-instance 'header-pseudo-encached-file :stream i
				  :pathname pathname
				  :area area
				  :file-version file-version))))))
    (loop named read-header do
      (if (null stream)
	  (catch-error-restart ((error) "Retry reading vc file header of ~A." pathname)
	    (let ((new-header
		    (with-open-file (i pathname :direction :input)
		      (do-it i))))
	      (flush-parser new-header)
	      new-header))
	  (do-it stream)))))

(defmethod (ensure-encached-file-up-to-date header-pseudo-encached-file) (&optional stream)
  (let ((new-file-info (condition-case (error)
			    (with-open-file (probe pathname :direction :probe
						   :characters t)
			      (send probe :info))
			  (fs:file-not-found nil)
			  (fs:file-operation-failure
			    (error "Error probing ~A:  ~A" pathname error)))))
    (flet ((reread-header (in)
	     (read-file-header :stream in :header self)
	     (setq header (send self :read-header))
	     (encached-file-read-header-from-parsed-header self header)
	     (setq file-info (send in :info))))
      (cond ((equal new-file-info file-info)
	     (when stream
	       (reread-header stream))
	     t)
	    (stream
	     (reread-header stream)
	     :updated-file)
	    (t
	     (with-open-file (in pathname :direction :input)
	       (reread-header in)
	       (flush-parser self))
	     :updated-file)))))

(defun find-or-make-encached-file-header (&key stream pathname (make-ok t)
					       (area *encached-file-area*)
					       (ensure-up-to-date t))
  (assert (and (or pathname stream) (not (and pathname stream)))
	  (stream pathname))
  (when stream
    (setq pathname (send stream :pathname)))
  (setq pathname (send pathname :new-pathname :version :newest :vc-branch nil
		       :vc-version nil))
  (let ((existing-file
	  (or (find-or-make-locked-encached-file
		:pathname pathname :make-ok nil :new-file-p nil :ensure-up-to-date nil)
	      (let ((t-pathname (send pathname :translated-pathname)))
		(cdr (assoc t-pathname *all-encached-file-headers*
			    :test #'(lambda (p1 p2)
				      (eq p1 (send p2 :translated-pathname)))))))))
    (cond (existing-file
	   (when ensure-up-to-date
	     (ensure-encached-file-up-to-date existing-file stream))
	   existing-file)
	  (make-ok
	   (let ((new-file (read-file-header :pathname pathname
					     :stream stream :area area)))
	     (push (cons pathname new-file) *all-encached-file-headers*
		   :area *encached-file-area* :localize t)
	     new-file))
	  (t nil))))

