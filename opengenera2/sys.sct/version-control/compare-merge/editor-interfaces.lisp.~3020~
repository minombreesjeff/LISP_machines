;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to
;;;> and comprise valuable trade secrets of Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
 -*- Version-Control: 3; -*-
B VTB 22
0 "Initial" 0 41083 "Margulies" 2743275305
1 "" 1 41201 "Widzinski" 2746459299
2 "" 2 41214 "Widzinski" 2746459589
3 "Margulies-Initial-highlight" 0 44145 "Margulies" 2746552717
4 "" 1 44177 "Margulies" 2746558231
5 "" 2 44346 "Margulies" 2746558863
3 "" 3 41212 "Widzinski" 2746559492
7 "" 4 44160 "Margulies" 2746559846
8 "" 5 44175 "Margulies" 2746886688
9 "" 6 44175 "Margulies" 2746918743
10 "" 7 44214 "Widzinski" 2747740260
11 "" 8 44244 "Margulies" 2747746083
12 "" 9 45290 "Margulies" 2747831895
13 "" 10 45289 "Margulies" 2747913115
14 "" 11 45854 "Margulies" 2747916375
15 "" 12 46353 "Margulies" 2750804160
16 "" 13 47407 "Margulies" 2751385204
17 "" 14 47443 "Margulies" 2751385582
18 "" 15 48097 "Widzinski" 2753291805
19 "" 16 48293 "Moon" 2759188712
20 "" 17 50129 "Moon" 2764378039
21 "" 18 49313 "Moon" 2766776089
E VTB
* PROPERTIES
#S(VCI:ENCACHED-FILE-PROPERTIES-1 :PROPERTIES (VCI:CONVERTED-PATHNAME-ALIST ((1 #S(VCI:FILE-VERSION :BRANCH-NAME "Initial" :BRANCH-VERSION 0) #P"VERSION-CONTROL:COMPARE-MERGE;FLAT-SOURCE;EDITOR-INTERFACES.LISP.1")) VCI:FILE-BRANCHES (#S(VCI:FILE-BRANCH :NAME "Margulies-Initial-highlight" :PRIVATE-USER-NAME "Margulies" :PARENT-FILE-VERSION #S(VCI:FILE-VERSION :BRANCH-NAME "Initial" :BRANCH-VERSION 2) :NEW-VERSIONS-PERMITTED-P T :SUCCESSOR-VERSION NIL :AUTHOR "Margulies" :CREATION-DATE 2746550783) #S(VCI:FILE-BRANCH :NAME "Initial" :PRIVATE-USER-NAME NIL :PARENT-FILE-VERSION NIL :NEW-VERSIONS-PERMITTED-P T :SUCCESSOR-VERSION NIL :AUTHOR "Margulies" :CREATION-DATE 2743296054)) VCI:CONVERTED-PATHNAME-LINKS-CHASED T)) 
B TEXT 87
BFS 0
;;; -*- Mode: lisp; Syntax: Common-Lisp; Base: 10; Lowercase: t; Package: (COMPARE-MERGE SCL); Default-character-style: (:fix :roman :normal); -*-
EFS 0
BFS 1

;;; Flavor to accumulate an annotated comparison in a result.
;;; This can be used to display a comparison, or to run a merge.
;;; In fact, running a merge consists of mapping the correct 
;;; stuff across the data structure that this produces.

;;; unlike the unused code in diagram-editor-interfaces, code above,
;;; this code creates no special node structure and no diagram lines. 
;;; It writes text into the buffer that it (or the user) can then find.

;;; This writes the compare results, together with annotations describing
;;; unresolved differences, into an interval.

;;; As each difference is written, a :record-difference is sent to self.
;;; This allows a mixin to build a possibilities buffer to track along
;;; the differences.

(defflavor no-diagrams-annotated-compare-result-mixin
	(target-interval)
	()
  (:documentation
   :mixin
   "Provides the process-common-line, process-common-interval and process-difference
methods for merging into an interval.")					
  (:required-flavors basic-compare)
  (:initable-instance-variables target-interval)
  (:required-init-keywords :target-interval)
  )
EFS 1
BFS 2

(defmethod (process-common-line no-diagrams-annotated-compare-result-mixin) (line)
  (let ((new-line (z:copy-line line target-interval)))
    (insert-line-at-end-of-interval new-line target-interval)))
EFS 2
BFS 3

(defmethod (process-common-interval no-diagrams-annotated-compare-result-mixin) (interval)
BDL 12
  (insert-copy-of-interval interval target-interval))
EDL 12
BIN 12
  (z:insert-interval (z:interval-last-bp target-interval) interval))
EIN 12
EFS 3
BFS 4

(defun insert-annotation-comment (target-interval format-string &rest format-args)
  (z:with-editor-stream (s :interval target-interval :no-redisplay t)
    (scl:with-character-face (:bold s)
      (if z:*comment-start*
	  (progn
	    (format s "~&~A " z:*comment-start*)
	    (apply #'format s format-string format-args)
	    (format s " ~A" z:*comment-end*))
	  (let ((four-comments
		  (if (> (length z:*comment-begin*) 1) z:*comment-begin*
		      (make-string 4 :initial-element (char z:*comment-begin* 0)))))
	    (format s "~&~A " four-comments)
	    (apply #'format s format-string format-args)
	    (format s "~%"))))))
EFS 4
BFS 5

(defconstant *difference-tag-start* "COMPARE-MERGE")
EFS 5
BFS 6
(defconstant *begin-difference-tag* "COMPARE-MERGE Start Difference")
EFS 6
BFS 7
(defconstant *end-difference-tag* "COMPARE-MERGE End Difference")
EFS 7
BFS 8
(defconstant *begin-difference-text-tag* "COMPARE-MERGE Text for ")
EFS 8
BFS 9
(defconstant *difference-no-text-tag* "COMPARE-MERGE Nothing in ")
EFS 9
BFS 10

(defmethod (process-difference no-diagrams-annotated-compare-result-mixin) (dif)
  (insert-annotation-comment target-interval *begin-difference-tag*)
  (loop for x from 0 to (- (compare-difference-n-source-sets dif) 1)
	as tag-list = nil			
	do
    (let ((ss (compare-difference-get-source-set dif x))
	  (set-dif-text-int nil)
	  (set-dif-null nil))	  
      (setq set-dif-text-int (sse-interval (first ss)))	; interval of the difference
						;  text
      (setq set-dif-null (null-interval-p set-dif-text-int))
      (let ((tags (loop for s in ss
			as source-x = (sse-source-x s)
			collect (list (send self :tag-string source-x)
				      (send self :description source-x)))))
	(setq tags (stable-sort tags #'string-lessp :key #'first))
	(insert-annotation-comment target-interval
				   "~A~:{~A - \"~A\" ~}"
				   (if set-dif-null
				       *difference-no-text-tag*
				       *begin-difference-text-tag*)
				   tags))
      (unless set-dif-null
BDL 12
	(insert-copy-of-interval set-dif-text-int target-interval))))
EDL 12
BIN 12
	(z:insert-interval (z:interval-last-bp target-interval) set-dif-text-int))))
EIN 12
  (insert-annotation-comment target-interval *end-difference-tag*))
EFS 10
BFS 82
BIN 17
(defflavor first-difference-hook-function-mixin
	(first-difference-hook-function)
	()
  (:initable-instance-variables first-difference-hook-function)
  (:required-flavors basic-compare)
  (:documentation
   :mixin
   "Provides a process-difference methods that calls a function when the first
difference is found.")
  (:default-init-plist :first-difference-hook-function nil))
EIN 17
EFS 82
BFS 83
BIN 17
(defwhopper (process-difference first-difference-hook-function-mixin) (dif)
  (when (and (= 1 number-of-differences) first-difference-hook-function)
    (funcall first-difference-hook-function))
  (continue-whopper dif))
EIN 17
EFS 83
BFS 75
BIN 13
(defparameter *typeout-difference-default-n-context-lines* 4)
EIN 13
EFS 75
BFS 11

(defflavor typeout-differences-result-mixin
BDL 13
	(stream)
EDL 13
BIN 13
	(stream
	 n-context-lines
	 context-silo)
EIN 13
	()
  (:documentation
   :mixin
   "Provides the process-common-line, process-common-interval and process-difference 
methods for typing out differences.")
  (:required-flavors basic-compare)
BDL 13
  (:initable-instance-variables stream)
EDL 13
BIN 13
  (:initable-instance-variables stream n-context-lines)
EIN 13
  (:required-init-keywords :stream)
BDL 13
  )
EDL 13
BIN 13
  (:default-init-plist :n-context-lines *typeout-difference-default-n-context-lines*))
EIN 13
EFS 11
BFS 76
BIN 13
(defmethod (make-instance typeout-differences-result-mixin) (&rest ignore)
  (if (and n-context-lines (plusp n-context-lines))
      (setq context-silo (make-array n-context-lines))
      (setq context-silo nil)))
EIN 13
EFS 76
BFS 77
BIN 13
(defun-in-flavor (context-line typeout-differences-result-mixin) (line)
  (when context-silo
    (setf (subseq context-silo 0 (1- n-context-lines))
	  (subseq context-silo 1 n-context-lines))
    (setf (aref context-silo (1- n-context-lines)) line)))
EIN 13
EFS 77
BFS 12
BDL 13

EDL 13
(defmethod (process-common-line typeout-differences-result-mixin) (line)
BDL 13
  (ignore line))
EDL 13
BIN 13
  (context-line line))
EIN 13
EFS 12
BFS 13

(defmethod (process-common-interval typeout-differences-result-mixin) (interval)
BDL 13
  (ignore interval))
EDL 13
BIN 13
  (z:linemap-interval (interval)
    (unless z:*this-is-the-last-line*
EIN 13
BIN 13
      (context-line (z:linemap-line)))))
EIN 13
EFS 13
BFS 14
BDL 8

EDL 8
(defmethod (process-difference typeout-differences-result-mixin) (dif)
BIN 13
  (when (and context-silo (some #'identity context-silo))
    (format stream "~&Difference after:~%")
    (loop for cl being the array-elements of context-silo
	  when cl do (send stream :line-out cl))
    (fill context-silo nil))
EIN 13
  (loop for x from 0 to (- (compare-difference-n-source-sets dif) 1)
	as tag-list = nil
	do
    (let ((ss (compare-difference-get-source-set dif x))
	  (set-dif-text-int nil)
BDL 7
	  (set-dif-null nil))	  
EDL 7
BIN 7
	  (set-dif-null nil))
EIN 7
      (setq set-dif-text-int (sse-interval (first ss)))	; interval of the difference
BDL 7
						;  text
EDL 7
BIN 7
						; text
EIN 7
      (setq set-dif-null (null-interval-p set-dif-text-int))
      (let ((tags (loop for s in ss
			as source-x = (sse-source-x s)
			collect (list (send self :tag-string source-x)
				      (send self :description source-x)))))
	(setq tags (stable-sort tags #'string-lessp :key #'first))
	(format stream "~2&~A~:{~A - \"~A\" ~}"
		(if set-dif-null
		    *difference-no-text-tag*
		    *begin-difference-text-tag*)
		tags))
      (unless set-dif-null
BDL 7
	(format stream "~A" (z:string-interval set-dif-text-int))))))
EDL 7
BIN 7
BDL 11
	(format stream "~&~A" (z:string-interval set-dif-text-int))))))
EIN 7
EDL 11
BIN 11
	(format stream "~&~A" (z:string-interval set-dif-text-int)))))
  (scl:with-character-style ('(:swiss nil nil))
EIN 11
BIN 11
    (format stream "~&__________________________________________________________________~%")))
EIN 11
EFS 14
BFS 15
BDL 10

(defmethod (do-comparison typeout-differences-result-mixin :after) ()
  (format stream "~2&Done."))
EDL 10
EFS 15
BFS 16

;;; Copied from Tags Search

(z:define-special-buffer-type visit-differences-buffer
	((current-difference-info nil)
	 (current-buffer nil)
	 (setup-merge-acceleration-p nil))
	(z:tag-table-user-special-purpose-buffer)
	visit-differences "Compare-Merge-Differences"
  (:settable-instance-variables setup-merge-acceleration-p)
  (:buffer-init-options :set-setup-merge-acceleration-p))
EFS 16
BFS 17

(defmethod (:description-1 visit-differences-buffer) (stream)
  (format stream "Compare differences"))
EFS 17
BFS 18

(defmethod (:header-description visit-differences-buffer) (stream)
  (format stream "Compare differences"))
EFS 18
BFS 19

(defmethod (:document visit-differences-buffer) (ignore)
  (format t "Search for the next compare difference."))
EFS 19
BFS 20

;;; at some point, set up a minor mode with commands that parse for the
;;; difference texts and accelerate things.
(defmethod (:select-possibility visit-differences-buffer) (starting-buffer)
  (cleanup-merge-acceleration self)		;clean up from the last one.
BDL 21
  (loop for buffer = starting-buffer then (send self :next-buffer)
	for bp = (if (eq buffer z:*interval*) (z:point) (z:buffer-saved-point buffer))
EDL 21
BIN 21
  (loop with current-zmacs-buffer = (z:window-interval z:*window*)
	for buffer = starting-buffer then (send self :next-buffer)
	for bp = (if (eq buffer current-zmacs-buffer) (z:point) (z:buffer-saved-point buffer))
EIN 21
	       then (z:interval-first-bp buffer)
	when
	  (setq bp (let ((z:*interval* buffer))
		     (z:search bp *begin-difference-tag* nil nil nil nil t)))
	  do
	    (z:point-pdl-push (z:point) z:*window*)
BDL 21
	    (when (neq buffer current-buffer)
EDL 21
BIN 21
	    (when (neq buffer current-zmacs-buffer)
EIN 21
	      (send z:*zmacs-command-loop* :set-interval buffer))
	    (setq current-buffer buffer)
	    (setup-merge-acceleration self bp)
BDL 21
	    (z:move-bp (z:point) bp)
	    (return z:dis-text)))

EDL 21
BIN 21
	    (z:move-point bp)
	    (z:must-redisplay z:*window* z:dis-text)
	    (send z:*typeout-window* :make-complete)
	    (let ((z:*centering-fraction* 0.10s0))
	      (z:recenter-window z:*window* ':absolute))
	    (z:redisplay z:*window* ':point nil nil t)
	    (let* ((info (with-merge-difference-node (mdn) (merge-choices-tag-info mdn)))
		   (char (z:prompt-line-activate
			   (format *query-io*
			     "~&Select ~{~1{~A~}, ~}or press Rubout or an editor command: "
			     info)
			   (read-char *query-io*))))
	      (cond ((loop for (tag) in info thereis (char-equal char (aref tag 0)))
		     (when (prefix-take-activate-internal char)
		       (return (send self :select-possibility buffer))))
		    ((or (char-equal char #\space) (char-equal char #\rubout)))
		    (t (unread-char char *query-io*))))
EIN 21
BIN 21
	    (return z:dis-text)))
EIN 21
EFS 20
BFS 21

(z:define-special-buffer-type compare-result-buffer () (z:special-purpose-buffer)
			      compare "Compare")

BDL 16
(compile-flavor-methods compare-result-buffer)

EDL 16
EFS 21
BFS 79
BIN 16
BDL 22
(defmethod (:set-not-modified compare-result-buffer) () nil)
EIN 16
EDL 22
BIN 22
(defmethod (:set-not-modified compare-result-buffer) (&optional undo-p)
  (ignore undo-p)
EIN 22
BIN 22
  nil)
EIN 22
EFS 79
BFS 80
BIN 16
;Contents comes from typeout; delete previous contents when told to revert
(defmethod (:revert compare-result-buffer) ()
  (z:delete-interval self))
EIN 16
EFS 80
BFS 81
BIN 16
(defmethod (:reusable compare-result-buffer) (&rest ignore) nil)

(compile-flavor-methods compare-result-buffer)

EIN 16
EFS 81
BFS 78
BIN 15
(z:defcom com-merge-environment-help "Prints help for merge accelerators, then
calls usual help command." (km)
  (filling-output (z:*typeout-window*)
    (write-string
      "Super-Z followed by a tag takes that tag. Super-control-s removes the annotations
and shows you what you have chosen so far. Super-c prompts you for a tag.
The tags are also mouse sensitive."
      z:*typeout-window*))
  (z:com-documentation))
EIN 15
EFS 78
BFS 22

;;; a bunch of zwei support for accelerating editing of merge
;;; differences.  they all depend on the 'merge-difference-node property
;;; of *interval* as the current state.  If there isn't one of those, they refuse to
;;; operate.
;;;
;;; The basic interaction is to point at the tag-line for a particular tag and
;;; click to add that to the text.

(z:defminor nil merge-acceleration "Merge" 1 "" nil
	    ;; I would like to organize this as a separate comtab containing
	    ;; all the relevant commands, but it dosen't seem possible.
	    ;; what a pain.
	    (z:set-comtab z:*mode-comtab*
			  `(#\s-z ,(z:make-extended-command *super-z-comtab*)
			    #\s-c-S com-swap-merge-difference-info
BIN 15
			    #\help com-merge-environment-help
EIN 15
			    #\s-c com-take-merge-choice)
			  (z:make-command-alist '(edit-compare-differences
						   tags-edit-compare-differences))))

(defvar *merge-acceleration-mode* (z:mode-of-flavor 'merge-acceleration))
BIN 15
#||(when *merge-acceleration-mode* (send *merge-acceleration-mode*
					 :clear-mode-forms-cache))
||#
EIN 15
EFS 22
BFS 23

(z:defminor com-test-merge-environment test-merge-environment "Test-Merge" 1 "" nil
	    (z:set-comtab z:*mode-comtab*
			  `(#\s-z ,(z:make-extended-command *super-z-comtab*)
			    #\s-c-S com-swap-merge-difference-info
			    #\s-c com-take-merge-choice)
			  (z:make-command-alist '(edit-compare-differences))))
EFS 23
BFS 24

(z:define-presentation-to-editor-command-translator
  take-merge-choice
  (z:bp "Take Merge Choice"
      z:*zmacs-comtab*
      :blank-area nil
      :tester ((bp &key window)
	       (let ((zwei-window (send-if-handles window
						   :zwei-window)))
		 (and zwei-window
		      (z:disable-for-other-window-tester
			zwei-window nil)
		      bp
		      (send z:*interval* :get 'merge-difference-node)
		      (getf (z:line-plist (z:bp-line bp)) 'begin-for-tags)
		      )))
BDL 14
      :gesture :super-right)
EDL 14
BIN 14
      :gesture :meta-right)
EIN 14
  (bp &key window)
  `(mouse-take-merge-choice ,bp ,(send window :zwei-window))
  )
EFS 24
BFS 25

(defun mouse-take-merge-choice (bp window)
  (append-choice-to-merge-result
    (send z:*interval* :get 'merge-difference-node)
    (first (getf (z:line-plist (z:bp-line bp)) 'begin-for-tags)))
  (z:must-redisplay window z:dis-text))
EFS 25
BFS 26

(defmethod (cleanup-merge-acceleration visit-differences-buffer) ()
  (when (and current-buffer setup-merge-acceleration-p)
    (when (send z:*interval* :get 'merge-difference-node)
      (cleanup-merge-difference-node (send z:*interval* :get 'merge-difference-node)))
    (send z:*interval* :remprop 'merge-difference-node)
    (z:turn-off-mode *merge-acceleration-mode*))
    )
EFS 26
BFS 27

(defmethod (setup-merge-acceleration visit-differences-buffer) (bp)
  (when setup-merge-acceleration-p
    (send z:*interval*
	  :putprop (make-instance 'merge-difference-node :key-bp bp) 'merge-difference-node)
    (z:turn-on-mode *merge-acceleration-mode*)
    ))
EFS 27
BFS 28

(defmethod (:popping-possibility visit-differences-buffer) ()
  (cleanup-merge-acceleration self))
EFS 28
BFS 29

;;; This flavor is the result of parsing the test in the buffer 
;;; to re-learn what the comparison stuff already knew. Oh well.
;;; It is in fact a node, with inferiors for each of the individual regions.
(defflavor merge-difference-node
	((tag-interval-alist nil) ; (TAG-STRING INFO INTERVAL)
	 (merged-text-bp nil)
	 (other-info-string)
	 (copy-for-undo)
	 (killed-copy))				;to swap back and forth between
						;showing merge-so-far and annotations.
	(z:node)
  (:init-keywords :key-bp)
  (:required-init-keywords :key-bp))
EFS 29
BFS 30

(defmethod (make-instance merge-difference-node) (&key key-bp &allow-other-keys)
  ;; This method has to parse the difference node.
  ;; there are two forms:
  ;; COMPARE-MERGE Start Difference 
  ;; COMPARE-MERGE Text for TAG-STRING1 ... TAG-STRING-N - FILE-INFO1 ... FILE-INFO-N
  ;; {text}
  ;; COMPARE-MERGE End Difference
  ;; 
  ;; or
  ;; COMPARE-MERGE Start Difference 1 one line of inserted commentary.
  ;; or
  ;; COMPARE-MERGE Start Difference *
  ;; multiple lines of commentary
  ;; COMPARE-MERGE End Difference
  ;;
  ;; the key-bp points just after the end of the COMPARE-MERGE Start Difference.
  ;;
  (setq z:first-bp nil z:last-bp nil)		;initialize 
  (if (and (< (z:bp-index key-bp) (length (z:bp-line key-bp)))
	   (char-equal #\1 (char (z:bp-line key-bp) (1+ (z:bp-index key-bp)))))
      (setq other-info-string (substring (z:bp-line key-bp) (1+ (z:bp-index key-bp))))
      (let ((end-bp (z:search key-bp *end-difference-tag* nil nil nil nil t)))
	(unless end-bp (z:barf "Malformed compare annotation, no ~A." *end-difference-tag*))
	(setq end-bp (z:beg-line end-bp))
	(setq z:first-bp (z:copy-bp (z:beg-line key-bp 0) :normal z:*interval*))
	(setq z:last-bp (z:copy-bp (z:beg-line end-bp 1) :moves z:*interval*))
	(setq copy-for-undo (z:make-interval 'z:interval :initial-line t))
	(z:copy-interval self nil nil copy-for-undo)
	(if (or (= (z:bp-index key-bp) (1- (length (z:bp-line key-bp))))
		(null (zl:string-search-not-set z:*whitespace-chars*
					       (z:bp-line key-bp)
					       (z:bp-index key-bp))))
	    (progn
	      (setq merged-text-bp (z:create-bp (z:bp-line (z:beg-line key-bp 1)) 0 :moves))
	      (parse-compare-difference self (z:beg-line key-bp 1) end-bp))
	    ;; assume that the * is present if the 1 isn't and it ain't whitespace.
	    (setq other-info-string
		  (z:string-interval (z:beg-line key-bp 1) end-bp t))))))
EFS 30
BFS 31
	 
(defmethod (cleanup-merge-difference-node merge-difference-node) ()
  (when z:first-bp
    (z:flush-bp z:first-bp))
  (when z:last-bp
    (z:flush-bp z:last-bp))
  (when merged-text-bp
    (z:flush-bp merged-text-bp))
  (loop for (tag-string info interval) in tag-interval-alist do
    (ignore info tag-string)
    (z:flush-bp (z:interval-first-bp interval))
    (z:flush-bp (z:interval-last-bp interval))))
EFS 31
BFS 32

(defmethod (remove-merge-difference-information merge-difference-node)
	   (keep-taken-text save-name)
BDL 21
  (declare (values not-aready-killed))
EDL 21
BIN 21
  (declare (values not-already-killed))
EIN 21
  (if killed-copy nil
      (setq killed-copy (z:copy-interval self))
BDL 22
      (if (not keep-taken-text)
	  (progn
EDL 22
BIN 22
      (z:with-undo-save-if save-name (save-name self)
	(if (not keep-taken-text)
EIN 22
	    (z:kill-interval self nil nil t nil (not (null save-name)))	;just wipe the thing
BDL 22
	    (when save-name
	      (setq z:*undo-type* save-name)))	;rename the kill
	  (when save-name
	    (z:undo-save self nil nil save-name))
BIN 21
	  (unless (or (z:bp-< (z:point) merged-text-bp)
		      (z:bp-< z:last-bp (z:point)))
	    ;; If point is in the part being deleted, move it to the part being saved
	    (z:move-point z:first-bp))
EIN 21
	  (z:delete-interval z:first-bp (z:beg-line z:first-bp 1) t)
	  (z:delete-interval merged-text-bp z:last-bp t))))
EDL 22
BIN 22
	    (unless (or (z:bp-< (z:point) merged-text-bp)
			(z:bp-< z:last-bp (z:point)))
	      ;; If point is in the part being deleted, move it to the part being saved
	      (z:move-point z:first-bp))
	    (z:delete-interval z:first-bp (z:beg-line z:first-bp 1) t)
EIN 22
BIN 22
	    (z:delete-interval merged-text-bp z:last-bp t)))))
EIN 22
EFS 32
BFS 33
      
(defmethod (return-merge-difference-information merge-difference-node) ()
  (declare (values nil-if-not-removed))
  (and killed-copy
       (progn
	 (z:delete-interval self)
	 (z:insert-interval z:last-bp killed-copy)
	 (setq killed-copy nil)
	 (parse-compare-difference self z:first-bp z:last-bp)	;reconstruct old info.
	 ;;merged text ends at the first tag 
	 (z:move-bp merged-text-bp
		    (z:beg-line (z:search (z:beg-line z:first-bp 1) *difference-tag-start*
					  nil nil nil z:last-bp) 0))
	 t)))
EFS 33
BFS 34

(defmethod (merge-information-hidden-p merge-difference-node) ()
  (not (null killed-copy)))
EFS 34
BFS 35

(defun insure-merge-difference-node ()
  (declare (values current-merge-difference-node))
  (or (send z:*interval* :get 'merge-difference-node)
      (z:barf "There is no current merge difference node")))
EFS 35
BFS 36

(defmacro with-merge-difference-node ((node-var) &body body)
  `(let ((,node-var (insure-merge-difference-node)))
     ,@body))
EFS 36
BFS 37

(z:defcom com-swap-merge-difference-info
	  "If merge difference information for the current merge difference is
visible, hide it. If it is invisible, display it."
	  ()
  (with-merge-difference-node (mdn)
    (if (merge-information-hidden-p mdn)
	(return-merge-difference-information mdn)
	(remove-merge-difference-information mdn t nil)	;don't setup conventional Undo
	))
  z:dis-text)
EFS 37
BFS 38

(z:defcom com-take-merge-choice
	  "Prompt for a tag, and inserts the text for that tag into the merge results."
	  ()
  (with-merge-difference-node (mdn)
    (let ((tag (z:prompt-line-activate (accept 'character :prompt "Tag?"))))
      (let ((success (append-choice-to-merge-result mdn tag)))
	(if success z:dis-text (z:barf "Tag ~A not defined." tag))))))
EFS 38
BFS 39

(defvar *super-z-comtab* (z:set-comtab "Super-Z merge acceleration" nil nil))

(z:set-comtab *super-z-comtab*
	      '(( #\A 26) com-prefix-take
		(#\s-a 26) com-prefix-take-activate))

(z:set-comtab-control-indirection *super-z-comtab*)
EFS 39
BFS 40

(z:defcom com-prefix-take
	  "Takes the merge choice indicated by the command character and adds it to
the merge result.  For example, s-Z A will add the text for A to the merge."
	  ()
  (with-merge-difference-node (mdn)
    (let ((success (append-choice-to-merge-result mdn (string z:*last-command-char*))))
      (if success z:dis-text (z:barf "Tag ~A not defined." z:*last-command-char*)))))
EFS 40
BFS 41

(z:defcom com-prefix-take-activate
	  "Takes the merge choice indicated by the command character and adds it to
the merge result. Remove the difference information, and ask for confirmation.
For example, s-Z s-A will add the text for A to the merge."
	  ()
BDL 21
  (with-merge-difference-node (mdn)
    (let ((success (append-choice-to-merge-result mdn (string z:*last-command-char*))))
      (unless success (z:barf "Tag ~A not defined." z:*last-command-char*)))
    (let ((confirmed nil))
      (unwind-protect
	  (progn
	    (remove-merge-difference-information mdn t nil)
	    (z:must-redisplay z:*window* z:dis-text)
	    (z:redisplay z:*window*)
	    (setq confirmed (z:prompt-line-activate
			      (y-or-n-p "OK?"))))
	(unless confirmed
	  (return-merge-difference-information mdn)))
      z:dis-text)))



#|
(z:set-comtab z:*zmacs-comtab* () (z:make-command-alist '(com-test-merge-environment)))
|#
EDL 21
BIN 21
  (prefix-take-activate-internal (make-character z:*last-command-char* :bits 0))
EIN 21
BIN 21
  z:dis-text)
EIN 21
EFS 41
BFS 85
BIN 21
;;; Returns T if confirmed
(defun prefix-take-activate-internal (char)  
  (with-merge-difference-node (mdn)
    (let ((success (append-choice-to-merge-result mdn (string char))))
      (unless success (z:barf "Tag ~A not defined." char)))
    (let ((confirmed nil))
      (unwind-protect
	  (progn
	    (remove-merge-difference-information mdn t nil)
	    (z:must-redisplay z:*window* z:dis-text)
	    (z:redisplay z:*window*)
	    (setq confirmed (z:prompt-line-activate
			      (y-or-n-p "OK? "))))
	(unless confirmed
	  (return-merge-difference-information mdn))))))
EIN 21
EFS 85
BFS 86
BIN 21
#|
(z:set-comtab z:*zmacs-comtab* () (z:make-command-alist '(com-test-merge-environment)))
|#
EIN 21
EFS 86
BFS 42

(defun parse-compare-difference-text-line (line begin-index)
  "begin-index is the index after \"... text for \""
  (declare (values tag-list other-info-string))
  (let ((after-all-tags-index			;where is the limit of this?
	  (string-search " - " line :start2 begin-index))
	(tag-list nil))
    (assert after-all-tags-index ()
	    "Compare difference line ~A is malformed. It has no \"-\"." line)
    (loop for start-index =
	      (zl:string-search-not-set z:*whitespace-chars* line begin-index)
	      then (zl:string-search-not-set z:*whitespace-chars* line after-tag-index)
	  as after-tag-index =
	     (zl:string-search-set
	       z:*whitespace-chars* line start-index)
	  do
      (let ((this-tag-string (substring line start-index after-tag-index)))
	(push this-tag-string tag-list)
	(when ( after-tag-index after-all-tags-index)	; space of " - " is after last tag
	  ;; the remainder is the info as a string
	  (setq tag-list (nreverse tag-list))
	  (return-from parse-compare-difference-text-line
	    (values tag-list
		    (with-input-from-string
		      (line-stream line :start (+ 3 after-all-tags-index))
		      (loop for x from 1 to (length tag-list)
			    collecting
			      (read line-stream nil nil))))))))))
EFS 42
BFS 43

;;; this node spans the difference, but the line-nodes don't indicate the node.
;;; Doing so would interact poorly with ordinary sectionization.
;;; instead, entries are made in the line-plist (not line-contents-plist)
;;; that indicate the sub-intervals for the different parts of the difference.
;;; this is a speed-up for mapping from a line up to the compare structure.
;;; an unsolved problem with this is if the user edits in one of the difference regions 
;;; and adds a line.  There is no good way to fix it.

(defmethod (parse-compare-difference merge-difference-node) (start-bp end-bp)
  ;; scan along lines, looking for Text for header lines.
  (let ((this-start-bp nil)
BDL 21
	(this-tag)
	(this-info)
	(last-tag)
BDL 19
	)
EDL 19
BIN 19
	(last-info))
EIN 19
EDL 21
BIN 21
	(this-tag nil)
	(this-info))
EIN 21
    (z:linemap (start-bp end-bp)
BDL 21
      (let ((tag-index
	      (string-search *begin-difference-text-tag* (z:linemap-line)))
	    (end-diff-p (or (string-search *end-difference-tag* (z:linemap-line))
BDL 19
			    (string-search *difference-no-text-tag* (z:linemap-line))
			    )))
EDL 19
BIN 19
			    (string-search *difference-no-text-tag* (z:linemap-line)))))
EIN 19
EDL 21
BIN 21
      (let* ((begin-diff-p (string-search *begin-difference-text-tag* (z:linemap-line)))
	     (end-diff-p (string-search *end-difference-tag* (z:linemap-line)))
	     (blank-diff-p (string-search *difference-no-text-tag* (z:linemap-line)))
	     (tag-index (cond (begin-diff-p
			       (+ begin-diff-p (length *begin-difference-text-tag*)))
			      (blank-diff-p
			       (+ blank-diff-p (length *difference-no-text-tag*))))))
	(when (and (or tag-index end-diff-p) this-tag)
	  ;; Close off previous section of text
	  (let ((int (z:make-interval		;this may be empty ...
		       'z:interval
		       :first-bp (if this-start-bp
				     (z:copy-bp this-start-bp :normal z:*interval*)
				     (z:create-bp (z:linemap-line) 0 :normal z:*interval*))
		       :last-bp (z:create-bp (z:linemap-line) 0 :moves z:*interval*))))
	    (loop for tag in this-tag
		  for info in this-info do
	      (push (list tag info int) tag-interval-alist))
	    (z:linemap-interval (int)
	      (setf (getf (z:line-plist (z:linemap-line)) 'data-for-tags) this-tag))
	    (setq this-start-bp nil
		  this-tag nil)))
	;; Start next section of text
EIN 21
	(when tag-index
BDL 21
	  (incf tag-index (length *begin-difference-text-tag*))
	  (setq last-tag this-tag)
BIN 19
	  (setq last-info this-info)
EIN 19
EDL 21
	  (multiple-value-setq (this-tag this-info)
	    (parse-compare-difference-text-line (z:linemap-line) tag-index))
BDL 21
	  (setf (getf (z:line-plist (z:linemap-line)) 'begin-for-tags) this-tag))
	(when (or tag-index end-diff-p)
	  (when this-start-bp
BDL 19
	    (let ((int (z:make-interval	;this may be empty ...
EDL 19
BIN 19
	    (let ((int (z:make-interval		;this may be empty ...
EIN 19
			 'z:interval
			 :first-bp (z:copy-bp this-start-bp :normal z:*interval*)
			 :last-bp (z:create-bp (z:linemap-line) 0 :moves z:*interval*))))
BDL 19
	      (loop for tag in this-tag for info in this-info
EDL 19
BIN 19
	      (loop for tag in (if end-diff-p this-tag last-tag)
		    for info in (if end-diff-p this-info last-info)
EIN 19
		    do
		(push (list tag info int) tag-interval-alist))
	      (z:linemap-interval (int)
		(setf (getf (z:line-plist (z:linemap-line)) 'data-for-tags) last-tag)))
BDL 19
	    (setq this-start-bp nil this-info nil))
EDL 19
BIN 19
	    (setq this-start-bp nil))
EIN 19
	  (when tag-index
	    (setq this-start-bp
		  (z:create-bp (z:line-next-in-buffer (z:linemap-line)) 0))))))))
EDL 21
BIN 21
	  (setf (getf (z:line-plist (z:linemap-line)) 'begin-for-tags) this-tag)
	  (when begin-diff-p
	    (setq this-start-bp (z:create-bp (z:line-next-in-buffer (z:linemap-line)) 0))))))
    ;; Keep it in textual order
EIN 21
BIN 21
    (setq tag-interval-alist (nreverse tag-interval-alist))))
EIN 21
EFS 43
BFS 44

(defmethod (merge-choices-tag-info merge-difference-node) () tag-interval-alist)
EFS 44
BFS 45

(defmethod (append-choice-to-merge-result merge-difference-node) (tag)
  (declare (values tag-found))
  (let ((tag-info (assoc tag tag-interval-alist :test #'string-equal)))
    (and tag-info
	 (progn
	   (let ((int (z:copy-interval (third tag-info))))
	     (z:insert-interval merged-text-bp int))
	   t))))

(compile-flavor-methods merge-difference-node visit-differences-buffer)
EFS 45
BFS 46

;;; There are three reasonable interfaces to this.  
;;; First, the interface to comparisons that use this annotation scheme can 
;;; make a new tag table out of all the result buffers and then set this loose on it.
;;;
;;; Second, a Tags Resolve Compare Differences command can run this across 
;;; an arbitrary tag table.
;;;
;;; Third, a Resolve Compare Differences command can make up a tag table with
;;; just one buffer and use that. (and kill it afterwards).

(defun start-visiting-differences-in-buffers (buffer-list &key merge-acceleration-p)
  (z:select-tag-table				; invent the tag table
    ':buffers-tag-table
    ':set-buffers-list buffer-list
    ':set-tag-table-name (format nil "Some buffers with compare-merge results"))
  (z:select-tag-table-user 'visit-differences	; and put it to work with c-.
			   :set-setup-merge-acceleration-p merge-acceleration-p))
EFS 46
BFS 47

(z:defcom tags-edit-compare-differences
	  "Sets up D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")c0-. to visit all of the compare differences in the current tags
table." ()
  ;; merge acceleration? I see no harm in it.
  (z:select-tag-table-user 'visit-differences :set-setup-merge-acceleration-p t))
EFS 47
BFS 48

(z:defcom edit-compare-differences
	  "Sets up 1c0-. to visit all of the compare differences in the current buffer."
	  ()
  (start-visiting-differences-in-buffers (list z:*interval*) :merge-acceleration-p t))
EFS 48
BFS 49


(defflavor automatically-resolve-differences-mixin
	((convergence-ok nil)
	 (original-source nil)
	 (force-edit-list nil)
	 (n-resolved 0)
	 (annotate-auto-resolutions nil))	
	()
  (:required-flavors basic-compare)
  (:documentation
   :mixin
   "Tries to choose one of a set of differences using
information about the change history.")
  (:initable-instance-variables annotate-auto-resolutions))
EFS 49
BFS 84
BIN 20
(defvar *automatically-resolve-when-all-versions-but-original-agree* t)
EIN 20
EFS 84
BFS 50

(defmethod (other-source-info automatically-resolve-differences-mixin)
	   (source-plist source-x)
BDL 20
  (when (or (getf (cdr source-plist) :original)
	    (getf (cdr source-plist) :old-original))
EDL 20
BIN 20
  (when (or (getf source-plist :original)
	    (getf source-plist :old-original))
EIN 20
    (when original-source
      (error "More than one source specified with the :original or :old-original attribute"))
    (setq original-source source-x)
BDL 20
    (when (getf (cdr source-plist) :old-original)
EDL 20
BIN 20
    (when (getf source-plist :old-original)
EIN 20
      (setq convergence-ok t)))
BDL 20
  (when (getf (cdr source-plist) :force-edit)
EDL 20
BIN 20
  (when (getf source-plist :force-edit)
EIN 20
    (push source-x force-edit-list)))

#|
The difference resolver resolves differences when the various sources sort
out into two group, and no more. There are two cases considered:

  (A) If all of the sources save one agree with the original, then
the dissenter is always taken as a valid resolution UNLESS it is a member
of the force-edit list. 

  (B) If the group that disagrees with the original has more than one
member, then the resolution proceeds only if the convergence-ok flag
is t, and none of the dissenters are in the force-edit list. The convergence-ok
flag should only be set if the original is OLD, that it, that there was a lost
itermediate between the original and some or all of the other participating
sources. In that case, it is expected that sources that diverged from
the "missing link" will have common changed. If the original is not old, then
common differences are coincidences, and still require manual resolution.
BDL 20
|#
EDL 20
BIN 20
However, if *automatically-resolve-when-all-versions-but-original-agree* is
true and the dissenters include everyone but the original, no manual
resolution is required.
EIN 20
BIN 20
|#
EIN 20
EFS 50
BFS 51

(defun-in-flavor (get-dissenter-list automatically-resolve-differences-mixin)
	      (difference &aux dissenter-source-set)
  ;; this can assume that there are only 2 source sets,
  ;; since it is only called if that is already known
  (loop for d from 0 to 1 named search do
    (setq dissenter-source-set (compare-difference-get-source-set difference d)); maybe
    ;; if this is the dissenter set, then the inner loop will complete and
    ;; return from the outer loop with the right values.
    ;; if not, it will just return here, and the outer loop will try the other
    ;; (neccessarily correct) source set.
    (loop named search-1 for source-and-interval in dissenter-source-set
			     ;; collect source-list in case this is the good pass.
	  collecting (sse-source-x source-and-interval) into source-list 
	  finally
	    (return-from search
	      (values source-list
		      (sse-interval (first dissenter-source-set))	; the interval
		      ))
	  do
      (when (= (sse-source-x source-and-interval) original-source)
	(return-from search-1 nil)))))

EFS 51
BFS 52

(defwhopper (process-difference automatically-resolve-differences-mixin)
	    (difference)
  (let ((dissenter-source-list)
	(dissenter-text-interval))
    (cond ((and original-source
		(= (compare-difference-n-source-sets difference) 2)
		(multiple-value-setq (dissenter-source-list dissenter-text-interval)
				     (get-dissenter-list difference))
						; guaranteed non-null, so the and is OK
		(null (intersection dissenter-source-list force-edit-list :test #'=))
						; no dissenters that decline
						; responsibility
		(or (= (length dissenter-source-list) 1)	; only one dissenter
BDL 20
		    convergence-ok))
EDL 20
BIN 20
		    convergence-ok
		    (and *automatically-resolve-when-all-versions-but-original-agree*
			 (= (length dissenter-source-list) (1- n-sources)))))
EIN 20
						; old original, multiple dissenters permitted
	   ;; it passes, now report the interval as common
	   (when annotate-auto-resolutions
	     (send self :auto-resolved-difference
		   difference dissenter-source-list dissenter-text-interval))
	   (process-common-interval self dissenter-text-interval)
	   (incf n-resolved)			
	   ;; and we are completely done
	   )
	  (t (continue-whopper difference)))))
EFS 52
BFS 53

(defmethod (:auto-resolved-difference automatically-resolve-differences-mixin :default)
	   (difference dissenter-source-list dissenter-text-interval)
  (ignore difference dissenter-source-list dissenter-text-interval))
EFS 53
BFS 54

(defmethod (:auto-resolved-difference typeout-differences-result-mixin)
	   (difference dissenter-source-list dissenter-text-interval)
  (ignore difference dissenter-source-list dissenter-text-interval)
  )
EFS 54
BFS 55

(defmethod (:auto-resolved-difference no-diagrams-annotated-compare-result-mixin)
	   (difference dissenter-source-list dissenter-text-interval)
  (ignore difference dissenter-source-list dissenter-text-interval)
  )
EFS 55
BFS 66
BDL 8
BIN 4
1;;; this can only handle two sources, since the idea is to bold-ify the text in one
;;; that is different from the text in the other.
;;; deletions? diagram line time.
0(defflavor character-style-highlight-differences-mixin
	(character-style
	 stream
	 source-to-display)
	()
  (:required-flavors basic-compare)
BDL 5
  (:init-keywords :character-style :stream)
EDL 5
BIN 5
  (:init-keywords :character-style)
  (:initable-instance-variables stream)
EIN 5
  (:required-init-keywords :character-style :stream)
  (:default-init-plist :character-style '(nil :bold nil)
		       :stream *standard-output*))
EIN 4
EDL 8
EFS 66
BFS 67
BDL 8
BIN 4
(defmethod (other-source-info character-style-highlight-differences-mixin)
	   (source-plist index)
BDL 5
  (when (getf source-plist :displayed) (setq source-to-display index)))
EIN 4
EDL 5
BIN 5
  (when (getf source-plist :display) (setq source-to-display index)))
EIN 5
EDL 8
EFS 67
BFS 68
BDL 8
BIN 4
(defmethod (make-instance character-style-highlight-differences-mixin :after)
BDL 5
	   (&key ((:character-style a-character-style)))
EDL 5
BIN 5
	   (&key ((:character-style a-character-style)) &allow-other-keys)
EIN 5
  (setq character-style (si:parse-character-style a-character-style))
  (unless (= 2 (compare-n-sources self))
    (error "~S only supports two sources." 'character-style-highlight-differences-mixin)))  
EIN 4
EDL 8
EFS 68
BFS 69
BDL 6
BIN 4
(defwhopper (process-difference character-style-highlight-differences-mixin) (dif)
  (with-character-style (character-style stream :bind-line-height t)
    (continue-whopper dif)))
EIN 4
EDL 6
EFS 69
BFS 70
BDL 8
BIN 4
(defmethod (process-common-line character-style-highlight-differences-mixin) (line)
  (format stream "~A~%" line))
EIN 4
EDL 8
EFS 70
BFS 71
BDL 8
BIN 4
(defmethod (process-common-interval character-style-highlight-differences-mixin) (int)
BDL 5
  (z:linemap-interval (int)
    (format stream "~A~%" z:line)))
EIN 4
EDL 5
BIN 5
  (format stream "~A" (z:string-interval int)))
EIN 5
EDL 8
EFS 71
BFS 72
BDL 8
BIN 4
(defmethod (process-difference character-style-highlight-differences-mixin) (dif)
  (let ((text-to-display nil))
    (loop for x from 0 below (compare-difference-n-source-sets dif)
	  do
      (let ((ss (compare-difference-get-source-set dif x)))
	(loop named find-text for sse in ss 1;; there won't be very many of these in this case.
0	      do
	  (when (= (sse-source-x sse) source-to-display)
	    (setq text-to-display (sse-interval sse))
	    (return-from find-text nil)))))
BDL 6
    (if text-to-display
BDL 5
	(z:linemap-interval (text-to-display)
	  (format stream "~A~%" z:line))
EDL 5
BIN 5
	(format stream "~A" (z:string-interval text-to-display))
EIN 5
	1;;--- lisp dependence, fix this later via major mode stuff.
0	(format stream ";;;; .... text deleted here .....
"))))
EIN 4
EDL 6
BIN 6
    (let ((str (with-output-to-string (s)
		 (with-character-style (character-style s :bind-line-height t)
		   (if text-to-display
		       (format s "~A" (z:string-interval text-to-display))
		       1;;--- lisp dependence, fix this later via major mode stuff.
0		       (format s ";;;; .... text deleted here .....
")
		       )))))
EIN 6
BIN 6
      (write-string str stream))))
EIN 6
EDL 8
EFS 72
BFS 73
BDL 8
BIN 4
(defflavor compare-2-highlighting-differences
	()
	(character-style-highlight-differences-mixin basic-compare)
  (:documentation "Given a stream, a style, and two sources, writes one of the
sources to the stream highlighting the text that differs from the other source.
The source to be displayed should include :displayed t in its source plist."))

(compile-flavor-methods compare-2-highlighting-differences)
EIN 4
EDL 8
EFS 73
BFS 74
BDL 8
BIN 4
(defun compare-2-intervals-highlighting-differences (from to target-stream
						     &key (character-style '(nil :bold nil)))
  (let ((comparison (make-instance 'compare-2-highlighting-differences
				   :stream target-stream
				   :character-style character-style
				   :sources
BDL 5
				   `((,from) (,to :display t)))))
EDL 5
BIN 5
				   `((:interval ,from) (:interval ,to :display t)))))
EIN 5
    (do-comparison comparison)))
EIN 4
EDL 8
EFS 74
BFS 66
BIN 8
1;;; this can only handle two sources, since the idea is to bold-ify the text in one
;;; that is different from the text in the other.
;;; deletions? diagram line time.
0(defflavor character-style-highlight-differences-mixin
	(character-style
	 stream
	 source-to-display)
	()
  (:required-flavors basic-compare)
  (:init-keywords :character-style)
  (:initable-instance-variables stream)
  (:required-init-keywords :character-style :stream)
  (:default-init-plist :character-style '(nil :bold nil)
		       :stream *standard-output*))
EIN 8
EFS 66
BFS 67
BIN 8
(defmethod (other-source-info character-style-highlight-differences-mixin)
	   (source-plist index)
  (when (getf source-plist :display) (setq source-to-display index)))
EIN 8
EFS 67
BFS 68
BIN 8
(defmethod (make-instance character-style-highlight-differences-mixin :after)
	   (&key ((:character-style a-character-style)) &allow-other-keys)
  (setq character-style (si:parse-character-style a-character-style))
  (unless (= 2 (compare-n-sources self))
    (error "~S only supports two sources." 'character-style-highlight-differences-mixin)))  
EIN 8
EFS 68
BFS 70
BIN 8
(defmethod (process-common-line character-style-highlight-differences-mixin) (line)
  (format stream "~A~%" line))
EIN 8
EFS 70
BFS 71
BIN 8
(defmethod (process-common-interval character-style-highlight-differences-mixin) (int)
  (format stream "~A" (z:string-interval int)))
EIN 8
EFS 71
BFS 72
BIN 8
(defmethod (process-difference character-style-highlight-differences-mixin) (dif)
  (let ((text-to-display nil))
    (loop for x from 0 below (compare-difference-n-source-sets dif)
	  do
      (let ((ss (compare-difference-get-source-set dif x)))
	(loop named find-text for sse in ss 1;; there won't be very many of these in this case.
0	      do
	  (when (= (sse-source-x sse) source-to-display)
	    (setq text-to-display (sse-interval sse))
	    (return-from find-text nil)))))
    (let ((str (with-output-to-string (s)
		 (with-character-style (character-style s :bind-line-height t)
		   (if text-to-display
		       (format s "~A" (z:string-interval text-to-display))
		       1;;--- lisp dependence, fix this later via major mode stuff.
0		       (format s ";;;; .... text deleted here .....
")
		       )))))
      (write-string str stream))))
EIN 8
EFS 72
BFS 73
BIN 8
(defflavor compare-2-highlighting-differences
	()
BDL 17
	(character-style-highlight-differences-mixin basic-compare)
EDL 17
BIN 17
	(first-difference-hook-function-mixin
	 character-style-highlight-differences-mixin basic-compare)
EIN 17
  (:documentation "Given a stream, a style, and two sources, writes one of the
sources to the stream highlighting the text that differs from the other source.
BDL 17
The source to be displayed should include :displayed t in its source plist."))
EDL 17
BIN 17
The source to be displayed should include :displayed t in its source plist.
A first-difference-hook-function can be supplied."))
EIN 17

(compile-flavor-methods compare-2-highlighting-differences)
EIN 8
EFS 73
BFS 74
BIN 8
(defun compare-2-intervals-highlighting-differences (from to target-stream
BDL 17
						     &key (character-style '(nil :bold nil)))
  (let ((comparison (make-instance 'compare-2-highlighting-differences
				   :stream target-stream
				   :character-style character-style
				   :sources
				   `((:interval ,from) (:interval ,to :display t)))))
BDL 9
    (do-comparison comparison)))
EIN 8
EDL 9
BIN 9
EDL 17
BIN 17
						     &key (character-style '(nil :bold nil))
						     first-difference-hook-function)
  (let ((comparison (make-instance
		      'compare-2-highlighting-differences
		      :stream target-stream
		      :character-style character-style
		      :first-difference-hook-function first-difference-hook-function
		      :sources
		      `((:interval ,from) (:interval ,to :display t)))))
EIN 17
    (do-comparison comparison)
EIN 9
BIN 9
    comparison))
EIN 9
EFS 74
BFS 56
BDL 4
BDL 8


EDL 4
EDL 8
(defflavor compare-zmacs-buffers
	()
	(basic-compare)
  (:documentation
   "Runs the compare algorithm, uses the automatic resolution
stuff.")
  (:init-keywords
BIN 13
BIN 17
   :first-difference-hook-function
EIN 17
   :n-context-lines				1;for typeout-differences-mixin
0EIN 13
   :automatically-resolve-differences
   :target-interval
   :typeout-differences
BDL 2
   :annotate-auto-resolutions)
EDL 2
BIN 2
   :annotate-auto-resolutions
   :stream)					;everybody has to take this,
						;even though some ignore it.
EIN 2
  (:default-init-plist 
   :target-interval nil
   :typeout-differences nil
   :automatically-resolve-differences nil)
  (:mixture
   (:automatically-resolve-differences automatically-resolve-differences-mixin)
BIN 17
   (:first-difference-hook-function
     (nil nil) (otherwise first-difference-hook-function-mixin))
EIN 17
   (:target-interval (nil nil) (otherwise no-diagrams-annotated-compare-result-mixin))
   (:typeout-differences (nil nil) (otherwise typeout-differences-result-mixin)))
  :abstract-flavor
  )
EFS 56
BFS 57

;;; a couple of methods to circumvent :mixture limitations.  (to whit:
;;; there is no way to make the :automatically-resolve-differences mixin
;;; dependent on the OR of :target-interval and :typeout-differences).

(defmethod (process-common-line compare-zmacs-buffers) (ignore))
EFS 57
BFS 58
(defmethod (process-common-interval compare-zmacs-buffers) (ignore))
EFS 58
BFS 59

(defmethod (make-instance compare-zmacs-buffers) (&key target-interval typeout-differences
						       &allow-other-keys)
  (assert (or target-interval typeout-differences)
	  ()
	  "Either :target-interval or :typeout-differences must be supplied."))

(compile-flavor-methods compare-zmacs-buffers)
EFS 59
BFS 60

(defun compare-merge-intervals (source-list
				&key
BIN 17
				first-difference-hook-function
EIN 17
				target-interval
				automatically-resolve-differences
				typeout-differences
				annotate-auto-resolutions)
BIN 18
  (declare (sys:downward-funarg *))
EIN 18
  (let ((comparison
	  (make-instance 'compare-zmacs-buffers
			 :sources source-list
			 :target-interval target-interval
BIN 17
			 :first-difference-hook-function first-difference-hook-function
EIN 17
			 :automatically-resolve-differences automatically-resolve-differences
BDL 3
			 :typeout-differences typeout-differences
BDL 2
			 :annotate-auto-resolutions annotate-auto-resolutions)))
EDL 2
BIN 2
EDL 3
BIN 3
			 :typeout-differences (not (null typeout-differences))
EIN 3
			 :annotate-auto-resolutions annotate-auto-resolutions
			 :stream typeout-differences)))
EIN 2
    (do-comparison comparison)
    comparison))
EFS 60
BFS 61

;;;The following functions support bulk processing of merges. The plan is this:
;;;
;;;1) read N starnames, each marked as usual with original/old original/force edit.
;;;2) read a target starname.
;;;3) expand all of the starnames, and sort on the file names (less the version)
;;;4) find matching names.
;;;5) pairwise run the whole business.

(defun zmacs-compare-merge-files (source-pn-list result-disposition
				  &key
				  typeout-differences
				  (target nil target-p)
				  auto-merge-p)
  "source-list is a plist with the pathname or buffer in the car"
  (ecase result-disposition
    ((:pathname :buffer)
     (assert target-p () "A target buffer or pathname must be supplied with ~ 
:result-disposition of :pathname or :buffer"))
    ((:overwrite :special-buffer) ; these require no checking, for now
     ))
  ;; :overwrite requires the last
  (let ((source-buffer-list
	  (loop with desc
		for (source . options) in source-pn-list
		as buf = (etypecase source
			   (zwei:buffer
			     (setq desc (format nil "Buffer ~A" (send source :name)))
			     source)
			   (pathname
			     (setq desc (format nil "File ~A" source))
			     (z:find-editor-buffer
			       :pathname (send source :truename)	;flush .newest here.
			       :load-p t
			       :create-p t)))
		collect `(:interval ,buf :description ,desc ,@options)
		do
	    ;;; if the target is supposed to be :newest,
	    ;;; make sure that the source no longer thinks it is.
BDL 16
	    (let ((source-pn (send buf :pathname)))
EDL 16
BIN 16
	    (let ((source-pn (send buf :pathname))
		  (target-pn (if (eq result-disposition :pathname) target
				 (and
				   (eq result-disposition :buffer)
				   (z:file-buffer-p target)
				   (send target :pathname)))))
EIN 16
	      (when (and
BDL 16
		      (string-equal (send target :string-for-dired)
EDL 16
BIN 16
		      target-pn
		      (string-equal (send target-pn :string-for-dired)
EIN 16
				    (send source-pn :string-for-dired))
BDL 16
		      (eq (send target :version) :newest)
EDL 16
BIN 16
		      (eq (send target-pn :version) :newest)
EIN 16
		      (eq (send source-pn :version) :newest))
		(sys:without-aborts ("Changing the pathname of ZMACS buffer ~A" buf)
		  (without-interrupts
		    (send buf :set-pathname (car (send buf :file-info)))
		    (send buf :set-name (send
					  (send buf :pathname) :string-for-editor)))))))))
    (let ((target-buffer
	    (case result-disposition
	      ((:buffer) target)
	      ((:special-buffer :overwrite)	;eventually, this has to
						;make arrangements to do the overwriting.
	       (send z:*current-command-loop* :find-special-buffer 'compare t))
	      ((:pathname)
	       (z:find-editor-buffer
		 :create-p t 
		 :pathname (if (not (send target :wild-p)) target
			       (let ((first-pn (if (typep (first source-pn-list)
							  'pathname)
						   (first source-pn-list)
						   (send (first source-pn-list)
							 :pathname))))
				 (send target :new-pathname
				       :name (send first-pn :name)
				       :type (send first-pn :type)
				       :version :newest))))))))
      (send target-buffer :set-not-modified)	; initialize the save-tick.
      (compare-merge-intervals source-buffer-list
			       :automatically-resolve-differences auto-merge-p
			       :typeout-differences typeout-differences 
			       :target-interval target-buffer)
      target-buffer)))
EFS 61
BFS 62

(defstruct (source-info (:conc-name si-))
  (presentation-type 'pathname)
  (prompt "Pathname")
  (qid-marker 0)
  (object)
  (options))
EFS 62
BFS 63

(defun accept-compare-sources-and-target (stream)
  (declare (values sources target edit-differences-p auto-merge-p result-disposition))
  (let ((sources)
	(target)
	(real-stream stream)
	(edit-differences-p)
	(auto-merge-p)
	(result-disposition ':pathname) 	;If :overwrite, and the last source has
						; version :NEWEST, overwrite the target.
						; if the version is wrong, just create
						; newest at the source.
						;
						;If :special-buffer, write it into
						; a buffer with a funny name.
						;
						;if :pathname, write it into a new
						; file buffer for the pathname.
						;
						;For single file comparisons,
						; there is the choice of :buffer,
						; an explicitly named non-file-buffer.
	(any-wild-pathnames-p)
	(typeout-differences)
	)
    (With-character-family (':swiss stream)
      (filling-output (stream)
	(format stream "~&Sources may be starnames.  If they are starnames, the starnames are listed, and the files in each group are matched by name and type. The compare/merge proceeds for each set of corresponding files.  Automatic merging is enabled for three or more source file sets by specifying the Original or Old-Original option for one source.  An automatic merge takes place when there are two versions of the text (i.e., some sources agree with the original, and the rest agree with each other).  With the Original option, only one of the sources may disagree with the original.  With the Old-Original option, any number may disagree. The disagreeing text becomes the final result, unless one of the disagreeing sources was marked with the Force-Edit option. The Force-Edit option on a source prevents any automatic merge where that source would become the final text."))
      (format stream "~2&")
      (dw:accepting-values (stream :label "Compare Merge" :resynchronize-every-pass t)
	(setq auto-merge-p
	      (accept 'boolean :prompt "Enable automatic merging"
		      :stream stream
		      :default auto-merge-p
		      :display-default t))
	(setq typeout-differences
	      (accept 'boolean :prompt "Type out differences on the typeout window"
		      :stream stream
		      :default typeout-differences
		      :display-default t))
	(format stream "~%")
	(setq sources
	      (dw::accept-values-on-sequence
		sources
		#'(lambda (elt stream index last-p)
		    (with-character-face ((if last-p :italic :roman) real-stream) 
		      (ignore real-stream)
		      (let ((qbase-increment 0))
			(flet ((qid (&optional (marker 0))
				 (+ (* 100000 index) (if last-p 10000 0) (* marker 1000)
				    (incf qbase-increment))))
			  (unless elt (setq elt (make-source-info)))
			  (multiple-value-bind (new-pt ignore pt-not-changed)
			      (accept '((member pathname zwei:buffer))
				      :default (si-presentation-type elt)
				      :stream stream
				      :prompt (format nil "Compare source ~D" index)
				      :query-identifier (qid)
				      :display-default t)
			    (setf (si-presentation-type elt) new-pt)
			    (unless pt-not-changed (setf (si-object elt) nil)))
			  (case (si-presentation-type elt)
			    (pathname (setf (si-prompt elt) "Pathname"
					    (si-qid-marker elt) 0))
			    (zwei:buffer (setf (si-prompt elt) "Buffer"
					       (si-qid-marker elt) 1)))
			  (setf (si-object elt)
				(accept (si-presentation-type elt)
					:default (or (si-object elt)
						     (dw:presentation-type-default
						       (si-presentation-type elt)))
					:stream stream
					:prompt (si-prompt elt)
					:query-identifier (qid (si-qid-marker elt))
					:display-default t))
			  (setf (si-options elt)
				(if auto-merge-p
				    (list
				      (accept
					'((member :none :original :old-original :force-edit))
					:prompt "Source Option or None"
					:query-identifier (qid)
					:stream stream
					:display-default t
					:default (cond
						   ((member :original (si-options elt))
						    :original)
						   ((member :old-original (si-options elt))
						    :old-original)
						   ((member :force-edit (si-options elt))
						    :force-edit)
						   (t nil))))
				    nil))
			  (unless last-p (format stream "~%"))
			  elt))))
		:stream stream
		:default nil
		))
	(format stream "~%")
	(setq any-wild-pathnames-p (some #'(lambda (si)
					     (and (pathnamep (si-object si))
						  (send (si-object si) :wild-p)))
					 sources))
	(when (and any-wild-pathnames-p
		   (eq result-disposition ':buffer))
						;not meaningful, unless it meant to
						;put all the comparisons in a single buffer.
						;there isn't technology for that, at least
						;not yet, so we force the default.
	  (setq result-disposition ':pathname)
	  (setq target nil))			;forget whatever was typed, sorry.
						;since we don't have a theory of
						;invalid input hanging around.
	(multiple-value-bind (new-result-disposition ignore result-disposition-not-changed)
	    (accept `((member :pathname :special-buffer :overwrite
			      ,@(and (not any-wild-pathnames-p) `(:buffer))))
		    :prompt "Result disposition"
		    :stream stream
		    :default result-disposition
		    :display-default t)
	  (setq result-disposition new-result-disposition)
	  (unless result-disposition-not-changed
	    (setq target nil)))
BDL 16
	(when (member result-disposition '(:pathname :buffer))
	  (let* ((target-pt (case result-disposition
			      (:pathname 'pathname)
			      (:buffer '((z:buffer) :create-p t))))
		 (target-prompt (if (eq target-pt 'pathname) "Target pathname"
				    "Target buffer")))
	    (setq target 
		  (accept target-pt
			  :stream stream
			  :default (or target (dw:presentation-type-default target-pt))
			  :display-default t
			  :prompt target-prompt)))))
EDL 16
BIN 16
	(case result-disposition
	  ((:pathname :buffer)
	   (let* ((target-pt (case result-disposition
			       (:pathname 'pathname)
			       (:buffer '((z:buffer) :create-p t))))
		  (target-prompt (if (eq target-pt 'pathname) "Target pathname"
				     "Target buffer")))
	     (setq target 
		   (accept target-pt
			   :stream stream
			   :default (or target (dw:presentation-type-default target-pt))
			   :display-default t
			   :prompt target-prompt))))))
EIN 16
      (values sources target edit-differences-p auto-merge-p result-disposition
	      typeout-differences)
      )))
EFS 63
BFS 64

(defun match-pathnames (&rest pathname-lists &aux matches)
  (flet
    ((same-name (x y)
       (and 
	 (string-equal (send x :name)
		       (send y :name))
	 (string-equal (send x :type)
		       (send y :type)))))
    (setq matches
	  (loop with current = (car pathname-lists)
		for next in (cdr pathname-lists)
		finally (return current)
		do
	    (setq current (intersection current next
					:test #'same-name))))
    ;; now, go back and construct the correspondance list
    (loop for m in matches ;; for each match
	  collecting
	    (loop for pl in pathname-lists ;; collect the list of pathnames
		  collecting (car (member m pl :test #'same-name))))))
EFS 64
BFS 65

(z:defcom com-compare-merge-multiple-files
	  "Prompts for a set of starnames. Run compare/merge over all
of the files for which there are correponding name.type files in the expansions
of all of the starnames. Optionally treats one of the sets as
an original or old original, enabling automatic merging of some differences.
If an original is designated, then differences where all sources (including
the original) agree and one disagrees will be resolved in favor of the 
new version. If there is an old original, differences where one sources
agree with the original and all of the others agree with each other will
be resolved in favor of the new versions. If the force edit option is
given for any sources, then they will never be used to automatically resolve
a difference."
	  ()
  (let ((source-file-list-list nil)
	(source-info-list nil)
	(corresponding-file-list nil)
	(one-buffer nil)
	(wild nil))
    (format z:*typeout-window* "~&")		;unbreak accept-values
    (multiple-value-bind (source-infos target edit-differences-p auto-merge-p
			  result-disposition typeout-differences)
	(accept-compare-sources-and-target z:*typeout-window*)
      (loop for si in source-infos
	    do
	(etypecase (si-object si)
	  (pathname
	    (when (send (si-object si) :wild-p)
	      (when one-buffer
		(z:barf "ZMACS buffers cannot be matched against starnames."))
	      (setq wild t))
	    (push
	      (loop for (file . nil) in
			(or (if (send (si-object si) :wild-p)
				(cdr (fs:directory-list (si-object si) :sorted))
				(list (list (si-object si))))
			    (z:barf "No files matched ~A." (si-object si)))
		    collecting file)
	      source-file-list-list))
	  (z:buffer
	    (when wild
	      (z:barf "A ZMACS buffer cannot be matched against a starname."))
	    (setq one-buffer t)
	    (push (list (si-object si)) source-file-list-list)))
	(push (si-options si) source-info-list))
      (setq source-file-list-list (nreverse source-file-list-list))
      (setq source-info-list (nreverse source-info-list))      
      (if wild					;implies no buffers, for now
	  (setq corresponding-file-list
		;; so match-pathname need not deal in buffers.
		(apply #'match-pathnames source-file-list-list))
	  (setq corresponding-file-list
		(list 
		  (loop for (file . nil) in source-file-list-list
			collect file))))
      (when (null corresponding-file-list)
	(z:barf "No files were found that corresponded for all sources."))
      (let ((result-buffer-list
	      (loop for set in corresponding-file-list with source-info
		    do
		(format t "~&----- Sources -----")
		(setq source-info
		      (loop for source in set
			    for source-info in source-info-list
			    collecting
			      `(,source
				:original ,(member :original source-info)
				:old-original ,(member :old-original source-info)
				:force-edit ,(member :force-edit source-info))
			    do
			(format
			  t "~&~A~:[~; Original~]~:[~; Old Original~]~:[~; Force Edit~]~%"
			  source
			  (member :original source-info)
			  (member :old-original source-info)
			  (member :force-edit source-info))))
BDL 16
		(format t "----- Target -----~%~A" (send target :string-for-mini))
EDL 16
BIN 16
		(when target
		  (format t "----- Target -----~%~A"
			  (send target :name)))
EIN 16
		    collect
		      (zmacs-compare-merge-files
			 source-info result-disposition :auto-merge-p auto-merge-p
			 :target target
			 :typeout-differences (and typeout-differences z:*typeout-window*)))))
	(when edit-differences-p
	  (start-visiting-differences-in-buffers
	    result-buffer-list
	    :merge-acceleration-p t))
	z:dis-all))))				;might switch buffers,
						;and in any case we want to flush typeout

(z:set-comtab z:*zmacs-comtab* ()
	      (z:make-command-alist '(com-compare-merge-multiple-files
				       tags-edit-compare-differences
				       edit-compare-differences)))


EFS 65
E TEXT
B FTR
95
1 
"Conversion from Y:>version-control>compare-merge>flat-source>editor-interfaces.lisp.1" 
0 
*
11
2 
"
" 
0 
*
11
3 
"
" 
0 
*
11
4 
"
" 
0 
*
11
5 
"
" 
0 
*
11
6 
"
" 
0 
*
11
7 
"
" 
0 
*
11
8 
"
" 
0 
*
11
9 
"
" 
0 
*
12
10 
"
" 
0 
*
12
11 
"
" 
0 
*
12
12 
"
" 
0 
*
12
13 
"
" 
0 
*
12
14 
"
" 
0 
*
12
15 
"
" 
0 
*
11
16 
"" 
0 
*
11
17 
"" 
0 
*
11
18 
"" 
0 
*
430
19 
"" 
1 
43 "This apparently never worked right.  It associated the tag with the text
for the previous tag, ignoring the first tag altogether.  Change to loop
for tag and info in last-tag and last-info.  These are where the data
was saved when the difference was found.  Use last-tag and last-info. 
for all except the last pass where you want to use this-tag and
this-info.  Set up last-info to hold info for correct tag.   
"
*
290
20 
"" 
3 
84 "New variable to allow resolution of policy dispute.
"
50 "No, Benson, (get plist ...) not (getf (cdr plist)...).
Update policy comment for *automatically-resolve-when-all-versions-but-original-agree*.
"
52 "Obey *automatically-resolve-when-all-versions-but-original-agree*
"
*
679
21 
"" 
5 
20 "Use MOVE-POINT, not MOVE-BP of POINT.  Recenter window nicely.
Use correct computation of Zmacs' current buffer (not *interval* and not current-buffer).
Query user for a merge tag, and if confirmed go on to the next difference,
allowing a quick action in the usual case.
"
32 "If point is in the part being deleted, move it to the part being saved.
"
41 "Split off subroutine, prefix-take-activate-internal.
Don't forget to clear the Super bit (that's why this command didn't work).
"
85 "Subroutine split off from com-prefix-take-activate.
"
43 "Fix bugs causing tags to be lost when there were blank sections of text.
Keep tag-interval-alist in textual order.
"
*
73
22 
"" 
2 
79 "Add undo-p argument.
"
32 "Update to new Undo facility.
"
*
E FTR
