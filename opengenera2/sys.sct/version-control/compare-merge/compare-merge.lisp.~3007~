;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to
;;;> and comprise valuable trade secrets of Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
 -*- Version-Control: 3; -*-
B VTB 7
0 "Initial" 0 91553 "Margulies" 2743274597
1 "" 1 35092 "Margulies" 2743275311
2 "" 2 35112 "Margulies" 2745409589
3 "" 3 35114 "Margulies" 2746560432
4 "" 4 35162 "Margulies" 2746886728
5 "" 5 35136 "Widzinski" 2748554343
6 "" 6 34917 "Margulies" 2751385145
E VTB
* PROPERTIES
#S(VCI:ENCACHED-FILE-PROPERTIES-1 :PROPERTIES (ZWEI:BRANCH-MERGE-RECORD NIL VCI:CONVERTED-PATHNAME-ALIST ((128 #S(VCI:FILE-VERSION :BRANCH-NAME "Initial" :BRANCH-VERSION 0) #P"VERSION-CONTROL:COMPARE-MERGE;FLAT-SOURCE;COMPARE-MERGE.LISP.128") (129 #S(VCI:FILE-VERSION :BRANCH-NAME "Initial" :BRANCH-VERSION 1) #P"VERSION-CONTROL:COMPARE-MERGE;FLAT-SOURCE;COMPARE-MERGE.LISP.129")) VCI:FILE-BRANCHES (#S(VCI:FILE-BRANCH :NAME "Initial" :PRIVATE-USER-NAME NIL :PARENT-FILE-VERSION NIL :NEW-VERSIONS-PERMITTED-P T :SUCCESSOR-VERSION NIL :AUTHOR "Margulies" :CREATION-DATE 2743296022)) VCI:CONVERTED-PATHNAME-LINKS-CHASED T)) 
B TEXT 151
BFS 0
;;; -*- Mode: lisp; Syntax: Common-Lisp; Base: 10; Lowercase: t; Package: (COMPARE-MERGE SCL); Default-character-style: (:fix :roman :normal); -*-

;;; package of flavors and support for multiple source compare/merge
;;; undertaken by BIM, 1985-07-02

#|

NOTE ON ZWEI INTERFACE

This implementation compares and merges zwei intervals. The algorithm would
cheerfully compare anything that arrived as a linked list of items
with a comparator for the items. However, that generalization would be pretty messy,
and probably innefficient with the current flavor system. In any case, No One
wants it just yet.

This implementation only works for ZWEI intervals that span an integral 
number of lines.  The boundary cases produce endless hair, and there
seems no good reason to bother.  However, ZWEI intervals and BP's are
used internally so that comparisons that span buffer sections work right.

NOTE ON ZMACS INTERFACE

Currently, the only user interfaces are through ZMACS. This could clearly operate 
in a standalone editor frame, where the displayed interval would contain
the compare results.

NOTE ON WHITESPACE

As of this writing, the significance of whitespace in comparisons is 
controlled by the choice of string comparison primitives. 
The default is still to consider all whitespace significant, for lack of semantic
data. (Perhaps we are in the midst of a string constant, for example.)
It is hard to imagine how to get that semantic data here. This leads me
(BIM) to believe that the right answer is for the editor to try really
hard to maintain canonical whitespace representation in code. Further, 
truly syntax-directed comparison is not the purpose of this package.


BASIC COMPARISON STRATEGY (the Mullen algorithm)

When a difference is found between any of the sources, we search for a
block of lines that is identical in all sources.

The function "try-deeper-resynch" searches for a block of common lines.
Each time that try-deeper-resynch is entered, it tries to construct one
synch-node based on each source. For each source, the synch-node starts
at first-potential-synch, which is one line deeper each time around.
The synch-node for the source is set to a set of lines that satisfy the
required minimum number of lines and characters for a synch block.  The
location (if any) of the synch interval in all of the sources is
recorded in the array cross-match.  A voting scheme is used to choose
amongst multiple synch intervals that exist in all sources. An interval
receives one vote for each other interval in which it occurs at the top,
without any further intervening difference.

The best interval via votes cannot be directly returned unless
duplicate-synch-block detection is disabled.
(max-lines-to-look-for-duplicates is 0) If duplicate detection is
enabled, then check-for-synch-duplicates must be called to insure that
the synch block is unique within the duplicate-checking range. If it is
not unique, then it is discarded, and the next lower vote-getter is
tried.

If no interval passes the duplicate test, or, for that matter, if no
interval could be found in all of the sources at all, then depth is
increased by one line in each source and the fun begins again. 
  
|#
EFS 0
BFS 1

(defvar *compare-merge-version* 3
  "Version 3 of the compare/merge package (Memorex user interface).")
EFS 1
BFS 2

(defvar *default-min-lines-for-resync* 2
  "The minimum number of lines that must match
in all sources to declare files resynchronized.")
EFS 2
BFS 3

(defvar *default-min-chars-for-resync* 5
  "The minimum number of characters that must
match in all sources to declare files resynchronized.")
EFS 3
BFS 4

(defvar *default-max-lines-to-look-for-duplicates* 100
  "The comparison rejects any resynchronization based on
a match block that recurs verbatim less than this many lines later.
Zero ==> implies look to the end of the interval, nil ==> don't even look.")
EFS 4
BFS 5
 


;;; a compare-difference states the beginning and ending of a difference
;;; in each source of the compare set. These are specified as intervals.
;;; There is one list recorded for each textually different block in the
;;; difference set.  Each source-set looks like ((source-x interval)
;;; (source-x interval) (source-x interval)) There is one element for
;;; each identical source block. The current line number for the source
;;; is guaranteed to be first line of the difference block. If the
;;; difference is null in a given source, then the first-bp of the
;;; interval will be nil.  Each element names the source by index, and
;;; gives the locations in that source of the text.

(defstruct (source-set-element
	     (:type :named-list)
	     (:conc-name sse-))
  source-x
  interval)
EFS 5
BFS 6

(defflavor compare-difference
	   (comparison				; the compare/merge that created this
	    n-source-sets			; max valid entry in source-sets
	    source-sets				; array of intervals
	    (lines-different 0)			; sum of the sizes of all of the difference blocks
	    )
	   ()
  (:initable-instance-variables comparison n-source-sets)
  (:readable-instance-variables n-source-sets lines-different comparison)
  (:writable-instance-variables n-source-sets)	
  (:required-init-keywords :comparison :n-source-sets)
  (:init-keywords :comparison :n-source-sets)
  (:documentation
   :special-purpose
   "Records a difference found in a compare/merge."))
EFS 6
BFS 7

(defmethod (make-instance compare-difference) (&rest ignore)
  (setq source-sets (make-array n-source-sets)))
EFS 7
BFS 8

(defmethod (compare-difference-add-source compare-difference)
	   (source-set-x source-set-element)
  (push source-set-element (aref source-sets source-set-x))
  (unless (null (z:interval-first-bp (sse-interval source-set-element)))
    (setq lines-different
	  (+ lines-different
	     (z:count-lines (sse-interval source-set-element) nil t)))))
EFS 8
BFS 9

(defmethod (compare-difference-get-source-set compare-difference) (source-set-x)
  (aref source-sets source-set-x))
EFS 9
BFS 10

(defmethod (:describe compare-difference) ()
  (flavor:describe-instance self)
  (loop for x from 0 to (- n-source-sets 1)
	do
    (format t "~&source set ~D" x)
    (loop for source in (aref source-sets x)
	  do
      (format t "~&       TAG: ~A~%" (send comparison :tag-string (sse-source-x source)))
      (when (and (sse-interval source)
		 (z:interval-first-bp (sse-interval source)))
	(z:linemap-interval ((sse-interval source)
			   nil)
	  (format t "~&|~A|" (z:linemap-line)))))))
EFS 10
BFS 11



(defgeneric process-common-line (comparison line)
  (:method-combination :progn))
EFS 11
BFS 12

(defgeneric process-common-interval (comparison interval)
  (:method-combination :progn))
EFS 12
BFS 13

(defgeneric process-difference (comparison difference)
  (:method-combination :progn))
EFS 13
BFS 14

(defgeneric do-comparison (comparison))
EFS 14
BFS 15

(defflavor basic-compare
	(min-lines-in-block
	 min-chars-in-block
	 max-lines-search-for-duplicate-block
;	 line-comparison-function
	 number-of-differences
	 number-of-different-lines
	 cross-match				; (i,j) interval describing match of
						;  synch-node (i)
						; in j
	 first-potential-synch			; (i) is pointer to first line in
						;  i to be considered
						; as the start of a synch block
	 votes					; (i) is quality metric of block (i)
	 best-source-x
	 difference-node
	 synch-node
	 synch-node-length
	 n-sources
	 last-source-x
	 (first-source-x 0)
	 source-interval
	 tag-string
	 description
	 current-line				; (i) is a pointer to the last synchronized
						; line so far. If the last synch'ed line
						; was the last line in the entire
						; this has the value of :eof.

  	 last-line				; the last line of the
						; intervals, for comparison
	 all-sources-eof 
	 grow-bp-array				; temp used in growing synch nodes
	 (trial-interval (z:create-interval (z:create-bp nil 0) (z:create-bp nil 0) nil))
	 (nsdp-temp-interval (z:create-interval (z:create-bp nil 0) (z:create-bp nil 0) nil))
	 )
	()
  (:documentation
   :mixin
   "Provides basic comparison technology. Given a set of zwei intervals,
runs the compare algorithm. As it scans the files, it sends the common
lines back to itself with process-common-line and
process-common-interval generic functions. When it finds a difference,
it resynchronizes, reports the difference with process-difference of
itself, and then continues. Other mixins of the compare/merge set are
responsible for dealing with process-common-line, process-common-interval,
 and process-difference.")
  (:initable-instance-variables
;  line-comparison-function
   min-lines-in-block
   min-chars-in-block
   max-lines-search-for-duplicate-block)
  (:required-methods process-common-line process-common-interval process-difference)
  (:init-keywords :sources)
  (:required-init-keywords :sources)
  (:conc-name compare-)
BDL 5
  (:readable-instance-variables n-sources)
EDL 5
BIN 5
  (:readable-instance-variables n-sources number-of-differences number-of-different-lines)
EIN 5
  (:default-init-plist
;  :line-comparison-function #'compare-lines-string-equal
   :min-lines-in-block *default-min-lines-for-resync*
   :min-chars-in-block *default-min-chars-for-resync*
   :max-lines-search-for-duplicate-block *default-max-lines-to-look-for-duplicates*))
EFS 15
BFS 16

(defmacro append-to-make-keyword args
  `(intern (string-append ,@args) :keyword))

(defprop define-get-array-IV-method defmethod definition-function-spec-type)
(defprop define-set-array-IV-method  defmethod definition-function-spec-type)
(defprop define-array-IV-methods defmethod definition-function-spec-type)
EFS 16
BFS 17

(defmacro define-get-array-IV-method (flavor IV)
  `(defmethod (,(append-to-make-keyword IV) ,flavor) (x)
     (aref ,IV x)))
EFS 17
BFS 18

;;;--- define setf methods some day.
(defmacro define-set-array-IV-method (flavor IV)
  `(defmethod (,(append-to-make-keyword "SET" "-" IV) ,flavor) (x v)
     (setf (aref ,IV x) v)))
EFS 18
BFS 19

(defmacro define-array-IV-methods (flavor IV)
  `(progn 
	  (define-get-array-IV-method ,flavor ,IV)
	  (define-set-array-IV-method ,flavor ,IV)))
EFS 19
BFS 20

(define-array-IV-methods basic-compare current-line)
EFS 20
BFS 21
(define-get-array-IV-method basic-compare tag-string)
EFS 21
BFS 22
(define-get-array-IV-method basic-compare description)
EFS 22
BFS 23
(define-get-array-IV-method basic-compare source-interval)
EFS 23
BFS 24

(defconstant *alphabet* "ABCDEFGHIJKLMNOPQRSTUVWXYZ" "The collating sequence, more or less")
EFS 24
BFS 25

(defmacro-in-flavor (loop-over-sources basic-compare) (var &body body)
  `(loop for ,var from first-source-x to last-source-x
	 . ,body))
EFS 25
BFS 26

;;; --- C R O C K
(SI:DEFMACRO-SET-INDENTATION-FOR-ZWEI 'LOOP-OVER-SOURCES 'ZWEI:INDENT-LOOP)
EFS 26
BFS 27

(defmethod (make-instance basic-compare :after) (&key ((:sources s-list)) &allow-other-keys)
  (setq n-sources (length s-list))	     
  (when (< n-sources 2)
    (error "~D sources given, at least two required." n-sources))
  (setq last-source-x (- n-sources 1))
  (setq source-interval (make-array n-sources))
  (setq last-line (make-array n-sources))
  (setq tag-string (make-array n-sources))
  (setq description (make-array n-sources))
  (loop-over-sources
       source-x
       for source in s-list 
BDL 3
       as source-plist = (locf source)
       as tag = (getf (cdr source-plist) :tag-string)
       as desc = (getf (cdr source-plist) :description)
       as interval = (getf (cdr source-plist) :interval)
EDL 3
BIN 3
       as tag = (getf source :tag-string)
       as desc = (getf source :description)
       as interval = (getf source :interval)
EIN 3
       do
BDL 3
    (unless interval (error "Null source interval for ~A" (cdr source-plist)))
EDL 3
BIN 3
    (unless interval (error "Null source interval for ~A" source))
EIN 3
    ;; if a mixin looks for other per-source keywords, let it examine this one.
BDL 3
    (other-source-info self source-plist source-x)
EDL 3
BIN 3
    (other-source-info self source source-x)
EIN 3
    ;; if a mixin supplies default tags and/or descriptions ...
    (default-source-info self source-x)	
    ;; fill in default-defaults to have something
    (unless desc
      (unless (setq desc (send-if-handles interval :name))
BDL 4
	(setq desc (format t "Compare source ~D" source-x))))
EDL 4
BIN 4
	(setq desc (format nil "Compare source ~D" source-x))))
EIN 4
    (unless tag
      (setq tag (char *alphabet* source-x)))
    (setf (aref source-interval source-x) interval)
    (setf (aref tag-string source-x) tag)
    (setf (aref description source-x) desc)
    (setf (aref last-line source-x) (z:bp-line (z:interval-last-bp interval))))
  ;;; create arrays that depend on n-sources
  (setq votes                   (make-array n-sources))
  (setq first-potential-synch   (make-array n-sources))
  (setq cross-match             (make-array (list n-sources n-sources)))
  (setq difference-node     (make-array n-sources))
  (setq synch-node          (make-array n-sources))
  (setq synch-node-length   (make-array n-sources))
  (setq current-line        (make-array n-sources))
  (setq grow-bp-array       (make-array n-sources))
  ;; create per-source internal intervals
  (loop-over-sources
       x 
       do
    (setf (aref grow-bp-array x) (z:create-bp nil 0))
    (let ((int (z:create-interval (z:create-bp nil 0) (z:create-bp nil 0))))
      (setf (z:node-superior int) (aref source-interval x))
      (setf (aref difference-node x) int))
    (let ((int (z:create-interval (z:create-bp nil 0) (z:create-bp nil 0))))
      (setf (z:node-superior int) (aref source-interval x))
      (setf (aref synch-node x) int))
    (loop-over-sources y
	 as int = (z:create-interval (z:create-bp nil 0) (z:create-bp nil 0) nil)
	 do
      (setf (aref cross-match x y) int))
    ))
  
EFS 27
BFS 28
  
(defmethod (other-source-info basic-compare) (source-plist source-x)
  (ignore source-plist source-x)
  nil)
EFS 28
BFS 29

(defmethod (default-source-info basic-compare) (source-x)
  (ignore source-x)
  nil)
EFS 29
BFS 30



(defsubst-in-flavor (last-line-p basic-compare) (line x)
  (eq line (aref last-line x)))
EFS 30
BFS 31

(defsubst reset-bp (bp new-bp-line)
  (setf (z:bp-index bp) 0)
  (setf (z:bp-line bp) new-bp-line))
EFS 31
BFS 32

(defsubst line-of-last-bp (interval)
  (z:bp-line (z:interval-last-bp interval)))
EFS 32
BFS 33

(defsubst reset-bp-to-bp (bp from-bp)
  (setf (z:bp-index bp) 0)
  (setf (z:bp-line bp) (z:bp-line from-bp)))
EFS 33
BFS 34

(defsubst insert-line-at-end-of-interval (line interval)
  (z:insert-line-with-leader line (z:bp-line (z:interval-last-bp interval))))
EFS 34
BFS 35

(defsubst set-interval-null (int)
  (reset-bp (z:interval-first-bp int) nil)
  (reset-bp (z:interval-last-bp int) nil))	; nil for line ==> NULL interval here
EFS 35
BFS 36

(defsubst null-interval-p (i)
  (z:bp-= (z:interval-first-bp i) (z:interval-last-bp i)))
EFS 36
BFS 37

BIN 7
D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");;; this needs to be taught about MMcM graphic diagrams like the VC file substrate was.
0EIN 7
(defsubst lines-equal (line1 line2)
  (cond ((z:line-diagram line1)
	 (z:line-diagram line2))
	(t (string-equal line1 line2))))
EFS 37
BFS 38



;;; This function is called whenever the sources are in synch and 
;;; described by synch-node (candidate). The synch node is made
;;; larger however many other lines are common, and the current-line
;;; array is left pointing to the next line for each interval.
BDL 7
;;; if the synch region for any source swallows the end of the interval,
;;; the current-line is left as :eof.
EDL 7

(defun-in-flavor (grow-synch-node basic-compare) (candidate &aux (grown nil))
  (macrolet
    ((c-synch-node () `(aref synch-node candidate)) 
     (c-cross-match (x) `(aref cross-match candidate ,x)))
    ;; start the scan at the bottom of the current matches
    (loop-over-sources x
	 do
BDL 7
      (reset-bp-to-bp (aref grow-bp-array x)
		      (z:interval-last-bp (c-cross-match x)))
      )
EDL 7
BIN 7
      (reset-bp-to-bp (aref grow-bp-array x) (z:interval-last-bp (c-cross-match x))))
    1;; at this point, grow-bp-array points to the first set of candidate lines
0    1;; for inclusion.
0EIN 7
    (loop named add-lines
	  as first-source-line = (z:bp-line (aref grow-bp-array first-source-x))
BDL 7
	  as first-source-eof = (eq first-source-line (aref last-line first-source-x)) 
EDL 7
BIN 7
	  as first-source-eof = (last-line-p first-source-line first-source-x)
EIN 7
	  do
BIN 7
      1;; if we have hit the bottom anyplace, we can't possibly add to the synch state.
0      (when first-source-eof (return-from add-lines nil))
EIN 7
      (loop for x from (+ 1 first-source-x) to last-source-x
BDL 7
	    as x-source-line = (z:bp-line (aref grow-bp-array x)) 
EDL 7
BIN 7
	    as x-source-line = (z:bp-line (aref grow-bp-array x))
EIN 7
	    do
BDL 7
	;; if the first is the eof line, the last must be as well
	(if first-source-eof
	    (if (neq x-source-line (aref last-line x))	; x must be last, as well
		(return-from add-lines nil))
	    (unless (lines-equal first-source-line x-source-line)
	      (return-from add-lines nil))))
EDL 7
BIN 7
	1;; if we have hit the bottom anyplace, we can't include anything else
0	(when (last-line-p x-source-line x) (return-from add-lines nil))
	1;; so if we aren't at the bottom, we can just check for equality.
0	(unless (lines-equal first-source-line x-source-line)
	  (return-from add-lines nil)))
EIN 7
      ;; arrival here implies that we found one more matching line
      ;; so we tack it on.
      (setq grown t)
      (loop for x from first-source-x to last-source-x do
BDL 7
	(cond (first-source-eof
	       ;; if we are handling the last line,
	       ;; then we copy the line and index from the source last-bp.
	       (reset-bp-to-bp (aref grow-bp-array x)
			       (z:interval-last-bp (aref source-interval x)))
	       (return-from add-lines nil))	; and stop, since we are certainly
						; at the end
	      (t
	       ;; otherwise, we zap the line pointer in the bp to point to the next line.
	       (reset-bp (aref grow-bp-array x)
			 (z:line-next (z:bp-line (aref grow-bp-array x))))))))
    (when grown
      (loop-over-sources x
	   do
	(reset-bp-to-bp (z:interval-last-bp (c-cross-match x))
			(aref grow-bp-array x))
	(when (= x candidate)
	  (reset-bp-to-bp (z:interval-last-bp (c-synch-node))
			  (aref grow-bp-array candidate)))))))



#|
Since the main compare loop starts with the sources out of synch, it is
first neccessary to find out how much of the sources are initially
identical and dispense with that much.  This is done in two steps.

First, see if the first lines are different. If so, then just set up
as needed for try-deeper-resynch. Otherwise, set up for grow-synch-node
and let it do the hard work.
|#
EDL 7
BIN 7
	(reset-bp (aref grow-bp-array x)
		  (z:line-next (z:bp-line (aref grow-bp-array x)))))
      (when grown
	(loop-over-sources x
	     do
	  (reset-bp-to-bp (z:interval-last-bp (c-cross-match x))
			  (aref grow-bp-array x))
	  (when (= x candidate)
	    (reset-bp-to-bp (z:interval-last-bp (c-synch-node))
EIN 7
BIN 7
			    (aref grow-bp-array candidate))))))))
EIN 7
EFS 38
BFS 39
  
BIN 7


#|
Since the main compare loop starts with the sources out of synch, it is
first neccessary to find out how much of the sources are initially
identical and dispense with that much.  This is done in two steps.

First, see if the first lines are different. If so, then just set up
as needed for try-deeper-resynch. Otherwise, set up for grow-synch-node
and let it do the hard work.
|#

EIN 7
(defun-in-flavor (make-initial-synch-node basic-compare) ()
  (macrolet
    ((c-synch-node () `(aref synch-node first-source-x))
     (c-cross-match (x) `(aref cross-match first-source-x ,x))
     (c-source () `(aref source-interval first-source-x)))
    ;; we know that the first line is the same, so start with an interval for that
    (let ((first-bp (z:interval-first-bp (c-source))))
      (reset-bp-to-bp (z:interval-first-bp (c-synch-node)) first-bp)
      (reset-bp-to-bp (z:interval-last-bp  (c-synch-node))
		      (z:create-bp (z:line-next (z:bp-line first-bp)) 0))
      (loop for x from first-source-x to last-source-x do
	(reset-bp-to-bp (z:interval-first-bp (c-cross-match x))
			(z:interval-first-bp (aref source-interval x)))
	(reset-bp (z:interval-last-bp (c-cross-match x))
		  (z:line-next			; in buffer?
						; when we figure out how to pass
						;  the buffer down.
		    (z:bp-line
		      (z:interval-first-bp (aref source-interval x)))))))
    ;; grow the node
    (grow-synch-node first-source-x)
    ;; report the result.
    (process-common-interval self (c-synch-node))
    ;; set the current line to something useful
    (loop-over-sources x with all-eof = t do
      (if (z:bp-= (z:interval-last-bp (c-cross-match x))
		  (z:interval-last-bp (aref source-interval x)))
	  ;; note an assymetry here -- :eof is set "prematurely", when
	  ;; all lines are in synch, even though the usual value of
	  ;; current-line(x) is the last line that was in synch.
	  (setf (aref current-line x) :eof)	; all used up
	  ;; previous line to point to the last line that was in synch.
	  (setf (aref current-line x)
		(z:line-previous (z:bp-line (z:interval-last-bp (c-cross-match x)))))
	  (setq all-eof nil))
	 finally (when all-eof (setq all-sources-eof t)))))
EFS 39
BFS 40

(defun-in-flavor (make-initial-asynch-node basic-compare) ()
  ;; The first lines are different.
  ;; current-line(*) is set to :bof so that resynchronize can be
  ;; currectly initialize first-potential-synch to be the first line
  ;; of each source.
  (loop-over-sources x do
    (setf (aref current-line x) :bof)))
EFS 40
BFS 41

(defun-in-flavor (initially-synchronize basic-compare) ()
  (if 
    (loop for x from (+ 1 first-source-x) to last-source-x
	  with first-line =			
	    (z:bp-line (z:interval-first-bp (aref source-interval first-source-x)))
	  always (string-equal first-line
			       (z:bp-line (z:interval-first-bp (aref source-interval x))))
	  )
    (make-initial-synch-node)
    (make-initial-asynch-node)))
EFS 41
BFS 42


;;; this function must search (for a specified depth) for the synch-node of candidate
;;; in all of the sources.
(defun-in-flavor (no-synch-duplicates-p basic-compare) (candidate)
  (block no-synch-duplicates-p
    (loop-over-sources x
	 as last-synch-line =
	    (z:bp-line (z:interval-last-bp (aref cross-match candidate x)))
	 
	    ;; the next line after an interval is the line pointed to by its last bp.
	    ;; if the synch interval encompassed the end of the source, there cannot
	    ;; possibly be a duplicate further down, since there is no "further down."
	 
	 unless (or (null last-synch-line) (last-line-p last-synch-line x))
	   
	   ;; construct the interval to search in.
	   ;; nsdp-temp-interval is reserved for this purpose.
	   ;; note that this cannot be called recursively on the same comparison.
	   ;; which could happen in debugging.
	   ;; perhaps resources would be appropriate...????????
	   
	   do
	     (reset-bp (z:interval-first-bp nsdp-temp-interval)
		       (z:line-next last-synch-line))
	     (reset-bp-to-bp (z:interval-last-bp nsdp-temp-interval)
			     (z:interval-last-bp (aref source-interval x)))
	     ;;
	     ;; now check for the duplicate, blow out if found.
	     
	     (when 
	       (search-for-interval
		 (aref synch-node candidate)	; what to look for
		 nsdp-temp-interval		; where to look for it (this gets bashed)
		 :max-depth max-lines-search-for-duplicate-block)
	       (return-from no-synch-duplicates-p nil))
	     
	 finally (return-from no-synch-duplicates-p t))))
EFS 42
BFS 43
  

(defun-in-flavor (find-best basic-compare) ()
  (loop-over-sources x with max-x = -1 with max-votes = 0
       do
    (when (> (aref votes x) max-votes)
      (setq max-votes (aref votes x))
      (setq max-x x))
       finally (setq best-source-x max-x)))

;;; function to see if an interval is duplicated at the top of another interval
;;; a source interval. 

EFS 43
BFS 44


(defun interval-at-top-p (source-interval target-interval &key (equal nil))
  "t/nil passed test, ran out of target, last line in target"
  (let*
    ((s-first (z:interval-first-bp source-interval))
     (t-first (z:interval-first-bp target-interval))
     (s-first-line (z:bp-line s-first))
     (t-first-line (z:bp-line t-first))
     (s-last (z:interval-last-bp source-interval))
     (t-last (z:interval-last-bp target-interval))
     (s-last-line (z:bp-line s-last))
     (t-last-line (z:bp-line t-last)))
    (block compare
      (macrolet ((done-s (t-line)
		   `(return-from compare
		      (values
			(or (not equal)		; it matched, that's enough
			    (eq ,t-line t-last-line)	;for equal we used all of t
			    )
			nil			; not a shortage of target
			,t-line)))
		 (done-t () `(return-from compare (values nil t))))
	(unless
	  (lines-equal s-first-line t-first-line)
	  (return-from compare (values nil nil)))
	;; ckeck for null interval.
	(when (eq s-first-line s-last-line)
	  (done-s t-last-line))
	;; on both sides.
	(when (eq t-first-line t-last-line)
	  (done-t))
	;; now loop over the remaining lines
	(loop for s-line = (z:line-next s-first-line) then (z:line-next s-line)
	      for t-line = (z:line-next t-first-line) then (z:line-next t-line)
	      do
	  ;; last line always has index zero, so no text to compare.
	  (when (eq s-line s-last-line)
	    (done-s t-line))
	  (unless (lines-equal s-line t-line)
	    (return-from compare (values nil nil)))
	  (when (eq t-line t-last-line)
	    (done-t))
	  )))))
EFS 44
BFS 45

(defsubst intervals-equal (i1 i2)
  (if (or (null-interval-p i1) (null-interval-p i2))
      (and (null-interval-p i1) (null-interval-p i2))
      (interval-at-top-p i1 i2 :equal t)))
EFS 45
BFS 46

(defsubst copy-interval-bounds (from to)
  (setf (z:bp-line (z:interval-first-bp to)) (z:bp-line (z:interval-first-bp from)))
  (setf (z:bp-index (z:interval-first-bp to)) (z:bp-index (z:interval-first-bp from)))
  (setf (z:bp-line (z:interval-last-bp to)) (z:bp-line (z:interval-last-bp from)))
  (setf (z:bp-index (z:interval-last-bp to)) (z:bp-index (z:interval-last-bp from))))
EFS 46
BFS 47

(defun-in-flavor (try-deeper-resynch-1 basic-compare) (x &aux chars-in-interval)
  (block make-synch-node-1-source
    (setq chars-in-interval 0)
    (macrolet
      ((punt-this () '(let ((had-votes (> (aref votes x) 0)))
			(setf (aref votes x) 0)
			;; if this had votes, then we did find a block,
			;; so a deeper search should be tried.
			(return-from make-synch-node-1-source had-votes))) 
       (this-votes () `(aref votes x))
       (this-source () `(aref source-interval x))
       (this-synch-node () `(aref synch-node x))
       (this-last-line () `(aref last-line x))
       (this-cross-match (other-x) `(aref cross-match x ,other-x))
       (this-fps () `(aref first-potential-synch x))
       (this-source-interval () `(aref source-interval x))
       (synch-big-enough () `(and ( (this-synch-node-length) min-lines-in-block)
				  ( chars-in-interval min-chars-in-block)))
       (this-synch-node-length () `(aref synch-node-length x)))
      (setf (this-votes) 0)			; the voting starts over at each depth
      (setf (this-synch-node-length) 0)
      ;; make a synch interval that satisfies the minima
      ;; first-potential-synch gives us the start
      (reset-bp-to-bp (z:interval-first-bp (this-synch-node)) (this-fps))
      ;;
      ;; line-sbp is always the bp to the beginning of the text
      ;; that is to be included in the block. It may have a non-zero index
      ;; the first time, (from the source first bp) but will have a zero bp
      ;; ever afterwards. Unless line-sbp points to the last line of the source,
      ;; we can add the entire contents of the line to the synch node.
      ;; if it does point to the last line, then we are constrained by
      ;; the z:bp-index of the last line. When the source ends at an even
      ;; line boundary, this will cause the synch node to include the last
      ;; line transition, and to credit itself with 1 line and no chars.
      ;; 
      (loop with line-sbp = (z:copy-bp (this-fps))
	    with line
	    until (synch-big-enough)
	    do
	(cond ((eq (z:bp-line line-sbp) (this-last-line))	; at the end
	       (reset-bp-to-bp (z:interval-last-bp (this-synch-node))
			       (z:interval-last-bp (this-source-interval)))
	       (incf chars-in-interval
		     (- (z:bp-index (z:interval-last-bp (this-source-interval)))
			(z:bp-index line-sbp)))
	       (incf (this-synch-node-length))
	       (unless (synch-big-enough) (punt-this)))
	      (t ;; not at the end of the line
	       (setq line (z:bp-line line-sbp))
	       (reset-bp (z:interval-last-bp (this-synch-node))	; set to include entire line
			 (z:line-next (z:bp-line line-sbp)))
	       (incf chars-in-interval
		     (- (length line) (z:bp-index line-sbp)))
	       (incf (this-synch-node-length))
	       (unless (synch-big-enough)
		 (reset-bp line-sbp (z:line-next line))))))
      
      ;; if we arrived here, we have a big enough synch node. Now look for it
      ;; in the other sources
      (incf (this-votes))			; one vote for just existing
      (loop-over-sources y
	    do
	(if (= y x) (copy-interval-bounds (this-synch-node) (this-cross-match x))
	    ;; otherwise, search the remainder of each of the others for the synch-node
	    (when (null (aref first-potential-synch y))	; this is at EOF already
	      (punt-this))
	    (reset-bp-to-bp (z:interval-first-bp trial-interval)
			    (aref first-potential-synch y))
	    (reset-bp-to-bp (z:interval-last-bp trial-interval)
			    (z:interval-last-bp (aref source-interval y)))
	    ;; trial-interval is the area to search in y
	    (let ((found-flag
		    (search-for-interval
		      (this-synch-node)		; look for this
		      trial-interval		; in this (modifying this on the way)
		      :result-interval (this-cross-match y)	;and set this to the match
		      )))
	      (unless found-flag (punt-this))	; not found, trash
	      (when (eq found-flag :top)
		(incf (this-votes)))		; extra credit
	      ))))
    t))
EFS 47
BFS 48



(defun-in-flavor (try-deeper-resynch basic-compare) (&aux n-blocks)
  (setq n-blocks 0)
  (loop-over-sources x
       do
    ;; resynchronize sets up first-potential-synch to a bp to
    ;; the first line that we should try.
    (when (try-deeper-resynch-1 x)
      (incf n-blocks)))
  (cond ((= n-blocks 0)				; no source contained a block at this depth
	 (setq all-sources-eof t)
	 t)
	(t
	 (find-best)				;sets best-source-x
	 (do ((synch nil))
	     ((or synch (= best-source-x -1)) synch)	; return t if we passed
						;  the synch test.
	   (when (> best-source-x -1)
	     (grow-synch-node best-source-x)	; add lines to the bottom of the synch block
	     (if (null max-lines-search-for-duplicate-block)
		 (setq synch t)			; no request for duplicate test,
						; so save wear and tear.
		 (unless
		   (setq synch (no-synch-duplicates-p best-source-x))
		   (setf (aref votes best-source-x) 0)
		   (find-best)			; go find another to try for acceptability
		   )))))))
EFS 48
BFS 49

(defun-in-flavor (report-synch-node-as-common-lines basic-compare) ()
  (process-common-interval self (aref synch-node best-source-x)))
EFS 49
BFS 50

  

(defun search-for-interval
       (search-for search-in &key (max-depth 0) (result-interval nil)) 
  (loop named search for top = t then nil
	for depth-count = 1 then (+ 1 depth-count)	; max-depth 1 ==> TOP
	do
    (multiple-value-bind (match out-of-target search-in-end-line)
	(interval-at-top-p search-for search-in)
      (when (and (not match) out-of-target)
	(return-from search nil))
      (when match
	(when result-interval
	  (reset-bp-to-bp (z:interval-first-bp result-interval)
			  (z:interval-first-bp search-in))
	  (reset-bp (z:interval-last-bp result-interval)
		    search-in-end-line))
	(return-from search (if top :top t))))
    ;; set start of search-in to next line, punting if we have used it up
    (when (eq (z:bp-line (z:interval-first-bp search-in))
	      (z:bp-line (z:interval-last-bp search-in)))
      (return-from search nil))			; all used up
    (when (and (> 0 max-depth) (= depth-count max-depth))
      (return-from search nil))
    (reset-bp (z:interval-first-bp search-in)
	      (z:line-next (z:bp-line (z:interval-first-bp search-in))))))

EFS 50
BFS 51

;;; drop lines down from the difference block to the synch block. 
;;; This only makes a difference if the comparison ended out of synch
;;; at EOF with some common stuff at the end that was insufficient for
;;; synch. 
(defun-in-flavor (trim-differences basic-compare) ()
  )
EFS 51
BFS 52


;;; instantiate a difference object.
;;; figure out the actual number of "different differences"

(defun-in-flavor (invent-difference basic-compare) ()
  (let ((used-up (make-array n-sources :element-type 'boolean :initial-element nil))
	(dif (make-instance 'compare-difference :comparison self 
			    :n-source-sets n-sources))	; this will be set down later
						; when the actual number of
						;  distinct difs is known.
	(n-source-sets 0))    
    (loop-over-sources x
	 do
      (when (not (aref used-up x))
	(compare-difference-add-source dif n-source-sets
	      (make-source-set-element :source-x x :interval (aref difference-node x)))
	(setf (aref used-up x) t)
	(loop-over-sources y
	     do
	  (when (and (not (aref used-up y))
		     (intervals-equal (aref difference-node x)
				      (aref difference-node y)))
	    (compare-difference-add-source dif n-source-sets
		  (make-source-set-element :source-x y
					   :interval (aref difference-node y)))
	    (setf (aref used-up y) t)))
	(incf n-source-sets)))
    (setf (compare-difference-n-source-sets dif) n-source-sets)
    dif))
EFS 52
BFS 53



;;; make difference-node(x) span (next current-line(x)) to end(x)
;;; this implies the end of the entire comparison, so current-line
;;; need not be set to anything useful.


(defun-in-flavor (resynch-set-dif-node-eof basic-compare) (x &aux cur dif)
  (setq dif (aref difference-node x))
  (setq cur (aref current-line x))
  (cond ((eq cur :eof)
	 (set-interval-null dif))		; simple
	((eq cur :bof)
	 (reset-bp-to-bp (z:interval-first-bp dif)
BDL 6
			 (z:interval-first-bp (aref source-interval first-source-x)))
EDL 6
BIN 6
			 (z:interval-first-bp (aref source-interval x)))
EIN 6
	 (reset-bp-to-bp (z:interval-last-bp dif)
BDL 6
			 (z:interval-last-bp (aref source-interval first-source-x))))
EDL 6
BIN 6
			 (z:interval-last-bp (aref source-interval x))))
EIN 6
	(t
	 (reset-bp (z:interval-first-bp dif) (z:line-next cur))
	 (reset-bp-to-bp (z:interval-last-bp dif)
			 (z:interval-last-bp (aref source-interval x))))))

EFS 53
BFS 54

(defun-in-flavor (resynch-set-dif-node-before-synch-node basic-compare) (x)
  (let* ((synch (aref cross-match best-source-x x))	; best must be set
						;  if we got into synch and have synch nodes.
	 (dif (aref difference-node x))
	 (cur (aref current-line x)))
    ;; this cannot be at eof, cause we have a synch node
    ;; it must therefore have a (virtual) z:bp-index of 0.
    ;; since we never try to start a synch in mid-line
    ;; the first-bp of the synch is the start of the line
    ;; on which the synch starts, and the end of the diff.
    (if (eq cur :bof)
	(reset-bp-to-bp (z:interval-first-bp dif)
			(z:interval-first-bp (aref source-interval x)))
	(reset-bp (z:interval-first-bp dif) (z:line-next cur)))
						; one man's start is another man's end
    ;; similiarly, for the synch node.
    (reset-bp-to-bp (z:interval-last-bp dif) (z:interval-first-bp synch))))
EFS 54
BFS 55

(defun-in-flavor (resynchronize basic-compare) ()
  ;; first, find a match block (which might be the null case involving EOF)
  (loop named try-resynch
	for first = t then nil
	as any-at-eof = nil
	do
    (loop-over-sources x
	 with fps
	 as cl = (if first
		     (aref current-line x)
		     (z:bp-line (aref first-potential-synch x)))
	 do
      (cond ((or (eq cl :eof)
		 (eq cl (aref last-line x)))	; on the fps loop, we won't set :eof
	     (setq any-at-eof t)
	     (setq fps nil))
	    ((eq cl :bof)
	     (setq fps (z:interval-first-bp (aref source-interval x))))
	    (t					; not bof or eof
	     (setq fps (z:create-bp (z:line-next cl) 0))))
      (setf (aref first-potential-synch x) fps))
    (cond (any-at-eof				; we cannot possibly
						;  get a synch if some have run dry.
	   (setq all-sources-eof t)
	   (return-from try-resynch))
	  (t
	   (when (try-deeper-resynch)		; if not known to be at eof, try to construct
	     (return-from try-resynch nil)))))
;;; At this point, either all-sources-eof, since we failed to find a synch,
;;; or there is a synch and a difference.
  (loop-over-sources x
       do
    (if all-sources-eof
	(resynch-set-dif-node-eof x)		; make dif nodes from cur->EOF
	(resynch-set-dif-node-before-synch-node x)))	; make dif
						;  nodes from cur->synch
  
  ;; make sure that there are no identical lines at the end of the difference blocks
  
  (trim-differences)
  
  ;; record the differences as a difference object, and return it.
  
  (invent-difference))
EFS 55
BFS 56
BDL 2

EDL 2

(defmethod (do-comparison basic-compare) (&aux difference)
  (setq all-sources-eof nil
	number-of-differences 0
	number-of-different-lines 0)
  (initially-synchronize)
  (do () (all-sources-eof nil)
    (setq difference
	  (resynchronize))
    (setq number-of-different-lines
	  (+ number-of-different-lines (compare-difference-lines-different difference)))
    (incf number-of-differences)
    (process-difference self difference)
    (unless all-sources-eof
      (report-synch-node-as-common-lines)
      ;; check to see if all sources are at eof, advancing
      ;; each current-line to past the synch node in the process.
      (loop-over-sources x with all-eof = t
	   as synch = (aref cross-match best-source-x x)
	   finally (when all-eof (setq all-sources-eof t))
	   do
	(unless (eq (aref current-line x) :eof)	; already off the end of the world
	  (setf (aref current-line x)
		(if (z:bp-= (z:interval-last-bp synch)
			    (z:interval-last-bp (aref source-interval x)))
		    :eof			; all used up
		    (setq all-eof nil) 
		    (z:line-previous ;; see make-initial-synch-node
		      (z:bp-line (z:interval-last-bp synch))))))))))
EFS 56
BFS 57
BDL 2



;;; This version of this code is decommisioned because diagram lines
;;; cannot be read and written, and because the special purpose command
;;; loop is often more of a hindrance than a help.

;;; Flavor to accumulate an annotated comparison in a result.
;;; This can be used to display a comparison, or to run a merge.
;;; In fact, running a merge consists of mapping the correct 
;;; stuff across the data structure that this produces.
;;; Unfortunately, at this time, all the knowledge of the special
;;; nature of this is lost if the annotated buffer is written and read
;;; back with the annotations.

;;; This writes the compare results, together with annotations describing
;;; unresolved differences, into an interval. The annotations are built with 
;;; diagrams.  For now, no attempt is made to hide the differences from the
;;; language behind comments, since some of them might leave unbalanced
;;; list structure (or whatever) even if hidden.

;;; As each difference is written, a :record-difference is sent-if-handled
;;; to self. This allows a mixin to build a possibilities buffer to track
;;; along the differences.

;;; Note that the target buffer must be built on result-node-mixin.

;;; A flavor of buffer that can remember the presence of compare result annotations.

(defflavor result-node-mixin
	(comparison
	 header-node
	 (difference-nodes nil)
	 )
	()
  (:initable-instance-variables)
  (:gettable-instance-variables)
  (:settable-instance-variables))
EDL 2
EFS 57
BFS 58
BDL 2

(defflavor result-node () (z:node result-node-mixin))
EDL 2
EFS 58
BFS 59
BDL 2

(defsubst line-get (line property)
  (getf (z:line-plist line) property))
EDL 2
EFS 59
BFS 60
BDL 2

(defun make-annotated-diagram-line (annotation &rest make-diagram-line-args)
  (let ((d-line (apply #'z:make-diagram-line make-diagram-line-args)))
    (setf (line-get d-line 'diagram-text-representation) annotation)
    d-line))
EDL 2
EFS 60
BFS 61
BDL 2

(defun line-annotation (line)
  (format nil "~A~%" (line-get line 'diagram-text-representation)))
EDL 2
EFS 61
BFS 62
BDL 2

(defun replace-diagram-line-with-annotation (line)
  (let ((annotation (line-annotation line))
	(temp-i (z:create-interval
		  (z:create-bp line 0 :normal)
		  (z:create-bp (z:line-next line) 0 :moves) nil)))
    (z:delete-interval temp-i)
    (z:insert (z:interval-last-bp temp-i) annotation)
    (z:flush-bp (z:interval-first-bp temp-i))
    (z:flush-bp (z:interval-last-bp temp-i)))) 
EDL 2
EFS 62
BFS 63
BDL 2

(defflavor annotated-compare-result-mixin
	(target-node
	 (last-difference-node nil)
	 )
	()
  (:documentation
   :mixin
   "Provides the process-common-line, process-common-interval and process-difference
methods for merging into an interval.")
  (:required-flavors basic-compare)
  (:initable-instance-variables target-node)
  (:required-init-keywords :target-node)
  )
EDL 2
EFS 63
BFS 64
BDL 2

;;; the following tries to initialize the target with attributes.
;;; the header interval is either empty or just containing the
;;; attribute list.

(defun-in-flavor (init-target-attributes annotated-compare-result-mixin) ()
  (let ((source-0-buffer))
    (setq source-0-buffer (z:node-top-level-node (aref source-interval 0)))  
    (when (and source-0-buffer
	       (typep target-node 'z:buffer))	; if its a buffer, then we have
						; control of it at the top level
						; and we will give it attributes based on
						; the first source.
      ;; take the attributes from the first buffer, if any, and use them for the
      ;; target.
      (z:with-editor-stream
	(int-stream :interval source-0-buffer
		    :start :beginning
		    :interval source-0-buffer)
	(let ((*package* si:pkg-user-package)
	      (*print-base* 10.))
	  (z:reparse-attribute-list-internal
	    target-node
	    int-stream))))))
EDL 2
EFS 64
BFS 65
BDL 2

(defun-in-flavor (make-header annotated-compare-result-mixin) ()
  ;; make an interval that will span the header area
  (setf (send target-node :header-node)
	(z:create-interval
	  ;; first-bp is either a blank line or the attribute line at this point
	  (z:copy-bp (z:interval-last-bp target-node) :normal)
	  (z:copy-bp (z:interval-last-bp target-node) :moves)))
  ;; make a stream so we can use format to construct this business.
  (z:with-editor-stream
    (header-stream :start (z:interval-last-bp (send target-node :header-node))
		   :end (z:interval-last-bp (send target-node :header-node)))	
    (format header-stream "Annotated Comparison, Version ~D. ~A~2%"
	    *compare-merge-version* (time:print-current-time nil))
    (loop for tag being the array-elements of tag-string 
	  for desc being the array-elements of description
	  do
      (format header-stream "~A~25T~A~%" tag desc)))
  ;; now add a diagram line.
  (insert-line-at-end-of-interval
    (make-annotated-diagram-line
      "--------------------------------------------------------------------------------"
      'z:black-line-diagram :structural t)
    (send target-node :header-node))
  (setf (z:bp-status (z:interval-last-bp (send target-node :header-node))) :normal))
EDL 2
EFS 65
BFS 66
BDL 2

(defmethod (make-instance annotated-compare-result-mixin :after) (&rest ignore)
  (send target-node :set-comparison self)
  (init-target-attributes)
  (make-header))
EDL 2
EFS 66
BFS 67
BDL 2

(defmethod (process-common-line annotated-compare-result-mixin) (line)
  (let ((new-line (z:copy-line line target-node)))
    (insert-line-at-end-of-interval new-line target-node)))
EDL 2
EFS 67
BFS 68
BDL 2

(defsubst insert-copy-of-interval (source target)
  (z:insert-interval-moving (z:interval-last-bp target) source nil t))
EDL 2
EFS 68
BFS 69
BDL 2

(defmethod (process-common-interval annotated-compare-result-mixin) (interval)
  (insert-copy-of-interval interval target-node))
EDL 2
EFS 69
BFS 70
BDL 2


(defflavor difference-text-node
	(tag-list)
	(z:node)
  (:settable-instance-variables)
  (:gettable-instance-variables))
EDL 2
EFS 70
BFS 71
BDL 2


(defmethod (do-comparison annotated-compare-result-mixin :after) ()
  (setf (send target-node :difference-nodes) ; correct order, please.
	(nreverse (send target-node :difference-nodes)))
  (z:with-bp (ip (z:interval-last-bp (send target-node :header-node)) :moves)
    (z:move-bp ip (z:line-previous (z:bp-line ip)) 0)
    (z:insert ip
	      (format nil "~%~D Differences, ~D Lines.~%"
		      number-of-differences number-of-different-lines))))
EDL 2
EFS 71
BFS 72
BDL 2

(defmethod (process-difference annotated-compare-result-mixin) (dif)
  (let ((top (z:create-interval nil nil)))
    (setf (z:node-superior top) target-node)
    (setf (z:interval-first-bp top) (z:copy-bp (z:interval-last-bp target-node) :normal))
    (setf (z:node-previous top) last-difference-node)
    (when last-difference-node
      (setf (z:node-next last-difference-node) top))
    (setq last-difference-node top)
    (push top (send target-node :difference-nodes))
    (insert-line-at-end-of-interval
      (make-annotated-diagram-line
	"============================== Begin Difference =============================="
	'z:black-line-diagram-with-legend :structural t
	:legend "Begin Difference"
	:height 3/8
	:style '(nil :bold-extended nil)) 
      target-node)
    (loop for x from 0 to (- (compare-difference-n-source-sets dif) 1)
	  with comparison = (compare-difference-comparison dif)
	  as tag-list = nil
	  with last-dif-node = nil 
	  do
	  (let ((ss (compare-difference-get-source-set dif x))
		(cur-dif-node nil)
		(set-dif-text-int nil)
		(set-dif-null nil))	  
	    (setq set-dif-text-int (sse-interval (first ss)))	; interval of the difference
						;  text
	    (setq set-dif-null (null-interval-p set-dif-text-int))
	    (let* ((tags 	
		     (loop for s in ss
			   collect
			   (send comparison :tag-string (sse-source-x s))))
		   (legend-string
		     (format nil "~:[In~;Nothing in~]~{ ~A~}" set-dif-null
			     (stable-sort tags #'string-lessp))))
	      (unless set-dif-null
		(setq tag-list (append tag-list tags)))
	      (insert-line-at-end-of-interval
		(make-annotated-diagram-line
		  (format nil
			  "------------------------------ ~A ------------------------------"
			  legend-string)
		  'z:black-line-diagram-with-legend :structural t
		  :legend legend-string
		  :height 1/6
		  :style `(nil :bold-extended nil))
		target-node))
	    (unless set-dif-null
	      (setq cur-dif-node (z:create-interval nil nil 'difference-text-node))
	      (send cur-dif-node :set-tag-list tag-list)
	      (setf (z:interval-first-bp cur-dif-node)
		    (z:copy-bp (z:interval-last-bp target-node) :normal))
	      (insert-copy-of-interval set-dif-text-int target-node)
	      (setf (z:interval-last-bp cur-dif-node)
		    (z:copy-bp (z:interval-last-bp target-node) :normal))
	      (setf (z:node-superior cur-dif-node) top)
	      (if (null (z:node-inferiors top))
		  (setf (z:node-inferiors top) (list cur-dif-node))
		  (setf (z:node-inferiors top)
			(nconc (z:node-inferiors top) (list cur-dif-node))))
	      (when last-dif-node
		(setf (z:node-next last-dif-node) cur-dif-node)
		(setf (z:node-previous cur-dif-node) last-dif-node))
	      (setq last-dif-node cur-dif-node))))
    (insert-line-at-end-of-interval 
      (make-annotated-diagram-line
	"============================== End Difference =============================="
	'z:black-line-diagram-with-legend :structural t
	:legend "End Difference"
	:height 3/8
	:style '(nil :bold-extended nil))
      target-node)
    (setf (z:interval-last-bp top) (z:copy-bp (z:interval-last-bp target-node) :normal))
    (setf (z:node-tick top) :read-only)))
EDL 2
EFS 72
BFS 73
BDL 2


;;; Flavor to accumulate an annotated comparison in a result.
;;; This can be used to display a comparison, or to run a merge.
;;; In fact, running a merge consists of mapping the correct 
;;; stuff across the data structure that this produces.

;;; unlike the commented out code above, this code creates no special node 
;;; structure and no diagram lines.  It writes text into the buffer that 
;;; it (or the user) can then find. 

;;; This writes the compare results, together with annotations describing
;;; unresolved differences, into an interval.

;;; As each difference is written, a :record-difference is sent to self.
;;; This allows a mixin to build a possibilities buffer to track along
;;; the differences.

(defflavor no-diagrams-annotated-compare-result-mixin
	(target-interval)
	()
  (:documentation
   :mixin
   "Provides the process-common-line, process-common-interval and process-difference
methods for merging into an interval.")					
  (:required-flavors basic-compare)
  (:initable-instance-variables target-interval)
  (:required-init-keywords :target-interval)
  )
EDL 2
EFS 73
BFS 74
BDL 2

(defmethod (process-common-line no-diagrams-annotated-compare-result-mixin) (line)
  (let ((new-line (z:copy-line line target-interval)))
    (insert-line-at-end-of-interval new-line target-interval)))
EDL 2
EFS 74
BFS 75
BDL 2

(defmethod (process-common-interval no-diagrams-annotated-compare-result-mixin) (interval)
  (insert-copy-of-interval interval target-interval))
EDL 2
EFS 75
BFS 76
BDL 2

(defun insert-annotation-comment (target-interval format-string &rest format-args)
  (z:with-editor-stream (s :interval target-interval :no-redisplay t)
    (scl:with-character-face (:bold s)
      (if z:*comment-start*
	  (progn
	    (format s "~&~A " z:*comment-start*)
	    (apply #'format s format-string format-args)
	    (format s " ~A" z:*comment-end*))
	  (let ((four-comments
		  (if (> (length z:*comment-begin*) 1) z:*comment-begin*
		      (make-string 4 :initial-element (char z:*comment-begin* 0)))))
	    (format s "~&~A " four-comments)
	    (apply #'format s format-string format-args)
	    (format s "~%"))))))
EDL 2
EFS 76
BFS 77
BDL 2

(defconstant *difference-tag-start* "COMPARE-MERGE")
EDL 2
EFS 77
BFS 78
BDL 2
(defconstant *begin-difference-tag* "COMPARE-MERGE Start Difference")
EDL 2
EFS 78
BFS 79
BDL 2
(defconstant *end-difference-tag* "COMPARE-MERGE End Difference")
EDL 2
EFS 79
BFS 80
BDL 2
(defconstant *begin-difference-text-tag* "COMPARE-MERGE Text for ")
EDL 2
EFS 80
BFS 81
BDL 2
(defconstant *difference-no-text-tag* "COMPARE-MERGE Nothing in ")
EDL 2
EFS 81
BFS 82
BDL 2

(defmethod (process-difference no-diagrams-annotated-compare-result-mixin) (dif)
  (insert-annotation-comment target-interval *begin-difference-tag*)
  (loop for x from 0 to (- (compare-difference-n-source-sets dif) 1)
	as tag-list = nil			
	do
    (let ((ss (compare-difference-get-source-set dif x))
	  (set-dif-text-int nil)
	  (set-dif-null nil))	  
      (setq set-dif-text-int (sse-interval (first ss)))	; interval of the difference
						;  text
      (setq set-dif-null (null-interval-p set-dif-text-int))
      (let ((tags (loop for s in ss
			as source-x = (sse-source-x s)
			collect (list (send self :tag-string source-x)
				      (send self :description source-x)))))
	(setq tags (stable-sort tags #'string-lessp :key #'first))
	(insert-annotation-comment target-interval
				   "~A~:{~A - \"~A\" ~}"
				   (if set-dif-null
				       *difference-no-text-tag*
				       *begin-difference-text-tag*)
				   tags))
      (unless set-dif-null
	(insert-copy-of-interval set-dif-text-int target-interval))))
  (insert-annotation-comment target-interval *end-difference-tag*))
EDL 2
EFS 82
BFS 83
BDL 2

(defflavor typeout-differences-result-mixin
	(stream)
	()
  (:documentation
   :mixin
   "Provides the process-common-line, process-common-interval and process-difference 
methods for typing out differences.")
  (:required-flavors basic-compare)
  (:initable-instance-variables stream)
  (:required-init-keywords :stream)
  )
EDL 2
EFS 83
BFS 84
BDL 2

(defmethod (process-common-line typeout-differences-result-mixin) (line)
  (ignore line))
EDL 2
EFS 84
BFS 85
BDL 2

(defmethod (process-common-interval typeout-differences-result-mixin) (interval)
  (ignore interval))
EDL 2
EFS 85
BFS 86
BDL 2

(defmethod (process-difference typeout-differences-result-mixin) (dif)
  (loop for x from 0 to (- (compare-difference-n-source-sets dif) 1)
	as tag-list = nil
	do
    (let ((ss (compare-difference-get-source-set dif x))
	  (set-dif-text-int nil)
	  (set-dif-null nil))	  
      (setq set-dif-text-int (sse-interval (first ss)))	; interval of the difference
						;  text
      (setq set-dif-null (null-interval-p set-dif-text-int))
      (let ((tags (loop for s in ss
			as source-x = (sse-source-x s)
			collect (list (send self :tag-string source-x)
				      (send self :description source-x)))))
	(setq tags (stable-sort tags #'string-lessp :key #'first))
	(format stream "~2&~A~:{~A - \"~A\" ~}"
		(if set-dif-null
		    *difference-no-text-tag*
		    *begin-difference-text-tag*)
		tags))
      (unless set-dif-null
	(format stream "~A" (z:string-interval set-dif-text-int))))))
EDL 2
EFS 86
BFS 87
BDL 2

(defmethod (do-comparison typeout-differences-result-mixin :after) ()
  (format stream "~2&Done."))
EDL 2
EFS 87
BFS 88
BDL 2

;;; Copied from Tags Search

(z:define-special-buffer-type visit-differences-buffer
	((current-difference-info nil)
	 (current-buffer nil)
	 (setup-merge-acceleration-p nil))
	(z:tag-table-user-special-purpose-buffer)
	visit-differences "Compare-Merge-Differences"
  (:settable-instance-variables setup-merge-acceleration-p)
  (:buffer-init-options :set-setup-merge-acceleration-p))
EDL 2
EFS 88
BFS 89
BDL 2

(defmethod (:description-1 visit-differences-buffer) (stream)
  (format stream "Compare differences"))
EDL 2
EFS 89
BFS 90
BDL 2

(defmethod (:header-description visit-differences-buffer) (stream)
  (format stream "Compare differences"))
EDL 2
EFS 90
BFS 91
BDL 2

(defmethod (:document visit-differences-buffer) (ignore)
  (format t "Search for the next compare difference."))
EDL 2
EFS 91
BFS 92
BDL 2

;;; at some point, set up a minor mode with commands that parse for the
;;; difference texts and accelerate things.
(defmethod (:select-possibility visit-differences-buffer) (starting-buffer)
  (cleanup-merge-acceleration self)		;clean up from the last one.
  (loop for buffer = starting-buffer then (send self :next-buffer)
	for bp = (if (eq buffer z:*interval*) (z:point) (z:buffer-saved-point buffer))
	       then (z:interval-first-bp buffer)
	when
	  (setq bp (let ((z:*interval* buffer))
		     (z:search bp *begin-difference-tag* nil nil nil nil t)))
	  do
	    (z:point-pdl-push (z:point) z:*window*)
	    (when (neq buffer current-buffer)
	      (send z:*zmacs-command-loop* :set-interval buffer))
	    (setq current-buffer buffer)
	    (setup-merge-acceleration self bp)
	    (z:move-bp (z:point) bp)
	    (return z:dis-text)))

EDL 2
EFS 92
BFS 93
BDL 2

(z:define-special-buffer-type compare-result-buffer () (z:special-purpose-buffer)
			      compare "Compare")

(compile-flavor-methods compare-result-buffer)

EDL 2
EFS 93
BFS 94
BDL 2

;;; a bunch of zwei support for accelerating editing of merge
;;; differences.  they all depend on the 'merge-difference-node property
;;; of *interval* as the current state.  If there isn't one of those, they refuse to
;;; operate.
;;;
;;; The basic interaction is to point at the tag-line for a particular tag and
;;; click to add that to the text.

(z:defminor nil merge-acceleration "Merge" 1 "" nil
	    ;; I would like to organize this as a separate comtab containing
	    ;; all the relevant commands, but it dosen't seem possible.
	    ;; what a pain.
	    (z:set-comtab z:*mode-comtab*
			  `(#\s-z ,(z:make-extended-command *super-z-comtab*)
			    #\s-c-S com-swap-merge-difference-info
			    #\s-c com-take-merge-choice)
			  (z:make-command-alist '(edit-compare-differences
						   tags-edit-compare-differences))))

(defvar *merge-acceleration-mode* (z:mode-of-flavor 'merge-acceleration))
EDL 2
EFS 94
BFS 95
BDL 2

(z:defminor com-test-merge-environment test-merge-environment "Test-Merge" 1 "" nil
	    (z:set-comtab z:*mode-comtab*
			  `(#\s-z ,(z:make-extended-command *super-z-comtab*)
			    #\s-c-S com-swap-merge-difference-info
			    #\s-c com-take-merge-choice)
			  (z:make-command-alist '(edit-compare-differences))))
EDL 2
EFS 95
BFS 96
BDL 2

(z:define-presentation-to-editor-command-translator
  take-merge-choice
  (z:bp "Take Merge Choice"
      z:*zmacs-comtab*
      :blank-area nil
      :tester ((bp &key window)
	       (let ((zwei-window (send-if-handles window
						   :zwei-window)))
		 (and zwei-window
		      (z:disable-for-other-window-tester
			zwei-window nil)
		      bp
		      (send z:*interval* :get 'merge-difference-node)
		      (getf (z:line-plist (z:bp-line bp)) 'begin-for-tags)
		      )))
      :gesture :super-right)
  (bp &key window)
  `(mouse-take-merge-choice ,bp ,(send window :zwei-window))
  )
EDL 2
EFS 96
BFS 97
BDL 2

(defun mouse-take-merge-choice (bp window)
  (append-choice-to-merge-result
    (send z:*interval* :get 'merge-difference-node)
    (first (getf (z:line-plist (z:bp-line bp)) 'begin-for-tags)))
  (z:must-redisplay window z:dis-text))
EDL 2
EFS 97
BFS 98
BDL 2

(defmethod (cleanup-merge-acceleration visit-differences-buffer) ()
  (when (and current-buffer setup-merge-acceleration-p)
    (when (send z:*interval* :get 'merge-difference-node)
      (cleanup-merge-difference-node (send z:*interval* :get 'merge-difference-node)))
    (send z:*interval* :remprop 'merge-difference-node)
    (z:turn-off-mode *merge-acceleration-mode*))
    )
EDL 2
EFS 98
BFS 99
BDL 2

(defmethod (setup-merge-acceleration visit-differences-buffer) (bp)
  (when setup-merge-acceleration-p
    (send z:*interval*
	  :putprop (make-instance 'merge-difference-node :key-bp bp) 'merge-difference-node)
    (z:turn-on-mode *merge-acceleration-mode*)
    ))
EDL 2
EFS 99
BFS 100
BDL 2

(defmethod (:popping-possibility visit-differences-buffer) ()
  (cleanup-merge-acceleration self))
EDL 2
EFS 100
BFS 101
BDL 2

;;; This flavor is the result of parsing the test in the buffer 
;;; to re-learn what the comparison stuff already knew. Oh well.
;;; It is in fact a node, with inferiors for each of the individual regions.
(defflavor merge-difference-node
	((tag-interval-alist nil) ; (TAG-STRING INFO INTERVAL)
	 (merged-text-bp nil)
	 (other-info-string)
	 (copy-for-undo)
	 (killed-copy))				;to swap back and forth between
						;showing merge-so-far and annotations.
	(z:node)
  (:init-keywords :key-bp)
  (:required-init-keywords :key-bp))
EDL 2
EFS 101
BFS 102
BDL 2

(defmethod (make-instance merge-difference-node) (&key key-bp &allow-other-keys)
  ;; This method has to parse the difference node.
  ;; there are two forms:
  ;; COMPARE-MERGE Start Difference 
  ;; COMPARE-MERGE Text for TAG-STRING1 ... TAG-STRING-N - FILE-INFO1 ... FILE-INFO-N
  ;; {text}
  ;; COMPARE-MERGE End Difference
  ;; 
  ;; or
  ;; COMPARE-MERGE Start Difference 1 one line of inserted commentary.
  ;; or
  ;; COMPARE-MERGE Start Difference *
  ;; multiple lines of commentary
  ;; COMPARE-MERGE End Difference
  ;;
  ;; the key-bp points just after the end of the COMPARE-MERGE Start Difference.
  ;;
  (setq z:first-bp nil z:last-bp nil)		;initialize 
  (if (and (< (z:bp-index key-bp) (length (z:bp-line key-bp)))
	   (char-equal #\1 (char (z:bp-line key-bp) (1+ (z:bp-index key-bp)))))
      (setq other-info-string (substring (z:bp-line key-bp) (1+ (z:bp-index key-bp))))
      (let ((end-bp (z:search key-bp *end-difference-tag* nil nil nil nil t)))
	(unless end-bp (z:barf "Malformed compare annotation, no ~A." *end-difference-tag*))
	(setq end-bp (z:beg-line end-bp))
	(setq z:first-bp (z:copy-bp (z:beg-line key-bp 0) :normal z:*interval*))
	(setq z:last-bp (z:copy-bp (z:beg-line end-bp 1) :moves z:*interval*))
	(setq copy-for-undo (z:make-interval 'z:interval :initial-line t))
	(z:copy-interval self nil nil copy-for-undo)
	(if (or (= (z:bp-index key-bp) (1- (length (z:bp-line key-bp))))
		(null (zl:string-search-not-set z:*whitespace-chars*
					       (z:bp-line key-bp)
					       (z:bp-index key-bp))))
	    (progn
	      (setq merged-text-bp (z:create-bp (z:bp-line (z:beg-line key-bp 1)) 0 :moves))
	      (parse-compare-difference self (z:beg-line key-bp 1) end-bp))
	    ;; assume that the * is present if the 1 isn't and it ain't whitespace.
	    (setq other-info-string
		  (z:string-interval (z:beg-line key-bp 1) end-bp t))))))
EDL 2
EFS 102
BFS 103
BDL 2
	 
(defmethod (cleanup-merge-difference-node merge-difference-node) ()
  (when z:first-bp
    (z:flush-bp z:first-bp))
  (when z:last-bp
    (z:flush-bp z:last-bp))
  (when merged-text-bp
    (z:flush-bp merged-text-bp))
  (loop for (tag-string info interval) in tag-interval-alist do
    (ignore info tag-string)
    (z:flush-bp (z:interval-first-bp interval))
    (z:flush-bp (z:interval-last-bp interval))))
EDL 2
EFS 103
BFS 104
BDL 2

(defmethod (remove-merge-difference-information merge-difference-node)
	   (keep-taken-text save-name)
  (declare (values not-aready-killed))
  (if killed-copy nil
      (setq killed-copy (z:copy-interval self))
      (if (not keep-taken-text)
	  (progn
	    (z:kill-interval self nil nil t nil (not (null save-name)))	;just wipe the thing
	    (when save-name
	      (setq z:*undo-type* save-name)))	;rename the kill
	  (when save-name
	    (z:undo-save self nil nil save-name))
	  (z:delete-interval z:first-bp (z:beg-line z:first-bp 1) t)
	  (z:delete-interval merged-text-bp z:last-bp t))))
EDL 2
EFS 104
BFS 105
BDL 2
      
(defmethod (return-merge-difference-information merge-difference-node) ()
  (declare (values nil-if-not-removed))
  (and killed-copy
       (progn
	 (z:delete-interval self)
	 (z:insert-interval z:last-bp killed-copy)
	 (setq killed-copy nil)
	 (parse-compare-difference self z:first-bp z:last-bp)	;reconstruct old info.
	 ;;merged text ends at the first tag 
	 (z:move-bp merged-text-bp
		    (z:beg-line (z:search (z:beg-line z:first-bp 1) *difference-tag-start*
					  nil nil nil z:last-bp) 0))
	 t)))
EDL 2
EFS 105
BFS 106
BDL 2

(defmethod (merge-information-hidden-p merge-difference-node) ()
  (not (null killed-copy)))
EDL 2
EFS 106
BFS 107
BDL 2

(defun insure-merge-difference-node ()
  (declare (values current-merge-difference-node))
  (or (send z:*interval* :get 'merge-difference-node)
      (z:barf "There is no current merge difference node")))
EDL 2
EFS 107
BFS 108
BDL 2

(defmacro with-merge-difference-node ((node-var) &body body)
  `(let ((,node-var (insure-merge-difference-node)))
     ,@body))
EDL 2
EFS 108
BFS 109
BDL 2

(z:defcom com-swap-merge-difference-info
	  "If merge difference information for the current merge difference is
visible, hide it. If it is invisible, display it."
	  ()
  (with-merge-difference-node (mdn)
    (if (merge-information-hidden-p mdn)
	(return-merge-difference-information mdn)
	(remove-merge-difference-information mdn t nil)	;don't setup conventional Undo
	))
  z:dis-text)
EDL 2
EFS 109
BFS 110
BDL 2

(z:defcom com-take-merge-choice
	  "Prompt for a tag, and inserts the text for that tag into the merge results."
	  ()
  (with-merge-difference-node (mdn)
    (let ((tag (z:prompt-line-activate (accept 'character :prompt "Tag?"))))
      (let ((success (append-choice-to-merge-result mdn tag)))
	(if success z:dis-text (z:barf "Tag ~A not defined." tag))))))
EDL 2
EFS 110
BFS 111
BDL 2

(defvar *super-z-comtab* (z:set-comtab "Super-Z merge acceleration" nil nil))

(z:set-comtab *super-z-comtab*
	      '(( #\A 26) com-prefix-take
		(#\s-a 26) com-prefix-take-activate))

(z:set-comtab-control-indirection *super-z-comtab*)
EDL 2
EFS 111
BFS 112
BDL 2

(z:defcom com-prefix-take
	  "Takes the merge choice indicated by the command character and adds it to
the merge result.  For example, s-Z A will add the text for A to the merge."
	  ()
  (with-merge-difference-node (mdn)
    (let ((success (append-choice-to-merge-result mdn (string z:*last-command-char*))))
      (if success z:dis-text (z:barf "Tag ~A not defined." z:*last-command-char*)))))
EDL 2
EFS 112
BFS 113
BDL 2

(z:defcom com-prefix-take-activate
	  "Takes the merge choice indicated by the command character and adds it to
the merge result. Remove the difference information, and ask for confirmation.
For example, s-Z s-A will add the text for A to the merge."
	  ()
  (with-merge-difference-node (mdn)
    (let ((success (append-choice-to-merge-result mdn (string z:*last-command-char*))))
      (unless success (z:barf "Tag ~A not defined." z:*last-command-char*)))
    (let ((confirmed nil))
      (unwind-protect
	  (progn
	    (remove-merge-difference-information mdn t nil)
	    (z:must-redisplay z:*window* z:dis-text)
	    (z:redisplay z:*window*)
	    (setq confirmed (z:prompt-line-activate
			      (y-or-n-p "OK?"))))
	(unless confirmed
	  (return-merge-difference-information mdn)))
      z:dis-text)))



#|
(z:set-comtab z:*zmacs-comtab* () (z:make-command-alist '(com-test-merge-environment)))
|#
EDL 2
EFS 113
BFS 114
BDL 2

(defun parse-compare-difference-text-line (line begin-index)
  "begin-index is the index after \"... text for \""
  (declare (values tag-list other-info-string))
  (let ((after-all-tags-index			;where is the limit of this?
	  (string-search " - " line :start2 begin-index))
	(tag-list nil))
    (assert after-all-tags-index ()
	    "Compare difference line ~A is malformed. It has no \"-\"." line)
    (loop for start-index =
	      (zl:string-search-not-set z:*whitespace-chars* line begin-index)
	      then (zl:string-search-not-set z:*whitespace-chars* line after-tag-index)
	  as after-tag-index =
	     (zl:string-search-set
	       z:*whitespace-chars* line start-index)
	  do
      (let ((this-tag-string (substring line start-index after-tag-index)))
	(push this-tag-string tag-list)
	(when ( after-tag-index after-all-tags-index)	; space of " - " is after last tag
	  ;; the remainder is the info as a string
	  (setq tag-list (nreverse tag-list))
	  (return-from parse-compare-difference-text-line
	    (values tag-list
		    (with-input-from-string
		      (line-stream line :start (+ 3 after-all-tags-index))
		      (loop for x from 1 to (length tag-list)
			    collecting
			      (read line-stream nil nil))))))))))
EDL 2
EFS 114
BFS 115
BDL 2

;;; this node spans the difference, but the line-nodes don't indicate the node.
;;; Doing so would interact poorly with ordinary sectionization.
;;; instead, entries are made in the line-plist (not line-contents-plist)
;;; that indicate the sub-intervals for the different parts of the difference.
;;; this is a speed-up for mapping from a line up to the compare structure.
;;; an unsolved problem with this is if the user edits in one of the difference regions 
;;; and adds a line.  There is no good way to fix it.

(defmethod (parse-compare-difference merge-difference-node) (start-bp end-bp)
  ;; scan along lines, looking for Text for header lines.
  (let ((this-start-bp nil)
	(this-tag)
	(this-info)
	(last-tag)
	)
    (z:linemap (start-bp end-bp)
      (let ((tag-index
	      (string-search *begin-difference-text-tag* (z:linemap-line)))
	    (end-diff-p (or (string-search *end-difference-tag* (z:linemap-line))
			    (string-search *difference-no-text-tag* (z:linemap-line))
			    )))
	(when tag-index
	  (incf tag-index (length *begin-difference-text-tag*))
	  (setq last-tag this-tag)
	  (multiple-value-setq (this-tag this-info)
	    (parse-compare-difference-text-line (z:linemap-line) tag-index))
	  (setf (getf (z:line-plist (z:linemap-line)) 'begin-for-tags) this-tag))
	(when (or tag-index end-diff-p)
	  (when this-start-bp
	    (let ((int (z:make-interval	;this may be empty ...
			 'z:interval
			 :first-bp (z:copy-bp this-start-bp :normal z:*interval*)
			 :last-bp (z:create-bp (z:linemap-line) 0 :moves z:*interval*))))
	      (loop for tag in this-tag for info in this-info
		    do
		(push (list tag info int) tag-interval-alist))
	      (z:linemap-interval (int)
		(setf (getf (z:line-plist (z:linemap-line)) 'data-for-tags) last-tag)))
	    (setq this-start-bp nil this-info nil))
	  (when tag-index
	    (setq this-start-bp
		  (z:create-bp (z:line-next-in-buffer (z:linemap-line)) 0))))))))
EDL 2
EFS 115
BFS 116
BDL 2

(defmethod (merge-choices-tag-info merge-difference-node) () tag-interval-alist)
EDL 2
EFS 116
BFS 117
BDL 2

(defmethod (append-choice-to-merge-result merge-difference-node) (tag)
  (declare (values tag-found))
  (let ((tag-info (assoc tag tag-interval-alist :test #'string-equal)))
    (and tag-info
	 (progn
	   (let ((int (z:copy-interval (third tag-info))))
	     (z:insert-interval merged-text-bp int))
	   t))))

(compile-flavor-methods merge-difference-node visit-differences-buffer)
EDL 2
EFS 117
BFS 118
BDL 2

;;; There are three reasonable interfaces to this.  
;;; First, the interface to comparisons that use this annotation scheme can 
;;; make a new tag table out of all the result buffers and then set this loose on it.
;;;
;;; Second, a Tags Resolve Compare Differences command can run this across 
;;; an arbitrary tag table.
;;;
;;; Third, a Resolve Compare Differences command can make up a tag table with
;;; just one buffer and use that. (and kill it afterwards).

(defun start-visiting-differences-in-buffers (buffer-list &key merge-acceleration-p)
  (z:select-tag-table				; invent the tag table
    ':buffers-tag-table
    ':set-buffers-list buffer-list
    ':set-tag-table-name (format nil "Some buffers with compare-merge results"))
  (z:select-tag-table-user 'visit-differences	; and put it to work with c-.
			   :set-setup-merge-acceleration-p merge-acceleration-p))
EDL 2
EFS 118
BFS 119
BDL 2

(z:defcom tags-edit-compare-differences
	  "Sets up 1c0-. to visit all of the compare differences in the current tags
table." ()
  ;; merge acceleration? I see no harm in it.
  (z:select-tag-table-user 'visit-differences :set-setup-merge-acceleration-p t))
EDL 2
EFS 119
BFS 120
BDL 2

(z:defcom edit-compare-differences
	  "Sets up 1c0-. to visit all of the compare differences in the current buffer."
	  ()
  (start-visiting-differences-in-buffers (list z:*interval*) :merge-acceleration-p t))
EDL 2
EFS 120
BFS 121
BDL 2


(defflavor automatically-resolve-differences-mixin
	((convergence-ok nil)
	 (original-source nil)
	 (force-edit-list nil)
	 (n-resolved 0)
	 (annotate-auto-resolutions nil))	
	()
  (:required-flavors basic-compare)
  (:documentation
   :mixin
   "Tries to choose one of a set of differences using
information about the change history.")
  (:initable-instance-variables annotate-auto-resolutions))
EDL 2
EFS 121
BFS 122
BDL 2

(defmethod (other-source-info automatically-resolve-differences-mixin)
	   (source-plist source-x)
  (when (or (getf (cdr source-plist) :original)
	    (getf (cdr source-plist) :old-original))
    (when original-source
      (error "More than one source specified with the :original or :old-original attribute"))
    (setq original-source source-x)
    (when (getf (cdr source-plist) :old-original)
      (setq convergence-ok t)))
  (when (getf (cdr source-plist) :force-edit)
    (push source-x force-edit-list)))

#|
The difference resolver resolves differences when the various sources sort
out into two group, and no more. There are two cases considered:

  (A) If all of the sources save one agree with the original, then
the dissenter is always taken as a valid resolution UNLESS it is a member
of the force-edit list. 

  (B) If the group that disagrees with the original has more than one
member, then the resolution proceeds only if the convergence-ok flag
is t, and none of the dissenters are in the force-edit list. The convergence-ok
flag should only be set if the original is OLD, that it, that there was a lost
itermediate between the original and some or all of the other participating
sources. In that case, it is expected that sources that diverged from
the "missing link" will have common changed. If the original is not old, then
common differences are coincidences, and still require manual resolution.
|#
EDL 2
EFS 122
BFS 123
BDL 2

(defun-in-flavor (get-dissenter-list automatically-resolve-differences-mixin)
	      (difference &aux dissenter-source-set)
  ;; this can assume that there are only 2 source sets,
  ;; since it is only called if that is already known
  (loop for d from 0 to 1 named search do
    (setq dissenter-source-set (compare-difference-get-source-set difference d)); maybe
    ;; if this is the dissenter set, then the inner loop will complete and
    ;; return from the outer loop with the right values.
    ;; if not, it will just return here, and the outer loop will try the other
    ;; (neccessarily correct) source set.
    (loop named search-1 for source-and-interval in dissenter-source-set
			     ;; collect source-list in case this is the good pass.
	  collecting (sse-source-x source-and-interval) into source-list 
	  finally
	    (return-from search
	      (values source-list
		      (sse-interval (first dissenter-source-set))	; the interval
		      ))
	  do
      (when (= (sse-source-x source-and-interval) original-source)
	(return-from search-1 nil)))))

EDL 2
EFS 123
BFS 124
BDL 2

(defwhopper (process-difference automatically-resolve-differences-mixin)
	    (difference)
  (let ((dissenter-source-list)
	(dissenter-text-interval))
    (cond ((and original-source
		(= (compare-difference-n-source-sets difference) 2)
		(multiple-value-setq (dissenter-source-list dissenter-text-interval)
				     (get-dissenter-list difference))
						; guaranteed non-null, so the and is OK
		(null (intersection dissenter-source-list force-edit-list :test #'=))
						; no dissenters that decline
						; responsibility
		(or (= (length dissenter-source-list) 1)	; only one dissenter
		    convergence-ok))
						; old original, multiple dissenters permitted
	   ;; it passes, now report the interval as common
	   (when annotate-auto-resolutions
	     (send self :auto-resolved-difference
		   difference dissenter-source-list dissenter-text-interval))
	   (process-common-interval self dissenter-text-interval)
	   (incf n-resolved)			
	   ;; and we are completely done
	   )
	  (t (continue-whopper difference)))))
EDL 2
EFS 124
BFS 125
BDL 2

(defmethod (:auto-resolved-difference automatically-resolve-differences-mixin :default)
	   (difference dissenter-source-list dissenter-text-interval)
  (ignore difference dissenter-source-list dissenter-text-interval))
EDL 2
EFS 125
BFS 126
BDL 2

(defmethod (:auto-resolved-difference typeout-differences-result-mixin)
	   (difference dissenter-source-list dissenter-text-interval)
  (ignore difference dissenter-source-list dissenter-text-interval)
  )
EDL 2
EFS 126
BFS 127
BDL 2

(defmethod (:auto-resolved-difference no-diagrams-annotated-compare-result-mixin)
	   (difference dissenter-source-list dissenter-text-interval)
  (ignore difference dissenter-source-list dissenter-text-interval)
  )
EDL 2
EFS 127
BFS 128
BDL 2


(defflavor compare-zmacs-buffers
	()
	(basic-compare)
  (:documentation
   "Runs the compare algorithm, uses the automatic resolution
stuff.")
  (:init-keywords
   :automatically-resolve-differences
   :target-interval
   :typeout-differences
   :annotate-auto-resolutions)
  (:default-init-plist 
   :target-interval nil
   :typeout-differences nil
   :automatically-resolve-differences nil)
  (:mixture
   (:automatically-resolve-differences automatically-resolve-differences-mixin)
   (:target-interval (nil nil) (otherwise no-diagrams-annotated-compare-result-mixin))
   (:typeout-differences (nil nil) (otherwise typeout-differences-result-mixin)))
  :abstract-flavor
  )
EDL 2
EFS 128
BFS 129
BDL 2

;;; a couple of methods to circumvent :mixture limitations.  (to whit:
;;; there is no way to make the :automatically-resolve-differences mixin
;;; dependent on the OR of :target-interval and :typeout-differences).

(defmethod (process-common-line compare-zmacs-buffers) (ignore))
EDL 2
EFS 129
BFS 130
BDL 2
(defmethod (process-common-interval compare-zmacs-buffers) (ignore))
EDL 2
EFS 130
BFS 131
BDL 2

(defmethod (make-instance compare-zmacs-buffers) (&key target-interval typeout-differences
						       &allow-other-keys)
  (assert (or target-interval typeout-differences)
	  ()
	  "Either :target-interval or :typeout-differences must be supplied."))

(compile-flavor-methods compare-zmacs-buffers)
EDL 2
EFS 131
BFS 132
BDL 2

(defun compare-merge-intervals (source-list
				&key
				target-interval
				automatically-resolve-differences
				typeout-differences
				annotate-auto-resolutions)
  (let ((comparison
	  (make-instance 'compare-zmacs-buffers
			 :sources source-list
			 :target-interval target-interval
			 :automatically-resolve-differences automatically-resolve-differences
			 :typeout-differences typeout-differences
			 :annotate-auto-resolutions annotate-auto-resolutions)))
    (do-comparison comparison)
    comparison))
EDL 2
EFS 132
BFS 133
BDL 2

;;;The following functions support bulk processing of merges. The plan is this:
;;;
;;;1) read N starnames, each marked as usual with original/old original/force edit.
;;;2) read a target starname.
;;;3) expand all of the starnames, and sort on the file names (less the version)
;;;4) find matching names.
;;;5) pairwise run the whole business.

(defun zmacs-compare-merge-files (source-pn-list result-disposition
				  &key
				  typeout-differences
				  (target nil target-p)
				  auto-merge-p)
  "source-list is a plist with the pathname or buffer in the car"
  (ecase result-disposition
    ((:pathname :buffer)
     (assert target-p () "A target buffer or pathname must be supplied with ~ 
:result-disposition of :pathname or :buffer"))
    ((:overwrite :special-buffer) ; these require no checking, for now
     ))
  ;; :overwrite requires the last
  (let ((source-buffer-list
	  (loop with desc
		for (source . options) in source-pn-list
		as buf = (etypecase source
			   (zwei:buffer
			     (setq desc (format nil "Buffer ~A" (send source :name)))
			     source)
			   (pathname
			     (setq desc (format nil "File ~A" source))
			     (z:find-editor-buffer
			       :pathname (send source :truename)	;flush .newest here.
			       :load-p t
			       :create-p t)))
		collect `(:interval ,buf :description ,desc ,@options)
		do
	    ;;; if the target is supposed to be :newest,
	    ;;; make sure that the source no longer thinks it is.
	    (let ((source-pn (send buf :pathname)))
	      (when (and
		      (string-equal (send target :string-for-dired)
				    (send source-pn :string-for-dired))
		      (eq (send target :version) :newest)
		      (eq (send source-pn :version) :newest))
		(sys:without-aborts ("Changing the pathname of ZMACS buffer ~A" buf)
		  (without-interrupts
		    (send buf :set-pathname (car (send buf :file-info)))
		    (send buf :set-name (send
					  (send buf :pathname) :string-for-editor)))))))))
    (let ((target-buffer
	    (case result-disposition
	      ((:buffer) target)
	      ((:special-buffer :overwrite)	;eventually, this has to
						;make arrangements to do the overwriting.
	       (send z:*current-command-loop* :find-special-buffer 'compare t))
	      ((:pathname)
	       (z:find-editor-buffer
		 :create-p t 
		 :pathname (if (not (send target :wild-p)) target
			       (let ((first-pn (if (typep (first source-pn-list)
							  'pathname)
						   (first source-pn-list)
						   (send (first source-pn-list)
							 :pathname))))
				 (send target :new-pathname
				       :name (send first-pn :name)
				       :type (send first-pn :type)
				       :version :newest))))))))
      (send target-buffer :set-not-modified)	; initialize the save-tick.
      (compare-merge-intervals source-buffer-list
			       :automatically-resolve-differences auto-merge-p
			       :typeout-differences typeout-differences 
			       :target-interval target-buffer)
      target-buffer)))
EDL 2
EFS 133
BFS 134
BDL 2

(defstruct (source-info (:conc-name si-))
  (presentation-type 'pathname)
  (prompt "Pathname")
  (qid-marker 0)
  (object)
  (options))
EDL 2
EFS 134
BFS 135
BDL 2

(defun accept-compare-sources-and-target (stream)
  (declare (values sources target edit-differences-p auto-merge-p result-disposition))
  (let ((sources)
	(target)
	(real-stream stream)
	(edit-differences-p)
	(auto-merge-p)
	(result-disposition ':pathname) 	;If :overwrite, and the last source has
						; version :NEWEST, overwrite the target.
						; if the version is wrong, just create
						; newest at the source.
						;
						;If :special-buffer, write it into
						; a buffer with a funny name.
						;
						;if :pathname, write it into a new
						; file buffer for the pathname.
						;
						;For single file comparisons,
						; there is the choice of :buffer,
						; an explicitly named non-file-buffer.
	(any-wild-pathnames-p)
	(typeout-differences)
	)
    (With-character-family (':swiss stream)
      (filling-output (stream)
	(format stream "~&Sources may be starnames.  If they are starnames, the starnames are listed, and the files in each group are matched by name and type. The compare/merge proceeds for each set of corresponding files.  Automatic merging is enabled for three or more source file sets by specifying the Original or Old-Original option for one source.  An automatic merge takes place when there are two versions of the text (i.e., some sources agree with the original, and the rest agree with each other).  With the Original option, only one of the sources may disagree with the original.  With the Old-Original option, any number may disagree. The disagreeing text becomes the final result, unless one of the disagreeing sources was marked with the Force-Edit option. The Force-Edit option on a source prevents any automatic merge where that source would become the final text."))
      (format stream "~2&")
      (dw:accepting-values (stream :label "Compare Merge" :resynchronize-every-pass t)
	(setq auto-merge-p
	      (accept 'boolean :prompt "Enable automatic merging"
		      :stream stream
		      :default auto-merge-p
		      :display-default t))
	(setq typeout-differences
	      (accept 'boolean :prompt "Type out differences on the typeout window"
		      :stream stream
		      :default typeout-differences
		      :display-default t))
	(format stream "~%")
	(setq sources
	      (dw::accept-values-on-sequence
		sources
		#'(lambda (elt stream index last-p)
		    (with-character-face ((if last-p :italic :roman) real-stream) 
		      (ignore real-stream)
		      (let ((qbase-increment 0))
			(flet ((qid (&optional (marker 0))
				 (+ (* 100000 index) (if last-p 10000 0) (* marker 1000)
				    (incf qbase-increment))))
			  (unless elt (setq elt (make-source-info)))
			  (multiple-value-bind (new-pt ignore pt-not-changed)
			      (accept '((member pathname zwei:buffer))
				      :default (si-presentation-type elt)
				      :stream stream
				      :prompt (format nil "Compare source ~D" index)
				      :query-identifier (qid)
				      :display-default t)
			    (setf (si-presentation-type elt) new-pt)
			    (unless pt-not-changed (setf (si-object elt) nil)))
			  (case (si-presentation-type elt)
			    (pathname (setf (si-prompt elt) "Pathname"
					    (si-qid-marker elt) 0))
			    (zwei:buffer (setf (si-prompt elt) "Buffer"
					       (si-qid-marker elt) 1)))
			  (setf (si-object elt)
				(accept (si-presentation-type elt)
					:default (or (si-object elt)
						     (dw:presentation-type-default
						       (si-presentation-type elt)))
					:stream stream
					:prompt (si-prompt elt)
					:query-identifier (qid (si-qid-marker elt))
					:display-default t))
			  (setf (si-options elt)
				(if auto-merge-p
				    (list
				      (accept
					'((member :none :original :old-original :force-edit))
					:prompt "Source Option or None"
					:query-identifier (qid)
					:stream stream
					:display-default t
					:default (cond
						   ((member :original (si-options elt))
						    :original)
						   ((member :old-original (si-options elt))
						    :old-original)
						   ((member :force-edit (si-options elt))
						    :force-edit)
						   (t nil))))
				    nil))
			  (unless last-p (format stream "~%"))
			  elt))))
		:stream stream
		:default nil
		))
	(format stream "~%")
	(setq any-wild-pathnames-p (some #'(lambda (si)
					     (and (pathnamep (si-object si))
						  (send (si-object si) :wild-p)))
					 sources))
	(when (and any-wild-pathnames-p
		   (eq result-disposition ':buffer))
						;not meaningful, unless it meant to
						;put all the comparisons in a single buffer.
						;there isn't technology for that, at least
						;not yet, so we force the default.
	  (setq result-disposition ':pathname)
	  (setq target nil))			;forget whatever was typed, sorry.
						;since we don't have a theory of
						;invalid input hanging around.
	(multiple-value-bind (new-result-disposition ignore result-disposition-not-changed)
	    (accept `((member :pathname :special-buffer :overwrite
			      ,@(and (not any-wild-pathnames-p) `(:buffer))))
		    :prompt "Result disposition"
		    :stream stream
		    :default result-disposition
		    :display-default t)
	  (setq result-disposition new-result-disposition)
	  (unless result-disposition-not-changed
	    (setq target nil)))
	(when (member result-disposition '(:pathname :buffer))
	  (let* ((target-pt (case result-disposition
			      (:pathname 'pathname)
			      (:buffer '((z:buffer) :create-p t))))
		 (target-prompt (if (eq target-pt 'pathname) "Target pathname"
				    "Target buffer")))
	    (setq target 
		  (accept target-pt
			  :stream stream
			  :default (or target (dw:presentation-type-default target-pt))
			  :display-default t
			  :prompt target-prompt)))))
      (values sources target edit-differences-p auto-merge-p result-disposition
	      typeout-differences)
      )))
EDL 2
EFS 135
BFS 136
BDL 2

(defun match-pathnames (&rest pathname-lists &aux matches)
  (flet
    ((same-name (x y)
       (and 
	 (string-equal (send x :name)
		       (send y :name))
	 (string-equal (send x :type)
		       (send y :type)))))
    (setq matches
	  (loop with current = (car pathname-lists)
		for next in (cdr pathname-lists)
		finally (return current)
		do
	    (setq current (intersection current next
					:test #'same-name))))
    ;; now, go back and construct the correspondance list
    (loop for m in matches ;; for each match
	  collecting
	    (loop for pl in pathname-lists ;; collect the list of pathnames
		  collecting (car (member m pl :test #'same-name))))))
EDL 2
EFS 136
BFS 137
BDL 2

(z:defcom com-compare-merge-multiple-files
	  "Prompts for a set of starnames. Run compare/merge over all
of the files for which there are correponding name.type files in the expansions
of all of the starnames. Optionally treats one of the sets as
an original or old original, enabling automatic merging of some differences.
If an original is designated, then differences where all sources (including
the original) agree and one disagrees will be resolved in favor of the 
new version. If there is an old original, differences where one sources
agree with the original and all of the others agree with each other will
be resolved in favor of the new versions. If the force edit option is
given for any sources, then they will never be used to automatically resolve
a difference."
	  ()
  (let ((source-file-list-list nil)
	(source-info-list nil)
	(corresponding-file-list nil)
	(one-buffer nil)
	(wild nil))
    (format z:*typeout-window* "~&")		;unbreak accept-values
    (multiple-value-bind (source-infos target edit-differences-p auto-merge-p
			  result-disposition typeout-differences)
	(accept-compare-sources-and-target z:*typeout-window*)
      (loop for si in source-infos
	    do
	(etypecase (si-object si)
	  (pathname
	    (when (send (si-object si) :wild-p)
	      (when one-buffer
		(z:barf "ZMACS buffers cannot be matched against starnames."))
	      (setq wild t))
	    (push
	      (loop for (file . nil) in
			(or (if (send (si-object si) :wild-p)
				(cdr (fs:directory-list (si-object si) :sorted))
				(list (list (si-object si))))
			    (z:barf "No files matched ~A." (si-object si)))
		    collecting file)
	      source-file-list-list))
	  (z:buffer
	    (when wild
	      (z:barf "A ZMACS buffer cannot be matched against a starname."))
	    (setq one-buffer t)
	    (push (list (si-object si)) source-file-list-list)))
	(push (si-options si) source-info-list))
      (setq source-file-list-list (nreverse source-file-list-list))
      (setq source-info-list (nreverse source-info-list))      
      (if wild					;implies no buffers, for now
	  (setq corresponding-file-list
		;; so match-pathname need not deal in buffers.
		(apply #'match-pathnames source-file-list-list))
	  (setq corresponding-file-list
		(list 
		  (loop for (file . nil) in source-file-list-list
			collect file))))
      (when (null corresponding-file-list)
	(z:barf "No files were found that corresponded for all sources."))
      (let ((result-buffer-list
	      (loop for set in corresponding-file-list with source-info
		    do
		(format t "~&----- Sources -----")
		(setq source-info
		      (loop for source in set
			    for source-info in source-info-list
			    collecting
			      `(,source
				:original ,(member :original source-info)
				:old-original ,(member :old-original source-info)
				:force-edit ,(member :force-edit source-info))
			    do
			(format
			  t "~&~A~:[~; Original~]~:[~; Old Original~]~:[~; Force Edit~]~%"
			  source
			  (member :original source-info)
			  (member :old-original source-info)
			  (member :force-edit source-info))))
		(format t "----- Target -----~%~A" (send target :string-for-mini))
		    collect
		      (zmacs-compare-merge-files
			 source-info result-disposition :auto-merge-p auto-merge-p
			 :target target
			 :typeout-differences (and typeout-differences z:*typeout-window*)))))
	(when edit-differences-p
	  (start-visiting-differences-in-buffers
	    result-buffer-list
	    :merge-acceleration-p t))
	z:dis-all))))				;might switch buffers,
						;and in any case we want to flush typeout

(z:set-comtab z:*zmacs-comtab* ()
	      (z:make-command-alist '(com-compare-merge-multiple-files
				       tags-edit-compare-differences
				       edit-compare-differences)))
EDL 2
EFS 137
BFS 138
BDL 2



#||
;;; The "old" user interface to all of this, with disgram lines and other
;;; wild things.

(z:define-special-buffer-type compare-differences-special-purpose-buffer
	(comparison-target-node)
	(z:reusable-possibilities-special-purpose-buffer-mixin
	  z:possibilities-special-purpose-buffer-mixin
	  z:subnode-special-purpose-buffer)
	:compare-differences "Compare-Differences"
	(:initable-instance-variables comparison-target-node)
	(:settable-instance-variables comparison-target-node)
	(:buffer-init-options :set-comparison-target-node)
	(:documentation
	  "Buffer used to keep track of all of the differences
that need editing."))
EDL 2
EFS 138
BFS 139
BDL 2

(defmethod (:revert compare-differences-special-purpose-buffer) ()
  (loop for dif-node in (send comparison-target-node :difference-nodes)
	for n = 1 then (+ 1 n)
	do
    (send self
	  :add-node 'compare-difference-node
	  :difference-top-node dif-node
	  :description (format nil "Difference ~D" n))))
EDL 2
EFS 139
BFS 140
BDL 2

(defmethod (:header-description compare-differences-special-purpose-buffer) (header-stream)
  (format header-stream "Comparison ")
  (loop for x from 0 to (- (compare-n-sources
			     (compare-difference-comparison comparison-target-node)) 1)
	do
    (format header-stream "~A "
	    (send (send comparison-target-node :comparison) :description x)))
  (format header-stream "~%"))

EDL 2
EFS 140
BFS 141
BDL 2

(defmethod (:document compare-differences-special-purpose-buffer) (mode)
  mode
  (format *standard-output* "position to the next compare difference."))
EDL 2
EFS 141
BFS 142
BDL 2

(defmethod (:list-possibilities compare-differences-special-purpose-buffer) (remaining-p)
  remaining-p) ; dont do anything
EDL 2
EFS 142
BFS 143
BDL 2

(defflavor compare-difference-node
	(difference-top-node
	 description
	 (result-text-node nil))
	(z:possibility-subnode z:node)
  (:initable-instance-variables difference-top-node description)
  (:required-init-keywords :difference-top-node :description))
EDL 2
EFS 143
BFS 144
BDL 2

(defmethod (:description compare-difference-node) (stream)
  (format stream "~A" description))
EDL 2
EFS 144
BFS 145
BDL 2


(defsubst redisplay-right-now ()
  (z:must-redisplay z:*window* z:dis-all)
  (z:redisplay z:*window* :point))
EDL 2
EFS 145
BFS 146
BDL 2

(defmethod (:select-possibility compare-difference-node) ()
  (let ((valid-choices)
	(tag-alist)
	(insert-point))
    (send z:*zmacs-command-loop* :set-interval (z:node-top-level-node difference-top-node))
    (z:move-point (z:interval-first-bp difference-top-node))
    (unless result-text-node
      (let ((d (z:bp-line (z:node-last-bp difference-top-node))))
	(setq result-text-node
	      (z:make-interval
		'z:node
		:first-bp (z:create-bp d 0 :normal)
		:last-bp (z:create-bp d 0 :moves)))
	(z:insert-line-with-leader
	  (make-annotated-diagram-line
	    "-- -- -- -- -- Text above copied from difference -- -- -- "
	    'z:dashed-line-diagram)
	  d)))
    (setq insert-point
	  (z:copy-bp (z:interval-first-bp result-text-node)
		     :moves))					; um, end problems?
    (z:must-redisplay z:*window* z:dis-bps)
    (z:recenter-window z:*window* :absolute 0.25s0)
    (z:redisplay z:*window* :point)
    (loop for dif-node in (z:node-inferiors difference-top-node) do
      (setq valid-choices (append valid-choices (send dif-node :tag-list)))
      (loop for tag in (send dif-node :tag-list) do
	(push (cons tag dif-node) tag-alist)))
    (setq valid-choices (append valid-choices '(#\end #\control-r #\rubout)))
    (loop named command-loop with choice 
	  do							; sit in a loop taking choices
      (setq choice
	    (z:prompt-line-activate
	      (loop with c = nil
		    do
		(setq c
		      (prompt-and-read
			:character
			"Text ID to insert,  to remove,  to take as is, or 1c-R 0to edit: "))
		(if (member c valid-choices :test #'char-equal)
		    (return c)
		    (beep)))))
      (let ((tag-pair (assoc choice tag-alist :test #'char-equal)))
	(cond (tag-pair
	       (z:insert-interval-moving insert-point (cdr tag-pair) nil nil)
	       (redisplay-right-now))
	      (t						; not a simple insert request
	       (case choice
		 (#\rubout
		  (z:with-read-only-suppressed (difference-top-node)
		    (let ((z:*enable-structural-diagrams* nil))
		      (z:delete-interval difference-top-node)
		      (when result-text-node
			(z:delete-interval (z:forward-line (z:node-last-bp result-text-node) -1)
					   (z:node-last-bp result-text-node)
					   t))))
		  (redisplay-right-now)
		  (setq difference-top-node nil)
		  (send z:superior :delete-node self)
		  (return-from command-loop nil)
		  )
		 (#\end 
		  (redisplay-right-now)
		  (return-from command-loop nil))
		 (#\control-r
		  (redisplay-right-now)
		  (z:control-r)
		  (z:redisplay z:*window* :point))))))))
  z:dis-text)
EDL 2
EFS 146
BFS 147
BDL 2



(z:defcom com-resolve-differences     
	     "Resolves differences for the current buffer."
  ()
  (let ((comparison-target-node (send z:*interval* :get 'target-node)))
    (unless comparison-target-node
      (z:barf "The current buffer does not contain comparison results."))
    (z:push-possibilities-buffer :start-editing :compare-differences
				    :set-comparison-target-node comparison-target-node))
  z:dis-all)

EDL 2
EFS 147
BFS 148
BDL 2

(z:defcom com-remove-comparison-header
	     "Removes the header that describes a comparison
from the current buffer."
	     ()
  (let* ((target-node (send z:*interval* :get 'target-node))
	 (buffer (z:node-top-level-node target-node)))
    (unless target-node (z:barf "The current buffer does not contain comparison results."))
    (let ((z:*enable-structural-diagrams* nil))
      (z:delete-interval (send target-node :header-node)))
    (z:reparse-attribute-list-internal z:*interval* (z:interval-stream z:*interval* nil t))
    (z:set-attribute-state-from-buffer z:*interval*)
    (z:sectionize-buffer buffer)
    (send z:*interval* :remprop 'target-node))
  z:dis-text)


EDL 2
EFS 148
BFS 149
BDL 2

(defun remove-diagrams (interval)
  (let ((z:*enable-structural-diagrams* nil))
    (loop 
      for line = (z:bp-line (z:interval-first-bp interval)) 
      then (z:line-next line)
      while (neq line (z:bp-line (z:interval-last-bp interval)))
      do
      (when (z:line-diagram line)
	(replace-diagram-line-with-annotation line)))))
EDL 2
EFS 149
BFS 150
BDL 2

(z:defcom com-remove-compare-diagrams
	     "Replaces all diagrams with text annotations."
	     ()
  (remove-diagrams z:*interval*)
  z:dis-all)

(z:set-comtab z:*zmacs-comtab* nil
	      (z:make-command-alist '(com-resolve-differences
				      com-remove-comparison-header
				      com-compare-merge-multiple-files
				      com-remove-compare-diagrams)))


||#
EDL 2
EFS 150
E TEXT
B FTR
93
1 
"Conversion from Y:>version-control>compare-merge>flat-source>compare-merge.lisp.128" 
0 
*
93
2 
"Conversion from Y:>version-control>compare-merge>flat-source>compare-merge.lisp.129" 
0 
*
11
3 
"
" 
0 
*
11
4 
"
" 
0 
*
11
5 
"
" 
0 
*
11
6 
"
" 
0 
*
10
7 
"" 
0 
*
E FTR
