;;; -*- Mode: LISP; Package: ("Compact"); Base: 10; Lowercase: T -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; This program takes several versions of the same file and places them into a binary
;;; representation, which is more compact than the sum of the lengths of all the original
;;; files. This program will work on binary files (i.e. it does not use string compare, but
;;; = as an equality predicate), however the data must be representable in 8 bit binary
;;; bytes. There are currently two representations for the compacted data; the first is
;;; an in core data structure called FILE (bad name, and should be changed). The second is
;;; a binary 8 bit file stored on any file computer. The design goals for the representation
;;; were that it be relatively compact, relatively efficient to place a version into the
;;; compact representation, and that a file can be retrieved from the secondary storage
;;; representation, with a single linear pass.
;;; ****NOTE**** versions must be inserted in INCREASING ORDER. This restriction could
;;; be hidden by additional programming, but currently it must be adhered to.

;;; This is a lousy user interface. No attempt has been made to make it a good one.
;;; The canonical type for an archive file is :COMPACT. As far as the following functions
;;; are concerned a COMPACT-FILE is either an in-core data structure (as returned by
;;; another call to one of these functions, or the name of a file containing the compact
;;; representation.

;;; Currently supported functions:
;;; (CREATE-ARCHIVE-FILE BASE-FILE-NAME)
;;;	Takes a complete base file name (like "S:>BEE>foo.lisp.23") and creates a
;;;	in-core COMPACT-FILE structure, and writes out a COMPACT-FILE containing only
;;;	that version. The file name is the same as the base-file-name, except with the
;;;	new canonical type :COMPACT (like "S:>BEE>foo.compact"). The function returns
;;;	the in-core representation for the COMPACT-FILE.
;;; (LIST-ARCHIVE COMPACT-FILE)
;;;	Does a "DIRED" style listing of the file versions which are contained in a
;;;	COMPACT-FILE.
;;; (ARCHIVE-FILES COMPACT-FILE START-VERSION &OPTIONAL (END-VERSION START-VERSION)
;;;				(CONSERVATIVE-P T))
;;;	Takes the COMPACT-FILE and extracts the name of the files it is storing. It then
;;;	adds the new versions specified to the COMPACT-FILE. (E.g. If it is called with
;;;	"S:>BEE>foo" 24. 37., it will read in the COMPACT-FILE S:>BEE>foo.compact, discover
;;;	it is storing file versions for "S:>BEE>foo.lisp" and add files "S:>BEE>foo.lisp.24"
;;;	through "S:>BEE>foo.lisp.37" to the archive). It will give a message if a file
;;;	in the range specified is already in the archive, or if it cannot be added because
;;;	that particular version does not exist to place into the archive. After placing the
;;;	appropriate versions into the compact representation, it will delete the versions of
;;;	the file unless they have the DONT-REAP or DONT-DELETE bits set. CONSERVATIVE-P makes
;;;	the compactor check its work several times. Please dont turn this off until I do.
;;; (DEARCHIVE-FILES COMPACT-FILE START-VERSION &OPTIONAL (END-VERSION START-VERSION))
;;;	Takes the COMPACT-FILE and extracts the name of the files it should dearchive. It
;;;	then copies the specified versions out of the COMPACT-FILE and writes the new 
;;;	individual copies where the versions originally were archived from. It will attempt
;;;	to restore all properties which were settable when the file was archived.
;;;  (ARCHIVE-NEW-VERSIONS-IN-DIRECTORY
;;;     (WILD-PATHNAME &KEY (START-FILE-NAME NIL) (KEEP-NEWEST 5)
;;;	(CORRECT-SYS-DIRECTORY NIL))
;;;     Finds all of the .compact files in the given wild pathname, and adds
;;;     unarchived versions to the archive.
;;;     :correct-sys-directories is useful when the base-name lacks rel-7.
;;;  (DELETE-ARCHIVED-FILES WILD-PATHNAME)
;;;     For each .compact file in the pathname, deletes all non-reap/delete protected
;;;     files that are already stored in the archive.

;;; Bugs with the current program
;;; N^2 loop in :RESYNCHRONIZE-VERSIONS. This should give up sometime
;;; We should look for sub-regions in :OPTIMIZE-INSERT
;;; There should be the ability to for a given version say: reduce the fragmentation
;;; at this point.
;;; Still a resonable amount of fragmentation creeps in. Examine this more closely.

(defconstant *estimated-extra-length* 100)
(defconstant *string-read-growth-factor* 2000)
(defconstant *resynchronize-length* 100)

(defvar *verbose-compact* t)			; if set, tell the user what compact is doing

(defmacro archive-comment (&rest format-args)
  `(when *verbose-compact*
     (format t "~&")
     (format t ,@format-args)))

(fs:define-canonical-type :compact "COMPACT")

(defstruct (file-region :named :conc-name)
  file
  lowest-version 
  highest-version
  successor
  predecessor
  string)

(defstruct (file-plist :list* :conc-name)
  version
  byte-size					;byte size or zero if characters
  length
  plist)

(defflavor write-primitives () ())

(defflavor read-primitives () ())

(defflavor file (base-name base-version lowest-version highest-version
		 (first-region nil) (last-region nil)
		 (property-lists nil))
	   (read-primitives write-primitives)
  :gettable-instance-variables
  (:settable-instance-variables base-name highest-version last-region first-region))

(defmethod (:print-self file) (stream &rest ignore)
  (si:printing-random-object (self stream)
    (format stream "Compact-file ")
    (if (not (variable-boundp base-name))
	(format stream "<No file>")
	(format stream "~A {~D,~D}" base-name lowest-version highest-version))))

(defmethod (:describe file) ()
  (let ((initialized (variable-boundp base-name)))
    (unless initialized
      (format t "~&~S is an uninitialized Compact-file." self))
    (when initialized
      (format t "~&~S is a Compact-file." self)
      (si:with-indentation (standard-output 2)
	(format t "~&Its base file is ~A, with versions ~D through ~D"
		base-name lowest-version highest-version)
	(format t "~&It consists of the following regions:")
	(si:with-indentation (standard-output 2)
	  (loop for reg first first-region
		  then (file-region-successor reg)
		until (null reg)
		for string = (file-region-string reg)
		for length = (string-length string)
		for high = (file-region-highest-version reg)
		for low = (file-region-lowest-version reg)
		do (format t "~2&Region of ~D characters for version~:[s ~D through ~D~; ~D~]"
			   length (= low high) low high)
		   (sys:with-stack-array (ss (min 50. length)
					     :type 'art-string
					     :displaced-to string)
		     (format t "~&~S" ss))))))))

(defmacro with-character-p ((character-p filename) &body body)
  `(let ((,character-p (with-open-file (s ,filename :characters :default)
			 (send s :characters))))
     ,@body))

(defmethod (:read-base-version file) (filename)
  (archive-comment "Archiving file ~A" filename)
  (with-character-p (character-p filename)
    (with-open-file (stream filename :element-type '(cl:unsigned-byte 8) :direction :input)
      (let* ((pathname (send stream :pathname))
	     (real-pathname (fs:link-opaque-truename pathname))
	     (version (send real-pathname :version))
	     (string (make-array (send stream :length) :type art-8B)))
	(send stream :string-in nil string)
	(setq base-name (send real-pathname :new-version nil)
	      base-version version
	      lowest-version version
	      highest-version version
	      first-region (make-file-region file self
					     lowest-version version
					     highest-version version
					     string string)
	      last-region first-region
	      property-lists (ncons (settable-properties stream character-p)))))
    nil))

(defun binary-string-append (&rest strings)
  (loop with total-length = (loop for string in strings summing (array-length string))
	with target = (make-array total-length :type art-8b)
	with i = 0
	for string in strings
	as length = (array-length string)
	do (copy-array-portion string 0 length target i (+ i length))
	   (incf i length)
	finally (return target)))

(defun nbinary-substring (string start &optional (end (array-length string)))
  (make-array (- end start)
	      :type art-8B
	      :displaced-to string
	      :displaced-index-offset start))

(defun binary-substring (string start &optional (end (array-length string)))
  (let ((new-string (make-array (- end start) :type art-8B)))
    (copy-array-portion string start end new-string 0 (- end start))
    new-string))

(defmethod (:break-region file) (old-region index)
  (unless (or (eq old-region nil) (eq old-region :eof))
    (let* ((old-string (file-region-string old-region)))
      (when (and (plusp index) ( index (string-length old-string)))
	(let* ((next-region (file-region-successor old-region))
	       (new-region
		 (make-file-region file self
				   lowest-version (file-region-lowest-version old-region)
				   highest-version (file-region-highest-version old-region)
				   successor next-region
				   predecessor old-region
				   string
				   (nbinary-substring old-string index))))
	  ;; Link into list
	  (when next-region
	    (setf (file-region-predecessor next-region) new-region))
	  (setf (file-region-successor old-region) new-region)
	  ;; Truncate old region
	  (setf (file-region-string old-region) (nbinary-substring old-string 0 index))
	  ;; Fix up last-region
	  (when (eq last-region old-region)
	    (setq last-region new-region)))))))

(defmethod (:find-next-region-for-version file) (start-region for-version)
  (loop for next-region first (cond ((null start-region) first-region)
				    ((eq start-region :eof) nil)
				    (t (file-region-successor start-region)))
	  then (file-region-successor next-region)
	when (null next-region)
	return :eof
	when (and ( for-version (file-region-lowest-version next-region))
		  ( for-version (file-region-highest-version next-region)))
	return next-region))

(defmethod (:find-previous-region-for-version file) (start-region for-version)
  (loop for previous-region first (cond ((null start-region) nil)
					((eq start-region :eof) last-region)
					(t (file-region-predecessor start-region)))
	  then (file-region-predecessor previous-region)
	when (null previous-region)
	return nil
	when (and ( for-version (file-region-lowest-version previous-region))
		  ( for-version (file-region-highest-version previous-region)))
	return previous-region))

;;; Higher level functions
(defmethod (:add-new-version file) (new-version)
  (when (> new-version highest-version)
    (let ((pathname (send base-name :new-version new-version)))
      (archive-comment "Archiving file ~A" pathname)
      (with-character-p (character-p pathname)
	(with-open-file (stream pathname :element-type '(cl:unsigned-byte 8))
	  (let ((previous-file (make-instance 'file-stream :file self
					      :version highest-version)))
	    (loop with prev-buf and prev-start and prev-end
		  and cur-buf and cur-start and cur-end
		  do (multiple-value (prev-buf prev-start prev-end)
		       (send previous-file :read-input-buffer))
		     (multiple-value (cur-buf cur-start cur-end)
		       (send stream :read-input-buffer))
		  until (and (null prev-buf) (null cur-buf))
		  when (null cur-buf)		;Stream ended
		    do (send previous-file :break-region new-version)
		       (return)
		  when (null prev-buf)
		    do (send previous-file :read-rest-of-stream stream new-version)
		       (return)
		  for differ = (compare-buffers prev-buf prev-start (- prev-end prev-start)
						cur-buf cur-start (- cur-end cur-start))
		  when (plusp differ)
		    do (let ((end-index (+ prev-start differ)))
			 (send previous-file :version-same-to-index end-index new-version)
			 (send previous-file :advance-input-buffer end-index)
			 (send stream :advance-input-buffer (+ cur-start differ)))
		  else
		    do (send previous-file :break-region new-version)
		       (send previous-file :resynchronize-versions stream new-version))
	    (push (settable-properties stream character-p) property-lists)
	    (setq highest-version new-version)))))))

(defun settable-properties (stream character-p)
  (multiple-value-bind (properties settable-properties)
      (send stream :properties)
    (let ((byte-size (get properties :byte-size)))
      (when (or character-p (null byte-size))
	(setq byte-size 0))			;Character mode
      (make-file-plist version (send (car properties) :version)
		       byte-size byte-size
		       length (send stream :length)
		       plist (loop for (prop value) on (cdr properties) by 'cddr
				   when (memq prop settable-properties)
				   nconc (list* prop value nil))))))

;;; Write and reading compact files
(defconstant *compact-file-version* 1)

(defconstant *compact-op-version* 1)
(defconstant *compact-op-header* 2)
(defconstant *compact-op-property-list* 3)
(defconstant *compact-op-region* 4)
(defconstant *compact-op-eof* 5)

(defmethod (:write-compact-file file) (filename)
  (archive-comment "Saving archive file ~A" filename)
  (with-open-file (stream filename :direction :output :characters nil :byte-size 8)
    (send self :write-file-version stream)
    (send self :write-file-header stream)
    (send self :write-property-lists stream)
    (loop for region first first-region then (file-region-successor region)
	  while region
	  do (send self :write-region stream region))
    (send self :write-eof stream)))

(defmethod (:write-file-header file) (stream)
  (send stream :tyo *compact-op-header*)
  (send self :write-string stream (format nil "~A" base-name))
  (send self :write-number stream base-version)
  (send self :write-number stream lowest-version)
  (send self :write-number stream highest-version))

(defmethod (:write-property-lists file) (stream)
  (send stream :tyo *compact-op-property-list*)
  (send self :write-number stream (length property-lists))
  (loop with base = 10 
	for pl in property-lists
	do (send self :write-number stream (file-plist-version pl))
	   (send stream :tyo (file-plist-byte-size pl))
	   (send self :write-number stream (file-plist-length pl))
	   (send self :write-string stream (format nil "~S" (file-plist-plist pl)))))

(defmethod (:read-compact-file file) (filename)
  (archive-comment "Reading archive file ~A" filename)
  (with-open-file (stream filename :characters nil :byte-size 8)
    (send self :read-file-info stream)
    (loop while (send self :read-regions stream))
    (send self :read-eof stream)))

(defmethod (:read-compact-file-header file) (filename)
  (with-open-file (stream filename :characters nil :byte-size 8)
    (send self :read-file-info stream)))

(defmethod (:read-file-info file) (stream)
  (send self :read-file-version stream)
  (multiple-value (base-name base-version lowest-version highest-version)
    (send self :read-file-header stream))
  (setq first-region nil last-region nil)
  (setq property-lists (send self :read-property-lists stream)))

(defmethod (:read-regions file) (stream)
  (loop for char = (send stream :tyi)
	while (= char *compact-op-region*)
	for lowest = (send self :read-number stream)
	for highest = (send self :read-number stream)
	for string = (send self :read-binary-string stream)
	for new-region = (make-file-region file self	
				   lowest-version lowest
					   highest-version highest
					   predecessor last-region
					   string string)
	do (when last-region
	     (setf (file-region-successor last-region) new-region))
	   (setq last-region new-region)
	   (unless first-region
	     (setq first-region new-region))
	finally (send stream :untyi char)))

(defmethod (:write-file-version write-primitives) (stream)
  (send stream :tyo *compact-op-version*)
  (send stream :tyo *compact-file-version*))

(defmethod (:write-region write-primitives) (stream region)
  (send stream :tyo *compact-op-region*)
  (send self :write-number stream (file-region-lowest-version region))
  (send self :write-number stream (file-region-highest-version region))
  (send self :write-binary-string stream (file-region-string region)))

(defmethod (:write-eof write-primitives) (stream)
  (send stream :tyo *compact-op-eof*))

(defmethod (:write-number write-primitives) (stream number)
  (unless (typep number :fixnum)
    (ferror "~S is not a fixnum, and cannot be written as a number"))
  (send stream :tyo (%logldb (byte 8 0) number))
  (send stream :tyo (%logldb (byte 8 8) number))
  (send stream :tyo (%logldb (byte 8 16) number))
  (send stream :tyo (%logldb (byte 8 24) number)))

(defmethod (:write-binary-string write-primitives) (stream string)
  (send self :write-number stream (string-length string))
  (send stream :string-out string))

(defmethod (:write-string write-primitives) (stream string)
  (send self :write-number stream (string-length string))
  (loop for ch being the array-elements of string
	do (send stream :tyo (char-code ch))))



(defmacro check-op (stream op name)
  `(let ((op-char (send ,stream :tyi)))
     (unless (= op-char ,op)
       (ferror "Expected ~A op (~D) read (~D)" ,name ,op op-char))))

(defmethod (:read-file-version read-primitives) (stream)
  (check-op stream *compact-op-version* "version")
  (let ((version (send stream :tyi)))
    (unless (= *compact-file-version* version)
      (ferror "Illegal file version ~D" version))))

(defmethod (:read-file-header read-primitives) (stream)
  (check-op stream *compact-op-header* "header")
  (values (fs:parse-pathname (send self :read-string stream))	;base-name
	  (send self :read-number stream)	;base-version
	  (send self :read-number stream)	;lowest-version
	  (send self :read-number stream)	;highest-version
	  ))

(defmethod (:read-property-lists read-primitives) (stream)
  (check-op stream *compact-op-property-list* "property lists")
  (loop with n-lists = (send self :read-number stream)
	with base = 10
	repeat n-lists
	collect (make-file-plist version (send self :read-number stream)
				 byte-size (send stream :tyi)
				 length (send self :read-number stream)
				 plist (read-from-string
					 (send self :read-string stream)))))

(defmethod (:read-region-header read-primitives) (stream)
  (let ((char (send stream :tyi)))
    (if (= char *compact-op-region*)
	(values (send self :read-number stream)
		(send self :read-number stream))
	(send stream :untyi char))))

(defmethod (:read-eof read-primitives) (stream)
  (check-op stream *compact-op-eof* "eof"))

(defmethod (:read-number read-primitives) (stream)
  (let ((b0 (send stream :tyi))
	(b1 (send stream :tyi))
	(b2 (send stream :tyi))
	(b3 (send stream :tyi)))
    (%logdpb b3 (byte 8 24)
	     (%logdpb b2 (byte 8 16)
		      (%logdpb b1 (byte 8 8)
			       (%logldb (byte 8 0) b0))))))

(defmethod (:read-string read-primitives) (stream)
  (let* ((length (send self :read-number stream))
	 (byte-array (make-array length :type art-8b)))
    (send stream :string-in nil byte-array)
    (loop with string = (make-array length :type art-string)
	  for i below length
	  do (setf (aref string i) (int-char (aref byte-array i)))
	  finally (return string))))

(defmethod (:read-binary-string read-primitives) (stream)
  (let* ((length (send self :read-number stream))
	 (string (make-array length :type art-8b)))
    (send stream :string-in nil string)
    string))

(defmethod (:skip-number read-primitives) (stream)
  (loop repeat 4 do (send stream :tyi)))

(defmethod (:skip-string read-primitives) (stream)
  (loop with length = (send self :read-number stream)
	while (plusp length)
	do (multiple-value-bind (ignore start end)
	       (send stream :read-input-buffer)
	     (let ((count (min length (- end start))))
	       (send stream :advance-input-buffer (+ start count))
	       (decf length count)))))

;;;--- B-R-A-I-N-D-A-M-A-G-E -- this does the wrong thing if there are gaps
;;;--- in the set of files present in the compact file.

(defmethod (:version-property-list file) (version)
  (unless (and ( version lowest-version)
	       ( version highest-version))
    (ferror "No information for version ~D" version))
  (file-plist-plist (assq version property-lists)))

(defmethod (:version-present-p file) (version)
  (and ( version lowest-version)
       ( version highest-version)
       (assq version property-lists)))

(defmethod (:list-all-versions file) ()
  (loop for v from lowest-version to highest-version
	as pl = (assq v property-lists)
	when pl
	  collect `(,v ,@(file-plist-plist pl) :length-in-bytes ,(file-plist-length pl))))

(defmethod (:version-characters file) (version)
  (unless (and ( version lowest-version)
	       ( version highest-version))
    (ferror "No information for version ~D" version))
  (zerop (file-plist-byte-size (assq version property-lists))))

(defmethod (:checksum-version file) (version)
  (with-open-file (stream (send base-name :new-version version)
			  :element-type '(cl:unsigned-byte 8))
    (with-open-stream (file-stream (make-instance 'file-stream :file self :version version))
      (when ( (checksum-stream stream) (checksum-stream file-stream))
	(ferror "File versions do not checksum")))))

(defun checksum-stream (stream)
  (loop with buf and start and end and checksum = 0
	and index = 0
	do (multiple-value (buf start end)
	     (send stream :read-input-buffer))
	while buf
	do (let ((ar buf))
	     (declare (sys:array-register ar))
	     (loop for i from start below end
		   do (setq checksum (%32-bit-plus checksum (lsh (aref ar i) index)))
		      (when (= (setq index (1+ index)) 24.)
			(setq index 0))))
	   (send stream :advance-input-buffer)
	finally (return checksum)))

(defmethod (:compare-version file) (version)
  (with-open-file (stream (send base-name :new-version version) :characters :default)
    (with-open-stream (file-stream (make-instance 'file-stream :file self :version version))
      (let ((generic-pathname (funcall base-name ':generic-pathname))
	    mode file-1 file-2)
	(fs:read-attribute-list generic-pathname stream)
	(setq mode (or (funcall generic-pathname ':get ':mode) ':lisp))
	(setq file-1 (srccom:make-srccom-file :file-stream stream
					      :file-name (funcall stream ':truename)
					      :file-major-mode mode)
	      file-2 (srccom:make-srccom-file :file-stream file-stream
					      :file-name (send base-name :new-type "Filed")
					      :file-major-mode mode))
	(srccom:source-compare-files file-1 file-2)))))


(defflavor file-stream
	(file
	 version
	 (region nil)) 
	(si:buffered-input-stream)
  (:initable-instance-variables file version)
  :gettable-instance-variables)

(defmethod (make-instance file-stream) (&rest ignore)
  (unless (send file :version-present-p version)
    (ferror "No information for version ~D" version)))

(defmethod (:pathname file-stream) ()
  (send file :base-name))

(defun open-file-stream (file version &key (element-type '(cl:unsigned-byte 8)))
  (cond ((eq element-type 'cl:character)
	 (make-instance
	   'si:indirect-escape-input-stream
	   :stream (make-instance 'file-stream :file file :version version)))
	((equal element-type '(cl:unsigned-byte 8))
	 (make-instance 'file-stream :file file :version version))))

;;; Required methods for buffered io
(defmethod (:next-input-buffer file-stream) (&optional no-hang-p)
  no-hang-p
  (setq region (send file :find-next-region-for-version region version))
  (if (eq region ':eof)
      (values nil nil nil t)
      (let ((string (file-region-string region)))
	(values string 0 (string-length string)))))

(defmethod (:discard-input-buffer file-stream) (ignore)
  nil)

;;; Other methods 
(defmethod (:version-same-to-index file-stream) (index new-version)
  (when ( index si:stream-input-limit)
    (setf (file-region-highest-version region)
	  (max (file-region-highest-version region) new-version))
    (setf (file-region-lowest-version region)
	  (min (file-region-lowest-version region) new-version))))

;;; It is a contract that this never changes region
(defmethod (:break-region file-stream) (&optional new-version)
  (cond ((null region))
	((eq region :eof))
	(t
	 ;; Break up the region
	 (send file :break-region region si:stream-input-index)
	 (setq si:stream-input-buffer (file-region-string region)
	       si:stream-input-limit (string-length si:stream-input-buffer))
	 (when new-version
	   (send self :version-same-to-index si:stream-input-index new-version)))))

(defmethod (:discard-characters file-stream) (count &optional new-version)
  (loop while (plusp count)
	do (multiple-value-bind (ignore start end)
	       (send self :read-input-buffer)
	     (let* ((length (min count (- end start)))
		    (end-discard (+ start length)))
	       (when new-version
		 (send self :version-same-to-index end-discard new-version))
	       (send self :advance-input-buffer end-discard)
	       (decf count length)))))

;;; This gets called when file-stream is at EOF, and the rest of the stream
;;; Should be postpended to the file
(defmethod (:read-rest-of-stream file-stream) (stream new-version)
  (unless (eq region :eof)
    (ferror "Cant handle this case"))
  (loop with estimated-length = (+ (- (send stream :length) (send stream :read-pointer))
				   *estimated-extra-length*)	;Some random number
	with string = (make-array estimated-length :type art-8b :fill-pointer 0)
	with last-end = 0 and eof = nil
	do (multiple-value (last-end eof)
	     (send stream :string-in nil string last-end))
	until eof
	do (incf estimated-length *string-read-growth-factor*)
	   (adjust-array-size string estimated-length)
	finally
	   (let* ((old-last-region (send file :last-region))
		  (new-region (make-file-region file file
					       lowest-version new-version
					       highest-version new-version
					       predecessor old-last-region
					       string string)))
	     (setf (file-region-successor old-last-region) new-region)
	     (send file :set-last-region new-region))))

(defmethod (:read-state file-stream) ()
  (values region si:stream-input-index))

(defmethod (:restore-state file-stream) (reg index)
  (send self :discard-current-input-buffer)
  (setq region reg)
  (if (or (null reg) (eq reg :eof))
      (setq si:stream-input-index index
	    si:stream-input-limit index)
      (setq si:stream-input-buffer (file-region-string reg)
	    si:stream-input-index index
	    si:stream-input-limit (string-length si:stream-input-buffer))))

;;; When this is called we are guaranteed to be at the beginning of a region.
;;; It should return with everything happy, and the streams resynchronized.
(defmethod (:resynchronize-versions file-stream) (stream new-version)
  (loop with new-file-strings
	do (multiple-value-bind (cur-buf cur-start cur-end)
	       (send stream :read-input-buffer)
	     (multiple-value-bind (found-region found-offset)
		 (send self :search-for-string cur-buf cur-start cur-end)
	       (when found-region
		 (send self :insert-string found-region found-offset
					   new-version new-file-strings)
		 (return nil))
	       ;; Here we might want to do something different
	       )
	     (push (binary-substring cur-buf cur-start cur-end) new-file-strings)
	     (send stream :advance-input-buffer))))

;;; Insert the string-list after the current point and before found-region and
;;; found-offset. However, leave point after the inserted string
(defmethod (:insert-string file-stream) (found-region found-offset
					 new-version string-list)
  (let ((before-region
	  (cond ((zerop si:stream-input-index)
		 (send file :find-previous-region-for-version region version))
		((= si:stream-input-index si:stream-input-limit) region)
		(t
		 (ferror "Cant work in this case"))))
	(discard-distance))
    ;; We dont have to worry about our current position, since we will be changing it
    (multiple-value (found-region found-offset string-list discard-distance)
      (send self :optimize-insert found-region found-offset string-list))
    (send file :break-region found-region found-offset)
    ;; We want to be at the end of a region
    (when string-list
      (let* ((after-before-region (if (null before-region)
				      (send file :first-region)
				      (file-region-successor before-region)))
	     (new-string (lexpr-funcall #'binary-string-append (nreverse string-list)))
	     (new-region (make-file-region file file
					   lowest-version new-version
					   highest-version new-version
					   predecessor before-region
					   successor after-before-region
					   string new-string)))
	(if (null before-region)
	    (send file :set-first-region new-region)
	    (setf (file-region-successor before-region) new-region))
	(setf (file-region-predecessor after-before-region) new-region)))
    (send self :restore-state found-region found-offset)
    (send self :discard-characters discard-distance new-version)))

(defmethod (:optimize-insert file-stream) (old-region old-offset old-strings)
  (if (or (null old-region) (null old-strings))
      (values old-region old-offset old-strings 0)
      (loop with reg = old-region
	    and strings = old-strings
	    with buffer = (unless (eq old-region :eof) (file-region-string old-region))
	    and string = (pop strings)
	    and buffer-index = old-offset
	    and discarded-chars = 0
	    with string-index = (string-length string)
	    when (zerop buffer-index)
	    do (when (neq reg region)
		 (setq reg (send file :find-previous-region-for-version reg version))
		 (unless (null reg)
		   (setq buffer (file-region-string reg)
			 buffer-index (string-length buffer))))
	    when (zerop string-index)
	    do (setq string (pop strings))
	       (setq string-index (string-length string))
	    do (decf string-index)
	       (decf buffer-index)
	       (incf discarded-chars)
	    while (not (null reg))
	    while (not (null string))
	    until (and (eq reg region) (< buffer-index si:stream-input-index))
	    while (= (aref buffer buffer-index) (aref string string-index))
	    finally
	      (if (and (eq old-region :eof) (< discarded-chars *resynchronize-length*))
		  (return (values old-region old-offset old-strings 0))
		  (return (values reg (1+ buffer-index)
				  (unless (null string)
				    (cons (nbinary-substring string 0 (1+ string-index))
					  strings))
				  (1- discarded-chars)))))))

(defmethod (:search-for-string file-stream) (string start end)
  (cond ((null string) (values :eof 0))
	((< (- end start) *resynchronize-length*) nil)
	(t (loop named top
		 with length = (- end start)
		 for reg first region
		   then (send file :find-next-region-for-version reg version)
		 for first-index first si:stream-input-index then 0
		 until (eq reg :eof)
		 do (multiple-value-bind (compare-position compare-length)
			(search-buffer reg first-index string start length)
		      (cond ((null compare-position))	;Didnt find it at all
			    ((= compare-length length)	;Found it all
			     (return (values reg compare-position)))
			    (t ;; Found a fraction, make sure it is in the next regions
			     (loop with remaining-length = (- length compare-length)
				   and string-start = start
				   for next-reg first (send file :find-next-region-for-version
							    reg version)
				     then (send file :find-next-region-for-version
						next-reg version)
				     when (eq next-reg :eof)
				       return nil
				     for compare-length = (equal-region next-reg
									string string-start
									remaining-length)
				     when (null compare-length)
				       return nil
				     do (decf remaining-length compare-length)
				        (incf string-start compare-length)
				     while (plusp remaining-length)
				     finally (return-from top
					       (values reg compare-position))))))))))

(defun compare-buffers (buffer-1 start-1 length-1 buffer-2 start-2 length-2)
  (let ((array-1 buffer-1)
	(array-2 buffer-2))
    (declare (sys:array-register array-1 array-2))
    (loop for idx1 from start-1 below (+ start-1 (min length-1 length-2))
	  for idx2 from start-2
	  while (= (aref array-1 idx1) (aref array-2 idx2))
	  finally (return (- idx1 start-1)))))

(defun search-buffer (in-region first-index for-string start length)
  (let ((buffer (file-region-string in-region))
	(key for-string))
    (declare (sys:array-register buffer key))
    (loop named top
	  with first-char = (aref key start)
	  for index from first-index below (string-length buffer)
	  when (= first-char (aref buffer index))
	  do (loop for index-1 from index below (string-length buffer)
		   for index-2 from start below (+ start length)
		   when ( (aref buffer index-1) (aref key index-2))
		   return nil
		   finally (return-from top (values index (- index-1 index)))))))

(defun equal-region (region string start length)
  (let ((buffer-1 (file-region-string region))
	(buffer-2 string))
    (declare (sys:array-register buffer-1 buffer-2))
    (loop repeat (min length (string-length buffer-1))
	  for index-1 from 0
	  for index-2 from start
	  when ( (aref buffer-1 index-1) (aref buffer-2 index-2))
	  return nil
	  finally (return index-1))))

(defun create-archive-file (base-file-name)
  (archive-comment "Creating an archive file to hold versions of ~A" base-file-name)
  (let ((new-file (make-instance 'file)))
    (send new-file :read-base-version base-file-name)
    (when (probef (compact-filename new-file))
      (ferror "Compact file for ~A already exists" base-file-name))
    (send new-file :write-compact-file (compact-filename new-file))
    new-file))

(defun archive-files (compact-file start-version
		      &optional (end-version start-version) (conservative-p t))
  (unless (typep compact-file 'file)
    (setq compact-file (read-compact-file (send (fs:parse-pathname compact-file)
						:new-canonical-type :compact))))
  (loop with old-highest = (send compact-file :highest-version)
	and base-name = (send compact-file :base-name)
	for vers from start-version to end-version
	for f = (send base-name :new-version vers)
	if ( vers old-highest)
	do (format t "~&Warning: Version ~A is already archived" f)
	else
	do (if (probef f)
	       (send compact-file :add-new-version vers)
	       (format t
		       "~&Warning: Version ~A cannot be archived because it does not exist"
		       f)))
  (when conservative-p
    (let ((old-file (read-compact-file (compact-filename compact-file))))
      (loop for vers from (send old-file :lowest-version)
	      below (min start-version (1+ (send old-file :highest-version)))
	    do (with-open-stream (old-stream (make-instance 'file-stream :file old-file
							    :version vers))
		 (with-open-stream (new-stream (make-instance 'file-stream :file compact-file
							      :version vers))
		   (when ( (checksum-stream old-stream) (checksum-stream new-stream))
		     (ferror "File versions do not checksum"))))))
    (loop with base-name = (send compact-file :base-name)
	  for vers from start-version to end-version
	  for f = (send base-name :new-version vers)
	  when (probef f)
	  do (send compact-file :checksum-version vers)))
  (send compact-file :write-compact-file (compact-filename compact-file))
  (loop with base-name = (send compact-file :base-name)
	for vers from start-version to end-version
	for f = (send base-name :new-version vers)
	for pl = (send compact-file :version-property-list vers)
	unless (or (get (locf pl) :dont-reap) (get (locf pl) :dont-delete))
	do (archive-comment "Deleting file ~A after archiving it" f)
	   (deletef f nil))
  compact-file)

(defun archive-list-of-pathnames (compact-file directory-list &optional (conservative-p t))
  (let ((wrote-one nil))
    (unless (typep compact-file 'file)
      (setq compact-file (read-compact-file (send (fs:parse-pathname compact-file)
						  :new-canonical-type :compact))))
    (loop with old-highest = (send compact-file :highest-version)
	  for path in directory-list
	  as vers = (send path :version)
	  unless ( vers old-highest)
	    do (setq wrote-one t)
	       (send compact-file :add-new-version vers))
    (when (and wrote-one conservative-p)
      (let ((old-file (read-compact-file (compact-filename compact-file))))
	(loop with highest = (send compact-file :highest-version)
	      for path in directory-list
	      as vers = (send path :version)
	      unless( vers highest)
		do (with-open-stream (old-stream (make-instance 'file-stream :file old-file
								:version vers))
		     (with-open-stream (new-stream
					 (make-instance 'file-stream :file compact-file
							:version vers))
		       (when ( (checksum-stream old-stream) (checksum-stream new-stream))
			 (ferror "File versions do not checksum"))))))
      (loop with highest = (send compact-file :highest-version)
	    for path in directory-list
	    as vers = (send path :version)
	    unless ( vers highest)
	      do (send compact-file :checksum-version vers)))
    (when wrote-one
      (send compact-file :write-compact-file (compact-filename compact-file)))
    compact-file))

(defun dearchive-files (compact-file start-version
			&optional (end-version start-version))
  (unless (typep compact-file 'file)
    (setq compact-file (read-compact-file (send (fs:parse-pathname compact-file)
						:new-canonical-type :compact))))
  (loop with lowest = (send compact-file :lowest-version) 
	and highest = (send compact-file :highest-version)
	and base-name = (send compact-file :base-name)
	for vers from start-version to end-version
	for f = (send base-name :new-version vers)
	for pl = (send compact-file :version-property-list vers)
	unless (and ( vers highest) ( vers lowest))
	do (ferror "Version ~A is not archived" f)
	when pl
	do (with-open-stream (in-stream (make-instance 'file-stream :file compact-file
						       :version vers))
	     (archive-comment "Retrieving file ~A from archive" f)
	     (with-open-file (out-stream f :direction :output
					 :element-type '(cl:unsigned-byte 8))
	       (stream-copy-until-eof in-stream out-stream)))
	   (lexpr-funcall #'fs:change-file-properties
			  f nil pl))
  compact-file)

(defun list-archive (compact-file)
  (unless (typep compact-file 'file)
    (let ((filename (send (fs:parse-pathname compact-file)
			  :new-canonical-type :compact))
	  (new-file (make-instance 'file)))
      (send new-file :read-compact-file-header filename)
      (setq compact-file new-file)))
  (format t "~&Contents of ~A~%" (compact-filename compact-file))
  (loop with base-name = (send compact-file :base-name)
	for pl in (reverse (send compact-file :property-lists))
	do (zwei:default-list-one-file
	     (list* (send base-name :new-version (file-plist-version pl))
		    :length-in-bytes (file-plist-length pl)
		    :byte-size 8
		    (file-plist-plist pl)))))
  
(defun read-compact-file (filename)
  (let ((new-file (make-instance 'file)))
    (send new-file :read-compact-file filename)
    new-file))
  
(defun compact-filename (compact-file)
  (send (send compact-file :base-name) :new-canonical-type :compact))

(defun read-compact-file-header (filename)
  (let ((new-file (make-instance 'file)))
    (send new-file :read-compact-file-header filename)
    new-file))


;;; File access path to compact files

;;; Direct file stream
(defflavor compact-input-stream-mixin (data-stream version
				       (region-count 0) (buffer-index nil))
	   (si:property-list-mixin si:file-data-stream-mixin read-primitives)
  (:initable-instance-variables data-stream version)
  (:required-flavors si:buffered-input-stream))

(defmethod (:init compact-input-stream-mixin :before) (ignore)
  (send self :read-file-version data-stream)
  (multiple-value-bind (base-name ignore lowest-version highest-version)
      (send self :read-file-header data-stream)
    (unless (and ( version lowest-version)
		 ( version highest-version))
      (ferror "Illegal access to version ~D" version))
    (setq si:pathname (send base-name :new-version version)))
  (let ((my-plist (assq version (send self :read-property-lists data-stream))))
    (setq flavor:property-list
	  `(:length ,(file-plist-length my-plist)
	    :byte-size ,(file-plist-byte-size my-plist)
	    . ,(file-plist-plist my-plist)))))

;;; Required methods for buffered-io
(defmethod (:next-input-buffer compact-input-stream-mixin) (&optional no-hang-p)
  no-hang-p
  (when buffer-index
    (ferror "Sync error"))
  (unless (plusp region-count)
    (setq region-count
	  (loop do (multiple-value-bind (low high)
		       (send self :read-region-header data-stream)
		     (when (null low)
		       (return 0))
		     (when (and ( version low) ( version high))
		       (return (send self :read-number data-stream)))
		     (send self :skip-string data-stream)))))
  (if (zerop region-count)
      (values nil nil nil t)
      (multiple-value-bind (buffer start end)
	  (send data-stream :read-input-buffer)
	(setq end (min end (+ start region-count)))
	(setq buffer-index end)
	(decf region-count (- end start))
	(values buffer start end))))

(defmethod (:discard-input-buffer compact-input-stream-mixin) (ignore)
  (when buffer-index
    (send data-stream :advance-input-buffer buffer-index)
    (setq buffer-index nil))
  nil)

(defflavor compact-input-character-stream ()
	   (compact-input-stream-mixin si:character-stream
	    si:buffered-input-stream))

(defun archive-new-versions-in-directory
       (directory-name &key (start-file-name nil) (keep-newest 5)
	(correct-sys-directory nil))
  (let* ((compact-default (fs:default-pathname "*" nil :compact :newest))
	 (dpathname (send (send 
			    (fs:parse-pathname directory-name nil compact-default)
			    :new-type :compact) :new-version :newest))
	 (compact-pn-list (cdr (fs:directory-list dpathname :no-extra-info :sorted)))
	 (compact-file (make-instance 'file)))
    (when start-file-name
      (let* ((start-pn (fs:parse-pathname start-file-name nil compact-default))
	     (start-pt
	       (cl:member start-pn compact-pn-list
			  :test #'eq)))
	(cond (start-pt
	       (setq compact-pn-list start-pt)
	       (format t "~& Restarting from ~A" start-pn))
	      (t (ferror "Restart file ~A not found in directory ~A."
			 start-pn dpathname)))))
    (loop for (compact-pn . nil) in compact-pn-list
	  do (send compact-file :read-compact-file-header compact-pn)
	  as base-pn = (send compact-file :base-name)
	  as must-refix-base = nil
	  when correct-sys-directory
	  do (when (string-equal (car (send base-pn :directory)) "SYS")
	       (setq base-pn (send base-pn :new-directory
				   (list* "REL-7" (send base-pn :directory))))
	       (send compact-file :set-base-name base-pn)
	       (setq must-refix-base t))
	  as last-in = (send compact-file :highest-version)
	  as newest-around = (send
			       (send
				 (send base-pn :new-version :newest)
				 :truename)
			       :version)
	  as unarchived = (- newest-around last-in)
	  do
	  (format t "~&Processing ~A - archived to ~D, newest ~D ... "
		  compact-pn last-in newest-around)
	  (cond ((> unarchived keep-newest)
		 (format t "Archiving ~D through ~D." (+ 1 last-in)
			 (- newest-around keep-newest))
		 (send compact-file :read-compact-file compact-pn)
		 (when must-refix-base
		   (send compact-file :set-base-name base-pn))
		 (archive-files compact-file (+ 1 last-in) (- newest-around keep-newest)))
		(t (format t "Less than ~D unarchived versions." keep-newest)
		   (when must-refix-base
		     (format t "----- Rewriting ~A to fix base pathname." compact-pn)
		     (send compact-file :write-compact-file
			   (send compact-pn :new-version :newest))))))))

(defun delete-archived-files
       (directory-name)
  (let* ((compact-default (fs:default-pathname "*" nil :compact :newest))
	 (dpathname (send (send 
			    (fs:parse-pathname directory-name nil compact-default)
			    :new-type :compact) :new-version :newest))
	 (compact-pn-list (cdr (fs:directory-list dpathname :no-extra-info :sorted)))
	 (compact-file (make-instance 'file)))
    (loop for (compact-pn . nil) in compact-pn-list
	  do
	  (send compact-file :read-compact-file-header compact-pn)
	  (loop with base-name = (send compact-file :base-name)
		for pl in (reverse (send compact-file :property-lists))
		as this-pn = (send base-name :new-version (file-plist-version pl))
		as current-properties = (cadr (fs:directory-list this-pn))
		unless (or (cl:getf (cdr current-properties) :dont-reap)
			   (cl:getf (cdr current-properties) :dont-delete))
		do (archive-comment "Deleting file ~A after archiving it" this-pn)
		   (deletef this-pn nil)))))


;;;;

;;;
;;; Some CP commands for hacking compact files
;;;


;;; (LIST-ARCHIVE COMPACT-FILE)
;;;	Does a "DIRED" style listing of the file versions which are contained in a
;;;	COMPACT-FILE.
(define-cp-command (com-show-archive :command-table "User")
		   ((compact-file 'cl:pathname
				  :confirm t
				  :prompt "Compact file"))
  (list-archive compact-file))

;;; (DEARCHIVE-FILES COMPACT-FILE START-VERSION &OPTIONAL (END-VERSION START-VERSION))
;;;	Takes the COMPACT-FILE and extracts the name of the files it should dearchive. It
;;;	then copies the specified versions out of the COMPACT-FILE and writes the new 
;;;	individual copies where the versions originally were archived from. It will attempt
;;;	to restore all properties which were settable when the file was archived.
(define-cp-command (com-extract-archive-files :command-table "User")
		   ((compact-file
		      '((cl:sequence cl:pathname))
		      :confirm t
		      :prompt "Compact file"
		      :documentation "Compact file from which archived versions are to be extracted")
		    (start-version
		      'cl:integer
		      :prompt "Start version"
		      :default nil)
		    &key
		    (end-version
		      'cl:integer
		      :prompt "End version"
		      :default start-version))
  (dearchive-files compact-file start-version end-version))

;;; THIS DESERVES COMMENTARY
(define-cp-command (com-add-archive-files :command-table "User")
		   ((base-files
		      '((cl:sequence cl:pathname))
		      :confirm t
		      :prompt "Base file, e.g., q:>lossage>foo.lisp"
		      :documentation "Create the compact files, if they don't already exist.
Add any new versions of the base files to the compact versions.")
		    &key
		    (keep 'cl:integer
			  :default 2
			  :documentation "How many versions to keep (not delete)")
		    (in-background
		      'scl:boolean
		      :default nil
		      :prompt "Background?"
		      :documentation "Run this behemoth in a background process")
		    (verbose
		      'scl:boolean
		      :default t
		      :prompt "Verbose?"
		      :documentation "Print messages about each step?"))
  (let ((bases (loop for path in base-files
		     when (send path :type-wild-p)
		       do (ferror "---Not supposed to hack wild types")
		     when (send path :wild-p)
		       nconc (mapcar #'car (cdr (fs:directory-list path)))
		     else collect path)))
    ;;verify "Archive these files?", maybe.  I don't understand the :ask :each philosophy
    (if in-background
	(process-run-function
	  (format () "Archive Files ~A~A"
		  (first bases)
		  (if (> (length bases) 1) "..." ""))
	  #'compact-a-list-of-base-files bases keep verbose)
	(compact-a-list-of-base-files bases keep verbose))))

(defun compact-a-list-of-base-files (bases keep *verbose-compact*)
  (dolist (base-file bases)
    (compact-one-base-file base-file keep)))

(defun compact-one-base-file (pathn versions-to-keep)
  (archive-comment "Archiving all new versions of ~A" pathn)
  (let* ((paths-and-properties
	   (cdr (fs:directory-list (send pathn :new-version :wild) :sorted)))
	 (paths (mapcar #'car paths-and-properties))
	 (compact-pathname (send pathn :new-pathname :type :compact :version :newest)))
    (unless paths
      (ferror "Gee guys, there is no file ~A" pathn))
    (let* ((compacting-paths paths)
	   (compact-file
	     (if (probef compact-pathname)
		 (read-compact-file compact-pathname)
		 (create-archive-file (pop compacting-paths)))))
      ;; actually put them in the new compact library
      (archive-list-of-pathnames compact-file compacting-paths)
      (loop with pl-alist = (send compact-file :property-lists)
	    repeat (max 0 (- (length paths) versions-to-keep))
	    for path in paths
	    for pl in paths-and-properties
	    as vers = (send path :version)
	    when (assq vers pl-alist)		; this vers in the compact file
	      unless (or (get pl :dont-reap) (get pl :dont-delete))
		do (archive-comment "Deleting file ~A after archiving it" path)
		   (deletef path nil)))))



