;;; -*- Mode: LISP; Syntax: Common-lisp; Package: D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")vci0; Base: 10; Lowercase: Yes; -*-

;;; Things to convert pre-version-control source files to version controlled source
;;; files.

;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
(defvar *conversion-area* sys:working-storage-area)

(defflavor forward-conversion-buffer
	(tlf-interval-array ; top-level-form
	 tlf-definition-array ; for each one, the first definition (if any)
	 (has-attribute-list nil)
	 (trivial-sections nil)
	 )
	(zwei:named-buffer-with-sections si:property-list-mixin)
  (:conc-name fcb-)
  (:readable-instance-variables has-attribute-list trivial-sections
				tlf-interval-array tlf-definition-array)
  (:gettable-instance-variables tlf-interval-array tlf-definition-array))

(defmethod (make-instance forward-conversion-buffer) (&rest ignore)
  (setq tlf-interval-array (make-array 100 :fill-pointer 0 :area *conversion-area*))
  (setq tlf-definition-array (make-array 100 :fill-pointer 0 :area *conversion-area*)))

;; assume that the buffer is already empty.
(defmethod (read-flat-contents forward-conversion-buffer)
	   (source-stream LOUD)
  (setf (fill-pointer tlf-interval-array) 0)
  (setf (fill-pointer tlf-definition-array) 0)
  ;;; remove when :line-in takes funargs.
  (let ((sys:default-cons-area *conversion-area*))
    (zwei:stream-into-bp source-stream zwei:last-bp))
  ;; VC can't represent a partial line.  Force a #\Return at the end.
  (when (plusp (zwei:bp-index zwei:last-bp))
    (zwei:insert-moving zwei:last-bp #\return))
  (let ((ct (send (send source-stream :pathname) :canonical-type)))
    (case ct
#|      (:lisp 
	(read-flat-contents-tls self (send source-stream :pathname) LOUD))
|#
      (otherwise
	(read-flat-contents-sectionize
	  self LOUD (zwei:major-mode-from-canonical-type (or ct :fundamental))))))
  (warn-about-duplicates self (send source-stream :pathname)))


(defmethod (f-c-b-unlink-lines forward-conversion-buffer) ()
  (loop for line = (zwei:bp-line zwei:first-bp) then next-line
	as next-line = (and line (zwei:line-next line))
	while line
	do
    (loop for bp in (zwei:line-bp-list line) do (zwei:flush-bp bp))
    (setf (zwei:line-next line) nil
	  (zwei:line-previous line) nil
	  (zwei:line-node line) nil    
    )))

(defmethod (read-flat-contents-tls forward-conversion-buffer) (pathname LOUD)
  (setq trivial-sections nil has-attribute-list nil)
  (let ((scanner (make-instance 'tls:scanner :interval self :area *conversion-area*)))
    (loop for first = t then nil
	  do
      (multiple-value-bind (item type definition)
	  (send scanner :item-in)
	(when (eq type :eof) (loop-finish))
	(case type
	  (:attribute-list
	    (cond (first
		   (vector-push-extend item tlf-interval-array)
		   (vector-push-extend nil tlf-definition-array)
		   (setq has-attribute-list t))
		  (t (error "Attribute list is not the first item in the file?"))))
;;--- commented distinction is decomissioned.
	  #||	  (:\#-double-vertical-comment
		    (vector-push-extend item tlf-interval-array)
		    (vector-push-extend (cons :commented-out definition)
				 tlf-definition-array))
	  (:\#-feature-form			; needs thought
	    (vector-push-extend item tlf-interval-array)
	    (vector-push-extend (cons :commented-in definition)
			 tlf-definition-array)
	    )
	  ||#
	  (otherwise
	    (unless (or definition (not LOUD))
	      (warn "~A has no definition in ~A" (zwei:string-interval item)
		    pathname))
	    (vector-push-extend item tlf-interval-array)
	    (vector-push-extend definition tlf-definition-array)))))))


(defconstant copyright-marker "> *****************************************************************************************")

;;; --- This is a miniature SECTIONIZE-BUFFER that was easier to write
;;; --- than remodularizing that.  This should be be flushed in LBE-LAND.
(defmethod (read-flat-contents-sectionize forward-conversion-buffer) (LOUD mode)
  (ignore LOUD)
  (let* ((zwei:*%suppress-lisp-parse-line-memoization* t)
	 (state (send mode :initial-sectionization-state))
	 (prev-start-bp zwei:first-bp)
	 (zwei:*interval* self))			  
    (send self :putprop (or (send self :get :major-mode) mode) :major-mode)
    (setq has-attribute-list nil)
    (with-standard-io-environment ;; zwei:reparse-attribute-list-internal setq's
      ;; standard variables. Hopefully, this macro binds all the variables
      ;; that it setq's ....
      (zwei:with-editor-stream (stream :interval self :start ':beginning :no-redisplay t)
	(let ((zwei:*typein-window* *standard-output*)
	      (*package* si:pkg-user-package)
	      (*print-base* 10.))
	  ;; bindings make sure that this behaves consistently
	  ;; do this whether or not there is a -*- in the house. It initializes
	  ;; buffer properties.
	  (zwei:reparse-attribute-list-internal self stream)))
      (tls::with-approximate-editor-bindings self
	(zwei:with-editor-stream (s :interval self :no-redisplay t :start ':beginning)
	  (when
	    (fs:read-attribute-list nil s :dont-reset-stream t)
	    (setq has-attribute-list t)
	    (let* ((after-attribute-bp (send s :read-bp))
		   (attribute-preferred-terminator
		     (loop named find-attribute-end
			   with copyright-started = nil
			   with copyright-end-bp = nil
			   with bp = (zwei:create-bp nil 0)
			   for line = (zwei:bp-line after-attribute-bp)
				    then (zwei:line-next line)
			   always line
			   do
		       (zwei:move-bp bp line 0)
		       (cond ((and (> (length line) 0) (char-equal (char line 0) #\Page))
			      ;; if the first thing we hit is a <page>,
			      ;; everything up to there goes.
			      (return-from find-attribute-end (zwei:forward-char bp -1)))
			     ((string-search copyright-marker line)
			      ;; if we hit a copyright, we remember where.
			      (if copyright-started (setq copyright-end-bp
							  (zwei:create-bp line (length line)))
				  (setq copyright-started t)))
			     ((multiple-value-bind (fspec dtype string err new-state)
				  (send mode :section-name line bp state)
				(ignore fspec dtype string)
				(setq state new-state)
				(not err))
			      ;; when we get to a definition, we back up to the
			      ;; copyright, if we have one.
			      (return-from find-attribute-end copyright-end-bp))))))
	      (when attribute-preferred-terminator
		(setq after-attribute-bp (zwei:forward-char attribute-preferred-terminator)))
	      (setq prev-start-bp after-attribute-bp)
	      (setq state (send mode :initial-sectionization-state))	; clean up state.
	      (let ((att-int (zwei:make-interval 'zwei:node :initial-line nil
						 :area *conversion-area*
						 :first-bp zwei:first-bp
						 :last-bp after-attribute-bp)))
		(vector-push-extend att-int tlf-interval-array)
		(vector-push-extend nil tlf-definition-array)))))
	(if (send mode :section-name-trivial-p)
	    (progn
	      (setq trivial-sections t)
	      (unless (zwei:bp-= prev-start-bp zwei:last-bp)
		(vector-push
		  (zwei:make-interval 'zwei:node :initial-line nil
				      :area *conversion-area*
				      :first-bp prev-start-bp
				      :last-bp zwei:last-bp)
		  tlf-interval-array)
		(vector-push-extend nil tlf-definition-array)))
	    
	    ;; ok, enough attribute section foolishness. on to the real work.
	    ;; we scan along until we find a definition.  once we find one, see if there is
	    ;; a page mark before the next one. If so, we include everything up to the page mark
	    ;; in the section. Note that when we enter this loop scan-bp may or may be at a def.
	    
	    (loop with prev-fspec with prev-dtype with string with new-state
		  with scan-bp = (zwei:create-bp nil 0)
		  as fspec = nil
		  as dtype = nil
		  as err = t
		  for line = (zwei:bp-line prev-start-bp) then (zwei:line-next line)
		  as int = nil
		  do
	      (if line (zwei:move-bp scan-bp line 0)
		  (setq scan-bp nil))
	      (if (null scan-bp)
		  (unless (zwei:bp-= prev-start-bp zwei:last-bp)
		    (setq int (zwei:make-interval 'zwei:node
						  :area *conversion-area*
						  :first-bp (zwei:copy-bp prev-start-bp)
						  :last-bp zwei:last-bp)))
		  (multiple-value-setq (fspec dtype string err new-state)
		    (and line (send mode :section-name line scan-bp state)))
		  (setq state new-state)
		  (when (null err)
		    (when prev-fspec
		      (let ((separator (zwei:backward-over-comment-lines scan-bp t nil t)))
			;;--- kludge over bug in zwei:backward-over-comment-lines.
			(setf (zwei:bp-index separator) 0)
			(when (zwei:bp-= prev-start-bp separator)
			  (error "Null definition interval. Something is broken."))
			(setq int (zwei:make-interval
				    'zwei:node
				    :area *conversion-area*
				    :first-bp (zwei:copy-bp prev-start-bp)
				    :last-bp separator)
			      prev-start-bp separator)
			(assert (not (zwei:bp-< (zwei:node-last-bp int)
						(zwei:node-first-bp int)))
				(int)
				"Section node ~S bp's are not in canonical order."
				int)
			))))
	      (when int 
		(vector-push-extend int tlf-interval-array)
		(vector-push-extend (and prev-fspec (cons prev-fspec prev-dtype))
				    tlf-definition-array)
		(unless scan-bp (loop-finish)))
	      (when (null err)
		(setq prev-fspec fspec prev-dtype dtype))))))))

(defflavor interval-from-encached-file (section-id)
	   (zwei:node)
  (:initable-instance-variables)
  (:gettable-instance-variables))

(defmethod (read-initial-version-from-encached-file forward-conversion-buffer)
	   (source-stream LOUD encached-file-pathname)
  (let ((zwei:*interval* self))
    (zwei:delete-interval self)) 
  (setf (fill-pointer tlf-interval-array) 0)
  (setf (fill-pointer tlf-definition-array) 0)
  (let ((zwei:*major-mode* (zwei:major-mode-from-canonical-type
			     (send encached-file-pathname :canonical-type)))
	(first t)
	(attributes nil)
	(current-interval nil))
    (with-standard-io-environment
      (setq trivial-sections (send zwei:*major-mode* :section-name-trivial-p))
      (flet
	((blip-handler (blip-error)		;NIL to indicate EOF
	   (let ((new-section-id
		   (and blip-error
			(sbb-begin-section-id
			  (encached-file-version-stream-blip-blip blip-error)))))
	     (if first
		 (setq first nil attributes t)
		 ;; end the last line.
		 (zwei:insert (zwei:interval-last-bp current-interval) #\cr)
		 (cond (trivial-sections
			(vector-push-extend nil tlf-definition-array))
		       ((and attributes 
			     (zwei:with-editor-stream (stream :interval current-interval
							      :start ':beginning
							      :no-redisplay t)
			       (let ((attribute-list-present
				       (fs:read-attribute-list nil stream)))
				 (let ((zwei:*typein-window* *standard-output*)
				       (*package* si:pkg-user-package)
				       (*print-base* 10.))
				   ;; bindings make sure that this behaves consistently

				   (zwei:reparse-attribute-list-internal self stream))
				 (if attribute-list-present
				     (progn
				       (vector-push-extend nil tlf-definition-array)
				       (setq has-attribute-list t))
				     nil)))))
		       (t
			(tls::with-approximate-editor-bindings self
			  (let ((zwei:*interval* current-interval))
			    (loop for bp = (zwei:interval-first-bp current-interval)
					 then (zwei:forward-line bp 1 nil current-interval)
				  do
			      (unless bp
				(when LOUD
				  (warn "~A has no definition in ~A"
					(zwei:string-interval current-interval)
					encached-file-pathname))
				(vector-push-extend nil tlf-definition-array)
				(return nil))
			      (when
				(and (zerop (zwei:bp-index bp))
				     (> (length (zwei:bp-line bp)) 3)
				     (char-equal (aref (zwei:bp-line bp) 0) #\()
				     (let
				       ((look-here
					  (1+ (or (string-search-char
						    #\:    
						    (zwei:bp-line bp)
						    :end (string-search-char
							   #\space (zwei:bp-line bp)))
						  0))))
				       (string-equal
					 "DEF" (zwei:bp-line bp)
					 :start2 look-here
					 :end2 (+ 3 look-here))))
				(multiple-value-bind (fspec dtype ignore error-p)
				    (zwei:get-definition-function-spec bp)
				  (unless error-p
 				    (vector-push-extend (cons fspec dtype)
							tlf-definition-array)
				    (return nil)))))))))
		 (setq attributes nil))
	     (when blip-error		;unless eof
	       (setq current-interval
		     (zwei:make-interval 'interval-from-encached-file
					 :section-id new-section-id
					 :area *conversion-area*
					 :initial-line t))
	       (vector-push-extend current-interval tlf-interval-array)))
	   (when blip-error
	     (send blip-error :proceed :no-action))))
	(condition-bind ((encached-file-version-stream-blip #'blip-handler))
	  (loop with record with eof
		do
	    (multiple-value-setq
	      (record eof)
	      (send source-stream :line-in))
	    (zwei:insert (zwei:interval-last-bp current-interval) #\cr)
	    (zwei:insert (zwei:interval-last-bp current-interval) record)
	    (when eof
	      (blip-handler nil)
	      (loop-finish))))))
    (warn-about-duplicates self encached-file-pathname)))
(defmethod (warn-about-duplicates forward-conversion-buffer) (pathname)
  #-ignore (ignore pathname)
  #+ignore
  (loop with dups = nil
	for def being the array-elements of tlf-definition-array using (index i)
	as count = (if (or (null def) (member def dups :test #'eq)) 0
		       (count def tlf-definition-array :test #'equal :start i))
	do
    (when (and def (> count 1))
      (push def dups)
      (warn "~A appears ~D times in ~A"
	    (let ((*package* nil))
	      (zwei:section-definition-name (cdr def) (car def)))
	    count pathname)))) 

(defflavor forward-converter
	(
	 (old-section-defs nil)
	 ;; old-section-defs contains NIL if the section was not present in the version,
	 ;; :none if it was present but had no definition (something that we try to avoid),
	 ;; or a dtype.fspec pair, otherwise.
	 (encached-file nil)
	 (LOUD nil)
	 (prev-had-attribute-list)
	 (trivial-sections)
	 )
	()
  (:writable-instance-variables encached-file)
  (:settable-instance-variables LOUD)
  (:gettable-instance-variables))

;;; This should be called after the first version is read in.
(defmethod (setup-definitions-table forward-converter)
	   (initial-buffer
			  &key file-already-exists
			  initial-pathname
			  initial-version
			  initial-pathname-properties)
  (flet ((setup-old-section-defs ()
	   (let ((section-table-length (send encached-file :section-table-length)))
	     (setq old-section-defs
		   (make-array section-table-length :area *conversion-area*
			       :initial-element nil)))))
    (let* ((defs (fcb-tlf-definition-array initial-buffer))
	   (ints (fcb-tlf-interval-array initial-buffer)))
      (cond (file-already-exists
	     ;; all we need to do is to fill in old-section-defs
	     (setup-old-section-defs)
	     (loop for int being the array-elements of ints
		   for def being the array-elements of defs
		   as sid = (send int :section-id)
		   do (setf (aref old-section-defs sid) (or def :none))))
	    ;; we aren't starting from an existing file, so we have to create one.
	    (t (let ((çs (make-array (length ints) :area *conversion-area*
				     :fill-pointer (length ints))))
		 (loop for int being the array-elements of ints
			       using (index index)
		       as ç = (aref çs index)
		       do
		   (setq ç (setf (aref çs index)
				 (let ((sys:default-cons-area *conversion-area*))
				   (make-ç-section :section-id :new))))
		   (setf (ç-section-new-version-interval ç) int))
		 (setf (file-version-info-length initial-version)
		       (or (getf initial-pathname-properties :length-in-bytes)
			   (getf initial-pathname-properties :length))
		       (file-version-info-author initial-version)
		       (getf initial-pathname-properties :author)
		       (file-version-info-creation-date initial-version)
			  (or (getf initial-pathname-properties :modification-date)
			      (getf initial-pathname-properties :creation-date)))
		 (send encached-file
		       :initialize-from-ç-section çs initial-version
		       (make-file-version-trailer
			 ;; Note that this might get parsed for the pathname someday.
			 :description (format nil "Conversion from ~A"
					      (send initial-pathname :truename))))
		 (setup-old-section-defs)
		 (loop for ç being the array-elements of çs
		       for def being the array-elements of defs
		       as sid = (ç-section-section-id ç)
		       do (setf (aref old-section-defs sid) (or def :none)))))))))

;;; Try to match each of the definitions in the new version with something from
;;; old-section-defs.  Use the old-section-used bitmap to mark off success.
;;; make the remainder be :deleted.

(defmethod (process-another-version forward-converter)
	   (a-buffer parent-version new-version pathname)
  (let* ((defs (fcb-tlf-definition-array a-buffer))
	 (ints (fcb-tlf-interval-array a-buffer))
	 (new-çs nil)
	 (çs (make-array (length ints) :fill-pointer 0 :area *conversion-area*)))
    ;; Use simple linear search technique to try to find an old definition to
    ;; go with each new one.  If there are duplicates, the first goes with the first.
    ;; as we go, we fill in çs for the ones that we find.
    (loop for def being the array-elements of defs  
	  for int being the array-elements of ints
		  using (index index)
	  as ç = (let ((sys:default-cons-area *conversion-area*))
			 (make-ç-section))
	  do
      (when (zwei:bp-= (zwei:node-first-bp int)
		       (zwei:node-last-bp int))
	(error "Null interval from sectionizer. Something is broken."))
      (vector-push-extend ç çs)
      (setf (ç-section-new-version-interval ç) int)
      (if (or trivial-sections (and (zerop index)
				    (fcb-has-attribute-list a-buffer)
				    prev-had-attribute-list))
	  (setf (ç-section-section-id ç) index)	; ought to be like that already
	  (let ((matched-sid (and def (position def old-section-defs :test #'equal))))
	    (if matched-sid
		(setf (ç-section-section-id ç) matched-sid
		      (aref old-section-defs matched-sid) nil)	;used up
		(when LOUD (warn "~A new in ~A"
				 (if def 
				     (let ((*package* nil))
				       (zwei:section-definition-name (cdr def) (car def)))
				     (zwei:string-interval int))
				 pathname))
		(push ç new-çs)
		(setf (ç-section-section-id ç) :new)))))
    ;; now, see if anything is left in old-section-defs to be :deleted
    (loop for old-def being the array-elements of old-section-defs from 1
		      using (index sid)
	  when old-def
	    do
	      (vector-push-extend
		(let ((sys:default-cons-area *conversion-area*))
		  (make-ç-section :section-id sid :new-version-interval :deleted))
		çs)
	      (when LOUD
		(warn " ~:[~A~;~D~] deleted in ~A."
		      (eq old-def :none)
		      (if (neq old-def :none)
			   (let ((*package* nil))
			     (zwei:section-definition-name (cdr old-def) (car old-def)))
			   sid)
		      pathname)))
    ;; now we are ready to feed the new version to the encached file.
    (add-new-version encached-file parent-version new-version çs
	  (make-file-version-trailer
	    :description (format nil "Conversion from ~A" pathname)))
    ;; make a new old-section-defs
    (setq old-section-defs (make-array (send encached-file :section-table-length)
				       :area *conversion-area*
				       :initial-element nil))
    ;; çs is one to one with defs, except for the :deleteds which are at the end.
    ;; since we marched defs to fill it up.
    (loop for def being the array-elements of defs from 1
	  for ç being the array-elements of çs from 1 using (index ç-index)
	  as sid = (ç-section-section-id ç)
	  do
      (setf (aref old-section-defs sid)
	    (if (null def) ':none def)))))


(defun list-versions-with-compact-file (pathname compact-pathname)
  (let* ((pathname (pathname pathname))
	 (dir-list (cdr (chase-directory-list pathname :sorted :no-extra-info)))
	 (compact-file
	   (and compact-pathname
		(Compact:read-compact-file-header compact-pathname)))
	 (compact-file-list (and compact-file
				 (send compact-file :list-all-versions))))
    ;; Make them all back into logical pathnames.
    (dolist (entry dir-list)
      (setf (first entry) (send pathname :back-translated-pathname (first entry))))
    (if (null compact-file-list) dir-list
	(loop
	   as next-dir-version = (and dir-list (send (caar dir-list) :version))
	   as next-compact-version = (and compact-file-list (caar compact-file-list))
	   while (or next-dir-version next-compact-version)
           when 
	     (and next-compact-version
		  (eql next-dir-version next-compact-version))
	     collect (car compact-file-list) and
	   do (setq compact-file-list (cdr compact-file-list))
	      (setq dir-list (cdr dir-list))
	   when (and next-compact-version
		     (or (null next-dir-version) (< next-compact-version next-dir-version)))
	     collect (car compact-file-list) and
	   do (setq compact-file-list (cdr compact-file-list))
	   when (and next-dir-version
		     (or (null next-compact-version)
			 (< next-dir-version next-compact-version)))
	     collect (car dir-list) and
	   do (setq dir-list (cdr dir-list))))))




(defun chase-one-link (pathname)
  (let ((info (fs:directory-list pathname :noerror)))
    (if (errorp info) pathname
	(setq info (cadr info))
	(let ((link-pathname (getf (cdr info) :link-to)))
	  (loop always link-pathname 
		as info =
		   (cadr			; skip silly header
		     (let ((f-info
			     (fs:directory-list
			       (fs:parse-pathname
				 link-pathname
				 (send (send pathname :translated-pathname) :host))
			       :noerror)))
		       (if (errorp f-info) nil f-info)))
		do
	    (setq pathname (car info))
	    (setq link-pathname (getf (cdr info) :link-to))))
	pathname)))

(defun chase-directory-list (initial-pathname &rest dir-list-args)
  (let ((initial-dir-list (apply #'fs:directory-list initial-pathname dir-list-args)))
    (loop for item on (cdr initial-dir-list)
	  as info = (car item)
	  as pathname = (car info)
	  as link-pathname = (getf (cdr info) :link-to)
	  do
      (loop always link-pathname 
	    as info =
	    (condition-case ()
		 (cadr				; skip silly header
		   (apply #'fs:directory-list
			  (fs:merge-pathnames	;LMFS bug can return NIL version
			    link-pathname
			    (send pathname :translated-pathname))
			  dir-list-args))
	       (fs:directory-not-found
		 nil))
	    do
	(if (null info)
	    (progn
	      (setq link-pathname nil)
	      ;; the delete in here aught to work OK against the loop,
	      ;; since the deleted cons's cdr should still be the next
	      ;; item in the list.
	      (setf (cdr initial-dir-list) (delete (car item) (cdr initial-dir-list))))
	    (rplaca item info)
	    (setq pathname (car info))
	    (setq link-pathname (getf (cdr info) :link-to)))
	))
    (when (member :sorted dir-list-args)
      (rplacd initial-dir-list
	      (sort (cdr initial-dir-list) #'<
		    :key #'(lambda (pni) (send (car pni) :version)))))
    initial-dir-list))

;;; Function that takes an ordinary set of files and produces a version controlled
;;; file.  

#||
(setq *conversion-area* (make-area :name '*test-area*
				   :gc ':ephemeral
				   :n-levels 4
				   :capacity #o1000000
				   :capacity-ratio 0.8
				   :region-size #o200000))
||#
(defun-in-flavor (trim-source-list forward-converter) 
		 (source-list all-converted-versions compact-pathname
			      append-to-branch target-pathname )
  (delete-if
    #'(lambda (pn)
	(let ((pn-v (send pn :version)))
	  (find-if
	    #'(lambda (a-c-v-e)
		(destructuring-bind
		  (pathname-version-number file-version ignore)
		   a-c-v-e
		  (and (string=
			 (file-version-branch-name file-version)
			 append-to-branch)
		       ( pn-v pathname-version-number))))
	    all-converted-versions)))
    source-list
    :key #'(lambda (pname-etc)
	     (if (numberp (car pname-etc))
		 (send compact-pathname
		       :new-pathname
		       ':type (send target-pathname :type)
		       ':version (car pname-etc))
		 (car pname-etc)))))

(defmethod (convert-file-set-internal forward-converter)
	   (source-pathname target-pathname
			    &key
			    warnings
			    append-to-branch	; branch name
			    new-branch-root
			    create-directories
			    (if-exists :new-version)	; only other meaningful
						; value is :error.
			    (if-does-not-exist :create idneg)
			    )
  (declare (values added-anything))
  1;; note that the encached-file I.V. can be non-nil on entry here.
0  (when new-branch-root
    (unless (typep new-branch-root 'file-version)
      (setq new-branch-root
	    (make-file-version-info
	      :branch-name (file-version-info-branch-name new-branch-root)
	      :branch-version (file-version-info-branch-version new-branch-root)))))

  (let ((zwei:editor-line-area *conversion-area*)
	(zwei:*line-area* *conversion-area*)	;same area, different name
	(zwei:editor-node-area *conversion-area*)
	(zwei:*bp-area* *conversion-area*)
	(zwei:*zmacs-buffer-area* *conversion-area*))
    (when (and new-branch-root (not idneg))
      (setq if-does-not-exist :error))
    (when (and new-branch-root 
	       (neq if-does-not-exist :error))
      (error
	":new-branch-root is not valid with :if-does-not-exist :create"))
    
    (setq LOUD warnings)
    (let* ((previous-version)
	   (target-exists (or encached-file
			      (condition-case-if create-directories ()
				   (probe-file target-pathname)
				 (fs:directory-not-found
				   (fs:create-directories-recursively target-pathname)
				   nil))))
	   (version)
	   (compact-pathname (and (pathnamep source-pathname)
				  (send source-pathname :new-pathname ':type ':compact
					':version ':newest)))
	   (compact-exists (and compact-pathname (probe-file compact-pathname)))
	   (source-list
	     (if (pathnamep source-pathname)
		 (list-versions-with-compact-file
		   source-pathname
		   (and compact-exists compact-pathname))
		 (let ((mfp-in-some-order (fs:multiple-file-plists source-pathname)))
		   (loop for sp in source-pathname
			 as spi = (assoc sp mfp-in-some-order)
			 when spi collect spi))))
	   (compact-file)
	   (initial-pathname)
	   (initial-properties)
	   (all-converted-versions)
	   (all-versions)
	   (buffer)
	   )
      (flet
	((blather-about-pathname (pathname-info-or-stream)
	   (let ((pathname-info 
		   (if (streamp pathname-info-or-stream)
		       (send pathname-info-or-stream :properties)
		       pathname-info-or-stream)))
	     (format *standard-output*
		     "~&Reading ~A Length ~D bytes ~A ~\\time\\ ... "
		     (car pathname-info)
		     (getf (cdr pathname-info) :length-in-bytes)
		     (getf (cdr pathname-info) :author)
		     (getf (cdr pathname-info) :modification-date))))
	 (end-blather () (format *standard-output* " read."))
	 (verify (a-buffer)
	   (let ((zwei:*interval* a-buffer))
	     (with-open-stream (int-stream (zwei:open-interval-stream a-buffer))
	       (verify-encached-file-text encached-file version int-stream))))
	 (push-version (file-version vc-file-version pathname)
	   (setq all-converted-versions
		 (acons file-version
			(list (copy-file-version vc-file-version) pathname)
			all-converted-versions))))
	(setq buffer (zwei:make-interval 'forward-conversion-buffer :initial-line t
					 :area *conversion-area*
					 :superior nil))
	(if target-exists
	    (when (eq if-exists :error)
	      (error "Target encached file already exists."))
	    (when (eq if-does-not-exist :error)
	      (error "Target encached file does not already exist.")))
	
	;; announce what we have in hand.
	
	(unless source-list
	  (format *standard-output* "~&No flat files or .compact file to convert.")
	  (return-from convert-file-set-internal nil))
	
	(when compact-exists
	  (format *standard-output* "~&     Compact file ~A."
		  (send compact-pathname :truename)))
	(if target-exists
	    (format *standard-output* "~& Appending to existing VC file ~A."
		    target-pathname)
	    (format *standard-output* "~& Creating new VC file ~A."
		    target-pathname))
	
	(if target-exists
	    (progn
	      (unless encached-file
		(format *standard-output* "~& Reading encached file header ... ")
		(setq encached-file
		      (read-file-header :pathname target-pathname :area *conversion-area*))
		(format *standard-output* "done."))
	      (setq all-versions (encached-file-versions encached-file))
	      (setq all-converted-versions
		    (getf (encached-file-stored-property-list encached-file)
			  'converted-pathname-alist))
	      (when new-branch-root
		(setq new-branch-root		;translate .newest, .oldest, etc.
		      (vci:encached-file-header-merge-version encached-file new-branch-root))
		(unless (find new-branch-root all-versions :test #'file-versions-equal)
		  (setq new-branch-root (signal-undefined-file-version
					  encached-file new-branch-root))))
	      (unless append-to-branch
		(setq append-to-branch *default-initial-branch-name*))
	      (when append-to-branch
		(unless (find append-to-branch all-versions
			      :test #'string=
			      :key #'file-version-branch-name)
		  (unless new-branch-root
		    (setq append-to-branch (signal-undefined-file-branch
					     encached-file append-to-branch)))))
	      ;; remove from source-list the versions that are already in the file,
	      ;; or the versions that are earlier than a version already in the file,
	      ;; because there is no way to insert a new version in the middle.
	      ;; it is assumed that all files in a branch are the `same thing',
	      ;; and that only their version components are significant in matching.
	      (setq source-list
		    (trim-source-list source-list all-converted-versions compact-pathname
				      append-to-branch target-pathname)))
	    ;; stuff for ^target-exists.
	    (setq encached-file (make-instance 'encached-file :area *conversion-area*
					       :name target-pathname))
	    (setq version (make-file-version-info :branch-name append-to-branch
						  :branch-version 0)))
	(unless source-list
	  (format *standard-output* "~& All versions are already in the VC file.")
	  (return-from convert-file-set-internal nil))
	
	;; now, get down to business
	
	(if target-exists
	    (progn
	      (unless (and encached-file
			   1;; not just a header.
0			   (typep encached-file 'encached-file))
		(format *standard-output* "~&Reading encached file ...")
		(setq encached-file (read-in-encached-file target-pathname :area *conversion-area*))
		(format *standard-output* "done."))
	      (when (and append-to-branch new-branch-root)
		(record-file-branch encached-file
				    (make-file-branch :name append-to-branch
						      :parent-file-version new-branch-root)))
	      (setq previous-version
		    (or new-branch-root
			(copy-file-version-info
			  (branch-last-version encached-file append-to-branch))))
	      (setq version
		    (if new-branch-root
			(make-file-version-info
			  :branch-name append-to-branch
			  :branch-version 0)
			(let ((last 
				(copy-file-version-info
				  (branch-last-version encached-file append-to-branch))))
			  (incf (file-version-branch-version last))
			  last)))
	      (with-open-stream
		(ef-stream (open-encached-file-stream
			     :encached-file encached-file
			     :file-version previous-version
			     :return-boundary-blips t))
		(read-initial-version-from-encached-file buffer ef-stream LOUD
							 target-pathname)
		(format *standard-output* "~&Reference version is ")
		(present previous-version)))
	    ;; no target, starting from scratch
	    (let* ((first (car source-list))
		   (first-pathname (first first)))
	      (loop named read-first-file do
		(catch-error-restart-if (pathnamep first-pathname)	;not from compact file
					((error)
					 "Retry reading ~A." first-pathname)
		  (with-open-stream
		    (flat-stream
		      (if (numberp first-pathname)
			  (progn
			    (push-version first-pathname version compact-pathname)
			    (unless compact-file
			      (setq compact-file (Compact:read-compact-file
						   compact-pathname)))
			    (setq initial-pathname
				  (send source-pathname :new-version first-pathname))
			    (Compact:open-file-stream compact-file first-pathname
						      :element-type 'character))
			  (push-version (send first-pathname :version) version first-pathname)
			  (setq initial-pathname first-pathname)
			  (open first-pathname :direction :input)))
		    (setq initial-properties (cdr first))
		    (blather-about-pathname
		      (if (numberp first-pathname)
			  (cons initial-pathname initial-properties)
			  flat-stream))		;use stream data when we have it.
		    (when (numberp first-pathname)
		      (format *standard-output* " (from compact file) "))
		    (setq source-list (cdr source-list))
		    (read-flat-contents buffer flat-stream LOUD)
		    (record-file-branch
		      encached-file (make-file-branch
				      :name (file-version-branch-name version)))
		    (end-blather)
		    (format t "~&Converting to ~A" version))
		  (return-from read-first-file nil)))))
	
	;; The buffer contains the first version, now setup
	(setup-definitions-table self
				 buffer :file-already-exists target-exists
				 :initial-pathname initial-pathname
				 :initial-version version
				 :initial-pathname-properties initial-properties)
	(setq prev-had-attribute-list (fcb-has-attribute-list buffer))
	(unless target-exists
	  (setq previous-version (copy-file-version-info version))
	  (verify buffer)
	  (incf (file-version-branch-version version)))
	(format *standard-output* "~%")
	(setq trivial-sections (fcb-trivial-sections buffer))
	(when buffer
	  (f-c-b-unlink-lines buffer))		;make garbage garbage more convincingly.
	(loop for (pathname . properties) in source-list
	      do
	  (setq buffer (zwei:make-interval 'forward-conversion-buffer :initial-line t
					   :area *conversion-area*
					   :superior nil))
	  (loop named retry-a-file do
	    (catch-error-restart-if (pathnamep pathname)
				    ((error) "Retry reading ~A." pathname)
	      (with-open-stream (stream
				  (if (numberp pathname)
				      (progn
					(unless compact-file
					  (setq compact-file (Compact:read-compact-file
							       compact-pathname)))
					(Compact:open-file-stream
					  compact-file pathname :element-type 'character))
				      (open pathname :direction :input)))
		(let ((a-pathname
			(if (pathnamep pathname) pathname
			    (send source-pathname :new-version pathname))))
		  (blather-about-pathname
		    (if (numberp pathname)
			(cons a-pathname properties)
			stream))
		  (when (numberp pathname)
		    (format *standard-output* " (from compact file) "))
		  (read-flat-contents buffer stream LOUD)
		  (end-blather)
		  (format *standard-output* "~&Converting to ")
		  (present version)
		  (if (numberp pathname)
		      (push-version pathname version compact-pathname)
		      (push-version (send pathname :version) version pathname))
		  (setf (file-version-info-author version)
			(getf properties :author)
			(file-version-info-creation-date version)
			(or (getf properties :modification-date)
			    (getf properties :creation-date))
			(file-version-info-length version)
			(or (send stream :length)
			    (getf properties :length-in-bytes)
			    (getf properties :length)))
		  (process-another-version
		    self buffer previous-version version a-pathname)
		  (setq prev-had-attribute-list (fcb-has-attribute-list buffer))
		  (verify buffer)
		  (setq previous-version (copy-file-version-info version))
		  (setq version (copy-file-version-info version))
		  (incf (file-version-branch-version version)))
		(when buffer
		  (f-c-b-unlink-lines buffer)) ;;make garbage garbage more convincingly.
		(setq buffer nil)
		(return-from retry-a-file nil)))))
	(setf (getf (encached-file-stored-property-list encached-file)
		    'converted-pathname-alist)
	      (stable-sort all-converted-versions #'< :key #'car)))))
  t)
(defmethod (write-out-encached-file forward-converter) (target)
  (let ((new-length
	  (loop named retry-write-file do
	    (catch-error-restart ((error) "Retry writing encached file ~A." target)
	      (return-from
		retry-write-file 
		(with-open-file (out target :direction :output)
		  (send encached-file :reconstruct-file out)
		  (send out :close)		; make :length valid
		  (send out :length)))))))
    (format *standard-output* "~& Target length ~D" new-length)))

(defparameter *default-conversion-warnings* nil)

(defun convert-file-set (source-pathname target
			 &key
			 create-directories
			 (warnings *default-conversion-warnings*)
			 append-to-branch	;branch name to put new stuff in
			 new-branch-root	;for new branch, parent version
			 )
  (error-restart ((error) "Retry conversion of ~A to ~A" source-pathname target)
    (si:with-ephemeral-migration-mode ':collect
      (let ((converter (make-instance 'forward-converter :area *conversion-area*)))
	(when
	  (convert-file-set-internal converter source-pathname target
				     :append-to-branch append-to-branch
				     :new-branch-root new-branch-root
				     :create-directories create-directories
				     :if-exists :new-version
				     :if-does-not-exist (if new-branch-root
							    :error
							    :create)
				     :warnings warnings)
	  (write-out-encached-file converter target))))))


(defun wild-pathname-p (pathname)
  (and (member (send pathname :type) '(nil :wild))
       (member (send pathname :name) '(nil :wild))
       (member (send pathname :version)
	       '(nil :wild))))


(cp:define-command (com-convert-file-sets-to-vc-files
		     :name "Convert File Sets to VC Files"
		     :command-table "User")
    ((file-set '((sequence
		   ((pathname))))
	       :default (list
			  (send (dw:presentation-type-default 'pathname)
				:new-version ':wild))
	       :prompt "file set"
	       :confirm t
	       :documentation "pathnames of file set to convert.")
     (target
       'pathname
       :documentation "pathname for the output files"
       :prompt "target directory"
       :confirm t
       :default (or (first file-set)
		    (dw:presentation-type-default 'pathname)))
     &key
     (create-directories 'boolean :default nil :mentioned-default t)
     (verify 'boolean :default nil :mentioned-default t)
     (branch-name 'string :default *default-initial-branch-name*
		  :documentation "The name of the branch that the versions
will be recorded in.")
     (new-branch-root
       '((or null file-version) :description "the parent version for a new branch, or nothing")
       :default nil
       :default-type 'null
       :prompt "new branch root version"
       :documentation "For a new branch, the version to be the parent of its first version."))
   (flet ((process-files (base-pathname pathname)
	    (let ((target-pn (send (send base-pathname :translate-wild-pathname target pathname)
				   :new-pathname :version :newest)))
	      (convert-file-set pathname target-pn :append-to-branch branch-name
				:new-branch-root new-branch-root
				:create-directories create-directories)
	      (when verify
		(format *standard-output* "~&Verifying all file versions:")
		(condition-case (error)
		     (verify-all-file-versions target-pn)
		   (fs:file-not-found
		     (format t "~2&VC File ~A does not exist, so it cannot be verified"
			     target-pn)))))))
     (loop for pathname in file-set
	   do
       (unless (eq (send pathname :version) :wild)
	 (error "Each source pathname must have a wild version."))
       (if (or (not (send pathname :wild-p))	;these will dir list to one thing,
						;which is fine.
	       (and (not (send pathname :type-wild-p))
		    (not (send pathname :version-wild-p))))
	   (process-files pathname pathname)
	   ;; there is a starname here ... we have to construct more specific starnames.
	   (let ((original-version (send pathname :version))
		 (all-files (fs:directory-list
			      (send pathname :new-version ':newest) :no-extra-info :sorted)))
	     ;; now replace each .NEWEST with the original version component
	     (loop for (newest-pathname . nil) in (cdr all-files)
		   unless (eq (send newest-pathname :canonical-type) :bin)
		     do (process-files pathname (send newest-pathname :new-version original-version))))))))
(cp:define-command (com-convert-files-to-vc-file
		     :name "Convert Files to VC File"
		     :command-table "User")
		   ((file-set '((sequence ((pathname))))
			      :default (list
					 (send (dw:presentation-type-default 'pathname)
					       :new-version ':wild))
			      :prompt "file set"
			      :confirm t
			      :documentation "pathnames of file set to convert.")
		    (target 'pathname
		      :documentation "a pathname with a non-specific name, type, and version."
		      :prompt "target directory"
		      :confirm t
		      :default (or (first file-set)
				   (send (dw:presentation-type-default 'pathname)
					       :new-version ':wild)))
		    &key
		    (create-directories 'boolean :default nil :mentioned-default t)
		    (verify 'boolean :default nil :mentioned-default t)
		    (branch-name 'string :default *default-initial-branch-name*
				 :documentation "The name of the branch that the versions
will be recorded in.")
		    (new-branch-root
		      '((or null file-version) :description "the parent version for a new branch, or nothing")
		      :default nil
		      :default-type 'null
		      :prompt "new branch root version"
		      :documentation "For a new branch, the version to be the parent of its first version."))
   (let ((all-pathnames nil))
     (loop for pathname in file-set
	   do
       (if (send pathname :wild-p) 
	   (let ((list (fs:directory-list pathname :no-extra-info :sorted)))
	     (loop for (p . nil) in list when p do (pushnew p all-pathnames)))
	   (pushnew pathname all-pathnames)))
     (convert-file-set (nreverse all-pathnames) target
		       :create-directories create-directories
		       :append-to-branch branch-name
		       :new-branch-root new-branch-root))
   (when verify
     (format *standard-output* "~&Verifying all file versions:")
     (condition-case (error)
	  (verify-all-file-versions target)
	(fs:file-not-found
	  (format t "~2&VC File ~A does not exist, so it cannot be verified"
		  target)))))

;;; This takes a pathname (say, SYS:SYS;FOO.LISP) and makes a version control file
;;; in SYS:SYS;vc-dir;FOO.LISP, where vc-dir defaults to VC. By default, it 
;;; creates the directory if it is missing.
(sct:define-system-operation :vc-convert
  #'(lambda (source ignore ignore &rest keys &key
	     (target-directory "VC") (create-directories t)
	     (branch *default-initial-branch-name*) (branch-root nil) verify
	     &allow-other-keys)
      keys
      (let* ((source-dir (send source :directory))
	     (target-pn (send source :new-directory
			      (append source-dir (list target-directory))))
	     (source-pn (send source :new-version :wild)))
	(catch-error-restart ((error) "Skip converting ~A" source-pn)
	  (format t "~&Converting ~A to ~A" source-pn target-pn)
	  (convert-file-set source-pn target-pn :create-directories create-directories
			    :append-to-branch branch :new-branch-root branch-root)
	  (when verify
	    (format t "~2&Verifying ...")
	    (verify-all-file-versions target-pn))
	  (finish-output))))
  #'(lambda (file ignore ignore &rest keys &key reap-protect &allow-other-keys)
      (ignore keys)
      (format t "~&Convert~[~;ing~;ed~] file ~A" sct:*system-pass* file))
  :arglist
  (system-name &rest keys
	       &key (query nil) silent batch
	       (include-components t) (version :newest)
	       (target-directory "VC") (create-directories t)
	       (branch *default-initial-branch-name*) (branch-root nil)
	       (verify nil)
	       &allow-other-keys)
  :encache nil
  :class :normal
  :plan-filter
  #'(lambda (system-op file module &rest ignore)
      (ignore system-op module)
      (and (not (fs:pathname-vc-p file))
	   (eq (send file :canonical-type) :lisp))))
(defun convert-system-sources-bg (system &key (target-directory "VC") (create-directories t)
				  (branch *default-initial-branch-name*)
				  verify
				  priority log-buffer log-file)
  (let ((system (sct:find-system-named system)))
    (process-run-function
      `(:name ,(format nil "VC Conversion ~A" (sct:system-short-name system))
	:priority ,priority
	:restart-after-boot t
	:restart-after-reset t)
      #'(lambda ()
	  (with-open-stream (log (if log-buffer (zwei:open-editor-stream
						  :create-p t
						  :buffer-name log-buffer
						  :set-point t)
				     (open (or log-file
					       (merge-pathnames
						 (format nil "~A.vc-log"
							 (sct:system-short-name system))))
					   :direction :output)))
	    (let ((*standard-output* log)
		  (*error-output* log))
	      (vc-convert-system system :target-directory target-directory
				 :create-directories create-directories
				 :branch branch
				 :verify verify)))))))
(cp:define-command (com-convert-system-sources-to-vc-files
		     :name "Convert System Sources to VC Files"
		     :command-table "User")
    ((system `((type-or-string ((or sct:subsystem sct:system))))
	     :documentation "Convert files for this system.")
     &key
     (include-components
       'boolean
       :documentation "Process files of component systems?"
       :default t)
     (vc-file-subdir 'string :default "VC"
;;;				       :name "VC File Subdirectory"
		     :prompt "VC file subdirectory"
		     :documentation "Version Control files will be created
and maintained in this subdirectory of the containing directory of the source files.")
     (create-directories
       'boolean :default t
       :documentation "Create subdirectories if they don't already exist.")
     (verify 'boolean :default nil
	     :documentation "Run verification after adding the files.")
     (branch-name 'string :default *default-initial-branch-name*
		  :documentation "The name of the branch that the versions 
will be recorded in.")
     (new-branch-root
       '((or null file-version)
	 :description "the parent version for a new branch, or nothing")
       :default nil
       :default-type 'null
       :prompt "new branch root version"
       :documentation "For a new branch, the version to be the parent of its first version."))
   (condition-case (error)
	(vc-convert-system system :target-directory vc-file-subdir
			   :create-directories create-directories
			   :include-components include-components
			   :verify verify
			   :branch branch-name
			   :branch-root new-branch-root)
      (sct:system-not-found (dbg:report error *error-output*))))
(cp:define-command (com-show-vc-file-contents
		     :name "Show VC File Branches"
		     :command-table "User")
    ((files `((sequence pathname)) :documentation "VC file to display"
	    :prompt "VC file pathnames")
     &key
     (detailed 'boolean :default nil :mentioned-default t
	       :documentation "Show the branch versions"))
   (loop for file in files
	 as version = (send file :version)
	 when (and version
		   (not (eql :newest version)))
	   do
	     (format *standard-output* "~2&~d is an incorrect file version in ~a.~%~
              Always use .newest file version for Show VC File Branches.~2%" version file)
	 as list = (fs:directory-list
		     (send (fs:vc-pathname-flat-pathname file) :new-version :newest)
		     :no-extra-info :sorted)
	 do
     (loop for (pathname . nil) in list
	   with file-found-p
	   finally (unless file-found-p
		     (format *standard-output* "~2&~a not found~2%" file))
	   when pathname
	     do
	       (setq file-found-p t)
	       (condition-case ()
		    (let ((ef (find-or-make-encached-file-header :pathname pathname)))
		      (print-branches-in-tree ef *standard-output*
					      :suppress-others-private nil
					      :show-versions detailed 
					      :encached-file-permanent-p t))
		  (non-version-controlled-file)))))
(zwei:define-section-name converter-cometh)
(compile-flavor-methods forward-conversion-buffer forward-converter
			interval-from-encached-file)
