;;;-*- Mode: LISP; Syntax: Common-lisp; Package: ZWEI; Base: 10; Lowercase: Yes; Default-character-style: (:fix :roman :normal); Vsp: 0 -*-
;;; Version-Control BuffersD,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI") 

;;; Base buffer flavor for buffers with disconnected sections.  This flavor
;;; provides unlinked line processing.

0;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
(defflavor basic-version-control-buffer
	(
	 display-array				1;list vc-hard-section-nodes
0						1;whose diagrams will be displayed above
0						1;them.
0	 look-here-first			1;heuristic guess of the likeliest
0						1;section to inspect for next-unlinked-line
0						1;processing.
0	 )
	(buffer)
  (:required-methods :revert)
  (:conc-name vcb-)
  (:readable-instance-variables display-array))
(defgeneric vc-buffer-trailer-major-mode (buffer)
  (:method (basic-version-control-buffer) (send self :major-mode)))
(defgeneric vc-buffer-non-trailer-major-mode (buffer)
  (:method (basic-version-control-buffer) (send self :major-mode)))
(defmethod (inferior-item-p basic-version-control-buffer) (item)
  (cl:find item display-array))
(defmethod (:set-pathname-for-write basic-version-control-buffer) (&rest ignore)
  (barf "Not permitted for a version controlled buffer."))
(defmethod (:make-non-file basic-version-control-buffer) (&rest ignore)
  (barf "Not permitted for a version controlled buffer."))

(defmethod (item-index basic-version-control-buffer) (item)
  (let ((lhf look-here-first))
    (when (> lhf (cl:length display-array))
      (setq lhf 0))
    (or
      (cl:position item display-array :start lhf)
      (cl:position item display-array :end lhf :from-end t)
1;;;--- This next is commented out because:
;;;--- 1) Some :revert methods (like DIRED) can do LINE-NEXT-IN-BUFFER
;;;---    when *INTERVAL* is not themselves.
;;;--- 2) Redisplay can use leftover lines against the wrong buffer.
;;;--- So for now, we just return NIL, and our callers returns NIL,
;;;--- which causes these bozos to do the right stuff.
;0    (error "~S is not in ~S" item self)
      )))

(defmethod (buffer-next-unlinked-line basic-version-control-buffer) (line)
  (let* ((item (line-top-level-node line))
	 (index (item-index self item)))
    (and index
	 (incf index)
	 (if ( index (fill-pointer display-array))
	     nil
	     (prog1
	       (bp-line (node-first-bp (aref display-array index)))
	       (setq look-here-first index))))))

(defmethod (buffer-previous-unlinked-line basic-version-control-buffer) (line)
  (let* ((item (line-top-level-node line))
	 (index (item-index self item)))
    (and index
	 (and (plusp index)
	      (bp-line
		(node-last-bp (aref display-array (setq look-here-first (1- index)))))))))

;; VC buffers lock entire hard sections
(defmethod (node-to-lock basic-version-control-buffer) (node)
  (if (typep node 'vc-hard-section-node-mixin)
      node
    (node-to-lock self (node-superior node))))

1;;; ---This is a temporary expedient to flush the diagram line at the top of the buffer,
;;; ---because it breaks too many other things.
0(defwhopper (vc-hard-section-node-diagram-line vc-section-version-node) ()
  (unless (eq self (aref (vcfb-section-version-node-array home-buffer) 0))
    (continue-whopper)))
(defvar *zmacs-display-bubble-diagram-lines-default* t)
;;; 1The basic usuable entity, a buffer containing a version of a file.

;;; A VC-FILE-BUFFER is a flavor of BASIC-VERSION-CONTROL-BUFFER that represents
;;; a particular version of a version-controlled source file.

0(defflavor vc-file-buffer
	(vc-file-version			1;the version number corresponding to the
0						1;contents as read from the encached file.
0						1;when the buffer is written back,
0						1;this is updated.
0	 update-tick				1;TICK when buffer was identical to parent
0	 encached-file				1;Data structure that holds all versions
0	 encached-file-file-info		
	 (name-tick 0)				1;used to force name updates
0	 (saved-name-tick 0)			1;ditto.
0	 (section-version-node-array nil)	1;the vc-section-version-nodes
0	 ç-section-array			1;parallel array of ç-section-info
0						1;used when writing a new version of the
0						1;entire buffer.
0	 (patch-only-ç-section-array nil)	1;used to save patch-only versions.
0	 (branch-locked-p nil)			1;user is the intended modifier of this
0						1;branch.
0	 (buffer-disconnected-p nil)		1;user is modifying without any locks.
0	 (user-read-only-p nil)			1;user has asked for read only status.
0	 (version-to-save nil)			1;If this is set, then when the file
0						1;is saved, the version is written into
0						1;a new branch.  
0	 (version-to-save-against nil)		1;if nil, when the buffer is saved its
0						1;parent version will be vc-file-version.
0						1;otherwise, it will be this.	 
0	 (file-branch-to-save nil)		1;if this is non-nil at save time,
0						1;it needs to be updated into the
0						1;encached file.
0	 (new-branch-p nil)			1;branch is new
0	 (display-trailers nil)			1;make the trailer sections visible.
0	 trailer-node-array			1;the trailer nodes.
0	 (non-trailer-major-mode nil)
	 (non-trailer-modes-list nil)
	 (trailer-major-mode nil)
	 (trailer-modes-list nil)
	 (mode-type 'section)
	 original-function-spec-array
	 new-original-function-specs
	 file-trailer-node			;a trailer node for the entire file.  	
	 (disposition-strategy nil)		;memo of the user's chosen disposition.
	 (vc-file-info nil)			;file info we return.
	 (unfinished-merge-target-buffer-p nil)	;set to t while buffer is begin created

	 ;; These are set if the current buffer is the result of a merge.  The
	 ;; ef, source and traget branches are saved in the
	 ;; vci::encached-file-stored-property-list to optomize future merging.

	 (source-branch-for-merge-in-progress nil)
	 (target-branch-for-merge-in-progress nil)
	 (ef-for-merge-in-progress nil)
	 (display-bubble-diagram-lines-p *zmacs-display-bubble-diagram-lines-default*)
	 1;; this next flag is used by merge to compensate for the difficulty of
0	 1;; getting all the right ticks advanced. It forces save to tell the encached
0	 1;; file about ALL of the sections, not just those with tocked ticks.
0	 (treat-all-section-versions-as-modified-at-save-time nil)
	 (deleted-section-list nil)
	 )
	(file-buffer-mixin basic-version-control-buffer)
  (:functions reset-important-bps make-vc-pathname)
  (:init-keywords vcfb-merge-target)
  (:conc-name vcfb-)
  (:initable-instance-variables encached-file vc-file-version file-branch-to-save
				(:file-info encached-file-file-info))
  (:writable-instance-variables display-bubble-diagram-lines-p
   source-branch-for-merge-in-progress target-branch-for-merge-in-progress
   ef-for-merge-in-progress deleted-section-list)
  (:readable-instance-variables
   (vcfb-file-version-to-save version-to-save)
   (vcfb-disconnected-p buffer-disconnected-p)
   section-version-node-array
   vc-file-version
   encached-file 
   original-function-spec-array
   display-bubble-diagram-lines-p
   disposition-strategy))
(defmethod (vc-buffer-trailer-major-mode vc-file-buffer) ()
  (cl:ecase mode-type
    (trailer (send self :major-mode))
    (section trailer-major-mode)))
(defmethod (:file-info vc-file-buffer) ()
  (cond ((null encached-file-file-info) ':never-read)	;conventional response.
	(file-branch-to-save ':never-read)	1;a new branch wasn't there before.
0	(vc-file-info)
	(t (setq vc-file-info
		 (with-open-file (probe-stream
				   (make-vc-pathname vc-file-version)
				   :direction :probe
				   :if-does-not-exist :error)	; can't happen
		   (send probe-stream :info))))))
(defmethod (vcfb-trailer-node-array vc-file-buffer) () trailer-node-array)
(defmethod (vcfb-display-trailers vc-file-buffer) () display-trailers)
;;; List of all section-nodes anywhere in this buffer
(defmethod (buffer-sections vc-file-buffer) ()
  (and section-version-node-array
       (loop for node being the array-elements of section-version-node-array
	     append (buffer-sections node))))
(defmethod (:sectionize-buffer vc-file-buffer) (stream)
  (cl:assert (null stream))
  (let ()
    (loop for node being the array-elements of section-version-node-array
	  do (send node :sectionize-buffer stream nil)
	     (when (vc-section-version-node-patch-only-before-node node)
	       (send (vc-section-version-node-patch-only-before-node node)
		     :sectionize-buffer stream nil))
	     (when (vc-section-version-node-patch-only-after-node node)
	       (send (vc-section-version-node-patch-only-after-node node)
		     :sectionize-buffer stream nil))
	     (when (vc-section-version-node-patch-only-instead-node node)
	       (send (vc-section-version-node-patch-only-instead-node node)
		     :sectionize-buffer stream nil)))
    ;; Speed up completion if enabled.
    (when si:*enable-aarray-sorting-after-loads*
      (si:sort-aarray *zmacs-completion-aarray*))
    (setq *zmacs-completion-aarray*
	  (follow-structure-forwarding *zmacs-completion-aarray*))
    nil))
(defwhopper (:kill vc-file-buffer) (&optional save-p)
  (when (continue-whopper save-p)		1; did the kill really happen?
0    (when branch-locked-p 
      (remove-from-buffer-name-table self)
      (vcfb-unlock-branch self))
    1;; Remove the encached file from (2 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")*zmacs-buffer-alist*1 so that it can be GC'ed --
    ;;    The primary 2:kill1 method for buffers will already have removed ourself from
    ;;    the encached file's entry in 2*zmacs-buffer-alist*1.
0    (let* ((key (zmacs-buffer-alist-key self))
	   (alist-entry (and key (assq key *zmacs-buffer-alist*))))
      (when (and alist-entry (null (cdr alist-entry)))
	(setq *zmacs-buffer-alist* (delq alist-entry *zmacs-buffer-alist*))))
1    ;; Something in the system tends to remember Zmacs buffers even after they're killed so we
    ;; need to forget the encached file locally to allow for proper GC operation.
0    (setq encached-file nil
	  encached-file-file-info nil
	  vc-file-info nil)
    t))
(defwhopper (:modified-p vc-file-buffer) (&optional (type ':for-saving))
  (if (and buffer-disconnected-p (eq type :for-saving))
      (values nil :disconnected)
      (continue-whopper type))) 
1;;; This is a noop.  CHECK-INTERVAL-SECTIONS does an ASSURE-SINGLE-SECTION-INTERVAL,
;;; and then takes the top-level-node of the start-bp.  This can only get called
;;; if point and mark are both on diagram lines, which we have to deal with
;;; somehow.
0(defmethod (:check-interval-sections vc-file-buffer) (start-bp end-bp)
  (ignore start-bp end-bp)
  (barf ":check-interval-sections sent to a buffer. Please report this ZWEI bug."))
(defmethod (zmacs-section-list vc-file-buffer) ()
  (loop for node being the array-elements of section-version-node-array
	append
	  (append (zmacs-section-list node)
		  (and (vc-section-version-node-patch-only-before-node node)
		       (zmacs-section-list
			 (vc-section-version-node-patch-only-before-node node)))
		  (and (vc-section-version-node-patch-only-after-node node)
		       (zmacs-section-list
			 (vc-section-version-node-patch-only-after-node node)))
		  (and (vc-section-version-node-patch-only-instead-node node)
		       (zmacs-section-list
			 (vc-section-version-node-patch-only-instead-node node))))))
	
(defmethod ((cl:setf zmacs-section-list) vc-file-buffer) (ignore)
  (error "Attempt to (cl:setf zmacs-section-list) a vc-file-buffer."))
(defmethod (vc-buffer-non-trailer-major-mode vc-file-buffer) ()
  (cl:ecase mode-type
    (section (send self :major-mode))
    (trailer non-trailer-major-mode)))
(defmethod (vcfb-node-type-and-index vc-file-buffer) (node)
  (cl:etypecase node
    (vc-section-version-node
      (values (cl:position node section-version-node-array)
	      'vc-section-version-node))
    (vc-section-version-trailer-node
      (values (cl:position node trailer-node-array)
	      'vc-section-version-trailer-node))))
(defmethod (vcfb-section-version-node-index vc-file-buffer) (node)
  (cl:position node section-version-node-array))

1;;; Buffer Names:
;;; 
;;; The buffer name of a buffer that is still read-only (either because it is
;;; going to stay that way, or because the user hasn't setup to modify)
;;; is named along a parallel convention to ordinary file buffers:
;;;
;;;  pathname-string-for-editor 01branch_name-branch_version0
1;;;
;;;  if the branch version is the latest in the branch, it is omitted.
;;;
;;;  As soon as the buffer becomes modifiable, the name must change.
;;;  It must always be possible to have a buffer containing the unmodified 
;;;  contents under their conventional name at the same time as the buffer
;;;  under modification.  Thus, buffers are always renamed when they become 
;;;  modifiable. Ideally, a modifiable buffer should advertise both its 
;;;  source version and its intended target, if any.
;;;
;;;  There can be any number of buffers all of whom started with the same
;;;  version and then went modifiable. This makes the choice of name a bit
;;;  hard to figure out. If the buffer is marked with the intention to save
;;;  as a particular version of a particular branch, then we can name it on
;;;  that basis, since that only happens under a lock that excludes any other
;;;  buffers from having the same idea.  If the buffer is floating free, then
;;;  it has to have a generated name.

0(defmethod (vcfb-read-only-name vc-file-buffer) ()
  (let ((sys:default-cons-area *zmacs-buffer-area*))
    (format nil "~A ~A~:[.~d~;~*~]"
	    (send pathname :string-for-editor)
	    (vci:file-version-branch-name vc-file-version)
	    (or (null encached-file-file-info)
		(vcfb-leaf-version-p self))	1;since we are read-only, we can't
0						1;be a leaf by virtue of saving as newest
0						1;in branch
0	    (vci:file-version-branch-version vc-file-version))))
(defmethod (vcfb-writable-name vc-file-buffer) ()
  (if version-to-save				1; we assume that this is unique
0						1; in the editor.
0      (let ((sys:default-cons-area *zmacs-buffer-area*))
	(format nil "~A ~A"
		(send pathname :string-for-editor)
		(vci:file-version-branch-name version-to-save)))
      ;; otherwise, we have to make up a name
      (loop for index from 1
	    as candidate-name =
	       (let ((sys:default-cons-area *zmacs-buffer-area*))
		 (format nil "~A ~A.~D  ~D"
			 (send pathname :string-for-editor)
			 (vci:file-version-branch-name vc-file-version)
			 (vci:file-version-branch-version vc-file-version)
			 index))
	    when (not (find-buffer-named candidate-name))
	      do (return candidate-name))))
(defmethod (:name vc-file-buffer) ()
  (if unfinished-merge-target-buffer-p
      name
      (if (and (equal encached-file-file-info (vci:encached-file-file-info encached-file))
	       (= name-tick saved-name-tick))
	  name
	  (setq encached-file-file-info (vci:encached-file-file-info encached-file))
	  (setq saved-name-tick name-tick)
	  (send self :set-name
		(if (eq tick ':read-only)
		    (vcfb-read-only-name self)
		    (vcfb-writable-name self)))
	  name)))

(defmethod (buffer-name-for-display vc-file-buffer) ()
  (format
    nil
    "~A~:[~*~; (~D)~]~:[~; (New)~]~:[~*~; (From ~A)~]~:[~; (Branch Locked)~]~:[~; (Disconnected)~]"
    (send self :name)
    (if (or version-to-save buffer-disconnected-p)
	 nil
	(vcfb-leaf-version-p self))
    (vci:file-version-branch-version (or version-to-save vc-file-version))
    (null encached-file-file-info)
     branch-locked-p				1;don't bother to show source in disconnected
0						1;case
0    vc-file-version
    branch-locked-p
    buffer-disconnected-p))
(defmethod (make-instance vc-file-buffer) (&key ((vcfb-merge-target vcfb-merge-target))
						&allow-other-keys)
  (if vcfb-merge-target
      (vcfb-setup-as-merge-target self)
      (setq vc-file-version
	    (vci:encached-file-header-merge-version encached-file vc-file-version))
      (unless encached-file-file-info 
	(setq version-to-save vc-file-version))
      (setq pathname (send (vci:encached-file-pathname encached-file) :translated-pathname))
      (let ((old-tick tick))
	(setq tick ':read-only)			1;needed for the following.
0	1;; 0vcfb-read-only-name1 will barf if the tick is a number.
0	(setq name (vcfb-read-only-name self))
	(setq tick old-tick))
      (unless encached-file-file-info (setq version-to-save vc-file-version))))
(defmethod (vcfb-setup-as-merge-target vc-file-buffer) ()
  (send self :putprop (major-mode-from-keyword :fundamental) :major-mode)
  (setq pathname nil encached-file-file-info nil name "Unfinished Merge Target"))

(cl:defparameter *initial-vcfb-n-sections* 10)
1;;; Function that constructs a list of things in the default empty file
0(defun simulate-empty-vc-file ()
  (list
    (vci:make-section-boundary-blip :begin-section-id :new)
    (let ((l (create-line art-string 4 nil)))
      (copy-array-portion "    " 0 4 l 0 4)
      l)
    (vci:make-section-boundary-blip :begin-section-id :new)
    (create-line art-string 0 nil)))
(defmethod (:revert vc-file-buffer) ()
  (remove-from-buffer-name-table self)
  (setq treat-all-section-versions-as-modified-at-save-time nil)
  (let ((buffer-state-important (or version-to-save buffer-disconnected-p))
	(creation-ex-nilho (null encached-file-file-info))	1; this is a brand new buffer.
0	(cl:*package* cl:*package*)		1;so we can setq to get the right value.
0	section-id-for-point-redisplay)
    ;; Inform all support buffers (there are several flavors that care)
    (loop for (key . buffers) in *zmacs-buffer-alist* do
      (when (symbolp key)
	(dolist (support-buffer buffers)
	  (send-if-handles support-buffer :buffer-killed self))))
    (flush-zmacs-buffers-properties-for-buffer self)
    (unless (or creation-ex-nilho
		(not (or version-to-save buffer-disconnected-p))
		(eql tick ':read-only) user-read-only-p)
      (unless (typein-line-y-or-n-p "Keep the modification style? ")
	(setq disposition-strategy nil)
	(setq buffer-disconnected-p nil)
	(when branch-locked-p
	  (remove-from-buffer-name-table self)	;remove old buffer name
	  (vcfb-unlock-branch self)
	  (add-to-buffer-name-table self))	;add with new buffer name
	(setq version-to-save nil)
	(setq file-branch-to-save nil)
	(incf name-tick)
	(send self :name)
	(setq tick ':read-only user-read-only-p nil)))
    (setq look-here-first 0)
    (setq trailer-major-mode (major-mode-from-keyword *vc-trailer-default-major-mode* t))
    (setq trailer-modes-list nil)
    (setq non-trailer-major-mode (major-mode-from-keyword :fundamental t))
    (setq mode-type 'section)
    (vcfb-set-display-trailers self nil)
    (setq user-read-only-p nil)
    (setq deleted-section-list nil)
    (setq source-branch-for-merge-in-progress nil
	  target-branch-for-merge-in-progress nil
	  ef-for-merge-in-progress nil)
    (setq read-tick (tick)
	  save-tick *tick*
	  update-tick *tick*)

    (when (vcfb-leaf-version-p self)
      (vci::ensure-encached-file-up-to-date encached-file)
      (unless (vcfb-leaf-version-p self)	;See if we're still the leaf version
	(typein-line "Reverting buffer to newest version ...")
	(setq vc-file-version
	      (vci:branch-last-version
		encached-file
		(vci:file-version-branch-name vc-file-version)))
	(setq vc-file-info			;update the file info
	      (with-open-file (probe-stream
				(make-vc-pathname vc-file-version)
				:direction :probe
				:if-does-not-exist :error)	; can't happen
		(send probe-stream :info)))
	;;redisplay-mode-line might be too big of a hammer to get the
	;;buffer label right, but I don't know where to find the right hammer
	(redisplay-mode-line)
	(setq version-to-save nil)))

    ;; Make this read-only if it's not a leaf version; to edit it, you have to fork it first.
    (unless buffer-state-important
      
      1;; The buffer is read-only until and unless branch lock is held or the user sets
0      1;; it adrift, which cannot happen here.
0      
      (if (or (eq encached-file-file-info nil) branch-locked-p)
	  (setq tick read-tick)
	  (setq tick ':read-only)))
    
    (setq new-branch-p (or creation-ex-nilho file-branch-to-save))
    
    (setq file-trailer-node
	  (make-interval 'vc-section-version-trailer-node
			 :tick read-tick
			 :home-buffer self
			 :file-trailer-p t
			 :section-version-node nil))
    
1    ;;Before we rewrite section-version-node-array, find the node containing (point).  If
    ;;this is a :new node, find the first non-:new node previous to it.  Save this node0 1id
    ;;for repositioning of point in finish-revert.
0    (unless creation-ex-nilho
      (let* ((point-node (bp-top-level-node (point)))
	     (point-section-index (cl:position point-node section-version-node-array)))
	(when (and (typep point-node 'vc-section-version-node)
		   point-section-index 
		   (eql (vc-section-version-node-section-id point-node) :new))
	  (setq section-id-for-point-redisplay
		(loop for node being the array-elements of section-version-node-array
			  from (1- point-section-index) downto 0
		      while (eql (vc-section-version-node-section-id node) :new)
		      finally (return (vc-section-version-node-section-id node)))))))

1    0;;1Use overestimate of the number of sections in this version of the file ---
    0;;1modularize parts of this shared with viewspec buffers out, later
0    (let* ((n-sections (if creation-ex-nilho *initial-vcfb-n-sections* 
			   (send encached-file :number-of-sections))))
      (setq section-version-node-array (cl:make-array n-sections :fill-pointer 0)
	    ç-section-array (cl:make-array n-sections :fill-pointer 0)
	    trailer-node-array (cl:make-array n-sections :fill-pointer 0)
	    original-function-spec-array (cl:make-array
					   n-sections :initial-element nil)))
    1;; Iterate over the sections that exist in this version of the file
0    1;; For each section, create a vc-section-version-node and fill in the text
0    1;; For each section after the first, put a separating-line-diagram before it
0    1;; and make the line-next and line-previous of that diagram point appropriately
0    (let ((current-node nil)			1;the node currently being constructed
0	  (previous-line nil)			1;the previous line in this node
0	  (previous-node nil)
	  (first-section-p t))
      (labels ((finish-section ()
		 (when current-node
		   (unless previous-line	1;sections can't be empty--can this happen?
0		     (setq previous-line (create-line 'sys:art-string 0 nil))
		     (cl:setf (interval-first-bp current-node)
			      (create-bp previous-line 0 :normal current-node)))
		   (cl:setf (line-next previous-line) nil)
		   (cl:setf (interval-last-bp current-node)
			    (create-bp previous-line (line-length previous-line)
				       :moves current-node))
		   (when first-section-p
		     (unless creation-ex-nilho
		       (with-open-stream
			 (first-section-is (open-interval-stream current-node))
			 (let ((cl:*package* si:pkg-user-package)
			       (cl:*print-base* 10.))
			   (reparse-attribute-list-internal self first-section-is))))
		     1;;there is already a binding established of *package*
0		     (setq cl:*package* (send self :get ':package))
		     (when *zmacs-force-fundamental-mode*
		       1;;special trick for Find File In Fund Mode
0		       (send self :putprop (major-mode-from-keyword :fundamental)
			     :major-mode))
		     (setq first-section-p nil))))
	       (process-record (record)
		 (cl:etypecase record
		   ((or string scl:instance)
1		     ;; Get a copy of the line that we can link into our data structure
0		     1;; the encached file hands us references to the real records.
0		     (let ((r (if (instancep record)
				  (let ((r (create-line 'sys:art-string 0 current-node)))
				    (setf (line-diagram r) record)		       
				    r)
				  (let ((r (create-line (array-type record) (cl:length record)
							current-node)))
				    (copy-array-contents record r)
				    r))))
		       (setq record r))
		     1;; If this is the first line in the interval, set interval-first-bp
0		     1;; and link the previous diagram to this line
0		     (unless previous-line
		       (cl:setf (interval-first-bp current-node)
				(create-bp record 0 :normal current-node)))
		     1;; Insert the line at the end of the interval
0		     (when previous-line
		       (cl:setf (line-next previous-line) record)
		       (cl:setf (line-previous record) previous-line))
		     (setq previous-line record))
		   (vci:section-boundary-blip
		     1;; Start of a new section
0		     (finish-section)
		     (setq current-node
			   (make-interval 'vc-section-version-node
					  :tick read-tick
					  :home-buffer self
					  :section-id (vci:sbb-begin-section-id record)))
		     (cl:vector-push-extend current-node section-version-node-array)
		     (let ((trailer-node 
				 (make-interval
				   'vc-section-version-trailer-node
				   :tick read-tick
				   :home-buffer self
				   :file-trailer-p nil
				   :section-version-node current-node
				   )))
		       (cl:vector-push-extend trailer-node trailer-node-array)
		       (cl:setf (vc-section-version-node-trailer-node current-node)
				trailer-node))
		     (cl:vector-push-extend
		       1;; the contents of the ç-section are ignored,
0		       1;; the important this is that we allocate the
0		       1;; structure.  The definitive version is filled in
0		       1;; at save time.0		       
		       (vci:make-ç-section
			 :section-id (vc-section-version-node-section-id current-node)
			 1;; We only set the
0			 1;; interval if the node
0			 1;; has been munged at save
0			 1;; time.
0			 :new-version-interval nil)
		       ç-section-array)
		     (setq previous-node current-node)
		     1;; Do not link lines of this section to lines of previous section
0		     (setq previous-line nil)))))
	(cond (creation-ex-nilho
	       (loop for record in (simulate-empty-vc-file) do (process-record record)))
	      (t
	       (loop for record being the text-and-section-records
			 in-version vc-file-version
			 of encached-file
		     do
		 (process-record record))))
	(unless current-node			1;--- can this happen?  create a dummy?
0	  (error "Empty vc files don't work"))
	1;; Finish the last section
0	(finish-section))
      (vcfb-finish-revert self section-id-for-point-redisplay)
      (loop for s-v-node being the array-elements of section-version-node-array do
	(sectionize-buffer-internal
	  s-v-node nil (send self :major-mode) cl:*package*
	  nil
	  self))
	(diagram-legend current-node t))	1; calculates the function spec.
0    )
  (add-to-buffer-name-table self)
  (send self :file-info)1			; cache this info for later
0  (when (eq self *interval*) (set-attribute-state-from-buffer self)))
(defmethod (vcfb-finish-revert vc-file-buffer) (&optional section-id-for-point-redisplay)
  (setq display-array (make-array (cl:length section-version-node-array)
				  :fill-pointer 0 :adjustable t))
  (loop for first = t then nil
	for s-v-node being the array-elements of section-version-node-array
	for t-node being the array-elements of trailer-node-array
	as s-v-caption = (make-diagram-line *vc-section-separating-diagram-flavor*)
	as s-v-alternate = (make-diagram-line *vc-intra-section-separating-diagram-flavor*)
	as s-v-title   = (make-diagram-line *vc-section-title-diagram-flavor*
					    :associated-node s-v-node)
	as t-caption   = (make-diagram-line *vc-section-separating-diagram-flavor*)
	as t-title     = (make-diagram-line *vc-section-title-diagram-flavor*
					    :associated-node t-node)
	do
    
    1;; store the function spec info.
0    (when (vc-section-version-node-function-spec s-v-node)
      (when ( (vc-section-version-node-section-id s-v-node)
	       (cl:length original-function-spec-array))
	(cl:adjust-array
	  original-function-spec-array
	  (+ 10 (vc-section-version-node-section-id s-v-node))))
      (cl:setf (aref original-function-spec-array
		     (vc-section-version-node-section-id s-v-node))
	       (cons (vc-section-version-node-definition-type
		       s-v-node)
		     (vc-section-version-node-function-spec s-v-node))))

    1;; put in the section title line0s1 at the beginning of each version section
0    1;; and each trailer section
0    
    (vcb-add-diagram-lines-to-node s-v-node nil s-v-caption s-v-alternate)
    (vcb-add-diagram-lines-to-node t-node nil t-caption)
    
    (cl:vector-push-extend s-v-node display-array))
  
  (let ((buffer-state-important (or version-to-save buffer-disconnected-p)))
    ;; Make this read-only if it's not a leaf version; to edit it, you have to fork it first.
    (unless buffer-state-important
      
      ;; The buffer is read-only until and unless branch lock is held or the user sets
      ;; it adrift, which cannot happen here.
      
      (if (or (eq encached-file-file-info nil) branch-locked-p)
	  (setq tick read-tick)
	  (setq tick ':read-only))))    
  
  ;; Make the text of the buffer be the text of all the sections
  ;; this assumes that display-trailers is nil!
  
  (setq first-bp
	(copy-bp (node-first-bp (aref section-version-node-array 0)) :normal self))
  
  (setq last-bp (copy-bp (interval-last-bp
			   (aref section-version-node-array
				 (1- (fill-pointer section-version-node-array))))
			 :moves self))

  (setq saved-point (if section-id-for-point-redisplay
			(let* ((section-index
				 (cl:position section-id-for-point-redisplay
					      section-version-node-array
					      :key #'vc-section-version-node-section-id))
			       (node (aref section-version-node-array section-index)))
			  (copy-bp (node-last-bp node) :normal self))
			(reposition-point-after-revert self (point))))
  (setq saved-mark (copy-bp saved-point :normal self))
  (setq saved-window-start-bp (copy-bp first-bp :normal self))

  ;; The following prevents redisplay from exploding.  Why the DIS-TEXT in REVERT
  ;; is insufficient is a mystery to me.
  (when (and (variable-boundp *interval*) (eq self *interval*))
    (move-point saved-point)		      
    (move-mark saved-mark)
    (cl:setf (window-mark-p *window*) nil)
    (move-bp (window-start-bp *window*) saved-window-start-bp)
    (set-attribute-state-from-buffer self)))
(defmethod (reposition-point-after-revert vc-file-buffer) (current-point)
  (let* ((point-node (bp-top-level-node current-point))
	 (point-section-index (when (typep point-node 'vc-section-version-node)
				(cl:position (vc-section-version-node-section-id point-node)
					     section-version-node-array :test #'eql
					     :key #'vc-section-version-node-section-id))))

1    ;;If the node containing point was not found in section-version-node-array, return
    ;;node-first-bp for the buffer.
0    (if (and point-section-index
	     (eq self (bp-buffer current-point)))
	(let ((line-in-section (count-lines (node-first-bp point-node) (point) t))
	      (character-in-line (bp-index (point))))
	  (copy-bp (forward-char (forward-line
				   (node-first-bp
				     (aref section-version-node-array point-section-index))
				   (1- line-in-section) t)
				 character-in-line t)
		   :normal self))
	(copy-bp first-bp :normal self))))
(defmethod (buffer-change-point-top-level-node vc-file-buffer) (target-node)
  1;; play games with the major mode.
0  (let ((was-trailer (eq mode-type 'trailer))	1;wherever we were last.
0	(target-trailer (cl:typep target-node 'vc-section-version-trailer-node)))
    (when (neq was-trailer target-trailer)
      1;; start with things that don't depend on whether we are the current buffer.
0      (setq mode-type (if target-trailer 'trailer 'section))
      (if (or (eq self *interval*) (eq self (interval-buffer *interval*)))
	  (progn
	    (if was-trailer
		(setq trailer-modes-list *mode-list*
		      trailer-major-mode (send (interval-buffer *interval*) :major-mode))
		(setq non-trailer-modes-list *mode-list*
		      non-trailer-major-mode (send (interval-buffer *interval*) :major-mode)))
	    (un-set-modes)
	    (set-modes
	      (if target-trailer trailer-modes-list non-trailer-modes-list)
	      (if target-trailer trailer-major-mode
		  non-trailer-major-mode))
	    (send self :putprop (if target-trailer trailer-major-mode
				    non-trailer-major-mode)
		  :major-mode)
	    (redisplay-mode-line))
	  1;; If we aren't *interval*, just set our internal state
0	  (setf (buffer-saved-mode-list self)
		(if target-trailer trailer-modes-list
		    1;; if modification comments have never been under the point,
0		    1;; the non-trailer info will never have been set up.
0		    1;; this assumption (that the buffer always starts out in
0		    1;; 'section) may be bogus.
0		    (or non-trailer-modes-list (buffer-saved-mode-list self))))))))
;;; For quick finding of all buffers extracted from an encached file
(defmethod (zmacs-buffer-alist-key vc-file-buffer) ()
  encached-file)
(defun lookup-version-controlled-buffer (encached-file encached-file-version)
  (cl:find-if #'(lambda (b)
		  (editing-vc-file-version-p b encached-file encached-file-version))
	      (cdr (assq encached-file *zmacs-buffer-alist*))))
(defmethod (map-buffer-names vc-file-buffer) (funarg)
  (funcall funarg name)
  (cond ((eq tick ':read-only)			;unscathed buffers match current & newest
	 (funcall funarg (make-vc-pathname vc-file-version))
	 (when (vcfb-leaf-version-p self)
	   (funcall funarg (make-vc-pathname vc-file-version :force-newest t))))
	(version-to-save (funcall funarg (make-vc-pathname version-to-save :force-newest t)))))
(defgeneric buffer-editing-modified-vc-file (buffer a-encached-file a-branch-name)
  (:method (buffer) (ignore a-encached-file a-branch-name) nil)
  (:method (vc-file-buffer)
   (and (eq encached-file a-encached-file)
	(not buffer-disconnected-p)
	(and version-to-save
	     (string-equal (vci:file-version-branch-name version-to-save)
			   a-branch-name)))))
;;; Note that this is less restrictive than :editing-pathname-p ---
;;; a modified buffer is still a file buffer for purposes of record-source-file-name
;;; and such, it just dosen't match on c-X c-F.
(defmethod (:editing-file-p vc-file-buffer) ()	;disconnected buffers don't count
  (not buffer-disconnected-p))			;as file buffers.
1;;;---should this be (newest+1) for 0version-to-save1, instead of :newest?
0(defmethod (:pathname vc-file-buffer) ()	;see :editing-file-p.
  (cond (unfinished-merge-target-buffer-p pathname)
	(buffer-disconnected-p nil)
	((eq tick ':read-only)
	 (make-vc-pathname vc-file-version))
	(version-to-save (make-vc-pathname version-to-save :force-newest t))
	;; mystery.
	(t (debugging-barf "No version-to-save on modified, non-disconnected buffer. ~
			    Please report this VC bug."))))
(defmethod (:default-pathname vc-file-buffer) ()
  (make-vc-pathname vc-file-version :force-newest t))
(defun-in-flavor (make-vc-pathname vc-file-buffer) (vc-version &key force-newest)
  (send pathname
	:new-pathname
	:version :newest			;lie usefully
	:vc-branch (vci:file-version-branch-name vc-version)
	:vc-version (if force-newest :newest
			(vci:file-version-branch-version vc-version))))
1;;; This says that a particular version is in a particular buffer 
;;; if either it is still an image (no designated version to save)
;;; or if it is intended to save as that.  
0(defmethod (editing-vc-file-version-p vc-file-buffer) (a-encached-file a-vc-file-version)
  (and (not buffer-disconnected-p)
       (eq encached-file a-encached-file)
       (vci:file-versions-equal
	 (or version-to-save vc-file-version)
	 a-vc-file-version)))
1;;; This just asks if the buffer came from that file.
0(defmethod (source-vc-file-version-p vc-file-buffer) (a-encached-file a-vc-file-version)
  (and (eq encached-file a-encached-file)
       (vci:file-versions-equal vc-file-version a-vc-file-version)))
(defmethod (editing-vc-file-version-p buffer) (a-encached-file a-vc-file-version)
  (ignore a-encached-file a-vc-file-version)
  nil)
(defmethod (source-vc-file-version-p buffer) (a-encached-file a-vc-file-version)
  (ignore a-encached-file a-vc-file-version)
  nil)
;;; Returns t if buffer is a disconnected VC buffer.
(defgeneric vc-file-buffer-disconnected-p (buffer)
  (:method (buffer) nil)
  (:method (vc-file-buffer)
   buffer-disconnected-p)) 
(defmethod (vc-file-buffer-p vc-file-buffer) ()
  t)
(defmethod (:set-not-modified vc-file-buffer) (&optional undo-p)
  1;; We consider this to be revert in disguise.  The alternative is too
0  1;; dangerous.
0  (when (send self :modified-p :for-listing)
    (if undo-p
	(setq save-tick (tick))
	(when (fquery-with-mini-buffer-history '(:type :tyi :list-choices t)
					       "Revert buffer ~A? " name)
	  (send self :revert)
	  (if (eq self (window-interval *window*))
	      (must-redisplay *window* dis-text)
	      (let ((window (dolist (window *window-list*)
			      (and (eq (window-interval window) self)
				   (return window)))))
		(when window (must-redisplay window dis-text))))))))
1;;; This is contracted to return the user state, not whether modifications will succeed.
0(defmethod (:read-only vc-file-buffer) () user-read-only-p)
(defmethod (:set-read-only vc-file-buffer) ()
  (unless user-read-only-p
    (setq user-read-only-p t)
    (prog1 (if (eq tick ':read-only) save-tick tick)
	   (remove-from-buffer-name-table self)
	   (setq tick ':read-only)
	   (add-to-buffer-name-table self))))
(defmethod (:set-read-write vc-file-buffer) (&optional tick-to-restore)
  (when user-read-only-p
    (setq user-read-only-p nil)
    1;; we only actually allow writing if the usual criteria are satisfied.
0    (when (or buffer-disconnected-p branch-locked-p)
      (remove-from-buffer-name-table self)
      (setq tick (or tick-to-restore (tick)))
      (add-to-buffer-name-table self))))
;;;--- :SELECTOR argument was accepted in 7.1, and compiled in by the MAP-OVER-HARD-SECTIONS
;;;--- macro, so it can't be removed until 8.0, to preserve binary file compatibility.
(defmethod (map-over-sections-in-interval vc-file-buffer)
	   (start-bp end-bp continuation &key selector)
  (ignore selector)
  (multiple-value-bind (real-start-bp real-end-bp)
      (assure-single-section-interval-1 start-bp end-bp nil t)
    (if (neq real-start-bp t)			; trivial case
	(funcall continuation real-start-bp real-end-bp)
	(loop for section being the array-elements of display-array
		  from (cl:position
			 (bp-top-level-node start-bp)
			 display-array)
	      as done = nil
	      as sbp = start-bp
		     then (node-first-bp section)
	      as ebp = (if (eq (bp-top-level-node end-bp) section)
			   (prog2 (setq done t) end-bp)
			   (node-last-bp section))
	      do
	  (funcall continuation sbp ebp)
	  (when done
	    (return nil))))))
;;;--- :SELECTOR argument was accepted in 7.1, and compiled in by the DEFINITION-REGION-LINES
;;;--- macro, so it can't be removed until 8.0, to preserve binary file compatibility.
(defmethod (map-over-lines-in-interval vc-file-buffer)
	   (start-line end-line continuation &key selector)
  (ignore selector)
  (if (eq (line-top-level-node start-line)
	  (line-top-level-node end-line))
      (funcall continuation start-line end-line)
      (let ((start-bp (create-bp start-line 0))
	    (end-bp (create-bp end-line (fill-pointer end-line))))
	(loop for section being the array-elements of display-array
		  from (cl:position (bp-top-level-node start-bp) display-array)
	      as sbp = start-bp then (node-first-bp section)
	      as ebp = (if (eq (bp-top-level-node end-bp) section) end-bp
			   (beg-line (node-last-bp section) -1 t))
	      do
	  (funcall continuation sbp ebp)
	  (when (bp-= ebp end-bp)
	    (return nil))))))
(defmethod (vcfb-section-version-node vc-file-buffer) (index)
  (aref section-version-node-array index))
(defmethod (vcfb-n-section-version-nodes vc-file-buffer) ()
  (1- (cl:length section-version-node-array)))
(defmethod (interval-bp-absolute-limiting-interval vc-file-buffer) (bp)
  "The containing hard section node of the BP"
  (node-top-level-node (line-node (bp-line bp))))
(defmethod (execute-buffer-mode-hook vc-file-buffer) ()
    (turn-on-mode *vcfb-mode*))

;;; This produces the text that will appear under the "File Version" column
;;; for c-x c-b
;;; Use buffer-name-for-display from start of vc information

(defmethod (:description vc-file-buffer) ()
  (let* ((buffer-name (buffer-name-for-display self))
	 (-pos (scl:string-search-char #\ buffer-name :from-end t)))
    (substring buffer-name -pos)))
(defmethod (buffer-version-controlled-p vc-file-buffer) () t)
1;;; the hard section is the item.
0(defmethod (interval-bp-item-limiting-interval vc-file-buffer) (bp)
  (bp-top-level-node bp))
(defgeneric buffer-mode-list (buffer)
  (:method (buffer) (if (or (eq self *interval*) (eq (interval-buffer self) *interval*))
			*mode-list*
			(buffer-saved-mode-list self))))
1;;;; --- Temporary ...

0(defun vc-zmacs-tweaks ()
  (unless *window-label-mode*
    (setf *window-label-mode* :vc-buffers-only))
  ;; for now, don't change label character style
  )

(add-initialization "ZMACS adjustments" '(vc-zmacs-tweaks)
		    nil 'vci:*initializations*)
