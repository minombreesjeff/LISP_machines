;;; -*- Mode: LISP; Base: 8; Package: TAPE; Lowercase: Yes -*-

;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
;;;>

;;;To be done:
;;; multiple tape handling
;;; automatic mapping, which subsumes hierarchies
;;; ability to dump systems.

(defvar *stream*)				;The tape stream 
(defvar *el-stream*)				;The embedded-length stream

(defun carry-dump (file-or-files
		   &key device tape-host density reel (report-stream t) (query t) (verify nil)
			since author)
  "Dump a file or set of files to a carry tape.  Carry tapes are written in a 
system-independent format intended to facilitate inter-system transfer of files.
The first argument must be a pathname, filespec, or list of pathnames and//or filespecs.
Wildcard pathnames or filespecs may be used.

Any type of file may be dumped.  Character files will be dumped and reloaded using
the Lisp Machine character set as an interchange medium.  Binary files will be dumped
and reloaded with the proper byte size as long as either 
   1) The file is of one of the system's known canonical types, or
   2) The operating system on which the file resides knows and can supply the byte size.

Keyword arguments allow explicit control over on which host the tape is
to be mounted and written, as well as other parameters of the tape.  If
you do not supply a tape host, you will be asked for one, with a
reasonable default, at the appropriate time."

  (when (eq report-stream t)
    (setq report-stream standard-output))
  (let ((file-lists (carry-dump-file-lists file-or-files
					   :since since :author author)))
    (cond ((loop for file-list in file-lists
		 never (cdr file-list))
	   (format error-output "~&None of the given specifications matches any files."))
	  ((or (not query) (dump-is-this-right file-lists))
	   (carry-dump-files file-lists
			     :tape-host tape-host
			     :device device
			     :density density
			     :report-stream report-stream
			     :reel reel)
	   D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");; Not sure if this is the right criteria for printing a "finish-up" message...
0	   1;; If carry-dump is called from within a program output may not be desireable.
0	   (when report-stream
	     (format report-stream "~&Dump complete."))
	   (when verify
	     (format report-stream "  Verifying.~%")
	     (carry-list :tape-host tape-host
			 :device device
			 :density density
			 :report-stream report-stream
			 :reel reel
			 :verify t))))))

(defun carry-dump-file-lists (files &key since author)
  (when (nlistp files)
    (setq files (list files)))
  (let ((non-wild-pathnames nil))
    (setq files (loop for path in files
		      do (setq path (fs:merge-pathnames path))
		      collect
			(list* path
			  (cond ((send path :wild-p)
				 (loop for node in (fs:directory-list path)
				       when (and (car node)
						 (not (get node :directory))
						 (not (and (get node :link-to)
							   (let* ((truename (send (car node)
										  :truename))
								  (props
								    (and truename
									 (send truename
									       :properties))))
							     (and props
								  (get props :directory)))))
						 (or (null since)
						     ( (cl:getf (cdr node) :creation-date 0)
							since))
						 (or (null author)
						     (if (listp author)
							 (member (get node :author) author)
							 (equal (get node :author) author))))
					 do (setf (car node)
						  (send path :back-translated-pathname
							(car node)))
					 and collect node))
				(t
				 (push path non-wild-pathnames)
				 nil)))))
    (dolist (node (fs:multiple-file-plists non-wild-pathnames))
      (let ((entry (assq (first node) files)))
	(when entry
	  (setf (cdr entry)
		(when (and (cdr node)
			   (or (null since)
			       ( (cl:getf (cdr node) :creation-date 0) since))
			   (or (null author)
			       (if (listp author)
				   (member (get node :author) author)
				   (equal (get node :author) author))))
		  (list (list* (send (first entry) :back-translated-pathname
				     (get node :truename))
			       (zwei:some-plist (cdr node)
						'(:author :creation-date :byte-size))))))))))
  (dolist (entry files)
    (setf (first entry)
	  ;; String-for-printing is the canonical key for grouping
	  ;; files at load time.
	  (send (first entry) :string-for-printing)))
  files)

(defun carry-dump-files-directory-invalid-handler (error)
  (declare (special *carry-dump-spec-in-progress*))
  (let ((file (send error :pathname)))
    (if (let ((node (second (fs:directory-list *carry-dump-spec-in-progress*))))
	  (and (get node :link-to)
	       (get (send (send (car node)
				:truename)
			  :properties)
		    :directory)))
	(dbg:with-extra-debugger-menu-conditions
	  (cli::default-error)
	  (cl:cerror
	    "Skip attempting to dump ~A"
	    "~A~%  is a link to directory ~A;~%  directories themselves can't be dumped."
	    *carry-dump-spec-in-progress* file)
	  (throw 'carry-dump-file-complete nil))
      nil)))

(defun carry-dump-files (file-spec-lists &key device tape-host density reel report-stream)
  (let ((file-spec-lists (copylist file-spec-lists))
	(*el-stream*)				;managed dynamically. Ycch, but
						;harmless
	(n-tapes 1)
	)
    (loop named split-onto-tapes do
      (block next-tape 
	(return-from split-onto-tapes
	  ;; dump-stream-getter SETQ's *el-stream*
	  (with-open-stream (*stream* (dump-stream-getter tape-host density reel device))
	    (write-prologue file-spec-lists)
	    (send *stream* ':eof)
	    (condition-case (err)
		 (loop for file-spec in file-spec-lists
		       as (spec . files) = file-spec
		       do (loop for file-and-plist in (copylist files)
				as (file) = file-and-plist
				do (let ((*carry-dump-spec-in-progress* spec))
				     (declare (special *carry-dump-spec-in-progress*))	;
				     (CATCH 'CARRY-dump-file-complete
				       (condition-bind
					 ((fs:invalid-operation-for-directory
					    #'carry-dump-files-directory-invalid-handler))
					 (dump-one-file
					   spec file file-and-plist report-stream))))
				   (pop (cdr file-spec))	;remove from the list
				   )
			  (pop file-spec-lists))
	       (end-of-tape
		 (close *stream*)
		 (format t "~&End of tape ~D." n-tapes)
		 (loop until
			 (y-or-n-p "Is the next tape mounted and ready? "))
		 (return-from next-tape nil)))))))))

(defun dump-is-this-right (file-lists)
  (format t "~&To be dumped:")
  (loop for (spec . files) in file-lists
	do (format t "~&~A: ~:[~D~;No~*~] file~:P" spec (null files) (length files)))
  (y-or-n-p "Is this right? "))

(defflavor carry-output-el-stream ()
	   (si:embedded-length-character-output-stream)
  )						;must precede use or compiler complains

(defun dump-stream-getter (tape-host density reel device &aux stream)
  (unwind-protect
    (prog1
      (setq stream
	    (tape:make-stream :device device
			      ':host tape-host ':density density ':reel reel
			      ':direction ':output ':record-length 8192.
			      ':minimum-record-length 256.
			      ':minimum-record-length-granularity 4))
      (setq *el-stream* (make-instance 'carry-output-el-stream
				       ':target-stream stream))
      (setq stream nil))
    (and stream (close stream ':abort))))


(defmethod (:write-sentinel carry-output-el-stream) ()
  nil)						;Don't write any.

(defflavor carry-input-el-stream ()
	   (si:embedded-length-character-input-stream)
  )

(defmethod (:collect-and-validate-sentinel carry-input-el-stream) ()
  t)						;Don't look for any.

;;kludge in case fix to e-l stuff didn't make it into the system
(defmethod (:discard-output-buffer carry-output-el-stream :after) (&rest ignore)
  (setq si:el-index 0))

(defconst *keywords*
	  ;;  inconvert      outconvert   props
	  '(((parse-number dec-print)
	     :VERSION :SEQUENCE :PART-SIZE :TAPE-SYSTEM-VERSION :RECORD-LENGTH :BYTE-SIZE)
	    ((time:parse-universal-time time-print)
	     :CREATION-DATE :TIME :DUMP-TIME :CONSOLIDATION-DATE)
	    ((parse-octal oct-print)
	     :UNIQUE-ID :PARTITION)
	    ((substring princ)
	     :PRELUDE :FILE :DIRECTORY :REEL :MAP-FILE-PATH :START-PATH :COMMENT
	     :USER-ID :MACHINE :END :DUMP-NAME :ERROR :TAPE-HOST :TAPE-DRIVE
	     :AUTHOR :DUMP-GROUP :HOST :DIRECTORY-NAME :CARRY-TAPE :PATHNAME
	     :NAME :TYPE :RAW-NAME :RAW-TYPE)
	    ((upkg-intern write-keyword)
	     :DELETED-FILES :RECORD-TYPE :DUMP-LIST-FOLLOWS :CANONICAL-TYPE :CHARACTERS
	     :SYSTEM-TYPE)))

(defun dec-print (x stream) (format stream "~D" x))
(defun oct-print (x stream) (format stream "~O" x))
(defun time-print (x stream)
  (time:print-universal-time x stream 0)	;GMT
  (princ " GMT" stream))
(defun write-keyword (symbol &optional (stream standard-output))
  (send stream :string-out (get-pname symbol)))

(defun print-plist (plist type stream)
  (scl:with-standard-io-environment
    (let ((cstream (si:thin-character-stream stream)))
      (when type
	(princ "RECORD-TYPE " cstream)
	(princ type cstream)
	(terpri cstream))
      (loop for (ind prop) on (cdr plist) by 'cddr
	    do (princ ind cstream)
	       (send cstream ':tyo #\SP)
	       (funcall (loop for ((nil printer) . props) in *keywords*
			      when (memq ind props)
				return printer
			      finally (return #'princ))
			prop cstream)
	       (terpri cstream))
      (princ "END" cstream)
      (terpri cstream))))

(defun write-prologue (file-lists)
  (print-plist
    `(nil :carry-tape ""
	  :version 1
	  :tape-system-version ,(si:get-system-version "tape")
	  :time ,(time:get-universal-time)
	  :machine ,si:local-host
	  :user-id ,user-id
	  :dump-list-follows ,(not (null file-lists))
	  :tape-host ,(send *stream* :host-name)
	  :tape-drive ,(send *stream* :unit))
    nil
    *stream*)
  (when file-lists
    (print-plist
      nil
      ':dump-list
      *stream*)
    (let ((cstream (si:thin-character-stream *stream*)))
      (loop for (spec) in file-lists
	    do (princ spec cstream)
	       (terpri cstream))
      (terpri cstream))))


(defun dump-file-opener (pathname plist)
  (let* ((canonical-type (send pathname ':canonical-type))
	 (characters
	   (cond ((symbolp canonical-type)
		  (null (get canonical-type ':binary-file-byte-size)))
		 (t ':default)))
	 (given-byte-size (get plist ':byte-size))
	 (byte-size (if characters		;t or ':default
			nil
			(get canonical-type ':binary-file-byte-size)))
	 (stream 
	   (open pathname
		 :direction :input
		 :characters characters
		 :byte-size byte-size
		 'fs:%return-binary-stream-for-character-file t)))
    (setq byte-size (cond ((send stream ':characters) nil)
			  ((null characters) byte-size)	;This is what we asked for.
			  ((send stream ':send-if-handles ':byte-size))
			  ;;Must be unknown canonical type, and binary. Might be
			  ;;36-bit QBIN lispm.init on TENEX, or maybe LMFS 8-bit
			  ;;binary dumper map.  We can trust LMFS byte-size as
			  ;;returned by directory-list, but can't trust TENEX.
			  ;;Take our chances.
			  ((null given-byte-size) 16.)
			  ;;If the server didn't know, he must have assumed 16.
			  ;;That wasn't LMFS or TENEX, obviously, so we won.
			  ((> given-byte-size 16.) 16.)
			  ;;"All files of 16 bits and over now ARE 16 bits!" -W. Allen
			  (t given-byte-size)))
    (values stream byte-size)))

(defmacro putprop-if (plist property indicator &environment env)
  (once-only (property &environment env)	;This is why putprop-if exists.
    `(if ,property (putprop ,plist ,property ,indicator))))

(defun dump-one-file (spec pathname plist report-stream &aux byte-size)
  (catch-error-restart (fs:file-lookup-error "Skip dumping ~A" pathname)
    (with-open-stream (file (multiple-value (nil byte-size)
			      (dump-file-opener pathname plist)))
      ;;(setq pathname (send file ':truename)) ;had better be defaulted.
      ;;and we want to preserve logicalness.
      (when report-stream
	(format report-stream "~&Dumping ~A~:[~; ~:[(~D-bit bytes)~;(binary)~*~]~]"
		pathname byte-size (and byte-size (= byte-size 16.)) byte-size))
      (let* ((host (send pathname ':host))
	     (out-plist
	       `(nil
		  :characters
		  ,(cl:subtypep (fs:%file-stream-file-element-type file) 'character)
		  :name ,(send pathname ':name)
		  :raw-name ,(send pathname ':raw-name)
		  :pathname ,(if (typep pathname 'fs:logical-pathname)
				 (let* ((string-for-printing
					  (send pathname ':string-for-printing))
					(colonx (string-search-char #/: string-for-printing)))
				   (if colonx
				       (substring string-for-printing (1+ colonx))
				       (send pathname ':string-for-printing)))
				 (send pathname ':string-for-host))
		  :directory ,(send pathname ':string-for-directory)
		  :host ,(send host ':name)
		  :system-type ,(send host ':system-type)
		  :dump-group ,spec)))
	(let ((type (send pathname ':raw-type))
	      (version (send pathname ':version)))
	  (unless (memq type '(nil :unspecific))
	    (putprop out-plist type ':raw-type)
	    (putprop out-plist (send pathname ':type) ':type))
	  (when (numberp version)
	    (putprop out-plist version ':version)))
	(putprop-if out-plist (get plist ':author) ':author)
	(putprop-if out-plist (get plist ':creation-date) ':creation-date)
	(putprop-if out-plist byte-size ':byte-size)
	(putprop-if out-plist (let ((ct (send pathname ':canonical-type)))
				(and (symbolp ct) ct))
		    ':canonical-type)
	(putprop-if out-plist (get plist :length-in-bytes) :length-in-bytes)
	;;That should be enough information about the file.
	(print-plist out-plist ':file *stream*)
	(send *el-stream* ':discard-current-output-buffer)
	(cond ((null byte-size)
	       (using-resource (stream si:epsilon-encoding-output-stream *el-stream*)
		 (stream-copy-until-eof file stream)))
	      ((> byte-size 8)
	       (fs:stream-copy-16-to-8 file *el-stream*))
	      (t
	       (stream-copy-until-eof file *el-stream*)))
	(send *el-stream* ':eof)
	(send *stream* ':eof)))))

(defmacro list-prop-if ((plist ind var) &body body)
  `(let ((,var (get ,plist ,ind)))
     (when ,var . ,body)))

(defun carry-list (&key device tape-host density reel (report-stream t) (verify nil) verbose)
  (when (eq report-stream t)
    (setq report-stream standard-output))
  (with-open-stream (*stream*
		      (tape:make-stream
			:device device
			':host tape-host
			':reel reel
			':density density
			':record-length 8192.
			':direction ':input))
    (let ((first-line (readline (si:thin-character-stream *stream*))))
      (unless (string-search "carry-tape" first-line)
	(ferror "This is not a carry tape.")))
    (send *stream* ':rewind)
    (let ((plist (read-tape-plist *stream*)))
      (list-prop-if (plist ':user-id user)
	(format report-stream "~&Carry dump made by ~A." user))
      (list-prop-if (plist ':time time)
	(format report-stream "~&Dump taken at ~\time\." time))
      (list-prop-if (plist ':machine machine)
	(format report-stream "~&Dumped on machine ~A." machine))
      (when (get plist ':dump-list-follows)
	(let ((plist (read-tape-plist *stream*)))
	  (unless (eq (get plist ':record-type) ':dump-list)
	    (ferror "List of items dumped missing from tape.")))
	(format report-stream "~&Files according to the following specifications were dumped:")
	(loop for line = (readline (si:thin-character-stream *stream*))
	      when (or (null line) (equal line "")) return nil
	      do (format report-stream "~&~A" line))
	(format report-stream "~&-----~%")))
    (send *stream* ':skip-file)
    (let ((*el-stream* (make-instance 'carry-input-el-stream :target-stream *stream*)))
      (list-files-on-tape *stream* report-stream verify verbose))))

(defun list-files-on-tape (stream report-stream verify verbose)
  (let ((n-ok 0)
	(n-bad 0)
	(n-file-short 0)
	(n-tape-short 0)
	(n-miscompared 0)
	(n-missing 0))
    (condition-case ()
	 (loop for plist = (read-tape-plist stream)
	       do (selectq (get plist ':record-type)
		    (:file
		     (format report-stream "~&File ~A:~A~&"
			     (get plist ':host) (get plist ':pathname))
		     (when verbose
		       (loop for (indicator value) on (cdr plist) by #'cddr
			     unless (memq indicator '(:host :pathname :dump-group :record-type))
			       do (format report-stream "~& ~A: ~A~&" indicator value)))
		     (when verify
		       (cl:ecase (verify-one-file plist *el-stream* report-stream)
			 (:compared     (incf n-ok))
			 (:file-short   (incf n-file-short)  (incf n-bad))
			 (:tape-short   (incf n-tape-short)  (incf n-bad))
			 (:file-missing (incf n-missing)     (incf n-bad))
			 (:miscompared  (incf n-miscompared) (incf n-bad))
			 )))
		    (:end-of-tape (format report-stream "~&-----~%End of data dumped.~&")
		     (return nil)))
		  (send stream ':skip-file))
       (end-of-tape (format report-stream " (Incomplete file)")))
    (when verify
      (if (zerop n-bad)
	  (format report-stream "~&All files compared correctly.~&")
	  (format report-stream "~&~D file~:P compared correctly,~@
           ~D file~:P had different data,~@
           ~D file~:P ~:*~[were~;was~:;were~] missing on disk,~@
           ~D file~:P ~:*~[were~;was~:;were~] shorter on disk than tape ~
                    (but compared up to end of the disk version),~@
           ~D file~:P ~:*~[were~;was~:;were~] longer on disk than on tape ~
                    (but compared up to end of the tape version).~&"
		  n-ok n-miscompared n-missing n-file-short n-tape-short)))
    ))

(defun read-tape-plist (stream)
  (let ((char-stream (si:thin-character-stream stream)) (ch (send stream ':tyi)))
    (cond ((null ch)
	   '(nil :record-type :end-of-tape))
	  (t (send stream ':untyi ch)
	     (cons nil
		   (loop for line = (readline char-stream)
			 until (equal line "END")
			 nconc (inconvert-prop-line line)))))))

(defun inconvert-prop-line (line)
  (let ((spacex (string-search-char #\SP line))
	sym converter)
    (loop for ((reader) . props) in *keywords*
	  thereis
	  (loop for ind in props
		when (string-equal line ind 0 0 spacex)
		return (setq sym ind converter reader)))
    (when (null sym)
      (setq sym (upkg-intern line 0 spacex))	;should almost never happen
      (setq converter #'substring))
    (cond ((null spacex)
	   (list sym ""))
	  (t (list sym (funcall converter line (1+ spacex) nil))))))

(defun parse-octal (string &optional (start 0) end)
  (parse-number string start end 8. t))

(defun upkg-intern (string &optional (start 0) end)
  (let ((substr (substring string start end)))
    (selector substr string-equal
      ("T" 't)
      ("NIL" 'nil)
      (otherwise
	(si:intern1 substr pkg-keyword-package)))))

(defvar *spec-alist* nil)
(defvar *host-dir-alist* nil)

(defun carry-load (&key tape-host density device reel (report-stream t) (if-exists :error))
  (when (eq report-stream t)
    (setq report-stream standard-output))
  (with-open-stream (*stream*
		      (tape:make-stream
			':device device
			':host tape-host
			':reel reel
			':density density
			':record-length 8192.
			':direction ':input))
    (let ((first-line (readline (si:thin-character-stream *stream*))))
      (unless (string-search "carry-tape" first-line)
	(ferror "This is not a carry tape.")))
    (send *stream* ':rewind)
    (let ((plist (read-tape-plist *stream*))
	  (*spec-alist* nil)
	  (*host-dir-alist* nil))
      (when report-stream
	(list-prop-if (plist ':user-id user)
	  (format report-stream "~&Carry dump made by ~A." user))
	(list-prop-if (plist ':time time)
	  (format report-stream "~&Dump taken at ~\time\." time))
	(list-prop-if (plist ':machine machine)
	  (format report-stream "~&Dumped on machine ~A." machine)))
      (when (get plist ':dump-list-follows)
	(let ((plist (read-tape-plist *stream*)))
	  (unless (eq (get plist ':record-type) ':dump-list)
	    (ferror "List of items dumped missing from tape.")))
	(select-load-list))		
      (send *stream* ':skip-file)
      (unless (eq *spec-alist* ':abort)
	(let ((*el-stream* (make-instance 'carry-input-el-stream ':target-stream *stream*)))
	  (load-files-on-tape *stream* :if-exists if-exists))))))
  
(defun load-files-on-tape (stream &key (if-exists :error))
  (condition-case ()
      (loop for plist = (read-tape-plist stream)
	    for read-eof = nil
	    do (selectq (get plist ':record-type)
		 (:file (let ((pathname (carry-load-target-pathname plist)))
			  (if pathname
			      (condition-case ()
				  (carry-load-file pathname plist :if-exists if-exists)
				(sys:end-of-file
				  (setq read-eof t)
				  (send stream ':clear-eof)
				  (format
				    error-output
				    "~&Unexpected end of data on tape in middle of file."
				    ))))))
		 (:end-of-tape (return nil)))
	    (unless read-eof (send stream ':skip-file)))
    (tape:end-of-tape
      (format error-output "~&Unexpected physical end of tape encountered."))
    (:no-error 
     (format t "~&End of data on tape."))))

(defun carry-load-file (pathname plist &key (if-exists :error))
  (catch 'skip-file
    (let ((byte-size (get plist ':byte-size)))
      (with-open-stream (stream (carry-load-file-opener pathname plist :if-exists if-exists))
	(format t "~&Loading ~A:~A into ~A ~:[~; ~:[(~D-bit bytes)~;(binary)~*~]~] ..."
		(get plist ':host) (get plist ':pathname)
		(send stream ':truename)
		byte-size (and byte-size (= byte-size 16.)) byte-size)
	(send *el-stream* ':establish-initial-condition)
	(funcall
	  (if (and byte-size (> byte-size 8.))
	      #'fs:stream-copy-8-to-16
	      #'stream-copy-until-eof)
	  *el-stream*
	  stream)
	(send *el-stream* ':discard-current-input-buffer)
	(send stream ':eof)
	(fs:copy-author-and-creation-date
	  stream (get plist ':author) (get plist ':creation-date)))
      (format t " Loaded."))))

;;files bigger than this are slow for LMFS anyway
(defvar *default-carry-load-estimated-length* (* 1 1024 1024 1024))

(defun carry-load-file-opener (pathname plist &key (if-exists :error))
  (with-stack-list (other-args ':direction ':output
			       'fs:%return-binary-stream-for-character-file t
			       ':characters (get plist ':characters)
			       ':byte-size (get plist ':byte-size)
			       ;;older versions of carry didn't put length in plist, so
			       ;;need to default for large files
			       :estimated-length (or (get plist :length-in-bytes)
						     *default-carry-load-estimated-length*)
			       :if-exists (if (eq if-exists :skip) :error if-exists))
    (error-restart-loop (error "Retry OPEN for carry load of ~A" pathname)
      (*catch 'load-file-open-retry
	(condition-case (err)
	    (return (lexpr-funcall #'open pathname other-args))
	  (fs:directory-not-found
	    (format error-output "~&~A" err)
	    (if (carry-load-directory-create-p pathname)
		(*throw 'load-file-open-retry nil))
	    (setq pathname (carry-load-new-pathname pathname plist err)))
	  (fs:file-already-exists
	    (cl:ecase if-exists
	      (:error (setq pathname (carry-load-new-pathname pathname plist err)))
	      (:skip (format error-output "~&~A" err)
		     (throw 'skip-file t))))
	  (fs:file-operation-failure
	    (setq pathname (carry-load-new-pathname pathname plist err))))))))

(defun carry-load-new-pathname (pathname plist err)
  (let ((new-pathname (fs:prompt-for-new-pathname pathname err 'open)))
    (unless (and (eq (send pathname ':host) (send new-pathname ':host))
		 (equal (send pathname ':directory) (send new-pathname ':directory)))
      (let ((elem (assoc (list (get plist ':host) (get plist ':directory))
			 *host-dir-alist*)))
	(when elem
	  (when (fquery nil "Do you want me to change the default directory for all~@
			    files from ~A on ~A to be ~A on ~A? "
			(get plist ':directory) (get plist ':host)
			(send new-pathname ':string-for-directory)
			(send new-pathname ':host))
	    (cond ((typep (cadr elem) 'fs:pathname)
		   (setf (cadr elem) new-pathname))
		  ((memq (car (cadr elem)) '(:default :auto-default))
		   (setf (cadr (cadr elem)) new-pathname))
		  (t (ferror "Don't understand list element ~S" elem)))))))
    new-pathname))

(defun carry-load-directory-create-p (path)
  (and (fquery nil "Shall I attempt to create the directory ~A:~A? "
	       (send (send path ':host) ':name-as-file-computer)
	       (send path ':string-for-directory))
       (fs:create-directories-recursively path)))

(defun select-load-list ()
  (let ((items
	  (loop for line = (readline (si:thin-character-stream *stream*))
		until (or (null line) (equal line ""))
		collect line)))
    (cond ((= (length items) 1)
	   (format query-io "~&Dumped: ~A" (car items))
	   (push (list (car items) t) *spec-alist*))
	  (t (format query-io "~&The following groups of files were dumped:")
	     (dolist (item items) (format query-io "~&~A" item))
	     (format query-io "~&-----~%")
	     (selectq (fquery
		       '(:choices
			 (((t "Yes") #/Y #\SP)
			  ((:query "Query for each group") #/Q)
			  ((:menu "Menu of groups") #/M))
			 :help-function select-load-list-help)
		       "Load all these files? (‘ to get out) ")
	       ((t) (setq *spec-alist* (copytree '((:wild t)))))
	       (:query
		(loop for iteml on items
		      for (item) = iteml
		      as choice =
		      (fquery
			'(:choices
			  (((nil "No (Don't load the group)") #/N)
			   ((t "Yes (Load the group)") #/Y #\SP)
			   ((:proceed
			     "Proceed (Load this and all succeeding groups)") #/P)))
			"Load group ~A? " item)
		      when (eq choice ':proceed)
		      return (loop for item in iteml
				   do (push `(,item t) *spec-alist*))
		      do (push `(,item ,choice) *spec-alist*)))
	       (:menu
		(loop for (item . (choice))
		      in
		      (tv:multiple-choose
			"Groups to be loaded"
			(loop for item in items
			      collect `(,item ,item ((:load t) :skip)))
			(copytree		;RPLACATION GOING ON HERE!!!...
			  '((:load "Load" nil t (:skip) nil)
			    (:skip "Skip" nil t (:load) nil))))
		      do (push (list item
				     (cdr (assq choice
						'((:load . t) (:skip . nil)))))
			       *spec-alist*))))))
    (if (null *spec-alist*) (setq *spec-alist* ':abort))))

(defun select-load-list-help (stream &rest ignore)
  (format stream "~&Y   (or SP) Load all the files on the tape.  You will be queried~@
		  ~4@Tabout each file, and more options will be offered then.~@
		  Q   Query about whether or not to load each of the dumped groups of~@
		  ~4@Tfiles.  We will ask you now about these groups, but you will still~@
		  ~4@Tbe offered options for each file in the groups you choose to load.~@
		  M   Same as Q, but with a menu instead of queries.~&"))

(defun carry-load-target-pathname (plist)
  (let* ((group (get plist ':dump-group))
	 (group-action	 
	  (or (cadr (assoc group *spec-alist*))
	      (cadr (assq ':wild *spec-alist*)))))
    (when group-action
      (let* ((host (get plist ':host))
	     (dir (get plist ':directory))
	     (elem (list host dir))			;We don't dump devices yet.
	     (action (cadr (assoc elem *host-dir-alist*)))
	     (default
	       (cond ((typep action 'fs:pathname)	;Not really used.
		      (carry-load-translate-pathname plist action))
		     ;;other choices here will be everything-in-one-place, hierarchical, etc.
		     ((or (null action)
			  (and (listp action) (memq (car action) '(:default :auto-default))))
		      (when (null action)
			1;; The default pathname when we don't know any better is the
			;; dumped pathname on the default host.  This doesn't
			;; translate pathnames between operating systems, but neither
			;; does the "Other Host" option below.
0			(setq action (list ':default (fs:default-pathname (get plist :pathname))))
			(push (list elem action) *host-dir-alist*))
		      (carry-load-translate-pathname plist (cadr action))))))
	(cond ((eq (car action) ':auto-default)
	       default)
	      (t
	       (let ((*carry-load-default* default)
		     (*carry-load-plist* plist))
		 (declare (special *carry-load-default* *carry-load-plist*))
		 (selectq
		   (fquery '(:choices
			     (((t "Yes") #/Y #\SP)
			      ((nil "No") #/N)
			      ((:other "Other place") #/O)
			      ((:host "Other host") #/H)
			      ((:accept "Accept this default for this directory") #/A))
			     :help-function carry-load-help)
			   "Load ~A:~A into ~A? "
			   (get plist ':host)
			   (get plist ':pathname)
			   default)
		   (nil nil)
		   ((t) default)
		   (:accept (setf (car action) ':auto-default) default)
		   (:proceed (push `(,group t) *spec-alist*) t)
		   (:host
		    (let* ((system-type (get plist :system-type))
			   (host (let ((defhost (get plist :host)))
				   (flet ((host-okay (host)
					    (eq (send host :system-type) system-type)))
				     (accept `((and fs:pathname-host
						    ((cl:satisfies ,#'host-okay)))
					       :description ,(format () "A ~A host"
								     system-type))
					     :prompt `("Host to use for ~A" ,defhost)
					     :default (block something
							(condition-case (host)
							     (fs:get-pathname-host defhost)
							   (fs:unknown-pathname-host )
							   (:no-error
							     (when (host-okay host)
							       (return-from something host))))
							(let ((lhost fs:user-login-machine))
							  (when (host-okay lhost)
							    lhost))))))))
		      ;; Host must be of the same system type.  Therefore parse the
		      ;; directory on the dumped host with regard to the new host to get
		      ;; the new default.  Of course, we're not really supposed to parse
		      ;; :string-for-directory's.
		      (setq default (fs:parse-pathname
				      (cl:case system-type
					(:lispm
					  (string-append (get plist :directory) ">"))
					((:unix :unix42)
					  (string-append (get plist :directory) "//"))
					(otherwise (get plist :directory)))
				      host))
		      (setq default (carry-load-translate-pathname plist default))
		      (setf (second action) default)
		      default))
		   (:other
		    (setq default (accept 'fs:pathname
					  :prompt `("New pathname for ~A:~A~%~2@T"
						    ,host ,(get plist ':pathname))
					  :default default))
		    (setf (second action) default)
		    default)))))))))

(defun carry-load-help (stream &rest ignore)
  (declare (special *carry-load-default* *carry-load-plist*))
  (let* ((path (get *carry-load-plist* ':pathname))
	 (target *carry-load-default*)
	 (target-dir (format nil "~A:~A"
			     (send (send target ':host) ':name-as-file-computer)
			     (send target ':string-for-directory)))
	 (host (get *carry-load-plist* ':host))
	 (system-type (get *carry-load-plist* ':system-type))
	 (stuff (format nil "files from ~A on ~A"
			(get *carry-load-plist* ':directory)
			host)))
    
    (format stream
	    "~&Y   (or SP) Load ~A into ~A.~%~4@T~A will remain the default for ~A.~@
	     N   Do not load ~A.~%~4@T~A will remain the default for ~A.~@
	     O   Prompt for another place in which to put ~A.~@
	     ~4@tThe directory portion of that pathname will then be~@
	     ~4@Tthe new default for ~A.~@
	     H   Prompt for another host to correspond to ~A.~@
	     ~@4TThe host must be of the same system type (~A).~@
             ~@4TThe same directory as on the original host will be used on this host.~@
	     A   Load ~A into ~A,~%~4@Tand then load all further ~A into ~A without asking.~&"
	    path target target-dir stuff
	    path target-dir stuff
	    path stuff
	    host system-type
	    path target stuff target-dir)))

(defun carry-load-translate-pathname (plist default)
  (let ((ostype (get plist ':system-type))
	(target-ostype (send (send default ':host) ':system-type)))
    (cond ((eq ostype target-ostype)
	   (send default ':new-pathname
		 ':raw-name (get plist ':raw-name)
		 ':raw-type (or (get plist ':raw-type) ':unspecific)
		 ':version (or (get plist ':version) ':newest)))
	  (t
	   (send default ':new-pathname
		 ':name (get plist ':name)
		 ':canonical-type (or (get plist ':canonical-type)
				      (get plist ':type)
				      "")
		 ':version (or (get plist ':version)
			       ':newest))))))

(defun verify-one-file (plist tape-stream report-stream)
  (let (disposition)
    (send tape:*el-stream* :establish-initial-condition)
    (unless (eq tape-stream tape:*el-stream*)
      (format t "~&Stream is unexpectedly ~A instead of ~A" tape-stream tape:*el-stream*))
    (unwind-protect
	(with-open-file-case (file-stream (format nil "~A:~A"
						  (get plist :host) (get plist :pathname))
					  'fs:%return-binary-stream-for-character-file t
					  :characters (get plist :characters)
					  :byte-size (get plist :byte-size)
					  )
	  (fs:file-lookup-error
	    (setq disposition :file-missing)
	    (format report-stream "~&*** Could not get file for comparison: ~~A~" file-stream))
	  (:no-error
	    (multiple-value-bind (ok? why-bad)
		(compare-streams file-stream tape-stream report-stream (> (get plist :byte-size) 8))
	      (setq disposition (if ok? :compared why-bad))
	      )))
      (send tape:*el-stream* :discard-current-input-buffer))
    disposition
    ))

(defun compare-streams (file-stream tape-stream report-stream file-is-16b?)
  (declare (values ok? why-bad 8bbyte-disp file-8bbyte tape-8bbyte))
  (let* ((null-buffer "")
	 file-eof-seen? tape-eof-seen?
	 (file-buffer null-buffer) file-start file-limit
	 (tape-buffer null-buffer) tape-start tape-limit
	 16b-extra-byte
	 (even t)
	 )
    (declare (sys:array-register file-buffer tape-buffer))
    (macrolet ((advance-file ()
		 `(progn
		    (cl:multiple-value-setq (file-buffer file-start file-limit)
		      (send file-stream :read-input-buffer))
		    (unless file-buffer
		      (setq file-eof-seen? t))))
	       (advance-tape ()
		 `(progn (cl:multiple-value-setq (tape-buffer tape-start tape-limit)
			   (condition-case (err)
				(send tape-stream :read-input-buffer)
			      ((tape::end-of-file tape:tape-error)
			       (format report-stream "~&Compare got error: ~A~&"
				       (send err :report-string))
			       nil)))
			 (unless tape-buffer
			   (setq tape-eof-seen? t)))))
      (loop named outer
	    with done
	    until done
	    with file-shift = (if file-is-16b? 1 0)
	    with byte-disp = 0
	    do (unless (eq (evenp byte-disp) even)
		 (error "Out of synch"))
	    do (when (eq tape-buffer null-buffer)
		 (advance-tape))
	       (when (eq file-buffer null-buffer)
		 (advance-file))
	       (cond ((and file-eof-seen? tape-eof-seen?)
		      (return t))
		     (file-eof-seen?
		      (format report-stream "~&*** Disk file ends before tape file at ~D.~&"
			      byte-disp)
		      (return (values nil :file-short)))
		     (tape-eof-seen?
		      (format report-stream "~&*** Tape file ends before disk file at ~D.~&"
			      byte-disp)
		      (return (values nil :tape-short)))
		     (16b-extra-byte
		      (unless (= 16b-extra-byte (aref tape-buffer tape-start))
			(return nil))
		      (setq even (not even))
		      (incf byte-disp)
		      (setq 16b-extra-byte nil)
		      (incf tape-start)		;compare from next byte
		      (when ( tape-start tape-limit)
			(send tape-stream :advance-input-buffer)
			(advance-tape))
		      (incf file-start)		;compare from next 16b byte too
		      (when ( file-start file-limit)
			(send file-stream :advance-input-buffer)
			(advance-file)))
		     (t (let ((bytes-to-compare
				(min (ash (- file-limit file-start) file-shift)
				     (- tape-limit tape-start))))
			  (loop with tape = tape-start
				with file = file-start
				with 16b-byte
				repeat bytes-to-compare
				for tape-byte = (aref tape-buffer tape)
				for file-byte = (if file-is-16b?
						    (if even
							(ldb (byte 8 0)
							     (setq 16b-byte (aref file-buffer file)))
							(ldb (byte 8 8) 16b-byte))
						    (aref file-buffer file))
				do (incf tape)
				   (if file-is-16b?
				       (when (not even)
					 (incf file))
				       (incf file))
				   (setq even (not even))
				unless (eql tape-byte file-byte)
				  do (format report-stream
					     "~&*** Files differ starting at byte ~D:  tape has ~D and file has ~D.~&"
					     byte-disp tape-byte file-byte)
				     (return-from outer (values nil :miscompared
								byte-disp file-byte tape-byte))
				do (incf byte-disp)
				finally (when (and file-is-16b? (not even))
					  (setq 16b-extra-byte
						(ldb (byte 8 8) 16b-byte)))
					(setq file-start file
					      tape-start tape))
			  (when ( tape-start tape-limit)
			    (send tape-stream :advance-input-buffer)
			    (setq tape-buffer null-buffer))
			  (when ( file-start file-limit)
			    (send file-stream :advance-input-buffer)
			    (setq file-buffer null-buffer)))))
	    finally (return (values nil :fell-off-loop))))
    ) )

(cp:define-command (com-write-carry-tape :command-table "Tape Administration")
    ((files '((cl:sequence fs:pathname)))
     &key
     (since '((time:universal-time) :past-p t) :documentation "Dump files newer than date")
     (author '((cl:sequence string)) :documentation "Dump files written by specific user(s)")
     (tape-spec 'tape-spec)
     (query 'boolean :default t :documentation "Ask before dumping")
     (verify 'boolean :default nil :mentioned-default t
	     :documentation "Compare tape after dumping"))
   (if tape-spec
       (carry-dump files :since since :author author
			 :query query :verify verify
			 :tape-host (send tape-spec :host)
			 :device (send tape-spec :device)
			 :density (send tape-spec :density)
			 :reel (send tape-spec :reel)
			 )
       (carry-dump files :since since :author author
			 :query query :verify verify
			 )))

(cp:define-command (com-read-carry-tape :command-table "Tape Administration")
    (&key (tape-spec 'tape-spec)
	  (if-exists '((cl:member :error :skip :supersede)) :default :skip))
   (if tape-spec
       (carry-load :tape-host (send tape-spec :host)
		   :device (send tape-spec :device)
		   :density (send tape-spec :density)
		   :reel (send tape-spec :reel)
		   :if-exists if-exists)
       (carry-load :if-exists if-exists)))

(cp:define-command (com-show-carry-tape :command-table "Tape Administration")
    (&key (tape-spec 'tape-spec)
	  (verify 'boolean :default nil :mentioned-default t
		  :documentation "Compare tape with file system"))
   (if tape-spec
       (carry-list :tape-host (send tape-spec :host)
		   :device (send tape-spec :device)
		   :density (send tape-spec :density)
		   :reel (send tape-spec :reel)
		   :verify verify)
       (carry-list :verify verify
		   )))
