;-*- Mode:LISP; Lowercase:yes; Syntax: Common-lisp; Package: COMMON-LISP-INTERNALS -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
;;;>

D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (:SWISS :BOLD :SMALL) "HL10B");;;; Parameters.

0(defparameter (2 0 (NIL 0) (:FIX :BOLD :NORMAL) "CPTFONTCB")TAR-TBLOCK0 512.)

1; This is correct, but makes the buffer too large for the Unibus map.
0(defparameter 2TAR-NBLOCK0 20.)

(defparameter 2TAR-NAME-SIZE0 100.)

(lmfs:defstorage (tar-header :constructor)
  (name char 100.)
  (mode char 8.)
  (uid char 8.)
  (gid char 8.)
  (size char 11.)
  (ignore char 1)
  (mtime char 12.)
  (chksum char 8.)
  (linkflag char 1)
  (linkname char 100.)
  (ignore char 255.))

1;;;; Utilities used by both sides.

0(defun heuristicate (pathname)
	   1;; &&& NOTE THAT THIS CAN ONLY WORK IF THE SOURCE FILE IS
0	   1;; &&& A LMFS FILE---NFS ALWAYS CLAIMS IT'S A CHARACTER FILE.
0	   1;; Slow but fairly sure.  This would be better if we could always
0	   1;; open the file in :DEFAULT mode and then just leave it open and
0	   1;; use that stream both to ask and to read, but the modularity of
0	   1;; doing that and still allowing a user query instead is hairy, so
0	   1;; we'll be inefficient and open it just to get that info, then close it.
0	   1;; Note that this is useful only when READING the file (e.g., WRITING
0	   1;; the tarfile), since it depends on the file existing, rather than
0	   1;; trying to figure out something from the file's name.
0	   (with-open-file (stream pathname
				   :direction :input
				   :element-type :default
				   :preserve-dates t)
	     (fs:%file-stream-file-element-type stream)))

(defun (3 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")TEXT-OR-BINARY?0 (mode pathname &optional for-output)
  (declare (values open-with-this-element-type translate-characters?))
  (flet ()
    (cl:ecase mode
      (:text
	(values 'cl:string-char
		t))
      (:binary
	(if for-output
	    (values '(cl:unsigned-byte 8)
		    nil)
	  1;; Unfortunately, we have to heuristicate even here, because we
0	  1;; might be handed a 16B binary file on a LMFS.  If we get something
0	  1;; that claims to be a character file, however, just ignore it and assume
0	  1;; that it's an 8B file.  We do this because NFS always claims to return
0	  1;; character files (*sigh*).
0	  (let* ((element-type (heuristicate pathname))
		 (returned-element-type
		   (if (eq element-type 'scl:character)
		       '(cl:unsigned-byte 8)
		     element-type)))
	    (values returned-element-type
		    nil))))
      (:query
	(setf mode (fquery '(:choices (((:text "Text.") #\T #\C)	1; Text or Character.
0				       ((:binary "Binary.") #\B))
			     :list-choices nil
			     :no-input-save t)
			   "Text or binary mode for ~A? "
			   pathname))
	(text-or-binary? mode pathname for-output))
      (:heuristicate
	(if for-output
	    (values '(cl:unsigned-byte 8)
		    nil)
	  (let ((element-type (heuristicate pathname)))
	    (if (eq element-type 'scl:character)
		(values 'cl:string-char
			t)
	      (values element-type
		      nil))))))))

(defun 2FILL-IN-CHECKSUM0 (header)
  1;; Is avoiding built-in field-length constants so bad?
0  (stack-let ((spaces (cl:make-array (cl:length (tar-header-chksum header))
				     :element-type 'cl:string-char
				     :initial-element #\space)))
    (setf (tar-header-chksum header) spaces))
  (let ((checksum (loop for x being the array-elements of header sum x)))
    (setf (tar-header-chksum header)
	  (unixify-string (format nil "~7O" checksum)))))

(defun 2VALIDATE-CHECKSUM0 (header)
  (let ((checksum (unix-octal (tar-header-chksum header))))
    (unless (numberp checksum)
      (error "Could not parse the checksum from the file header."))
    (fill-in-checksum header)
    (unless (= checksum (unix-octal (tar-header-chksum header)))
      (format *error-output* "~&Warning: The checksum in the header does not match the recomputed checksum.~@
                                Tape = ~A, computed = ~A"
	      checksum
	      (unix-octal (tar-header-chksum header))))))

(defun 2UNIX-STRING0 (s)
  (let ((zfind (string-search-char (code-char #o0) s)))
    (if zfind (substring s 0 zfind) s)))

(defun 2UNIX-OCTAL0 (s)
  (zl:parse-number (string-trim " " s) 0 nil 8.))

(defun 2UNIXIFY-STRING0 (s)
  (let ((new-string (cl:make-string (1+ (cl:length s))
				    :element-type 'cl:string-char
				    :initial-element (code-char 0))))
    (cl:replace new-string s)
    new-string))

(defvar 2*UNIX-TIME-ORIGIN*0 (time:parse-universal-time "01/01/1970 00:00 GMT"))

(defun 2UT->UNIX-TIME0 (ut)
  (- ut *unix-time-origin*))

(defun 2UNIX-TIME->UT0 (unix-time)
  (+ unix-time *unix-time-origin*))

1;;; Why does this always seem to be different each time?  The system's ASCII-translating-mixin
;;; looks for CR/LF pairs and discards the LFs.  The TAR tape comes just with LFs, so we have to
;;; roll our own.
0(defun 2ASCII-TO-LISPM-CHARACTER-CONVERT0 (string start end)
  (let ((string string))
    (declare (sys:array-register string))
    (loop for i from start below end
	  for ch = (aref string i)
	  for code = (char-code ch)
	  do
      (when (< code #o40)
	(cl:case code
	  1;; I'm not seeing a CR/LF sequence, just LF, so convert them to Return.
0	  (#o12 (setf (aref string i) #\return))
	  (otherwise (setf (aref string i) (ascii-to-char code))))))
    string))

1;;; Substitute just LF for Return.
0(defun 2LISPM-TO-ASCII-CHARACTER-CONVERT0 (string start end)
  (let ((string string))
    (declare (sys:array-register string))
    (loop for i from start below end
	  for ch = (aref string i)
	  do
      (cl:case ch
	(#\return (setf (aref string i) (code-char (ascii-code "lf"))))
	(otherwise (setf (aref string i) (code-char (char-to-ascii ch))))))
    string))

(defun 2PARSE-UNIX-PATHNAME-STRING0 (s)		1; List of components, and absolute-flag.
0  (let ((sindex 0)
	(answer nil)
	(absflag nil)
	(slength (string-length s)))
    (do () ((not (char-equal #\/ (aref s sindex))))
      (setf absflag t)
      (incf sindex))
    (do () (( sindex slength))
      (let ((slashx (string-search-char #\/ s :start sindex)))
	(if (null slashx)
	    (return (push (substring s sindex) answer)))
	(push (substring s sindex slashx) answer)
	(setf sindex (1+ slashx))))
    (values (nreverse answer)
	    absflag
	    (char-equal #\/ (aref s (1- slength))))))

1;;;; Reading.

0(defun 2READ-TAR-TAPE0 (dirpath &key
		      (mode :query) function-name
		      (reroot-absolute-pathnames :unspecified))
  1;; Heuristication only works when writing a tarfile from already-existing files.
0  (zl:check-arg mode (member mode '(:text :binary :query))
		"one of :TEXT, :BINARY, or :QUERY")
  1;; Now do the work.
0  (read-tar-generic dirpath
		    #'tape:make-stream `(:record-length ,(* tar-tblock tar-nblock 2))
		    :mode mode :function-name function-name
		    :reroot-absolute-pathnames reroot-absolute-pathnames)
  (values))

(defun 2READ-TAR-FILE0 (dirpath tar-file-path &key
		      (mode :query)
		      (reroot-absolute-pathnames :unspecified)
		      (compressed? nil)
		      function-name
		      )
  1;; Heuristication only works when writing a tarfile from already-existing files.
0  (zl:check-arg mode (member mode '(:text :binary :query :function))
		"one of :TEXT, :BINARY, :QUERY or :FUNCTION")
  1;; Now do the work.
0  (if compressed?
      (with-open-file (8stream tar-file-path :element-type '(unsigned-byte 8))
	(read-tar-generic dirpath 'decompressing-8b-stream (list 8stream)
			  :mode mode :function-name function-name
			  :reroot-absolute-pathnames reroot-absolute-pathnames))
      (read-tar-generic dirpath #'open `(,tar-file-path :element-type (cl:unsigned-byte 8))
			:mode mode :function-name function-name
			:reroot-absolute-pathnames reroot-absolute-pathnames))
  (values))

(defun 2READ-TAR-GENERIC0 (dirpath stream-fcn stream-args &key
			 (mode :query) (function-name nil)
			 (reroot-absolute-pathnames :unspecified))
  1;; Heuristication only works when writing a tarfile from already-existing files.
0  (zl:check-arg mode (member mode '(:text :binary :query :function))
		"one of :TEXT, :BINARY, :QUERY or :FUNCTION")
  (when (and (eql mode :function)
	     (null function-name))
    (error "Function-name not specified"))
  1;; Now do the work.
0  (let ((dir (send (fs:merge-pathnames dirpath) :new-pathname
		   :name nil :type nil :version nil))
	(hbuf (make-tar-header)))
    (condition-case ()
	 (open dir :direction :probe-directory :error t)
       (fs:file-lookup-error
	 (if (cl:y-or-n-p
	       "Directory ~A:~A doesn't exist.  Create it? "
	       (send (send dir :host) :name-as-file-computer)
	       (send dir :string-for-directory))
	     (fs:create-directories-recursively dir))))
    (with-open-stream (8stream (apply stream-fcn stream-args))
      (loop finally (format t "~&End of TAR input.")
	    do
	(condition-case ()
	     1;; Read a header block.
0	     (send 8stream :string-in "End of File" hbuf 0 tar-tblock)
	   (sys:end-of-file (loop-finish)))
	(if (zerop (aref hbuf 0)) (loop-finish))
	(validate-checksum hbuf)
	(multiple-value-bind (parsed absolute-p dirp)
	    (parse-unix-pathname-string (unix-string (tar-header-name hbuf)))
	  1;; Flush the "." component.  Relative pathnames are merged against DIRPATH.
0	  (when (string-equal (first parsed) ".")
	    (pop parsed))
	  1;; --- When can this happen?  Doesn't DOT have to be the first dir component?
0	  (loop for s on parsed
		when (equal (car s) ".")
		  do (rplaca s "dot"))
	  (when absolute-p
	    1;; Create a dir component list to add to the front of absolute pathnames.
0	    (when (eq reroot-absolute-pathnames :unspecified)
	      1;; The command passes in a value for this, but otherwise prompt here.
0	      (setf reroot-absolute-pathnames
		    (scl:yes-or-no-p "Reroot absolute pathnames under ~A? " dir))))
	  1;; &&& I'm not sure I buy the semantics of the LET below.  If the tape has
0	  1;; &&& /Foner/Test on it, and my new root is >Foner>New-Test, then files go
0	  1;; &&& into >Foner>New-Test>Foner>Test> if RRP is T, but >Foner>New-Test if
0	  1;; &&& RRP is unspecified.  I'm not sure what I want, but that seems weird.
0	  (let ((out-dir (cond ((or (not absolute-p)
				    (eq reroot-absolute-pathnames t))	1; Tri-valued logic.
0				1;; Scrunch together the dir components from the tape pathname and DIRPATH.
0				(send dir :new-pathname
				      :raw-directory (append (send dir :raw-directory)
							     1;; Drop the filename.
0							     (butlast parsed))))
			       (t
				dir))))
	    (let* ((final-name (car (last parsed)))
		   (period-index
		     (string-search-char #\. final-name :from-end t))
		   (fname (if period-index
			      (substring final-name 0 period-index)
			      final-name))
		   (type (if period-index
			     (substring final-name (1+ period-index))
			     "")))
	      1;; Compensate for a major controversy in pathname theory:  Is a zero-length
0	      1;; NAME component, for any given filesystem, legal?  Extensive discussions about
0	      1;; LMFS say that, even though it's possible to open such a file on a local LMFS
0	      1;; (by creating a pathname object directly to have "" in its name field), this
0	      1;; really shouldn't be allowed (because ">.bar" parses with NIL, not "", in its
0	      1;; NAME field, and therefore various access paths to remote LMFi will always
0	      1;; default the name [e.g., to ">foo.bar"], rather than leaving it ""---and
0	      1;; because it was deemed illegal to create such files, even though it is nowhere
0	      1;; documented to be so).  Thus, rather than attempt to create such a file, even
0	      1;; though this is a common case in UNIX tar tapes (e.g., ".cshrc" files), we'll
0	      1;; always turn such a file into " .cshrc" (e.g., a NAME field of a single space).
0	      1;; If there is both a ".cshrc" and  " .cshrc" on the tape, well, you lose.
0	      (when (zerop (string-length fname))
		(setf fname " "))
	      (let ((fpath (send out-dir :new-pathname
				 :raw-name fname
				 :raw-type type
				 :version :newest)))
		(cond ((member (tar-header-linkflag hbuf) '("1" "2"))
		       (format t "~&Ignoring ~:[~;symbolic ~]link ~A to ~S" 
			       (equal (tar-header-linkflag hbuf) "2")
			       fpath
			       (unix-string (tar-header-linkname hbuf)))
		       (setf fpath nil)
		       (setf (tar-header-size hbuf) "00000000000"))
		      (dirp
		       (setf fpath nil)))
		(read-tar-file-from-tape 8stream hbuf fpath (if (eql mode :function)
								(funcall function-name hbuf fpath)
							    mode))))))))))

1;;; NOTE:  Should make a handler for function below that can cope with
;;; handing this a pathname that can't be stored in whatever filesystem
;;; we're writing to.  This came up in the case of the pathname
;;; ".newgroups-pruned", because LMFS has a limit of 16 characters in
;;; the type field.  It might also come up if we're restoring from a
;;; UNIX that allowed >14 character filenames into one that doesn't.
;;; The proceed option should ask for a new name, without telling the
;;; caller.  I know I've seen this somewhere else before.  --- Foner
;;; 26-Jul-89.

;;; FPATH can be null, meaning that this entry is a directory or link or something
;;; and is to be skipped (i.e., drop the data on the floor).
0(defun 2READ-TAR-FILE-FROM-TAPE0 (8stream hbuf fpath mode)
  (when fpath
    (condition-case ()
	 (cond ((zl:probef fpath)
		(format *error-output* "~&~A is there already.~&" fpath)
		(let ((type (heuristicate fpath)))
		  (when (or (and (eql mode :text)
				 (eql type 'character))
			    (and (eql mode :binary)
				 (equal type '(unsigned-byte 8))))
		    (setq fpath nil))))
	       (t nil))
       (fs:file-not-found nil)
       (fs:directory-not-found
	 (fs:create-directories-recursively fpath))))
  (let ((size (unix-octal (tar-header-size hbuf)))
	(open-element-type :default)		1; This will become some non-:DEFAULT element-type if FPATH is non-null.
0	(translate? nil))
    (when fpath					1; Don't ask stupid questions if we're just going to throw the data away.
0      (multiple-value-setq (open-element-type translate?)
	(text-or-binary? mode fpath t))
      (format t "~&Loading ~A (~A)~&"		1; It's still okay to say this, 'cause we'll load.
0	      fpath				1; Is there any way to get the original UNIX name into this message as well?
0	      (if translate? "text" "binary")))
    (with-open-stream
      (out-stream (if fpath
		      (open fpath
			    :direction :output
			    :element-type open-element-type)
		      'si:null-stream))
      (do ((count size))
	  ((zerop count))
	(multiple-value-bind (fbuf index n-there)
	    (send 8stream :get-input-buffer
		  "Unexpected EOF while reading file contents from tape stream.")
 	  (let ((array-type (if translate? 'sys:art-string 'sys:art-8b)))
	    (sys:with-stack-array (cfbuf n-there
					 :type array-type
					 :displaced-to fbuf
					 :displaced-index-offset index)
	      (let ((howmany (min count n-there)))
		1;; Make a copy on the stack so we can ASCII-convert in place.
0		(sys:with-stack-array (file-contents howmany :type array-type)
		  (cl:replace file-contents cfbuf)
		  (when translate?
		    (ascii-to-lispm-character-convert file-contents 0 howmany))
		  (send out-stream :string-out file-contents 0 howmany)
		  (send 8stream :advance-input-buffer (+ index howmany))
		  (decf count howmany))))))))
    1;; Set the new file's modification date from the info on the tape
0    1;; (before we bash the header info in the :STRING-IN below).
0    (when fpath
      (let ((mtime (unix-octal (tar-header-mtime hbuf))))
	(fs:change-file-properties fpath nil
				   1;; --- Seems most useful to set the creation date.
0				   :creation-date (unix-time->ut mtime))))
    1;; If the file wasn't an exact multiple of TAR-TBLOCK bytes long, read out the
0    1;; rest of the block from the tape.
0    (if (not (zerop (rem size tar-tblock)))
	(send 8stream :string-in "Unexpected EOF on tar medium"
	      hbuf 0 (- tar-tblock (rem size tar-tblock))))))

1;;;; Scanning (reading, but dropping the actual data on the floor).

0(defun 3SHOW-TAR-GENERIC0 (8stream)
  (let ((header (make-tar-header)))
    (loop for count from 1
	  finally (format t "~&End of TAR input.")
	  do
      (condition-case ()
	   1;; Read a header block.
0	   (send 8stream :string-in "End of File" header 0 tar-tblock)
	 (sys:end-of-file (loop-finish)))
      (if (zerop (aref header 0)) (loop-finish))
      (validate-checksum header)
      (format t "~&File ~D: ~A" count (unix-string (tar-header-name header)))
      1;; Skip file contents.
0      (read-tar-file-from-tape 8stream header nil nil)))
  (values))

(defun 3SHOW-TAR-TAPE0 ()
  (with-open-stream (8stream (tape:make-stream
			       :record-length (* tar-tblock tar-nblock)))
    (show-tar-generic 8stream))
  (values))

(defun decompressing-8b-stream (stream)
  (make-instance 'compression::buffered-decompressing-input-stream
		 :stream stream
		 :forced-preamble-type :unix
		 :unix-translation-in-effect? nil
		 :public-buffer-element-type '(unsigned-byte 8)))

(defun 3SHOW-TAR-FILE0 (pathname &optional (compressed? nil))
  (if compressed?
      (with-open-file (8stream pathname
			       :direction :input
			       :element-type '(cl:unsigned-byte 8))
	(with-open-stream (8cstream (decompressing-8b-stream 8stream))
	  (show-tar-generic 8cstream)))
      (with-open-file (8stream pathname
			       :direction :input
			       :element-type '(cl:unsigned-byte 8))
	(show-tar-generic 8stream))
      (values)))

1;;;; Mapping.

0(defun map-tar-generic (8stream function &optional args)
  (if (member :read-pointer (send 8stream :which-operations))
      (map-tar-generic-pointer 8stream function args)
      (map-tar-generic-non-pointer 8stream function args)))

;;calls function with tar header, count and stream.  Function returns T if it read file,
;;NIL if it didn't.
(defun MAP-TAR-GENERIC-non-pointer (8stream function &optional args)
  (let ((header (make-tar-header)))
    (loop with index and eof
	  for count from 1
	  do (multiple-value-setq (index eof)
	       (condition-case (error)
		    1;; Read a header block.
0		    (send 8stream :string-in "End of File" header 0 tar-tblock)
		  (tape::tape-error (format t "~&Got error, exiting: ~a" error)
				    (loop-finish))
		  (sys:end-of-file (loop-finish))))
	  until eof do (ignore index)
      (if (zerop (aref header 0)) (loop-finish))
      (condition-case (err)
	   (validate-checksum header)
	 (sys::error (format t "~&Error validating header, scanning: ~a" err)
		     (loop with done = nil
			   with copy = (make-array 512 :element-type'(unsigned-byte 8))
			   for new-byte = (read-byte 8stream nil nil)
			   while new-byte
			   do (loop for i below 511
				    for j from 1
				    do (setf (aref header i) (aref header j))
				    finally (setf (aref header 511) new-byte))
			      (setq done (and
					   (unix-octal (tar-header-uid header))
					   (unix-octal (tar-header-gid header))
					   (unix-octal (tar-header-size header))
					   (unix-octal(tar-header-chksum header))))
			      (when done
				(cl::copy-seq header copy)
				(condition-case (err)
				     (validate-checksum header)
				   (sys:error (setq done nil)))
				(unless done
				  (cl::copy-seq copy header)))
			   until done)))
      (when (null (apply function header count 8stream args))
	(read-tar-file-from-tape 8stream header nil nil))))
  (values))

;;calls function with tar header, count and stream.  Function returns T if it read file,
;;NIL if it didn't.  The pointer variant will fix things up if file is positioned wrong.
(defun MAP-TAR-GENERIC-pointer (8stream function &optional args)
  (let (scan
	(header (make-tar-header)))
    (loop with last-header-position
	  for count from 1
	  do (if scan
		 (loop named scan
		       for pos from last-header-position by 512
		       for ok = t
		       do (condition-case (err1)
			       (file-position 8stream pos)
			     (sys::end-of-file (loop-finish))
			     (sys::error 
			       (setq ok nil)
			       (format t "~&Error while positioning to ~d for scan: ~a" 
				       pos err1)))
			  (when ok
			    (condition-case (err2)
				 (send 8stream :string-in "End of File" header 0 tar-tblock)
			       (sys::end-of-file (loop-finish))
			       (sys::error
				 (setq ok nil)
				 (format t "~&Error reading header for scan at ~D: ~A" pos
					 err2))))
			  (when ok
			    (let (;(header-size (unix-octal (tar-header-size header)))
				  (original-header-checksum 
				    (unix-octal (tar-header-chksum header))))
			      (fill-in-checksum header)
			      (when (and original-header-checksum
					 (eql original-header-checksum
					      (unix-octal (tar-header-chksum header))))
				(format t "~&Found valid header for ~a at ~D" 
					(unix-string (tar-header-name header)) pos)
				(setq scan nil
				      last-header-position pos)
				(return-from scan t)))))
		 (condition-case ()
		      (progn (setq last-header-position (file-position 8stream))
			     1;; Read a header block.
0			     (send 8stream :string-in "End of File" header 0 tar-tblock))
		    (sys:end-of-file (loop-finish))))
	     (if (zerop (aref header 0)) (loop-finish))
	     (validate-checksum header)
	     (let* ((name (unix-string (tar-header-name header)))
		    (size (unix-octal (tar-header-size header)))
		    (extra (if (zerop (mod size 512))
			       0
			       (- 512 (mod size 512))))
		    (next-header-position (+ 512 last-header-position size extra)))
	       (when (null (condition-case (err)
				(apply function header count 8stream args)
			      (sys::error (format t "~&Error while applying function for ~a at ~d: ~a" name last-header-position err) nil))
			   )
		 (condition-case ()
		      (read-tar-file-from-tape 8stream header nil nil)
		    (sys:error (format t "~&Error reading ~A (~D)" name last-header-position))))
	       (let ((position-now (file-position 8stream)))
		 (unless (eql position-now next-header-position)
		   (format t "~&Warning, at ~d instead of ~d, fixing" position-now
			   next-header-position)
		   (condition-case ()
			(file-position 8stream next-header-position)
		      (sys:error (setq last-header-position next-header-position)
				 (format t "~&Error positioning to ~d, scanning" next-header-position)
				 (setq scan t))))))))
  (values))


1;;;; Comparing.

0(defvar *tar-compare-verbose?*)
(defvar *tar-compare-success-count*)
(defvar *tar-compare-failures*)

(defvar *tar-compare-donew* t)

(defun without-common-directory-components (pattern-directory example)
  (if (null pattern-directory)
      example
      (let ((pattern-length (length pattern-directory)))
      (unless (equalp (subseq example 0 pattern-length)
		      pattern-directory)
	(error "Non-corresponding directory elements: ~S vs ~S"
	       pattern-directory (subseq example 0 pattern-length)))
      (subseq example pattern-length))))

(defun compare-to-original (header count 8stream prefix last-dir-location tape-name)
  (let* ((begin (get-internal-real-time))
	 (tar-position (ignore-errors (file-position 8stream)))
	 (size (unix-octal (tar-header-size header)))
	 (last-dir (location-contents last-dir-location))
	 (name (unix-string (tar-header-name header)))
	 (verbose? *tar-compare-verbose?*)
	 (last-slash (position #\/ name :test'char-equal :from-end t))
	 (no-slash (null last-slash))
	 (prefix-as-pathname (when prefix (fs:parse-pathname prefix)))
	 (prefix-directory (when prefix-as-pathname
			     (let ((directory (send prefix-as-pathname :directory)))
			       (if (eql :root directory)
				   ()
				   directory))))
	 (prefix-is-unix? (when prefix
			    (search "UNIX" 
				    (string 
				      (send (send prefix-as-pathname :host) :system-type))
				    :test'char-equal)))
	 (pathname (if (and nil prefix-is-unix?)
		       ;;easy case, just prepend prefix -- also wrong, and NIL skips it
		       (fs:parse-pathname 
			 (concatenate 'string prefix (if no-slash last-dir "") name))
		       ;;hard case, need to come up with corresponding pathname
		       ;;we don't necessarily have a Unix host handy, so we'll do the
		       ;;slash parsing ourselves
		       (let* ((last-dot (position #\. name :from-end t :test'char-equal))
			      (this-type (if last-dot
					     (subseq name (1+ last-dot))
					     ""))
			      (this-name (if last-slash
					     (subseq name (1+ last-slash) last-dot)
					     (subseq name 0 last-dot)))
			      (first-slash (when last-slash
					     (position #\/ name :test'char-equal))))
			 (send prefix-as-pathname :new-pathname :raw-name this-name
			       :raw-type this-type
			       :version :newest
			       :directory 
			       (if (or (null last-slash)
				       (and last-slash first-slash
					    (eql last-slash first-slash)))
				   (send prefix-as-pathname :directory)
				   (append prefix-directory
					   (without-common-directory-components
					     prefix-directory
					     (loop with i = first-slash
						   until (eql i last-slash)
						   for next = (position #\/
									name
									:test'char-equal
									:start (1+ i))
						   collect (subseq name (1+ i)
								   next)
						   do (setq i next))))))))))
    (ignore no-slash) ;;used for debugging
;    (when no-slash (setq verbose? t) (describe header))
    (when verbose?
;    (describe header)
      (format t "~&File ~D: ~a" count pathname))
    ;;this was a hack to get long filenames to work on Alpha, probably isn't quite right
    ;;but what Alpha tar does in this case isn't documented.
    (when (string-equal "5" (tar-header-linkflag header))
      (setf (location-contents last-dir-location) (concatenate 'string name "/")))
    (unless (zerop size)			;test isn't right, really want normal filep
      (prog1
	(condition-case (err)
	     (with-open-file (i pathname :element-type'(unsigned-byte 8))
	       (if *tar-compare-donew*
		   (loop with position = 0
			 with failed?
			 with tbuf and tstart and tend
			 with fbuf and fstart and fend
			 with todo = size
			 until (zerop todo)
			 for tavail = (if tbuf
					  (- tend tstart)
					  (progn
					    (multiple-value-setq (tbuf tstart tend)
					      (send 8stream :read-input-buffer))
					    (unless tbuf
					      (error "Unexpected EOF"))
					    (- tend tstart)))
			 for favail = (if fbuf
					  (- fend fstart)
					  (progn
					    (multiple-value-setq (fbuf fstart fend)
					      (send i :read-input-buffer))
					    (if (null fbuf)
						(progn
						  (setq failed? t)
						  0)
						(- fend fstart))))
			 until failed?
			 for this-time = (min todo tavail favail)
			 if (zerop this-time)
			   do (when (zerop tavail)
				(send 8stream :advance-input-buffer tend))
			      (when (zerop favail)
				(send i :advance-input-buffer fend))
			 else do (loop repeat this-time
				       for count from 1
				       for ti from tstart
				       for fi from fstart
				       unless (eql (aref tbuf ti) (aref fbuf fi))
					 do (setq failed? t)
					    (loop-finish)
				       finally (decf todo count)
					       (incf tstart count)
					       (incf fstart count)
					       (incf position count)
					       (when (eql tstart tend)
						 (send 8stream :advance-input-buffer tstart)
						 (setq tbuf nil))
					       (when (eql fstart fend)
						 (send i :advance-input-buffer fstart)
						 (setq fbuf nil)))
			 finally (when tbuf
				   (send 8stream :advance-input-buffer tstart))
				 (when fbuf
				   (send i :advance-input-buffer fstart))
				 #+ignore
				 (when verbose? (format t " position ~d" position))
				 (when failed?
				   (when verbose? (format t " toskip ~d" todo))
				   (loop with tb and ts and te
					 with toskip = todo
					 until (zerop toskip)
					 for avail = (progn(multiple-value-setq (tb ts te)
							     (send 8stream :read-input-buffer))
							   (when (null tb)
							     (error "Unexpected eof"))
							   (- te ts))
					 for this = (min avail toskip)
					 do (decf toskip this)
					    (incf ts this)
					    (send 8stream :advance-input-buffer ts)))
				 (when verbose? (format t " ~d byte~:p" size))
				 (let ((excess (- 512 (mod size 512))))
				   (unless (eql 512 excess)
				     #+ignore
				     (when verbose? (format t " excess ~d" excess))
				     (loop with tb and ts and te
					   with toskip = excess
					   until (zerop toskip)
					   for avail = (progn(multiple-value-setq (tb ts te)
							       (send 8stream :read-input-buffer))
							     (when (null tb)
							       (error "Unexpected eof"))
							     (- te ts))
					   for this = (min avail toskip)
					   do (decf toskip this)
					      (incf ts this)
					      (send 8stream :advance-input-buffer ts))))
				 (if failed? 
				     (progn (push (list pathname failed? tar-position) *tar-compare-failures*)
					    (when verbose? 
					      (si:dbg)
					      (format t " ***** MISCOMPARE skipping ~d file byte~:p" (- size position))))
				     (when tape-name
				       (let ((old-property (send pathname :get tape-name))
					     (this-property (if failed? :miscompare
								:ok)))
					 (when (and old-property (neq old-property this-property))
					   (format t "~&Comparsion was ~A last time."))
					 (send pathname :putprop this-property tape-name)))
				       
				     (incf *tar-compare-success-count*))
				 (return t))
;	       #+ignore
		   (loop with failed?
			 repeat size
			 for file-code = (send i :tyi)
			     #+ignore
			     (read-byte i nil nil)
			 for tape-code = (send 8stream :tyi)
			     #+ignore
			     (read-byte 8stream nil nil)
			 for position from 0
			 unless (eql file-code tape-code)
			   do (setq failed? position)
			 until failed?
			 finally (incf position)
				 (when verbose?
				   (unless failed?
				     (format t " ~d byte~:p" position)))
				 (if failed? 
				     (progn 
				       #+ignore
				       (when verbose?
					 (format t " failed at position ~d, file had ~X, tape had ~x" (1- position) file-code tape-code))
				       (push (list pathname failed? tar-position) *tar-compare-failures*)
				       (when verbose? (format t " ***** MISCOMPARE skipping ~d file byte~:p" (- size position)))
				       (loop repeat (- size position)
					     for code = (read-byte 8stream nil nil)
					     unless code
					       do (error "Unexpected tape eof")))
				     (incf *tar-compare-success-count*))
				 (when tape-name
				   (let ((old-property (send pathname :get tape-name))
					 (new-property (if failed? :miscompare :ok)))
				     (when (and old-property (neq old-property new-property))
				       (format t "~&Last time compare was ~a" old-property))
				     (send pathname :putprop new-property tape-name)))
				 (unless (zerop (mod size 512))
				   #+ignore
				   (when verbose?
				     (format t " skipping ~d pad byte~:p" (- 512 (mod size 512))))
				   (loop repeat (- 512 (mod size 512))
					 for tape-byte = (read-byte 8stream nil nil)
					 when (null tape-byte)
					   do (error "Unexpected eof")))
				 (return t))))
	   (fs::file-operation-failure 
	     #+ignore
	     (unless (or (typep err 'nfs::nfs2-eacces)
			 (typep err 'nfs::nfs-enoent)
			 (typep err 'nfs::nfs2-enoent-directory))
	       (si:dbg))
	     (let ((error-string (format nil "~A" err)))
	       (when verbose?
		 (format t " ***** ERROR: ~a"(subseq error-string 0 (position #\return error-string :test'char-equal)))))
	     (push (list pathname err (copy-seq header)) *tar-compare-failures*)
	     nil))
	(when verbose?
	  (let* ((end (get-internal-real-time))
		 (difference (- end begin)))
	    (unless (zerop difference)
	      (format t " (~2$ byte~:p/second)" (/ (* 1000.0 size) difference)))))))))

(defun tape-name-report (tape-name prefix)
  (let* ((template-pathname(fs:parse-pathname prefix))
	 (phost (send template-pathname :host))
	 (wild-pathname (send template-pathname  :new-pathname
			      :name :wild :directory  
			      (append (send template-pathname
					    :directory)
				      (list :wild-inferiors))))
	 (pathnames-matching (loop for x being the hash-elements of 
				       (send phost :pathname-hash-table)
;					 with-key list
				   when (and (fcl-user::pathname-match-p x wild-pathname)
					     (send x :get tape-name))
				     collect x))
	 (files-matching (directory wild-pathname))
	 (pathnames-but-not-files
	   (set-difference pathnames-matching files-matching :test'equalp))
	 (files-but-not-pathnames
	   (set-difference files-matching pathnames-matching :test'equalp))
	 (files-and-pathnames (intersection pathnames-matching files-matching :test'equalp))
	 (miscompares-or-errors (loop for file in files-and-pathnames
				      for status = (send file :get tape-name)
				      unless (eql status :ok)
					collect file)))
    (when files-but-not-pathnames
      (format t "~&~%~D file~:p not on tape:" (length files-but-not-pathnames))
      (loop for file in files-but-not-pathnames
	    do (format t "~&  ~A" file)))
    (when pathnames-but-not-files
      (format t "~&~%~D file~:p deleted from filesystem:" (length pathnames-but-not-files))
      (loop for file in pathnames-but-not-files
	    do (format t "~&  ~A" file)))
    (when miscompares-or-errors
      (format t "~&~%~D file~:p failed to compare:" (length miscompares-or-errors))
      (loop for file in miscompares-or-errors
	    for status = (send file :get tape-name)
	    do (format t "~& ~A (~A)" file status)))
    (values miscompares-or-errors files-but-not-pathnames pathnames-but-not-files)))

(defun skip-over-eof (stream)
  (loop for code = (read-byte stream nil nil)
	while code)
  (send-if-handles stream :clear-eof))

(defun compare-tar-tape (&key (prefix "host:")(verbose? t) tape-name)
  (let ((last-dir "")
	(*tar-compare-failures* nil)
	(*tar-compare-success-count* 0)
	(*tar-compare-verbose?* verbose?))
    (with-open-stream (tape (tape::make-stream))
      (loop with done until done
	    do (condition-case (err)
		    (progn
		      (map-tar-generic 
			tape 'compare-to-original 
			(list prefix (locf last-dir) tape-name))
		      (skip-over-eof tape))
		  (tape::end-of-tape (setq done t))
		  (tape::transfer-error (setq done t)
					(format t "Got error ~S, assuming EOF" err)))))
    (when tape-name (tape-name-report tape-name prefix))
    (values *tar-compare-success-count*
	    *tar-compare-failures*)))

(defun compare-tar-file (filename &key (prefix "host:")(verbose? t) tape-name)
  (let ((last-dir "")(*tar-compare-failures* nil) (*tar-compare-success-count* 0) (*tar-compare-verbose?* verbose?))
    (with-open-file (i filename :element-type'(unsigned-byte 8))
      (map-tar-generic i 'compare-to-original (list prefix (locf last-dir) tape-name)))
    (when tape-name (tape-name-report tape-name prefix))
    (values *tar-compare-success-count*
	    *tar-compare-failures*)))

(defvar *last-compare-failure-list* nil)

(cp:define-command (3COM-COMPARE-TAR-TAPE0 :name "Compare TAR Tape"
				      :command-table "Tape Administration")
    (&key 
     (prefix 'string :default "host:" :documentation "Part of pathname to prepend to what is on tape")
     (tape-name 'boolean :default nil :documentation "If T, compare contents of tree on tape to contents of tree on disk and report on missing/extra files")
     (verbose? 'boolean :default nil :documentation "Report on progress"))
   (multiple-value-bind (success-count failures)
       (compare-tar-tape :prefix prefix :verbose? verbose? :tape-name tape-name)
     (format t "~&~D compared, ~D failed" success-count (length failures))
     (setq *last-compare-failure-list* failures)
     ))

(cp:define-command (3COM-COMPARE-TAR-FILE0 :name "Compare TAR File"
				      :command-table "Tape Administration")
    ((tarfile 'cl:pathname
	      :prompt "Tarfile to be read")
     &key #+ignore ;NYI
	  (compressed 'boolean :default nil
		      :mentioned-default t
		      :documentation "Is file in Unix compress format")
     (prefix 'string :default "host:" :documentation "Part of pathname to prepend to what is on tape")
     (tape-name 'boolean :default nil :documentation "If T, compare contents of tree on tape to contents of tree on disk and report on missing/extra files")
     (verbose? 'boolean :default nil :documentation "Report on progress")
     )
   (multiple-value-bind (success-count failures)
   (compare-tar-file tarfile 
;		     :compressed compressed
		     :prefix prefix
		     :verbose? verbose? :tape-name tape-name)
     (format t "~&~D compared, ~D failed" success-count (length failures))
     (setq *last-compare-failure-list* failures)
     ))


1;;;; Writing.

0(defun 3MAYBE-WARN-ABOUT-WILD-VERSIONS0 (wp wp-list)
  1;; Depends on the fact that WP-LIST is sorted and that they're all from
0  1;; one directory-listing, hence all one host.  Makes sure that there are
0  1;; no two pathnames that are the same except for their version.
0  (let ((no-duplicates?
	  (loop for (leader) in (cddr wp-list) 
		while leader
		for (trailer) in (cdr wp-list)	1; Ignore directory-properties entry, which is first.
0		never (and (equalp (send leader  :device)
				   (send trailer :device))
			   (equalp (send leader  :directory)
				   (send trailer :directory))
			   (equalp (send leader  :name)
				   (send trailer :name))
			   (equalp (send leader  :type)
				   (send trailer :type))))))
    (unless no-duplicates?
      (format *error-output*
	      "~&Warning:  At least two pathnames in the files in ~A~@
                 are the same except for their versions.  This will cause multiple versions~@
                 of some files to be written to the tape with the same name, since no version-number~@
                 translation is in effect.  Only the first one written will be loaded when the~@
                 tarfile is read.~2&"
	      wp))))

1;;; Toplevels.

0(defun 2WRITE-TAR-TAPE0 (wild-paths &key
		       (mode :query)
		       relativize-pathnames
		       since)
  (write-tar-generic wild-paths
		     #'tape:make-stream `(:record-length ,(* tar-tblock tar-nblock) :direction :output)
		     :mode mode
		     :relativize-pathnames relativize-pathnames
		     :since since)
  (values))

(defun 3WRITE-TAR-FILE0 (wild-paths tar-file-path &key
		       (mode :query)
		       relativize-pathnames
		       since)
  (write-tar-generic wild-paths
		     #'open `(,tar-file-path :direction :output :element-type (cl:unsigned-byte 8))
		     :mode mode
		     :relativize-pathnames relativize-pathnames
		     :since since)
  (values))

(defun 3WRITE-TAR-GENERIC0 (wild-paths stream-fcn stream-args &key
			  (mode :query)
			  relativize-pathnames
			  since)
  (unless (listp wild-paths)
    (setf wild-paths (ncons wild-paths)))
  1;; Have to use translated-pathnames to do relativization correctly.
0  (setf wild-paths (cl:map 'list
			   #'(lambda (p)
			       (send (cl:pathname p) :translated-pathname))
			   wild-paths))
  (let ((relativization-root nil))
    (when relativize-pathnames
      (cond ((= (length wild-paths) 1)
	     1;; Make the "relativization root" by gathering all the non-wild components
0	     1;; from the front end of the pathname's directory.
0	     (let* ((path (first wild-paths))
		    (dir (send path :directory))
		    1;;--- This is kludgy.  I want only the "fixed head" of the pathname.
0		    1;; What other special cases am I forgetting?
0		    (fixed-head (loop for entry in dir
				      until (or (eq entry :wild-inferiors)
						(string-search "*" entry))
				      collect entry)))
	       (setf relativization-root (send path :new-pathname
					       :directory fixed-head
					       :name nil
					       :type nil
					       :version nil))))
	    (t
	     1;; More than one pathname supplied:  defer to the user.  I know, I know, we could
0	     1;; analyze all the pathnames for the common "fixed head", but I don't feel like
0	     1;; writing the code.  Besides, we handle >foo>bar>**>*.lisp which should be good
0	     1;; enough for most purposes.  (Note that the error message talks about the
0	     1;; :RELATIVIZE option, not the :RELATIVIZE-PATHNAMES option, because that's
0	     1;; its name in the CP command, which is the real user interface.)
0	     (format *query-io* "~&Multiple directories have been supplied with the :RELATIVIZE option.~&")
	     (setf relativization-root
		   (scl:accept 'cl:pathname
			       :prompt "Directory to relativize with respect to "
			       :default nil)))))
    (let* ((header (make-tar-header))
	   (files-dumped 0)
	   (total-size 0))
      (with-open-stream (8stream (apply stream-fcn stream-args))
	(loop for wp in wild-paths do
	  (setf wp (fs:merge-pathnames wp))
	  (let ((wp-list (fs:directory-list wp :sorted)))
	    (maybe-warn-about-wild-versions wp wp-list)
	    (loop for (file . properties) in wp-list
		  do
	      (when file
		(when (write-file-to-tar-tape file properties header 8stream
					      relativization-root since mode)
		  (incf files-dumped)
		  (incf total-size (cl:getf properties :length-in-bytes 0)))))))
	1;; --- I can't seem to get the EOF processing to work right, but both our
0	1;; READ-TAR-TAPE and UNIX's will stop on a null header.
0	(loop repeat 512 do
	  (send 8stream :tyo 0))
	(send 8stream :eof))
      (format t "~&~D files dumped (~:D bytes)" files-dumped total-size))))

1;;; Returns T to indicate file was dumped.
0(defun 2WRITE-FILE-TO-TAR-TAPE0 (file properties header tape-stream relativization-root since mode)
  (cond ((cl:getf properties :link-to)
	 (format t "~&Skipping link ~A~&" file)
	 nil)
	((cl:getf properties :directory)
	 #+ignore
	 1;; Message isn't really very useful.
0	 (format t "~&Skipping directory file ~A~&" file)
	 nil)
	1;; From here down we know it's a file.
0	((and (not (null since))
	      (< (cl:getf properties :creation-date 0) since))
	 #+ignore
	 1;; Message is just too annoying.  Add a silent/verbose flag to control it.
0	 (format t "~&Skipping ~A, 'cause it's too old.~&" file)
	 nil)
	(t
	 (let* ((host (get :unix42 'neti:sample-host))	1; Very convenient.
0		(sample-pathname (send host :sample-pathname))
		1;; The relativization hair.  We have been given a pathname that
0		1;; represents a common "fixed head" that we want to strip of all
0		1;; pathnames that we write on the tape.  Compare the directory of the
0		1;; file with this dir one component at a time.  If the beginning of the
0		1;; pathname matches the relativization-root, replace it with "./".  If
0		1;; not, use the absolute pathname as a fall back.
0		(unix-dir (cond (relativization-root
				 (block strip-common-head
				   (let ((dir (send file :directory))
					 (fixed-head (send relativization-root :directory)))
				     (loop for element in fixed-head
					   for to-lose in dir
					   do
				       (unless (string-equal element to-lose)
					 1;; Match failure, use the file's full, absolute pathname.
0					 (return-from strip-common-head (send file :raw-directory)))
				       (pop dir))
				     1;; Add "./" to the beginning.
0				     (append '(:relative ".") dir))))
				(t
				 (send file :raw-directory))))
		(unix-path (send sample-pathname :new-pathname
				 :device (send file :device)
				 :raw-directory unix-dir
				 :raw-name (let ((raw-name (send file :raw-name)))
					     1;; Undo the horrible grossness with null names we did in READ-TAR-TAPE above.
0					     (if (string-equal raw-name " ")
						 ""
						 raw-name))
				 1;; --- Is this right? Or just use :RAW-TYPE?
0				 :type (send file :type)
				 :version :unspecific))
		(unix-path-string (send unix-path :string-for-host)))
	   (multiple-value-bind (open-element-type translate?)
	       (text-or-binary? mode file)
	     (format t "~&Writing ~A as ~A (~A)~&"
		     file
		     unix-path-string
		     (if translate? "text" "binary"))
	     (with-open-file (file-stream file
					  :direction :input
					  :element-type open-element-type
					  :preserve-dates t)
	       (let ((bytes-written 0)
		     (file-size (or (send file-stream :length)	1; TCP-FTP to a UNIX will answer NIL for this...
0				    (getf properties :length-in-bytes))))	1; ... so use this if it does.
0		 1;; Rely on the "ignore" field following the size to supply the null-char.
0		 (setf (tar-header-size header) (format nil "~11O" file-size))
		 (setf (tar-header-name header) (cl:replace (tar-header-name header)
							    (unixify-string unix-path-string)))
		 (let ((creation-date (cl:getf properties :creation-date)))
		   (setf (tar-header-mtime header)
			 (format nil "~11O " (ut->unix-time creation-date))))
		 1;; --- It is unclear to me when we have to terminate the field strings with
0		 1;; a null character and when a space is good enough.  Studying the header from
0		 1;; a real Unix TAR tape showed both kinds.
0		 (setf (tar-header-uid header) (unixify-string (format nil "~6O " 0)))
		 (setf (tar-header-gid header) (unixify-string (format nil "~6O " 0)))
		 1;; --- What mode should I use?
0		 (setf (tar-header-mode header) (unixify-string (format nil "~6O " #o644)))
		 (fill-in-checksum header)
		 (send tape-stream :string-out header)
		 1;; Write the file to the tape one input buffer at a time.
0		 (loop do
		   (multiple-value-bind (file-contents start end)
		       (condition-case ()
			    (send file-stream :read-input-buffer t)
			  (sys:end-of-file
			    (loop-finish)))
		     (let ((buffer-size (- end start)))
		       1;; Make a stack copy so we can ASCII-translate in place.
0		       (sys:with-stack-array (file-copy buffer-size
							:element-type open-element-type)
			 (cl:replace file-copy file-contents :start2 start)
			 (sys:with-stack-array (file-bytes buffer-size
							   :element-type '(cl:unsigned-byte 8)
							   :displaced-to file-copy
							   )
			   (when translate?
			     (lispm-to-ascii-character-convert file-copy 0 buffer-size))
			   (send tape-stream :string-out file-bytes)
			   (incf bytes-written buffer-size)
			   (send file-stream :advance-input-buffer end))))))
		 1;; If the file isn't a multiple of TAR-TBLOCK bytes long, pad out the incomplete block.
0		 (when (not (zerop (rem file-size tar-tblock)))
		   (loop repeat (- tar-tblock (rem file-size tar-tblock))
			 do
		     (send tape-stream :tyo 0)))))))
	 1;; Indicate to the caller that the file was dumped.
0	 t)))

1;;;; User interface.

0(cp:define-command (3COM-READ-TAR-TAPE0 :name "Read TAR Tape"
				      :command-table "Tape Administration")
    ((root 'cl:pathname
	   :prompt "Root directory for relative pathnames"
	   :default (send (send (send (si:pathname-history-first-pathname)
				      :translated-pathname)
				:directory-pathname-as-file)
			  :pathname-as-directory))
     &key
     (mode
       '((scl:alist-member
	   :alist (("Binary" :value :binary
		    :documentation "Binary bytes with no character set translation")
		   ("Text" :value :text
		    :documentation "Text characters (:ELEMENT-TYPE 'CL:STRING-CHAR) with UNIX character set translation")
		   ("Query" :value :query
		    :documentation "Ask for each file")
		   1;; Heuristication mode only works when writing the tarfile, not when reading.
0		   ))
	 :description "a copy mode")
       :default :query
       :documentation "Mode in which to perform the copy")
     (reroot-absolute-pathnames
       'scl:boolean
       :default nil
       :mentioned-default t
       :documentation "Use the specified root directory as the \"root\" for absolute pathnames"))
   1;; Now do the work.
0   (read-tar-tape
     root
     :mode mode
     :reroot-absolute-pathnames reroot-absolute-pathnames))

(cp:define-command (3COM-READ-TAR-FILE0 :name "Read TAR File"
				      :command-table "Tape Administration")
    ((tarfile 'cl:pathname
	     :prompt "Tarfile to be read")
     (root 'cl:pathname
	   :prompt "Root directory for relative pathnames"
	   :default (send (send (send (si:pathname-history-first-pathname)
				      :translated-pathname)
				:directory-pathname-as-file)
			  :pathname-as-directory))
     &key
     (mode
       '((scl:alist-member
	   :alist (("Binary" :value :binary
		    :documentation "Binary bytes with no character set translation")
		   ("Text" :value :text
		    :documentation "Text characters (:ELEMENT-TYPE 'CL:STRING-CHAR) with UNIX character set translation")
		   ("Query" :value :query
		    :documentation "Ask for each file")
		   1;; Heuristication mode only works when writing the tarfile, not when reading.
0		   ("Function" :value :function :documentation "Use supplied function name to decide on type")
		   ))
	 :description "a copy mode")
       :default :query
       :documentation "Mode in which to perform the copy")
     (reroot-absolute-pathnames
       'scl:boolean
       :default nil
       :mentioned-default t
       :documentation "Use the specified root directory as the \"root\" for absolute pathnames")
     (compressed 'boolean :default nil
		      :mentioned-default t
		      :documentation "Is file in Unix compress format")

     (function-name 'symbol :default nil)
     )
   1;; Now do the work.
0   (read-tar-file
     root
     tarfile
     :mode mode :function-name function-name
     :reroot-absolute-pathnames reroot-absolute-pathnames
     :compressed? compressed
     ))

(cp:define-command (3COM-WRITE-TAR-TAPE0 :name "Write TAR Tape"
				       :command-table "Tape Administration")
    ((paths '((cl:sequence cl:pathname)))
     &key
     (mode
       '((scl:alist-member
	   :alist (("Binary" :value :binary
		    :documentation "Binary bytes with no character set translation")
		   ("Text" :value :text
		    :documentation "Text characters (:ELEMENT-TYPE 'CL:STRING-CHAR) with UNIX character set translation")
		   ("Query" :value :query
		    :documentation "Ask for each file")
		   ("Heuristicate" :value :heuristicate
		    :documentation "Determined automatically per file")
		   ))
	 :description "a copy mode")
       :default :query
       :documentation "Mode in which to perform the copy")
     (relativize
       'scl:boolean
       :default nil
       :mentioned-default t
       :documentation "Write relative UNIX pathnames onto the tape")
     (since
       '((time:universal-time) :past-p t)
       :documentation "Dump files newer than this date")
     )
   1;; Now do the work.
0   (write-tar-tape
     paths
     :mode mode
     :relativize-pathnames relativize
     :since since))

(cp:define-command (3COM-WRITE-TAR-FILE0 :name "Write TAR File"
				       :command-table "Tape Administration")
    ((paths '((cl:sequence cl:pathname)))
     (tarfile 'cl:pathname
	      :prompt "Tarfile to be written")
     &key
     (mode
       '((scl:alist-member
	   :alist (("Binary" :value :binary
		    :documentation "Binary bytes with no character set translation")
		   ("Text" :value :text
		    :documentation "Text characters (:ELEMENT-TYPE 'CL:STRING-CHAR) with UNIX character set translation")
		   ("Query" :value :query
		    :documentation "Ask for each file")
		   ("Heuristicate" :value :heuristicate	1; &&& ONLY WORKS IF INPUT FILE ON LMFS, NOT UNIX!  (Should deal with this!)
0		    :documentation "Determined automatically per file")
		   ))
	 :description "a copy mode")
       :default :query
       :documentation "Mode in which to perform the copy")
     (relativize
       'scl:boolean
       :default nil
       :mentioned-default t
       :documentation "Write relative UNIX pathnames onto the tape")
     (since
       '((time:universal-time) :past-p t)
       :documentation "Dump files newer than this date")
     )
   1;; Now do the work.
0   (write-tar-file
     paths
     tarfile
     :mode mode
     :relativize-pathnames relativize
     :since since))

1;;; I still can't help but feel that "List" is the natural verb here, but
;;; it would be madness to differ from "Show Carry Tape", etc.
0(cp:define-command (3COM-SHOW-TAR-TAPE0 :name "Show TAR Tape"
				      :command-table "Tape Administration")
    ()
   (show-tar-tape))

(cp:define-command (3COM-SHOW-TAR-FILE0 :name "Show TAR File"
				      :command-table "Tape Administration")
    ((tarfile 'cl:pathname
	      :prompt "Tarfile to be read")
     &key (compressed 'boolean :default nil
		      :mentioned-default t
		      :documentation "Is file in Unix compress format")
     )
   (show-tar-file tarfile compressed))

1;;; End of file.
