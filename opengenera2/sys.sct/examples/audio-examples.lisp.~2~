;;; -*- Mode: LISP; Package: USER; Base: 8; Lowercase: t; -*-
;;;> EXAMPLES-MESSAGE
;;;>
;;;>******************************************************************************************
;;;>
;;;>       Symbolics hereby grants permission to customer to incorporate
;;;>       the examples in this file in any work belonging to customer.
;;;>
;;;>******************************************************************************************

#|
This file contains example programs that use 
the Symbolics digital audio facilities.
Refer to the section "Digital Audio Facilities" 
for an explanation of the audio forms used.
|#

(defun sine-wave (frequency)
  (audio:with-audio ()			;this sets up the environment for doing audio
    (let* ((start (audio:audio-index))	;get the current index, which is where we start
	   (samples-per-cycle (round audio:*sample-rate* frequency))
	   ;; spread out several cycles to get a more accurate
	   ;; frequency.  Extra factor of 2 makes sure there is room.
	   (number-of-cycles (max 1 (floor (audio:audio-limit) (* samples-per-cycle 2))))
	   ;; Actual number of samples we are going to produce
	   (number-of-samples (* samples-per-cycle number-of-cycles)))
      ;; make sure we have room to play this frequency
      (when (> (+ number-of-samples 2) (audio:audio-limit))
	(ferror "Frequency too low"))
      ;; We are going to compute number-of-samples inline (as opposed to
      ;; in a separate array).  This form allows us to do that.  If we
      ;; didn't know how many samples we are going to produce we could
      ;; supply NIL for number-of-samples and the form will keep track
      ;; and adjust the command array when the form is exited.  Since we
      ;; do supply the number of samples, the form will check to make
      ;; sure we supply exactly that many.  This helps avoid writing
      ;; incorrect audio programs.
      (audio:computing-immediate-audio-samples (number-of-samples)
	(loop for sample-number below number-of-samples
	      as phase =
		 ;; this is the phase (angle) which will be passed to SIN
		 ;; to get the sine wave.  (This will cons double-floats in
		 ;; systems where cl:pi is a double-float.)
		 (// (* 2 cl:pi sample-number number-of-cycles)
		     number-of-samples)	      
	      as sample =
		 ;; Take the SIN of the phase.  Also multiply it by
		 ;; something less than 1 so we never get a value of 1.0
		 ;; (a restriction, see documentation).  Take the
		 ;; resulting floating point number in the range [-1.0,
		 ;; +1.0) and create a 'sample.'
		 (audio:float-sample (* (sin phase) 0.9))
	      do ;; Now actually push the sample into the command array.
		 (audio:push-immediate-audio-sample sample)))
      ;; All of the samples are computed and an appropriate command has
      ;; been generated to output them.  Now we cause a jump back to the
      ;; beginning to keep the sound going.
      (audio:push-audio-jump start)
      ;; The program is complete, we can now start the audio facility.
      (audio:audio-start start)
      ;; When you've heard enough, just type anything.  WITH-AUDIO
      ;; supplies code to turn off the audio facility when exited and do
      ;; other bookkeeping.
      (tyi))))

;;; This is roughly the same as sine-wave, but instead produces a
;;; sawtooth and only generates one cycle for it.

(defun saw-wave (frequency)
  (audio:with-audio ()
    (let* ((start (audio:audio-index))
	   (samples-per-cycle (round audio:*sample-rate* frequency)))
      (audio:computing-immediate-audio-samples (samples-per-cycle)
	(loop for sample-number below samples-per-cycle
	      as value =
		 ;; create a sawtooth value in the range [-1.0,1.0).
		 ;; Note this can never be exactly 1.0 since
		 ;; sample-number never quite gets as large as
		 ;; samples-per-cycle. 
		 (- (// (* 2.0 sample-number) samples-per-cycle) 1.0)
	      do (audio:push-immediate-audio-sample (audio:float-sample value)))
	(audio:push-audio-jump start)
	(audio:audio-start start)
	(tyi)))))

;;; Yet another type of wave form: square wave.  This also demonstrates
;;; the AUDIO-LOOP form.

(defun square-wave (frequency)
  (audio:with-audio ()
    (let* ((start (audio:audio-index))
	   (samples-per-cycle (round audio:*sample-rate* frequency))
	   ;; Compute the number of samples for the high value and
	   ;; low value.  Divide them as evenly as possible.
	   (samples-first-half (// samples-per-cycle 2))
	   (samples-second-half (- samples-per-cycle samples-first-half)))
      ;; Create a loop that will repeat samples-first-half times.  If we
      ;; weren't sure how many times we want to repeat, we could specify
      ;; NIL and then use SET-AUDIO-REPEAT-COUNT to set the count. 
      (audio:audio-loop (samples-first-half)
	;; Compute 1 value (the high value) for output.
	(audio:computing-immediate-audio-samples (1)
	  (audio:push-immediate-audio-sample (audio:float-sample 0.9))))
      ;; Do the same for the second half.
      (audio:audio-loop (samples-second-half)
	(audio:computing-immediate-audio-samples (1)
	  (audio:push-immediate-audio-sample (audio:float-sample -0.9))))
      ;; Jump back to the beginning so we get more than one cycle.
      (audio:push-audio-jump start)
      (audio:audio-start start)
      (tyi))))



;;; This is roughly the LM-2 %BEEP equivalent, but there are many
;;; reasons why this version can fail as the default.  It is basically a
;;; modified SQUARE-WAVE.

(defun %beep-ignoring-most-issues (frequency duration)
  (audio:with-audio ()
    (let* ((start (audio:audio-index))
	   (samples-per-cycle (sys:round audio:*sample-rate* frequency))
	   (samples-first-half (// samples-per-cycle 2))
	   (samples-second-half (- samples-per-cycle samples-first-half)))
      ;; can't nest loops, so we have to do the outer loop with a jump 
      ;; and bash the location when time has elapsed.
      (audio:audio-loop (samples-first-half)
	(audio:computing-immediate-audio-samples (1)
	  (audio:push-immediate-audio-sample (audio:float-sample 0.9))))
      (audio:audio-loop (samples-second-half)
	(audio:computing-immediate-audio-samples (1)
	  (audio:push-immediate-audio-sample (audio:float-sample -0.9))))
      ;; This is the tricky part.  We need to put a jump to the
      ;; beginning, but we need to know where it is so we can cause it
      ;; to fall through.  We also need a flag so we know when the audio
      ;; has stopped so we can exit.  If we simply exited without
      ;; waiting, the WITH-AUDIO form could turn off the sound prematurely.
      (let* (;; get the index that we will eventually bash and put in a
	     ;; jump back to the start.
	     (jump-index (prog1 (audio:audio-index) (audio:push-audio-jump start)))
	     ;; reserve (and reset) an audio flag.
	     (flag-index (audio:reserve-audio-flags 1))
	     ;; reserve-audio-flags puts in a jump command around the
	     ;; flags it reserves, so we could have gotten the
	     ;; fall-through index after pushing the jump command.
	     ;; Anyway, get the index of the fall-through location.
	     (fall-through-index (audio:audio-index)))
	;; when we bash the jump command the microcode will jump to here
	;; instead, which will cause the flag to get zeroed and the
	;; audio facility to stop.  Both events happen atomically as far
	;; as Lisp can tell because no samples are output in the
	;; intervening time.
	(audio:push-audio-zero-flag flag-index)
	(audio:push-audio-stop)
	;; fire it up!
	(audio:audio-start start)
	;; wait the appropriate number of microseconds.
	(loop with start-time = (sys:%microsecond-clock)
	      until ( (%32-bit-difference (sys:%microsecond-clock) start-time) duration))
	;; Here is where we bash the argument of the jump command to
	;; instead jump to the fall-through code.
	(audio:modify-audio-command-arg fall-through-index :index jump-index)
	;; Wait for the microcode to get to the flag and stop before we exit.
	(audio:wait-for-audio-flag flag-index "%BEEP")))))



;;; Very high quality sound cannot be generated in real time (one sample
;;; every 20 microseconds).  Small pieces (pieces that can fit in
;;; physical memory) can computed and then later played.

(defun play-audio-sample-array (array &optional (from 0) (to (array-active-length array)))
  (audio:with-audio ()
    ;; with-wired-structure wires the structure on entry and unwires on
    ;; exit.  External sample arrays must be wired.
    (si:with-wired-structure array
      (let* ((flag-index (audio:reserve-audio-flags 1))
	     (start (audio:audio-index)))
	;; Cause the samples to be played.  If we supplied a non-NIL
	;; immediate-p argument, we wouldn't have to wired the
	;; structure, since the samples would be put in the command
	;; array which is already wired.  However, most command arrays
	;; are not very large and probably couldn't hold all the
	;; samples.  It's a tradeoff.
	(audio:push-array-of-audio-samples array from to)
	;; When the microcode finishes the samples, cause it to clear
	;; the flag and stop.
	(audio:push-audio-zero-flag flag-index)
	(audio:push-audio-stop)
	;; start it up and wait for it to finish.
	(audio:audio-start start)
	(audio:wait-for-audio-flag flag-index "Play samples")))))



;;; Larger pieces (those that are too big to fit in physical memory) can
;;; still be played.  This program plays data that is stored on the FEP
;;; filesystem.  It must be on the FEP filesystem for various reasons.
;;; It still must produce data at the rate of one sample every 20
;;; microseconds (including ALL overhead).  This is 1.6 megabits per
;;; second, which is a small factor away from raw disk speed.  After
;;; overhead, this is getting close to the limits of the system.  The
;;; LMFS file system is too much overhead.  Also, we can't copy (as LMFS
;;; would try to do if we used :string-in into an array) and we can't
;;; spend time wiring buffers (as we would need to do with LMFS if we
;;; used :read-input-buffer).  The FEP filesystem allows us to do
;;; disk-dma directly into a buffer which we can keep wired.  We can
;;; also setup the audio facility to point to these buffers (using
;;; push-array-of-audio-samples) once so we don't have to do it often.

;;; This macro takes care of multibuffering bookkeeping.  The user
;;; decides how many pages to devote to each buffer and the number of
;;; buffers.  Disk arrays (the buffers) are allocated and wired on entry
;;; and unwired on exit.

(defmacro with-multi-disk-buffering ((npages nbuffers) (array-of-buffers size-of-each-buffer)
				     &body body)
  "npages and nbuffers are inputs, array-of-buffers and size-of-each-buffer are outputs"
  `(let ((,array-of-buffers (make-array ,nbuffers))
	 (,size-of-each-buffer (* ,npages 288.)))
     (unwind-protect
       (progn (loop for .idx. below ,nbuffers
		    as .buffer. = (allocate-resource 'si:disk-array
						     (+ ,size-of-each-buffer 288.))
		    do (setf (aref ,array-of-buffers .idx.) .buffer.)
		    (si:wire-structure .buffer.))
	      ,@body)
       (loop for .idx. below ,nbuffers
	     as .buffer. = (aref ,array-of-buffers .idx.)
	     do (when (si:structure-wired-p .buffer.)
		  (si:unwire-structure .buffer.))
	     (deallocate-resource 'si:disk-array .buffer.)))))

;;; This is the workhorse.  There are many "if we are fast enough"
;;; clauses in here.  As long as there isn't much other activity
;;; (especially paging activity) we usually are fast enough.

(defun play-disk-file (pathname)
  (setq pathname (fs:merge-pathnames pathname "FEP:>.mus.newest"))
  ;; get the FEP file opened.
  (with-open-file (file pathname :direction :block
			:if-exists :overwrite
			:if-does-not-exist :error)
    ;; These numbers were picked after a large amount of experimentation and tuning.
    (let* ((npages 40.) (nbuffers 8))
      (audio:with-audio ()
	(with-multi-disk-buffering (npages nbuffers) (buffers buffer-size)
	  ;; allocate a flag for each buffer for synchronization.
	  (let* ((flags (audio:reserve-audio-flags nbuffers))
		 (start (audio:audio-index)))
	    ;; build the audio program.  Push each buffer as an array of
	    ;; samples and then cause the flag associated with the
	    ;; buffer to be zeroed.
	    (loop for buffer below nbuffers
		  do (audio:push-array-of-audio-samples (aref buffers buffer) 0 buffer-size)
		     (audio:push-audio-zero-flag (+ flags buffer)))
	    ;; Loop back to the beginning.  To play new data (if we are
	    ;; fast enough, there /will/ be new data in the buffers).
	    (audio:push-audio-jump start)
	    ;; Here's the theory.  n-queued is the number of buffers
	    ;; filled with valid data that the microcode can use.  (The
	    ;; microcode will use all of them, but if we are fast enough
	    ;; we can keep them full.)  We fill up all the buffers and
	    ;; then start the audio facility.  This is done by an
	    ;; interaction with need-to-start and n-queued.  (There is
	    ;; also provision for small files.)  When all the buffers
	    ;; are queued, we need to wait for the microcode to finish
	    ;; the next one before we can do disk dma into it.
	    (loop with n-queued = 0
		  with need-to-start = t
		  with n-file-blocks = (sys:ceiling (send file :length) 1152.)
		  with current-file-block = 0
		  initially (format t "~&~F seconds~%"
			      (// (* n-file-blocks 288.) audio:*sample-rate*))

		  as blocks-this-whack =
		     ;; this is the number of blocks to do this time
		     ;; around.  It is at most the number of pages of
		     ;; buffering.  It is also at most the number of
		     ;; blocks remaining in the file.
		     (min npages (- n-file-blocks current-file-block))
		  for buffer-number =
		      ;; this is the current buffer number we are going
		      ;; to try to fill.  It is gets incremented modulo
		      ;; the number of buffers of buffering.
		      0 then (\ (1+ buffer-number) nbuffers)
		  as flag-index = (+ flags buffer-number)
		  do ;; If all the buffers are queued, or if the end of
		     ;; the file has been reached, wait for the
		     ;; microcode to finish the buffer and then count it
		     ;; as dequeued.
		     (when (or (= n-queued nbuffers) (zerop blocks-this-whack))
		       (audio:wait-for-audio-flag flag-index "Play disk file")
		       (decf n-queued))
		     ;; If we have some blocks to queue, make sure the
		     ;; flag for this buffer is reset, read in the
		     ;; blocks from the FEP file, increment the block
		     ;; pointer into the file, and count another buffer
		     ;; as queued.
		     (when (not (zerop blocks-this-whack))
		       (audio:reset-audio-flag flag-index)
		       (send file :block-in current-file-block blocks-this-whack
			     (aref buffers buffer-number))
		       (incf current-file-block blocks-this-whack)
		       (incf n-queued))
		     ;; If the audio facility hasn't been started and
		     ;; all buffers are filled, start the audio facility
		     ;; (and remember we did start it).
		     (when (and need-to-start
				(or (= n-queued nbuffers)
				    ( current-file-block n-file-blocks)))
		       (audio:audio-start start)
		       (setq need-to-start nil))
		  until
		    ;; we are finished when nothing is queued and we are
		    ;; at the end of the file.
		    (and (zerop n-queued) ( current-file-block n-file-blocks)))))))))

  ;;
;;;;;;  Polyphony example
  ;;

;;; This is a simple muse.  It uses roughly the same multi-buffering
;;; strategy as the disk example above, so that portion will not be
;;; commented as heavily.  The muse muses some number of voices (user
;;; specified) between 1 and 6.  All voices start at DO.  Each step
;;; (approximately every 1/4 second) causes each voice to wander
;;; randomly between 2 diatonic tones below the previous value and 2
;;; diatonic tones above the previous value.

;;; Figure out how large wave tables are in this release.


(defconst *samples-per-polyphonic-wave-table*
	  (expt 2 (byte-size sys:%%audio-increment-integer)))


;; This is the wave-array for the muse.  It is big enough to ensure that
;; there will be at least *samples-per-polyphonic-wave-table* consecutive wired words.

(defvar *muse-wave-array* (make-array (+ *samples-per-polyphonic-wave-table* sys:page-size -1)
				      :initial-value 0 :area audio:audio-area))

(defun polyphonic-muse (&optional (n-voices 4) &aux address wired)
  (check-arg n-voices (and (fixp n-voices) ( 1 n-voices audio:*number-of-polyphonic-voices*))
	     "an integer between 1 and 6")
  (audio:with-audio ()
    (unwind-protect
      (let ((offset-to-page
	      ;; This is how one gets to the number of Qs to the beginning of a page boundary
	      (ldb sys:%%vma-word-offset
		   (- sys:page-size (ldb sys:%%vma-word-offset
				     (%pointer (locf (aref *muse-wave-array* 0))))))))
	;;; Wire words of the wave table, starting at the location computed above.
	(setq address (locf (aref *muse-wave-array* offset-to-page)))
	(si:wire-consecutive-words
	  address				;where
	  *samples-per-polyphonic-wave-table*)	;how many, one per word.
	(setq wired t)				;Set a reminder to unwire it...
	  
	  ;; setup the muse wave array for a 1/6 (minus a bit) amplitude 
	  ;; sinewave (sawtooth doesn't seem to sound good here).  1/6
	;; allows all six voices to proceed without overflow.  The
	;; "minus a bit" avoids clipping at 1.0.
	(loop for index below *samples-per-polyphonic-wave-table*
	      do (setf (aref *muse-wave-array* (+ index offset-to-page))
		       (audio:float-polyphonic-wave-table-entry
			 (// (sin (// (* 2.0 si:pi index)
				      *samples-per-polyphonic-wave-table*)) 6.2))))
	;; Initialize each voice to a reasonable value.  It is essential
	;; that each voice gets a proper wave-array pointer and
	;; increment value.  An increment value of 0 will cause the
	;; pointer never to be incremented.  (This isn't strictly true,
	;; since the voice number is stored in the low 3 bits, but this
	;; advances the pointer VERY slowly.)
	(let ((start (audio:audio-index)))
	  (loop for voice below audio:*number-of-polyphonic-voices*
		do (audio:push-audio-load-voice voice *muse-wave-array* offset-to-page 0))
	  (audio:push-audio-stop)
	  (audio:audio-start start)
	  ;; put the audio index back to the start
	  (setf (audio:audio-index) start))

	(loop with nbuffers = 4
	      with n-queued = 0
	      with need-to-start = t
	      with flags = (audio:reserve-audio-flags nbuffers)
	      with start = (audio:audio-index)
	      with chords-per-whack =
		;; Take the room remaining, divide by the level of
		;; buffering and then divide by the sum of [2 locations
		;; per voice for the push-audio-load-voice command, one
		;; for the push-audio-polyphony command, and one for a
		;; possible flag or jump].
		(// (audio:audio-room) nbuffers (+ (* n-voices 2) 1 1))
	      with half-tone-offsets =
		;; 0 (and the multiples of 12) are DO.  The other
		;; numbers are offsets (from 0) to consecutive notes in
		;; the diatonic scale.
		'(-25. -24. -22. -20. -19. -17. -15. -13.
		       -12. -10. -08. -07. -05. -03. -01.
		       000. +02. +04. +05. +07. +09. +11.
		       +12. +14. +16. +17. +19. +21. +23.
		       +24. +26. +28. +29. +31. +33. +35.)
	      with half-tone-offsets-length = (length half-tone-offsets)
	      with voice-indices =
		;; a list, one element for each voice, starting at middle DO.
		(make-list n-voices
			   :initial-value (find-position-in-list 000. half-tone-offsets))
	      for buffer-number = 0 then (\ (1+ buffer-number) nbuffers)
	      until (kbd-tyi-no-hang)		;stop when user hits a key
	      do
	  (when ( n-queued nbuffers)
	    ;; this also resets the flag
	    (audio:wait-for-audio-flag (+ flags buffer-number) "Muse")
	    (decf n-queued))
	  ;; if this is buffer zero, make sure we are back to the start.
	  (when (zerop buffer-number) 
	    (setf (audio:audio-index) start))

	  ;; setup the chords for this buffer
	  (loop repeat chords-per-whack
		do ;; update each voice
		   (loop for voice-indices-scan on voice-indices
			 as old-index = (car voice-indices-scan)
			 as new-index = (let ((index (+ old-index (random 5) -2)))
					   ;; clip at the boundaries of the list
					   (cond ((< index 0) 1)
						 (( index half-tone-offsets-length)
						  (- half-tone-offsets-length 2))
						 (T index)))
			 do (setf (car voice-indices-scan) new-index))
		   ;; and queue the new values to polyphony facility
		   (loop for index in voice-indices
			 for voice-number upfrom 0
			 as half-tone-offset = (nth index half-tone-offsets)
			 as octave-offset = (// half-tone-offset 12.0)
			 as frequency-factor = (expt 2.0 octave-offset)
			 as frequency = (* 256.0 frequency-factor)
			 do (audio:push-audio-load-voice
			      voice-number *muse-wave-array* offset-to-page
			      (audio:frequency-polyphonic-increment frequency)))
		   ;; do polyphony for 1/4 second
		   (audio:push-audio-polyphony (sys:round audio:*sample-rate* 4)))
	  ;; synchronize this buffer
	  (audio:push-audio-zero-flag (+ flags buffer-number))
	  (incf n-queued)
	  (when (and ( n-queued nbuffers) need-to-start)
	    (audio:push-audio-jump start)
	    (audio:audio-start start)
	    (setq need-to-start nil))))
      (when wired
	(si:unwire-words address *samples-per-polyphonic-wave-table*)))))