;;; -*- Mode: LISP; Syntax: Zetalisp; Package: SCT; Base: 10; Lowercase: T -*-

;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; In the new world order of the SCT, all the information about a system that used
;;; to be kept in the special variable SI:PATCH-SYSTEMS-LIST is now kept in instance
;;; variables in the system object.  This includes whether the system is patchable
;;; (SYSTEM-PATCHABLE), the loaded system version number (SYSTEM-VERSION-LOADED --
;;; NIL if system not presently loaded), and the list structure of loaded patches
;;; (SYSTEM-LOADED-PATCHES).  Also, the cached record of the creation date of the
;;; patch directory file when it was last loaded is now kept more accessibly in
;;; SYSTEM-LOADED-PATCH-DIR-CREATION-DATE.  This requires different modularization.
;;; For convenience, we define a function SCT:PATCH-SYSTEMS-LIST to replace the
;;; convenience of the list in the old special variable.

(defun all-patchable-systems ()
  (loop for system in *all-systems*
	when (and (typep system 'system)
		  (system-patchable system))
	  collect system))

(defun patch-systems-list ()
  (loop for system in *all-systems*
	when (and (typep system 'system)
		  (system-patchable system)
		  (system-loaded-patches system))
	  collect (system-loaded-patches system)))

;; Just like PATCH-SYSTEMS-LIST, but it also includes entries for
;; systems that are not patchable, but have a numbered version loaded.
(defun systems-version-list (&optional unjournalled-too)
  (loop for system in *all-systems*
	when (and (typep system 'system)
		  (system-patchable system)
		  (system-loaded-patches system))
	  collect (system-loaded-patches system)
	when (and (typep system 'system)
		  (not (system-patchable system))
		  (or (numberp (system-version-loaded system))
		      (and unjournalled-too
			   (not (system-maintain-journals system))
			   (eq (system-version-loaded system) :newest))))
	  collect (make-patch-system
		    name-and-atom (patch-system-name-and-atom system)
		    version (system-version-loaded system)
		    status (system-status system))))

(defvar *patch-directory-bindings*
	'((base 10.)
	  (ibase 10.)
	  (package si:pkg-user-package)
	  (readtable si:standard-readtable)))

(defmacro with-patch-directory-bindings (&body body)
  `(scl:with-standard-io-environment
     (progw *patch-directory-bindings*
       ,@body)))

(defstruct (patch-major :list (:conc-name patch-))
  name-and-atom			;system to be patched, and its patch-atom
  version)			;most recent version of the system

(defun patch-system (patch-major &optional (error-p t))
  (let* ((name-and-atom (patch-name-and-atom patch-major))
	 (system (if (listp name-and-atom) (first name-and-atom) name-and-atom)))
    (if (typep system 'basic-system)
	system
	(find-system-named system error-p t))))

(defun patch-name (patch-major)
  (let* ((name-and-atom (patch-name-and-atom patch-major))
	 (name (if (listp name-and-atom) (first name-and-atom) name-and-atom)))
    (if (typep name 'basic-system)
	(string (system-name name))
	name)))

(defun patch-atom (patch-major)
  (let* ((name-and-atom (patch-name-and-atom patch-major))
	 (name (if (listp name-and-atom) (second name-and-atom) name-and-atom)))
    (if (typep name 'basic-system)
	(string (system-name name))
	name)))

;; Internal format of each patch system, parallel to the patch-directory file
(defstruct (patch-system :list (:conc-name patch-) (:include patch-major))
  status			;a keyword
  (version-list nil))		;list of versions loaded and explanations

(defun patch-system-name-and-atom (system)
  (let ((name system)
	(patom (system-patch-atom system)))
    ;; STRING= because case matters for file systems such as Unix...
    (if (string= (string (system-name system)) patom)
	name
	(list name patom))))

;; Format of patch directory file itself
(defstruct (patch-dir :list :conc-name)
  status
  version-list)

;; Information for each patch
(defstruct (patch-version :list (:conc-name version-))
  number			;minor number of the patch
  explanation			;explanation of the patch
  (author user-id)		;who dun it
  date				;date/time patch was created
  reviewer)			;who reviewed it

;; needed for compatibility conversions
(defun current-type-of-patch-version-p (pv)
  (eql (length pv) 5))

;; Returns six values, the major and minor version of a given system, its status,
;; the system object, loaded branch name, and its ECO level
;; Various combinations are possible, depending on conditions:
(defun get-system-version (&optional (system "System"))
  (declare (values major-version minor-version status system system-branch eco-level))
  (setq system (find-system-named system nil t))
  (let* ((major-version (and system
			     (neq (system-version-loaded system) :incomplete)
			     (system-version-loaded system)))
	 (patchable-system (and major-version
				(get-patchable-system-named system))))
    (cond ((null system) nil)			;---should this be an error?
	  ((null major-version) nil)		;returns all NILs if system not loaded
	  ((null patchable-system)		;(major NIL status) if not patchable
	   (values major-version nil
		   (if (typep system 'subsystem) nil (system-status system))
		   system
		   (system-branch-loaded system)))
	  (( major-version (patch-version patchable-system))
	   (ferror "Internal record for system ~A is inconsistent.  Please reload it."
	     system))
	  (t
	   (values (patch-version patchable-system)
		   (version-number (first (patch-version-list patchable-system)))
		   (patch-status patchable-system)
		   system
		   (system-branch-loaded system)
		   (system-eco-level system))))))

;; Stub for compatibility...
(deff si:get-system-version 'get-system-version)
(compiler:make-obsolete si:get-system-version "use SCT:GET-SYSTEM-VERSION instead")

;; Given the name of a system, or the system itself, return the patchable system description
(defun get-patchable-system-named (name &optional error-p)
  (let ((system (find-system-named name error-p t)))
    (cond ((and system
		(system-patchable system))	   ;assure consistency
	   (if (and (system-version-loaded system) ;is it loaded?
		    (neq (system-version-loaded system) :incomplete))
	       (system-loaded-patches system)	;yes, there better be a loaded-patches record
	     (if error-p
		 (ferror "The system ~A is patchable, but not yet loaded" system)
	       nil)))
	  ((null error-p) nil)
	  (t (ferror "The system ~A is not patchable" system)))))

;; Called when actually loading a system, create the PATCH-SYSTEM description.
;; Assumes system is patchable.
;; Returns the major version, the status, and whether there are patches.
(defun add-patch-system (name version)
  (declare (values major-version status existing-patches))
  (let ((system (find-system-named name t t))
	(*version* (if (eq version :newest) :latest version))
	patch-system first-vers patch-dir status)
    (when (keywordp *version*)
      (setq *version* (get-system-major-version-from-directory name *version*)))
    ;; If there is already a version of this system loaded, and it is the same
    ;; version as the one we are about to add, then don't bother, because we'll
    ;; lose patches which have already been loaded.
    (when (and (system-loaded-patches system)
	       (= *version* (patch-version (system-loaded-patches system))))
      ;; ... but do inform the environment which patches are loaded.
      (let* ((loaded-patches (system-loaded-patches system))
	     (first-patch (first (patch-version-list loaded-patches)))
	     (highest-version (version-number first-patch)))
	(note-patches-loaded (system-environment system) system highest-version))
      (return-from add-patch-system nil))
    (setq patch-system (make-patch-system
			 name-and-atom (patch-system-name-and-atom system)
			 version *version*)
	  patch-dir (read-patch-directory patch-system)
	  first-vers (first (patch-dir-version-list patch-dir))
	  status (patch-dir-status patch-dir))
    ;; Flush old patch system if there is one
    (flush-patch-caches system)
    (unless (eql (version-number first-vers) 0)
      (ferror "Patch directory for ~A messed up: ~S" system first-vers))
    (setf (patch-status patch-system) status)
    ;; Stash first (noop) patch; others, if any, must still be loaded
    (setf (patch-version-list patch-system) (ncons first-vers))
    (setf (system-loaded-patches system) patch-system)
    (note-patches-loaded (system-environment system) system 0)
    ;; Special behavior for the "System" system
    (when (string-equal (system-short-name system) 'system)
      #+cadr (aset *version* #'si:system-communication-area si:%sys-com-major-version)
      #+(or 3600 imach) (setq si:syscom-major-version-number *version*
			      si:syscom-minor-version-number 0))	;not patched yet
    (values *version* status (cdr (patch-dir-version-list patch-dir)))))

;; Given the name of a system, this increments the major version as seen in the master
;; directory on the file computer.
(defun increment-system-major-version (name status &optional only-update-on-disk)
  (let* ((system (find-system-named name t nil))
	 (old-patch-dir (system-cached-patch-dir system))
	 (old-patch-dir-info (system-cached-patch-dir-file-info system))
	vers-num)
    (unwind-protect
	(multiple-value-bind (dir-file nil plist versions)
	    (read-system-directory system t)
	  (unless dir-file
	    (sct-inform "~&No system directory for ~A, creating one" system))
	  (unless plist
	    (setq plist (make-system-attributes name (system-patch-atom system))))
	  ;; Update the system-dir, but only on disk (in-core gets done later)
	  (putprop plist (setq vers-num (1+ (or (eval (cl:getf (cdr plist) :latest))
						0))) :latest)
	  (write-system-directory system dir-file plist versions)
	  ;; Write the new patch-directory
	  (when (system-patchable system)
	    (let* ((first-vers
		     (make-patch-version
		       number 0
		       date (time:get-universal-time)	;time-stamp it!
		       explanation (format nil "~A version ~@(~D~) loaded."
				     (system-short-name system) vers-num)
		       reviewer nil))
		   (patch-system
		     (make-patch-system
		       name-and-atom (patch-system-name-and-atom system)
		       version vers-num
		       status status
		       version-list (ncons first-vers))))
	      (write-patch-directory patch-system
				     (make-patch-dir status status
						     version-list (ncons first-vers))
				     t)
	      ;; Don't update LOADED-PATCHES if we are only hacking the journal files
	      (unless only-update-on-disk
		(setf (system-loaded-patches system) patch-system)))))
      (when only-update-on-disk
	;; If we only updated on disk, restore the saved patch-dir state
	(setf (system-cached-patch-dir system) old-patch-dir)
	(setf (system-cached-patch-dir-file-info system) old-patch-dir-info)))
    ;; Return the version number to a higher authority
    vers-num))

;; Requires a keyword version designator
(defun get-system-major-version-from-directory (name version-designator &optional no-error-p)
  (let ((system
	  (with-stack-list (s name version-designator nil)
	    (find-system-named s t t))))
    ;; Quick check for unversioned systems
    (when (not (system-maintain-journals system))
      (return-from get-system-major-version-from-directory :newest))
    (when (numberp version-designator)
      (ferror "Illegal to try to look up a number for a number!"))
    ;; :NEWEST means look up the :LATEST version in the system directory
    (when (eq version-designator :newest)
      (setq version-designator :latest))
    (multiple-value-bind (dir-file nil plist)
	(read-system-directory system t)
      (when (null dir-file)
	(if no-error-p
	    (return-from get-system-major-version-from-directory nil)
	  (ferror "No system directory exists for system ~A" system)))
      (or (eval (cl:getf (cdr plist) version-designator))
	  (if no-error-p
	      (return-from get-system-major-version-from-directory nil)
	    (ferror "There is no major version number recorded for version ~@(~A~) of ~A"
	      version-designator system))))))

;; Read in a patch directory file, returning the list-structure representation.
(defun read-patch-directory (patch-system &optional no-error-p)
  (declare (values patch-dir file-creation-date))
  (error-restart ((error) "Retry reading patch directory for ~A"
		  (patch-name patch-system)) 
    (let ((path (patch-system-pathname (patch-system patch-system)
				       :patch-directory
				       (patch-version patch-system)))
	  (system (patch-system patch-system))
	  file-info)
      (return-from read-patch-directory
	;; Use the cached patch-dir if possible
	(if (equal (system-cached-patch-dir-file-info system)
		   (with-open-file-case (probe-stream path :direction :probe
							   :if-does-not-exist :error)
		     (fs:file-not-found (return-from read-patch-directory nil))
		     (:no-error (setq file-info (send probe-stream :info)))))
	    (values (system-cached-patch-dir system)
		    (cdr file-info))
	  (with-open-file-case-if no-error-p
				  (stream path :direction :input
					       :if-does-not-exist :error)
	    (fs:file-not-found (return-from read-patch-directory nil))
	    (:no-error
	      ;; Make sure that the file stream gets closed non-abortedly!
	      (with-patch-directory-bindings
		(let ((patch-dir (copytree (read stream))))
		  ;; Cache the newly read patch-dir
		  (setf (system-cached-patch-dir system) patch-dir)
		  (setf (system-cached-patch-dir-file-info system) (send stream :info))
		  (values patch-dir
			  (send stream :creation-date)))))))))))

;; Read in a patch directory file, returning the list-structure representation.
(defun uncached-read-patch-directory (system version &optional never-probe)
  (let ((system (find-system-named system t t)))
    (when (not (system-patchable system))
      (return-from uncached-read-patch-directory nil))
    (error-restart ((error) "Retry reading patch directory for ~A"
		    (system-name system))
      (let ((path (patch-system-pathname system :patch-directory version)))
	(return-from uncached-read-patch-directory
	  ;; Use the cached patch-dir if possible
	  (if (and (not never-probe)
		   (equal (system-cached-patch-dir-file-info system)
			  (with-open-file-case (probe-stream path :direction :probe
								  :if-does-not-exist :error)
			    (fs:file-not-found
			      (return-from uncached-read-patch-directory nil))
			    (:no-error
			      (send probe-stream :info)))))
	      (system-cached-patch-dir system)
	    (with-open-file-case (stream path :direction :input
					      :if-does-not-exist :error)
	      (fs:file-not-found (return-from uncached-read-patch-directory nil))
	      (:no-error
		(with-patch-directory-bindings
		  (let ((patch-dir (read stream)))
		    (values patch-dir)))))))))))

;; Write out a patch directory file from the list-structure representation
;; and return the file info.
(defun write-patch-directory (patch-system patch-dir &optional first-time)
  (error-restart ((error) "Retry writing patch directory for ~A"
		  (patch-name patch-system))
    (let ((file (patch-system-pathname (patch-system patch-system)
				       :patch-directory
				       (patch-version patch-system)))
	  (system (patch-system patch-system)))
      (with-open-file-case (s file :direction :probe-directory
			      :if-does-not-exist :error)
	((fs:directory-not-found fs:file-not-found)
	 (fs:create-directories-recursively file)))
      (with-open-file (stream file :direction :output)
	(write-patch-directory-to-stream stream patch-system patch-dir first-time)
	(send stream :close)			;make :INFO valid
	(let ((file-info (send stream :info)))
	  (setf (system-cached-patch-dir system) patch-dir)
	  (setf (system-cached-patch-dir-file-info system) (send stream :info))
	  file-info)))))

;; Separate the part within the open stream to allow GUARDING-PATCH-DIRECTORY-MODIFICATION
;; to abort or finish the file output, as needed.
(defun write-patch-directory-to-stream (stream patch-system patch-dir &optional first-time)
  (with-patch-directory-bindings
    (if first-time
	(condition-case (error)
	     (send stream :change-properties t :generation-retention-count 2)
	   ((fs:unknown-property fs:unknown-operation))	;Common, don't complain.
	   (fs:file-error
	     (sct-warn
		 "Warning:  Can't set generation retention of ~A patch directory.~@
		  Error was ~~A~"
	       (patch-name patch-system) error))))
    (let ((si:print-readably t)
	  (system (patch-system patch-system)))
      (format stream
	  ";;; -*- Mode: Lisp; Package: ZL-User; Base: 10.; Patch-File: T -*-~@
	   ;;; Patch directory for ~A version ~D~%"
	system (patch-version patch-system))
      (write-responsibility-comment stream)
      (format stream "(~S~% (" (patch-dir-status patch-dir))
      (let* ((patches (patch-dir-version-list patch-dir))
	     (number-of-patches (length patches)))
	(tv:noting-progress
	    ((format nil " Patch directory for ~A version ~D"
	       system (patch-version patch-system)))
	  (loop for patch in patches
		for i from 0
		do (tv:note-progress i number-of-patches)
		   (format stream "~S~%  " patch))))
      (format stream "))"))))

;; Say who did it: which hardware, which firmware, which software, and which meatware.
(defun write-responsibility-comment (stream)
  (format stream ";;;  -*- Mode: LISP; Base: 10; Syntax: Zetalisp -*-~
	       ~2%;;; Written ~\DATIME\ by ~A,~
	        ~%;;; while running on ~A from ~:[band ~C~;~A~]~
	        ~%~A.~2%"
    (if (and (boundp 'zwei:*current-patch*)
	     (not (null zwei:*current-patch*))
	     (zwei:patch-state-author zwei:*current-patch*)
	     (not (string-equal user-id (zwei:patch-state-author zwei:*current-patch*))))
	(format nil "~A (logged in as ~A)"
	  (zwei:patch-state-author zwei:*current-patch*) user-id)
      user-id)
    si:local-pretty-host-name
    t (si:loaded-band-name)
    (formatted-system-version-info ";;; " "" "with " 86.)))


;; This condition exists so collect-new-patch-systems can present a reasonable
;; error to the user when a subprocess gets an error.
(defflavor load-patches-error-on-host
	(host error system-names)
	(error)
  :initable-instance-variables
  :readable-instance-variables)

(defmethod (dbg:report load-patches-error-on-host) (stream)
  (format stream "An error occurred while checking file dates on host ~A:~%~A" host error))

(defmethod (sys:proceed load-patches-error-on-host :skip-loading-patches) ()
  (values :skip-loading-patches))

(defun abbreviated-systems-list-for-load-patches-error (system-names)
  (let ((n (length system-names)))
    (scl:format-textual-list (if (> n 3)
				 (list (first system-names)
				       (second system-names)
				       (format nil "~D others" (- n 2)))
				 system-names)
			     #'princ
			     :conjunction "and"
			     :stream format:*format-output*)))

(defmethod (dbg:document-proceed-type load-patches-error-on-host :skip-loading-patches)
	   (stream)
  (format stream "Skip loading patches for the system~P on host ~A (~VQ)"
	  (length system-names) host
	  system-names #'abbreviated-systems-list-for-load-patches-error))

(defmethod (sys:proceed load-patches-error-on-host :retry-operation) ()
  (values :retry-operation))

(defmethod (dbg:document-proceed-type load-patches-error-on-host :retry-operation) (stream)
  (format stream "Retry checking file dates on host ~A" host))

(compile-flavor-methods load-patches-error-on-host)

;; Given a list of PATCH-SYSTEMs, return the sublist of those which have a newer
;; patch-directory file, and therefore actually need to be loaded.  Reading those
;; files can be lengthy.
(defun collect-new-patch-systems (patchable-system-list)
  (let* ((pathnames
	   (loop for patchable-system in patchable-system-list
		 collect (list
			   (patch-system-pathname (patch-system patchable-system)
						  :patch-directory
						  (patch-version patchable-system))
			   (patch-name patchable-system))))
	 (host-pathname-alist (loop with l and h and s
				    for (p n) in pathnames
				    do (setq h (send (send p :translated-pathname) :host)
					     s (assq h l))
				       (if s (progn (push p (second s))
						    (push n (third s)))
					 (push (list h (list p) (list n)) l))
				    finally (return l)))
	 (host-plist-alist (si:parallel-mapcar '(:whostate "Probe patch directories"
						 :name     "Probe Patch Directories")
			     (lambda (alist-entry)
			       (list (first alist-entry)
				     (condition-case (error)
					  (fs:multiple-file-plists (second alist-entry))
					((fs:file-error net:network-error) error))
				     (third alist-entry)))
			     host-pathname-alist))
	 (plists (loop for (host plists names) in host-plist-alist
		       do (setq names (nreverse names))
		       when (or (cl:consp plists)
				(dbg:with-extra-debugger-menu-conditions
				    (load-patches-error-on-host)
				  (signal-proceed-case (() 'load-patches-error-on-host
							:host host :error plists
							:system-names names)
				    (:retry-operation
				      (catch-error-restart
					((error)
					 "Skip loading patches for the system~P on host ~A (~VQ)"
					 (length names) host
					 names
					 #'abbreviated-systems-list-for-load-patches-error)
					(setq plists (fs:multiple-file-plists
						       (second
							 (assq host host-pathname-alist)))))
				      (cl:consp plists))
				    (:skip-loading-patches nil))))
			 append plists)))
    (loop for pathname in pathnames
	  for patchable-system in patchable-system-list
	  as plist = (cdr (assq (first pathname) plists))
	  as system = (patch-system patchable-system nil)
	  when (and plist system
		    (let ((p (system-loaded-patch-dir-creation-date system)))
		      (not (and p (eql (cl:getf plist :creation-date) p)))))
	    ;; Only collect those systems whose patch-dirs have changed and
	    ;; for which we managed to get the property-lists above
	    collect patchable-system)))

(defvar system-status-alist '((:experimental "Experimental" "Exp" "experimental")
			      (:released "" "" "released")
			      (:frozen "Frozen" "Froze" "frozen")
			      (:obsolete "Obsolete" "Obs" "obsolete")
			      (:broken "Broken" "Broke" "broken")))

(defconst broken-system-message
	  "Loading the latest patches for ~A will set its status to /"Broken/".~@
           This means that the maintainers feel that one of the patches you are~@
           about to load may cause severe problems if loaded.~@
           Are you sure you want to load patches for ~A? ")

(defvar-standard *dangerous-patch-action* :skip :skip :skip
		 (memq *dangerous-patch-action* '(:skip :query :load)))

(defvar-standard *loading-patch-pathname* nil nil nil)
(defvar-standard *loading-patches-for-system* nil nil nil)
(defvar-standard *patch-systems-to-retry* nil nil nil)

(defmacro with-dangerous-patch-action ((action) &body body)
  `(progn
     (cl:assert (cl:typep ,action '(cl:member :skip :query :load)))
     (let ((*dangerous-patch-action* ,action))
       ,@body)))

(defun (compiler:style-checker action-ok with-dangerous-patch-action) (form)
  (let ((action-form  (first (second form))))
    (when (cl:constantp action-form)
      (let ((action-symbol
	      (cond ((symbolp action-form) action-form)
		    ((and (listp action-form)
			  (= (length action-form) 2)
			  (eq (first action-form) 'quote))
		     (second action-form))
		    (t
		     (compiler:warn '(:fatal t)
			 "~S is not a valid dangerous patch action." action-form)))))
	(unless (memq action-symbol '(:skip :query :load))
	  (compiler:warn '(:fatal t)
	      "~S is not a valid dangerous patch action." action-form))))))

(defprop dangerous-patch warn-if-at-top-level compiler:top-level-form)

(defun warn-if-at-top-level (form)
  (cl:warn "~S should not be used at top level." (car form))
  form)

(defun dangerous-patch (format-string &rest format-args)
  (let ((dpa *dangerous-patch-action*)
	(relevant-pathname (or *loading-patch-pathname* sys:fdefine-file-pathname))
	;; This local used to be initialized to (AND (VARIABLE-BOUNDP *SILENT-P*) *SILENT-P*).
	;; This is the wrong thing to do, because *SILENT-P* is for gagging normal output,
	;; not error messages, which output from this function is, in effect.
	(silent nil)
	(query-forced nil))
    (flet ((expound ()
	     (format query-io "~2&The patch file ~A cannot be loaded routinely.~%"
	       (or relevant-pathname "being loaded"))
	     (si:with-indentation (query-io 2)
	       (lexpr-funcall #'format query-io format-string format-args))))
      (loop doing
	(block retry
	  (selectq dpa
	    (:skip
	     (cond ((not (null *loading-patch-pathname*))
		    (when *loading-patches-for-system* 
		      (unless silent
			(expound)
			(format query-io "~&No more patches can be loaded for system ~A."
			  (system-name *loading-patches-for-system*))))
		    (throw 'skip-current-patch nil))
		   (t
		    (when query-forced		        ; a kludgy escape -- only works if
		      (throw 'si:bin-load-done nil))	; loading via SI:BIN-LOAD-TOP-LEVEL
		    (setq dpa :query
			  query-forced t)
		    (return-from retry nil))))
	    (:load
	     (return-from dangerous-patch nil))
	    (:query
	     (expound)
	     (let ((action
		     (dw:with-accept-help
			 (((:subhelp :override) "")
			  ((:top-level-help :override)
			   (lambda (stream ignore)
			     (format stream "~&Choose an action:~%")
			     (dw:with-output-as-presentation
			         (:stream stream
				  :object ':skip
				  :type '((cl:member :skip :load))
				  :single-box t)
			       (format stream
				   "~&Skip loading~@[ further patches for system ~A~]."
				 (and *loading-patches-for-system*
				      (system-name *loading-patches-for-system*))))
			     (dw:with-output-as-presentation
			         (:stream stream
				  :object :load
				  :type '((cl:member :skip :load))
				  :single-box t)
			       (format stream "~&Load ~A even though it is dangerous."
				 (or relevant-pathname "the patch"))))))
		       (scl:accept '((cl:member :skip :load))
				   :prompt "Skip or Load?"))))
	       (setq dpa action)
	       (when (eq dpa :skip) (setq silent t))	;don't print twice
	       (return-from retry)))))))))

;; Ask user whether to load the patches that aren't loaded yet for a given system.
;; Returns T if anything changed, otherwise NIL.
;; SYSTEMS can be :ALL (or NIL), :LOCAL, or a list of systems
;;--- Make this take real keyword args in Release 8
(defun load-patches (&rest args)
  (declare (arglist &optional systems
		    &key (query t) silent no-warn reload (include-components t)
			 (excluding nil)
			 (dangerous-patch-action *dangerous-patch-action*)
			 (machine-type *current-machine-type*)))
  (if (and (keywordp (first args))
	   (not (memq (first args) '(:all :local))))
      (dwimify-old-load-patches args)
    (fs:force-user-to-login)
    (let* ((systems (first args))
	   (query (if (cl:member :query args) (cl:getf (cdr args) :query) t))
	   (silent (cl:getf (cdr args) :silent))
	   (no-warn (cl:getf (cdr args) :no-warn))
	   (reload (cl:getf (cdr args) :reload))
	   (include-components (cl:getf (cdr args) :include-components t))
	   (excluding (cl:getf (cdr args) :excluding nil))
	   (dangerous-patch-action (cl:getf (cdr args) :dangerous-patch-action
					    *dangerous-patch-action*))
	   (machine-type (cl:getf (cdr args) :machine-type *current-machine-type*))
	   (environment (find-environment machine-type)))
      (let* ((*query-type* :normal)
	     (*query-p* query)
	     (*silent-p* silent)
	     (*batch-p* nil)
	     (*current-machine-type* machine-type)
	     (something-changed nil)
	     (inhibit-fdefine-warnings no-warn)
	     (compiler:suppress-compiler-warnings no-warn))
	(canonicalize-state-variables)
	(catch-error-restart ((error) "Skip LOAD-PATCHES entirely")
	  (when (null systems) (setq systems :all))
	  (setq systems (patchable-systems-list environment systems))
	  (when (null systems) (return-from load-patches nil))
	  (when (nlistp systems) (setq systems (list systems)))
	  ;; Use the plan-builder to order the patch-loading.  If the user did not ask
	  ;; to include components, believe the ordering he gave us.
	  (if include-components
	      (setq systems (order-load-patches-dependencies systems))
	      (setq systems (mapcar #'find-system-named systems)))
	  ;; Get rid of systems we don't want to load patches for.
	  (when excluding
	    (when (nlistp excluding)
	      (setq excluding (list excluding)))	;dwim
	    (setq excluding (mapcar #'find-system-named excluding))
	    (setq systems (cl:set-difference systems excluding)))
	  ;; Now filter out unpatchable or not fully-loaded systems, and
	  ;; at the same convert the list of systems to a list of patch-systems.
	  (setq systems
		(loop for system in systems
                      as patch-system =
			 (catch-error-restart ((error) "Skip loading patches for ~A" system)
			   (get-patchable-system-named system t))
		      when patch-system		;could possibly be not loaded yet
			collect patch-system))
	  ;; Load patches only for systems whose patch directory has changed,
	  ;; except when reloading, when, of course, we load patches regardless
	  (unless reload
	    (setq systems (collect-new-patch-systems systems)))
	  (let ((first-system t)		;this is the first system being patched.
		patch-dir file-creation-date)
	    (si:inhibit-lengthy-background-updates
	      (si:sorting-modified-aarrays-if si:*enable-aarray-sorting-after-loads*
		(unwind-protect
		    (loop as *patch-systems-to-retry* = nil
			  as something-changed-this-time = nil
			  doing
		      ;; Don't update anything until we are completely done
		      (dolist (patch systems)
			(catch 'skip-current-system
			  (catch-error-restart ((error)
						"Skip loading patches for ~A"
						(patch-name patch))
			    (let ((*loading-patches-for-system*
				    (find-system-named (patch-name patch) nil nil t)))
			      (condition-case ()
				   (multiple-value (patch-dir file-creation-date)
				     (read-patch-directory patch))
				 (fs:file-lookup-error
				   (sct-warn
				     "Warning: Cannot find patch system directory for ~A ~D; ~
				      patches will not be loaded."
				     (patch-name patch) (patch-version patch))
				   (go end-loop)))
			      (multiple-value-bind (aborted changed)
				  (with-dangerous-patch-action (dangerous-patch-action)
				    (load-patch-directory
				      environment patch-dir patch
				      first-system file-creation-date
				      :query (memq *query-type* '(:normal :selective))
				      :silent *silent-p* :reload reload))
				(when (eq aborted 'aborted)
				  (go end-loop))
				(when changed
				  (setq something-changed-this-time t)
				  (setq something-changed t))))))
			(setq first-system nil)
			end-loop)	;jump to this tag to abort one system
		      ;; If there are no systems to retry, or nothing was loaded this time
		      ;; around, then we're done.  (The second condition keeps us from
		      ;; looping forever when there are unfinished patches.)  Otherwise,
		      ;; collect the systems which we need to retry, and retry them.
		      (if (or (null *patch-systems-to-retry*)
			      (not something-changed-this-time))
			  (return)
			(setq systems (loop for system in *patch-systems-to-retry*
					    collect (get-patchable-system-named system t)))))
		  ;; Keep the software-info up to date.
		  (neti:compute-finger-string)))))
	  something-changed)))))

(defmethod (patchable-systems-list lisp-world-environment) (systems)
  (when (memq systems '(:all :local))
    ;; If no specific systems were specified, check for updated logical host
    ;; definitions.  Do this first, because some patch might depend upon it.
    (reload-logical-pathnames-translation-files :query *query-p* :silent t)
    (setq systems (if (eq systems :all)
		      (loop for patch-system in (patch-systems-list)
			    collect (patch-name patch-system))
		      (loop with local-site = (send net:*local-site* :name)
			    for patch-system in (patch-systems-list)
			    as system = (patch-system patch-system)
			    as maintaining-sites = (system-maintaining-sites system)
			    when (or (null maintaining-sites)
				     (memq local-site maintaining-sites))
			      collect (patch-name patch-system)))))
  systems)

(defun reload-logical-pathnames-translation-files (&key (query nil) (silent t))
  (let ((*current-machine-type* *local-machine-type*))
    (catch-error-restart (error "Skip loading updated logical host definitions")
      (load-system 'logical-pathnames-translation-files
		   :version :newest		;never read in the system-dir
		   :no-reload-system-declaration t
		   :dont-set-version t		;never, ever...
		   :load-patches nil
		   :query query :silent silent))))

(define-system-operation :load-patches
  nil nil
  :encache :nothing
  :class :normal
  :subsystems-ok nil
  :no-top-level-function t)

;; For a bunch of systems, construct a plan to order them so that patches
;; load in the "correct" order
(defun order-load-patches-dependencies (systems)
  (let ((*version* :newest)
	(*component-system-info* nil)
	(*system-caches-to-flush* nil)
	;; Progress notes are just too distracting here
	(*maintain-sct-progress-note* nil)
	(system-op :load-patches)
	(top-level t)
	(keys `(:version :newest
		:machine-types ,(list *current-machine-type*)
		:additional-plan-constructor ,#'make-plan-for-loading-patches
		:no-reload-system-declaration t)))
    (flet ((build-patch-plan (system)
	     (if (eq (system-modules system) :need-to-reload-system-declaration)
		 ;; Fallback does not necessarily get the right ordering
		 (loop for component in (system-component-systems system)
		       when (typep component 'system)
			 collect component)
	       ;; Build the plan for a system in the simplest possible way
	       ;; which is sure to get the proper ordering
	       (let ((*system* system))
		 (with-plan-for-system (plans system-op top-level keys)
		   (setq plans (lexpr-funcall #'flatten-plans-for-components
					      plans nil
					      :include-components t
					      keys))
		   (setq plans (si:eliminate-duplicates
				 plans #'(lambda (x y)
					   (equal (plan-inputs x) (plan-inputs y)))))
		   ;; Now return all of the systems (we don't need to execute the
		   ;; plans, we just need to extract the system objects)
		   (loop for plan in plans nconcing (plan-inputs plan)))))))
      (loop for system-name in systems
	    as system = (find-system-named system-name)
	    ;; Cache and reuse the plans for the system since the general
	    ;; computation is not as fast as we would like
	    as plans = (or (system-load-patches-plan system)
			   (setf (system-load-patches-plan system)
				 (append (build-patch-plan system) (list system))))
	    nconcing (copylist plans) into ordered-systems
	    finally (return (si:eliminate-duplicates ordered-systems))))))

(defun make-plan-for-loading-patches (system-op &rest keys)
  (ignore system-op keys)
  (when (and (system-patchable *system*)
	     (numberp (system-version-loaded *system*)))
    (let ((plan (make-plan nil *system*
			   :inputs (list *system*)
			   :never-query t
			   :driving-function
			   #'(named-lambda load-patches-driver
					   (system ignore ignore &rest keys)
			       (ignore keys)
			       system)
			   :documentation nil)))
      (values nil (list plan)))))

;;--- Remove this for Release 8
(defun dwimify-old-load-patches (args)
  (loop with systems and silent and query and no-warn and arglist and tem
	for opts on args
	as opt = (first opts)
	do (selectq opt
	     (:systems
	      (setq opts (cdr opts))
	      (setq systems
		    (loop for sys-name in
			      (if (listp (car opts)) (car opts) (list (car opts)))	;DWIM
			  collect (get-patchable-system-named sys-name))))
	     (:silent (setq silent t query nil))
	     (:verbose (setq silent nil))
	     (:selective (setq query t silent nil))
	     (:noselective (setq query nil))
	     (:nowarn (setq no-warn t))
	     (otherwise
	      (when (and (or (symbolp (car opts)) (stringp (car opts)))
			 (setq tem (get-patchable-system-named (car opts))))
		(setq systems (nconc systems (ncons (patch-name tem)))))))
	finally (unless systems
		  (setq systems :all))		;load patches for all systems
		(setq arglist (ncons systems))
		(unless (eq query t)
		  (setq arglist (nconc arglist (list :query query))))
		(when silent
		  (setq arglist (nconc arglist (list :silent silent))))
		(when no-warn
		  (setq arglist (nconc arglist (list :no-warn no-warn))))
		(format t "~& Note: ~(LOAD-PATCHES ~{~S~^ ~})~%is an old-style call ~
				      to LOAD-PATCHES.  It will be evaluated as ~%~
				      (LOAD-PATCHES ~{~S~^ ~}).~" args arglist)
		(return (lexpr-funcall #'load-patches arglist))))

(defun load-and-save-patches ()
  (let ((services-enabled net:*services-enabled*))
    (si:disable-services)
    (let ((tv:more-processing-global-enable nil))
      (fs:with-automatic-login-to-sys-host	;OPEN will FS:FORCE-USER-TO-LOGIN
	(cond ((lexpr-funcall #'load-patches :all '(:query nil :silent t))
	       (setq tv:more-processing-global-enable t)
	       (disk-save))
	      (t (format query-io "~&No patches have been made")))
	(and services-enabled (si:enable-services services-enabled))))))

(defun load-patch-directory (environment patch-dir patch-system
			     first-system file-creation-date
			     &key query silent reload)
  (declare (values aborted something-changed))
  (let ((something-changed nil)
	aborted)
    (setq
      aborted
      (block didnt-load-any-patches
	(let* ((new-versions (patch-dir-version-list patch-dir))
	       (high-vers (caar (last new-versions)))	;highest patch number for system
	       (first-patch-p t)			;the first patch to this system
	       (change-status-p t)			;OK to change the system status
	       (proceed-flag (not query))		;has the user said to proceed?
	       (highest-flag nil)			;has a highest-patch-to-load been set?
	       (highest-version-to-load high-vers)
	       (highest-version-loaded nil)
	       (system-being-patched (patch-system patch-system nil)))
	  (when system-being-patched
	    (setf (system-loaded-patch-dir-creation-date system-being-patched) nil))
	  (when (and (eq (patch-dir-status patch-dir) :broken)
		     (neq (patch-status patch-system) :broken)
		     (not (fquery format:yes-or-no-p-options broken-system-message
			    (patch-name patch-system) (patch-name patch-system))))
	    (return-from didnt-load-any-patches 'aborted))
	  (block didnt-load-all-patches
	    (dolist (version			;work even if current patch deleted
		      (memass #'<
			      (if reload 0	;maybe he wants to reload everything?
				(version-number (first (patch-version-list patch-system))))
			      new-versions))
	      (let* ((present-vers (version-number version)))
		(if (null (version-explanation version))
		    ;; NIL is used to mark patches that are reserved, but not finished.
		    ;; We can't load any more patches without this one, in order to
		    ;; make sure that any two systems claiming to be version xx.yy
		    ;; always have exactly the same set of patches loaded.  So punt.
		    (return-from didnt-load-all-patches
		      (unless silent
			(report-unfinished-patches present-vers new-versions patch-system)))
		  (when (and first-patch-p (not silent))
		    (format t "~&~:[~%~]Patches for ~A (Current version is ~D.~D):"
		      first-system (system-pretty-name system-being-patched)
		      (patch-version patch-system) high-vers))
		  (when (and highest-flag
			     (> present-vers highest-version-to-load))
		    ;; If this patch is past the limit, load no more.
		    (setq change-status-p nil)	;and don't change the status
		    (return-from didnt-load-all-patches nil))
		  (unless silent
		    (report-patch-contents (patch-version patch-system) version))
		  (selectq-every (load-patch-previous-setting-or-proceed-query
				   proceed-flag highest-flag)	;select on answers to query
		    (nil			;"No", don't load any more for this system
		      (setq change-status-p nil); also don't change the status
		      (return-from didnt-load-all-patches nil))
		    (highest			;"Highest", query for a number
		      (setq highest-version-to-load	;will be present-vers  N  high-vers
			    (load-patches-highest-minor-version-query
			      high-vers present-vers))
		      (setq highest-flag t))
		    (proceed			;"Proceed" with the rest for this system.
		      (setq proceed-flag t))
		    ((t proceed highest)	;"Yes" or "Proceed" or "Highest", do this one
		     (block load-a-patch
		       (catch 'skip-current-patch
			 (condition-case ()
			      (load-patch environment
					  patch-system present-vers silent
					  (null (version-date version)))
			    ;;--- This will catch f-n-f errors produced when
			    ;;--- a patch tries to load another file.
			    (fs:file-not-found
			      (unless silent
				(diagnose-missing-patch-binary patch-system version))
			      (return-from didnt-load-all-patches nil)))
			 (setq something-changed t
			       highest-version-loaded present-vers)
			 (when (string-equal (patch-name patch-system) 'system)
			   (setq sys:syscom-minor-version-number present-vers)
			   #+imach
			   (sys:system-case
			     (embedded (setf (sys:emb-guest-minor-version) present-vers))
			     (otherwise nil)))
			 (push version (patch-version-list patch-system))
			 (return-from load-a-patch nil))
		       (return-from didnt-load-all-patches nil))))))
	      (setq first-patch-p nil))
	    ;; All patches from the patch directory are loaded; save the file creation date.
	    (when system-being-patched
	      (setf (system-loaded-patch-dir-creation-date system-being-patched)
		    file-creation-date)))
	  (when change-status-p
	    (when (update-patch-system-status patch-dir patch-system silent)
	      (setq something-changed t)
	      (when system-being-patched
		(unless highest-version-loaded
		  ;; Need to force a call to note-patches-loaded to record status change.
		  (setq highest-version-loaded (version-number (first (patch-version-list
									patch-system))))))))
	  (when (and system-being-patched highest-version-loaded)
	    (note-patches-loaded environment system-being-patched highest-version-loaded))
	  nil)))
    (values aborted something-changed)))

(defun report-unfinished-patches (present-vers new-versions patch)
  (let* ((remaining-vers (memass #' present-vers new-versions))
	 (culprits (loop for vers in remaining-vers
			 when (null (version-explanation vers))
			   collect vers))
	 (n-culprits (length culprits)))
    (sct-warn "There ~:[are~;is an~] unfinished patch~:*~:[es~;~] in ~A:~@
	       ~:{   ~D.~D, by ~A, started ~A~%~}"
      (= n-culprits 1)
      (system-pretty-name (patch-system patch))
      (loop for culp in culprits
	    collect (list (system-version-loaded (patch-system patch))
			  (version-number culp)
			  (version-author culp)
			  (and (numberp (version-date culp))
			       (time:print-brief-universal-time (version-date culp) nil)))))))

(defun report-patch-contents (major version)
  (format t "~&~D.~D~9T" major (version-number version))
  (si:with-indentation (standard-output 9)
    (let ((time (and (numberp (version-date version))
		     (time:print-brief-universal-time (version-date version) nil))))
      (format t " (~A)~@[  (reviewed by ~A)~]~@[  (created ~A)~]~&~A"
	(version-author version) (version-reviewer version) time
	(version-explanation version)))))

(defun load-patch-previous-setting-or-proceed-query (proceed-flag highest-flag)
  (cond ((or proceed-flag highest-flag))
	(t (format t "  ")
	   (fquery `(:fresh-line ,(neq query-io standard-output)
		     :choices
		     (((t "Yes.") #/Y #/Space #/T)
		      ((nil "No.") #/N #/Rubout)
		      ((proceed "Proceed.") #/P)
		      ((highest "Highest.") #/H)))
	       "Load? "))))

(defun load-patches-highest-minor-version-query (high-vers present-vers)
  ;; Query for a limit on the minor version numbers to load
  (scl:accept `((cl:integer ,present-vers ,high-vers))
	      :prompt "    Highest patch number to load"
	      :default high-vers))

(defun diagnose-missing-patch-binary (patch version)
  (sct-warn
      "(Patch file for ~A ~D.~D has not yet been compiled for the ~A;~@
        no further patches for ~0@*~A can be loaded.)"
    (patch-name patch) (patch-version patch) (version-number version)
    (string-capitalize-words *current-machine-type*))
  (let ((sites (system-maintaining-sites (patch-system patch))))
    (when (and sites (not (memq (send net:*local-site* :name) sites)))
      (sct-warn
	  "(The patches may not have been correctly distributed from ~{~A~^ or ~})"
	sites))))

(defun update-patch-system-status (patch-dir patch silent)
  (let ((new-status (patch-dir-status patch-dir)))
    (when (neq (patch-status patch) new-status)
      (unless silent
	(format standard-output "~&The loaded version of ~A (~D) is now ~A."
	  (patch-system patch) (patch-version patch)
	  (fourth (assq new-status system-status-alist))))
      (setf (patch-status patch) new-status)      ;update the status
      t)))

(defun patch-binary-pathname (system major-version minor-version
			      &optional (environment (system-environment system)))
  (patch-system-pathname system :patch-file major-version minor-version
			 ;; This is a kludge until we figure out how to
			 ;; patch documentation systems.
			 (if (eq (system-default-module-type system) :sage)
			     :bin
			     (default-binary-file-type environment))))

;; Load a patch file.  This loads it from the right place.  It also suppresses the
;; unwanted error checking in LOAD.
;;--- Currently, all patches have to be .BIN files for this to work
(defmethod (load-patch lisp-world-environment) (patch-system number silent
						&optional get-date)
  (let* ((system (patch-system patch-system))
	 (*loading-patch-pathname* 
	   (patch-binary-pathname system (patch-version patch-system) number self))
	 (*eco-system* system)
	 (*eco-major-version* (system-version-loaded system))
	 (*eco-minor-version* number))
    (error-restart ((error) "Retry loading patch file ~A" *loading-patch-pathname*)
      (with-open-file (stream *loading-patch-pathname* :characters nil)
	(let ((patch-date (when get-date (send stream :creation-date))))
	  (si:load-binary-file-internal stream nil silent)
	  patch-date)))))

(defmethod (note-patches-loaded lisp-world-environment) (system highest-version)
  (declare (ignore environment system highest-version))
  nil)


;;; Creating new patches

(defflavor private-patch-info
	((description)
	 (pathname))
	()
  (:initable-instance-variables)
  (:writable-instance-variables))

(defun make-private-patch-info (&key description pathname)
  (make-instance 'private-patch-info :description description :pathname pathname))

;; The function (in GLOBAL) to add a private patch to the database.
(defun note-private-patch (string &optional force-pathname)
  (check-arg-type string :string)
  (setq string (cl:substitute #/space #/return string))
  (let ((patch-file-pathname (and (variable-boundp sys:fdefine-file-pathname)
				  sys:fdefine-file-pathname))	;loading a file
	(old-info (cl:find string *private-patch-info*
			   :test #'string-equal
			   :key #'private-patch-info-description))
	(truename
	  (and (variable-boundp si:fasl-generic-pathname-plist)
	       (get si:fasl-generic-pathname-plist :qfasl-source-file-unique-id))))
    ;; Perhaps we should retain the truename wholesale
    (when (and truename patch-file-pathname (cl:pathnamep truename))
      (setq patch-file-pathname
	    (send patch-file-pathname :new-pathname
		  :version (send truename :version)
		  :type (send truename :type))))
    (when force-pathname
      (setq patch-file-pathname (fs:parse-pathname force-pathname)))
    (if old-info
	(when patch-file-pathname
	  (setf (private-patch-info-pathname old-info) patch-file-pathname))
      (setq *private-patch-info*
	    (nconc *private-patch-info*
		   (ncons
		     (make-private-patch-info :description string
					      :pathname patch-file-pathname)))))))

(defun delete-private-patch-note (string)
  (setq *private-patch-info* (cl:delete string *private-patch-info*
					:key #'private-patch-info-description
					:test #'string-equal)))


;; There are a number of functions that read a patch-directory file, make a small
;; modification to the big form in it, and rewrite it immediately.  There is some
;; exposure, however, to loss and conflicts.  Suppose that A and B are patching
;; the same system at about the same time.  They both do m-X Start Patch, and
;; both read that system's patch directory.  A's machine gets to rewriting it
;; first, then B's.  Now the patch system says (in the latest file) that B has
;; opened patch N; A's ownership has been lost, and A has not been warned.  This
;; kind of exposure increases as the size of patch directories grows, and with
;; factors like server load.
;;
;; The present version tries to reduce the window of vulnerability to just a second or
;; two: it does a probe before writing the directory.  If that's OK, it opens the
;; file, writes it, but does another probe before closing it.  If still OK, it closes
;; the file; if not, it aborts the write.  So exposure to unguarded clashes is limited
;; to the time it takes to close the file.  Also on the horizon is the possibility of
;; absolute protection via a real distributed locking system.

;; The following are a set of utilities for modifying SCT journal files with
;; window protection.  They implement two window protection stategies: the
;; file-info checking strategy that existed in 7.0, and the new network lock
;; service.  (Note that the lock service is not quite here yet, but is
;; provided for.  We will probably turn it on under the control of a DEFSYSTEM
;; keyword at first.)

;; This assumes that there are a fixed set of journals identified by
;; keywords.  Otherwise, we have to pass around a bunch of functions
;; that can extract things from system objects.  More general, but
;; a big pain to code and get right.  Maybe on the next try.
(defconst *valid-journal-keywords*
	  `((:patch-directory
	      :major-version t :name "Patch directory"
	      :canonical-type :patch-patch-directory
	      :cached-file-info ,#'system-cached-patch-dir-file-info
	      :set-cached-file-info ,#'(cl:setf system-cached-patch-dir-file-info)
	      :cached-file ,#'system-cached-patch-dir
	      :set-cached-file ,#'(cl:setf system-cached-patch-dir))
	    (:system-directory
	      :major-version nil :name "System directory"
	      :canonical-type :patch-system-directory
	      :cached-file-info ,#'system-cached-system-dir-file-info
	      :set-cached-file-info ,#'(cl:setf system-cached-system-dir-file-info)
	      :cached-file ,#'system-cached-system-dir
	      :set-cached-file ,#'(cl:setf system-cached-system-dir))
	    (:component-directory
	      :major-version t :name "Component directory"
	      :canonical-type :patch-component-directory
	      :cached-file-info ,#'system-cached-component-dir-file-info
	      :set-cached-file-info ,#'(cl:setf system-cached-component-dir-file-info)
	      :cached-file #'system-cached-component-dir
	      :set-cached-file ,#'(cl:setf system-cached-component-dir))
	    (:vc-source-change-journal
	      :major-version t :name "Source Change Journal"
	      :canonical-type :vc-source-change-journal
	      :cached-file-info ,#'system-cached-vc-source-change-journal-file-info
	      :set-cached-file-info ,#'(cl:setf
					 system-cached-vc-source-change-journal-file-info)
	      :cached-file ,#'system-cached-vc-source-change-journal
	      :set-cached-file ,#'(cl:setf system-cached-vc-source-change-journal))))

(defmacro modifying-journal-file-locked
	  ((system file-contents journal-keyword file-read-function file-write-function
		   &key major-version)
	   &body body)
  `(with-journal-file-locked-internal
     ,system ,journal-keyword ,major-version ,file-read-function ,file-write-function
     #'(named-lambda with-journal-file-locked-internal
		     (,file-contents .return-new-contents.)
	 (declare (sys:downward-function))
	 (macrolet ((abort-journal-modification (&rest args)
		      `(throw 'abort-journal-modification ,@args))
		    (return-new-journal-contents (new)
		      `(funcall .return-new-contents. ,new))) 
	   ,@body))))

(defun with-journal-file-locked-internal (system journal-keyword major-version
					  file-read-function
					  file-write-function continuation)
  (cl:check-type system system)
  (unless (system-maintain-journals system)
    (ferror "System ~A does not maintain journals"))
  (let ((ji (cdr (assq journal-keyword *valid-journal-keywords*))))
    (unless ji
      (ferror "~S is not a valid system journal keyword" journal-keyword))
    (let ((major-version-needed (cl:getf ji :major-version))
	  (name (cl:getf ji :name)))
      (when (neq (not major-version-needed) (null major-version))
	(ferror "A major version must~:[ not~;~] be supplied for the ~A"
	  major-version-needed name))
      (let* ((pathname (patch-system-pathname system journal-keyword major-version))
	     ;; If no major version is relevant, then the cached version (if any)
	     ;; has to be for the right version.  For major-version-sensitive
	     ;; things, then only the version-loaded can be in the cache.
	     ;; Create one set of functions that close over state, rather than
	     ;; a different specific function for each kind of journal.
	     (cached-file-info-fun
	       (and (or (null major-version-needed)
			(eql major-version (system-version-loaded system)))
		    (cl:getf ji :cached-file-info)))
	     (cached-set-file-info-fun
	       (and cached-file-info-fun (cl:getf ji :set-cached-file-info)))
	     (cached-file-fun
	       (and cached-file-info-fun (cl:getf ji :cached-file)))
	     (set-cached-file-fun
	       (and cached-file-info-fun (cl:getf ji :set-cached-file))))
	(with-arbitrary-journal-locked-internal
	  system
	  name
	  pathname
	  file-read-function
	  file-write-function
	  cached-file-info-fun
	  cached-set-file-info-fun
	  cached-file-fun
	  set-cached-file-fun
	  continuation)))))

(defun with-arbitrary-journal-locked-internal
       (system journal-name journal-pathname file-read-function file-write-function
	cached-file-info-fun set-cached-file-info-fun cached-file-fun set-cached-file-fun 
	continuation)
  ;; Now we are ready to play with the lock server if we have it
  (with-arbitrary-journal-locked-internal-guarded
    system journal-name journal-pathname file-read-function file-write-function
    cached-file-info-fun set-cached-file-info-fun cached-file-fun set-cached-file-fun 
    continuation))

(defun with-arbitrary-journal-locked-internal-lock-1
       (system journal-name journal-pathname file-read-function file-write-function
	cached-file-info-fun set-cached-file-info-fun cached-file-fun set-cached-file-fun 
	continuation)
  ;; grab lock, if not, loop querying (?)
  (with-arbitrary-journal-locked-do-the-work
	    system journal-name journal-pathname file-read-function file-write-function
	    cached-file-info-fun set-cached-file-info-fun
	    cached-file-fun set-cached-file-fun 
	    continuation
	    #'cl:ignore
	    #'cl:ignore)
  ;; release lock
  )

(defun with-arbitrary-journal-locked-internal-guarded
       (system journal-name journal-pathname file-read-function file-write-function
	cached-file-info-fun set-cached-file-info-fun cached-file-fun set-cached-file-fun 
	continuation)
  (loop for first = t then nil doing
    (block collision
      ;; The contract here is to open the file, check the cache (if any),
      ;; and then call the body to try to update the file.
      (flet ((before-hook (file-info-read)
	       (declare (sys:downward-function))
	       (unless (equal file-info-read
			      (send (open journal-pathname :direction :probe
							   :if-does-not-exist :error)
				    :info))
		 (return-from collision nil)))
	     (after-hook (file-info-read stream)
	       (declare (sys:downward-function))
	       (unless (or (not (typep (send stream :pathname) 'fs:lmfs-pathname))
			   ;; Only do this check for LMFS, for now
			   (equal file-info-read
				  (send (open journal-pathname :direction :probe
							       :if-does-not-exist :error)
					:info)))
		 ;; The file we have open for writing is invisible to PROBEs
		 ;; (known to be true for LMFS, and no place else), so if
		 ;; we probe now, we see if someone else has written.
		 (return-from collision nil))))
	(return-from with-arbitrary-journal-locked-internal-guarded
	  (with-arbitrary-journal-locked-do-the-work
	    system journal-name journal-pathname file-read-function file-write-function
	    cached-file-info-fun set-cached-file-info-fun
	    cached-file-fun set-cached-file-fun 
	    continuation
	    #'before-hook
	    #'after-hook))))
    (beep)
    (format query-io "~&Since the patch directory file for ~A was read ~
			(just moments ago), it has~%~2Tbeen rewritten by ~
			somebody else." (system-pretty-name system))
    (cond ((or first (y-or-n-p "Try again? "))
	   (when first
	     (setq first nil)
	     (format query-io "  Trying again.")))
	  (t
	   (return-from with-arbitrary-journal-locked-internal-guarded nil)))))
		
(defun with-arbitrary-journal-locked-do-the-work
       (system journal-name journal-pathname file-read-function file-write-function
	cached-file-info-fun set-cached-file-info-fun cached-file-fun set-cached-file-fun 
	continuation before-write-collision-check-hook
	after-write-collision-check-hook)
  (let ((file-info)
	(file-contents)
	(new-file-info)
	(new-file-contents))
    (error-restart ((error) "Retry reading the ~A for ~A"
		    journal-name (system-pretty-name system))
      (with-open-file (journal-stream journal-pathname :if-does-not-exist :error)
	(setq file-info (send journal-stream :info))
	;; Try to speed up the process
	(if (and cached-file-info-fun
		 (equal (funcall cached-file-info-fun system) file-info))
	    (setq file-contents (funcall cached-file-fun system))
	    (setq file-contents
		  (funcall file-read-function journal-stream))
	    (when cached-file-info-fun
	      (funcall set-cached-file-fun system file-contents)
	      (funcall set-cached-file-info-fun system file-info)))))
    ;; OK, we have a set of contents, we can run the body.  Afterwards
    ;; we call the collision-check-hook if there is one.  This is used
    ;; by the non-locking case to detect when someone else has snuck in
    ;; and wrote.  If the body aborts, we return what it tells us to.
    (catch 'abort-journal-modification
      (let ((return-values (multiple-value-list
			     (funcall continuation file-contents
				      #'(lambda (new-contents)
					  (declare (sys:downward-function))
					  (setq new-file-contents new-contents))))))
	(funcall before-write-collision-check-hook file-info)
	(error-restart ((error) "Retry writing ~A for ~A"
			journal-name (system-pretty-name system))
	  (with-open-file (journal-stream journal-pathname :direction :output)
	    (funcall file-write-function new-file-contents journal-stream)
	    (when after-write-collision-check-hook
	      (funcall after-write-collision-check-hook file-info journal-stream))
	    (close journal-stream)
	    (setq new-file-info (send journal-stream :info))))
	(when cached-file-info-fun
	  (funcall set-cached-file-info-fun system new-file-info)
	  (funcall set-cached-file-fun system new-file-contents))
	(values-list return-values)))))

(defun gpdm-read-patch-directory (stream)
  (with-patch-directory-bindings
    ;; Warning to future Bensons:  This copytree here is to compact the list
    ;; returned by READ, and therefore improve working set.  It is not there
    ;; because somebody thought READ could return a stack list.
    (copytree (read stream))))
  
(defun gpdm-write-patch-directory (new-dir stream patch-system)
  (write-patch-directory-to-stream stream patch-system new-dir))
				 
;; Here is the implementation of the old crufty macro in terms of the new
;; structure.  Its here to avoid having to modify all of its callers.
;; Wrap it around the code to do the particular modification to the
;; patch-directory that you want.  The value(s) of the last form in the body are
;; returned.  The raw patch-directory list structure is available to the body as
;; the value of .PATCH-DIR.; the body should set .OK-TO-REWRITE. to NIL to
;; prevent rewriting the directory.

;;; Comments on copying list structure:
;;; The modifying-journal-file-locked structure will give the body 
;;; the list structure returned by the read function, or the list structure
;;; to be found in the cache.
;;; There is an argument that it should always COPYTREE the cached copy.
;;; However, COPYTREE may not be good enough (consider a journal that
;;; when read is evaluated to get flavor instances or structures). So instead,
;;; the user has to do that for itself.  GPDM always does a copy, which at worst
;;; reduntantly copies the tree returned by read (but it used to do that anyway).
;;; it modifies the copied copy, and sticks that back into the cache.
(defmacro guarding-patch-directory-modification (&body body)
  `(let ((.ok-to-rewrite. t)
	 (.system. (patch-system patch-system nil)))
     (flet ((.write. (new-contents stream)
	      (gpdm-write-patch-directory new-contents stream patch-system)))
       (modifying-journal-file-locked
	 (.system. .patch-dir. :patch-directory #'gpdm-read-patch-directory #'.write.
	  :major-version (patch-version patch-system))
	 (setq .patch-dir. (copytree .patch-dir.))
	 (let ((.results. (multiple-value-list (progn ,@body))))
	   (unless .ok-to-rewrite. (abort-journal-modification nil))
	   (return-new-journal-contents .patch-dir.)
	   (values-list .results.)))))) 

;; Allocate a minor system number.  Mark it in the directory with a NIL.
;; Returns the version number, or NIL if no new version reserved.
(defun reserve-patch (patch-system &optional (author user-id) reviewer)
  (guarding-patch-directory-modification
    (let* ((patches (patch-dir-version-list .patch-dir.))
	   (last-patch (last patches))
	   (new-version (1+ (version-number (first last-patch)))))
      ;; Reserve a new version if either there are no higher numbered patches...
      (if (not (or ( (version-number (first last-patch))
		      (version-number (first (patch-version-list patch-system))))
		   ;; Or there are higher numbered finished and/or unfinished 
		   ;; patch(es), and the user says OK...
		   (query-about-unloaded-patches patch-system patches)))
	  (setq .ok-to-rewrite. nil)		;return NIL if no new version reserved
	(rplacd last-patch
		(ncons (make-patch-version number new-version
					   date (time:get-universal-time)
					   explanation nil
					   author author
					   reviewer reviewer)))
	new-version))))

(defun query-about-unloaded-patches (patch-system new-vers)
  (let* ((system (patch-system patch-system))
	 (major (patch-version patch-system))
	 (loaded-version (version-number (first (patch-version-list patch-system))))
	 (remaining-versions (memass #'< loaded-version new-vers))
	 (unfinished-only-p (loop for patch in remaining-versions
				  always (null (version-explanation patch)))))
    (sct-warn "~:[You are not up to patch level~;~
                  There are unfinished patches~] in system ~A."
      unfinished-only-p (system-pretty-name system))
    (sct-warn "~2TYour patch level is ~D.~D, the current level is ~D.~D.~@
               ~2TThe patches not yet loaded are:~2%"
      major loaded-version major (version-number (first (last new-vers))))
    (catch-error-restart ((error) "Skip printing unloaded patch description for ~A"
				  system)
      (loop for p in remaining-versions
	    as item-time = (and (numberp (version-date p))
				(time:print-brief-universal-time (version-date p) nil))
	    do (format t "~&~D.~D ~ (~A)~@[  (reviewed by ~A)~]~@[  (created ~A)~]~&~A~"
		 major (version-number p)
		 (version-author p) (version-reviewer p)
		 item-time (or (version-explanation p) "[ *** Unfinished patch *** ]"))))
    (format t "~2&")
    (let* ((query-io zwei:*typeout-window*)
	   (answer 
	     (format:with-query-io-selected ()
	       (scl:accept '((scl:alist-member :alist (("Yes" . T)
						       ("No" . NIL)
						       ("Load Patches" . :LOAD-PATCHES))))
			   :prompt "OK to proceed? (Yes, No, or Load Patches) "
			   :prompt-mode :raw))))
      (if (neq answer :load-patches)
	  answer
	(load-patches system :query nil)
	t))))

(defun query-about-unloaded-patches-for-system (system-name &optional major)
  (declare (values ok-to-proceed))
  (let* ((system (find-system-named system-name))
	 (loaded-major (sct:get-system-version system)))
    (when (or (not major) (= loaded-major major))
      ;; It only makes sense to proceed into here if the major version of the system
      ;; in question is the one currently loaded.
      (let* ((patch-system (get-patchable-system-named system t))
	     (versions (patch-dir-version-list (read-patch-directory patch-system)))
	     (last-version (version-number (car (last versions)))))
	(multiple-value-bind (ignore minor)
	    (sct:get-system-version system)
	  (unless (= last-version minor)
	    (query-about-unloaded-patches patch-system versions)))))))

;; Finish up making the patch for the specified minor system version
;; number.  "message" is the message to be displayed to the user in
;; GET-PATCHES.  This replaces the NILs left by RESERVE-PATCH with the
;; message.  Returns NIL if successful, T if patch didn't really get
;; consummated (which can happen only if a WARNINGS-STREAM was given and
;; warnings happened).
(defun consummate-patch (patch-system number message author reviewer warnings-stream
			 &optional environment)
  (when (null environment)
    (setq environment (system-environment (patch-system patch-system))))
  (let ((tick compiler:new-compiler-warnings-tick))
    (compile-patch environment patch-system number)
    (cond ((and ( tick compiler:new-compiler-warnings-tick)
		(let ((query-io warnings-stream))
		  (not (yes-or-no-p "Do you still want to finish the patch? "))))
	   t)					;Patch not consummated.
	  (t
	   (let ((consummate-p t))
	     (guarding-patch-directory-modification
	       (let* ((patch-list-tail
			(memass 'eql number (patch-dir-version-list .patch-dir.)))
		      (patch (car patch-list-tail)))
		 (when (null patch-list-tail)
		   (format warnings-stream
			   "~2&There is no initial record for the patch you are ~
finishing, ~D.~D, in the latest
 patch-directory for system ~A.  This probably means
 that there has been a conflict with somebody else who is also patching
 system ~:*~A; the file you wrote in starting your patch was
 probably superseded by a file written by the other patcher.  This patch
 will not be finished now.   You will have to reconcile the latest versions
 of ~A
 in the file system, then try finishing this patch again."
			   (patch-version patch-system) number (patch-name patch-system)
			   (send (patch-system-pathname
				   (patch-system patch-system) :patch-directory
				   (patch-version patch-system))
				 :new-version nil))
		   (setq consummate-p nil)
		   (tv:type-a-space-to-flush warnings-stream)
		   (abort-journal-modification nil))
		 (unless (current-type-of-patch-version-p patch)
		   (let ((new-patch (make-patch-version number (version-number patch)
							date (version-date patch))))
		     (setf (car patch-list-tail) new-patch)
		     (setq patch new-patch)))
		 (setf (version-explanation patch) message)
		 (setf (version-author patch) author)
		 (setf (version-reviewer patch) reviewer)))
	     (if consummate-p nil		;Patch consummated.
	       t))))))				;Patch not consummated.

;; Abort the patch in progress for the specified minor system version number.
;; This un-reserves the minor version number in the patch directory.
;; Returns NIL if successful, otherwise returns a string with an error message.
(defun abort-patch (patch-system number)
  (guarding-patch-directory-modification
    (let* ((patches (patch-dir-version-list .patch-dir.))
	   (version (assq number patches)))
      (cond ((null version)
	     (setq .ok-to-rewrite. nil)
	     (format nil "There is no minor version number ~D. allocated" number))
	    ((not (null (version-explanation version)))
	     (setq .ok-to-rewrite. nil)
	     (format nil "The patch with minor version number ~D. has already been made."
	       number))
	    (t
	     (setf (patch-dir-version-list .patch-dir.) (delq version patches))
	     nil)))))

;; Compile the specified patch file.
;; This uses the appropriate pathname tools so that the result goes in the right place.
(defmethod (compile-patch lisp-world-environment) (patch-system number)
  (let ((system (patch-system patch-system))
	(version (patch-version patch-system)))
    (si:inhibit-lengthy-background-updates
      (compiler:compile-file
	(patch-system-pathname system :patch-file version number :lisp)
	(patch-binary-pathname system version number self)))))


;; Call this if there are uncompiled patches AND you know what you are doing.
;; Run this on the machine-type for which you want to compile the patches.
(defun compile-uncompiled-patches (&rest systems)
  (compile-uncompiled-patches-for-machine-type systems *local-machine-type*))

(defun compile-uncompiled-patches-for-machine-type (systems &optional
						    (machine-type *local-machine-type*))
  (setq systems (get-patchable-systems-list systems))
  (loop with *current-machine-type* = machine-type
	with environment = (find-environment machine-type)
	for patch-system in systems doing
    (let ((*compiling-for-require-patch-level* t))
      (catch 'skip-current-system
	(loop with printed-header = nil
	      with loaded-patches = nil
	      with system = (patch-system patch-system)
	      with patch-dir = (read-patch-directory patch-system)
	      with major-version = (patch-version patch-system)
	      with patch-versions = (cdr (patch-dir-version-list patch-dir))
	      for version in patch-versions
	      as minor-version = (version-number version)
	      when (and (not (null (version-explanation version)))
			;; Neuter this optimization if we're compiling for
			;; a different machine type on this machine
			(or (not (eq *local-machine-type* *current-machine-type*))
			    (not (patch-loaded-p major-version minor-version system))))
		;; The only candidates are those which are clearly finished and have
		;; never been loaded on this machine.
		collect (patch-binary-pathname 
			  system major-version minor-version environment)
		  into candidates
		and collect minor-version into minor-versions
	      finally
		(loop with plists = (fs:multiple-file-plists candidates)
		      for pathname in candidates
		      for minor-version in minor-versions
		      doing
		  (cond ((null (cdr (assq pathname plists)))
			 ;; Only offer to compile when there is no .BIN file at all
			 (when (not printed-header)
			   (format t "~&Patches for ~A:" system)
			   (setq printed-header t))
			 (compile-uncompiled-patch
			   patch-system minor-version patch-versions environment))
			((and (not loaded-patches)
			      (or (not (eq *local-machine-type* *current-machine-type*))
				  (not (patch-loaded-p major-version minor-version system))))
			 ;; There is a .BIN file which we have not yet loaded, so
			 ;; offer to load patches if we have not done so already
			 (let ((action
				 (scl:accept
				   '((scl:alist-member
				       :alist (("Yes" :load)
					       ("Skip system" :skip)
					       ("Compile without loading" :no-load))))
				   :prompt
				     (format nil
					 "Load patches for ~A ~
					  (Yes, Skip system, or Compile without loading)?"
				       system)
				     :default :load)))
			   (cl:case action
			     (:load
			       (let ((*compiling-for-require-patch-level* nil))
				 (load-patches system :query nil))
			       (setq loaded-patches t))
			     (:skip
			       (return))
			     (:no-load
			       (setq loaded-patches t))))))))))))

(defun recompile-changed-patches (&rest systems)
  (recompile-changed-patches-for-machine-type systems *local-machine-type*))

(defun recompile-changed-patches-for-machine-type (systems &optional
						   (machine-type *local-machine-type*))
  (setq systems (get-patchable-systems-list systems))
  (loop with *current-machine-type* = machine-type 
	with environment = (find-environment machine-type)
	for patch-system in systems doing
    (let ((*compiling-for-require-patch-level* t))
      (catch 'skip-current-system
	(loop with printed-header = nil
	      with loaded-patches = nil
	      with system = (patch-system patch-system)
	      with patch-dir = (read-patch-directory patch-system)
	      with major-version = (patch-version patch-system)
	      with patch-versions = (cdr (patch-dir-version-list patch-dir))
	      for version in patch-versions
	      as minor-version = (version-number version)
	      when (not (null (version-explanation version)))
		;; Any finished patch is a candidate for recompilation
		collect (patch-system-pathname system :patch-file
					       major-version minor-version
					       :lisp) into candidates
		and collect (patch-binary-pathname 
			      system major-version minor-version environment)
		      into candidates
		and collect minor-version into minor-versions
	      finally
		(loop with plists = (fs:multiple-file-plists candidates)
		      for (lisp bin) on candidates by 'cddr
		      for minor-version in minor-versions
		      doing
		  (cond ((let* ((bin-props (cdr (assq bin plists)))
				(lisp-props (and bin-props (cdr (assq lisp plists)))))
			   (or (null bin-props)
			       (> (cl:getf lisp-props :creation-date)
				  (cl:getf bin-props :creation-date))))
			 ;; Offer to recompile the patch if the .LISP file is newer than
			 ;; the .BIN file, or if it has never been compiled at all.
			 (when (not printed-header)
			   (format t "~&Patches for ~A:" system)
			   (setq printed-header t))
			 (compile-uncompiled-patch
			   patch-system minor-version patch-versions environment))
			((and (not loaded-patches)
			      (not (patch-loaded-p major-version minor-version system))
			      (not (null (cdr (assq bin plists)))))
			 (let ((action
				 (scl:accept
				   '((scl:alist-member
				       :alist (("Yes" :load)
					       ("Skip system" :skip)
					       ("Compile without loading" :no-load))))
				   :prompt
				     (format nil
					 "Load patches for ~A ~
					  (Yes, Skip system, or Compile without loading)?"
				       system)
				   :default :load)))
			   (cl:case action
			     (:load
			       (let ((*compiling-for-require-patch-level* nil))
				 (load-patches system :query nil))
			       (setq loaded-patches t))
			     (:skip
			       (return))
			     (:no-load
			       (setq loaded-patches t))))))))))))

(defun get-patchable-systems-list (systems)
  (if (null systems)
      (patch-systems-list)
    (loop for system in systems
	  as patch-system = (get-patchable-system-named system)
	  when (not (null patch-system))
	    collect patch-system
	  when (null patch-system)
	    do (cl:cerror "Skip compiling patches for this system"
			  (let ((s (find-system-named system nil t)))
			    (if (null s)
				"~A is not a loaded system"
			      "~A is not a patchable system"))
		 system))))

(defun compile-uncompiled-patch (patch-system minor-version patch-versions
				 &optional environment)
  (when (null environment)
    (setq environment (system-environment (patch-system patch-system))))
  (loop with system = (patch-system patch-system)
	with major-version = (patch-version patch-system)
	with source = (patch-system-pathname
			system :patch-file
			major-version minor-version
			:lisp)
	with version = (ass #'= minor-version patch-versions)
	with date = (and (numberp (version-date version))
			 (time:print-brief-universal-time
			   (sct:version-date version) nil))
	doing
    (format t "~&~D.~D ~ (~A)~@[  (reviewed by ~A)~]~@[  (created ~A)~]~&~A~"
	    major-version (version-number version)
	    (version-author version) (version-reviewer version)
	    date (version-explanation version))
    (selectq (fquery '(:choices (((t "Yes.") #/Y #/Space)
				 ((nil "No.") #/N #/Rubout)
				 ((:edit "Edit.") #/E)
				 ((:view "View.") #/V)))
		     "Compile it? ")
      ((nil)
       (return))
      ((t)
       (catch-error-restart (error
			      "Skip compiling ~A and ask again" source)
	 (compile-patch environment patch-system minor-version)
	 (when (y-or-n-p "Load it? ")
	   (let ((*compiling-for-require-patch-level* nil))
	     (load-patch environment patch-system minor-version t))
	   ;; Tell the world this patch has been loaded, but only if
	   ;; the patch number is going to increase by 1 (i.e., we have
	   ;; just compiled and loaded the next patch in sequence).
	   (when (= minor-version
		    (1+ (version-number (first (patch-version-list patch-system)))))
	     (when (string-equal (patch-name patch-system) 'system)
	       (setq sys:syscom-minor-version-number minor-version)
	       #+imach
	       (sys:system-case
		 (embedded (setf (sys:emb-guest-minor-version) minor-version))
		 (otherwise nil)))
	     (push version (patch-version-list patch-system))))
	 (return)))
      (:view
       (viewf source))
      (:edit
       (ed source)))))


;;; Some user-interface functions

(defun print-system-modifications (&rest system-names)
  (cond ((or (null system-names)
	     (and (= (length system-names) 1) (eq (car system-names) :all)))
	 (dolist (patch (patch-systems-list))
	   (print-patches (patch-name patch))))
	((and (= (length system-names) 1) (eq (car system-names) :local))
	 (let ((local-site (send net:*local-site* :name)))
	   (dolist (patch (patch-systems-list))
	     (let* ((system (patch-system patch))
		    (maintaining-sites (system-maintaining-sites system)))
	       (when (or (null maintaining-sites)
			 (memq local-site maintaining-sites))
		 (print-patches (patch-name patch)))))))
	(t
	 (dolist (pat-name system-names)
	   (print-patches pat-name)))))

(defun print-patches (&optional (system "System") (from 0) (to nil))
  (let ((patch (get-patchable-system-named system)))
    (cond ((null patch)
	   (format t "~%No such system as ~A is loaded~%" system))
	  (t
	   (let* ((patch-list (patch-version-list patch))
		  (last (version-number (first patch-list))))
	     (or to (setq to last))		;last patch number to show
	     (cond
	       ((> from last)			;args can't be right
		(format t "~&The first modification requested, ~D, is beyond ~D, the last one"
		  from last))
	       ((> from to)			;might be right but not likely
		(format t "~&~D (FROM) is greater than ~D (TO); please respecify~%"
		  from to))
	       (t				;ok
		(format t "~%Modifications to ~A:~%"
		  (system-pretty-name (patch-system patch)))
		(loop with major = (patch-version patch)
		      for p in (loop for l on (reverse patch-list)
				     when ( (version-number (first l)) from)
				       return l)
		      while ( (version-number p) to)
		      do (format t "~D.~D~9T" major (version-number p))
			 (si:with-indentation (standard-output 9)
			   (format t "~A -- ~A~@[ (reviewed by ~A)~]"
			     (version-explanation p)
			     (version-author p) (version-reviewer p)))
			 (send standard-output ':tyo #\cr)))))))))

;; Stub for compatibility...
(deff si:print-patches 'print-patches)
(compiler:make-obsolete si:print-patches "use SCT:PRINT-PATCHES instead")

;; For unversioned systems, pass in MAJOR-VERSION :NEWEST or NIL
;; For unpatchable systems, pass in MINOR-VERSION NIL
(defun patch-loaded-p (major-version minor-version &optional (system "System"))
  (multiple-value-bind (loaded-major loaded-minor nil system)
      (get-system-version system)
    (when (null major-version)			;a little dwim...
      (setq major-version :newest))
    (and (not (null loaded-major))		;system may not be loaded at all
	 (or (and (eq major-version :newest)	;test for unversioned systems
		  (eq loaded-major :newest))
	     (> loaded-major major-version)
	     (and (= loaded-major major-version)
		  (or (not (system-patchable system))
		      ( loaded-minor minor-version)))))))

;; Stub for compatibility...
(deff si:patch-loaded-p 'patch-loaded-p)
(compiler:make-obsolete si:patch-loaded-p "use SCT:PATCH-LOADED-P instead")



(DEFFLAVOR PATCHES-NOT-LOADED-FOR-SYSTEM (SYSTEM MAJOR MINOR) (SYS:CONDITION)
  :INITABLE-INSTANCE-VARIABLES
  :WRITABLE-INSTANCE-VARIABLES)

;This probably never gets used since we normally won't land in the debugger,
;but it's still healthy to have. -kmp 30-Sep-92
(DEFMETHOD (DBG:REPORT PATCHES-NOT-LOADED-FOR-SYSTEM) (STREAM)
  (FORMAT STREAM "Patches for system ~A are not loaded." SYSTEM))

(DEFMETHOD (DBG:PROCEED PATCHES-NOT-LOADED-FOR-SYSTEM :NO-ACTION) ()
  "Try to continue without loading patches."
  :NO-ACTION)


;;; Boolean that tells REQUIRE-PATCH-LEVEL-FOR-PATCH whether it is being
;;; encountered under a compiling operation (value is T) or a loading
;;; operation (NIL).  Functions that compile patches must bind this to T
;;; so REQUIRE-PATCH-LEVEL-FOR-PATCH will act and print accordingly.
;;;
(defvar *compiling-for-require-patch-level* nil)

;;; Boolean that tells REQUIRE-PATCH-LEVEL-FOR-PATCH whether, when
;;; *COMPILING-FOR-REQUIRE-PATCH-LEVEL* is T, to abort the compilation when
;;; the specified level is not satisfied (NIL), or whether to go ahead and
;;; compile anyway (T).  This should only be bound to T by the Zmacs m-X
;;; Finish Patch operation, to let a patch creator specify a required level
;;; for the patch which is not officially loaded in the creating machine.
;;;
(defvar *ignore-required-level-for-compile* nil)

;;; List of systems to explicitly not bother with.
;;;
(defvar *ignore-required-level-for-systems* '())

(defun require-patch-level-for-patch (&rest system-major-minor-specs)
  (let ((not-up-to-required-level nil))
    (loop for (system-name major minor) in system-major-minor-specs
	  with first = t
	  as system = (find-system-named system-name nil t)
	  unless (or (member system *ignore-required-level-for-systems*)
		     (patch-loaded-p major minor system-name)
		     (unless sct:*ignore-required-level-for-compile*
		       ;; This is a non-fatal condition, so SIGNAL will just return NIL
		       ;; if it goes unhandled.  This permits callers an opportunity to
		       ;; intervene if they care without forcing them to. -kmp 30-Sep-92
		       (signal-proceed-case (() 'patches-not-loaded-for-system
					     :system system
					     :major major :minor minor)
			 (:no-action))
		       ;; Check again just in case it got fixed.
		       (or (member system *ignore-required-level-for-systems*)
			   (patch-loaded-p major minor system-name))))
	    collect (format nil "~:[, and~% ~;The system~] ~A must be ~
				   ~:[loaded and ~]patched to level ~D.~D"
			    first (or system system-name) system major minor)
	      into error-strings
	    and do (setq first nil)
	  finally (when (and error-strings (not *ignore-required-level-for-compile*))
		    (setq not-up-to-required-level t)
		    (sct-warn "~2&Note: This patch cannot be ~:[loaded~;compiled~] because ~
                                  definitions it depends on are not yet loaded:~@
                                  ~6T~~{~A~}~%before ~:[loading~;compiling~] ~
                                  ~:[this patch~;further patches for ~:*~A~].~~2%"
		      *compiling-for-require-patch-level* error-strings
		      *compiling-for-require-patch-level* *loading-patches-for-system*)))
    (when not-up-to-required-level
      (setq *patch-systems-to-retry* (append *patch-systems-to-retry*
					     (ncons *loading-patches-for-system*)))
      (throw 'skip-current-system nil))))

;; Change the status of a system
(defun set-system-status (system new-status &optional major-version only-update-on-disk)
  (check-arg new-status (assq new-status system-status-alist) "a defined system status")
  (let* ((system (find-system-named system t nil))
	 (only-update-on-disk (or (null (system-version-loaded system))
				  (eq (system-version-loaded system) :incomplete)
				  ;; If this system hasn't yet been loaded, only do
				  ;; the update on disk
				  only-update-on-disk))
	 (patchable (system-patchable system))
	 (old-patch-dir (system-cached-patch-dir system))
	 (old-patch-dir-info (system-cached-patch-dir-file-info system))
	 (patch-system (when patchable
			 (get-patchable-system-named system (not only-update-on-disk)))))
    ;; If there is no maintaining site, don't sweat this stuff
    (when (system-maintaining-sites system)
      (loop for site in (system-maintaining-sites system)
	    when (equal (neti:find-object-named :site site nil) neti:*local-site*)
	      do (return)
	    finally (format t "~&The maintaining sites list for ~A is ~S.~@
			         It is not generally intended that its status be changed ~
				 at a customer site."
		      system (system-maintaining-sites system))
		    (if (yes-or-no-p "Do you really want to do this? ")
			(return) (return-from set-system-status nil))))
    (when (and patchable
	       (or only-update-on-disk
		   (and (not (null major-version))
			(not (= major-version (patch-version patch-system))))))
      ;; User wants to modify a major version that isn't the current one.
      (setq patch-system (make-patch-system
			   name-and-atom (patch-system-name-and-atom system)
			   version major-version)))
    (unless only-update-on-disk
      ;; Change the status in the internal data structure only if we're updating in-core
      (when patchable
	(setf (patch-status patch-system) new-status))
      (setf (system-status system) new-status))
    ;; Change the status in the patch directory in the file system.
    (when patchable
      (unwind-protect
	  (guarding-patch-directory-modification
	    (setf (patch-dir-status .patch-dir.) new-status))
	(when only-update-on-disk
	  ;; If we only updated on disk, restore the saved patch-dir state
	  (setf (system-cached-patch-dir system) old-patch-dir)
	  (setf (system-cached-patch-dir-file-info system) old-patch-dir-info))))))

(defun designate-system-version (system designator major-version
				 &optional only-update-on-disk)
  (let ((system (find-system-named system t nil)))
    (when (system-maintain-journals system)
      (let* ((only-update-on-disk (or (null (system-version-loaded system))
				      (eq (system-version-loaded system) :incomplete)
				      only-update-on-disk))
	     (old-sys-dir (system-cached-system-dir system))
	     (old-sys-dir-info (system-cached-system-dir-file-info system))
	     (patch-atom (sct:system-patch-atom system)))
	(unwind-protect
	    (multiple-value-bind (dir-file nil plist versions)
		(read-system-directory system t)
	      (unless plist
		(setq plist (make-system-attributes name patch-atom)))
	      (if major-version
		  (putprop plist major-version designator)
		(remprop plist designator))
	      (write-system-directory system dir-file plist versions))
	  (when only-update-on-disk
	    ;; If we only updated on disk, restore the saved system-dir state
	    (setf (system-cached-system-dir system) old-sys-dir)
	    (setf (system-cached-system-dir-file-info system) old-sys-dir-info)))))))

(defun release-system (system major-version &key only-update-on-disk (reap-protect t))
  ;; This updates no in-core datastructures if the system has not been loaded
  (set-system-status system :released major-version only-update-on-disk)
  (designate-system-version system :released major-version only-update-on-disk)
  (when reap-protect
    (reap-protect-system system :version major-version
				:include-components nil :query :confirm)))

;; Use this with care
(defun update-system-dependents (system)
  (let* ((system (find-system-named system t nil))
	 (dependents (and (typep system 'system)
			  (system-component-of-systems system))))
    (if (null dependents)
	(format t "~&System ~A has no dependent systems." system)
      (loop for dependent in dependents
	    do (format t "~&Updating the component directory of ~A..." dependent)
	       (update-component-directory-from-world dependent)
	    finally (format t "~&Done.")))))

;; Used to find the pathname from which a given patch version of a given system
;; was loaded for any sys host; useful to determine whether (1) it was loaded,
;; and (2) the right version was loaded
(defun system-patch-version-source-truename (&key (system "System")
						  (major-version (get-system-version system))
						  minor-version)
  (check-arg major-version (and (fixp major-version) (> major-version 0))
	     "patch system major version number")
  (check-arg minor-version (and (fixp minor-version) (> minor-version 0))
	     "patch system minor version number")
  (let* ((pathname (patch-binary-pathname system major-version minor-version))
	 (logical (send pathname :generic-pathname)))
    (send logical :get :qfasl-source-file-unique-id)))

;; Guard utility to forcibly stop patch loading if the incorrect version of an
;; earlier patch is the one loaded.  Theoretically, patches should never be 
;; redone, but it sometimes happens, and sometimes use of an older version
;; is fatal.
;; :FILE-VERSION :NONE means "Verify that this patch has not been loaded at all."
(defun check-system-patch-file-version (&key (system "System")
					     (major-version (get-system-version system))
					     minor-version file-version)
  (let ((patch-source (system-patch-version-source-truename :major-version major-version
							    :minor-version minor-version
							    :system system)))
    (if (eq file-version :none)
	(when patch-source
	  (ferror "~A patch ~D.~D was loaded into this world load, but that patch~@
		   has been revoked.  This renders this world invalid, and it should~@
		   be discarded, as continued use may lead to problems."
	    system major-version minor-version))
      (unless patch-source
	(ferror "~A patch ~D.~D was not loaded into this world load.  This renders~@
		 this world invalid, and it should be discarded, as continued use may~@
		 lead to problems."
	  system major-version minor-version))
      (let ((version (send patch-source :version)))
	(unless (eq version :unspecific)	;Unix, sigh
	  (unless (eq version file-version)
	    (ferror "Your world has an old, incorrect version of ~A patch ~D.~D.~@
		     Yours came from source file version ~D; version ~D was expected.~@
		     Boot a new world with ~A ~D earlier than ~D.~D, and load patches~@
		     into that world.  This world should be discarded, as continued use~@
		     may lead to problems."
	      system major-version minor-version
	      version file-version
	      system major-version
	      major-version minor-version)))))))


;; Here are a couple of useful functions (which nobody in the system uses :-)
(defun map-over-patches (function &optional pathname-p (systems *all-systems*) &rest args)
  (declare (sys:downward-funarg function))
  (loop for system-and-version in systems
	as system = (find-system-named (if (listp system-and-version)
					   (first system-and-version)
					 system-and-version))
	as version = (if (listp system-and-version)
			 (second system-and-version)
		       nil)
	doing
    (lexpr-funcall #'map-over-patches-in-system system function pathname-p version args)))

(defun map-over-patches-in-system (system function &optional pathname-p version &rest args)
  (declare (sys:downward-funarg function))
  (let ((system (find-system-named system)))
    (when (and (typep system 'system) (system-patchable system))
      (flet ((map (major minor patch)
		  (when (not (zerop minor))
		    (lexpr-funcall function
				   system major minor
				   (version-author patch) (version-reviewer patch) 
				   (version-explanation patch)
				   (version-date patch)
				   (and pathname-p
					(patch-system-pathname system :patch-file
							       major minor :lisp))
				   args))))
	(if version
	    (loop for patch in (patch-dir-version-list
				 (uncached-read-patch-directory system version t))
		  as minor = (version-number patch)
		  do (map version minor patch))
	  (loop with patch-system = (system-loaded-patches system)
		with major = (patch-version patch-system)
		for patch in (patch-version-list patch-system)
		as minor = (version-number patch)
		do (map major minor patch)))))))


;; A useful command.  Put it here rather than into sys:cp;info-commands
(defun tell-about-unloaded-patches (patch-system new-vers comments print-when-at-level)
  (let* ((system (patch-system patch-system))
	 (major (patch-version patch-system))
	 (loaded-version (version-number (first (patch-version-list patch-system))))
	 (remaining-versions (memass #'< loaded-version new-vers))
	 (unfinished-only-p (loop for patch in remaining-versions
				  always (null (version-explanation patch)))))
    (if (null remaining-versions)
	(when print-when-at-level
	  (sct-warn "~2&  You are up to the current patch level in system ~A, ~D.~D.~%"
	    (system-pretty-name system) major loaded-version))
      (sct-warn "~2&~2T~:[You are not up to patch level~;~
                          There are unfinished patches~] in system ~A."
	unfinished-only-p (system-pretty-name system))
      (sct-warn "~4TYour patch level is ~D.~D, the current level is ~D.~D.~%"
	major loaded-version major (version-number (first (last new-vers))))
      (when (or (and (eql comments :yes)
		     (progn (format t "~%  Patches not yet loaded for ~A:"
				    (system-pretty-name system))
			    t))
		(and (eql comments :ask)
		     (prog2
		       (format t "~%")
		       (y-or-n-p "  Show the patch comments for the patches not yet loaded? ")
		       (format t "~&"))))
	(format t "~2&")
	(loop for p in remaining-versions
	      as item-time = (and (numberp (version-date p))
				  (time:print-brief-universal-time (version-date p) nil))
	      as minor = (version-number p)
	      do
	  (dw:with-output-as-presentation
	      (:type 'fs:logical-pathname
	       :object (sct:patch-binary-pathname system major minor))
	    (format t "~&~D.~D ~ (~A)~@[  (reviewed by ~A)~]~@[  (created ~A)~]~&~A~"
		    major minor
		    (version-author p) (version-reviewer p) item-time
		    (or (version-explanation p) "[ *** Unfinished patch *** ]"))))
	(format t "~&")))))


;;; Magic things inserted at the front of each patch section by Zwei

;;; This is a separate function so we don't bloat every patch file ever made.
(defun begin-patch-section-get-syntax ()
  (let ((gp (send sys:fdefine-file-pathname :generic-pathname)))
    (when gp
      (let ((syntax-keyword (send gp :get :syntax)))
	(when syntax-keyword
	  (let ((syntax (si:lisp-syntax-from-keyword syntax-keyword)))
	    (when syntax
	      (let ((rt (si:lisp-syntax-readtable syntax)))
		(or rt si:standard-readtable)))))))))

(defmacro begin-patch-section ()
  `(progn
     (eval-when (compile load eval)
       (setq readtable
	     ;; Patches from Genera get migrated to earlier worlds by Minima all the time,
	     ;; by moving the binaries without recompiling them.  Make this work in that case.
	     (if (fboundp 'begin-patch-section-get-syntax)
		 (begin-patch-section-get-syntax)	;So PATCH-SECTION-ATTRIBUTES will read
		 si:standard-readtable)))
     (setq si:patch-source-file-pathname nil)))	;In case no PATCH-SECTION-SOURCE-FILE

(defun patch-section-source-file (pathname)
  (when (and (variable-boundp sys:fdefine-file-pathname)
	     sys:fdefine-file-pathname)		;Loading a file
    (setq si:patch-source-file-pathname
	  (send (fs:parse-pathname pathname) :generic-pathname)))
  nil)

(defmacro patch-section-attributes (string)
  `(eval-when (compile load eval)
     (zwei:patch-section-attributes-internal
       ',(loop for (indicator value) on (fs:parse-attribute-list string) by 'cddr
	       when (get indicator 'fs:file-attribute-bindings)
		 append (list indicator value)))))

;; This assumes that the patch file itself has all possible attributes, so that any
;; variables we SETQ here are bound at a higher level.  That is normally the case.
(defun zwei:patch-section-attributes-internal (attributes)
  (multiple-value-bind (vars vals)
      (fs:file-attribute-bindings nil :additional-attributes attributes)
    (loop for var in vars and val in vals do
      (set var val))))

(defmacro files-patched-in-this-patch-file (&body pathnames)
  (declare (ignore pathnames))
  nil)
