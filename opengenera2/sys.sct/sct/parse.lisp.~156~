;;; -*- Mode: LISP; Syntax: Zetalisp; Package: SCT; Base: 10; Lowercase: T -*-

;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; Parser for DEFSYSTEMs for the System Construction Tool


;; Sigh, canonicalize the system name by interning it into KEYWORD
(defun canonicalize-system-name (system-name)
  (intern-in-keyword-package (if (typep system-name 'basic-system)
				 (system-name system-name)
			       system-name)))

;; The DEFSYSTEM macro, which compiles a system definition
(defprop defsystem "System" si:definition-type-name)
(defmacro defsystem (system-name options &body body)
  (declare (zwei:indentation 1 3 2 1))
  (when (memq :name options)
    (ferror "You may not explicitly specify :NAME in a DEFSYSTEM form"))
  (let ((system-name (canonicalize-system-name system-name)))
    (warn-about-defsystem-obsolescences system-name 'defsystem options body)
    `(progn
       (record-source-file-name ',system-name 'defsystem)
       (define-system-internal  ',system-name 'system ',options
				',(expand-short-form body)))))

(defprop defsubsystem "Subsystem" si:definition-type-name)
(defprop defsubsystem defsystem zwei:definition-function-spec-type)
(defmacro defsubsystem (system-name options &body body)
  (declare (zwei:indentation 1 3 2 1))
  (when (memq :name options)
    (ferror "You may not explicitly specify :NAME in a DEFSUBSYSTEM form"))
  (let ((system-name (canonicalize-system-name system-name)))
    (warn-about-defsystem-obsolescences system-name 'defsubsystem options body)
    `(progn
       (record-source-file-name ',system-name 'defsystem)
       (define-system-internal  ',system-name 'subsystem ',options
				',(expand-short-form body)))))

(defun warn-about-defsystem-obsolescences (system-name type options body)
  (ignore body)
  (when (cl:getf options :initializations)
    (let ((pretty-name (or (cl:getf options :pretty-name)
			   (string-capitalize-words system-name))))
      (cl:warn '(:obsolete t) ":INITIALIZATIONS is obsolete for ~S ~A; ~
			       use :BEFORE-PATCHES-INITIALIZATIONS instead."
	type pretty-name))))

;; Purge all traces of a system (well, lots of traces anyhow...)
(defun undefsystem (system-name)
  (let* ((system (find-system-named system-name nil t t))
	 (system-name (and system (system-name system))))
    (when system
      (with-system-locked system
        (sys:without-aborts ("Undefining system ~A" system)
	  (remove-system-from-completion-caches system)
	  (process:with-lock (*all-systems-lock*)
	    (setq *all-systems* (delq system *all-systems*))
	    (scl:remhash (system-name system) *all-systems-table*)
	    (scl:remhash (system-short-name system) *all-systems-table*)
	    (scl:remhash (system-pretty-name system) *all-systems-table*))
	  (si:nremprop system-name 'system-source-file))
	(let* ((all-sfns (get system-name :source-file-name))
	       (sfn (assq 'defsystem all-sfns)))
	  (setq all-sfns (delq sfn all-sfns))
	  (if (null all-sfns)
	      (si:nremprop system-name :source-file-name)
	     (putprop system-name all-sfns :source-file-name)))
	t))))

(defun define-system-internal (system-name system-type options body)
  (let ((old-system (find-system-named system-name nil t t))
	(system (lexpr-funcall #'make-instance 
			       system-type :name system-name options)))
    ;; Nobody touches either system while we are doing this
    (with-system-locked old-system
      (with-system-locked system
	;; Bind *SYSTEM* so that we have access to the environment
	;;--- Note that there is a bootstrapping problem, in that
	;;--- SUBSYSTEM-PARENT-SYSTEM will not work reliably yet
	(let ((*system* system))
	  (parse-modules system body)
	  ;; Now do a quick check for any possible circularities
	  (when *system-check-circularities*
	    (loop for module in (system-modules system)
		  nconc (loop for (op . stuff) in (module-dependencies module)
			      do (ignore stuff)
			      collect op) into all-operations
		  finally
		    (cl:pushnew :compile all-operations)
		    (loop for operation in (si:eliminate-duplicates all-operations)
			  doing (order-dependencies system operation
						    :transform nil
						    :recompile t :reload t)))))
	;; Add the new system and flush the old one
	(sys:without-aborts (|Adding system to list| "Defining system ~A" system)
	  (add-system-to-systems-list system old-system)
	  (when old-system
	    (remove-system-from-completion-caches old-system))
	  (add-system-to-completion-caches system))
	;; If there was an old version of this system, be sure to remember
	;; all of the useful state it collected
	(when (or (typep old-system 'system)
		  (typep old-system 'subsystem))
	  (sys:without-aborts ("Updating attributes in system ~A" system)
	    (setf (system-loaded-version system) (system-loaded-version old-system))
	    (setf (system-loaded-branch system) (system-loaded-branch old-system))
	    ;; In case we are redefining a system while building it...
	    (setf (system-files-info system) (system-files-info old-system))
	    (when (and (typep system 'system)
		       (typep old-system 'system))
	      ;; If both the new system and the old system were true systems,
	      ;; then collect all of the saved patch state
	      (setf (system-loaded-patches system)
		    (system-loaded-patches old-system))
	      (setf (system-eco-level system)
		    (system-eco-level old-system))
	      (setf (system-loaded-patch-dir-creation-date system)
		    (system-loaded-patch-dir-creation-date old-system))
	      (setf (system-cached-patch-dir system)
		    (system-cached-patch-dir old-system))
	      (setf (system-cached-patch-dir-file-info system)
		    (system-cached-patch-dir-file-info old-system))
	      (setf (system-cached-system-dir system)
		    (system-cached-system-dir old-system))
	      (setf (system-cached-system-dir-file-info system)
		    (system-cached-system-dir-file-info old-system))
	      (setf (system-cached-component-dir system)
		    (system-cached-component-dir old-system))
	      (setf (system-cached-component-dir-file-info system)
		    (system-cached-component-dir-file-info old-system))
	      (setf (system-cached-component-dir-machine-type system)
		    (system-cached-component-dir-machine-type old-system)))))
	;; Record the patch-file translations if this is a true system
	(when (and (typep system 'system)
		   (system-maintain-journals system))
	  (let ((name (system-name system))
		(journal (system-journal-directory system)))
	    (when (operation-handled-p journal :record-patch-system-translation)
	      (send journal :record-patch-system-translation
		    name (patch-system-pathname system :system-directory)))))
	;; Reconcile all of the system backpointers with this new system
	(update-component-systems-pointers (system-name system))
	(when old-system
	  (labels ((flush-patch-cache (system)
		     (when (typep system 'system)
		       (setf (system-load-patches-plan system) nil))
		     (loop for parent in (system-component-of-systems system)
			   do (flush-patch-cache parent))))
	    (flush-patch-cache old-system)))
	;; Record the source file name if it isn't a patch file
	(when (and sys:fdefine-file-pathname
		   (null si:patch-source-file-pathname))
	  (send (send sys:fdefine-file-pathname :generic-pathname)
		:putprop system 'sct:system))
	system))))

;; LOADED-ONLY is the same thing as :NO-RELOAD-SYSTEM-DECLARATION T
;; UNDEFINED-OK is for bootstrapping systems which have only been defined with
;; SET-SYSTEM-SOURCE-FILE, but whose sysdcl has never been evaluated
(defun find-system-named (system-name &optional (error-p t) loaded-only undefined-ok)
  (let ((version (and (listp system-name) (second system-name)))
	(branch (and (listp system-name) (third system-name)))
	(system-name (if (listp system-name) (first system-name) system-name)))
    (if (or (typep system-name 'system)
	    (typep system-name 'subsystem)
	    (and undefined-ok
		 (typep system-name 'undefined-system)))
	system-name
      (setq system-name (canonicalize-system-name system-name))
      (cond ((let ((system (cl:gethash system-name *all-systems-table*)))
	       (when (or (typep system 'system)
			 (typep system 'subsystem)
			 (and undefined-ok (typep system 'undefined-system)))
		 system)))
	    ((not loaded-only)
	     ;; Go out to SYS:SITE; to get the sysdcl file, if necessary
	     (load-system-declaration-if-necessary
	       system-name (or version :newest) branch error-p)
	     (find-system-named system-name error-p t))
	    (error-p
	     (signal 'system-not-found :system-name system-name))))))

;; Push the new system onto *ALL-SYSTEMS*.  If there was an old version,
;; splice the new version into the same place, otherwise tack it to the end
;; of the list.  Update *ALL-SYSTEMS-TABLE* accordingly.
(defun add-system-to-systems-list (system old-system)
  (sys:with-aborts-enabled (|Adding system to list|)
    (let ((conflict (find-system-named (system-short-name system) nil t t)))
      ;; If there is a non-EQ system under the same name, complain
      (when (and conflict (neq conflict old-system))
	(ferror "The short name for system ~A conflicts with system ~A"
	  system conflict))))
  (process:with-lock (*all-systems-lock*)
    (without-interrupts
      (if (null old-system)
	  (setf *all-systems* (nconc *all-systems* (list system)))
	(cl:nsubstitute system old-system *all-systems* :count 1)))
    (when old-system
      (scl:remhash (system-name old-system) *all-systems-table*)
      (scl:remhash (system-short-name old-system) *all-systems-table*)
      (scl:remhash (system-pretty-name old-system) *all-systems-table*))
    (setf (scl:gethash (system-name system) *all-systems-table*) system)
    (setf (scl:gethash (system-short-name system) *all-systems-table*) system)
    (setf (scl:gethash (system-pretty-name system) *all-systems-table*) system))
  *all-systems*)

;; Add this system object to all of the aarrays, under all of its names
(defmethod (add-system-to-completion-caches basic-system) ()
  (let* ((all-names nil)
	 (symbol-name (string name))
	 (short-equivalent (string-capitalize-words short-name))
	 (symbol-equivalent (string-capitalize-words symbol-name)))
    ;; Collect all of the different looking names for this system
    (push pretty-name all-names)
    (unless (string-equal pretty-name short-equivalent)
      (push short-name all-names))
    (unless (or (string-equal pretty-name symbol-equivalent)
		(string-equal short-equivalent symbol-equivalent))
      (push symbol-name all-names))
    (flet ((suggest (names aarray)
	     (loop for name in names
		   do (si:aarray-insert aarray name self t))))
      (when (not (typep self 'subsystem))
	(suggest all-names *true-systems-aarray*))
      (when (and (typep self 'system)
		 (system-patchable self))
	(suggest all-names *patchable-systems-aarray*))
      (suggest all-names *subsystems-aarray*))))

;; Remove this system object from all of the aarrays
(defmethod (remove-system-from-completion-caches basic-system) ()
  (flet ((remove (aarray)
	   ;; We need to do this looping by hand because there can be several names 
	   ;; for the same system object
	   (si:with-aarray-locked aarray
	     (si:sort-aarray aarray)
	     (loop for index downfrom (1- (fill-pointer aarray)) to 0
		   as (nil . system-object) = (aref aarray index)
		   when (and system-object
			     (eq (system-name system-object) name))
		     do (si:aarray-delete-internal aarray index)))))
    (sys:without-aborts ("Removing completions for system ~A" self)
      (remove *true-systems-aarray*)
      (remove *patchable-systems-aarray*)
      (remove *subsystems-aarray*))))

;; Walk over all the systems in the world, making backpointers from component
;; systems to all of their ancestors.  This is an O(n^2) algorithm which pages
;; a lot, but it only runs when a system is defined, and the payoffs are high
;; e.g., the Zmacs m-X Add Patch and the Debugger m-L commands run much faster.
(defun update-component-systems-pointers (defendant)
  ;; Only one process can do this at a time
  (process:with-lock (*all-systems-lock*)
    (loop for system in *all-systems*
	  when (not (typep system 'undefined-system))
	    do (setf (system-component-of-systems system) nil))
    (loop for system in *all-systems*
	  when (not (typep system 'undefined-system))
	    do (loop for component-name in (system-component-systems system)
		     as component = (find-system-named
				      ;; Extract the name of the system so that we
				      ;; forcibly look it up again
				      (if (typep component-name 'basic-system)
					  (system-name component-name) component-name)
				      nil t)
		     do (when component
			  (let ((first-component-of
				  (first (system-component-of-systems component))))
			    ;; Subsystems may have only a single parent, but only
			    ;; issue an error when we are defining one of the systems
			    ;; which is involved in the problem.
			    (if (and (typep component 'subsystem)
				     first-component-of
				     (or (eq defendant (system-name system))
					 (eq defendant (system-name component))
					 (eq defendant (system-name first-component-of))))
				(cl:cerror "Ignore the extra parent system"
					   "The subsystem ~A is a component of more than one ~
					    system (at least ~A and ~A)"
				  component first-component-of system)
			      (push system (system-component-of-systems component)))))
		     collect (or component component-name) into all-components
		     finally (unless (equal all-components (system-component-systems system))
			       ;; Don't update more than necessary (improves locality)
			       (setf (system-component-systems system) all-components))))))


;;; All the basic methods for a system

(defmethod (:print-self basic-system) (stream ignore slashify)
  (let ((scl:*print-string-length* nil))
    (if slashify
	(si:printing-random-object (self stream :typep)
	  (princ name stream))
      (princ pretty-name stream))))

(defun-in-flavor (describe-internal basic-system) (&optional abbreviated-ivs)
  (let* ((instance (follow-structure-forwarding self))
	 (flavor (sys:%instance-flavor instance))
	 (symbols (flavor:flavor-all-instance-variables flavor))
	 (min-indentation 27.)
	 (max-indentation 40.)
	 (indentation))
    (format t "~&~S, an object of flavor ~S,~% has instance variable values:~%"
      instance (sys:flavor-name flavor))
    ;; Add 5 for the leading " " and the trailing ":  "
    (setq indentation
	  (min max-indentation
	       (max min-indentation
		    (+ 5 (loop for symbol in symbols maximize (flatsize symbol))))))
    (loop for symbol in symbols
	  for i from 1 do
      (let-if (memq symbol abbreviated-ivs)
	      ((prinlevel 3)
	       (prinlength 3))
	(let ((locative (%make-pointer-offset dtp-locative instance i)))
	  (scl:present locative `((dbg:named-locative-slot)
				  :symbol ,symbol
				  :indentation ,indentation
				  :structure ,instance))
	  (terpri))))
    instance))

(defmethod (:describe basic-system) ()
  (describe-internal))

(defmethod (:describe system) ()
  (describe-internal '(loaded-patches cached-patch-dir
		       cached-system-dir cached-component-dir)))

(defmethod (:init basic-system :after) (options)
  (macrolet ((fixup-pathname (pathname)
	       `(when (eq ,pathname t)
		  ;; Special case: T means use the pathname we are reading from now
		  (let ((source (if fs:this-is-a-patch-file
				    (or si:patch-source-file-pathname
					sys:fdefine-file-pathname)
				  sys:fdefine-file-pathname)))
		    (when source
		      (setq ,pathname (send source :new-pathname
						   :name nil :type nil :version nil)))))))
    (fixup-pathname default-pathname)
    (fixup-pathname default-destination-pathname))
  (when default-pathname
    (setq default-pathname (fs:parse-pathname default-pathname)))
  (when (null default-destination-pathname)
    (setq default-destination-pathname default-pathname))
  (when default-destination-pathname
    (setq default-destination-pathname (fs:parse-pathname default-destination-pathname)))
  (when (null pretty-name)
    (setq pretty-name (string-capitalize-words name)))
  (when (null short-name)
    (setq short-name (string-upcase name)))
  ;; These must be strings, and thin ones at that
  (setq pretty-name (string-thin (string pretty-name) :remove-bits t :error-if :fat)
	short-name  (string-thin (string short-name)  :remove-bits t :error-if :fat))
  (unless (validate-machine-types machine-types)
    (cl:cerror "Use :ALL as the value for :MACHINE-TYPES"
	       "~S is an invalid :MACHINE-TYPES specification" machine-types)
    (setq machine-types :all))
  (when default-system-branch
    (setq default-system-branch (canonicalize-system-branch default-system-branch)))
  (setq branch-mapping (canonicalize-branch-mapping
			 (or branch-mapping default-system-branch)))
  (when (or branch-mapping default-system-branch)
    ;; If there's a branch-mapping, we must be version-controlled
    (setq version-controlled t))
  ;; Try to add a bug-report recipient
  (when bug-reports
    (when (fdefinedp 'zwei:add-bug-recipient-for-system)
      (funcall 'zwei:add-bug-recipient-for-system self)))
  ;; Get the default source-category right
  (let* ((fake-module (make-instance (or (cdr (assq default-module-type
						    *module-type-flavor-alist*))
					 (ferror "There is no such module-type as ~S"
					   default-module-type))
				     :name "Dummy")))
    (when (null source-category)
      (setq source-category ':basic))
    (setq source-category (canonicalize-source-category
			    source-category fake-module self t)))
  ;; Compatibility for :INITIALIZATIONS
  (let ((initializations (get options :initializations)))
    (when initializations
      (setq before-patches-initializations initializations))))

(defun validate-machine-types (types)
  (or (eq types :all)
      (and (listp types)
	   (loop for type in types
		 always (loop for group in *machine-type-file-type-mappings*
			      thereis (assq type group))))))

(defmethod (:init system :after) (init-keys &rest ignore)
  (macrolet ((fixup-pathname (pathname)
	       `(when (eq ,pathname t)
		  (let ((source (if fs:this-is-a-patch-file
				    (or si:patch-source-file-pathname
					sys:fdefine-file-pathname)
				    sys:fdefine-file-pathname)))
		    (when source
		      (setq ,pathname (send source :new-pathname
					    :name nil :type nil :version nil)))))))
    (fixup-pathname journal-directory))
  ;; Only full systems have component-directories
  (if journal-directory
      (setq journal-directory (fs:parse-pathname journal-directory))
    (when (and (null default-pathname)
	       (not (null sys:fdefine-file-pathname)))
      (let ((default (send sys:fdefine-file-pathname
			   :new-pathname :name nil :type nil :version nil)))
	(cl:cerror (format nil "Use ~A as the default pathname" default)
		   "The system ~A has no default pathname" self)
	(setq default-pathname default)
	(when (null default-destination-pathname)
	  (setq default-destination-pathname default-pathname))))
    (if (null default-pathname)
	(ferror "You must supply either :DEFAULT-PATHNAME or :JOURNAL-DIRECTORY for ~A"
	  self)
      (setq journal-directory (send (merge-pathname-with-defaults
				      "patch" :lisp self)
				    :pathname-as-directory))))
  (unless (memq patchable '(t nil))
    (cl:cerror "Make the system patchable and continue"
	       ":PATCHABLE must be either T or NIL for system ~A" self)
    (setq patchable t))
  (when (and (not maintain-journals)
	     ;; If the user specified :MAINTAIN-JOURNALS NIL, and did not
	     ;; explicitly give :PATCHABLE NIL, do it for him
	     (null (cl:getf (cdr init-keys) :patchable nil)))
    (setq patchable nil))	 
  (when (and (not maintain-journals) (eq patchable t))
    (cl:cerror "Make the system unpatchable and continue"
	       ":MAINTAIN-JOURNALS NIL requires that the system ~A be unpatchable" self)
    (setq patchable nil))
  (when (null patch-atom)
    (setq patch-atom short-name))
  (setq patch-atom (string-thin (string patch-atom) :remove-bits t :error-if :fat))
  (unless (memq patches-reviewed '(t nil))
    (setq patches-reviewed (string-thin (string patches-reviewed)
					:remove-bits t :error-if :fat)))
  (when (and advertised-in (atom advertised-in))
    (setq advertised-in (list advertised-in)))
  (let ((bad-ad))
    (unless (loop for ad in advertised-in
		  do (setq bad-ad ad)
		  always (memq ad '(:disk-label :herald :finger)))
      (cl:cerror "Make the system be advertised only in the herald and continue"
		 "~S is not valid in :ADVERTISED-IN;~@
		  it must be NIL or a list of :DISK-LABEL, :HERALD, or :FINGER" bad-ad)
      (setq advertised-in '(:herald))))
  (when (and required-systems (atom required-systems))
    (setq required-systems (list required-systems)))
  ;; Null environment is the running Lisp world
  (when (null environment)
    (setq environment (find-environment-named 'lisp-world)))
  ;; Do this here as an optimization; note that the environment must be
  ;; defined before anyone can refer to it
  (setq environment (find-environment-named environment))
  ;; Remember that this system uses this environment
  (si:push* name (environment-systems environment))
  ;; Ensure that this is a list; note that a maintaining site of NIL means
  ;; that the system is maintained at the current site
  (when (and maintaining-sites (atom maintaining-sites))
    (setq maintaining-sites (list maintaining-sites)))
  (when installation-script
    (setq installation-script
	  (merge-pathname-with-defaults installation-script :lisp self))))


;; Parse one module in a system
(defun-in-flavor (parse-one-module basic-system) (module)
  (declare (values module modules-referred-to))
  (let ((other-package nil))
    (destructuring-bind (type module-name &rest module-body) module
      (when (null module-name)
	(setq module-name (fintern "Anonymous module ~D"
				   (incf *anonymous-module-count*))))
      (selectq type
	(:module
	 (destructuring-bind (inputs &rest clauses) module-body
	   (unless (cl:listp inputs)
	     (setq inputs (list inputs)))
	   ;; The list of inputs can actually be of the form
	   ;; ((other-system other-module)), which means "use the list of
	   ;; inputs from other-module in the system other-system", or it
	   ;; can be (("input-path" "output-path") ...), which we simply
	   ;; ignore here, since it will be detected later.  Note that the
	   ;; package is inherited from the package of the other module,
	   ;; but can be overridden by a package declaration here.
	   (let ((other-system-module (car inputs)))
	     (when (and (= (length inputs) 1)
			(listp other-system-module)
			(= (length other-system-module) 2))
	       (destructuring-bind (other-sys other-mod) other-system-module
		 (when (and (symbolp other-sys) (symbolp other-mod))
		   (let* ((other-system (find-system-named other-sys nil t))
			  (other-module (if other-system
					    (find-module-named other-system other-mod))))
		     (if (null other-module)
			 (ferror "Cannot find module ~A in system ~A" other-mod other-sys)
		       (setq inputs (module-inputs other-module))
		       (setq other-package (or (module-in-package other-module)
					       (system-default-package other-system)))))))))
	   ;; Parse just this one module, and return a module instance
	   (multiple-value-bind (dependencies uses module-type modules-referred-to)
	       (parse-module-dependencies clauses)
	     (let* ((mt (or module-type default-module-type))
		    (type (or (cdr (assq mt *module-type-flavor-alist*))
			      (ferror "There is no such module-type as ~S" mt)))
		    (module (make-instance type
					   :name module-name
					   :inputs inputs
					   :dependencies dependencies
					   :uses-definitions-from uses
					   :machine-types machine-types)))
	       ;; Parse all the other random stuff in the module spec
	       (let ((unrecognized-clauses
		       (parse-module-clauses module clauses self)))
		 (when unrecognized-clauses
		   (setq unrecognized-clauses
			 (parse-module-specific-clauses module unrecognized-clauses self))
		   (when unrecognized-clauses
		     (ferror "The following clause~:[s are~; is~] unrecognized in module ~A:~%~S"
		       (= (length unrecognized-clauses) 1) (module-name module)
		       unrecognized-clauses))))
	       ;; Perhaps stash the package from the "other system"
	       (when (and other-package
			  (null (module-in-package module)))
		 (setf (module-in-package module) other-package))
	       ;; Track component systems
	       (when (eq type 'system-module)
		 (setq component-systems (append component-systems inputs)))
	       (canonicalize-module-pathnames module self)
	       (values module modules-referred-to)))))
	(otherwise
	 (ferror "Can't parse this module: ~S" module))))))

(defun anonymous-module-p (module)
  (let* ((module-name (string (module-name module)))
	 (length (string-length module-name)))
    (or (let* ((s "Module ")
	       (l (string-length s)))
	  (and (> length l)
	       (%string= module-name 0 s 0 l)
	       (digit-char-p (aref module-name l))))
	(let* ((s "Anonymous module ")
	       (l (string-length s)))
	  (and (> length l)
	       (%string= module-name 0 s 0 l)
	       (digit-char-p (aref module-name l)))))))

(defun canonicalize-module-name (module-name)
  (and module-name
       (intern-in-keyword-package module-name)))

(defmethod (find-module-named basic-system) (module-name)
  (and module-names
       (values (cl:gethash (canonicalize-module-name module-name) module-names))))

;; Parse all the modules in a system
(defmethod (parse-modules basic-system) (body)
  (tv:noting-progress ((format nil "Parsing DEFSYSTEM modules for ~A" self))
    (loop with *anonymous-module-count* = 0
	  with n-modules = (length body)
	  with module-object
	  with modules-referred-to
	  with all-modules-referred-to
	  for which-module upfrom 1
	  for module in body
	  ;; First collect all the modules and their referrals
	  do (tv:note-progress which-module n-modules)
	     (multiple-value (module-object modules-referred-to)
	       (parse-one-module module))
	  when module-object
	    collect module-object into all-modules
	  do (setq all-modules-referred-to (union all-modules-referred-to
						  modules-referred-to))
	  finally
	    ;; Cache the module names so that plan-building is faster
	    (when (not (null all-modules))
	      (setq module-names (scl:make-hash-table :size (length all-modules)))
	      (loop with offenders = nil
		    for module in all-modules
		    as module-name = (canonicalize-module-name (module-name module))
		    do (if (cl:gethash module-name module-names)
			   (cl:pushnew module-name offenders)
			 (setf (cl:gethash module-name module-names) module))
		    finally
		      (when offenders
			(let ((message (format:print-list nil "~A" offenders)))
			  (ferror "The module~P ~A ~:[are~;is~] defined multiple times ~
				   in system ~A"
			    (length offenders) message (= (length offenders) 1) self)))))
	    ;; Issue a compile-time warning if there are undefined modules
	    (loop with offenders = nil
		  for referred in all-modules-referred-to
		  do (when (not (cl:gethash referred module-names))
		       (cl:pushnew referred offenders))
		  finally
		    (when offenders
		      (let ((message (format:print-list nil "~A" offenders)))
			(ferror "The module~P ~A ~:[were~;was~] used but not defined ~
				 in system ~A"
			  (length offenders) message (= (length offenders) 1) self))))
	    ;; We can finally make the system aware of all the modules
	    (setq modules all-modules))))


;;; The short-form parser

(defconst *legal-short-form-clauses*
	  '(:definitions :parallel :serial :serial-definitions))

(defun expand-short-form (body &optional which-form)
  (declare (values modules changed-modules))
  (let* ((body (copytree body))			;`cuz we destructively modify the body
	 (*named-modules*
	   (loop for phrase in body
		 as (key . rest) = phrase
		 when (memq key '(:module :module-group))
		   collect `(,(car rest) ,phrase)
		 else unless (memq key *legal-short-form-clauses*)
			do (ferror "Illegal keyword ~S in top-level DEFSYSTEM form ~S"
			     key phrase)))
	 (*module-count* 0)
	 (*module-creation-options* nil)
	 (*new-modules* nil)
	 (*modules-changed* nil))
    (loop for phrase in body
	  do (cond ((memq (car phrase) *legal-short-form-clauses*)
		    (unless (and which-form (not (equal which-form phrase)))
		      (expand-short-phrase phrase nil t)))
		   ((eq (car phrase) :module-group)
		    (push phrase *new-modules*)
		    (unless (and which-form (not (equal which-form phrase)))
		      (expand-short-phrase phrase nil t)))
		   (t (push phrase *new-modules*))))
    (values (loop for module in (copytree (reverse *new-modules*))
		  as (key . rest) = module
		  as (name inputs first-body) = rest
		  do (ignore name inputs first-body)	;destructure for effect
		  collect (if (eq key :module-group)
			      `(:module ,@rest)
			    module))
	    *modules-changed*)))

(defun expand-short-phrase (phrase definitions-used &optional top-level)
  (labels ((create-module (strings definitions-used)
	     (incf *module-count*)
	     (let ((name (fintern "Module ~D" *module-count*)))
	       (if (or (mem #'(lambda (item list) (eq item (cadr list)))
			    name *new-modules*)
		       (memq name *named-modules*))
		   (create-module strings definitions-used)
		 (let ((module
			 `(:module ,name
				   ,strings
				   ,@(when definitions-used
				       `((:uses-definitions-from ,(car definitions-used))))
				   ,@(copylist *module-creation-options*))))
		   (push module *new-modules*)
		   module))))
	   (module-interval (module)
	     (list module module))
	   (find-module (name)
	     (let ((pair (assq name *named-modules*)))
	       (if pair
		   (cadr pair)
		 (ferror "No module named ~A" name))))
	   (append-dependency (module when then)
	     (unless (memq (car module) '(:module :module-group))
	       (ferror "~S is a bad module" module))
	     ;; Works by side-effecting MODULE
	     (nconc module `((:in-order-to ,when ,then)))
	     (when (assq (cadr module) *named-modules*)
	       (let ((changes (or (assq (cadr module) *modules-changed*)
				  (let ((value `(,(cadr module))))
				    (push value *modules-changed*)
				    value))))
		 (nconc changes `((:in-order-to ,when ,then)))))
	     nil)
	   (prepend-dependency (module when then)
	     (unless (memq (car module) '(:module :module-group))
	       (ferror "~S is a bad module" module))
	     ;; Works by side-effecting MODULE, and kludgily NREVERSEing pieces of it
	     ;;--- Of course, this can only be called once per module
	     (nconc module `((:in-order-to ,when ,then)))
	     (setf (cdddr module) (nreverse (cdddr module)))
	     (when (assq (cadr module) *named-modules*)
	       (let ((changes (or (assq (cadr module) *modules-changed*)
				  (let ((value `(,(cadr module))))
				    (push value *modules-changed*)
				    value))))
		 (nconc changes `((:in-order-to ,when ,then)))
		 (setf (cdr changes) (nreverse (cdr changes)))))
	     nil))
    (typecase phrase
      (:symbol
	(module-interval (find-module phrase)))
      (:string
	(module-interval (create-module (list phrase) definitions-used)))
      (:list
	(selectq (car phrase)
	  (:parallel
	   ;; All the strings go into a single module
	   (let* ((strings
		    (loop for element in (cdr phrase)
			  when (stringp element)
			    collect element))
		  (string-module (when strings
				   (create-module strings definitions-used)))
		  (module-set (loop for element in (cdr phrase)
				    unless (stringp element)
				      collect
					(expand-short-phrase element definitions-used)))
		  (all-modules (if string-module
				   (cons (module-interval string-module) module-set)
				 module-set)))
	     (if (null (cdr all-modules))
		 (car all-modules)
	       #---ignore
	       ;; Add a dependency requiring which passes :COMPILE and
	       ;; :LOAD through to all the dependents.
	       (unless top-level
		 (let* ((root (create-module nil definitions-used))
			(rest (loop for (first last) in all-modules
				    do (ignore first)
				    collect (cadr last))))
		   (when rest
		     (append-dependency root :compile `(:compile ,@rest))
		     (append-dependency root :load `(:load ,@rest)))
		   (module-interval root)))
	       #+++ignore
	       ;; Make each have the dependency:
	       ;;   (:in-order-to :load (:compile last-of-all-other-modules))
	       ;;--- This causes circularities in things which look like this:
	       ;;---   (:ser "s1" (:par (:ser "s2a" "s2b") (:ser "s3a" "s3b")))
	       ;;--- so for now, just depend on how plan-building is implemented
	       ;;--- to get the ordering correct
	       (loop for module-interval in all-modules
		     as my-first = (car module-interval)
		     as dependents =
			(loop for interval in all-modules
			      unless (eq interval module-interval)
				collect (cadr (cadr interval)))
		     do (when dependents
			  (append-dependency my-first
					     :load `(:compile ,@dependents)))
		     finally
		       ;; Add a dependency requiring which passes :COMPILE and
		       ;; :LOAD through to all the dependents
		       (unless top-level
			 (return
			   (let* ((root (create-module nil definitions-used))
				  (rest (loop for (first last) in all-modules
					      collect (cadr last))))
			     (when rest
			       (append-dependency root
						  :compile `(:compile ,@rest))
			       (append-dependency root
						  :load `(:load ,@rest)))
			     (module-interval root))))))))
	  ((:serial :serial-definitions)
	   (let ((all-modules
		   (loop for element in (cdr phrase)
			 collect (expand-short-phrase
				   element
				   definitions-used))))
	     #---ignore
	     ;; Put a (:in-order-to (:compile :load) (:load predecessor))
	     ;; dependency as the first dependency on each of the elements
	     (loop for modules on all-modules
		   while (cdr modules)
		   as pred = (car modules)
		   as succ = (cadr modules)
		   do (prepend-dependency (car succ)
					  '(:compile :load) `(:load ,(cadr (cadr pred))))
		      ;; If this is a :SERIAL-DEFINITIONS, add the :USES stuff, too
		      (when (eq (car phrase) :serial-definitions)
			(let ((module (car succ))
			      (uses (cadr (cadr pred))))
			(nconc module `((:uses-definitions-from ,uses)))
			(when (assq (cadr module) *named-modules*)
			  (let ((changes (or (assq (cadr module) *modules-changed*)
					     (let ((value `(,(cadr module))))
					       (push value *modules-changed*)
					       value))))
			    (nconc changes `((:uses-definitions-from ,uses)))))))) 
	     #+++ignore
	     ;; Put a (:in-order-to (:compile :load) (:load predecessor))
	     ;; dependency on each of the elements
	     (loop for modules on all-modules
		   while (cdr modules)
		   as pred = (car modules)
		   as succ = (cadr modules)
		   do (append-dependency (car succ)
					 '(:compile :load) `(:load ,(cadr (cadr pred)))))
	     (list (car (car all-modules))
		   (cadr (car (last all-modules))))))
	  (:definitions
	   (unless (null (cdddr phrase))
	     (ferror "The format for the :DEFINITIONS phrase is ~
		      (:DEFINITIONS primary element), not ~S" phrase))
	   (unless (or (stringp (cadr phrase)) (symbolp (cadr phrase)))
	     (ferror "The first arg of :DEFINITIONS must be a string or module name, ~
		      not ~S" (cadr phrase)))
	    (let* ((primary (expand-short-phrase (cadr phrase) definitions-used))
		   (element (expand-short-phrase
			      (caddr phrase)
			      (cons (cadr (car primary)) definitions-used))))
	      (list (car primary) (cadr element))))
	  (:module-group
	   (let* ((*module-creation-options* (copylist (cdddr phrase)))
		  (expansion (expand-short-phrase (caddr phrase) definitions-used))
		  (my-module (find-module (cadr phrase))))
	     (append-dependency my-module
				:load `(:load ,(cadr (cadr expansion))))
	     (setf (caddr my-module) nil)
	     (list (car expansion) my-module)))
	  (otherwise (ferror "Unrecognized phrase ~S" phrase))))
      (otherwise (ferror "Unrecognized phrase ~S" phrase)))))


;; Parse the dependencies in a module, returning lots of values
;;--- Someday this should resolve all of the module-names into actual modules
(defun parse-module-dependencies (module-body)
  (declare (values dependencies uses-definitions-from module-type modules-referred-to))
  (let (dependencies uses-definitions-from module-type modules-referred-to)
    ;; Get the module type
    (setq module-type (cadr (assq :type module-body)))
    (when module-type
      (when (null (assq module-type *module-type-flavor-alist*))
	(ferror "There is no module type ~S" module-type)))
    ;; These three functions are used to process :IN-ORDER-TO's
    (labels ((parse-action-clauses (clauses)
	       (loop for clause in clauses
		     nconc (parse-one-action-clause clause)))
	     ;; Break down something like (:LOAD A B) into (:LOAD A) (:LOAD B)
	     (parse-one-action-clause (clause)
	       (declare (dbg:error-reporter))
	       (destructuring-bind (module-op &rest modules) clause
		 (when (null modules)
		   (ferror "You forgot to supply a module in ~S" clause))
		 (loop for module in modules
		       do (cl:pushnew (canonicalize-module-name module)
				      modules-referred-to)
		       collect `(,module-op ,module))))
	     (parse-module-body-internal (body)
	       (loop for body-clause in body
		     as when = (car body-clause)
		     as what = (cdr body-clause)
		     nconc (expand-when when (parse-action-clauses what))))
	     (expand-when (whens what)
	       (if (nlistp whens)
		   `((,whens ,@what))
		 (loop for when in whens
		       collect `(,when ,@(copylist what))))))
      ;; Handle :IN-ORDER-TO and :USES-DEFINITIONS-FROM
      (loop with in-order-tos = nil
	    for (iot . stuff) in module-body
	    ;; Parse an :USES-DEFINITIONS-FROM phrase
	    when (eq iot :uses-definitions-from)
	      do (setq uses-definitions-from (append uses-definitions-from stuff))
	    ;; Parse an :IN-ORDER-TO phrase
	    when (eq iot :in-order-to)
	      do (destructuring-bind (whens . whats) stuff
		   (unless (listp whens) (setq whens (list whens)))
		   ;; Turn (:IN-ORDER-TO (:COMPILE :LOAD) ...) into
		   ;; (:IN-ORDER-TO :COMPILE ...) (:IN-ORDER-TO :LOAD ...)
		   (loop for when in whens
			 doing
		     (let ((old (assq when in-order-tos)))
		       ;; If this dependency has already been mentioned once, include
		       ;; the new piece, otherwise add the new dependency
		       (if old
			   (rplacd (last old) (copylist whats))
			 (push `(,when ,@(copylist whats)) in-order-tos)))))
	    finally (setq dependencies (nreverse in-order-tos)))
      ;; Having collected all the dependencies, process them
      (loop for module in uses-definitions-from
	    do (cl:pushnew (canonicalize-module-name module) modules-referred-to))
      (when dependencies
	(setq dependencies (parse-module-body-internal dependencies))))
    ;; Merge dependencies with uses-definitions, that is, :USES-DEFINITIONS-FROM
    ;; establishes defaults for :LOAD and :COMPILE which may be overridden by
    ;; other :IN-ORDER-TOs
    ;;--- This may still have bugs in it
    (when uses-definitions-from
      (flet ((expand-uses (uses)
	       (loop for use in uses
		     collect `(:load ,use))))
	(loop for time in '(:compile :load)
	      as match = (assq time dependencies)
	      do (if match
		     (rplacd (last match) (expand-uses uses-definitions-from))
		   (push `(,time ,@(expand-uses uses-definitions-from)) dependencies)))))
    ;; Return all the values
    (values dependencies uses-definitions-from module-type modules-referred-to)))

(defun parse-module-clauses (module module-body system)
  (declare (values unrecognized-clauses))
  (let ((unrecognized-clauses nil))
    (flet ((validate (clause tester &optional more)
	     (declare (dbg:error-reporter))
	     (unless (funcall tester (cdr clause) more)
	       (ferror "The ~S clause is ill-formed in module ~A:~%~S"
		 (car clause) (module-name module) clause)))
	   (boolean (frob &optional more)
	     (and (= (length frob) 1)
		  (let ((car (car frob)))
		    (or (memq car '(t nil)) (memq car more))))))
      (multiple-value-bind (distribute-sources distribute-binaries source-category)
	  (distribution-defaults module system)
	(multiple-value-bind (version-controlled branch-mapping)
	    (version-control-defaults module system)
	  (loop for clause in module-body
		as (keyword . stuff) = clause
		doing
	    (selectq keyword
	      ;; These are handled in PARSE-MODULE-DEPENDENCIES
	      ((:in-order-to :uses-definitions-from :type))
	      ;; Everything else we do ourselves
	      (:package
	       (validate clause
		 #'(lambda (x &optional ignore)
		     (and (= (length x) 1)
			  (let ((car (car x)))
			    (or (symbolp car) (stringp car) (typep car 'si:package))))))
	       (setf (module-in-package module) (car stuff)))
	      (:compile-satisfies-load
	       (validate clause #'boolean)
	       (setf (module-compile-satisfies-load module) (car stuff)))
	      (:root-module
	       (validate clause #'boolean)
	       (setf (module-root-module module) (car stuff)))
	      (:machine-types
	       (validate clause #'(lambda (types &optional ignore)
				    (and (= (length types) 1)
					 (validate-machine-types (car types)))))
	       (setf (module-machine-types module) (car stuff)))
	      (:version-controlled
	       (validate clause #'boolean)
	       (setq version-controlled (car stuff)))
	      (:branch-mapping
	       (validate clause #'(lambda (x &optional ignore) (= (length x) 1)))
	       (setq branch-mapping (canonicalize-branch-mapping (car stuff))))
	      (:distribute-sources
	       (validate clause #'boolean '(:always))
	       (setq distribute-sources (car stuff)))
	      (:distribute-binaries
	       (validate clause #'boolean '(:always))
	       (setq distribute-binaries (car stuff)))
	      (:source-category
	       (validate clause #'(lambda (x &optional ignore) (= (length x) 1)))
	       (setq source-category (canonicalize-source-category (car stuff) module system)))
	      (otherwise
	       (push clause unrecognized-clauses))))
	  (setf (module-version-controlled module) version-controlled)
	  (setf (module-branch-mapping module) branch-mapping)
	  (setf (module-distribute-sources module) distribute-sources)
	  (setf (module-distribute-binaries module) distribute-binaries)
	  ;; Be forgiving of people who write their own module-types
	  (when (symbolp source-category)
	    (setq source-category (list (list source-category))))
	  (setf (module-source-category module) source-category))))
    (nreverse unrecognized-clauses)))

(defun canonicalize-system-branch (system-branch)
  (and system-branch				;NIL  NIL
       (intern-in-keyword-package system-branch)))

(defun canonicalize-branch-mapping (branch-mapping)
  (when branch-mapping
    (if (not (listp branch-mapping))
	(list branch-mapping)
      (loop with default = nil
	    for map in branch-mapping
	    if (not (listp map))
	      do (if default
		     (cl:cerror "Use the initially supplied default VC branch"
				"More than one default VC branch seen in ~S" branch-mapping)
		   (setq default map))
	      else collect
		     (destructuring-bind (sys-branch vc-branch . more-vc-branches) map
		       (when more-vc-branches
			 (cl:cerror "Ignore the extra VC branches"
				    "Multiple VC branches not yet supported in ~S"
			   branch-mapping))
		       (let ((sys-branches
			       (if (listp sys-branch)
				   (loop for sb in sys-branch
					 collect (canonicalize-system-branch sb))
				 (list (canonicalize-system-branch sys-branch)))))
			 (list sys-branches vc-branch))) into mapping
	    finally (return `(,default ,@mapping))))))

(defun canonicalize-source-category (categories module system &optional (error-p nil))
  (when (symbolp categories)
    (setq categories (list (list categories))))
  (loop with default-seen = nil
	for category in categories
	as parsed-category =
	   (let ((name (if (listp category) (car category) category))
		 (files (if (listp category) (cdr category) nil)))
	     (when (null files)
	       (when default-seen
		 (cl:cerror "Use the initially supplied default source category"
			    "More than one default source category for module ~A" module))
	       (setq default-seen t))
	     (unless (assq name *category-rank-alist*)
	       (ferror "~S is not a valid source category for module ~A"
		 name module))
	     `(,name ,@(when files
			 (canonicalize-category-pathnames module system files))))
	collect parsed-category into parsed-categories
	finally (unless default-seen
		  (if error-p
		      (ferror "You must supply a default source category for system ~S"
			system)
		    ;; Ensure there is a default category
		    (push (system-source-category system) parsed-categories)))
		(return parsed-categories)))

;; Extract the default value for some keyword argument from the parameters
;; of the current system
(defmacro default-keyword-arguments (&rest keys)
  (loop for key in keys
	nconc `(,key (default-keyword-arguments-internal ',key ,key)) into defaults
	finally (return `(setq ,@defaults))))

(defun default-keyword-arguments-internal (sym val)
  (if (null val)
      ;; Only get default if the supplied value is NIL (--- really needs supplied-p, too)
      (loop for default in (system-parameters *system*)
	    as dsym = (if (listp default) (car default) default)
	    as dval = (if (listp default) (cadr default) nil)
	    do (when (eq sym dsym) (return dval)))
    val))
