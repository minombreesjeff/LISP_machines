;;; -*- Mode: LISP; Syntax: Zetalisp; Package: SCT; Base: 10; Lowercase: T -*-

;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; Top level constructors for the System Construction Tool


;; Assumes that there are bindings for all of these state variables...
(defun canonicalize-state-variables ()
  (cond (*batch-p*
	 (cond ((eq *query-p* :confirm)
		(setq *query-type* :normal))
	       ((eq *query-p* :no-confirm)
		(setq *query-type* :no-confirm))
	       ((not (null *query-p*))
		(setq *query-type* :selective))
	       (t
		(setq *query-type* :no-confirm))))
	(*silent-p*
	 (setq *query-type* :no-confirm))
	((eq *query-p* :confirm)
	 (setq *query-type* :normal))
	((or (null *query-p*)
	     (eq *query-p* :no-confirm))
	 (setq *query-type* :no-confirm))
	((not (null *query-p*))
	 (setq *query-type* :selective))))

(defun canonicalize-system-version-number (system version
					   &key ignore-subsystems exact-match)
  (cond ((typep system 'subsystem)
	 (if ignore-subsystems
	     version
	   (if (memq version '(:newest :latest))
	       :newest
	     (cl:cerror "Use version Newest instead"
			"The version, ~@(~D~), does not make sense for the subsystem ~A"
	       version system)
	     :newest)))
	((numberp version) version)
	((not (system-maintain-journals system)) :newest)
	((eq version :newest) :newest)
	(t (or (get-system-major-version-from-directory system version t)
	       ;; Only do this if we are not looking for an exact match
	       (when (and (eq version :released) (not exact-match))
		 (sct-inform
		     "~&No Released version designated for system ~A, will try to use Latest"
		   system)
		 ;; Kludge to make sure that the error message is right below
		 (setq version :latest)
		 (get-system-major-version-from-directory system :latest t))
	       ;; Just in case the component-dir does not exist at all...
	       (prog2 (sct-inform
			  "~&Could not find version ~@(~A~) for ~A, will use Newest"
			version system)
		      :newest)))))

;; Assumes *CURRENT-MACHINE-TYPE* has its top-level value
(defun canonicalize-machine-types (machine-types system version)
  (when (listp machine-types)
    (loop for machine-type in machine-types doing
      (when (not (memq machine-type *all-machine-types*))
	(ferror "~S is not a valid machine type" machine-type))))
  (flet ((machine-types (machine-types)
	   (if (system-maintain-journals system)
	       (let* ((version (if (eq version :newest)
				   (canonicalize-system-version-number
				     system :latest :exact-match t)
				 version))
		      (all-machine-types
			(multiple-value-bind (nil nil nil nil components)
			    (read-component-directory system version)
			  (loop for (machine) in components
				collect machine))))
		 (loop for machine-type in machine-types
		       when (memq machine-type all-machine-types)
			 collect machine-type))
	     machine-types)))
    (cond ((null machine-types)
	   (list *current-machine-type*))
	  ((eq machine-types :all)
	   (machine-types *all-machine-types*))
	  (t
	   (machine-types machine-types)))))

;; Macro to wrap around a body which will create a plan for an operation over a
;; system.  The file-property-list-cache is flushed at the end to guarantee that
;; file data will be up to date the next time.  Perhaps this can be optimized
;; later, but this seems the widest safe degree of caching.
;; Note that *SYSTEM*, *VERSION*, and *BRANCH* must be bound at a higher level
;; For "funny operations", you must include :ORIGINAL-SYSTEM-OP in the keywords!
(defmacro with-plan-for-system ((plans system-op top-level-p keys)
				&body body)
  (declare (zwei:indentation 0 3 1 1))
  `(lexpr-funcall #'with-plan-for-system-internal
		  ,system-op ,top-level-p
		  ;; Create a continuation function to do all the work
		  #'(named-lambda with-plan-for-system-internal
				  (,(or plans 'ignore)
				   ,(or system-op 'ignore)
				   ,(or top-level-p 'ignore)
				   ,(or keys 'ignore))
		     (ignore ,plans ,system-op ,top-level-p ,keys)
		     ,@body)
		  ,keys))

;; Note that this does not recursively construct plans for component systems;
;; that doesn't happen until you run the plans (with EXECUTE-PLAN) or flatten
;; the plans (via FLATTEN-PLANS-FOR-COMPONENTS)
(defun with-plan-for-system-internal (system-op top-level-p continuation &rest keys)
  (with-system-locked *system*
    (let* ((operation (assq system-op *system-operation-alist*))
	   (plan-builder (if (eq (operation-class operation) :simple)
			     #'make-simple-plan-for-system
			     #'make-plan-for-system))
	   (original-op (or (cl:getf keys :original-system-op) system-op))
	   (compile-through (cl:getf keys :compile-through))
	   (component-version (cl:getf keys :component-version)))
      (tv:noting-progress-if *maintain-sct-progress-note*
	  ((format nil "Building plan for ~@(~A~) operation on ~A" original-op *system*)
	   *sct-progress-note*)
	;; If we are trying to compile a component system and it is not
	;; explicitly allowed then just simulate a load.
	(when (and (not top-level-p)
		   (typep *system* 'system)
		   (eq original-op :compile)
		   (not (or (system-compile-is-transitive *system*)
			    compile-through)))
	  (when (and (eq *version* :newest)
		     (system-maintain-journals *system*))
	    ;; Massage the version number, too
	    (setq *version* (map-operation-and-version-to-component-version
			      *system* :compile :newest :newest component-version)))
	  (setq original-op :load))
	(catch-error-restart ((error) "Skip building plan for ~@(~A~) operation on ~A"
				      system-op *system*)
	  (error-restart ((error) "Retry building plan for ~@(~A~) operation on ~A"
				  system-op *system*)
	    (letf (((system-environment (subsystem-parent-system *system*))
		    (if (eq *current-machine-type* *local-machine-type*)
			(system-environment *system*)
			(find-environment *current-machine-type*
					  (system-environment *system*)))))
	      (let ((env (system-environment *system*)))
		(when (environment-salvable env)
		  ;; If this is a salvable environment, ask it to load itself.
		  ;; Of course, the environment itself should remember if it has
		  ;; already loaded itself, and not bother to reload in that case.
		  (when (lexpr-funcall #'load-environment env original-op keys)
		    ;; We might queue it up for saving later on, too.
		    (si:push* (environment-name env) *environments-to-save*))))
	      (let ((plans (lexpr-funcall plan-builder
					  system-op top-level-p
					  keys)))
		(funcall continuation plans system-op top-level-p keys)))))))))

(defconst *use-recursive-querying* nil)

;; The highest level function to operate on a system...
;; Note that all of the global state variables get bound by the individually
;; defined top-level operations, like COMPILE-SYSTEM.  TOP-LEVEL-P of NIL
;; means that we should collect the plans for the non-top-level (i.e.,
;; component) system and just return the plans
;; ADDITIONAL-PLAN-CONSTRUCTOR can be used to construct additional plans to be
;; prefixed and/or appended for some special-purpose operations (e.g., distribution).
;; PLAN-FILTER is a predicate (which takes a file, a module and keywords)
;; which is used to filter over all of the plans.
;; Note that *SYSTEM*, *VERSION*, and *BRANCH* must be bound at a higher level.
;; This function only gets called at the highest level, since even
;; FLATTEN-PLANS-FOR-COMPONENTS binds over this function so that it can
;; use its own special version.
(defun construct-system-internal (system-op &rest keys
				  &key (top-level-p t)
				       additional-plan-constructor plan-filter
				       suppress-detail-printing
				  &allow-other-keys)
  (catch 'no-op
    (with-plan-for-system (plans system-op top-level-p keys)
      (let* ((default-driver (operation-driving-function
			       (assq system-op *system-operation-alist*)))
	     (default-doc (operation-documentation
			    (assq system-op *system-operation-alist*))))
	;; If there is a constructor which will build additional plans,
	;; call it now
	(when additional-plan-constructor
	  (multiple-value-bind (prepended-plans appended-plans)
	      (lexpr-funcall additional-plan-constructor system-op keys)
	    (setq plans (append prepended-plans plans appended-plans))))
	;; If there is some post-processing, run it now
	(when plan-filter
	  (setq plans (lexpr-funcall #'filter-plans plan-filter system-op plans keys)))
	;; Flatten the plans for component systems into the top-level tree.
	;; The effect of this is to put the plans for component systems at the
	;; same level as the plans for the top-level system, causing all of
	;; the querying to be done at the beginning of the process.  If you
	;; like "recursive querying", then set *USE-RECURSIVE-QUERYING* to T.
	(when (and (system-component-systems *system*)
		   (not *use-recursive-querying*))
	  (setq plans (lexpr-funcall #'flatten-plans-for-components
				     plans default-driver
				     keys)))
	;; Try not to do anything more than once.  This counts on the fact
	;; that SI:ELIMINATE-DUPLICATES keeps the initial thing and eliminates
	;; subsequent occurrences of it.
	(setq plans (si:eliminate-duplicates
		      plans
		      #'(lambda (x y)
			  (and (eq (plan-default-input-type x)
				   (plan-default-input-type y))
			       (eq (plan-default-output-type x)
				   (plan-default-output-type y))
			       (eq (sys:%instance-flavor (plan-module x))
				   (sys:%instance-flavor (plan-module y)))
			       (let ((pdf-x (plan-driving-function x))
				     (pdf-y (plan-driving-function y)))
				 (or (eq pdf-x pdf-y)
				     ;; Two lexical closures might not be EQ,
				     ;; but we should check them for EQUAL
				     (and (typep pdf-x :lexical-closure)
					  (typep pdf-y :lexical-closure)
					  (eq (sys:lexical-closure-function pdf-x)
					      (sys:lexical-closure-function pdf-y))
					  (equal (sys:lexical-closure-environment pdf-x)
						 (sys:lexical-closure-environment pdf-y)))))
			       ;; Don't need to compare the outputs
			       (equal (plan-inputs x) (plan-inputs y))))))
	(unless *silent-p*
	  (format standard-output "~2&"))
	;; Turn off the top-level plan-building progress note
	(tv:remove-progress-note *sct-progress-note*)
	;; Query about all the plan pieces
	(setq plans (query-for-system plans default-doc default-driver keys))
	(unless *silent-p*
	  (format standard-output "~2&"))
	;; Get a good pathname for compiler warnings
	(when *batch-p*
	  (let* ((cwarns 
		   (if (symbolp *batch-p*)
		       (scl:accept 'fs:pathname
				   :default (send (or (system-default-pathname *system*)
						      (fs:default-pathname))
						  :new-pathname
						  :name (system-short-name *system*)
						  :type :cwarns
						  :version nil)
				   :prompt (format nil
					       "Write compiler warnings for ~A to"
					     *system*))
		     (fs:merge-pathnames *batch-p*
					 (system-default-pathname *system*)))))
	    (setq *batch-p* cwarns)))
	;; Prevent false optimizations later
	(when (null (system-version-loaded *system*))
	  (setf (system-version-loaded *system*) :incomplete))
	;; Now we can actually run the plans
	(si:with-stack-array (plan-string 250 :type 'art-fat-string :fill-pointer 0)
	  (let-if suppress-detail-printing ((*silent-p* t))
	    (loop with *system-pass* = 1
		  for plan in plans doing
	      ;; Do this incrementally so that the description and the execution of
	      ;; a piece of a plan (i.e., an operation on a single file) happen
	      ;; atomically.  This makes error-recovery more friendly.
	      (loop until (null (plan-inputs plan))
		    do (setf (fill-pointer plan-string) 0)
		       ;; Compute the description for this piece of the plan so
		       ;; that we can use it for error recovery documentation later
		       (with-output-to-string (standard-output plan-string)
			 (describe-plan plan default-doc t keys))
		       ;; Print it again so that we get DW sensitivity
		       (unless *silent-p*
			 (describe-plan plan default-doc t keys))
		       (execute-plan plan default-driver
				     ;; Make the plan-string have nice casification
				     (if (plusp (string-length plan-string))
					 (string-downcase plan-string 0 1 nil)
				       plan-string)
				     t keys)
		       (setf (plan-inputs plan)
			     (if (listp (plan-inputs plan))
				 (cdr (plan-inputs plan)) nil))
		       (setf (plan-outputs plan)
			     (if (listp (plan-outputs plan))
				 (cdr (plan-outputs plan)) nil)))
		  finally (unless *silent-p* (format standard-output "~2&")))))))))

(defun query-for-system (plans default-doc default-driver keys)
  ;; Handling queries is a bit of a kludge, since it is not enough to
  ;; just describe the plan and then query, since a plan description can
  ;; include several physical operations.  Instead, we manually pick apart
  ;; the plan, querying for each part of it, and build it back up as the
  ;; user answers the queries.
  (when (neq *query-type* :no-confirm)
    (let ((*query-type* *query-type*))
      (unless *silent-p*			; set queries off from info. output
	(unless (eq standard-output query-io) (format query-io "~2&")))
      (loop named query-loop
	    with *system-pass* = 0
	    as count = 0
	    doing
	(when (eq *query-type* :normal)
	  (loop with standard-output = query-io	;make plan descriptions appear on QUERY-IO
		for plan in plans
		when (and (not (plan-never-query plan))
			  (or default-driver
			      (plan-driving-function plan)))
		  ;; Don't count anything unless the plan will do something
		  do (incf count (length (plan-inputs plan)))
		     (describe-plan plan default-doc nil keys))
	  (let ((ok (or (zerop count)
			(fquery '(:choices (((t "Yes.") #/Y #/SP #/T)
					    ((nil "No.") #/N #/Rubout)
					    ((:quit "Quit.") #/Q)
					    ((:selective "Selective.") #/S)))
			   "~2&Perform the ~D operation~:P above? " count))))
	    (cond ((eq ok t)
		   (return-from query-loop))
		  ((eq ok nil)
		   (throw 'no-op nil))
		  ((eq ok :quit)
		   (throw 'quit nil))
		  ((eq ok :selective)))))
	(loop with *system-pass* = 0
	      with *proceed-p* = nil
	      for plan in plans
	      ;; QUERY-FOR-PLAN side-effects the plan
	      do (query-for-plan plan default-doc keys))
	;; The effect of this is as follows: if the query type was :SELECTIVE,
	;; we have already asked a bunch of questions and gathered the results,
	;; so now we can ask the user whether or not he got everything right.
	(setq *query-type* :normal)
	(unless (zerop count)
	  (format query-io "~2&")))
      (unless *silent-p*			; set queries off from info. output
	(unless (eq standard-output query-io) (format query-io "~2&")))))
  plans)

;;; Define the basic operations over systems

(defvar *system-operation-bindings*
	'((*source-and-product-truenames* nil)
	  (*systems-with-plans-built* nil)
	  (*system-caches-to-flush* nil)
	  (*environments-to-save* nil)
	  (*component-system-info* nil)
	  (*unloaded-system-modules* nil)
	  ;; These are used to eliminate extra probing, at the cost of increasing
	  ;; the size of the window in which journals can be out of date
	  (*cached-system-directories* nil)
	  (*cached-component-directories* nil)
	  (*cached-system-creation-dates* nil)))

;; DRIVING-FUNCTION and DOCUMENTATION are functions which three positional
;; arguments: an input pathname, an output pathname, the module in which
;; the input and output live, and, finally, a list of keywords.  ARGLIST is
;; for documentation; CLASS can take on of three values: :NORMAL, which goes
;; through the full plan-construction mechanism, :FUNNY, which says "in order
;; to build a plan for this system, pretend to do a :COMPILE, then insert the
;; appropriate driving functions for this operation", and :SIMPLE, which maps
;; over all of the files in the system.  The BODY-WRAPPER is precisely that,
;; a wrapper which goes around the body provided by the macro.  ENCACHE gives
;; you a way to tell ENCACHE-FILES-OF-SYSTEM just what files to do the
;; MULTIPLE-FILE-PLISTS on; a judicious choice can save quite a bit of time.
;; SUBSYSTEMS-OK and CHECK-DEPENDENTS should be obvious.
(defprop define-system-operation define-system-operation zwei:definition-function-spec-type)
(defprop define-system-operation "System operation" si:definition-type-name)
(defmacro define-system-operation (operation driving-function documentation
				   &key (arglist
					  '(system-name &rest keys
					    &key (version :released) system-branch
						 machine-types
						 (query :confirm) silent batch
						 (include-components t)
					    &allow-other-keys))
				        (class :normal) (funny-p nil)
					(subsystems-ok t)
					(encache :both) (check-dependents nil)
					system-branch-required
					additional-plan-constructor plan-filter
					body-wrapper no-top-level-function
				   &environment env)
  ;; The driving-function and documentation-function each take four arguments:
  ;; an input, an output, the module being operated on, and keywords
  (declare (zwei:indentation 1 1 3 1))
  (when (not (memq encache '(:both :source :destination nil :nothing)))
    (ferror "ENCACHE must be one of :BOTH, :SOURCE, :DESTINATION, NIL, or :NOTHING"))
  (when (not (memq class '(:normal :simple)))
    (ferror "CLASS must be one of :NORMAL or :SIMPLE"))
  (when (and body-wrapper no-top-level-function)
    (ferror "Having a BODY-WRAPPER when there is no top-level function is nonsense"))
  (let* ((lli (lt:parse-lambda-list arglist))
	 (system-name (if ( (lt::lli-n-required lli) 1)
			  (ferror "There must be one and only one required argument")
			(first (lt::lli-required lli))))
	 (rest-arg-name (or (lt::lli-rest lli)
			    (ferror "You must supply an &REST argument")))
	 (function (fintern "~A-SYSTEM" operation))
	 (hacked-keywords
	   (loop repeat (lt::lli-n-key lli)
		 for key in (lt::lli-key lli)
		 as listp-key = (listp key)
		 as length-key = (if listp-key (length key) 0)
		 as key-name = (if listp-key (first key) key)
		 as key-value = (if (> length-key 1) (second key) nil)
		 as key-supplied = (fintern-in-package 'sct "~A-P" key-name)
		 collect `(,key-name ,key-value ,key-supplied))))
    (unless (zerop (lt::lli-n-optional lli))
      (ferror "You may not specify &OPTIONAL arguments, use &KEY arguments instead"))
    (loop for (key value supplied) in
	      '((include-components t include-components-p)
		(batch nil batch-p)
		(silent nil silent-p)
		(query :confirm query-p)
		(machine-types nil machine-types-p)
		(system-branch nil system-branch-p)
		(version :released version-p))
	  do (unless (assq key hacked-keywords)
	       (push `(,key ,value ,supplied) hacked-keywords)))
    (setq arglist `(,system-name &rest ,rest-arg-name
		    &key ,@hacked-keywords &allow-other-keys))
    (multiple-value-bind (keywords-and-values keyword-symbols keyword-names)
	(loop for (keyword value supplied-p) in hacked-keywords
	      as keyword-symbol = (intern-in-keyword-package keyword)
	      nconc `(,keyword-symbol (if ,supplied-p ,keyword ,value))
		into keywords-and-values
	      collect keyword into keyword-symbols
	      collect keyword-symbol into keyword-names
	      finally (return (values keywords-and-values keyword-symbols keyword-names)))
      ;; Bind all of the DEFSYSTEM state variables
      (flet ((keyword-name (keyword)
	       ;; Need this to get the package right
	       (let ((position (find-position-in-list keyword keyword-names)))
		 (and position
		      (nth position keyword-symbols)))))
	(let ((body
		(unless no-top-level-function
		  `((with-stack-list* (,rest-arg-name ,@keywords-and-values ,rest-arg-name)
		      (lexpr-funcall #'construct-system-internal ,operation
				     ;; For "funny" operations...
				     :original-system-op ,operation
				     :additional-plan-constructor
				     (or ,(when (memq :additional-plan-constructor
						      keyword-names)
					    (keyword-name :additional-plan-constructor))
					 ,additional-plan-constructor)
				     :plan-filter
				     (or ,(when (memq :plan-filter keyword-names)
					    (keyword-name :plan-filter))
					 ,plan-filter)
				     ,rest-arg-name))))))
	  (when body-wrapper
	    (setq body `(,(eval `(let ((body ',body))
				   ,body-wrapper) env))))
	  `(progn 
	     (record-source-file-name ',operation 'define-system-operation)
	     ,(unless no-top-level-function
		`(compiler-let ((compiler:*enable-frame-splitting* t))
		   (defun ,function (,@arglist)
		     (declare (sys:function-parent ,operation define-system-operation))
		     ;; Maintain a top-level binding of *SYSTEM*
		     (catch 'quit
		       (let* ((no-reload-sysdcl
				(cl:getf ,rest-arg-name :no-reload-system-declaration))
			      ;; Bind the top-level state variables
			      (*system*
				(find-system-named (list ,system-name
							 ,(keyword-name :version)
							 (canonicalize-system-branch
							   ,(keyword-name :system-branch)))
						   t no-reload-sysdcl))
			      (*version*
				(canonicalize-system-version-number
				  *system* ,(keyword-name :version)))
			      (*branch*
				,(when (memq :system-branch keyword-names)
				   `(canonicalize-system-branch
				      ,(keyword-name :system-branch))))
			      ;; CONSTRUCT-SYSTEM-INTERNAL canonicalizes these...
			      (*query-type* :normal)
			      (*batch-p* ,(keyword-name :batch))
			      (*query-p* ,(if (memq :query keyword-names)
					      `(if ,(keyword-name :batch)
						   (if query-p ,(keyword-name :query) nil)
						   ,(keyword-name :query))))
			      (*silent-p* ,(keyword-name :silent))
			      (aborted t))
			 (catch-error-restart ((error) "Skip top-level ~@(~A~) operation on ~A"
					       ,operation *system*)
			   (error-restart ((error) "Retry top-level ~@(~A~) operation on ~A"
					   ,operation *system*)
			     (progw *system-operation-bindings*
			       (si:with-rem-keywords
			         (,rest-arg-name ,rest-arg-name ',keyword-names)
				 (validate-system-keywords *system* ,rest-arg-name
							   :no-reload-system-declaration
							   :loading-unloaded-modules)
				 (canonicalize-state-variables)
				 (unwind-protect
				     (progn
				       ,@(when (and system-branch-required
						    (memq :system-branch keyword-names))
					   `((multiple-value (,(keyword-name :system-branch)
							      system-branch-p)
					       (ensure-reasonable-system-branch
						 *system* ,(keyword-name :system-branch)))
					     (setq *branch* ,(keyword-name :system-branch))))
				       ;; Might need to reload the sysdcl file
				       (unless no-reload-sysdcl
					 (setq *system* (reload-system-declaration-if-necessary
							  *system* *version* *branch*)
					       ;; Reset the branch if we reloaded the sysdcl
					       ;;--- This might not happen early enough...
					       *branch* (or *branch*
							    (system-default-system-branch *system*))
					       ,@(when (memq :system-branch keyword-names)
						   `(,(keyword-name :system-branch) *branch*))))
				       ,@(when check-dependents
					   `((check-depended-upon-systems ,operation)))
				       (setq machine-types (canonicalize-machine-types
							     machine-types *system* *version*)
					     machine-types-p t)
				       ,@body
				       (setq aborted nil)
				       ;; This is a reasonable value to return
				       *system*)
				   (lexpr-funcall #'finish-top-level-system-operation
						  ',operation aborted ,rest-arg-name)))))))))))
	     (let ((new (make-operation-alist
			  operation        ,operation
			  driving-function ,driving-function
			  documentation	   ,documentation
			  encache	   ,encache
			  class		   ,class
			  funny-p	   ,(not (null funny-p))
			  subsystems-ok	   ,subsystems-ok))
		   (old (assq ',operation *system-operation-alist*)))
	       (when old
		 (setq *system-operation-alist*
		       (delq old *system-operation-alist*)))
	       (push new *system-operation-alist*))))))))

;; This is used to clean up stuff which is squirrelled away in the dynamic state
;;--- This should lock the systems against other processes, but in what order?
(defun finish-top-level-system-operation (system-op aborted &rest keywords)
  ;; Save any environments which need saving
  (unless aborted
    (loop for env-name in (nreverse *environments-to-save*)
	  as env = (find-environment-named env-name)
	  do (lexpr-funcall #'dump-environment env system-op keywords)))
  ;; Decache the plan-building optimizations
  (loop for system-name in *systems-with-plans-built*
	as system = (find-system-named system-name)
	do (setf (system-plans-built system) nil))
  (loop for system in *system-caches-to-flush*
	do (flush-file-property-list-cache system)))

(defun validate-system-keywords (system keys &rest legal-keywords)
  (unless (cl:getf keys :allow-other-keys)    ; use :ALLOW-OTHER-KEYS and you're on your own
    (let* ((legal-keywords (append legal-keywords
				   (system-parameters system)
				   (environment-parameters (system-environment system))))
	   (failed (loop for key-and-value on keys by 'cddr
			 as key = (car key-and-value)
			 when (not (mem #'(lambda (x y)
					    (let ((kwd (if (listp y) (car y) y)))
					      (eq x (intern-in-keyword-package kwd))))
					key legal-keywords))
			   collect key)))
      (when failed
	(let ((offenders (format:print-list nil "~S" failed)))
	  (cl:cerror "Ignore the unrecognized keywords"
		     "The following keyword~:[s are~; is~] invalid: ~A"
		     (= (length failed) 1) offenders))))))

(defun ensure-reasonable-system-branch (system system-branch)
  (declare (values system-branch system-branch-p))
  (let ((system-branch (or system-branch
			   (system-default-system-branch system)))
	(system-branch-p t))
    (if (null system-branch)
	(when (system-version-controlled system)
	  (setq system-branch
		(signal-proceed-case ((new-branch)
				      'no-system-branch-mapping
				      :system system
				      :module nil
				      :system-branch "Default")
		  (:no-action new-branch)
		  (:new-value new-branch))))
      (when (not (system-version-controlled system))
	(cl:cerror "Ignore the system branch specification"
		   "You have specified a system branch to a non-version controlled system")
	(setq system-branch nil)))
    (values system-branch system-branch-p)))

(defun request-confirmation (string &rest args)
  (or (not (variable-boundp *query-type*))
      (eq *query-type* :no-confirm)
      (lexpr-funcall #'cl:y-or-n-p string args)))


(define-system-operation :load
  nil nil
  :arglist
    (system-name &rest keys
     &key no-warn reload no-load never-load dont-set-version
	  (load-patches t) (component-version nil)
     &allow-other-keys)
  :class :normal :encache :destination
  :subsystems-ok nil :check-dependents t
  :additional-plan-constructor #'make-plan-to-initialize-system
  :body-wrapper
    `(let ((inhibit-fdefine-warnings
	     ;; if the user said "no warn", then say nothing; else if in batch mode
	     ;;  just print the warnings with no queries; else take any outer binding.
	     (cond (no-warn t)
		   (batch :just-warn)
		   (t inhibit-fdefine-warnings))))
       (let-if (or no-warn batch)
	       ((tv:more-processing-global-enable nil))
	 (unless (equal machine-types (list *current-machine-type*))
	   (ferror "You can only load systems for the current machine type"))
	 (unless *silent-p*
	   (format t "~&Loading system ~A version ~@(~D~)" *system* *version*))
	 (si:inhibit-lengthy-background-updates
	   (si:sorting-modified-aarrays-if si:*enable-aarray-sorting-after-loads*
	     (compiler:compiler-warnings-context-bind
	       (unwind-protect (progn ,@BODY)
		 ;; Keep the software-info up to date.
		 (neti:compute-finger-string))))))))

;; For a single system *SYSTEM*, version *VERSION*, branch *BRANCH* build a plan
;; which finalizes its datastructures (like its version and patchable-system stuff),
;; perhaps loads patches for it, and runs initializations for it.
;; Subsystems get initialized here, too, although in practice, the only thing
;; that gets done is that the system initializations get run.
(defun make-plan-to-initialize-system (system-op &rest keys
				       &key no-load never-load silent
					    load-patches (top-level-p t)
				       &allow-other-keys)
  (ignore keys)
  (flet ((documentation (format-string real-version real-branch)
			#'(named-lambda system-init-documentation
					(system-name ignore ignore &rest ignore)
			    (let* ((system (find-system-named system-name))
				   (subsystem-p (typep system 'subsystem))
				   (real-version (if subsystem-p nil real-version)))
			      (format standard-output
				  (string-append "~&" format-string
						 " ~:[~;sub~]system ~A~
						   ~@[ version ~@(~D~)~]~
						   ~@[ branch ~@(~A~)~]")
				*system-pass* subsystem-p system real-version real-branch)))))
    (let* ((dont-load (or no-load never-load))
	   (system-name (system-name *system*))
	   (initialization-module
	     (make-instance 'system-initialization-module
			    :name "System initializations"
			    :inputs (list (list system-name system-name))))
	   (plan-inputs (list system-name))
	   ;; Capture *VERSION* and *BRANCH* in a lexical variable
	   (real-version *version*)
	   (real-branch *branch*)
	   (prepended-plans
	     (list
	       ;; Run the "before hooks" before anything else gets done, even
	       ;; before any files have been loaded.
	       (when (and (not dont-load)
			  (system-before-construction *system*))
		 (make-plan initialization-module *system*
			    :inputs plan-inputs
			    :driving-function
			      #'(named-lambda system-run-before-hooks
					      (system-name ignore ignore &rest keys)
				  (let ((system (find-system-named system-name)))
				    (si:with-rem-keywords (keys keys
							   '(:version :system-branch :top-level-p))
				      (lexpr-funcall (system-before-construction system)
						     system system-op
						     :version real-version
						     :system-branch real-branch
						     :top-level-p top-level-p
						     keys))))
			    :documentation
			      (documentation "~[Run~;Running~;Ran~] before hooks for"
					     real-version real-branch)))))
	   (appended-plans
	     (list
	       ;; Finalize the internal datastructures (patchability, etc.)
	       (make-plan initialization-module *system*
			  :inputs plan-inputs
			  :never-query t
			  :driving-function
			    #'(named-lambda system-init-driver
					    (system-name ignore ignore &rest keys)
				(lexpr-funcall #'initialize-system-internal
					       system-name system-op
					       ;; *VERSION* will not be in the dynamic
					       ;; environment by the time we call this
					       :real-version real-version
					       :real-branch real-branch
					       keys))
			  :documentation
			    (documentation "Initializ~[e~;ing~;ed~]"
					   real-version real-branch))
	       ;; Run the "after hooks" before loading patches
	       (when (and (not dont-load)
			  (system-after-construction *system*))
		 (make-plan initialization-module *system*
			    :inputs plan-inputs
			    :driving-function
			      #'(named-lambda system-run-after-hooks
					      (system-name ignore ignore &rest keys)
				  (let ((system (find-system-named system-name)))
				    (si:with-rem-keywords (keys keys
							   '(:version :system-branch :top-level-p))
				      (lexpr-funcall (system-after-construction system)
						     system system-op
						     :version real-version
						     :system-branch real-branch
						     :top-level-p top-level-p
						     keys))))
			    :documentation
			      (documentation "~[Run~;Running~;Ran~] after hooks for"
					     real-version real-branch)))
	       ;; Run the "before patches" initializations
	       (when (and (not dont-load)
			  (system-before-patches-initializations *system*))
		 (make-plan initialization-module *system*
			    :inputs plan-inputs
			    :driving-function
			      #'(named-lambda system-run-inits-driver
					      (system-name ignore ignore &rest ignore)
				  (let* ((system (find-system-named system-name))
					 (initializations
					   (system-before-patches-initializations system)))
				    (when (stringp initializations)
				      ;; Sometimes you need to supply a string here to
				      ;; get around package bootstrapping problems
				      (setq initializations (zwei:read-from-string initializations)))
				    (if (symbolp initializations)
					(initializations initializations)
				      (eval initializations))))
			    :documentation
			      (documentation "~[Run~;Running~;Ran~] before patches initializations for"
					     real-version real-branch)))
	       ;; Now we can safely load patches
	       (when (and (not dont-load)
			  load-patches (system-patchable *system*)
			  ;; Don't load patches for a system we just compiled
			  (not (and top-level-p (eq system-op :compile))))
		 (make-plan initialization-module *system*
			    :inputs plan-inputs
			    :driving-function
			      #'(named-lambda system-load-patches-driver
					      (system-name ignore ignore
					       &key reload load-patches &allow-other-keys)
				  (load-patches (find-system-named system-name)
						:query nil :silent silent
						:reload (or (eq load-patches :reload)
							    (not (null reload)))
						;; Don't load patches for components,
						;; this will get done naturally as a
						;; result of the full plan-building.
						;; This also prevents bogus optimization
						;; for :LOAD-PATCHES plans.
						:include-components nil))
			    :documentation 
			      (documentation "Load~[~;ing~;ed~] patches for"
					     real-version real-branch)))
	       ;; Run the "after patches" initializations
	       (when (and (not dont-load)
			  (system-after-patches-initializations *system*))
		 (make-plan initialization-module *system*
			    :inputs plan-inputs
			    :driving-function
			      #'(named-lambda system-run-inits-driver
					      (system-name ignore ignore &rest ignore)
				  (let* ((system (find-system-named system-name))
					 (initializations
					   (system-after-patches-initializations system)))
				    (when (stringp initializations)
				      ;; Sometimes you need to supply a string here to
				      ;; get around package bootstrapping problems
				      (setq initializations (zwei:read-from-string initializations)))
				    (if (symbolp initializations)
					(initializations initializations)
				      (eval initializations))))
			    :documentation
			      (documentation "~[Run~;Running~;Ran~] after patches initializations for"
					     real-version real-branch))))))
      (values (cl:remove nil prepended-plans)
	      (cl:remove nil appended-plans)))))

;; This function finishes up all the bookkeeping for a system, e.g., sets
;; its loaded version number, adds it as a patchable system, etc.  When a
;; system has just been compiled, it also write the journal files.
(defun initialize-system-internal (system-name system-op &rest keys
				   &key initial-status (update-directory t)
					real-version real-branch
				   &allow-other-keys)
  (let* ((system (find-system-named system-name))
	 (*system* system)
	 (*version* real-version)
	 (*branch* real-branch)
	 (status (or initial-status
		     (and (eq update-directory :released) :released)
		     (system-initial-status *system*)
		     :experimental)))
    (selectq system-op
      ;; Stuff specific to the :COMPILE operation
      (:compile
       (lexpr-funcall #'note-system-compiled
		      (system-environment system)
		      *system* *version* *branch* status
		      keys))
      (:load
       (lexpr-funcall #'note-system-loaded
		      (system-environment system)
		      *system* *version* *branch* status
		      keys)))))

;; Merge the changes in *UNLOADED-SYSTEM-MODULES* into *ALL-UNLOADED-SYSTEM-MODULES*
(defun record-all-unloaded-system-modules ()
  (loop for (system . modules) in *unloaded-system-modules* doing
    (loop for module in modules doing
      (let ((entry (assq system *all-unloaded-system-modules*)))
	(when (null entry)
	  (setq entry (list system))
	  (setq *all-unloaded-system-modules*
		(nconc *all-unloaded-system-modules* (list entry))))
	(unless (memq module (cdr entry))
	  ;; If this module isn't recorded, do it now
	  (nconc entry (list module)))))))

;; Loop through *ALL-UNLOADED-SYSTEM-MODULES* finding systems which we can now load
(defun load-all-unloaded-system-modules ()
  (loop for system-and-module-names on *all-unloaded-system-modules*
	as (system-name . module-names) = (first system-and-module-names)
	as system = (find-system-named system-name nil t) doing
    (when (and system
	       (get-system-version system))
      (loop for module-name in module-names
	    as module = (unless (eq (system-modules system)
				    :need-to-reload-system-declaration)
			  ;; Don't bother if the modules have been "forgotten"
			  (find-module-named system module-name))
	    as required-systems = (and module
				       (send module :get :required-systems))
	    ;; If this module has some required systems which are now
	    ;; all loaded, then we can try to load the module now
	    when (and required-systems
		      (cl:every #'get-system-version required-systems))
	      collect module into modules-to-load
	    finally
	      (when modules-to-load
		(unless *silent-p*
		  (let ((module-names (format:print-list nil "~@(~A~)"
					modules-to-load))
			(required-names (format:print-list nil "~@(~A~)"
					  (cl:delete-duplicates
					    (cl:reduce 'append modules-to-load
						       :key '(lambda (m)
							       (send m :get :required-systems))
						       )))))
		    (format standard-output
			"~&Loading the following module~P from system ~A ~
			   (which require~:[~;s~] ~A):~%  ~A"
		      (length modules-to-load) system
		      (= (length modules-to-load) 1) required-names
		      module-names)))
		(load-unloaded-system-modules system modules-to-load)
		(let ((remaining-modules
			(cl:remove-if #'(lambda (mn) (cl:member mn modules-to-load
								:key #'module-name))
				      module-names)))
		  ;;--- Flush entry when there are no more remaining modules
		  (setf (first system-and-module-names)
			(list* system-name remaining-modules))))))))

;; Create a dummy system which contains only those modules which should
;; now be loaded, and then load the system
(defun load-unloaded-system-modules (system modules-to-load)
  (with-system-locked system
    (let* ((standin-name (canonicalize-system-name
			   (format nil "~A-standin" (system-name system))))
	   (parent (subsystem-parent-system system))
	   (standin
	     (make-instance 'system
			    :name standin-name
			    :short-name standin-name
			    :pretty-name standin-name
			    :parameters (system-parameters system)
			    :default-package (system-default-package system)
			    :package-override (system-package-override system)
			    :default-module-type (system-default-module-type system)
			    :default-pathname (system-default-pathname system)
			    :default-destination-pathname
			      (system-default-destination-pathname system)
			    :initializations nil
			    :branch-mapping (system-branch-mapping system)
			    :version-controlled (system-version-controlled system)
			    :version-mapping (system-version-mapping system)
			    :advertised-in nil
			    :patchable nil
			    ;; Subsystems need to use the parent's journals,
			    :maintain-journals (system-maintain-journals parent)
			    :journal-directory (system-journal-directory parent)
			    :patch-atom (system-patch-atom parent)))
	   saved-dependencies)
      (setf (system-modules standin) modules-to-load)
      (setf (system-module-names standin) (system-module-names system))
      ;; Can't run any dependencies now, they better already be done
      (setq saved-dependencies (loop for module in modules-to-load
				     as dependencies = (module-dependencies module)
				     as definitions = (module-uses-definitions-from module)
				     do (setf (module-dependencies module) nil)
					(setf (module-uses-definitions-from module) nil)
				     collect (list dependencies definitions)))
      ;; Make sure that SCT's encacher doesn't erroneously optimize things
      (setf (system-version-loaded standin) :incomplete)
      (unwind-protect
	  (progn
	    (process:with-lock (*all-systems-lock*)
	      (push standin *all-systems*)
	      (setf (scl:gethash (system-name standin) *all-systems-table*)
		    standin)
	      (setf (scl:gethash (system-short-name standin) *all-systems-table*)
		    standin)
	      (setf (scl:gethash (system-pretty-name standin) *all-systems-table*)
		    standin))
	    (load-system standin
			 :version (system-version-loaded parent)
			 :system-branch (system-branch-loaded parent)
			 :no-reload-system-declaration t
			 :loading-unloaded-modules t
			 :include-components nil
			 :load-patches nil
			 :query nil :silent t))
	(process:with-lock (*all-systems-lock*)
	  (setq *all-systems* (delq standin *all-systems*))
	  (scl:remhash (system-name standin) *all-systems-table*)
	  (scl:remhash (system-short-name standin) *all-systems-table*)
	  (scl:remhash (system-pretty-name standin) *all-systems-table*))
	(loop for module in modules-to-load
	      for (dependencies definitions) in saved-dependencies
	      do (setf (module-dependencies module) dependencies)
		 (setf (module-uses-definitions-from module) definitions))))))
