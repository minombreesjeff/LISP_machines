;;; -*- Mode: LISP; Syntax: Zetalisp; Package: SCT; Base: 10; Lowercase: T -*-

;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

(defun describe-system (system-name &rest keys
			&key (show-files t show-files-p) (use-journals nil)
			     system-op detailed
			     (reload nil rl-p) (recompile nil rc-p)
			     version system-branch
			     (machine-types (list *current-machine-type*))
			&allow-other-keys)
  (ignore reload recompile)			;just for documentation...
  (when (and (not (null system-op))
	     (not show-files-p))
    (setq show-files nil))
  (when (and (eq system-op :load) (not rl-p))
    (setq reload t))
  (when (and (eq system-op :compile) (not rc-p))
    (setq recompile t reload t))
  (si:with-rem-keywords (keys keys '(:reload :recompile))
    (let* ((system
	     (with-stack-list (s system-name version system-branch)
	       (find-system-named s)))
	   (subsystem-p (typep system 'subsystem))
	   (parent (subsystem-parent-system system))
	   (system-source (si:get-source-file-full-name (system-name system) 'defsystem)))
      ;; Validate the keywords, include all the common ones by hand...
      (validate-system-keywords system keys
				:show-files :system-op :use-journals :detailed
				:machine-types :version :system-branch
				:component-version :include-components
				:query :silent :batch :no-warn
				:reload :no-load :never-load
				:recompile :no-compile :compile-through
				:increment-version :update-directory :initial-status
				:dont-set-version :load-patches
				:reap-protect :distribution-stream :source-category
				:distribute-sources :distribute-binaries
				:include-journals :include-patches :copy-compile-p)
      (when show-files
	(format t "~2&~:[S~;Subs~]ystem ~A" subsystem-p system)
	(when system-source
	  (format t " is defined in the file ")
	  (scl:present system-source 'fs:pathname))
	(multiple-value-bind (major minor status nil nil eco)
	    (get-system-version parent)
	  (when (null version)
	    ;; Try to use the loaded version number
	    (setq version (or major :released)))
	  (when (null system-branch)
	    (setq system-branch (system-branch-loaded parent)))
	  ;; First show some generally interesting stuff
	  (si:with-indentation (standard-output 2)
	    (when major
	      (format t "~&Version ~@(~D~)~@[.~D~]~@[ (ECO level ~D)~] ~
			   ~:[~*~;of its parent system ~A ~]is currently loaded; ~
		           its status is ~S"
		major minor eco subsystem-p parent status)
	      (when (system-patchable system)
		(format t "~&A typical patch file pathname is ~A"
		  (patch-system-pathname system :patch-file
					 (or major 1) (or minor 0) :lisp))))
	    (when system-branch
	      (format t "~&The loaded system branch is ~@(~A~)" system-branch)))
	  (cond ((system-package-override system)
		 (format t "~&Files in this system are forcibly read in package ~A"
		   (system-package-override system)))
		((system-default-package system)
		 (format t "~&Files in this system are defaultly read in package ~A"
		   (system-default-package system))))
	  (format t "~&Sources are~:[ not~] distributed; ~
		       binaries are~:[ not~] distributed."
	    (system-distribute-sources system) (system-distribute-binaries system))
	  ;; Now describe all of the files in the system, going out to the
	  ;; component directory if necessary
	  (format t "~2%The system is composed of the following files:")
	  (describe-system-files-internal system version system-branch
					  :use-journals use-journals
					  :detailed detailed))
	(format t "~2&"))
      ;; Show the plan for a system
      (when system-op
	(when (null version)
	  (setq version :released))
	(format t "~&The plan for constructing ~A version ~@(~D~) ~
		     for the ~@(~A~) operation is:"
	  system version system-op)
	(si:with-indentation (standard-output 2)
	  (let* ((*system* (find-system-named system t t))
		 (*version* (canonicalize-system-version-number
			      *system* (if subsystem-p :newest version)))
		 (*branch* (canonicalize-system-branch system-branch))
		 (*system-caches-to-flush* nil))
	    (lexpr-funcall #'describe-system-internal system-op
			   :machine-types machine-types
			   :reload reload
			   :recompile recompile
			   :original-system-op system-op
			   keys)))
	(format t "~2&"))
    system)))

;; This doesn't work incredibly well for subsystems, but it's passable
(defun describe-system-internal (system-op &rest keys
				 &key (top-level-p t) original-system-op &allow-other-keys)
  (let* ((*query-type* :no-confirm)
	 (*query-p* nil)
	 (*silent-p* nil)
	 (*batch-p* nil)
	 (*component-system-info* nil)
	 (*inhibit-validating-system-operation* t))
    (canonicalize-state-variables)
    (with-plan-for-system (plans system-op top-level-p keys)
      (let ((default-doc (operation-documentation
			   (assq original-system-op *system-operation-alist*))))
	(loop with *system-pass* = 0
	      for plan in plans
	      do (describe-plan plan default-doc nil keys)))))) 

(defun describe-system-files-internal (system version system-branch
				       &key detailed use-journals)
  (let ((flushees nil))
    (labels
      ((describe-one (system version system-branch &key detailed recurse-on-subsystem)
	 (si:with-indentation (standard-output 2)
	   (let* ((system-branch (canonicalize-system-branch system-branch))
		  ;; Note well: SYSTEM and *SYSTEM* can be different in this code!
		  ;; This is because we want to be able to show information for subsystems
		  ;; using the encached information for its parent.
		  (*system* (subsystem-parent-system system))
		  (*version* (canonicalize-system-version-number
			       *system* version :ignore-subsystems t))
		  (*branch* system-branch)
		  (*component-system-info* nil)
		  (loaded-version-p (and (not use-journals)
					 (eq *version* (system-version-loaded *system*)))))
	     (let* ((system-name (system-name system))
		    (pathname (or (si:get-source-file-name system-name 'defsystem)
				  (get system-name 'system-source-file)))
		    (truename (and pathname
				   (first (sys:get-file-loaded-id
					    (send pathname :generic-pathname) nil)))))
	       (when (or truename pathname)
		 (format t "~&~VSystem declaration file:~  ~A"
		   '(nil nil :smaller) (or truename pathname))))
	     (loop initially
		     ;; Don't encache the parent system more than once
		     (when (and (null (system-files-info *system*))
				(not loaded-version-p)
				(not recurse-on-subsystem))
		       (encache-files-of-system *system* nil :compile
						:reload t :recompile t
						:version version
						:system-branch system-branch)
		       ;; The result of wanting subsystems to win...
		       (push (system-name *system*) flushees))
		   with printed-anonymous = nil
		   for module in (system-modules system)
		   as module-in-package = (module-in-package module)
		   as system-module-p = (typep module 'system-module)
		   doing
	       (cond ((anonymous-module-p module)
		      ;; Heuristic so that we don't print gensymed names
		      (unless printed-anonymous
			(format t "~&~VAnonymous module(s):~" '(nil nil :smaller)))
		      (setq printed-anonymous t))
		     (t
		      (format t "~&~VModule ~A:~" '(nil nil :smaller) module)
		      (setq printed-anonymous nil)))
	       (si:with-indentation (standard-output 2)
		 (scl:with-character-size (:smaller)
		   (when module-in-package
		     (format t "~&Files in this module are forcibly read in package ~A"
		       module-in-package))
		   (when (or (neq (module-distribute-sources module)
				  (system-distribute-sources system))
			     (neq (module-distribute-binaries module)
				  (system-distribute-binaries system)))
		     (format t "~&Sources are~:[ not~] distributed; ~
			          binaries are~:[ not~] distributed."
		       (module-distribute-sources module)
		       (module-distribute-binaries module))))
		 (loop with environment = (system-environment *system*)
		       for (input output) in (module-inputs module)
		       as opath =
			  (or system-module-p
			      (if loaded-version-p
				  ;; Look in the world for the loaded pathname
				  (let ((opath
					  (car (get-file-loaded-info
						 environment output
						 (or module-in-package
						     (system-package-override system))))))
				    (if opath
					(send output :back-translated-pathname opath)
				      output))
				;; Look in the journals for what would be loaded
				(merge-pathname-with-version output)))
		       as ipath = (if system-module-p
				      input
				    (if loaded-version-p
					;; Look in the world for the source pathname
					(or (send (send opath :generic-pathname)
						  :get :qfasl-source-file-unique-id)
					    input)
				      (merge-pathname-with-version input)))
		       doing
		   (if system-module-p
		       ;;--- This should really supply the version and system-branch,
		       ;;--- except it's just a real pain here
		       (let* ((ipath (find-system-named ipath))
			      (subsystem-p (typep ipath 'subsystem)))
			 (multiple-value-bind (version branch)
			     (if (and (not subsystem-p)
				      (system-version-loaded ipath) 
				      (neq (system-version-loaded ipath) :incomplete)
				      (eq (system-version-loaded *system*) *version*)
				      (eq (system-branch-loaded *system*) *branch*))
				 ;; If the version of the system we are describing
				 ;; is the same as the loaded version, and the
				 ;; component system is loaded, then use the data
				 ;; from the running world.
				 (values (system-version-loaded ipath)
					 (system-branch-loaded ipath))
			       (if (and subsystem-p
					(system-version-loaded ipath)
					(neq (system-version-loaded ipath) :incomplete))
				   (values (system-version-loaded ipath)
					   (system-branch-loaded ipath))
				 (component-system-version-and-branch ipath)))
			   (format t "~&~:[Component ~;Sub~]system ~A~
					~:[ version ~@(~D~)~]~:[ branch ~@(~A~)~]"
			     subsystem-p ipath subsystem-p version
			     (null branch) branch)
			   (when (or subsystem-p detailed)
			     (describe-one ipath version branch
					   :detailed detailed
					   :recurse-on-subsystem subsystem-p))))
		     (format t "~&")
		     (scl:present ipath)
		     (let ((category (pathname-source-category ipath)))
		       (when (neq category :basic)
			 (format t " ~V(~@(~A~))~" '(nil nil :smaller) category)))
		     (when (and (neq opath ipath)
				(send opath :canonical-type))
		       (format t "  ")
		       (scl:present opath)
		       (let ((version
			       (get-file-loaded-info
				 environment
				 opath (or module-in-package
					   (system-package-override system)))))
			 (when (and version
				    (neq (send opath :version)
					 (send (car version) :version)))
			   (format t " ~V(loaded version is ~D)~"
			     '(nil nil :smaller)
			     (send (car version) :version)))))))))))))
      (unwind-protect
	  (describe-one system version system-branch :detailed detailed)
	;; Clean up after ourselves
	(loop for flushee in flushees
	      doing (flush-file-property-list-cache (find-system-named flushee)))))))


(define-system-operation :compile
  nil nil
  :arglist
    (system-name &rest keys
     &key (version :newest) (component-version nil)
	  no-warn recompile no-compile reload no-load never-load 
	  (increment-version t) (update-directory t) (initial-status nil)
	  (update-from-world nil) (load-patches t) (copy-compile-p :query)
     &allow-other-keys)
  :class :normal :encache :both
  :subsystems-ok nil :check-dependents t
  :system-branch-required t
  :additional-plan-constructor #'make-plan-to-initialize-system
  :body-wrapper
    `(let ((inhibit-fdefine-warnings
	     ;; if the user said "no warn", then say nothing; else if in batch mode
	     ;;  just print the warnings with no queries; else take any outer binding.
	     (cond (no-warn t)
		   (batch :just-warn)
		   (t inhibit-fdefine-warnings)))
	   (start-time (time:get-universal-time))
	   (machine-type-for-encaching nil))
       (let-if (or no-warn batch)
	       ((tv:more-processing-global-enable nil))
	 (unless (equal machine-types (list *current-machine-type*))
	   (ferror "You can only compile systems for the current machine type"))
	 (when (neq version :newest)
	   ;; The user is probably asking to compile a specific version of a system
	   ;; on a machine-type for which it has not yet been compiled.  Make sure.
	   (multiple-value-bind (nil nil nil files-alist component)
	       (uncached-read-component-directory *system* version t t)
	     (cond ((null component)
		    (cl:cerror "Compile version :NEWEST instead"
			       "Version ~D of ~A has never been compiled on any machine"
			       version *system*)
		    (setq version :newest
			  *version* :newest))
		   ((null files-alist)				;never compiled for this machine-type
		    (setq increment-version nil
			  increment-version-p t
			  ;; This gives us the machine-type whose journals we will read
			  machine-type-for-encaching (first (first component))))
		   (t
		    (cl:cerror "Compile version :NEWEST instead"
			       "You can only compile this system with version :NEWEST")
		    (setq version :newest
			  *version* :newest)))))
	 (when (and (not increment-version) (not update-from-world)
		    (not machine-type-for-encaching))
	   ;; If the user asked to not increment the version number, and he is
	   ;; not simply updating from the running world, then ask him if he
	   ;; really knows what he is doing
	   (let* ((*silent-p* t)				;kludge-o-matic
		  (latest-version (canonicalize-system-version-number
				    *system* :latest :ignore-subsystems t :exact-match t))
		  (released-version (canonicalize-system-version-number
				      *system* :released :ignore-subsystems t :exact-match t))
		  (patch-dir (and (neq latest-version :newest)	;never compiled
				  (uncached-read-patch-directory *system* latest-version))))
	     (cond ((and (null patch-dir)
			 (system-patchable *system*))
		    (cl:cerror "Compile the system anyway"
			       "The system ~S has never been compiled;~@
			      you should not be compiling it with :INCREMENT-VERSION NIL"
			       *system*))
		   ((or (and (system-maintain-journals *system*)
			     (eql latest-version released-version))
			;; PATCH-DIR is NIL if the system is not patchable
			(eq (patch-status patch-dir) :released)
			(cdr (patch-version patch-dir)))
		    ;; If the patch-dir indicates that this version has been released,
		    ;; or (in the case of a non-patchable system), the latest and the
		    ;; released versions are the same, then complain.  Ditto if there
		    ;; have been patches made.
		    (cl:cerror "Compile the system anyway"
			       "~:[The system ~A has been declared to be Released;~;~
			         The system ~A has already had patches made to it;~]~@
			      you should not be compiling it with :INCREMENT-VERSION NIL"
			       (cdr (patch-version patch-dir)) *system*)))))
	 (si:inhibit-lengthy-background-updates
	   (si:sorting-modified-aarrays-if si:*enable-aarray-sorting-after-loads*
	     (compiler:compiler-warnings-context-bind
	       (unwind-protect
		   (stack-let ((keys `(:machine-type-for-encaching ,machine-type-for-encaching
				       ,@keys)))
		     ,@BODY
		     ;; Dump all the compiler warnings
		     (when *batch-p*
		       (batch-print-compiler-warnings *system* "COMPILE-SYSTEM" start-time
						      *batch-p* *silent-p*))
		     ;; Maybe copy-instantiate for other machine-types
		     (when (and (cl:case copy-compile-p
				  ((t) t)
				  (:query (not *silent-p*))
				  (otherwise nil))
				(not (system-compilable-p *system*)))
		       (let* ((version (or (and (numberp *version*) *version*)
					   (system-version-loaded *system*)))
			      (machine-types-to-compile
				(query-for-copy-compile
				  *system* version (first machine-types) copy-compile-p)))
			 (copy-compile *system* version machine-types-to-compile
				       (first machine-types) (not *silent-p*)))))
		 ;; Keep the software-info up to date, in case the system was
		 ;; loaded after compiling it
		 (neti:compute-finger-string))))))))

;; Assumes that this system/version has been compiled for the current-machine-type
;; Returns UNCOMPILED-MACHINE-TYPES to avoid computing it again in the caller
(defun query-for-copy-compile (system version current-machine-type copy-compile-p)
  (multiple-value-bind (nil nil nil nil component)
      (uncached-read-component-directory system version t t)
    (let* ((uncompiled-machine-types
	     (loop for machine-type in (cl:remove current-machine-type *all-machine-types*)
		   unless (component-machine-alists component machine-type)
		     collect machine-type))
	   (mtypes-text (with-output-to-string (s)
			  (scl:format-textual-list uncompiled-machine-types #'princ
						   :conjunction "and" :stream s))))
      (when uncompiled-machine-types
	(cl:case copy-compile-p
	  ((t) uncompiled-machine-types)
	  (:query
	   (format cl:*query-io*
		   "~&The system ~A is made up entirely of modules with no compiled product,~@
    ~3Tand therefore can be /"compiled/" for other machine types by copying its journal~@
    ~3Tfiles.  You have just compiled ~A, version ~D,~@
    ~3Tfor the ~A.  This version is not yet compiled for the ~A.~%"
		   system system version current-machine-type mtypes-text)
	   (if (not (cl:member *query-p* '(nil :no-confirm)))
	       (when (cl:yes-or-no-p "Copy-compile ~A ~D for the ~A? "
				     system version mtypes-text)
		 uncompiled-machine-types)
	     (format cl:*query-io*
		     "If this compilation had been set to allow querying, you would have~@
    ~3Tbeen asked whether to copy-compile ~A ~D for the ~A.~@
    ~3THowever nothing was done, since querying was not allowed.  Please run~@
    ~3T:Compile System ~A :Version ~D on a ~A.~2&"
		     system version mtypes-text system version mtypes-text)
	     nil))
	  (otherwise nil))))))

;; This is used to shortcut the multi-architecture compilation problem
;; for systems with no compilable modules.  Copies the component-list
;; for one machine-type to another.
(defun copy-components-for-machine-type (system version for-machine-type from-machine-type)
  (let* ((system (find-system-named system))
	 (attributes (make-component-attributes
		       name (system-patch-atom system) version-number version)))
    (multiple-value-bind (file nil nil nil component)
	(uncached-read-component-directory system version t t)
      (when (cl:find for-machine-type component :key #'first)
	(ferror "~A version ~A is already compiled for the ~A."
		system version for-machine-type))
      (unless (cl:find from-machine-type component :key #'first)
	(ferror "~A version ~A has not been compiled for the ~A."
		system version from-machine-type))
      (setq component
	    (append component
		    (list
		      (append (ncons for-machine-type)
			      (cl:rest (cl:find from-machine-type component :key #'first))))))
      (write-component-directory system version file attributes component))))

(defun copy-compile (system version for-machine-types from-machine-type report-p)
  (loop for for-machine-type in for-machine-types
	do (copy-components-for-machine-type
	     system version for-machine-type from-machine-type)
	   (when report-p
	     (format t "~&~A version ~@(~D~) copy-compiled for the ~A"
	       system version for-machine-type))
	finally (when (and report-p for-machine-types)
		  (format t "~2&"))))

;; This is admittedly a hack, but it can be very useful...
(defun compile-files-of-subsystem (subsystem-name &rest keys)
  (declare (arglist subsystem-name &rest keys
		    &key (query :confirm) silent batch system-branch
			 no-warn recompile no-compile reload no-load never-load
		    &allow-other-keys))
  (let* ((subsystem (find-system-named subsystem-name))
	 (subsystem-standin-name (canonicalize-system-name
				   (format nil "~A-standin" (system-name subsystem))))
	 (subsystem-standin
	   (make-instance 'system
			  :name subsystem-standin-name
			  :short-name subsystem-standin-name
			  :pretty-name subsystem-standin-name
			  :parameters (system-parameters subsystem)
			  :default-package (system-default-package subsystem)
			  :package-override (system-package-override subsystem)
			  :default-module-type (system-default-module-type subsystem)
			  :default-pathname (system-default-pathname subsystem)
			  :default-destination-pathname (system-default-destination-pathname subsystem)
			  :initializations nil
			  :branch-mapping (system-branch-mapping subsystem)
			  :version-controlled (system-version-controlled subsystem)
			  :version-mapping (system-version-mapping subsystem)
			  :patchable nil
			  :maintain-journals nil
			  :journal-directory (system-default-pathname subsystem)
			  :advertised-in nil
			  :compile-is-transitive (system-compile-is-transitive subsystem)
			  :initial-status :experimental
			  :required-systems (system-required-systems subsystem))))
    (setf (system-modules subsystem-standin) (system-modules subsystem))
    (setf (system-module-names subsystem-standin) (system-module-names subsystem))
    (unwind-protect
	(si:with-rem-keywords (keys keys '(:version :increment-version
					   :update-directory :include-components
					   :no-reload-system-declaration))
	  (process:with-lock (*all-systems-lock*)
	    (push subsystem-standin *all-systems*)
	    (setf (scl:gethash (system-name subsystem-standin) *all-systems-table*)
		  subsystem-standin)
	    (setf (scl:gethash (system-short-name subsystem-standin) *all-systems-table*)
		  subsystem-standin)
	    (setf (scl:gethash (system-pretty-name subsystem-standin) *all-systems-table*)
		  subsystem-standin))
	  (lexpr-funcall #'compile-system subsystem-standin
					  :version :newest
					  :increment-version nil
					  :update-directory nil
					  :include-components nil
					  :no-reload-system-declaration t
					  keys))
      (process:with-lock (*all-systems-lock*)
	(setq *all-systems* (delq subsystem-standin *all-systems*))
	(scl:remhash (system-name subsystem-standin) *all-systems-table*)
	(scl:remhash (system-short-name subsystem-standin) *all-systems-table*)
	(scl:remhash (system-pretty-name subsystem-standin) *all-systems-table*)))))


(defvar *buffer-to-select-for-edit*)
(define-system-operation :edit
  #'(named-lambda edit-system-driver
		  (source ignore ignore &rest ignore)
      (multiple-value-bind (nil buffer)
	  (zwei:load-file-into-zmacs source nil)
	;; Kludge so that we enter the editor with the first file selected
	(when (null *buffer-to-select-for-edit*)
	  (setq *buffer-to-select-for-edit* buffer))))
  #'(named-lambda edit-system-documentation
		  (source ignore ignore &rest ignore)
      (format standard-output "~&Edit~[~;ing~;ed~] file ~A"
	*system-pass* source))
  :arglist
    (system-name &rest keys &key (version :newest) &allow-other-keys)
  :class :normal :encache nil
  :system-branch-required t
  :additional-plan-constructor #'include-sysdcl-file-for-operation
  :plan-filter
    #'(named-lambda edit-system-filter (system-op file module &rest ignore)
	(ignore system-op module)
	(let ((edit-p (and (not (scl:gethash file *pathname-mark-table*))
			   (zwei:file-readable-by-zmacs file))))
	  (setf (scl:gethash file *pathname-mark-table*) t)
	  edit-p))
  :body-wrapper
    `(let ((*pathname-mark-table* (scl:make-hash-table :number-of-values 0))
	   (*buffer-to-select-for-edit* nil))
       (declare (special zwei:*inside-zmacs*))
       ,@BODY
       (when *buffer-to-select-for-edit*
	 (if zwei:*inside-zmacs*
	     (zwei:make-buffer-current *buffer-to-select-for-edit*)
	   (zwei:zed (send *buffer-to-select-for-edit* :pathname))))))

(sct:define-system-operation :hardcopy
  #'(named-lambda hardcopy-system-driver
		  (source ignore ignore &rest keys
		   &key (hardcopy-device hardcopy:*default-text-printer*)
		   &allow-other-keys)
      (declare (special hardcopy:*default-text-printer*))
      (si:with-rem-keywords (keys keys '(:query :silent :batch
					 :include-components :version :system-branch
					 :additional-plan-constructor :plan-filter
					 :hardcopy-device :original-system-op
					 :machine-types))
	(lexpr-funcall #'hardcopy:hardcopy-file source hardcopy-device keys)))
  #'(named-lambda hardcopy-system-documentation
		  (source ignore ignore &rest ignore)
      (format standard-output "~&Hardcop~[y~;ying~;ied~] file ~A"
	*system-pass* source))
  :arglist
    (system-name &rest keys
     &key (version :newest)
	  (hardcopy-device hardcopy:*default-text-printer*)
	  title (copies 1) (landscape-p nil) page-headings
	  body-character-style heading-character-style
     &allow-other-keys)
  :class :normal :encache nil
  :system-branch-required t
  :plan-filter
    #'(named-lambda hardcopy-system-filter (system-op file module &rest ignore)
	(ignore system-op module)
	(let ((hardcopy-p (not (scl:gethash file *pathname-mark-table*))))
	  (setf (scl:gethash file *pathname-mark-table*) t)
	  hardcopy-p))
  :additional-plan-constructor #'include-sysdcl-file-for-operation
  :body-wrapper
    `(let ((*pathname-mark-table* (scl:make-hash-table :number-of-values 0)))
       ,@BODY))

(define-system-operation :reap-protect
  #'(named-lambda reap-protect-system-driver
		  (file ignore ignore &rest keys &key reap-protect &allow-other-keys)
      (ignore keys)
      (fs:change-file-properties file t :dont-reap reap-protect))
  #'(named-lambda reap-protect-system-documentation
		  (file ignore ignore &rest keys &key reap-protect &allow-other-keys)
      (ignore keys)
      (format standard-output "~&~:[Un-reap~;Reap~] protect~[~;ing~;ed~] file ~A"
	reap-protect *system-pass* file))
  :arglist
    (system-name &rest keys
     &key (version :latest) (machine-types :all)
	  (reap-protect t)
     &allow-other-keys)
  :class :simple :encache nil
  :subsystems-ok nil
  :plan-filter
    #'(named-lambda reap-protect-system-filter (system-op file module &rest ignore)
	(ignore system-op module)
	(let ((reap-p (and (not (scl:gethash file *pathname-mark-table*))
			   (not (fs:pathname-vc-p file)))))
	  (setf (scl:gethash file *pathname-mark-table*) t)
	  reap-p))
  :additional-plan-constructor #'include-sysdcl-file-for-operation
  :body-wrapper
    `(let ((*pathname-mark-table* (scl:make-hash-table :number-of-values 0)))
       ,@BODY))

;; Like it says: include the sysdcl file in the operation.  For subsystems,
;; include the sysdcl for the parent system
(defun include-sysdcl-file-for-operation (system-op &rest keys)
  (ignore system-op keys)
  (dbg:with-debugger-special-command (system-declaration-not-found
				      "Don't include the sysdcl file in the plan")
      (return-from include-sysdcl-file-for-operation nil)
    (let ((sysdcl-module (make-instance 'lisp-module
					:name "System declaration")))
      (list
	(make-plan sysdcl-module *system*
		   :inputs (loop with parent = (subsystem-parent-system *system*)
				 for (file) in
				     (get-system-input-and-output-defsystem-files
				       parent
				       (if (system-maintain-journals parent)
					   *version* nil))
				 collect file))))))


;;; CP commands

(cp:define-command (si:com-compile-system :command-table "System Maintenance")
    ((system-spec '((scl:type-or-string sct:system))
		  :default-type 'sct:system
		  :confirm t
		  :documentation "Program system to compile")
     &key
     (version '(dw:token-or-type (:newest) cl:integer)
	      :prompt "Newest or a version number"
	      :default :newest
	      :documentation "Which major version of the system to compile")
     (branch `((scl:null-or-type
		 ((sct:system-branch :system ,system-spec))))
	     :documentation "A system branch"
	     :default (and system-spec (not (stringp system-spec))
			   (sct:system-version-controlled system-spec)
			   (sct:system-default-system-branch system-spec))
	     :when (and (cl:member :version-control cl:*features*)
			(or (stringp system-spec)
			    (sct:system-version-controlled system-spec))))
     (condition '((cl:member :always :new-source))
		:default :new-source
		:documentation "Whether to compile each source")
     (copy-compile '(dw:token-or-type (:query) scl:boolean)
		   :prompt "for other machine types"
		   :default :query
		   :documentation "Instantiate (/"compile/") for any remaining machine types,
when possible, by copying this compilation's record")
     (load '((cl:member :everything :newly-compiled :only-for-dependencies
			:nothing))
	   :default :newly-compiled
	   :documentation "Which files to load.")
     (query '((cl:member :everything :yes :confirm-only :no))
	    :mentioned-default :everything
	    :default :no
	    :documentation
	    "Whether to ask about compiling each file, just confirm the list of files, or don't ask")
     (redefinitions-ok 'scl:boolean
		       :default nil
		       :mentioned-default t
		       :documentation
		       "Whether to proceed through redefinition warnings")
     (new-major-version 'scl:boolean
			:default (eq version :newest)
			:documentation
			"Whether to increment the major version number of the system")
     (update-directory '(or scl:boolean cl:keyword)
		       :default t
		       :prompt "Yes, No, or a version designator"
		       :documentation
		       "Whether to update the directory of the system's components")
     (silent 'scl:boolean
	     :default nil
	     :mentioned-default t
	     :documentation "Whether to suppress all terminal output")
     (batch `(or scl:boolean
		 ((fs:pathname)
		  :default-name ,(if (typep system-spec 'sct:system)
				     (sct:system-short-name system-spec)
				   system-spec)
		  :default-type :cwarns))
	    :default nil
	    :mentioned-default t
	    :documentation
	    "Whether to save compiler warnings in a file, rather than printing them")
     (include-components 'scl:boolean
			 :default t
			 :documentation
			 "Whether to include component systems")
     (component-version 'sct:system-version
			:default nil
			:mentioned-default :released
			:documentation "Which version of the component systems to load")
     (simulate 'scl:boolean
	       :prompt "compiling"
	       :default nil
	       :mentioned-default t
	       :documentation
	       "Whether to print the plan for compiling, without doing it")
     (machine-type `(cl:member ,@sct:*all-machine-types*)
		   :default sct:*local-machine-type*
		   :prompt "machine type"
		   :documentation
		     "Compile system for the target machine type"))
  (let ((system (sct:find-system-named system-spec nil nil t))
	(ok-to-proceed t))
    ;; This check is necessary here because only loaded systems are checked
    ;; in the SYSTEM type reader.  This is to prevent reading files,
    ;; extraneous output, long delays and the like during command line input.
    (if (not system)
	(format t "~& Error: System ~A not found." system-spec)
      (let ((compile-system-options))
	(setq system (sct:system-name system))	; in case a new sysdcl is loaded
	(setq compile-system-options
	      (selectq condition
		(:always (append compile-system-options '(:recompile t)))
		(:new-source (append compile-system-options '(:recompile nil)))))
	(setq compile-system-options
	      (selectq load
		(:everything (append compile-system-options
				     '(:reload t :no-load nil :never-load nil)))
		(:newly-compiled (append compile-system-options
					 '(:reload nil :no-load nil :never-load nil)))
		(:only-for-dependencies (append compile-system-options
						'(:reload nil :no-load t :never-load nil)))
		(:nothing (append compile-system-options
				  '(:reload nil :no-load nil :never-load t)))))
	(setq compile-system-options
	      (selectq query
		((:yes :everything) (append compile-system-options '(:query t)))
		(:confirm-only (append compile-system-options '(:query :confirm)))
		(:no (append compile-system-options '(:query :no-confirm)))))
	(setq compile-system-options
	      (append compile-system-options
		      `(:no-warn ,(and redefinitions-ok (or silent :just-warn))
			:increment-version ,new-major-version)))
	(setq compile-system-options
	      (selectq update-directory
		((t) (append compile-system-options '(:update-directory t)))
		((nil) (append compile-system-options '(:update-directory nil)))
		(otherwise
		 (append compile-system-options
			 `(:update-directory ,(intern (string-upcase update-directory)
						      pkg-keyword-package))))))
	(when (cl:pathnamep batch)
	  (when (null (fs:pathname-name batch))
	    (setq batch (send batch :new-name (string system))))
	  (when (null (fs:pathname-type batch))
	    (setq batch (send batch :new-type :cwarns))))
	(setq compile-system-options
	      (append compile-system-options
		      `(:silent ,silent
			:batch ,batch
			:include-components ,include-components
			:component-version ,component-version
			:version ,version
			:system-branch ,(and (cl:member :version-control cl:*features*)
					     (or (stringp system-spec)
						 (sct:system-version-controlled system-spec))
					     branch)
			:copy-compile-p ,copy-compile)))
	#+++ignore	;--- This needs a separate command interface
	(selectq declare-status
	  ((:released :latest)
	   (push `(:update-directory ,declare-status) load-system-options))
	  (nil)
	  (otherwise
	   (if (fquery
		 nil " Declare the loaded version of the ~A system to be named version :~A? "
		 system-spec (string-upcase declare-status))
	       (push `(:update-directory ,(intern (string-upcase declare-status) "KEYWORD"))
		     load-system-options)
	     (setq ok-to-proceed nil))))
	(if ok-to-proceed
	    (cond (simulate
		   (cl:fresh-line)
		   (let ((sct:*current-machine-type* machine-type))
		     (lexpr-funcall 'sct:describe-system system-spec :show-files nil
				    :system-op :compile compile-system-options)))
		  (t
		   (let ((sct:*current-machine-type* machine-type))
		     (lexpr-funcall 'sct:compile-system system-spec compile-system-options))
		   (cl:fresh-line)))
	  (format t "~&  Compile System aborted.~2&"))))))


#||						;comment out until implemented
;; Create a brand, new system
(cp:define-command (com-create-system :command-table "global")
		   ((system 'sct:system
			    :prompt "named")
		    (default-pathname 'string)
		    (logical-pathname 'string))
  ;;--- Create the new system
  (format t "Not yet implemented"))
||#

(cp:define-command (si:com-edit-system :provide-output-destination-keyword nil
				    :command-table "System Maintenance")
    ((system '((scl:type-or-string ((or sct:subsystem sct:system))))
	     :default-type '((or sct:subsystem sct:system))
	     :confirm t
	     :documentation "System to edit")
     &key
     (branch `((scl:null-or-type
		 ((sct:system-branch :system ,system))))
	     :documentation "A system branch"
	     :default (and system (not (stringp system))
			   (sct:system-version-controlled system)
			   (sct:system-default-system-branch system))
	     :when (and (cl:member :version-control cl:*features*)
			(or (stringp system)
			    (sct:system-version-controlled system))))
     (include-components 'scl:boolean
			 :default t
			 :documentation
			 "Whether to edit component systems")
     (machine-types `(scl:token-or-type (:all)
		       (scl:sequence (scl:member ,@*all-machine-types*)))
		    :default (list *current-machine-type*)
		    :prompt "machine types"
		    :documentation
		    "Edit files for the specified machine types") 
     (query '((cl:member :everything :yes :confirm-only :no))
	    :mentioned-default :everything
	    :default :no
	    :documentation
	    "Whether to ask about editing each file")
     (silent 'scl:boolean
	     :default t
	     :documentation "Whether to suppress all terminal output"))
   (setq query (selectq query
		 ((:yes :everything) t)
		 (:confirm-only :confirm)
		 (:no :no-confirm)))
   (when (neq query :no-confirm)
     (setq silent nil))
   (sct:edit-system system :query query
		    :silent silent
		    :machine-types machine-types
		    :include-components include-components
		    ;; the hairy expression is because the CP can't be trusted
		    ;; to leave NIL in there when the :when clause fails.
		    :system-branch (and (cl:member :version-control cl:*features*)
					(or (stringp system)
					    (sct:system-version-controlled system))
					branch)))

#||
(cp:define-command (com-release-system :command-table "Global"
				       :provide-output-destination-keyword nil)
    ((systems-and-versions '((scl:sequence
			       ((or ((scl:sequence-enumerated
				       ((scl:type-or-string
					  ((sct:system :true-systems-only t))))
				       (or null sct:system-version))
				     :sequence-delimiter #\space :echo-space nil)
				    ((scl:type-or-string
				       ((sct:system :true-systems-only t))))))))
			   :prompt "a sequence of systems and version numbers"))
   (loop for system-and-version in systems-and-versions
	 as system = (if (listp system-and-version)
			 (first system-and-version) system-and-version)
	 as system-version = (if (listp system-and-version)
				 (second system-and-version) :latest)
	 as version = (sct:canonicalize-system-version-number system system-version)
	 do (sct:release-system system version)))
||#

;; Define a presentation-type so that we get our own history
(scl:define-presentation-type sct-operations ()
   :expander `((cl:sequence
		 ((cl:member :all . ,(loop for (op) in sct:*system-operation-alist*
					   collect op))
		  :description "an SCT operation")))
   :description "System Construction operation(s)"
   :history t)

;; Display the plan(s) for some operation(s) on a system
(cp:define-command (si:com-show-system-plan :command-table "System Maintenance")
    ((system '((scl:type-or-string ((or sct:subsystem sct:system))))
	     :default-type 'sct:system
	     :documentation
	     "System for which to construct and display plans")
     (operations 'sct-operations
		 :prompt "for operations"
		 :default '(:load)
		 :documentation
		 "System operations for which to display a plan")
     &key
     (detailed 'scl:boolean
	       :default nil
	       :mentioned-default t
	       :prompt "describe systems to all levels"
	       :documentation
	       "Whether to describe the plans for component systems")
     (version 'sct:system-version
	      :default (if (typep system 'sct:system) :released :newest)
	      :documentation
	      "Version of the system for which to construct plans")
     (machine-types `(scl:token-or-type (:all)
		       (scl:sequence (scl:member ,@*all-machine-types*)))
		    :default (list *current-machine-type*)
		    :prompt "machine types"
		    :documentation
		    "Show plan for the specified machine types")
     (date-checking 'scl:boolean
		    :default t
		    :prompt "in plan construction"
		    :documentation
		    "Compare files against the file system"))
   (when (eq machine-types :all)
     (setq machine-types *all-machine-types*))
   (when (memq :all operations)
     (loop for (op) in sct:*system-operation-alist*
	   collect op into ops
	   finally (setq operations ops)))
   (terpri)
   (loop with sct:*date-testing-off* = (not date-checking)
	 for op in operations
	 do (sct:describe-system system :show-files nil :system-op op
					:version (if (eq op :compile) :newest version)
					:machine-types machine-types
					:detailed detailed)))

;; Display the description of a system
(cp:define-command (si:com-show-system-definition :command-table "System Maintenance")
    ((system '((scl:type-or-string ((or sct:subsystem sct:system))))
	     :default-type 'sct:system
	     :documentation
	     "System for which to display description and files")
     &key					;possible future usefulness
     (detailed 'scl:boolean
	       :default nil
	       :mentioned-default t
	       :prompt "describe systems to all levels"
	       :documentation
	       "Whether to describe the plans for component systems")
     (version 'sct:system-version
	      :default (when (typep system 'sct:basic-system)
			 (let ((version (sct:system-version-loaded
					  (sct:subsystem-parent-system system))))
			   (and (neq version :incomplete)
				version)))
	      :documentation
	      "What version of the system for which to construct plans")
     (use-journals 'scl:boolean
		   :default nil
		   :mentioned-default t
		   :documentation
		   "Prefer the system's journals to the running world"))
   (sct:describe-system system :show-files t :system-op nil
			       :version version
			       :detailed detailed :use-journals use-journals))

(cp:define-command (si:com-show-system-components :command-table "System Maintenance")
    ((system '((scl:type-or-string ((or sct:subsystem sct:system))))
	     :default-type 'sct:system
	     :documentation
	     "System for which to graph the components"))
  (let ((system (sct:find-system-named system)))
    (flet ((print-system-name (system stream)
	     (dw:with-output-as-presentation (:stream stream
					      :object system
					      :type (sys:flavor-name
						      (sys:%instance-flavor system))
					      :allow-sensitive-inferiors nil)
	       (princ system stream)
	       (scl:with-character-size (:smaller stream)
		 (multiple-value-bind (major minor status)
		     (sct:get-system-version system)
		   (when major
		     (format stream " ~@(~D~)" major)
		     (when minor
		       (format stream ".~D" minor))
		     (when status
		       (format stream " ~@(~A~)" status)))))))
	   (system-components (system)
	     (loop for component in (sct:system-component-systems system)
		   ;; This could print "Mumble is unknown" messages in the middle
		   ;; of the graph.  Who cares, execute the command again.
		   collect (sct:find-system-named component))))
      (scl:format-graph-from-root system
				  #'print-system-name
				  #'system-components
				  :orientation :horizontal
				  :dont-draw-duplicates t))))

(cp:define-command (si:com-show-additional-patches :command-table "System Maintenance")
    ((systems 'scl:((token-or-type (:All :Local)
		     ((sequence ((sct:system :patchable-only t))))))
	      :default :all
	      :prompt "for systems"
	      :documentation "System(s) for which to show the patches not yet loaded.")
     &key
     (comments '((cl:member :yes :no :ask))
	       :prompt "to be shown"
	       :default :ask
	       :mentioned-default :yes
	       :documentation "Whether to show the comments of the not-yet-loaded patches"))
   (let ((always-print t))
     (when (memq systems '(:all :local))
       (setq systems (if (eq systems :all)
			 (loop for patch-system in (sct:patch-systems-list)
			       collect (sct:patch-name patch-system))
		       (loop with local-site = (send net:*local-site* :name)
			     for patch-system in (sct:patch-systems-list)
			     as system = (sct:find-system-named (sct:patch-name patch-system))
			     as maintaining-sites = (sct:system-maintaining-sites system)
			     when (or (null maintaining-sites)
				      (memq local-site maintaining-sites))
			       collect (sct:patch-name patch-system)))
	     always-print nil)
       ;; If no specific systems were specified, check for updated logical host
       ;; definitions.  Do this first, because some patch might depend upon it.
       (sct:reload-logical-pathnames-translation-files :query nil :silent t))
     (loop for s in systems
	   as system = (sct:get-patchable-system-named s t) do
       (catch-error-restart ((error)
			     "Skip checking unloaded patches for ~A" (sct:patch-name system))
	 (let ((sct:*loading-patches-for-system*
		 (sct:find-system-named (sct:patch-name system) nil nil t))
	       (patch-dir))
	   (condition-case ()
		(catch-error-restart ((error)
				      "Skip loading patch-directory for ~A"
				      (sct:patch-name system))
		  (setq patch-dir (sct:read-patch-directory system)))
	      (fs:file-lookup-error
		(sct:sct-warn
		    "Cannot find patch system directory for ~A ~D."
		  (sct:patch-name system) (sct:patch-version system)))
	      (:no-error
		(sct:tell-about-unloaded-patches
		  system (sct:patch-dir-version-list patch-dir) comments always-print)))))
	   finally (format t "~%"))))

(cp:define-command (com-show-system-version-designations :command-table "System Maintenance")
    ((systems '(scl:sequence (scl:type-or-string sct:system))
	      :documentation "Systems for which to show named version designations"))
  (loop for system in systems doing
    (let ((system (sct:find-system-named system))
	  (designations-plist nil))
      (when (sct:system-maintain-journals system)
	(multiple-value-bind (nil nil plist)
	    (sct:read-system-directory system t)
	  (setq designations-plist (cdr plist))))
      (if (null designations-plist)
	  (format t "~&There are no version designations for ~A~%" system)
	(format t "~&Version designations for system ~A~%" system)
	(scl:formatting-table (t :inter-column-spacing 2)
	  (loop for (designator version) on designations-plist by 'cddr doing
	    (scl:formatting-row ()
	      (scl:formatting-cell ()
		(format t " ~@(~A~)" designator))
	      (scl:formatting-cell ()
		(format t "~D" version)))))))
    (terpri)))
