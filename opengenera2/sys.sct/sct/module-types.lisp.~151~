;;; -*- Mode: LISP; Syntax: Zetalisp; Package: SCT; Base: 10; Lowercase: T -*-

;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; Basic module-type definitions for the System Construction Tool


;; An abstract module type knows only about its input files, and it returns
;; the "null" mapping functions (i.e., the system must supply it)
;; A module may handle any of the system-constructing operators, such as :LOAD
;; or :EDIT.  NB: the DEFMETHODs which implement these should name the method
;; with a keyword, and should return a single value, the PLAN object which
;; will carry out the current system operation over the module (the single
;; exception is the :COMPILE method, which may return a second value of T to
;; indicate that some file in the module required compilation).  When a method
;; for a module type is called, SELF is the current module, and it gets passed
;; as its other arguments the current system-operation and all of the keywords
;; which the user supplied.  DEFAULT-KEYWORD-ARGUMENTS can be used to fill in
;; unsupplied keyword arguments from the system's parameters.  *SYSTEM* is
;; bound to the system being constructed.

(defmethod (:print-self basic-module) (stream ignore slashify)
  (let ((scl:*print-string-length* nil))
    (if slashify
	(si:printing-random-object (self stream :typep)
	  (princ name stream))
      (princ name stream))))

;; Everything built on BASIC-MODULE gets to have a method which parses
;; the clauses.  Each method should return two values, the unparsed clauses
;; and the system.  Any unparsed clauses get handled at a higher level.
(defgeneric parse-module-specific-clauses (module clauses system)
  (:method-combination :pass-on :most-specific-first clauses system))

;; Every type of module supports :LOAD-WHEN-SYSTEMS-LOADED, a.k.a. :REQUIRED-SYSTEMS.
(defmethod (parse-module-specific-clauses basic-module) (clauses system)
  (let ((systems (or (assq :load-when-systems-loaded clauses)
		     (assq :required-systems clauses))))
    (when systems
      (setq clauses (delq systems clauses))
      (when (anonymous-module-p self)
	(cl:cerror "Use the ~S clause anyway"
		   "You should not be using the ~S clause in an anonymous module"
	  (car systems)))
      (send self :putprop (cdr systems) :required-systems)))
  (values clauses system))

;; Record an unloaded module of a system so that it can be loaded later
(defun-in-flavor (record-unloaded-system-module basic-module) (system)
  (let ((entry (assq (system-name system) *unloaded-system-modules*)))
    (when (null entry)
      (setq entry (list (system-name system)))
      (setq *unloaded-system-modules* (nconc *unloaded-system-modules* (list entry))))
    (unless (memq name (cdr entry))
      ;; If this module isn't recorded, do it now
      (nconc entry (list name))))
  nil)

;; When we're loading or compiling a system, don't build a plan for this module if
;; its required systems aren't loaded
(defun-in-flavor (required-systems-present-p basic-module) (system-op)
  (flet ((system-loaded-p (system-name)
	   ;; We need to check to see if the system is loaded now,
	   ;; or we are about to load it as part of this plan.
	   (or (get-system-version system-name)
	       (let ((system (find-system-named system-name nil t)))
		 (and (boundp '*systems-with-plans-built*)
		      (memq system-name *systems-with-plans-built*)
		      (memq :load (system-plans-built system)))))))
    (let ((required-systems (send self :get :required-systems)))
      (or (not (or (eq system-op :compile) (eq system-op :load)))
	  (null required-systems)
	  (cl:every #'system-loaded-p required-systems)
	  ;; If we're trying to compile a system, then don't just quietly
	  ;; skip compiling some module.  Ask the user if he wants to pretend
	  ;; the missing system is loaded.
	  (when (eq system-op :compile)
	    (let ((offenders (loop for required in required-systems
				   when (not (system-loaded-p required))
				     collect required)))
	      (setq offenders (format:print-list nil "~A" offenders))
	      (cl:cerror "Compile ~A as though the missing systems were loaded"
			 "In order to compile the system ~A, ~
			  the following systems must be loaded:~%  ~A"
	        *system* offenders))
	    t)))))

(defwhopper (:compile basic-module) (system-op &rest keys
				     &key original-system-op &allow-other-keys)
  (ignore system-op)
  (when (required-systems-present-p original-system-op)
    (lexpr-continue-whopper system-op keys)))

(defwhopper (:load basic-module) (system-op &rest keys
				  &key original-system-op &allow-other-keys)
  (ignore system-op)
  (if (required-systems-present-p original-system-op)
      (lexpr-continue-whopper system-op keys)
    (record-unloaded-system-module *system*)))

(defwhopper (:read basic-module) (system-op &rest keys
				  &key original-system-op &allow-other-keys)
  (ignore system-op)
  (if (required-systems-present-p original-system-op)
      (lexpr-continue-whopper system-op keys)
    (record-unloaded-system-module *system*)))

(defmethod (version-control-defaults basic-module) (system)
  (declare (values (version-controlled branch-mapping)))
  (values (system-version-controlled system)
	  (system-branch-mapping system)))

;; If the files in the module are version-controlled, then just return the
;; branch, otherwise return NIL.  This can also be called on to return a
;; new system-branch instead of a true VC branch if PRODUCE-SYSTEM-BRANCH is T
(defun-in-flavor (vc-branch-internal basic-module)
		 (system-branch &optional (produce-system-branch nil))
  (if (not version-controlled)
      nil
    (let ((vc-branch
	    (loop with system-branch = (if system-branch
					   (canonicalize-system-branch system-branch)
					 (system-default-system-branch *system*))
		  ;; If BRANCH-MAPPING is NIL for the module, then we could
		  ;; fall back to the system's value, but we don't, since the
		  ;; only way it can be NIL is for the user to have explicitly
		  ;; specified it that way (see PARSE-MODULE-CLAUSES)
		  for (system-branches vc-branch) in (cdr branch-mapping)
		  do (when (memq system-branch system-branches)
		       (return vc-branch))
		     ;; If there is no match, use the default
		  finally (return
			    (let ((default-vc-branch (or (first branch-mapping)
							 system-branch)))
			      (or default-vc-branch
				  ;; Give the user a chance to select his own VC branch
				  (signal-proceed-case ((new-branch)
							'no-system-branch-mapping
							:system *system*
							:module self
							:system-branch system-branch)
				    (:no-action new-branch)
				    (:new-value new-branch))))))))
      (and vc-branch
	   (if produce-system-branch
	       (canonicalize-system-branch vc-branch)
	     (string-thin (string vc-branch) :remove-bits t :error-if :fat))))))

(defmethod (vc-branch-if-appropriate basic-module) (system-branch)
  (declare (values vc-branch))
  (vc-branch-internal system-branch nil))

;; Needed for compatibility with 7.1, where this was not a method on modules
(defun collect-inputs-and-outputs (&rest args)
  (declare (arglist inputs &optional merge-version))
  (if (typep (first args) 'basic-module)
      ;; Someone in 7.2 is using the old form in the new way
      (lexpr-funcall #'collect-module-inputs-and-outputs args)
    ;; We have the module inputs, find the module they came from
    (let* ((inputs (first args))
	   (merge-version (second args))
	   (module (loop for module in (system-modules *system*)
			 do (when (eq inputs (module-inputs module))
			      (return module))
			 finally (ferror "Couldn't find the module with these inputs;~@
					  please use ~S instead."
				   'collect-module-inputs-and-outputs))))
      ;; Call the real function now that we have the module
      (collect-module-inputs-and-outputs module merge-version))))

(compiler:make-obsolete collect-inputs-and-outputs
			"use SCT:COLLECT-MODULE-INPUTS-AND-OUTPUTS instead")

;; From a module, return both the inputs and the outputs, all fully merged
(defmethod (collect-module-inputs-and-outputs basic-module) (&optional merge-version
							     &key vc-branch)
  (declare (values module-inputs module-outputs))
  (loop with merge-input = (or (eq merge-version t)
			       (eq merge-version :input))
	with merge-output = (or (eq merge-version t)
				(eq merge-version :output))
	for (input output) in inputs
	as input-file = (if (typep input 'fs:pathname)
			    (let* ((ip (if merge-input
					   (merge-pathname-with-version input)
					   input))
				   ;; If there is already a VC branch, use it
				   (vcb (or (send ip :vc-branch) vc-branch))
				   (vcv (send ip :vc-version)))
			      (send ip :new-pathname
				       :vc-branch vcb
				       :vc-version (and vcb (or vcv :newest))))
			  input)
	as output-file = output
	do (when (typep output-file 'fs:pathname)
	     ;;--- This can't be the right place to do this
	     (setq output-file (send output-file :new-type
				     (filetype-for-machine 
				       (send output-file :canonical-type)
				       *current-machine-type* self)))
	     (when merge-output
	       (setf output-file (merge-pathname-with-version output-file))))
	collect input-file into module-inputs
	collect output-file into module-outputs
	finally (return (values module-inputs module-outputs))))

;; Return a plan which includes only the inputs for this module; the operation
;; must be supplied later by CONSTRUCT-SYSTEM-INTERNAL
(defmethod (:unclaimed-message basic-module) (message system-op &rest keys
					      &key system-branch &allow-other-keys)
  (ignore message system-op keys)
  (make-plan self *system*
	     :inputs (collect-module-inputs-and-outputs
		       self :input
		       :vc-branch (vc-branch-if-appropriate self system-branch))
	     :default-input-type (source-file-type-default self)))

;; Canonicalize the inputs and outputs, and add each generic pathname to the
;; specified system.  Note that inputs and outputs must be either pathnames or
;; strings.  Modules which can take symbols are inputs (e.g., :SYSTEM or :FONT
;; modules) have their own versions of this method.
(defmethod (canonicalize-module-pathnames basic-module) (system)
  (loop for input in inputs
	as input-file = (if (listp input) (first input) input)
	as ipath-p = (or (stringp input-file)
			 (typep input-file 'fs:pathname))
	as real-input = (if ipath-p
			    (merge-pathname-with-defaults
			      input-file (source-file-type-default self) system)
			  (ferror "The input ~S in module ~A is neither a string nor a pathname"
			    input-file self))
	as explicit-output = (listp input)
	as output-file = (if (listp input) (second input) input-file)
	as opath-p = (or (stringp output-file)
			 (typep output-file 'fs:pathname))
	as real-output = (if opath-p
			     (merge-pathname-with-defaults
			       output-file (product-file-type-default self) system
			       ;; Force the output type if none was given explicitly
			       :force-type (null explicit-output)
			       ;; Destination files go to the destination pathname
			       :destination-file t)
			   (if (null output-file)
			       nil
			     (ferror "The output ~S in module ~A is neither a string nor a pathname"
			       output-file self)))
	do (when ipath-p
	     (add-pathname-to-system system real-input (if opath-p real-output)))
	collect `(,real-input ,real-output) into inputs-and-outputs
	finally (setq inputs inputs-and-outputs)))

;; This is useful when the input and output pathnames will be identical, for example,
;; in :LISP-LOAD-ONLY modules
(defun-in-flavor (canonicalize-module-input-pathnames basic-module) (system default-type)
  (loop for input-file in inputs
	as ipath-p = (or (stringp input-file)
			 (typep input-file 'fs:pathname))
	as real-input = (if ipath-p
			    (merge-pathname-with-defaults
			      input-file default-type system)
			  (ferror "The input ~S in module ~A is neither a string nor a pathname"
			    input-file self))
	do (add-pathname-to-system system real-input)
	collect `(,real-input ,real-input) into inputs-and-outputs
	finally (setq inputs inputs-and-outputs)))

(defmethod (canonicalize-category-pathnames basic-module) (system pathnames)
  (loop for path in pathnames
	as path-p = (or (stringp path)
			(typep path 'fs:pathname))
	as real-path = (if path-p
			   (merge-pathname-with-defaults
			     path (source-file-type-default self) system)
			 (ferror "The input ~S in module ~A is neither a string nor a pathname"
			   path self))
	collect (send real-path :generic-pathname)))

;; The default compilation method makes a plan which compiles all the inputs
;; into :BIN outputs, iff FILE-NEWER-THAN-FILE-P or recompilation forced.
;; The second returned value is T iff anything needs to be compiled; this
;; is the only case in which it is permissible to return a second value from
;; any of the methods of a module.  FORCE-COMPILATION (which is set when
;; a :USED module returns T from this function) does what it says...
(defmethod (default-compile basic-module) (system-op recompile driving-function documentation
					   &rest keys
					   &key original-system-op system-branch 
						force-bin-type
					   &allow-other-keys)
  (declare (values plan compilations-p))
  (ignore system-op keys)
  (multiple-value-bind (input-files output-files)
      (collect-module-inputs-and-outputs
	self :input
	:vc-branch (vc-branch-if-appropriate self system-branch))
    (multiple-value-bind (ins outs)
	(loop for input in input-files
	      for output in output-files
	      do (cond (force-bin-type
			(setq output (send output :new-type force-bin-type)))
		       ((null (send output :canonical-type))
			(setq output (send output :new-type (product-file-type-default self)))))
	      ;; Don't bother checking the file system if we are recompiling, or
	      ;; something we :USE'd was compiled, or :COMPILE-SATISFIES-LOAD is T
	      when (or recompile force-compilation compile-satisfies-load
		       (file-newer-than-file-p *system* input output self))
		collect input into ins
		and collect output into outs
		;; If we have already loaded a version of the BIN file and are
	        ;; compiling to create a new version of the BIN file, then we
		;; need to "tick" the cached information so that any load plan
	        ;; for this file will succeed.
		;;--- Note that if a user answers NO to a compile query, then
		;;--- he will still get asked if he wants to load the .BIN file.
		and do (unless (operation-funny-p
				 (assq original-system-op *system-operation-alist*))
			 (tick-file-property-list *system* output))
	      finally (return (values ins outs)))
    (values
      (make-plan self *system*
		 :inputs ins
		 :outputs outs
		 :default-input-type (source-file-type-default self)
		 :default-output-type (or force-bin-type
					  (product-file-type-default self))
		 :driving-function
		   #'(named-lambda default-compile-driver (&rest args)
		       (multiple-value-bind (binary source-truename binary-truename)
			   (lexpr-funcall driving-function args)
			 ;; Save the source and binary truenames returned by the
			 ;; compiler for use in the journalling phase
			 (when binary		;might have skipped the compile...
			   (push `(,(send binary :generic-pathname)
				   ,source-truename ,binary-truename)
				 *source-and-product-truenames*))))
		 :documentation
		   #'(named-lambda default-compile-documentation
				   (source bin module &rest ignore)
		       (let ((output (if (and (cl:equalp (send source :name)
							 (send bin :name))
					      (cl:equalp (send source :directory)
							 (send bin :directory))
					      (cl:equalp (send source :host)
							 (send bin :host)))
					 nil bin)))
			 (format standard-output "~&~A ~A~
					          ~@[ in package ~A~]~
						  ~@[ into file ~A~]"
			   (documentation-for-pass documentation)
			   source (package-for-module module) output))))
      (not (null ins))))))

;; The default loading method makes a plan which loads all the inputs only
;; if necessary.  When INHIBIT-LOADING is non-NIL (set when this module was
;; compiled and COMPILE-SATISFIES-LOAD is also set), the load is not done.
;;--- INHIBIT-LOADING should probably be per-file, not per-module
(defmethod (default-load basic-module) (system-op reload
					driving-function documentation
					&rest keys
					&key force-bin-type 
					&allow-other-keys)
  (ignore system-op keys)
  (multiple-value-bind (nil input-files)
      (collect-module-inputs-and-outputs self :output)
    (let ((ins (loop for input-file in input-files
		     when force-bin-type
		       do (setf input-file (send input-file :new-type force-bin-type))
		     when (and (not inhibit-loading)
			       (or reload
				   (file-newer-than-installed-p *system* input-file self)))
		     collect input-file)))
      (make-plan self *system*
		 :inputs ins
		 :default-input-type (or force-bin-type
					 (product-file-type-default self))
		 :driving-function
		   #'(named-lambda default-load-driver (&rest args)
		       (multiple-value-bind (binary binary-truename)
			   (lexpr-funcall driving-function args)
			 ;; Save the binary truename only if we have not already
			 ;; saved it via a :COMPILE function
			 (when binary		;might have skipped the load...
			   (let ((generic (send binary :generic-pathname)))
			     (unless (assq generic *source-and-product-truenames*)
			       (push `(,generic nil ,binary-truename)
				     *source-and-product-truenames*))))))
		 :documentation
		   #'(named-lambda default-load-documentation
				   (bin ignore module &rest ignore)
		       (format standard-output "~&~A ~A~@[ into package ~A~]"
			 (documentation-for-pass documentation)
			 bin (package-for-module module)))))))

(defmethod (default-read basic-module) (system-op reload driving-function documentation
					&rest keys
					&key system-branch
					&allow-other-keys)
  (ignore system-op keys)
  (let ((ins (loop for input-file
		       in (collect-module-inputs-and-outputs
			    self :input
			    :vc-branch (vc-branch-if-appropriate self system-branch))
		   when (and (not inhibit-loading)
			     (or reload
				 (file-newer-than-installed-p *system* input-file self)))
		     collect input-file)))
    (make-plan self *system*
	       :inputs ins
	       :default-input-type (source-file-type-default self)
	       :driving-function
	         #'(named-lambda default-read-driver (&rest args)
		     (multiple-value-bind (pathname truename)
			 (lexpr-funcall driving-function args)
		       ;; Collect this truename, unless it is already on
		       ;; the list by some other means
		       (when pathname		;might have skipped the read...
			 (let ((generic (send pathname :generic-pathname)))
			   (unless (assq generic *source-and-product-truenames*)
			     (push `(,generic ,truename nil)
				   *source-and-product-truenames*))))))
	       :documentation
	         #'(named-lambda default-read-documentation
				 (source ignore module &rest ignore)
		     (format standard-output "~&~A ~A~@[ into package ~A~]"
		       (documentation-for-pass documentation)
		       source (package-for-module module))))))

;; Merge all the various package specifications
;; Do not return the system's default package unless FORCE-P is T, because
;; that means all files in the module will be forcibly hacked in that package.
(defun package-for-module (module &optional (system *system*) force-p)
  (declare (values package default-p))
  (let* ((default-pkg (and (system-default-package system)
			   (pkg-find-package (system-default-package system))))
	 (pkg (or (system-package-override system)
		  (module-in-package module)
		  (and force-p default-pkg))))
    (when pkg (setq pkg (pkg-find-package pkg)))
    (values pkg (eq pkg default-pkg))))

(defmethod (internal-dependencies basic-module) (system-op module-op)
  (ignore system-op module-op)
  nil)

;; The default module is not compilable
(defmethod (module-compilable-p basic-module) () nil)

(defmethod (source-file-type-default basic-module) ()
  nil)

(defmethod (product-file-type-default basic-module) ()
  nil)

;; Let the less abstract module-type define the defaults, and if it doesn't,
;; just get the defaults from the system itself
(defmethod (distribution-defaults basic-module) (system)
  (declare (values distribute-sources distribute-binaries source-category))
  (values (system-distribute-sources system)
	  (system-distribute-binaries system)
	  (system-source-category system)))

;; Normally, the distibution pathnames are just the input pathnames
(defmethod (distribution-pathname basic-module) (pathname &rest ignore)
  pathname)

(defmethod (module-special-source-category basic-module) (pathname)
  (ignore pathname)
  nil)

;; We don't load patches for anything but system modules
(defmethod (:load-patches basic-module) (system-op &rest keys)
  (ignore system-op keys)
  nil)


;;; Abstract module types, from which real modules are built

(defflavor compilable-module () (basic-module))

(defmethod (module-compilable-p compilable-module) () t)

;; This module type is for anything whose :LOAD method calls the BIN loader
(defflavor bin-load-module () (basic-module))

;; In order to :LOAD a bin file, it must be :COMPILE'd first
(defmethod (internal-dependencies bin-load-module) (system-op module-op)
  (if (eq system-op :compile)
      (selectq module-op
	(:load `((:compile ,name)))
	(otherwise nil))
    nil))

;; :NEVER-LOAD T means "no matter what anyone else says, don't ever :LOAD anything"
(defmethod (:load bin-load-module) (system-op &rest keys
					      &key never-load reload &allow-other-keys)
  (unless never-load
    (lexpr-funcall #'default-load
		   self system-op reload
		   #'(named-lambda bin-load-driver
				   (bin ignore module &rest ignore)
		       (let ((truename
			       (load-binary-file 
				 (system-environment *system*) bin
				 :verbose nil
				 :default-package (system-default-package *system*)
				 :package (package-for-module module))))
			 (and truename
			      (values bin truename))))
		   '("Load" "Loading" "Loaded")
		   keys)))

;; This is needed because basic-module requires a :COMPILE
(defmethod (:compile bin-load-module) (&rest ignore)
  (ferror "The :COMPILE method for BIN-LOAD-MODULE should never be called.~@
	   Some flavor that contains it must be missing a :COMPILE method."))


;; This module type is for anything for which it is not meaningful to load
;; or compile the inputs
(defflavor no-load-or-compile-module () (basic-module))

(defmethod (:compile no-load-or-compile-module) (system-op &rest keys)
  (ignore system-op keys)
  nil)

;; You may wonder why we have a :LOAD method for "no load" modules at all.
;; The reason is that, even though these modules are not loaded or compiled,
;; they are still distributed (or reap-protected, or whatever).  Since we
;; make the driving and documentation functions NIL, the plan will not do
;; anything except set the loaded-id for the file unless these slots are
;; explicitly filled in later; distribution and its friends does this.
(defmethod (:load no-load-or-compile-module) (system-op
					      &key never-load system-branch &allow-other-keys)
  (ignore system-op)
  (unless never-load
    (multiple-value-bind (input-files nil)
	;; Since these files are never compiled, we use the input file
	;; as the output file as well!
	(collect-module-inputs-and-outputs
	  self :input
	  :vc-branch (vc-branch-if-appropriate self system-branch))
      (make-plan self *system*
		 :inputs input-files
		 :default-input-type (source-file-type-default self)
		 :driving-function
		   #'(lambda (source ignore module &rest ignore)
		       (with-open-file (stream source :direction :probe)
			 (when stream
			   (let-if (system-default-package *system*)
				   ((package (pkg-find-package
					       (system-default-package *system*))))
			     ;; So that journalling does not complain...
			     (sys:set-file-stream-loaded-id
			       stream (package-for-module module))))))
		 :documentation nil))))


;; This module type is for anything which does not have a real source file,
;; i.e., it isn't meaningful to edit or hardcopy it
(defflavor binary-module () (basic-module))

(defmethod (:edit binary-module) (system-op &rest keys)
  (ignore system-op keys)
  nil)

(defmethod (:hardcopy binary-module) (system-op &rest keys)
  (ignore system-op keys)
  nil)

;; This is needed because basic-module requires a :compile 
(defmethod (:compile binary-module) (&rest ignore)
  (ferror "The :COMPILE method for BINARY-MODULE should never be called.~@
	   Some flavor that contains it must be missing a :COMPILE method."))


;; Handy macro for defining a module type
(defprop define-module-type define-module-type zwei:definition-function-spec-type)
(defprop define-module-type "Module type" si:definition-type-name)
(defmacro define-module-type (type source-default product-default &body base-flavors)
  (let ((base-flavors (if (null base-flavors) '(basic-module) base-flavors))
	(flavor (fintern "~A-MODULE" type)))
    `(progn
       (record-source-file-name ',type 'define-module-type)
       (defprop ,flavor (,type define-module-type) si:flavor-parent)
       (let ((old (assq ',type *module-type-flavor-alist*)))
	 (when old
	   (setq *module-type-flavor-alist* (delq old *module-type-flavor-alist*)))
	 (push '(,type . ,flavor) *module-type-flavor-alist*))
       (let ((old (assq ',type *module-type-file-type-alist*)))
	 (when old
	   (setq *module-type-file-type-alist* (delq old *module-type-file-type-alist*)))
	 (push (list ',type ,source-default ,product-default) *module-type-file-type-alist*))
       (when ,source-default
	 (cl:pushnew ,source-default *source-file-types*))
       (when ,product-default
	 (cl:pushnew ,product-default *destination-file-types*))
       (defflavor ,flavor () (,@base-flavors))
       (defmethod (source-file-type-default ,flavor) ()
	 (declare (sys:function-parent ,type define-module-type))
	 ,source-default)
       (defmethod (product-file-type-default ,flavor) ()
	 (declare (sys:function-parent ,type define-module-type))
	 ,product-default))))


;;; Miscellaneous module type definitions

;; System modules know how to compile and load themselves
(define-module-type :system nil nil)

(defmethod (parse-module-specific-clauses system-module) (clauses system)
  (ignore system)
  (let ((version (assq :version clauses)))
    (when version
      (setq clauses (delq version clauses))
      (send self :putprop (second version) :version)))
  clauses)

;; Canonicalize the inputs and outputs, which for a system module means just make
;; the inputs a list of strings which are the names of the systems.
(defmethod (canonicalize-module-pathnames system-module) (system)
  (ignore system)
  (loop for input in inputs
	as input-file = (if (listp input) (first input) input)
	as real-input = (string input-file)
	as output-file = (if (listp input) (second input) input-file)
	as real-output = (string output-file)
	collect `(,real-input ,real-output) into inputs-and-outputs
	finally (setq inputs inputs-and-outputs)))

(defmethod (canonicalize-category-pathnames system-module) (system systems)
  (ignore system systems)
  (cl:cerror "Ignore the :SOURCE-CATEGORY"
	     "It does not make sense to include systems in a :SOURCE-CATEGORY list~@
	      for the module ~A"
    self))

;; A system is compilable if any one of its modules is compilable.
(defun system-compilable-p (system)
  (loop for mod in (system-modules system)
	thereis (module-compilable-p mod)))

;; A system module is compilable if any one of its components is compilable.
(defmethod (module-compilable-p system-module) ()
  (loop for (system-name) in inputs
	as system = (find-system-named system-name t t)
	thereis (system-compilable-p system)))

;; Distributing a component system should just distribute the system itself
(defmethod (distribution-pathname system-module) (system-name &rest ignore)
  (let ((system (find-system-named system-name t t)))
    system))

(defmethod (vc-branch-if-appropriate system-module) (system-branch)
  (declare (values system-branch))
  (vc-branch-internal system-branch t))

;; Actually, VC-BRANCH is really a system branch here
(defmethod (collect-module-inputs-and-outputs system-module) (&optional merge-version
							      &key vc-branch)
  (declare (values module-inputs module-outputs))
  (ignore merge-version vc-branch)
  (loop for (input output) in inputs
	collect input into module-inputs
	collect output into module-outputs
	finally (return (values module-inputs module-outputs))))

;; In order to :LOAD a system, it must be :COMPILE'd first.  Naturally, the :COMPILE
;; is not really done except for compile-through systems or subsystems
(defmethod (internal-dependencies system-module) (system-op module-op)
  (if (eq system-op :compile)
      (selectq module-op
	(:load `((:compile ,name)))
	(otherwise nil))
    nil))

;; Compiling a component system doesn't do a thing, unless the user
;; explicitly requests it
;;--- If something was compiled in a subsystem module, and other module
;;--- :USES-DEFINITIONS-FROM that subsystem, then that module should be
;;--- compiled, too.  It may be enough to return a second value of T when
;;--- the list of plans in non-NIL.
(defmethod (:compile system-module) (system-op &rest keys
				     &key compile-through no-compile &allow-other-keys)
  (ignore system-op)
  (unless no-compile
    (if compile-through
	(lexpr-funcall #'make-plan-for-component-systems
		       self :compile inputs "Compile" keys)
      (loop for input in inputs
	    as component = (find-system-named (car input) t t)
	    when (and component (system-compile-is-transitive component))
	      collect input into transitive-components
	    finally (return (if transitive-components
				(lexpr-funcall #'make-plan-for-component-systems
					       self :compile transitive-components
					       "Compile" keys)
			      nil))))))

(defmethod (:load system-module) (system-op &rest keys
				  &key never-load reload-for-components &allow-other-keys)
  (ignore system-op)
  (unless never-load
    ;; :RELOAD-FOR-COMPONENTS overrides :RELOAD, since :RECOMPILE does not
    ;; imply :RELOAD for component systems.  MAKE-PLAN-FOR-SYSTEM has more
    ;; support for this kludge.
    (si:with-rem-keywords (keys keys '(:reload-for-components :reload))
      (lexpr-funcall #'make-plan-for-component-systems
		     self :load inputs "Load"
		     :reload reload-for-components
		     keys))))

(defmethod (:reap-protect system-module) (system-op &rest keys
					  &key compile-through &allow-other-keys)
  (ignore system-op)
  ;; This is a bit of a kludge: we reap-protect components only if they
  ;; are "compile through"
  (if compile-through
      (lexpr-funcall #'make-plan-for-component-systems
		     self :reap-protect inputs "Reap protect" keys)
    (loop for input in inputs
	  as component = (find-system-named (car input) t t)
	  when (and component (system-compile-is-transitive component))
	    collect input into transitive-components
	  finally (return (if transitive-components
			      (lexpr-funcall #'make-plan-for-component-systems
					     self :reap-protect transitive-components
					     "Reap protect" keys)
			    nil)))))

(defmethod (:unclaimed-message system-module) (message system-op &rest keys)
  (ignore message)
  (lexpr-funcall #'make-plan-for-component-systems
		 self system-op inputs (string-capitalize-words system-op) keys))

;; Believe it or not, we don't even build the plan for loading patches here,
;; it is done completely by an additional plan-constructor!  We need to pass
;; the operation to all the components so that the additional constructor is
;; called for each component.
(defmethod (:load-patches system-module) (system-op &rest keys)
  (lexpr-funcall #'make-plan-for-component-systems
		 self system-op inputs (string-capitalize-words system-op) keys))


;; This is a special case of the system module which is used when initializing
;; systems and their components.  It is never used for anything except as a
;; placemarker, so nobody should ever call any methods for it.  The flavor
;; must not inherit from SYSTEM-MODULE!
(define-module-type :system-initialization nil nil)

(defun-in-flavor (illegal-call system-initialization-module) ()
  (ferror "Someone is calling into a :SYSTEM-INITIALIZATION module, which shouldn't happen"))

(defmethod (canonicalize-module-pathnames system-initialization-module) (ignore)
  (illegal-call))

(defmethod (canonicalize-category-pathnames system-initialization-module) (ignore ignore)
  (illegal-call))

(defmethod (distribution-pathname system-initialization-module) (ignore &rest ignore)
  (illegal-call))

(defmethod (:compile system-initialization-module) (ignore &rest ignore)
  (illegal-call))

(defmethod (:unclaimed-message system-initialization-module) (message ignore &rest ignore)
  (ignore message)
  (illegal-call))


;; Special type for the added modules that are created by plan-building
;; for journals, patches, sysdcl
;;--- Not clear that this should inherit from lisp-module
(define-module-type :plan-overhead
		    :lisp si:*default-binary-file-type*
  lisp-module)

(defmethod (module-special-source-category plan-overhead-module) (pathname)
  (ignore pathname)
  :basic)

(defmethod (module-compilable-p plan-overhead-module) () nil)


;; Lisp modules know how to compile (or recompile) and load
(define-module-type :lisp
		    :lisp si:*default-binary-file-type*
  compilable-module bin-load-module)

;;--- This will produce a duplicate definition warning.  Too bad.
(defmethod (product-file-type-default lisp-module) ()
  (default-binary-file-type (system-environment *system*)))

(defmethod (:compile lisp-module) (system-op &rest keys
				   &key recompile no-compile &allow-other-keys)
  (unless no-compile
    (when (eq system-op :compile)
      ;; Only compile when the system operation is :COMPILE
      (lexpr-funcall #'default-compile
		     self system-op recompile
		     #'(named-lambda lisp-compile-driver
				     (source bin module &rest ignore)
			 (let-if (system-default-package *system*)
				 ;; Bind PACKAGE to the default package in case
				 ;; the override mechanism supplies NIL
				 ((package (pkg-find-package
					     (system-default-package *system*))))
			   (compile-lisp-file 
			     (system-environment *system*)
			     source bin (package-for-module module))))
		     '("Compile" "Compiling" "Compiled")
		     keys))))

;; This is used to side-effect the compile-time environment
(defmethod (:compile-for-effect lisp-module) (system-op &rest keys
					      &key recompile no-compile &allow-other-keys)
  (ignore recompile)
  (unless no-compile
    (when (eq system-op :compile)
      ;; Only compile when the system operation is :COMPILE
      (lexpr-funcall #'default-compile
		     self system-op t		;always recompile!
		     #'(named-lambda lisp-compile-for-effect-driver
				     (source bin module &rest ignore)
			 (let-if (system-default-package *system*)
				 ((package (pkg-find-package
					     (system-default-package *system*))))
			   ;;--- This should just call PHASE-1 and not write a .BIN file
			   (compile-lisp-file
			     (system-environment *system*)
			     source bin (package-for-module module))))
		     '("Compile for effect" "Compiling for effect" "Compiled for effect")
		     keys))))

(defmethod (:read lisp-module) (system-op &rest keys
					  &key reload never-load &allow-other-keys)
  (ignore system-op keys)
  (unless never-load
    (lexpr-funcall #'default-read
		   self system-op reload
		   #'(named-lambda lisp-read-driver
				   (source ignore module &rest ignore)
		       (let ((truename
			       (cl:load source
					:verbose nil
					:default-package (system-default-package *system*)
					:package (package-for-module module))))
			 (and truename
			      (values source truename))))
		   '("Read" "Reading" "Read")
		   keys)))


;; Lisp-read-only modules functionally replace the old DEFSYSTEM's :READFILE
;; transformation for lisp files.  Presumably, this could be done for other languages,
;; if they can interpret code, or if the file is to be compiled by hand only.
(define-module-type :lisp-read-only
		    :lisp nil
  lisp-module)

(defmethod (module-compilable-p lisp-read-only-module) () nil)

(defmethod (distribution-defaults lisp-read-only-module) (system)
  (declare (values distribute-sources distribute-binaries source-category))
  (values (or (system-distribute-sources system) t)	;in case of :ALWAYS
	  nil
	  (system-source-category system)))

(defmethod (:compile lisp-read-only-module) (system-op &rest keys)
  (ignore system-op keys)
  nil)

(defmethod (:load lisp-read-only-module) (system-op &rest keys)
  (lexpr-send self :read system-op keys))


;; Lisp-load-only modules are useful when you want to steal an entire
;; module from another system, e.g., (:module foo ((bar defs)))
(define-module-type :lisp-load-only
		    :lisp si:*default-binary-file-type*
  lisp-module)

;;--- This will produce a duplicate definition warning.  Too bad.
(defmethod (product-file-type-default lisp-load-only-module) ()
  (default-binary-file-type (system-environment *system*)))

(defmethod (module-compilable-p lisp-load-only-module) () nil)

(defmethod (canonicalize-module-pathnames lisp-load-only-module) (system)
  (loop for input in inputs
	as real-input = (merge-pathname-with-defaults
			  (if (listp input) (second input) input)
			  (product-file-type-default self) system
			  :destination-file t)
	;; It only makes sense to keep the destination pathname
	collect `(,real-input ,real-input) into inputs-and-outputs
	finally (setq inputs inputs-and-outputs)))

(defmethod (:compile lisp-load-only-module) (system-op &rest keys)
  (ignore system-op keys)
  nil)


;; Logical pathname translation files -- it works to :READ or :LOAD them
;;--- The source-default should be :TRANSLATIONS, but there is no such canonical type
(define-module-type :logical-translations
		    :lisp nil
  lisp-read-only-module)

(defmethod (:compile logical-translations-module) (system-op &rest keys)
  (ignore system-op keys)
  nil)

(defmethod (canonicalize-module-pathnames logical-translations-module) (system)
  (canonicalize-module-input-pathnames system "TRANSLATIONS"))


;; Text modules know that compiling and loading are no-ops
(define-module-type :text
		    :text nil
  no-load-or-compile-module)

(defmethod (distribution-defaults text-module) (system)
  (declare (values distribute-sources distribute-binaries source-category))
  (values (or (system-distribute-sources system) t)	;in case of :ALWAYS
	  nil
	  '((:basic))))

(defmethod (canonicalize-module-pathnames text-module) (system)
  (canonicalize-module-input-pathnames system (source-file-type-default self)))


;; Lisp example modules are a lot like text modules
(define-module-type :lisp-example
		    :lisp nil
  text-module)


;; Font modules only know about loading
;;--- Fonts just don't seem to know whether they are source files or product files
(define-module-type :font
		    :bfd nil
  binary-module)

(defmethod (version-control-defaults font-module) (system)
  (declare (values (version-controlled branch-mapping)))
  (ignore system)
  (values nil nil))

;; Canonicalize the inputs and outputs, which for a font module means to just
;; pair the input into an input and an output.
(defmethod (canonicalize-module-pathnames font-module) (system)
  (loop for input in inputs
	as font = (if (listp input) (first input) input)
	;; Turn the font name into a real pathname.  Notice that if the font
	;; is a symbol, we look in the SYS:FONT;, but if it is a string, we
	;; look in the system's default directory
	as font-file = (if (stringp font)
			   (merge-pathname-with-defaults
			     font (source-file-type-default self) system)
			 (send (fs:parse-pathname (first fed:*screen-font-bfd-search-paths*))
			       :new-name (string font)))
	collect `(,font-file ,font-file) into inputs-and-outputs
	finally (setq inputs inputs-and-outputs)))

(defmethod (canonicalize-category-pathnames font-module) (system fonts)
  (loop for font in fonts
	;; Turn the font name into a real pathname.  Notice that if the font
	;; is a symbol, we look in the SYS:FONT;, but if it is a string, we
	;; look in the system's default directory
	as font-file = (if (stringp font)
			   (merge-pathname-with-defaults
			     font (source-file-type-default self) system)
			 (send (fs:parse-pathname (first fed:*screen-font-bfd-search-paths*))
			       :new-name (string font)))
	collect (send font-file :generic-pathname)))

(Defmethod (distribution-defaults font-module) (system)
  (declare (values distribute-sources distribute-binaries source-category))
  ;;--- More font schizophrenia.  This really needs to be resolved.
  (values (system-distribute-binaries system)	;these act like binary files
	  (system-distribute-binaries system)
	  '((:basic))))

;; For a font module, the distribution pathname is just the pathname if it was
;; given, otherwise we have to cons up a pathname from the font name and the
;; system's default pathname.
(defmethod (distribution-pathname font-module) (font &rest ignore)
  (if (or (stringp font) (typep font 'fs:pathname))
      font
    (let ((font-pathname (send (fs:merge-pathnames (string font)
						   (system-default-pathname *system*))
				:new-type :bfd)))
      font-pathname)))

(defmethod (:compile font-module) (system-op &rest keys)
  (ignore system-op keys)
  nil)

(defmethod (:load font-module) (system-op &rest keys
				&key reload never-load &allow-other-keys)
  (ignore system-op keys)
  (unless never-load
    (lexpr-funcall #'default-read
		   self system-op reload
		   #'(named-lambda font-load-driver
				   (font ignore ignore &rest ignore)
		       ;; For the time being, we don't bother collecting the
		       ;; version info, since we can get it by other means
		       (fed:read-font-from-bfd-file font)
		       (values font nil))
		   '("Load font" "Loading font" "Loaded font")
		   keys)))


;; Readtables
(define-module-type :readtable
		    :lisp si:*default-binary-file-type*
  bin-load-module)

(defmethod (:compile readtable-module) (system-op &rest keys
					&key recompile no-compile &allow-other-keys)
  (unless no-compile
    (when (eq system-op :compile)
      ;; Only compile when the system operation is :COMPILE
      (lexpr-funcall #'default-compile
		     self system-op recompile
		     #'(named-lambda readtable-compile-driver
				     (source bin ignore &rest ignore)
			 (si:rtc-file source bin))
		     '("Compile readtable" "Compiling readtable" "Compiled readtable")
		     keys))))


;; Type for binary data that is neither compiled nor loaded by SCT.  Since it is in
;; some binary format, it is also neither edited nor hardcopied.  But it is still
;; distributed, copied, reap-protected, et al.  We need to go out to the filesystem
;; to get the journalling information.
(define-module-type :binary-data
		    nil si:*default-binary-file-type*
  no-load-or-compile-module binary-module)

(defmethod (version-control-defaults binary-data-module) (system)
  (declare (values (version-controlled branch-mapping)))
  (ignore system)
  (values nil nil))

(defmethod (distribution-defaults binary-data-module) (system)
  (declare (values distribute-sources distribute-binaries source-category))
  ;; These act like "source" files, and are defaultly distributed
  (values (or (system-distribute-sources system) t)	;in case of :ALWAYS
	  nil
	  '((:basic))))

;; The :LOAD method is used to make distribution work.
(defmethod (:load binary-data-module) (system-op &key never-load &allow-other-keys)
  (ignore system-op)
  (unless never-load
    (multiple-value-bind (primary-input-files backup-input-files)
	;; No need to handle :VC-BRANCH for binary data
	(collect-module-inputs-and-outputs self t)
      (let ((input-files
	      ;; :BINARY-DATA modules are a bit funny, because the input file
	      ;; specified in the defsystem form is really a destination file!
	      ;; This is not a problem if the file type is :BIN (the default),
	      ;; but if it's something else, we need to merge in the file type.
	      ;; (This hackery makes Distribution work correctly.)
	      (loop for primary in primary-input-files
		    for backup in (or backup-input-files primary-input-files)
		    collect (if (null (send primary :type))
				(send primary :new-type (send backup :type))
			      primary))))
	(make-plan self *system*
		   :inputs input-files
		   :default-input-type (product-file-type-default self)
		   :driving-function nil
		   :documentation nil)))))

(defmethod (canonicalize-module-pathnames binary-data-module) (system)
  (canonicalize-module-input-pathnames system (product-file-type-default self)))


;; Type for text data that is neither compiled nor loaded by SCT.
(define-module-type :text-data
		    :text nil
  text-module)


;; A different, but obsolete name, for :BINARY-DATA
(define-module-type :data-no-load
		    nil si:*default-binary-file-type*
  binary-data-module)

(defmethod (distribution-defaults data-no-load-module) (system)
  (declare (values distribute-sources distribute-binaries source-category))
  ;; These act like "source" files, and are defaultly distributed
  (values (or (system-distribute-sources system) t)	;in case of :ALWAYS
	  nil
	  '((:basic))))


;; Hardcopy's LGP2 metrics file
(define-module-type :lgp2-metrics
		    :lisp :lgp2-metrics
  compilable-module bin-load-module)

(defmethod (:compile lgp2-metrics-module) (system-op &rest keys
					   &key no-compile recompile &allow-other-keys)
  (ignore keys)
  (unless no-compile
    (when (eq system-op :compile)
      (lexpr-funcall #'default-compile
		     self system-op recompile
		     #'(named-lambda lgp2-metrics-compile-driver
				     (source bin module &rest ignore)
			 (let ((package (package-for-module module *system* t)))
			   (lgp:compile-lgp2-metrics-file source bin)))
		     '("Compile" "Compiling" "Compiled")
		     keys))))

;; :NEVER-LOAD T means "no matter what anyone else says, don't ever :LOAD anything"
(defmethod (:load lgp2-metrics-module) (system-op &rest keys
						  &key never-load reload &allow-other-keys)
  (unless never-load
    (lexpr-funcall #'default-load
		   self system-op reload
		   #'(named-lambda lgp2-metrics-load-driver
				   (metrics ignore ignore &rest ignore)
		       (lgp:load-lgp2-metrics-file metrics))
		   '("Load LGP2 metrics in"
		     "Loading LGP2 metrics in"
		     "Loaded LGP2 metrics in")
		   keys)))

;;; Module types for embedded systems

(define-module-type :macintosh-fonts :macintosh-resource nil
  binary-module)

(defmethod (:compile macintosh-fonts-module) (system-op &rest keys)
  (ignore system-op keys)
  nil)

(defmethod (:load macintosh-fonts-module) (system-op &rest keys
						     &key reload never-load &allow-other-keys)
  (ignore system-op keys)
  (unless never-load
    (cl:apply #'default-read
	      self system-op reload
	      #'(sys:named-lambda macintosh-fonts-load-driver
				  (file ignore ignore &rest ignore)
		  (macintosh-internals:load-more-fonts file)
		  (values file nil))
	      '("Load Macintosh fonts" "Loading Macintosh fonts" "Loaded Macintosh fonts")
	      keys)))


(define-module-type :toolkit-program
		    :lisp si:*default-binary-file-type*
  lisp-module)


(define-module-type :mac-c-include
		    nil si:*default-binary-file-type*
  bin-load-module)

(defmethod (:compile mac-c-include-module)
	   (system-op &rest keys
		      &key recompile no-compile &allow-other-keys)
  (unless no-compile
    (when (eq system-op :compile)
      ;; Only compile when the system operation is :COMPILE
      (cl:apply #'default-compile
		self system-op recompile
		#'(sys:named-lambda lisp-compile-driver (source bin module &rest ignore)
		    (let-if (system-default-package *system*)
			    ;; Bind PACKAGE to the default package in case
			    ;; the override mechanism supplies NIL
			    ((cl:*package* (pkg-find-package
					     (system-default-package *system*))))
		      (ignore module)
		      (macintosh-internals::compile-c-include-file source bin)))
		'("Compile" "Compiling" "Compiled")
		keys))))


(define-module-type :sage
		    :sage-binary nil)

(defconst *document-examiner* "NSage")
(defmethod (:init sage-module :after) (&rest ignore)
  (send self :putprop (list *document-examiner*) :required-systems))

(defmethod (distribution-defaults sage-module) (system)
  (declare (values distribute-sources distribute-binaries source-category))
  (values (system-distribute-sources system)
	  nil
	  (system-source-category system)))

(defmethod (distribution-pathname sage-module) (pathname &key compress &allow-other-keys)
  (if compress
      (sage::compressed-database-file
	pathname :system-name (system-name *system*) :major-version *version*)
    pathname))

(defmethod (:compile sage-module) (system-op &rest keys
				   &key recompile no-compile &allow-other-keys)
  (unless no-compile
    (when (eq system-op :compile)
      ;; Only compile when the system operation is :COMPILE
      (lexpr-funcall #'default-read		;NSage doesn't compile anything anymore
		     self system-op recompile
		     #'(named-lambda sage-compile-driver
				     (sab ignore ignore &rest ignore)
			 ;; All we need to do here is get the proper version number
			 (with-open-file (stream sab :direction :probe
						     :if-does-not-exist :error)
			   (values (send stream :pathname)
				   (send stream :truename))))
		     '("/"Compile/" documentation in"
		       "/"Compiling/" documentation in"
		       "/"Compiled/" documentation in")
		     keys))))

(defmethod (:load sage-module) (system-op &rest keys
				&key compress reload never-load &allow-other-keys)
  (unless (or never-load (and compress (neq system-op :compile)))
    (lexpr-funcall #'default-read
		   self system-op reload
		   #'(named-lambda sage-load-driver
				   (sab ignore ignore &rest ignore)
		       (sage:load-index-info sab))
		   '("Load documentation in"
		     "Loading documentation in"
		     "Loaded documentation in")
		   keys)))

;; Hardcopying .SAB files is ridiculous...
(defmethod (:hardcopy sage-module) (system-op &rest keys)
  (ignore system-op keys)
  nil)


;; This is a lot like the :SAGE module-type, except that it is really for
;; end-user documentation
(define-module-type :documentation
		    :sage-binary nil
  sage-module)

(defmethod (:edit documentation-module) (system-op &rest keys)
  (ignore system-op keys)
  nil)


;;; Define the module types for the layered (foreign) languages.
;;; The actual methods are defined in each of the language products.

(define-module-type :fortran
		    :fortran si:*default-binary-file-type*
  compilable-module bin-load-module)

(define-module-type :pascal
		    :pascal si:*default-binary-file-type*
  compilable-module bin-load-module)

(define-module-type :c
		    :c si:*default-binary-file-type*
  compilable-module bin-load-module)

(define-module-type :c-include
		    :c nil
  no-load-or-compile-module)
