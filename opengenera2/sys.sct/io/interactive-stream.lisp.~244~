;;; -*- Syntax: Zetalisp; Mode: Lisp; Package: System-internals; Base: 8 -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

(DEFVAR-RESETTABLE *INPUT-EDITOR-PACKAGE* NIL)

(DEFVAR *INPUT-EDITOR-HISTORIES* NIL)

;; Various input editor and window state macros.  Some are used in this file, which is why
;; they appear at the beginning of it.  These macros are very repetitive; there should be some
;; meta-macrology for defining them.

;; Macros for input editor commands which typeout or accept typein.

(DEFUN WITH-IE-TYPEOUT-INTERNAL (STREAM TYPE START-SPACING FINISH-SPACING CONTINUATION)
  (DECLARE (DOWNWARD-FUNARG CONTINUATION))
  (SEND STREAM :START-TYPEOUT TYPE START-SPACING)
  (MULTIPLE-VALUE-PROG1
    (FUNCALL CONTINUATION)
    (SEND STREAM :FINISH-TYPEOUT FINISH-SPACING)))

(DEFMACRO WITH-IE-TYPEOUT ((STREAM TYPE &OPTIONAL START-SPACING FINISH-SPACING) &BODY BODY)
  `(WITH-IE-TYPEOUT-INTERNAL ,STREAM ,TYPE ,START-SPACING ,FINISH-SPACING
			     (LAMBDA () . ,BODY)))

(DEFMACRO WITH-IE-TYPEIN ((STREAM &OPTIONAL TYPE &REST OPTIONS) &BODY BODY)
  (DECLARE (ARGLIST (STREAM &OPTIONAL TYPE &KEY (REFRESH T) (ERASE NIL)) &BODY BODY))
  `(WITH-IE-TYPEIN-INTERNAL ,STREAM ,TYPE (LAMBDA () . ,BODY) . ,OPTIONS))

(DEFUN WITH-IE-TYPEIN-INTERNAL (STREAM TYPE CONTINUATION &KEY (REFRESH T) (ERASE NIL))
  (DECLARE (DOWNWARD-FUNARG CONTINUATION))
  (LET (SAVED-BUFFER)
    (UNWIND-PROTECT
	(LET ((START-X (SEND STREAM :BUFFER-X))
	      (START-Y (SEND STREAM :BUFFER-Y)))
	  (SETQ SAVED-BUFFER (SEND STREAM :SAVE-INPUT-BUFFER TYPE))
	  (LET ((RUBOUT-HANDLER NIL)
		(*INPUT-EDITOR-STREAM* NIL)
		(*INPUT-EDITOR-TYPEIN* T)
		(*INPUT-EDITOR-OPTIONS* NIL))
	    (MULTIPLE-VALUE-PROG1 (FUNCALL CONTINUATION)
	      (WHEN ERASE
		(MULTIPLE-VALUE-BIND (X Y)
		    (SEND STREAM :READ-CURSORPOS)
		  (SEND STREAM :CLEAR-BETWEEN-CURSORPOSES START-X START-Y X Y))
		(SEND STREAM :SET-CURSORPOS START-X START-Y)
		(WHEN (EQ REFRESH T) (SETQ REFRESH :NO-NEWLINE))))))
      (SEND STREAM :RESTORE-INPUT-BUFFER SAVED-BUFFER REFRESH))))

(DEFMACRO WITH-IE-TYPEOUT-IF-APPROPRIATE ((&OPTIONAL (STREAM 'STANDARD-OUTPUT)
						     &REST ARGS)
					  &BODY BODY)
  (DECLARE (ARGLIST (&OPTIONAL (STREAM 'STANDARD-OUTPUT)
			       (TYPE :INSERT)
			       (START-SPACING NIL) (FINISH-SPACING :BLANK-LINE))
		    &BODY BODY))
  `(WITH-IE-TYPEOUT-INTERNAL-IF-APPROPRIATE ,STREAM (LAMBDA (,STREAM) . ,BODY) . ,ARGS))

(DEFUN WITH-IE-TYPEOUT-INTERNAL-IF-APPROPRIATE (STREAM CONTINUATION
						&OPTIONAL (TYPE :INSERT)
							  (START-SPACING NIL)
							  (FINISH-SPACING :BLANK-LINE))
  (DECLARE (DOWNWARD-FUNARG CONTINUATION))
  ;; It's not appropriate to hack IE typeout on non-interactive streams
  (IF (NOT (SEND-IF-HANDLES STREAM :IE-TYPEOUT-IS-APPROPRIATE))
      (FUNCALL CONTINUATION STREAM)
      (LET ((SPECIAL-STREAM (INPUT-EDITOR-FLAG :HELP-STREAM)))
	(IF (OR (NULL SPECIAL-STREAM)
		(EQ (FOLLOW-SYN-STREAM SPECIAL-STREAM) STREAM))
	    (WITH-IE-TYPEOUT (STREAM TYPE START-SPACING FINISH-SPACING)
	      (FUNCALL CONTINUATION STREAM))
	    (FUNCALL CONTINUATION SPECIAL-STREAM)))))

;; Macro for command loops which accept preemptable input.

(DEFUN WITH-PREEMPTABLE-INPUT-INTERNAL (STREAM CONTINUATION)
  (DECLARE (DOWNWARD-FUNARG CONTINUATION)) 
  (LET (SAVED-BUFFER)
    (UNWIND-PROTECT
	(PROGN
	  (SETQ SAVED-BUFFER (SEND STREAM :SAVE-INPUT-BUFFER))
	  (FUNCALL CONTINUATION))
      (SEND STREAM :RESTORE-INPUT-BUFFER SAVED-BUFFER))))

(DEFMACRO WITH-PREEMPTABLE-INPUT ((STREAM) &BODY BODY)
  `(WITH-PREEMPTABLE-INPUT-INTERNAL ,STREAM (LAMBDA () . ,BODY)))

;; Macro for temporarily changing the cursor visibility

(DEFUN WITH-CURSOR-VISIBILITY-INTERNAL (NEW-VISIBILITY STREAM CONTINUATION)
  (DECLARE (DOWNWARD-FUNARG CONTINUATION))
  (UNLESS STREAM (SETQ STREAM STANDARD-OUTPUT))
  (LET ((VISIBILITY (SEND-IF-HANDLES STREAM :CURSOR-VISIBILITY)))
    (UNWIND-PROTECT
	(PROGN
	  (SEND-IF-HANDLES STREAM :SET-CURSOR-VISIBILITY NEW-VISIBILITY)
	  (FUNCALL CONTINUATION))
      (SEND-IF-HANDLES STREAM :SET-CURSOR-VISIBILITY VISIBILITY))))

(DEFMACRO WITH-CURSOR-VISIBILITY ((NEW-VISIBILITY &OPTIONAL STREAM) &BODY BODY)
  `(WITH-CURSOR-VISIBILITY-INTERNAL ,NEW-VISIBILITY ,STREAM (LAMBDA () . ,BODY)))

;; Macro for temporarily changing the label

(DEFUN WITH-LABEL-INTERNAL (NEW-LABEL STREAM CONTINUATION)
  (DECLARE (DOWNWARD-FUNARG CONTINUATION))
  (UNLESS STREAM (SETQ STREAM STANDARD-OUTPUT))
  (LET ((LABEL (SEND-IF-HANDLES STREAM :LABEL)))
    (UNWIND-PROTECT
	(PROGN
	  (SEND-IF-HANDLES STREAM :SET-LABEL NEW-LABEL)
	  (FUNCALL CONTINUATION))
      (SEND-IF-HANDLES STREAM :SET-LABEL LABEL)))) 

(DEFMACRO WITH-LABEL ((NEW-LABEL &OPTIONAL STREAM) &BODY BODY)
  `(WITH-LABEL-INTERNAL ,NEW-LABEL ,STREAM (LAMBDA () . ,BODY)))

;; Macro for temporarily changing the line truncation flag

(DEFUN WITH-LINE-TRUNCATION-INTERNAL (NEW-TRUNCATION-MODE STREAM CONTINUATION)
  (DECLARE (DOWNWARD-FUNARG CONTINUATION))
  (UNLESS STREAM (SETQ STREAM STANDARD-OUTPUT))
  (LET ((TRUNCATION-MODE (SEND-IF-HANDLES STREAM :TRUNCATE-LINE-OUT)))
    (UNWIND-PROTECT
	(PROGN
	  (SEND-IF-HANDLES STREAM :SET-TRUNCATE-LINE-OUT NEW-TRUNCATION-MODE)
	  (FUNCALL CONTINUATION))
      (SEND-IF-HANDLES STREAM :SET-TRUNCATE-LINE-OUT TRUNCATION-MODE)))) 

(DEFMACRO WITH-LINE-TRUNCATION ((NEW-TRUNCATION-MODE &OPTIONAL STREAM) &BODY BODY)
  `(WITH-LINE-TRUNCATION-INTERNAL ,NEW-TRUNCATION-MODE ,STREAM (LAMBDA () . ,BODY)))

;; Macro for temporarily changing the reverse video mode

(DEFUN WITH-REVERSE-VIDEO-INTERNAL (NEW-REVERSE-VIDEO-MODE STREAM CONTINUATION)
  (DECLARE (DOWNWARD-FUNARG CONTINUATION))
  (UNLESS STREAM (SETQ STREAM STANDARD-OUTPUT))
  (LET ((REVERSE-VIDEO-MODE (SEND-IF-HANDLES STREAM :REVERSE-VIDEO-P)))
    (UNWIND-PROTECT
	(PROGN
	  (SEND STREAM :SET-REVERSE-VIDEO-P NEW-REVERSE-VIDEO-MODE)
	  (FUNCALL CONTINUATION))
      (SEND-IF-HANDLES STREAM :SET-REVERSE-VIDEO-P REVERSE-VIDEO-MODE))))

(DEFMACRO WITH-REVERSE-VIDEO ((NEW-REVERSE-VIDEO-MODE &OPTIONAL STREAM) &BODY BODY)
  `(WITH-REVERSE-VIDEO-INTERNAL ,NEW-REVERSE-VIDEO-MODE ,STREAM (LAMBDA () . ,BODY)))

;; LAST-INPUT is used by (SI:OUTPUT-RECORDING-STREAM :INPUT-EDITOR).  The input history
;;   can't be used for this purpose since not all input is saved on the input history.

(DEFFLAVOR INTERACTIVE-STREAM
	(ASYNCHRONOUS-CHARACTERS
	 INPUT-EDITOR-BUFFER
	 (INPUT-HISTORY NIL)
	 (LAST-INPUT NIL)
	 (YANK-HISTORY NIL)
	 (MARK NIL)
	 (ACTIVATOR NIL)
	 (RESCAN-CHARACTER NIL)
	 (RESCAN-POINTER NIL)
	 (ECHO-STYLE TV:*DEFAULT-ECHO-STYLE*)
	 (TYPEOUT-TYPE NIL)
	 (TYPEOUT-OVERWRITABLE NIL)
	 (BUFFER-X) (BUFFER-Y)
	 (PROMPT-X) (PROMPT-Y)
	 (TYPEOUT-X NIL) (TYPEOUT-Y NIL)
	 (NOTIFICATION NIL)
	 (NOTIFICATION-MODE :POP-UP)
	 (TYPEIN-STYLE (SI:STYLE-INDEX TV:*DEFAULT-TYPEIN-STYLE*))
						; an index for efficiency
	 (SPARE-SLOT-1 NIL) (SPARE-SLOT-2 NIL)
	 (SPARE-SLOT-3 NIL) (SPARE-SLOT-4 NIL))
	(LINE-OUTPUT-STREAM-MIXIN CHARACTER-STREAM BIDIRECTIONAL-STREAM)
  :ABSTRACT-FLAVOR
  (:REQUIRED-METHODS :INPUT-WAIT :ANY-TYI :ANY-TYI-NO-HANG
		     INPUT-EDITOR-TYI INPUT-EDITOR-REPLACE-INPUT INPUT-EDITOR-CURSOR-MOTION
		     INPUT-EDITOR-REFRESH INPUT-EDITOR-DISPLAY-HELP)
  (:METHOD-ORDER
   :TYO :STRING-OUT :LINE-OUT
   :LISTEN :TYI :TYI-NO-HANG :ANY-TYI :ANY-TYI-NO-HANG)
  ;; Forward references to local functions of flavor defined in input-editor file
  (:FUNCTIONS IE-INSERT-BLIP INPUT-EDITOR-RETURN-CHAR INPUT-EDITOR-UNRETURN-CHAR
	      IE-SET-POSITION IE-INSERT-CHAR IE-SEARCH-BACKWARD-WORD IE-INSERT-FROM-HISTORY
	      IE-FIXUP-WHITESPACE IE-SEARCH-BACKWARD-PARENS IE-SEARCH-FORWARD-PARENS
	      IE-YANK-COMMAND)
  (:GETTABLE-INSTANCE-VARIABLES BUFFER-X BUFFER-Y INPUT-HISTORY LAST-INPUT)
  (:SETTABLE-INSTANCE-VARIABLES ASYNCHRONOUS-CHARACTERS NOTIFICATION-MODE ACTIVATOR)
  (:DEFAULT-INIT-PLIST
   :ASYNCHRONOUS-CHARACTERS '((#\c-ABORT TV:KBD-ASYNCHRONOUS-INTERCEPT-CHARACTER)
			      (#\c-m-ABORT TV:KBD-ASYNCHRONOUS-INTERCEPT-CHARACTER)
			      (#\c-SUSPEND TV:KBD-ASYNCHRONOUS-INTERCEPT-CHARACTER)
			      (#\c-m-SUSPEND TV:KBD-ASYNCHRONOUS-INTERCEPT-CHARACTER)))
  (:DOCUMENTATION :COMBINATION
   "This is the flavor of stream which is designed for interacting with a human user.
It extends the protocol for bidirectional streams by adding messages which support
input editing.  Any stream to which TERMINAL-IO may be bound should be built on
this flavor."))

(DEFFLAVOR DISPLAY-INPUT-EDITOR () (INTERACTIVE-STREAM)
  (:DOCUMENTATION :COMBINATION
   "The version of the input editor that works on streams that support display protocol."))

;; The only pieces of input editor state which are stored in the buffer are those which
;; must be saved by :SAVE/RESTORE-RUBOUT-HANDLER-BUFFER.  All others are stored in
;; the stream itself.

(DEFSTRUCT (INPUT-EDITOR-BUFFER (:TYPE :NAMED-ARRAY-LEADER)
				(:MAKE-ARRAY (:LENGTH 512. :TYPE ART-FAT-STRING))
				(:DEFAULT-POINTER INPUT-EDITOR-BUFFER)
				(:CONC-NAME IEB-))
  (FILL-POINTER 0)
  (SCAN-POINTER 0)
  (TYPEIN-POINTER 0)
  (NOISE-STRINGS NIL)
  (BUFFER-BLIPS NIL))

(DEFSELECT ((:PROPERTY INPUT-EDITOR-BUFFER NAMED-STRUCTURE-INVOKE))
  (:PRINT-SELF (INPUT-EDITOR-BUFFER STREAM IGNORE SLASHIFY-P)
    (IF SLASHIFY-P
	(PRIN1 (SUBSTRING INPUT-EDITOR-BUFFER 0) STREAM)
	(MAP-OVER-INPUT-EDITOR-BUFFER INPUT-EDITOR-BUFFER 0 NIL
				      #'(LAMBDA (STRING &REST REST)
					  (LEXPR-SEND STREAM :STRING-OUT STRING REST))
				      #'(LAMBDA (NOISE)
					  (PRESENT NOISE (CL:TYPE-OF NOISE) :STREAM STREAM))
				      #'(LAMBDA (BLIP IGNORE)
					  (PRESENT (DW:PRESENTATION-BLIP-OBJECT BLIP)
						   (DW:PRESENTATION-BLIP-PRESENTATION-TYPE BLIP)
						   :STREAM STREAM))
				      T))))

(DEFSUBST INPUT-EDITOR-BUFFER-P (IEB)
  (TYPEP IEB 'INPUT-EDITOR-BUFFER))

(DEFRESOURCE INPUT-EDITOR-BUFFER ()
  :CONSTRUCTOR (MAKE-INPUT-EDITOR-BUFFER)
  :INITIAL-COPIES 5)

(DEFUN COPY-INPUT-EDITOR-BUFFER (INPUT-EDITOR-BUFFER &OPTIONAL (START 0) END)
  (UNLESS END (SETQ END (IEB-FILL-POINTER)))
  (LET* ((LENGTH (- END START))
	 (COPY (MAKE-INPUT-EDITOR-BUFFER :MAKE-ARRAY (:LENGTH LENGTH))))
    (COPY-ARRAY-PORTION INPUT-EDITOR-BUFFER START END COPY 0 LENGTH)
    (SETF (IEB-FILL-POINTER COPY) LENGTH)
    (SETF (IEB-NOISE-STRINGS COPY)
	  (LOOP FOR (INDEX . STRING) IN (IEB-NOISE-STRINGS)
		WHEN (< START INDEX END)
		COLLECT `(,(- INDEX START) . ,STRING)))
    (SETF (IEB-BUFFER-BLIPS COPY)
	  (IEB-BUFFER-BLIPS INPUT-EDITOR-BUFFER))
    COPY))

;;; Blips are encoded in the input buffer by using placeholder characters
;;; from a special character set.  The char-code of the character is an
;;; index into the BUFFER-BLIPS list.  Using actual characters as blip
;;; placeholders means that all things in the input buffer are CHARACTERP
;;; and fewer special cases are necessary when scanning the buffer.
;;;
;;; Perhaps this whole scheme should be replaced by one similar to noise
;;; strings, where the blips list includes the blip's index into the buffer
;;; and the index is fixed up as characters are added or deleted...

;;; This character set defines the minimum possible set of attributes,
;;; since it will just be used to mark special characters in a string.
(DEFFLAVOR BLIP-CHARACTER-SET
	()
	(CHARACTER-SET-NO-CASE-MIXIN BASIC-CHARACTER-SET)
  (:DEFAULT-INIT-PLIST
   :NAME "BLIPS"
   :N-CHARACTERS #O177
   :CHARACTERS '#O((0 "a blip"))))

(DEFMETHOD (:GRAPHIC-CHAR-P BLIP-CHARACTER-SET) (IGNORE) NIL)

(COMPILE-FLAVOR-METHODS BLIP-CHARACTER-SET)

(DEFCONST *BUFFER-BLIPS-CHARSET* (MAKE-INSTANCE 'BLIP-CHARACTER-SET))

(DEFMETHOD (:INTERACTIVE INTERACTIVE-STREAM) () T)

(DEFGENERIC SYS:REMOTE-TERMINAL-P (&OPTIONAL (STREAM TERMINAL-IO))
  (:FUNCTION
    (OR (NOT (VARIABLE-BOUNDP TV:MAIN-SCREEN))
	(NULL TV:MAIN-SCREEN)
	(LET ((STREAM (SI:FOLLOW-SYN-STREAM STREAM)))
	  (AND (TYPEP STREAM 'INTERACTIVE-STREAM)
	       (FUNCALL (FLAVOR:GENERIC SYS:REMOTE-TERMINAL-P) STREAM))))))

(DEFMETHOD (SYS:REMOTE-TERMINAL-P INTERACTIVE-STREAM :DEFAULT) () NIL)

;; Asynchronous characters.

(DEFMETHOD (:ASYNCHRONOUS-CHARACTER-P INTERACTIVE-STREAM) (CHARACTER)
  (CL:ASSOC CHARACTER ASYNCHRONOUS-CHARACTERS))

(DEFMETHOD (:HANDLE-ASYNCHRONOUS-CHARACTER INTERACTIVE-STREAM) (CHARACTER)
  (LET ((ENTRY (CL:ASSOC CHARACTER ASYNCHRONOUS-CHARACTERS)))
    (FUNCALL (CADR ENTRY) CHARACTER SELF)))

(DEFMETHOD (:ADD-ASYNCHRONOUS-CHARACTER INTERACTIVE-STREAM) (CHARACTER HANDLER)
  (CHECK-ARG-TYPE CHARACTER :CHARACTER)
  (CHECK-ARG HANDLER #'FUNCTIONP "A function or function name.")
  (SEND SELF :REMOVE-ASYNCHRONOUS-CHARACTER CHARACTER)
  (PUSH `(,CHARACTER ,HANDLER) ASYNCHRONOUS-CHARACTERS))

(DEFMETHOD (:REMOVE-ASYNCHRONOUS-CHARACTER INTERACTIVE-STREAM) (CHARACTER)
  (SETQ ASYNCHRONOUS-CHARACTERS
	(CL:DELETE CHARACTER ASYNCHRONOUS-CHARACTERS :KEY #'CAR)))

;;; Inside the input editor, using this stream, and not in a nested WITH-IE-TYPEOUT.
(DEFMETHOD (:IE-TYPEOUT-IS-APPROPRIATE INTERACTIVE-STREAM) ()
  (AND RUBOUT-HANDLER
       (EQ (FOLLOW-SYN-STREAM *INPUT-EDITOR-STREAM*) (FOLLOW-SYN-STREAM SELF))
       (NOT TYPEOUT-TYPE)))

;; Input editor

;; RUBOUT-HANDLER, *INPUT-EDITOR-TYPEIN*, and *INPUT-EDITOR-OPTIONS* keep track of the state
;; of the input editor.  RUBOUT-HANDLER can have one of the following settings:

;;    NIL	Outside the input editor
;;    :READ	Inside the :INPUT-EDITOR method but not inside :TYI
;;    :TYI	Inside the :TYI method

;; RUBOUT-HANDLER, *INPUT-EDITOR-TYPEIN*, and *INPUT-EDITOR-OPTIONS* are bound back to NIL
;; whenever entering a new listener loop which establishes its own editing context, and are
;; known about by LISP-REINITIALIZE, BREAK, and DBG:DEBUGGER-TOP-LEVEL.  *INPUT-EDITOR-TYPEIN*
;; is bound to T whenever we are inside the input editor "minibuffer".  These specials should
;; be merged at some point, so that it isn't necessary to constantly modify LISP-REINITIALIZE,
;; etc. whenever a new one is created.

;; These generic functions are the entry points to the input editor, called
;; by methods of INTERACTIVE-STREAM.  There can be multiple input editor
;; implementations, e.g. for different terminal capabilities.
;; Ascii and remote terminals used to work by binding *INPUT-EDITOR-INVOKE*, but that
;; involved abusing defun-methods, so now they work by providing a suitable flavor of stream.
;; Other functions whose names begin with INPUT-EDITOR- exist but are currently not generic
;; because every input editor implementation uses the same definition.

(DEFGENERIC INPUT-EDITOR-TYI (INTERACTIVE-STREAM *RESCAN-STATE*))

(DEFGENERIC INPUT-EDITOR-REPLACE-INPUT (INTERACTIVE-STREAM N-CHARS STRING BEGIN END))

(DEFGENERIC INPUT-EDITOR-CURSOR-MOTION (INTERACTIVE-STREAM POINTER)
  (:METHOD (INTERACTIVE-STREAM :DEFAULT) (IGNORE)	;If terminal can't move cursor
    (IGNORE POINTER)
    NIL))

(DEFGENERIC INPUT-EDITOR-REFRESH (INTERACTIVE-STREAM)
  (:METHOD (INTERACTIVE-STREAM :DEFAULT) () NIL))	;If terminal can't erase & refresh

(DEFGENERIC INPUT-EDITOR-DISPLAY-HELP (INTERACTIVE-STREAM NUMERIC-ARG))

(DEFVAR *NOISE-STRING-CHARACTER-STYLE* NIL)
(DEFVAR *DISABLE-NOISE-STRINGS* NIL)

;; Perform some operation over the strings that make up the input editor buffer:
;; the text itself, noise strings, and echoed read objects.
;; START and END delimit the range of the input buffer to use.
;; Takes three continuations for the three cases.  Each one is called with normal
;; :STRING-OUT arguments unless BLIP-P, in which case READ-STRINGS is called with the
;; actual blip and the string.
(DEFUN MAP-OVER-INPUT-EDITOR-BUFFER (INPUT-EDITOR-BUFFER START END
				     REGULAR-STRINGS NOISE-STRINGS READ-STRINGS
				     &OPTIONAL (BLIP-P NIL))
  (DECLARE (SYS:DOWNWARD-FUNARG REGULAR-STRINGS NOISE-STRINGS READ-STRINGS))
  (WHEN (NULL END)
    (SETQ END (IEB-FILL-POINTER)))
  (LET ((NOISE (IEB-NOISE-STRINGS))
	(READ (IEB-BUFFER-BLIPS INPUT-EDITOR-BUFFER)))
    (FLET ((PRINT-IEB-PORTION-THAT-MAY-CONTAIN-BLIPS (IEB START END)
	     (IF (NULL READ)
		 (FUNCALL REGULAR-STRINGS IEB START END)
		 (LOOP FOR INDEX FROM START BELOW END
		       AS CHAR = (AREF IEB INDEX)
		       WHEN (EQ (CHAR-CHAR-SET-AND-INDEX CHAR) *BUFFER-BLIPS-CHARSET*)
			 DO
			   (FUNCALL REGULAR-STRINGS IEB START INDEX)
			   (DESTRUCTURING-BIND (BLIP STRING) (NTH (CHAR-SUBINDEX CHAR) READ)
			     (IF BLIP-P
				 (FUNCALL READ-STRINGS BLIP STRING)
				 (FUNCALL READ-STRINGS STRING)))
			   (SETQ START (1+ INDEX))
		       FINALLY
			 (FUNCALL REGULAR-STRINGS IEB START END)))))
      (LET ((INSIDE-P NIL))
	;; Break input editor buffer between noise string chunks and print those
	;; using FLETted function above that handles blips properly.
	(LOOP FOR (INDEX . STRING) IN NOISE
	      UNTIL (> INDEX END)
	      DO
	  (WHEN (AND (NOT INSIDE-P) (> INDEX START))
	    (SETQ INSIDE-P T))
	  (WHEN INSIDE-P
	    (PRINT-IEB-PORTION-THAT-MAY-CONTAIN-BLIPS INPUT-EDITOR-BUFFER START INDEX)
	    (UNLESS *DISABLE-NOISE-STRINGS*
	      (SCL:WITH-CHARACTER-STYLE (*NOISE-STRING-CHARACTER-STYLE*)
		(FUNCALL NOISE-STRINGS STRING)))
	    (SETQ START INDEX)))
	(PRINT-IEB-PORTION-THAT-MAY-CONTAIN-BLIPS INPUT-EDITOR-BUFFER START END)))))

;; Display some portion of the input editor buffer, with noise strings interspersed.  There's
;; a subtle bug which occurs in this code.  If the printing wraps around the bottom of the
;; screen during normal typein, everything works fine.  But if the printing wraps because the
;; typein is being redisplayed by INPUT-EDITOR-STRING-OUT, there will be a more break at the
;; bottom of the screen, and the bottom line of the window won't be used to display typein, so
;; everything is off by one.  This is really a bug in the window system, in that (TV:SHEET
;; :COMPUTE-MOTION) can't tell when a more break will occur.

(DEFUN-IN-FLAVOR (INPUT-EDITOR-STRING-OUT INTERACTIVE-STREAM) (&OPTIONAL (START 0) END)
  (LET ((TV:MORE-PROCESSING-GLOBAL-ENABLE NIL))
    (FLET ((STRING-OUT (STRING &REST REST)
	     (LEXPR-SEND SELF :STRING-OUT STRING REST))
	   (STRING-OUT-IN-ECHO-STYLE (STRING &REST REST)
	     (SCL:WITH-CHARACTER-STYLE (ECHO-STYLE SELF)
	       (LEXPR-SEND SELF :STRING-OUT STRING REST))))
      (MAP-OVER-INPUT-EDITOR-BUFFER INPUT-EDITOR-BUFFER START END
				    #'STRING-OUT-IN-ECHO-STYLE
				    #'STRING-OUT
				    #'STRING-OUT))))

(DEFUN-IN-FLAVOR (INPUT-EDITOR-DELETE-STRING INTERACTIVE-STREAM) (START END)
  (FLET ((DELETE-STRING (STRING &REST REST)
	   (LEXPR-SEND SELF :DELETE-STRING STRING REST))
	 (DELETE-STRING-IN-ECHO-STYLE (STRING &REST REST)
	   (SCL:WITH-CHARACTER-STYLE (ECHO-STYLE SELF)
	     (LEXPR-SEND SELF :DELETE-STRING STRING REST))))
    (MAP-OVER-INPUT-EDITOR-BUFFER INPUT-EDITOR-BUFFER START END
				  #'DELETE-STRING-IN-ECHO-STYLE
				  #'DELETE-STRING
				  #'DELETE-STRING)))

(DEFUN-IN-FLAVOR (INPUT-EDITOR-INSERT-STRING INTERACTIVE-STREAM) (START END)
  (FLET ((INSERT-STRING (STRING &REST REST)
	   (LEXPR-SEND SELF :INSERT-STRING STRING REST))
	 (INSERT-STRING-IN-ECHO-STYLE (STRING &REST REST)
	   (SCL:WITH-CHARACTER-STYLE (ECHO-STYLE SELF)
	     (LEXPR-SEND SELF :INSERT-STRING STRING REST))))
    (MAP-OVER-INPUT-EDITOR-BUFFER INPUT-EDITOR-BUFFER START END
				  #'INSERT-STRING-IN-ECHO-STYLE
				  #'INSERT-STRING
				  #'INSERT-STRING)))

;; Determine cursor positions within the input editor buffer.  We don't have to worry
;; about :PIXEL or :CHARACTER since the stream will work in whatever units are the most
;; convenient for it.

(DEFSUBST-IN-FLAVOR (INPUT-EDITOR-COMPUTE-MOTION INTERACTIVE-STREAM)
		    (&OPTIONAL (START 0) END X Y)
  (INPUT-EDITOR-BUFFER-COMPUTE-MOTION SELF INPUT-EDITOR-BUFFER START END X Y))

(DEFUN INPUT-EDITOR-BUFFER-COMPUTE-MOTION (STREAM INPUT-EDITOR-BUFFER
					   &OPTIONAL (START 0) END X Y)
  (LABELS ((COMPUTE-ADDITIONAL-MOTION (STRING &OPTIONAL (START 0) END)
	     (MULTIPLE-VALUE (X Y)
	       (SEND STREAM :COMPUTE-MOTION STRING START END X Y)))
	   (COMPUTE-ADDITIONAL-MOTION-IN-ECHO-STYLE (STRING &OPTIONAL (START 0) END)
	     (LET ((ECHO-STYLE (SEND-IF-HANDLES STREAM :ECHO-CHARACTER-STYLE)))
	       ;; be prepared to handle non-interactive streams
	       (IF ECHO-STYLE
		   (MULTIPLE-VALUE (X Y)
		     (SCL:WITH-CHARACTER-STYLE (ECHO-STYLE STREAM)
		       (SEND STREAM :COMPUTE-MOTION STRING START END X Y)))
		   (COMPUTE-ADDITIONAL-MOTION STRING START END)))))
    (MAP-OVER-INPUT-EDITOR-BUFFER INPUT-EDITOR-BUFFER START END
				  #'COMPUTE-ADDITIONAL-MOTION-IN-ECHO-STYLE
				  #'COMPUTE-ADDITIONAL-MOTION
				  #'COMPUTE-ADDITIONAL-MOTION))
  (VALUES X Y))

(DEFSUBST-IN-FLAVOR (INPUT-EDITOR-COMPUTE-MOTION-FROM-START INTERACTIVE-STREAM) (END)
  (INPUT-EDITOR-COMPUTE-MOTION 0 END BUFFER-X BUFFER-Y))

;; Empty out the buffer.

(DEFVAR *INPUT-EDITOR-CLEAR-HOOKS* NIL)

(DEFUN-IN-FLAVOR (INPUT-EDITOR-CLEAR-BUFFER INTERACTIVE-STREAM) ()
  (DOLIST (HOOK *INPUT-EDITOR-CLEAR-HOOKS*)
    (FUNCALL HOOK SELF INPUT-EDITOR-BUFFER))
  (SETF (IEB-FILL-POINTER) 0)
  (SETF (IEB-SCAN-POINTER) 0)
  (SETF (IEB-TYPEIN-POINTER) 0)
  (SETF (IEB-NOISE-STRINGS) NIL)
  (SETF (IEB-BUFFER-BLIPS) NIL)
  (SETF ACTIVATOR NIL)
  (SETF RESCAN-CHARACTER NIL))


;; Move whatever characters are left in the buffer after the scan pointer to the beginning
;; of the buffer.  The scan pointer should always lie before the fill pointer, but don't
;; rely on this.

(DEFUN-IN-FLAVOR (INPUT-EDITOR-SHIFT-BUFFER INTERACTIVE-STREAM) ()
  (LET ((GAP (MAX 0 (- (IEB-FILL-POINTER) (IEB-SCAN-POINTER)))))
    (COPY-ARRAY-PORTION INPUT-EDITOR-BUFFER (IEB-SCAN-POINTER) (IEB-FILL-POINTER)
			INPUT-EDITOR-BUFFER 0 GAP)
    (SETF (IEB-FILL-POINTER) GAP)
    (SETF (IEB-SCAN-POINTER) 0)
    (SETF (IEB-TYPEIN-POINTER) GAP)
    (SETF (IEB-NOISE-STRINGS) NIL)
    (SETF ACTIVATOR NIL)))

(DEFUN CLEAR-BETWEEN-CURSORPOSES (STREAM X1 Y1 X2 Y2)
  (SEND STREAM :CLEAR-BETWEEN-CURSORPOSES X1 Y1 X2 Y2)
  (SEND STREAM :SET-CURSORPOS X1 Y1))

(DEFUN CLEAR-TO-CURSORPOS (STREAM X1 Y1)
  (MULTIPLE-VALUE-CALL
    #'CLEAR-BETWEEN-CURSORPOSES STREAM X1 Y1 (SEND STREAM :READ-CURSORPOS)))

(DEFUN-IN-FLAVOR (ASSURE-OUTSIDE-INPUT-EDITOR INTERACTIVE-STREAM) (MESSAGE)
  (IF (EQ RUBOUT-HANDLER :READ)
      (FERROR "Attempt to send a ~S message to ~S from inside the input editor."
	      MESSAGE SELF)))

(DEFUN-IN-FLAVOR (ASSURE-INSIDE-INPUT-EDITOR INTERACTIVE-STREAM) (MESSAGE)
  (IF (NOT RUBOUT-HANDLER)
      (FERROR "Attempt to send a ~S message to ~S from outside the input editor."
	      MESSAGE SELF)))

;; Ordinarily, characters are only stored into and read from the input editor buffer
;; when the input editor is being used.  However, sometimes unread input will be left in
;; the buffer after the input editor has returned, and this must be accessible to
;; non-input-editing readers of the stream.  This allows input such as "'ABC'" to echo
;; and be read correctly.  The last character will have been echoed by the input editor
;; and stored in the buffer.  Also, if an editing input editor is in use, it is possible
;; to leave more than one character in the buffer after the read function has returned.

;; :UNTYI must be careful to return characters to the correct buffer.  It must handle
;; four cases:
;;
;;   State = NIL   Input in the IEB	-- Decrement the scan pointer
;;   State = NIL   No input in the IEB	-- Untyi to the IOB
;;   State = :READ			-- Decrement the scan pointer
;;   State = :TYI			-- Untyi to the IOB
;;
;; If there are any characters which have been read from the IEB but which can be
;; Untyi'ed, then the scan pointer will be positive.

(DEFWHOPPER (:UNTYI INTERACTIVE-STREAM) (CH)
  (SETQ CH (INPUT-EDITOR-UNRETURN-CHAR CH))
  (COND ((OR (LISTP CH) (NULL CH))
	 (COND ((EQ RUBOUT-HANDLER :READ)
		(WHEN (AND (< (IEB-SCAN-POINTER) (IEB-FILL-POINTER))
			   ;; See the commented out code in INPUT-EDITOR-TYI
			   ;; that would have forced a rescan first but cannot.
			   (NOT (AND CH (DW:PRESENTATION-BLIP-P CH)
				     (GETF (DW:PRESENTATION-BLIP-OPTIONS CH) :ONCE-ONLY))))
		  (FERROR "Attempt to :UNTYI an activation character while rescanning."))
		(SETQ ACTIVATOR (IF (NULL CH) :EOF CH)))
	       (T (CONTINUE-WHOPPER CH))))
	((OR (EQ RUBOUT-HANDLER :TYI)
	     (NOT (VARIABLE-BOUNDP INPUT-EDITOR-BUFFER))
	     (ZEROP (IEB-SCAN-POINTER)))
	 (CONTINUE-WHOPPER CH))
	(T
	 (LET ((IEB-CH (AREF INPUT-EDITOR-BUFFER (1- (IEB-SCAN-POINTER)))))
	   ;; We can get away with CHAR-EQUAL here because usually the only
	   ;; things which are UNTYI'ed on interactive-streams are blips and
	   ;; activation characters which have no style, or whose style does
	   ;; not matter.  The root of this kludge is the fact that the
	   ;; "replace input" routines abuse character-styles.  --SWM
	   (UNLESS (CHAR-EQUAL CH IEB-CH)
	     (FERROR "Attempt to :UNTYI the character ~:C.~@
		      The last character :TYI'ed from ~A was ~:C."
		     CH SELF IEB-CH))
	   (DECF (IEB-SCAN-POINTER))))))

(DEFWHOPPER (:CLEAR-INPUT INTERACTIVE-STREAM) ()
  ;; Throw away input buffered by the input editor.
  (WHEN (VARIABLE-BOUNDP INPUT-EDITOR-BUFFER)
    (INPUT-EDITOR-CLEAR-BUFFER))
  ;; Throw away input buffered by the rest of the stream.
  (CONTINUE-WHOPPER))

;; Check for EOF and signal if necessary

(DEFUN-IN-FLAVOR (ANY-TYI-CHECK-EOF INTERACTIVE-STREAM) (CHAR EOF)
  (IF (OR CHAR (NOT EOF))
      CHAR
      (ERROR 'END-OF-FILE :STREAM SELF :FORMAT-STRING EOF)))

;; Be careful to fetch characters from the correct buffer.  There are three cases to handle.
;;
;;   State = NIL	-- Check IEB.  Check IOB.
;;   State = :READ	-- Check IEB.  Enter IE.
;;   State = :TYI	-- Check IOB.

(DEFWHOPPER (:ANY-TYI INTERACTIVE-STREAM) (&OPTIONAL EOF)
  (LOOP DO					;Loop if INPUT-EDITOR-TYI returns NIL
    (COND ;; If no IEB exists, don't look in it
      ((NOT (VARIABLE-BOUNDP INPUT-EDITOR-BUFFER))
       (RETURN (ANY-TYI-CHECK-EOF (CONTINUE-WHOPPER) EOF)))
      ;; State = NIL or State = :READ
      ((AND (NOT (EQ RUBOUT-HANDLER :TYI))
	    (< (IEB-SCAN-POINTER) (IEB-FILL-POINTER))
	    (NOT (AND RESCAN-CHARACTER
		      (= (IEB-SCAN-POINTER) RESCAN-POINTER))))
       (RETURN (PROG1 (INPUT-EDITOR-RETURN-CHAR (AREF INPUT-EDITOR-BUFFER
						      (IEB-SCAN-POINTER)))
		      (INCF (IEB-SCAN-POINTER)))))
      ;; State = :READ or rescan character seen.
      ((EQ RUBOUT-HANDLER :READ)
       ;; Return activation blip or activation character, if present
       (IF ACTIVATOR
	   (RETURN (PROG1 (ANY-TYI-CHECK-EOF (IF (EQ ACTIVATOR :EOF) NIL ACTIVATOR) EOF)
			  (SETF ACTIVATOR NIL)))
	 ;; Return a blip character, or loop and read out of input buffer
	 (LET ((BLIP-CHARACTER (INPUT-EDITOR-TYI SELF NIL)))
	   (IF BLIP-CHARACTER (RETURN BLIP-CHARACTER)))))
      ;; State = NIL or State = :TYI
      (T
       ;; :UNTYI into the IOB instead of the IEB
       (IF (AND (NOT RUBOUT-HANDLER) (NOT (ZEROP (IEB-SCAN-POINTER))))
	   (INPUT-EDITOR-CLEAR-BUFFER))
       (RETURN (ANY-TYI-CHECK-EOF (CONTINUE-WHOPPER) EOF))))))

;; It is not meaningful to send :LISTEN, :TYI-NO-HANG, :ANY-TYI-NO-HANG, or :INPUT-WAIT from
;; inside a reading function, i.e. when the value of RUBOUT-HANDLER is :READ.  Reading
;; functions are supposed to be able to read either from interactive or non-interactive
;; streams, and therefore should not depend in any way on any temporal factors.  Input should
;; always be available until EOF is reached.

(DEFWHOPPER (:ANY-TYI-NO-HANG INTERACTIVE-STREAM) (&OPTIONAL EOF)
  (ASSURE-OUTSIDE-INPUT-EDITOR :ANY-TYI-NO-HANG)
  (MULTIPLE-VALUE-BIND (CHAR CHAR-P)
      (CONTINUE-WHOPPER)
    (IF (AND (NULL CHAR) CHAR-P EOF)
	(ERROR 'END-OF-FILE :STREAM SELF :FORMAT-STRING EOF)
      (VALUES CHAR CHAR-P))))

(DEFWHOPPER (:LISTEN INTERACTIVE-STREAM) ()
  (ASSURE-OUTSIDE-INPUT-EDITOR :LISTEN)
  (CONTINUE-WHOPPER))

;; Default the whostate to "Tyi" at this level, since the next lower level might default
;; it to "Net In" or "Serial In".

(DEFVAR *WHOSTATE-AWAITING-USER-INPUT* "User Input")

(DEFWHOPPER (:INPUT-WAIT INTERACTIVE-STREAM) (&OPTIONAL WHOSTATE FUNCTION &REST ARGUMENTS)
  ;; We don't boost the priority because we may resume for a non-interactive reason.
  ;; This one probably wouldn't buy us much, anyway.  If this is purely interactive, it
  ;; is the caller's responsibility to give it the interactive priority.
  (ASSURE-OUTSIDE-INPUT-EDITOR :INPUT-WAIT)
  (LEXPR-CONTINUE-WHOPPER (OR WHOSTATE *WHOSTATE-AWAITING-USER-INPUT*) FUNCTION ARGUMENTS))

;; Probably this should always beep when throwing a blip away, but be conservative
;; for the time being.  Also, there is no reason for Mouse-R-1 to be synchronous
;; with the process sending the :TYI.  Ignoring Mouse-L-1 is a kludge to compensate
;; for (ESSENTIAL-MOUSE :MOUSE-CLICK) always sending a blip, even if the window isn't
;; selected.  Fix this when the activity system is written.

(DEFUN TYI-BLIP-HANDLER (BLIP STREAM)
  (IF (LISTP BLIP)
      (LET ((HANDLER (GET (CAR BLIP) 'BLIP-HANDLER)))
	(IF HANDLER
	    (FUNCALL HANDLER BLIP STREAM)
	    (PROGN (SELECTQ (CAR BLIP)
		     (:MOUSE-BUTTON
		      (SELECTOR (SECOND BLIP) CHAR-MOUSE-EQUAL
			(#\Mouse-L )
			(OTHERWISE
			  (CL:APPLY #'TV:CONSIDER-MOUSE-CALL-SYSTEM-MENU (REST1 BLIP)))))
		     ((:MENU :TYPEOUT-EXECUTE)
		      (BEEP)))
		   NIL)))))

;; The FULL-RUBOUT code below is triggered only by blips which are generated by the input
;; editor and returned to the caller of :TYI, i.e. only by :ACTIVATION blips.  It can be
;; flushed when FULL-RUBOUT is flushed.

(DEFUN-IN-FLAVOR (TYI-INTERNAL INTERACTIVE-STREAM) (OPERATION EOF)
  (LOOP FOR CHAR = (SEND SELF OPERATION EOF) DO
    (COND ((OR (NULL CHAR) (CHARACTERP CHAR))
	   (RETURN CHAR))
	  (T (SETQ CHAR (TYI-BLIP-HANDLER CHAR SELF))
	     (IF CHAR (RETURN CHAR))))
    (WHEN (AND RUBOUT-HANDLER
	       (VARIABLE-BOUNDP INPUT-EDITOR-BUFFER)
	       (ZEROP (IEB-FILL-POINTER))
	       (INPUT-EDITOR-FLAG :FULL-RUBOUT))
      (THROW 'INPUT-EDITOR-RESCAN NIL))))

;; For programs which are prepared only to receive keyboard input.

(DEFMETHOD (:TYI INTERACTIVE-STREAM) (&OPTIONAL EOF)
  (TYI-INTERNAL :ANY-TYI EOF))

(DEFMETHOD (:TYI-NO-HANG INTERACTIVE-STREAM) (&OPTIONAL IGNORE)
  (TYI-INTERNAL :ANY-TYI-NO-HANG NIL))

;; For programs which are prepared only to receive lists.

(DEFMETHOD (:LIST-TYI INTERACTIVE-STREAM) ()
  (LOOP FOR CHAR = (SEND SELF :ANY-TYI) DO
	(IF (ATOM CHAR) (BEEP) (RETURN CHAR))))

(DEFMETHOD (:READ-BP INTERACTIVE-STREAM) ()
  (ASSURE-INSIDE-INPUT-EDITOR :READ-BP)
  (IEB-SCAN-POINTER))

(DEFMETHOD (:FORCE-RESCAN INTERACTIVE-STREAM) ()
  (ASSURE-INSIDE-INPUT-EDITOR :FORCE-RESCAN)
  (THROW 'INPUT-EDITOR-RESCAN NIL))

(DEFMETHOD (:RESCANNING-P INTERACTIVE-STREAM) ()
  (ASSURE-INSIDE-INPUT-EDITOR :RESCANNING-P)
  (OR (< (IEB-SCAN-POINTER) (IEB-FILL-POINTER))
      ACTIVATOR))

;; N-CHARS may be:
;;   A number -- remove that many characters from immediately after the scan pointer
;;   A string -- remove as many characters as there are in the string
;;   NIL      -- remove from the beginning of the input buffer to the scan pointer
;; STRING may be a string or something which can be coerced into a string.
;; RESCAN-MODE may be:
;;   :ENABLE  -- replace even if rescanning (i.e. text may change in the middle of input)
;;   :IGNORE  -- don't replace when rescanning
;;   :ERROR   -- signal an error if this method is sent while rescanning
;;   :REPLACE -- obsolete way of saying :ENABLE

(DEFMETHOD (:REPLACE-INPUT INTERACTIVE-STREAM)
	   (N-CHARS STRING &OPTIONAL (BEGIN 0) END (RESCAN-MODE :IGNORE))
  (ASSURE-INSIDE-INPUT-EDITOR :REPLACE-INPUT)
  (COND ((OR (= (IEB-SCAN-POINTER) (IEB-FILL-POINTER))
	     (MEMQ RESCAN-MODE '(:ENABLE :REPLACE)))
	 (SETQ STRING (STRING STRING))
	 (OR END (SETQ END (STRING-LENGTH STRING)))
	 (COND ((NULL N-CHARS)
		(SETQ N-CHARS (IEB-SCAN-POINTER)))
	       (T (IF (STRINGP N-CHARS) (SETQ N-CHARS (STRING-LENGTH N-CHARS)))
		  (UNLESS ( 0 N-CHARS (IEB-SCAN-POINTER))
		    (FERROR "Attempt to remove ~D characters from the input editor buffer; ~
			     there are only ~D characters before the scan pointer."
			    N-CHARS (IEB-SCAN-POINTER)))))
	 (INPUT-EDITOR-REPLACE-INPUT SELF N-CHARS STRING BEGIN END)
	 (INCF (IEB-SCAN-POINTER) (- (- END BEGIN) N-CHARS)))
	((EQ RESCAN-MODE :IGNORE))
	((EQ RESCAN-MODE :ERROR)
	 (FERROR "Attempt to invoke the :REPLACE-INPUT operation with the scan pointer ~
		  not at the end of the input buffer."))
	(T (FERROR "~S is an unknown rescan mode for :REPLACE-INPUT." RESCAN-MODE))))

;;; Like :REPLACE-INPUT-SINCE, but takes a blip.
(DEFMETHOD (:INSERT-INPUT-BLIP INTERACTIVE-STREAM) (BLIP &OPTIONAL START-LOC)
  (LET* ((BLIP-STRING (IE-BLIP-BUFFER-BLIP BLIP))
	 (LENGTH (STRING-LENGTH BLIP-STRING)))
    (INPUT-EDITOR-REPLACE-INPUT SELF (IF START-LOC (- (IEB-SCAN-POINTER) START-LOC) 0)
				BLIP-STRING 0 LENGTH)
    (INCF (IEB-SCAN-POINTER) LENGTH)))

(DEFMETHOD (:READ-LOCATION INTERACTIVE-STREAM) ()
  (ASSURE-INSIDE-INPUT-EDITOR :READ-LOCATION)
  (IEB-SCAN-POINTER))

(DEFMETHOD (:SET-LOCATION INTERACTIVE-STREAM) (LOCATION)
  (SETF (IEB-SCAN-POINTER) LOCATION))

(DEFMETHOD (:TYPEIN-LOCATION INTERACTIVE-STREAM) ()
  (IEB-TYPEIN-POINTER))

(DEFMETHOD (:SET-TYPEIN-LOCATION INTERACTIVE-STREAM) (LOCATION &OPTIONAL (DELTA 0))
  (IE-SET-POSITION (+ LOCATION DELTA))
  (THROW 'INPUT-EDITOR-RESCAN NIL))

(DEFMETHOD (:REPLACE-INPUT-SINCE INTERACTIVE-STREAM) (LOCATION STRING &OPTIONAL (BEGIN 0) END
							       (RESCAN-MODE :IGNORE))
  (SEND SELF :REPLACE-INPUT (- (IEB-SCAN-POINTER) LOCATION) STRING BEGIN END RESCAN-MODE))

(DEFMETHOD (:COPY-INPUT-SINCE INTERACTIVE-STREAM) (LOCATION)
  (COPY-INPUT-EDITOR-BUFFER INPUT-EDITOR-BUFFER LOCATION (IEB-SCAN-POINTER)))

;; Noise strings may be added when typing at the end of the line, or when typing a rescan
;; character in the middle of the line.  They should not be added by input editor commands
;; since the position of the noise string is associated with the scan pointer, not the typein
;; pointer.
;; STRING may be a string or something which can be coerced into a string.
;; RESCAN-MODE may be:
;;   :ENABLE -- insert even if rescanning (i.e. noise string appears in the middle of input)
;;   :IGNORE -- don't insert when rescanning
;;   :ERROR  -- signal an error if this method is sent while rescanning

;; A kludge was added so that printing a noise string at the end of the line is suppressed if
;; one is there already.  This breaks multiple noise strings.  There should be a more
;; structured way of determining if a rescan is taking place than just (= SCAN-POINTER
;; FILL-POINTER), since this doesn't tell you if a :NOISE-STRING-OUT happened after the last
;; call to :TYI.  Also, there should probably be a RESCAN-MODE called :REPLACE which compares
;; the new string and the old string, and replaces if they do not match.  Also, :ENABLE
;; probably should have some way of telling whether the noise string it is printing
;; is already visible, or whether it is a new noise string being inserted in the middle
;; of the line.  -- CWH/DEG 10/29/84

(DEFMETHOD (:NOISE-STRING-OUT INTERACTIVE-STREAM) (STRING &OPTIONAL (RESCAN-MODE :IGNORE))
  (UNLESS *DISABLE-NOISE-STRINGS*
    (ASSURE-INSIDE-INPUT-EDITOR :NOISE-STRING-OUT)
    (LET ((SCAN-POINTER (IEB-SCAN-POINTER))
	  (FILL-POINTER (IEB-FILL-POINTER)))
      (COND ((OR (AND (= SCAN-POINTER FILL-POINTER)
		      (NOT (ASSQ SCAN-POINTER (IEB-NOISE-STRINGS))))
		 (EQ RESCAN-MODE :ENABLE))
	     (SETQ STRING (STRING STRING))
	     (SETF (IEB-NOISE-STRINGS)
		   (NCONC (IEB-NOISE-STRINGS)
			  (NCONS (CONS SCAN-POINTER STRING))))
	     (SCL:WITH-CHARACTER-STYLE (*NOISE-STRING-CHARACTER-STYLE*)
	       (COND ((= SCAN-POINTER FILL-POINTER)
		      (SEND SELF :STRING-OUT STRING))
		     (T (SORTCAR (IEB-NOISE-STRINGS) #'LESSP)
			(SEND SELF :INSERT-STRING STRING)))))
	    ((EQ RESCAN-MODE :IGNORE))
	    ((EQ RESCAN-MODE :ERROR)
	     (FERROR "Attempt to invoke the :NOISE-STRING-OUT operation with the scan pointer ~
		      not at the end of the input buffer."))
	    (T (FERROR "~S is an unknown rescan mode for :NOISE-STRING-OUT." RESCAN-MODE))))))

;; If this is the first time the :INPUT-EDITOR message has been sent to this stream,
;; create the input history.

;;; Make a new kind of input history based on the formatted-output
;;; macros.
;;; Commented out until those macros are installed.
;
;(DEFFLAVOR INPUT-BUFFER-HISTORY () (ZWEI:HISTORY))
;
;(DEFMETHOD (INPUT-BUFFER-HISTORY :PRINT-ELEMENT) (ELEMENT STANDARD-OUTPUT)
;  (WHEN (LISTP ELEMENT)
;    (SETQ ELEMENT (FIRST ELEMENT)))
;  (WITH-ABBREVIATED-OUTPUT (:WIDTH 30. :HEIGHT 2
;			    :LOZENGE-RETURNS T :SHOW-ABBREVIATION T
;			    :ABBREVIATE-INITIAL-WHITESPACE T)
;    (IF (INPUT-EDITOR-BUFFER-P ELEMENT)
;	(FLET ((STRING-OUT (STRING &OPTIONAL (START 0) END)
;		 (SEND STANDARD-OUTPUT :STRING-OUT STRING START END)))
;	  (MAP-OVER-INPUT-EDITOR-BUFFER ELEMENT 0 NIL
;					;; Use IGNORE for noise to keep from abbeviating.
;					#'STRING-OUT #'IGNORE #'STRING-OUT))
;	(PRINC ELEMENT))))
;
;;; If this is the first time the :INPUT-EDITOR message has been sent to this stream,
;;; create the input history.
;
;(DEFUN-METHOD INPUT-EDITOR-ENTER INTERACTIVE-STREAM ()
;  (WHEN (NULL INPUT-HISTORY)
;    (SETF INPUT-HISTORY
;	  (MAKE-INSTANCE 'INPUT-BUFFER-HISTORY :NAME
;			 (STRING-APPEND (SEND SELF :NAME) " Input")))
;    (PUSH INPUT-HISTORY *INPUT-EDITOR-HISTORIES*)))

(DEFUN-IN-FLAVOR (INPUT-EDITOR-ENTER INTERACTIVE-STREAM) ()
  (WHEN (NULL INPUT-HISTORY)
    (SETF INPUT-HISTORY
	  (MAKE-INSTANCE 'ZWEI:ABBREVIATING-HISTORY :NAME
			 (STRING-APPEND (SEND SELF :NAME) " Input")))
    (PUSH INPUT-HISTORY *INPUT-EDITOR-HISTORIES*)))

;; Save the contents of the input buffer on the input history, unless the string is two
;; characters or less, or unless :NO-INPUT-SAVE is specified (usually by FQUERY).
;; Identical consecutive strings are saved on the history, but the history display and
;; yank mechanism filters them out.  While editing, the scan pointer is left alone -- only
;; the fill pointer is updated -- so the fill pointer may often be less than the scan
;; pointer.  In fact, the scan pointer and typein pointer slots could probably be merged.
;; I don't think the two are ever needed at the same time.

;; During a normal return, only the scanned contents of the buffer are saved on the input
;; ring.  For instance, if "'ABC'" is typed to a Lisp listener, only "'ABC" is saved, and
;; "'" is left in the buffer to be read later.  Aborting out of a read causes the entire
;; buffer to be saved.  There is a good argument for saving the buffer on the kill ring
;; instead of the input history in this case, but since the input history should
;; correspond to what is on the screen, we don't do this.

(DEFUN-IN-FLAVOR (INPUT-EDITOR-EXIT INTERACTIVE-STREAM) (ABORT-P)
  (LET ((SAVE-POINTER (IF ABORT-P
			  (IEB-FILL-POINTER)
			  (MIN (IEB-FILL-POINTER) (IEB-SCAN-POINTER)))))
    ;  (IF (AND (> SAVE-POINTER 0)
    ;		(CHAR= (AREF INPUT-EDITOR-BUFFER (1- SAVE-POINTER)) #\SPACE))
    ;      (DECF SAVE-POINTER))
       (UNLESS *INPUT-EDITOR-TYPEIN*
	 ;; LAST-INPUT should only be set to NIL when ABORT-P is T and
	 ;; IEB-FILL-POINTER is 0.
	 (SETQ LAST-INPUT
	       (WHEN (> SAVE-POINTER 0)
		 (COPY-INPUT-EDITOR-BUFFER INPUT-EDITOR-BUFFER 0 SAVE-POINTER)))
	 (COND ((AND (NOT (INPUT-EDITOR-FLAG :NO-INPUT-SAVE))
		     (NOT (NULL LAST-INPUT))	;NIL in history is a no-no
		     ;; save all blips that echoed any characters, save non-blip
		     ;; input that is long enough to be worth saving
		     (OR (NOT (NULL (IEB-BUFFER-BLIPS)))
			 (> SAVE-POINTER 2)))
		(SEND INPUT-HISTORY :PUSH LAST-INPUT))
	       ;; Not returning via :FULL-RUBOUT, :PREEMPTABLE, or :COMMAND.
	       ((> SAVE-POINTER 0)
		(SEND INPUT-HISTORY :SET-ROTATION 0))))))

;; Currently, if there are any characters left over in the input buffer, the read function
;; takes them as input immediately.  If we decide that some confirmation is needed instead,
;; then change the (ASSQ :INITIAL-INPUT ...) to be (> (IEB-FILL-POINTER) 0).

(DEFVAR *POSITION-TO-READ-ERROR-THRESHOLD* 20.)

(DEFVAR *BEEP-ON-PARSE-ERROR* NIL)

(DEFUN-IN-FLAVOR (INPUT-EDITOR-READ INTERACTIVE-STREAM) (READ-FUNCTION READ-ARGS)
  (DO ((*INPUT-EDITOR-PACKAGE* PACKAGE)
       (FIRST-P T)
       (PREEMPTABLE (INPUT-EDITOR-FLAG :PREEMPTABLE))
       (ACTIVATION (INPUT-EDITOR-OPTION :ACTIVATION))
       (COMMAND (INPUT-EDITOR-OPTION :COMMAND))
       (FULL-RUBOUT (INPUT-EDITOR-FLAG :FULL-RUBOUT))
       (LIMITED-FULL-RUBOUT (INPUT-EDITOR-FLAG :LIMITED-FULL-RUBOUT)))
      (NIL)
    ;; Throw here to reparse buffered input.
    (CATCH 'INPUT-EDITOR-RESCAN
      (WHEN FIRST-P
	;; If there is initial input, force a call into the input editor
	;; before invoking the read function.
	(SETQ FIRST-P NIL)
	(WHEN (OR (INPUT-EDITOR-OPTION :INITIAL-INPUT)
		  (INPUT-EDITOR-OPTION :INITIAL-YANK))
	  (INPUT-EDITOR-TYI SELF ':EOL)))
      ;; Begin rescanning the input buffer.
      (SETF (IEB-SCAN-POINTER) 0)
      (CONDITION-CASE (ERROR)
	  (LET ((RUBOUT-HANDLER :READ))
	    (RETURN (APPLY READ-FUNCTION READ-ARGS)))
	(PARSE-ERROR
	  ;; Clear the activator cell in case this error was triggered by an activator
	  ;; but was untyi'ed before PARSE-ERROR was called.
	  (SETF ACTIVATOR NIL)
	  (MULTIPLE-VALUE-BIND (X1 Y1)
	      (SEND SELF :READ-CURSORPOS)
	    (SEND SELF :FRESH-LINE)
	    (WHEN *BEEP-ON-PARSE-ERROR*
	      (SEND SELF :BEEP))
	    (SEND ERROR :REPORT SELF)
	    (IF (SEND ERROR :CORRECT-INPUT)
		(PROGN
		  (UNLESS (ZEROP (SEND SELF :READ-CURSORPOS))
		    (MULTIPLE-VALUE-BIND (WIDTH HEIGHT)
			(SEND SELF :SIZE-IN-CHARACTERS)
		      (IF (AND ( HEIGHT 4) (> WIDTH 78.))
			  (SEND SELF :STRING-OUT "  ")
			  (SEND SELF :TYO #\NEWLINE))))
		  (SEND SELF :LINE-OUT "Press  to correct your input.")
		  ;; Subtract at least 1 from the fill pointer in case the last character
		  ;; typed was untyied.  Test case:  "(1e300("
		  (IF (AND *POSITION-TO-READ-ERROR-THRESHOLD*
			   (< (IEB-SCAN-POINTER)
			      (- (IEB-FILL-POINTER) *POSITION-TO-READ-ERROR-THRESHOLD*)))
		      (MULTIPLE-VALUE-BIND (X2 Y2)
			  (SEND SELF :READ-CURSORPOS)
			(SETF (IEB-TYPEIN-POINTER) (IEB-SCAN-POINTER))
			(INPUT-EDITOR-CURSOR-MOTION SELF (IEB-TYPEIN-POINTER))
			;; Code to receive notifications should be added here.
			(SEND SELF :INPUT-WAIT)
			(SEND SELF :CLEAR-BETWEEN-CURSORPOSES X1 Y1 X2 Y2))))
		(MULTIPLE-VALUE-BIND (X2 Y2)
		    (SEND SELF :READ-CURSORPOS)
		  (INPUT-EDITOR-CURSOR-MOTION SELF (IEB-TYPEIN-POINTER))
		  (SEND SELF :INPUT-WAIT)
		  (SEND SELF :CLEAR-BETWEEN-CURSORPOSES X1 Y1 X2 Y2)))
	    ;; Remain in the input editor until INPUT-EDITOR-RESCAN is thrown to.
	    (INPUT-EDITOR-TYI SELF ':ACTIVATION)))))
    ;; Non-normal exit of the input editor
    (COND
      ;; Some type of activation
      ((NOT (ATOM ACTIVATOR))
       (COND
	 ;; Re-enter the read function if an activation character is typed.
	 ((AND ACTIVATION (EQ (CAR ACTIVATOR) :ACTIVATION)))
	 ;; Return if a keystroke command is typed.
	 ((EQ (CAR ACTIVATOR) :COMMAND)
	  (WHEN COMMAND
	    (SETF (IEB-SCAN-POINTER) 0)
	    (RETURN (VALUES ACTIVATOR :COMMAND))))
	 ;; Return if some other blip comes through the I/O buffer.
	 (PREEMPTABLE
	  (SETF (IEB-SCAN-POINTER) 0)
	  (RETURN (VALUES ACTIVATOR PREEMPTABLE)))))
      ;; Return if the input buffer is emptied.
      ((AND (ZEROP (IEB-FILL-POINTER))
	    (OR FULL-RUBOUT (AND LIMITED-FULL-RUBOUT (NOT RESCAN-CHARACTER))))
       (RETURN (VALUES NIL (OR FULL-RUBOUT LIMITED-FULL-RUBOUT)))))))

(DEFWHOPPER (:INPUT-EDITOR INTERACTIVE-STREAM) (READ-FUNCTION &REST READ-ARGS)
  (LET ((*INPUT-EDITOR-STREAM* SELF))
    (LEXPR-CONTINUE-WHOPPER READ-FUNCTION READ-ARGS)))

(DEFMETHOD (:INPUT-EDITOR INTERACTIVE-STREAM) (READ-FUNCTION &REST READ-ARGS)
  ;; Make a buffer if we don't already have one
  (UNLESS (VARIABLE-BOUNDP INPUT-EDITOR-BUFFER)
    (SETQ INPUT-EDITOR-BUFFER (MAKE-INPUT-EDITOR-BUFFER)))
  ;; Discard already scanned input.
  (INPUT-EDITOR-SHIFT-BUFFER)
  ;; Copy initial input into the input editor buffer.  Append it to whatever is already there.
  ;; The arguments to the option are the string, indices into the string, and an initial
  ;; cursor position.
  (FLET ((DO-INITIAL-INPUT (STRING &OPTIONAL (BEGIN 0) END TYPEIN-POINTER
				   &AUX NEW-FILL-POINTER)
	   (OR BEGIN (SETQ BEGIN 0))
	   (OR END (SETQ END (ARRAY-ACTIVE-LENGTH STRING)))
	   (SETQ NEW-FILL-POINTER (+ (IEB-FILL-POINTER) (- END BEGIN)))
	   (IF (< (ARRAY-LENGTH INPUT-EDITOR-BUFFER) NEW-FILL-POINTER)
	       (ADJUST-ARRAY-SIZE INPUT-EDITOR-BUFFER NEW-FILL-POINTER))
	   (LET ((MERGE-STYLE (SI:INDEX-CHARACTER-STYLE TYPEIN-STYLE)))
	     (IF (NEQ MERGE-STYLE *NULL-STYLE*)
		 (LOOP FOR C BEING THE ARRAY-ELEMENTS OF STRING FROM BEGIN BELOW END
		       FOR TO-X FROM (IEB-FILL-POINTER) DO
		   (SETF (CHAR-STYLE-INDEX C)
			 (STYLE-INDEX (MERGE-CHARACTER-STYLES (CHAR-STYLE C) MERGE-STYLE)))
		   (SETF (AREF INPUT-EDITOR-BUFFER TO-X) C))
		 (COPY-ARRAY-PORTION STRING BEGIN END
				     INPUT-EDITOR-BUFFER (IEB-FILL-POINTER) NEW-FILL-POINTER)))
	   (SETF (IEB-FILL-POINTER) NEW-FILL-POINTER)
	   (SETF MARK (IEB-TYPEIN-POINTER))
	   (SETF (IEB-TYPEIN-POINTER)
		 (IF (NOT TYPEIN-POINTER)
		     NEW-FILL-POINTER
		     (MAX 0 (MIN TYPEIN-POINTER NEW-FILL-POINTER))))))
    (LET ((OPTION (INPUT-EDITOR-OPTION :INITIAL-INPUT)))
      (WHEN (CAR OPTION)
	(LEXPR-FUNCALL #'DO-INITIAL-INPUT OPTION)))
    (LET ((OPTION (INPUT-EDITOR-OPTION :INITIAL-YANK)))
      (WHEN OPTION
	(DESTRUCTURING-BIND (HISTORY &OPTIONAL N) OPTION
	  (LET ((STRING (AND HISTORY (SEND HISTORY :YANK N))))
	    (WHEN STRING
	      (DO-INITIAL-INPUT STRING)
	      (SETF YANK-HISTORY HISTORY)))))))
  (INPUT-EDITOR-ENTER)
  (LET ((ABORT-P T))
    (SEND SELF :REFRESH-RUBOUT-HANDLER :PROMPT)
    (UNWIND-PROTECT
	(MULTIPLE-VALUE-PROG1
	  (INPUT-EDITOR-READ READ-FUNCTION READ-ARGS)
	  (SETQ ABORT-P NIL))
      (INPUT-EDITOR-EXIT ABORT-P)
      ;; If normal return, discard scanned input, and erase everything but the scanned
      ;; input from the screen, since it will be echoed later.  If abortive return,
      ;; discard all input.
      (IF (OR ABORT-P ( (IEB-SCAN-POINTER) (IEB-FILL-POINTER)))
	  (INPUT-EDITOR-CLEAR-BUFFER)
	  (PROGN 
	    (MULTIPLE-VALUE-CALL
	      #'CLEAR-BETWEEN-CURSORPOSES SELF
	      (INPUT-EDITOR-COMPUTE-MOTION-FROM-START (IEB-SCAN-POINTER))
	      (INPUT-EDITOR-COMPUTE-MOTION-FROM-START (IEB-FILL-POINTER)))
	    (INPUT-EDITOR-SHIFT-BUFFER)))
      )))

;; Prompt and print the input buffer, preserving the typein pointer.
;; REASON can be one of the following, depending upon where it is called from:
;;   :PROMPT				:INPUT-EDITOR method
;;   :RESTORE				:RESTORE-INPUT-BUFFER method
;;   :FINISH-TYPEOUT			:FINISH-TYPEOUT method
;;   :REFRESH				<Refresh> key
;;   :ERASE-TYPEOUT			<Page> key

(DEFMETHOD (:REFRESH-RUBOUT-HANDLER INTERACTIVE-STREAM) (&OPTIONAL REASON)
  (UNLESS (EQ REASON :FINISH-TYPEOUT)
    (SETF TYPEOUT-OVERWRITABLE NIL)
    (SETF TYPEOUT-X NIL)
    (SETF TYPEOUT-Y NIL))
  (MULTIPLE-VALUE (PROMPT-X PROMPT-Y)
    (DISPLAY-PROMPT-OPTION SELF
			   (OR (AND (NEQ REASON :PROMPT)
				    (INPUT-EDITOR-OPTION :REPROMPT))
			       (INPUT-EDITOR-OPTION :PROMPT))
			   T REASON))
  (MULTIPLE-VALUE (BUFFER-X BUFFER-Y)
    (SEND SELF :READ-CURSORPOS))
  (WHEN (VARIABLE-BOUNDP INPUT-EDITOR-BUFFER)
    (INPUT-EDITOR-STRING-OUT)
    (INPUT-EDITOR-REFRESH SELF)))

;; Clear all input histories just before doing a disk-save, so that the history is empty
;; on cold boot.

(DEFUN INPUT-EDITOR-CLEAR-HISTORIES ()
  (DOLIST (HISTORY *INPUT-EDITOR-HISTORIES*) (SEND HISTORY :RESET)))

(ADD-INITIALIZATION "Clear Input Editor Histories" '(INPUT-EDITOR-CLEAR-HISTORIES)
		    '(BEFORE-COLD))

(DEFINE-GC-CLEANUP RESET-ALL-INPUT-HISTORIES ("Reset all input histories? ")
  (INPUT-EDITOR-CLEAR-HISTORIES))

;; SPACING may be either :NONE, :FRESH-LINE, or :BLANK-LINE.  NIL or no argument means to
;; use a default value, which is computed from the value of the TYPE argument to
;; :START-TYPEOUT and :FINISH-TYPEOUT.  :NONE means that no space is inserted before the
;; typeout, :FRESH-LINE means that the typeout will begin at the beginning of a line, and
;; :BLANK-LINE will assure that there is a blank line before the typeout.

(DEFUN-IN-FLAVOR (TYPEOUT-SPACING INTERACTIVE-STREAM) (SPACING)
  (SELECTQ SPACING
    (:NONE)
    (:FRESH-LINE
     (SEND SELF :FRESH-LINE))
    (:BLANK-LINE
     (SEND SELF :FRESH-LINE)
     (SEND SELF :TYO #\NEWLINE))
    (T (FERROR "Attempt to typeout on ~S, using unknown spacing ~S" SELF SPACING))))

;; The input editor knows about the following forms of typeout:
;; :INSERT
;;    The typeout is inserted before the current input, as is done with notifications.
;; :OVERWRITE
;;    Like :INSERT, but the next time :INSERT or :OVERWRITE typeout is performed,
;;    this typeout will be overwritten.  Should this be called "overwriteable"?
;; :APPEND
;;    The typeout appears after the current input, which will remain visible
;;    before the typeout.  This is the style used by the BREAK function and the Suspend key.
;; :TEMPORARY
;;    The typeout appears after the current input, and is erased after the user
;;    types a character.
;; :CLEAR-WINDOW
;;    The window is cleared and the typeout appears at the top.

;; TYPEOUT-TYPE will be one of the keywords above while typeout is going on, and will
;; be NIL otherwise.  TYPEOUT-X will be non-NIL if existing typeout on the screen
;; can be erased.  TYPEOUT-TYPE is not protected from unwinding, so aborting in the
;; middle of typeout does not change the value.  Perhaps it should.

(DEFMETHOD (:START-TYPEOUT INTERACTIVE-STREAM) (TYPE &OPTIONAL SPACING &AUX X1 Y1)
  (ASSURE-INSIDE-INPUT-EDITOR :START-TYPEOUT)
  ;; (IF TYPEOUT-TYPE
  ;;     (FERROR "Typeout of type ~A to ~S is already in progress"
  ;;		 TYPEOUT-TYPE SELF))
  (SETF TYPEOUT-TYPE TYPE)
  (SELECTQ TYPE
    ;; Move cursor to the beginning of the buffer.
    ;; Erase the entire region occupied by the typeout and the input buffer, since the new
    ;; typeout may not fill the available space, and since the typeout may appear slowly.
    ((:INSERT :OVERWRITE)
     (IF (AND TYPEOUT-OVERWRITABLE (EQ TYPE :OVERWRITE))
	 (SETQ X1 TYPEOUT-X Y1 TYPEOUT-Y)
	 (SETQ X1 PROMPT-X Y1 PROMPT-Y))
     (MULTIPLE-VALUE-BIND (IN X Y)
	 (CURSOR-INSIDE-INPUT-EDITOR-BUFFER-P SELF)
       (SEND SELF :CLEAR-BETWEEN-CURSORPOSES X1 Y1 X Y) ;clear the inside area
       (WHEN IN				;and position to start unless already moved away
	 (SEND SELF :SET-CURSORPOS X1 Y1))))
    ;; Move cursor to the end of the buffer.
    ((:APPEND :TEMPORARY)
	   ;when the cursor is inside the input editor buffer, move to its end.
     (MULTIPLE-VALUE-BIND (IN X Y)
	 (CURSOR-INSIDE-INPUT-EDITOR-BUFFER-P SELF)
       (WHEN IN 
	 (SEND SELF :SET-CURSORPOS X Y))))
    (:CLEAR-WINDOW
     (SEND SELF :CLEAR-WINDOW))
    (T (FERROR "Attempt to typeout on ~S, using unknown type ~S" SELF TYPE)))
  ;; Compute the default value of SPACING.  For :INSERT or :OVERWRITE typeout, do a
  ;; :FRESH-LINE since the prompt may not have started at the left edge, or may have been
  ;; printed outside the input editor.  For :APPEND or :TEMPORARY typeout, leave a blank
  ;; line before reprinting the input buffer.  For :CLEAR-WINDOW, no action is needed.
  (TYPEOUT-SPACING (OR SPACING
		       (SELECTQ TYPE
			 ((:INSERT :OVERWRITE) :FRESH-LINE)
			 ((:APPEND :TEMPORARY) :BLANK-LINE)
			 (:CLEAR-WINDOW :NONE))))
  ;; Mark the start of the typeout, if necessary.
  (SELECTQ TYPE
    ((:INSERT :OVERWRITE)
     (UNLESS TYPEOUT-X
       (SETQ TYPEOUT-X X1)
       (SETQ TYPEOUT-Y Y1)))
    ((:APPEND :TEMPORARY)
     (SETQ TYPEOUT-X NIL TYPEOUT-Y NIL))
    (:CLEAR-WINDOW
     (SETQ TYPEOUT-X 0 TYPEOUT-Y 0)))
  ;; Set the overwritable bit
  (SETQ TYPEOUT-OVERWRITABLE (EQ TYPE :OVERWRITE)))

(DEFMETHOD (CURSOR-INSIDE-INPUT-EDITOR-BUFFER-P INTERACTIVE-STREAM)
	   (&OPTIONAL (START-X PROMPT-X) (START-Y PROMPT-Y))
  (MULTIPLE-VALUE-BIND (X Y)
      (INPUT-EDITOR-COMPUTE-MOTION-FROM-START (IEB-FILL-POINTER))
    (MULTIPLE-VALUE-BIND (CX CY) (SEND SELF :READ-CURSORPOS)
      (VALUES (AND ( START-Y CY Y)
		   (COND ((= CY START-Y)
			  (AND ( CX START-X)
			       (OR ( CY Y) ( CX X ))))
			 ((= CY Y) ( CX X))
			 (T T)))
	      X Y CX CY)
      )))

;; If the typeout mode is :TEMPORARY, then the typeout will only be erased if the ERASE?
;; parameter is T.  Otherwise, the input will be reprinted after the typeout.  It is the
;; responsibility of the code doing the typeout to keep track of whether or not it has
;; wrapped around the window and overwritten the original input.

(DEFMETHOD (:FINISH-TYPEOUT INTERACTIVE-STREAM) (&OPTIONAL SPACING ERASE?)
  (ASSURE-INSIDE-INPUT-EDITOR :START-TYPEOUT)
  (IF (NOT TYPEOUT-TYPE)
      (FERROR "No typeout to ~S is in progress." SELF))
  (TYPEOUT-SPACING (OR SPACING :BLANK-LINE))
  (COND ((AND (EQ TYPEOUT-TYPE :TEMPORARY) ERASE?)
	 (LET* ((RUBOUT-HANDLER :TYI)
		(CHAR (READ-CHARACTER SELF :PROMPT "Press any character to erase: "
					   :SUSPEND NIL :ABORT NIL :REFRESH NIL)))
	   (IF (CHAR CHAR #\SPACE) (SEND SELF :UNTYI CHAR)))
	 (MULTIPLE-VALUE-CALL
	   #'CLEAR-TO-CURSORPOS SELF
	   (INPUT-EDITOR-COMPUTE-MOTION-FROM-START NIL))
	 (INPUT-EDITOR-REFRESH SELF))
	(T (SEND SELF :REFRESH-RUBOUT-HANDLER :FINISH-TYPEOUT)))
  (SETF TYPEOUT-TYPE NIL))

(DEFMETHOD (:INPUT-BUFFER INTERACTIVE-STREAM) () INPUT-EDITOR-BUFFER)

(DEFMETHOD (:SAVE-INPUT-BUFFER INTERACTIVE-STREAM) (&OPTIONAL TYPE)
  (OR TYPE (SETQ TYPE :APPEND))
  ;; If there are characters in the buffer, then save them.
  (WHEN (AND (VARIABLE-BOUNDP INPUT-EDITOR-BUFFER)
	     (> (IEB-FILL-POINTER) 0))
    ;; If inside the input editor, move the cursor to the end of the buffer.
    (IF RUBOUT-HANDLER (SEND SELF :START-TYPEOUT TYPE :FRESH-LINE))
    ;; Disallow use of m-Y.
    (SETF YANK-HISTORY NIL)
    ;; Return the current buffer and allocate a new one.
    (PROG1 INPUT-EDITOR-BUFFER
	   (SETQ INPUT-EDITOR-BUFFER (ALLOCATE-RESOURCE 'INPUT-EDITOR-BUFFER)))))

(DEFMETHOD (:RESTORE-INPUT-BUFFER INTERACTIVE-STREAM) (BUFFER &OPTIONAL (REFRESH? T))
  ;; If we're being given back a buffer, then hand ours back too.
  (WHEN BUFFER
    (DEALLOCATE-RESOURCE 'INPUT-EDITOR-BUFFER INPUT-EDITOR-BUFFER)
    (SETQ INPUT-EDITOR-BUFFER BUFFER))
  ;; Redisplay and update variables if we were inside the input editor.
  (WHEN (AND REFRESH? RUBOUT-HANDLER)
    (IF (EQ REFRESH? :NO-NEWLINE)
	(WHEN (VARIABLE-BOUNDP INPUT-EDITOR-BUFFER)
	  (MULTIPLE-VALUE (BUFFER-X BUFFER-Y)
	    (SEND SELF :READ-CURSORPOS))
	  (INPUT-EDITOR-STRING-OUT)
	  (INPUT-EDITOR-REFRESH SELF))
      (SEND SELF :FRESH-LINE)
      (SEND SELF :TYO #\NEWLINE)
      (SEND SELF :REFRESH-RUBOUT-HANDLER :RESTORE))))

(DEFMETHOD (:WITH-SAVED-STATE-FOR-BREAK INTERACTIVE-STREAM) (CONTINUATION)
  (DECLARE (DOWNWARD-FUNARG CONTINUATION))
  (LET ((IN-INPUT-EDITOR (AND RUBOUT-HANDLER (EQ SELF *INPUT-EDITOR-STREAM*)))
	(OLD-INPUT-BUFFER (SEND SELF :SAVE-INPUT-BUFFER)))
    (UNWIND-PROTECT-CASE (ABORT-P)
	(FUNCALL CONTINUATION)
      (:ALWAYS
	;; Restore the state of the original input buffer
	;;--- Note: The use of ABORT-P here to suppress refreshing the input buffer
	;;--- is not correct.  We may be invoking an error-restart that lies inside
	;;--- the program called from the input-editor; in that case, ABORT-P is T
	;;--- but the input-editor is not being aborted.  To fix this requires knowing
	;;--- how far the throw that is now happening is going to go.
	(WHEN IN-INPUT-EDITOR
	  (SEND SELF :RESTORE-INPUT-BUFFER OLD-INPUT-BUFFER (NOT ABORT-P)))))))

(DEFMETHOD (:CHOOSE-ATTRIBUTES INTERACTIVE-STREAM) ()
  (LET* ((DEVICE (SEND SELF :DISPLAY-DEVICE-TYPE))
	 (DEFAULT (SCL:ACCEPT `((SCL:CHARACTER-STYLE-FOR-DEVICE
				  ;; I guess we assume that the only interactive
				  ;; streams are b&w for the time being
				  :DEVICE ,DEVICE
				  :ALLOW-RELATIVE NIL))
			      :PROMPT "Default character style"
			      :DEFAULT (SEND SELF :DEFAULT-CHARACTER-STYLE)))
	 (ECHO (SCL:ACCEPT `((SCL:CHARACTER-STYLE-FOR-DEVICE
			       :DEVICE ,DEVICE :AGAINST-DEFAULT ,DEFAULT))
			   :PROMPT "Echo character style"
			   :DEFAULT (SEND SELF :ECHO-CHARACTER-STYLE)))
	 (TYPEIN (SCL:ACCEPT `((SCL:CHARACTER-STYLE-FOR-DEVICE
				 :DEVICE ,DEVICE :AGAINST-DEFAULT ,DEFAULT))
			     :PROMPT "Typein character style"
			     :DEFAULT (SEND SELF :TYPEIN-CHARACTER-STYLE))))
    (LIST :SET-DEFAULT-CHARACTER-STYLE DEFAULT
	  :SET-ECHO-CHARACTER-STYLE ECHO
	  :SET-TYPEIN-CHARACTER-STYLE TYPEIN)))

;; The D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")Style0 used by the input editor for typein.

(DEFMETHOD (:TYPEIN-CHARACTER-STYLE INTERACTIVE-STREAM) ()
  (SI:INDEX-CHARACTER-STYLE TYPEIN-STYLE))

;; Some CP command should worry about merging and parsing.
;; But this should also work like :set-default-style, so it parses.
;; It doesn't take a style index, though.
(DEFMETHOD (:SET-TYPEIN-CHARACTER-STYLE INTERACTIVE-STREAM) (STYLE)
  "This method takes a parsed character style."
  (DECLARE (ARGLIST STYLE-LIST-OR-PARSED-STYLE))
  (CL:CHECK-TYPE STYLE (OR CHARACTER-STYLE SCL:LIST))
  (WHEN (LISTP STYLE) (SETQ STYLE (SI:PARSE-CHARACTER-STYLE STYLE)))
  (SETQ TYPEIN-STYLE (STYLE-INDEX STYLE T)))

(COMPILER:MAKE-MESSAGE-OBSOLETE :TYPEIN-STYLE "Use :TYPEIN-CHARACTER-STYLE.")
(COMPILER:MAKE-MESSAGE-OBSOLETE :SET-TYPEIN-STYLE "Use :SET-TYPEIN-CHARACTER-STYLE.")

(DEFMETHOD (:TYPEIN-STYLE INTERACTIVE-STREAM) () (SEND SELF :TYPEIN-CHARACTER-STYLE))
(DEFMETHOD (:SET-TYPEIN-STYLE INTERACTIVE-STREAM) (STYLE)
  (SEND SELF :SET-TYPEIN-CHARACTER-STYLE STYLE))

;; The (2 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")Style 0used by the input editor to 1echo 0typein

(DEFMETHOD (:ECHO-CHARACTER-STYLE INTERACTIVE-STREAM) () ECHO-STYLE)

(DEFMETHOD (:SET-ECHO-CHARACTER-STYLE INTERACTIVE-STREAM) (STYLE)
  (DECLARE (ARGLIST STYLE-LIST-OR-PARSED-STYLE))
  (CL:CHECK-TYPE STYLE (OR CHARACTER-STYLE CL:LIST))
  (WHEN (LISTP STYLE) (SETQ STYLE (SI:PARSE-CHARACTER-STYLE STYLE)))
  (SETQ ECHO-STYLE STYLE))

(COMPILER:MAKE-MESSAGE-OBSOLETE :ECHO-STYLE "Use :ECHO-CHARACTER-STYLE.")
(COMPILER:MAKE-MESSAGE-OBSOLETE :SET-ECHO-STYLE "Use :SET-ECHO-CHARACTER-STYLE.")

(DEFMETHOD (:ECHO-STYLE INTERACTIVE-STREAM) () (SEND SELF :ECHO-CHARACTER-STYLE))
(DEFMETHOD (:SET-ECHO-STYLE INTERACTIVE-STREAM) (STYLE)
  (SEND SELF :SET-ECHO-CHARACTER-STYLE STYLE))

;; Hook for the read function for displaying help.  This allows the Help character to be setup
;; as a character blip and a rescan character so that the text displayed depends upon the
;; cursor position.

(DEFMETHOD (:DISPLAY-HELP INTERACTIVE-STREAM) (&OPTIONAL NUMERIC-ARG)
  (ASSURE-INSIDE-INPUT-EDITOR :DISPLAY-HELP)
  (INPUT-EDITOR-DISPLAY-HELP SELF NUMERIC-ARG))

;; Methods for simulating non-interactive streams and debugging programs which use them.

(DEFMETHOD (:LINE-IN INTERACTIVE-STREAM) (&OPTIONAL LEADER)
  (DECLARE (VALUES LINE EOF-P))
  (MULTIPLE-VALUE-BIND (STRING EOF)
      (LET ((OLD-STATE RUBOUT-HANDLER))
	(WITH-INPUT-EDITING (SELF :LINE)
	  (READ-DELIMITED-STRING (IF OLD-STATE #\RETURN) SELF NIL NIL
				 NIL :LEADER-LENGTH (IF (NUMBERP LEADER) LEADER))))
    (VALUES STRING EOF)))

(DEFMETHOD (:STRING-IN INTERACTIVE-STREAM) (EOF STRING &OPTIONAL (START 0) END)
  (DECLARE (VALUES LINE EOF-P))
  (MULTIPLE-VALUE-BIND (NIL EOF NIL NIL INDEX)
      (WITH-INPUT-EDITING (SELF)
	(READ-DELIMITED-STRING-INTERNAL
	  NIL SELF EOF STRING START (OR END (ARRAY-LENGTH STRING))))
    (VALUES INDEX EOF)))

(DEFMETHOD (:STRING-LINE-IN INTERACTIVE-STREAM) (EOF STRING &OPTIONAL (START 0) END)
  (DECLARE (VALUES LENGTH-SO-FAR EOF-P MORE-ON-LINE-P))
  (MULTIPLE-VALUE-BIND (NIL EOF DELIMITER NIL INDEX)
      (LET ((OLD-STATE RUBOUT-HANDLER))
	(WITH-INPUT-EDITING (SELF :LINE)
	  (READ-DELIMITED-STRING-INTERNAL
	    (IF OLD-STATE '(#\RETURN)) SELF EOF STRING START (OR END (ARRAY-LENGTH STRING)))))
    (VALUES INDEX EOF (NOT (OR EOF DELIMITER)))))

;; Notifications

;; Programs which wish to display notifications in their own fashion, rather than using the
;; pop-up window, should check for the notification cell becoming non-NIL in their wait
;; functions.  If a notification is present, then it can be received using
;; :RECEIVE-NOTIFICATION.  If the receiving process does not take the notification after some
;; timeout, the notification process will take it back and display it some other way.

(DEFMETHOD (:NOTIFICATION-CELL INTERACTIVE-STREAM) ()
  (LOCF NOTIFICATION))

(DEFMETHOD (:RECEIVE-NOTIFICATION INTERACTIVE-STREAM) ()
  (LET ((NOTE NOTIFICATION))
    (WHEN (AND NOTE
	       (STORE-CONDITIONAL (LOCF NOTIFICATION) NOTE NIL))
      NOTE)))

;; Stub for interactive streams which can't support mouse sensitivity.
;; TV:ITEM-LIST and ZWEI:DISPLAY-HISTORY-MENU may be called on such streams.

(DEFMETHOD (:ITEM INTERACTIVE-STREAM :DEFAULT) (TYPE ITEM &REST FORMAT-ARGS)
  TYPE ITEM  ;Ignored
  (IF FORMAT-ARGS (LEXPR-FUNCALL #'FORMAT SELF FORMAT-ARGS) (PRINC ITEM SELF)))

;; This message seems to only be sent to interactive streams.  If it is supposed to work for
;; non-interactive streams, then move this method to CHARACTER-STREAM or OUTPUT-STREAM.

(DEFMETHOD (:DISPLAY-LOZENGED-STRING INTERACTIVE-STREAM :DEFAULT) (STRING)
  (SEND SELF :TYO #/<)
  (SEND SELF :STRING-OUT STRING)
  (SEND SELF :TYO #/>))

;; Replacement for the TV:PREEMPTABLE-READ-ANY-TYI-MIXIN flavor and the :PREEMPTABLE-READ
;; message.  Instead of (SEND STREAM :PREEMPTABLE-READ () #'READ-FOR-TOP-LEVEL STREAM), write
;; (SI:PREEMPTABLE-READ #'READ-FOR-TOP-LEVEL STREAM), or specify the :PREEMPTABLE input editor
;; option using the WITH-INPUT-EDITING-OPTIONS special form.

(DEFUN PREEMPTABLE-READ (READ-FUNCTION &REST READ-ARGS)
  (MULTIPLE-VALUE-BIND (VALUE FLAG)
      (WITH-INPUT-EDITING-OPTIONS ((:PREEMPTABLE :MOUSE-CHAR))
	(APPLY READ-FUNCTION READ-ARGS))
    (IF (EQ FLAG :MOUSE-CHAR)
	(VALUES VALUE FLAG)
	VALUE)))

;; Compatibility

;; Obsolete interface to the input editor

(DEFMETHOD (:RUBOUT-HANDLER INTERACTIVE-STREAM)
	   (*INPUT-EDITOR-OPTIONS* READ-FUNCTION &REST READ-ARGS)
  (LEXPR-SEND SELF :INPUT-EDITOR READ-FUNCTION READ-ARGS))

;; Uncomment this when all references to :RUBOUT-HANDLER are removed from the system.  CVV
;; still needs to be converted to allow the read functions to invoke the input editor
;; themselves.

;; (COMPILER:MAKE-MESSAGE-OBSOLETE :RUBOUT-HANDLER
;;   "The :RUBOUT-HANDLER message to windows is obsolete.
;; Please use the WITH-INPUT-EDITING macro instead.")

;; User programs which do preemptable reading send these messages.
;; Flush in Rel 8.

(DEFMETHOD (:SAVE-RUBOUT-HANDLER-BUFFER INTERACTIVE-STREAM) (&REST ARGS)
  (LEXPR-SEND SELF :SAVE-INPUT-BUFFER ARGS))

(DEFMETHOD (:RESTORE-RUBOUT-HANDLER-BUFFER INTERACTIVE-STREAM) (&REST ARGS)
  (LEXPR-SEND SELF :RESTORE-INPUT-BUFFER ARGS))

(COMPILER:MAKE-MESSAGE-OBSOLETE :SAVE-RUBOUT-HANDLER-BUFFER
				"it has been renamed to :SAVE-INPUT-BUFFER")
(COMPILER:MAKE-MESSAGE-OBSOLETE :RESTORE-RUBOUT-HANDLER-BUFFER
				"it has been renamed to :RESTORE-INPUT-BUFFER")

(COMPILE-FLAVOR-METHODS INTERACTIVE-STREAM)
