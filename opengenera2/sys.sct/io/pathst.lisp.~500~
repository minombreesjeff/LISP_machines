;;; -*- Mode: LISP; Syntax: Zetalisp; Package: FILE-SYSTEM; Base: 8 -*-

;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

(DEFINE-PATHNAME-KEY-METHODS (NETI:PATHNAME-HOST-MIXIN PATHNAME)
  (GP-DEVICE)
  (GP-DIRECTORY)
  (GP-NAME)
  (GP-TYPE)
  (GP-VERSION))

;;; Case support

(DEFWHOPPER (:CASE-COMPONENT CASE-MIXIN) (COMPONENT)
  (IF (STRINGP COMPONENT)
      (CONTINUE-WHOPPER COMPONENT)
    COMPONENT))

(DEFWHOPPER (:UNCASE-COMPONENT CASE-MIXIN) (COMPONENT)
  (IF (STRINGP COMPONENT)
      (CONTINUE-WHOPPER COMPONENT)
    COMPONENT))

(DEFMETHOD (:CASE-DEVICE CASE-MIXIN :DEFAULT) (COMPONENT)
  (SEND SELF ':CASE-COMPONENT COMPONENT))

(DEFMETHOD (:CASE-DIRECTORY CASE-MIXIN :DEFAULT) (COMPONENT)
  (IF (STRINGP COMPONENT)
      (LIST (SEND SELF ':CASE-COMPONENT COMPONENT))
    COMPONENT))


(DEFMETHOD (:CASE-DIRECTORY HIERARCHICAL-DIRECTORY-MIXIN) (COMPONENT-LIST)
  (COND ((STRINGP COMPONENT-LIST) (LIST (SEND SELF ':CASE-COMPONENT COMPONENT-LIST)))
	((ATOM COMPONENT-LIST)
	 (SEND SELF ':CASE-COMPONENT COMPONENT-LIST))
	(T (LET ((RESULT (MAKE-LIST (LENGTH COMPONENT-LIST))))
	     (DO ((C COMPONENT-LIST (CDR C))
		  (R RESULT (CDR R)))
		 ((NULL C) RESULT)
	       (SETF (CAR R)
		     (SEND SELF ':CASE-COMPONENT (CAR C))))))))

(DEFMETHOD (:CASE-NAME CASE-MIXIN :DEFAULT) (COMPONENT)
  (SEND SELF ':CASE-COMPONENT COMPONENT))

(DEFMETHOD (:CASE-TYPE CASE-MIXIN :DEFAULT) (COMPONENT)
  (SEND SELF ':CASE-COMPONENT COMPONENT))

(DEFMETHOD (:UNCASE-DEVICE CASE-MIXIN :DEFAULT) (COMPONENT)
  (SEND SELF ':UNCASE-COMPONENT COMPONENT))

(DEFMETHOD (:UNCASE-DIRECTORY CASE-MIXIN :DEFAULT) (COMPONENT-LIST)
  (SEND SELF ':UNCASE-COMPONENT (IF (ATOM COMPONENT-LIST)
				    (SELECTQ COMPONENT-LIST
				      (:ROOT COMPONENT-LIST)
				      (OTHERWISE (LIST COMPONENT-LIST)))
				  (LAST COMPONENT-LIST))))

(DEFMETHOD (:UNCASE-DIRECTORY HIERARCHICAL-DIRECTORY-NO-PATCH-MIXIN) (COMPONENT-LIST)
  (IF (ATOM COMPONENT-LIST)
      (IF (STRINGP COMPONENT-LIST)
	  (LIST (SEND SELF ':UNCASE-COMPONENT COMPONENT-LIST))	;Bleh.
	  COMPONENT-LIST)
    (LET ((RESULT (MAKE-LIST (LENGTH COMPONENT-LIST))))
      (DO ((C COMPONENT-LIST (CDR C))
	   (R RESULT (CDR R)))
	  ((NULL C) RESULT)
	(SETF (CAR R)
	      (SEND SELF ':UNCASE-COMPONENT (CAR C)))))))

(DEFMETHOD (:UNCASE-NAME CASE-MIXIN :DEFAULT) (COMPONENT)
  (SEND SELF ':UNCASE-COMPONENT COMPONENT))

(DEFMETHOD (:UNCASE-TYPE CASE-MIXIN :DEFAULT) (COMPONENT)
  (SEND SELF ':UNCASE-COMPONENT COMPONENT))

(DEFMETHOD (:CASE-COMPONENT CASE-MIXIN :DEFAULT) (COMPONENT)
  COMPONENT)

(DEFMETHOD (:UNCASE-COMPONENT CASE-MIXIN :DEFAULT) (COMPONENT)
  COMPONENT)

(DEFFLAVOR CASE-PATHNAME-MIXIN
	((CASE-DEVICE NIL)
	 (CASE-DIRECTORY NIL)
	 (CASE-NAME NIL)
	 (CASE-TYPE NIL)
	 )
	(CASE-MIXIN)
  (:REQUIRED-INSTANCE-VARIABLES DEVICE DIRECTORY NAME TYPE))

(DEFMETHOD (:DEVICE CASE-PATHNAME-MIXIN) ()
  (OR CASE-DEVICE
      (SETQ CASE-DEVICE (SEND SELF ':CASE-DEVICE DEVICE))))

(DEFMETHOD (:DIRECTORY CASE-PATHNAME-MIXIN) ()
  (OR CASE-DIRECTORY
      (SETQ CASE-DIRECTORY (SEND SELF ':CASE-DIRECTORY DIRECTORY))))

(DEFMETHOD (:NAME CASE-PATHNAME-MIXIN) ()
  (OR CASE-NAME
      (SETQ CASE-NAME (SEND SELF ':CASE-NAME NAME))))

(DEFMETHOD (:TYPE CASE-PATHNAME-MIXIN) ()
  (OR CASE-TYPE
      (SETQ CASE-TYPE (SEND SELF ':CASE-TYPE TYPE))))

(DEFMETHOD (:RAW-DEVICE CASE-PATHNAME-MIXIN) ()
  DEVICE)

(DEFMETHOD (:RAW-DIRECTORY CASE-PATHNAME-MIXIN) ()
  DIRECTORY)

(DEFMETHOD (:RAW-NAME CASE-PATHNAME-MIXIN) ()
  NAME)

(DEFMETHOD (:RAW-TYPE CASE-PATHNAME-MIXIN) ()
  TYPE)

(DEFFLAVOR UPPER-CASE-ONLY-MIXIN ()
	   (CASE-PATHNAME-MIXIN)
  (:DOCUMENTATION "This mixin is for systems with pathnames in all upper case."))

(DEFMETHOD (:CASE-COMPONENT UPPER-CASE-ONLY-MIXIN) (COMPONENT)
  (SI:STRING-UPCASE-IF-NECESSARY COMPONENT))

(DEFMETHOD (:UNCASE-COMPONENT UPPER-CASE-ONLY-MIXIN) (COMPONENT)
  (SI:STRING-UPCASE-IF-NECESSARY COMPONENT))

(DEFFLAVOR UPPER-CASE-ONLY-UNDERSCORE-MIXIN ()
	   (CASE-PATHNAME-MIXIN)
  (:DOCUMENTATION "This mixin is for systems with pathnames in all upper case, and with
underscore instead of hyphen."))

(DEFUN STRING-UPCASE-UNDERSCORE-IF-NECESSARY (STRING)
  (LET ((STRING STRING))
    (DECLARE (SYS:ARRAY-REGISTER STRING))
    (IF (LOOP FOR I BELOW (ARRAY-ACTIVE-LENGTH STRING)
	      FOR CH = (AREF STRING I)
	      NEVER (LOWER-CASE-P CH)
	      NEVER (CHAR-EQUAL CH #\-))
	STRING
      (LET ((NEWSTRING (MAKE-ARRAY (ARRAY-ACTIVE-LENGTH STRING) :TYPE 'ART-STRING)))
	(DECLARE (SYS:ARRAY-REGISTER NEWSTRING))
	(LOOP FOR I BELOW (ARRAY-ACTIVE-LENGTH STRING)
	      FOR CHAR = (AREF STRING I)
	      FOR NEWCHAR = (CHAR-UPCASE CHAR)
	      WHEN (CHAR-EQUAL NEWCHAR #\-)
		DO (SETQ NEWCHAR #\_)
	      DO (SETF (AREF NEWSTRING I) NEWCHAR))
	NEWSTRING))))

(DEFUN STRING-UPCASE-HYPHEN-IF-NECESSARY (STRING)
  (LET ((STRING STRING))
    (DECLARE (SYS:ARRAY-REGISTER STRING))
    (IF (LOOP FOR I BELOW (ARRAY-ACTIVE-LENGTH STRING)
	      FOR CH = (AREF STRING I)
	      NEVER (LOWER-CASE-P CH)
	      NEVER (CHAR-EQUAL CH #\_))
	STRING
      (LET ((NEWSTRING (MAKE-ARRAY (ARRAY-ACTIVE-LENGTH STRING) :TYPE 'ART-STRING)))
	(DECLARE (SYS:ARRAY-REGISTER NEWSTRING))
	(LOOP FOR I BELOW (ARRAY-ACTIVE-LENGTH STRING)
	      FOR CHAR = (AREF STRING I)
	      FOR NEWCHAR = (CHAR-UPCASE CHAR)
	      WHEN (CHAR-EQUAL NEWCHAR #\_)
		DO (SETQ NEWCHAR #\-)
	      DO (SETF (AREF NEWSTRING I) NEWCHAR))
	NEWSTRING))))

(DEFMETHOD (:CASE-COMPONENT UPPER-CASE-ONLY-UNDERSCORE-MIXIN) (COMPONENT)
  (STRING-UPCASE-HYPHEN-IF-NECESSARY COMPONENT))

(DEFMETHOD (:UNCASE-COMPONENT UPPER-CASE-ONLY-UNDERSCORE-MIXIN) (COMPONENT)
  (STRING-UPCASE-UNDERSCORE-IF-NECESSARY COMPONENT))

(DEFFLAVOR UPPER-CASE-PREFERRED-MIXIN ()
	   (CASE-PATHNAME-MIXIN)
  (:DOCUMENTATION
   "This mixin is for systems with both cases, with upper case being the norm."))

(DEFMETHOD (:CASE-COMPONENT UPPER-CASE-PREFERRED-MIXIN) (COMPONENT)
  COMPONENT)

(DEFMETHOD (:UNCASE-COMPONENT UPPER-CASE-PREFERRED-MIXIN) (COMPONENT)
  COMPONENT)

(DEFFLAVOR LOWER-CASE-PREFERRED-MIXIN ()
	   (CASE-PATHNAME-MIXIN)
  (:DOCUMENTATION
   "This mixin is for systems with both cases, with lower case being the norm."))

(DEFUN STRING-INVERT-CASE (STRING)
  (COND ((LOOP WITH LEN = (ARRAY-ACTIVE-LENGTH STRING)
	       FOR I FROM 0 BELOW LEN
	       NEVER (LOWER-CASE-P (AREF STRING I)))
	 (STRING-DOWNCASE STRING))
	((LOOP WITH LEN = (ARRAY-ACTIVE-LENGTH STRING)
	       FOR I FROM 0 BELOW LEN
	       NEVER (UPPER-CASE-P (AREF STRING I)))
	 (STRING-UPCASE STRING))
	(T STRING)))

(DEFMETHOD (:CASE-COMPONENT LOWER-CASE-PREFERRED-MIXIN) (COMPONENT)
  (STRING-INVERT-CASE COMPONENT))

(DEFMETHOD (:UNCASE-COMPONENT LOWER-CASE-PREFERRED-MIXIN) (COMPONENT)
  (STRING-INVERT-CASE COMPONENT))

(DEFFLAVOR LOWER-CASE-ONLY-MIXIN ()
	   (CASE-PATHNAME-MIXIN)
  (:DOCUMENTATION "This mixin is for systems with pathnames only in lower case"))

(DEFMETHOD (:CASE-COMPONENT LOWER-CASE-ONLY-MIXIN) (COMPONENT)
  (SI:STRING-UPCASE-IF-NECESSARY COMPONENT))

(DEFMETHOD (:UNCASE-COMPONENT LOWER-CASE-ONLY-MIXIN) (COMPONENT)
  (SI:STRING-DOWNCASE-IF-NECESSARY COMPONENT))

(DEFFLAVOR BOTH-CASES-SAME-LOWER-PREFERRED-MIXIN ()
	   (LOWER-CASE-ONLY-MIXIN)
  (:DOCUMENTATION
   "This mixin is for systems which allow either case to name the same file, lower preferred"))

(DEFMETHOD (:UNCASE-COMPONENT BOTH-CASES-SAME-LOWER-PREFERRED-MIXIN) (COMPONENT)
  (STRING-INVERT-CASE COMPONENT))

(DEFFLAVOR BOTH-CASES-SAME-MIXIN ()
	   (LOWER-CASE-ONLY-MIXIN)
  (:DOCUMENTATION
   "This mixin is for systems which allow either case to name the same file."))

(DEFMETHOD (:UNCASE-COMPONENT BOTH-CASES-SAME-MIXIN) (COMPONENT)
  COMPONENT)



(DEFFLAVOR MAILBOX-PATHNAME-MIXIN () ()
  (:REQUIRED-FLAVORS PATHNAME)
  (:DOCUMENTATION :MIXIN "This mixin defines the basics of mailbox behaviour for Zmail."))

(DEFFLAVOR ITS-MAILBOX-PATHNAME-MIXIN () (MAILBOX-PATHNAME-MIXIN)
  :ABSTRACT-FLAVOR)

(DEFFLAVOR TOPS20-MAILBOX-PATHNAME-MIXIN () (MAILBOX-PATHNAME-MIXIN)
  :ABSTRACT-FLAVOR)

(DEFFLAVOR TENEX-MAILBOX-PATHNAME-MIXIN () (MAILBOX-PATHNAME-MIXIN)
  :ABSTRACT-FLAVOR)

(DEFFLAVOR VMS-MAILBOX-PATHNAME-MIXIN () (MAILBOX-PATHNAME-MIXIN)
  :ABSTRACT-FLAVOR)

(DEFFLAVOR UNIX-MAILBOX-PATHNAME-MIXIN () (MAILBOX-PATHNAME-MIXIN)
  :ABSTRACT-FLAVOR)

(DEFFLAVOR MULTICS-MAILBOX-PATHNAME-MIXIN () (MAILBOX-PATHNAME-MIXIN)
  :ABSTRACT-FLAVOR)

;;; Useless component support...

(DEFFLAVOR NO-DEVICE-MIXIN () ()
  (:REQUIRED-FLAVORS PATHNAME))

(DEFMETHOD (:VALID-DEVICE-P NO-DEVICE-MIXIN) (DEV)
  (EQ DEV ':UNSPECIFIC))

(DEFMETHOD (:VALID-DEVICE NO-DEVICE-MIXIN) (DEV)
  DEV						;Useless
  ':UNSPECIFIC)

(DEFMETHOD (MAKE-INSTANCE NO-DEVICE-MIXIN) (&REST IGNORE)
  (SETQ DEVICE ':UNSPECIFIC))

(DEFINE-PATHNAME-KEY-METHODS (NETI:NO-DEVICE-HOST-MIXIN NO-DEVICE-MIXIN) 
  (GP-DIRECTORY)
  (GP-NAME)
  (GP-TYPE)
  (GP-VERSION)) 

(DEFFLAVOR NO-DIRECTORY-MIXIN () ()
  (:REQUIRED-FLAVORS PATHNAME))

(DEFMETHOD (:VALID-DIRECTORY-P NO-DIRECTORY-MIXIN) (DIR)
  (EQ DIR ':UNSPECIFIC))

(DEFMETHOD (:VALID-DIRECTORY NO-DIRECTORY-MIXIN) (DIR)
  DIR						;Useless
  ':UNSPECIFIC)

(DEFMETHOD (MAKE-INSTANCE NO-DIRECTORY-MIXIN) (&REST IGNORE)
  (SETQ DIRECTORY ':UNSPECIFIC))


(DEFINE-PATHNAME-KEY-METHODS (NETI:NO-DIRECTORY-HOST-MIXIN NO-DIRECTORY-MIXIN)
  (GP-DEVICE)
  (GP-NAME)
  (GP-TYPE)
  (GP-VERSION)) 

(DEFFLAVOR NO-VERSION-MIXIN () ()
  (:REQUIRED-FLAVORS PATHNAME))

(DEFMETHOD (:VALID-VERSION-P NO-VERSION-MIXIN) (VRS)
  (EQ VRS ':UNSPECIFIC))

(DEFMETHOD (:VALID-VERSION NO-VERSION-MIXIN) (VRS)
  VRS						;Useless
  ':UNSPECIFIC)

(DEFMETHOD (MAKE-INSTANCE NO-VERSION-MIXIN) (&REST IGNORE)
  (SETQ VERSION ':UNSPECIFIC))

(DEFINE-PATHNAME-KEY-METHODS (NETI:NO-VERSION-HOST-MIXIN NO-VERSION-MIXIN)
  (GP-DEVICE)
  (GP-DIRECTORY)
  (GP-NAME)
  (GP-TYPE)) 

(DEFFLAVOR NO-TYPE-MIXIN () ()
  (:REQUIRED-FLAVORS PATHNAME))

(DEFMETHOD (:VALID-TYPE-P NO-TYPE-MIXIN) (TYP)
  (EQ TYP :UNSPECIFIC))

(DEFMETHOD (:VALID-TYPE NO-TYPE-MIXIN) (TYP)
  TYP
  :UNSPECIFIC)

(DEFMETHOD (MAKE-INSTANCE NO-TYPE-MIXIN) (&REST IGNORE)
  (SETQ TYPE :UNSPECIFIC))

(DEFINE-PATHNAME-KEY-METHODS (NETI:NO-TYPE-HOST-MIXIN NO-TYPE-MIXIN)
  (GP-DEVICE)
  (GP-DIRECTORY)
  (GP-NAME)
  (GP-VERSION))

(DEFFLAVOR NO-DEVICE-OR-VERSION-MIXIN () (NO-DEVICE-MIXIN NO-VERSION-MIXIN))

(DEFINE-PATHNAME-KEY-METHODS
  (NETI:NO-DEVICE-OR-VERSION-HOST-MIXIN NO-DEVICE-OR-VERSION-MIXIN)
  (GP-DIRECTORY)
  (GP-NAME)
  (GP-TYPE)) 

(DEFFLAVOR NO-DIRECTORY-OR-VERSION-MIXIN () (NO-DIRECTORY-MIXIN NO-VERSION-MIXIN))

(DEFINE-PATHNAME-KEY-METHODS
  (NETI:NO-DIRECTORY-OR-VERSION-HOST-MIXIN NO-DIRECTORY-OR-VERSION-MIXIN)
  (GP-DEVICE)
  (GP-NAME)
  (GP-TYPE)) 

(DEFFLAVOR NO-DEVICE-OR-TYPE-OR-VERSION-MIXIN ()
	   (NO-DEVICE-MIXIN NO-VERSION-MIXIN NO-TYPE-MIXIN))

(DEFINE-PATHNAME-KEY-METHODS
  (NETI:NO-DEVICE-OR-TYPE-OR-VERSION-HOST-MIXIN NO-DEVICE-OR-TYPE-OR-VERSION-MIXIN)
  (GP-DIRECTORY)
  (GP-NAME))


(DEFFLAVOR RANDOM-PATHNAME-MIXIN () (NO-DEVICE-OR-VERSION-MIXIN UPPER-CASE-PREFERRED-MIXIN)
  (:REQUIRED-FLAVORS PATHNAME))

(DEFMETHOD (MAKE-INSTANCE RANDOM-PATHNAME-MIXIN) (&REST IGNORE)
  (SETF DIRECTORY ':UNSPECIFIC)
  (SETF TYPE ':UNSPECIFIC))

(DEFINE-PATHNAME-KEY-METHODS (NETI:RANDOM-HOST-MIXIN RANDOM-PATHNAME-MIXIN)
  (GP-NAME))

(DEFMETHOD (:VALID-DIRECTORY-P RANDOM-PATHNAME-MIXIN) (DIR)
  (EQ DIR ':UNSPECIFIC))

(DEFMETHOD (:VALID-DIRECTORY RANDOM-PATHNAME-MIXIN) (DIR)
  DIR
  ':UNSPECIFIC)

(DEFMETHOD (:VALID-TYPE-P RANDOM-PATHNAME-MIXIN) (TYP)
  (EQ TYP ':UNSPECIFIC))

(DEFMETHOD (:VALID-TYPE RANDOM-PATHNAME-MIXIN) (TYP)
  TYP
  ':UNSPECIFIC)

(DEFMETHOD (:PARSE-NAMESTRING RANDOM-PATHNAME-MIXIN)
	   (HOST-SPECIFIED NAMESTRING &OPTIONAL (START 0) END)
  HOST-SPECIFIED
  (UNLESS END (SETF END (STRING-LENGTH NAMESTRING)))
  (SETQ START (OR (STRING-SEARCH-NOT-CHAR #\SPACE NAMESTRING START END)
		  END))
  (VALUES :UNSPECIFIC :UNSPECIFIC (SUBSTRING NAMESTRING START END) :UNSPECIFIC :UNSPECIFIC))

(DEFMETHOD (:STRING-FOR-EDITOR RANDOM-PATHNAME-MIXIN) ()
  (FORMAT NIL "~A ~A:" NAME (SEND HOST :NAME-AS-FILE-COMPUTER)))

(DEFMETHOD (:STRING-FOR-HOST RANDOM-PATHNAME-MIXIN) (&OPTIONAL IGNORE)
  NAME)

(DEFMETHOD (:STRING-FOR-DIRED RANDOM-PATHNAME-MIXIN) ()
  NAME)

(DEFMETHOD (:STRING-FOR-DIRECTORY RANDOM-PATHNAME-MIXIN) ()
  NAME)

;;; Conversion of internal components to strings for external consumption

(DEFUN STRING-OR-WILD (PATHNAME FIELD &OPTIONAL NO-QUOTE-P)
  (COND ((NULL FIELD) "")
	((EQ FIELD ':WILD) "*")
	(NO-QUOTE-P (STRING FIELD))
	(T (QUOTE-COMPONENT-STRING PATHNAME FIELD))))

(DEFUN STRING-OR-WILD-DIRECTORY (PATHNAME DIRECTORY)
  (STRING-OR-WILD PATHNAME (IF (LISTP DIRECTORY) (FIRST DIRECTORY) DIRECTORY)))

(DEFUN QUOTE-COMPONENT-STRING (PATHNAME STRING)
  (LET ((QUOTE-CHAR (SEND PATHNAME :QUOTE-CHARACTER)))
    (UNLESS QUOTE-CHAR
      (RETURN-FROM QUOTE-COMPONENT-STRING STRING))
    (DO ((I 0 (1+ I))
	 (LENGTH (STRING-LENGTH STRING))
	 (NSTRING NIL)
	 (START 0)
	 (N-QUOTES 0))
	(( I LENGTH)
	 (COND (NSTRING
		(COPY-ARRAY-PORTION STRING START I NSTRING (+ START N-QUOTES) (+ I N-QUOTES))
		(ADJUST-ARRAY-SIZE NSTRING (+ I N-QUOTES)))
	       (T STRING)))
      (WHEN (SEND PATHNAME :CHARACTER-NEEDS-QUOTING-P (AREF STRING I))
	(UNLESS NSTRING
	  (SETQ NSTRING (MAKE-ARRAY (- (* LENGTH 2) I) :TYPE 'ART-STRING)))
	(COPY-ARRAY-PORTION STRING START I NSTRING (+ START N-QUOTES) (+ I N-QUOTES))
	(SETF (AREF NSTRING (+ I N-QUOTES)) QUOTE-CHAR)
	(SETQ START I)
	(INCF N-QUOTES)))))

;;;; ITS support
;;; An FN2 can be either a version, if it is all numbers, or a type otherwise.
;;; NAME and VERSION are either both NIL, or one is :UNSPECIFIC and the
;;; other is non-null non-:UNSPECIFIC data.

(DEFFLAVOR ITS-PATHNAME-MIXIN ()
	   (ITS-MAILBOX-PATHNAME-MIXIN UPPER-CASE-ONLY-MIXIN)
  (:REQUIRED-FLAVORS PATHNAME))

(DEFINE-PATHNAME-KEY-METHODS (NETI:HOST-ITS-MIXIN ITS-PATHNAME-MIXIN)
  (GP-DEVICE)
  (GP-DIRECTORY)
  (GP-NAME)
  (SEND (GP-HOST) ':PICK-FN2 (GP-TYPE) (GP-VERSION)))

(DEFVAR *ITS-UNINTERESTING-TYPES* '("LISP" "TEXT" "PALX" "MIDAS" NIL :UNSPECIFIC))

(DEFFLAVOR INVALID-ITS-PATHNAME-COMPONENT-COMBINATION ()
	   (INVALID-PATHNAME-COMPONENT)
  (:DEFAULT-INIT-PLIST :COMPONENT ':FN2
		       :COMPONENT-VALUE ':UNSPECIFIC
		       :COMPONENT-DESCRIPTION "second filename (type or version)"))

(DEFMETHOD (:REPORT INVALID-ITS-PATHNAME-COMPONENT-COMBINATION) (STREAM)
  (FORMAT STREAM "Attempt to make both type and version :UNSPECIFIC in ITS pathname ~A."
	  PATHNAME))

(COMPILE-FLAVOR-METHODS INVALID-ITS-PATHNAME-COMPONENT-COMBINATION)


(DEFMETHOD (:VALIDATE ITS-PATHNAME-MIXIN :AFTER) ()
  (MULTIPLE-VALUE (TYPE VERSION)
    (SEND HOST ':PICK-TYPE-AND-VERSION TYPE VERSION))
  (WHEN (EQ TYPE ':ERROR)
    (SETQ TYPE NIL VERSION NIL)
    (SIGNAL-PROCEED-CASE ((NEW-VALUE) 'INVALID-ITS-PATHNAME-COMPONENT-COMBINATION
			  ':PATHNAME SELF)
      (:NEW-COMPONENT
       (COND ((MEMQ NEW-VALUE '(NIL :WILD))
	      (SETQ TYPE NEW-VALUE
		    VERSION NEW-VALUE))
	     ((MEMQ NEW-VALUE '(:NEWEST :OLDEST))
	      (SETQ TYPE ':UNSPECIFIC
		    VERSION NEW-VALUE))
	     ((NUMBERP NEW-VALUE)
	      (SETQ TYPE ':UNSPECIFIC
		    VERSION NEW-VALUE))
	     (T (SETQ NEW-VALUE (SEND SELF ':CASE-TYPE NEW-VALUE))
		(UNLESS (MEMQ NEW-VALUE '(NIL :WILD :UNSPECIFIC))
		  (SETQ NEW-VALUE
			(SEND SELF ':UNCASE-TYPE
			      (SEND SELF ':TYPE-FOR-NEW-CANONICAL-TYPE NEW-VALUE NIL NIL))))
		(SETQ NEW-VALUE (SEND SELF ':UNCASE-TYPE NEW-VALUE))
		(SETQ TYPE NEW-VALUE
		      VERSION ':UNSPECIFIC)))
       (SETQ STRING-FOR-PRINTING NIL)
       (SETQ VC-STRING-FOR-PRINTING NIL)
       (SEND SELF ':VALIDATE)))))

(DEFWHOPPER (:NEW-DEFAULT-PATHNAME ITS-PATHNAME-MIXIN) (&REST OPTIONS)
  (CONDITION-BIND ((INVALID-ITS-PATHNAME-COMPONENT-COMBINATION 'ITS-DEFAULT-FN2-HANDLER))
    (LEXPR-CONTINUE-WHOPPER OPTIONS)))

(DEFUN ITS-DEFAULT-FN2-HANDLER (ERROR)
  (WHEN (SEND ERROR ':PROCEED-TYPE-P ':NEW-COMPONENT)
    (SEND ERROR ':PROCEED ':NEW-COMPONENT ':NEWEST)))

;; These messages are careful to cons only the actual string in PATHNAME-AREA.
;; See comment by PATHNAME-AREA.

;;; If the device is DSK, avoid printing it.
(DEFUN-IN-FLAVOR (ITS-DEVICE-STRING ITS-PATHNAME-MIXIN) (&AUX HOSTS)
  (SETQ HOSTS (SEND HOST ':NAME-AS-FILE-COMPUTER))
  (IF (OR (MEMBER DEVICE '("DSK" NIL))
	  (EQUAL DEVICE HOSTS))
      HOSTS
      (STRING-APPEND HOSTS ": " DEVICE)))

;;; If name is a list, its first component is the FN1 and second is FN2
;;; If only FN2 is present, FN1 is placeholder ""
(DEFUN-IN-FLAVOR (ITS-FN1-STRING ITS-PATHNAME-MIXIN) (&OPTIONAL NO-QUOTE-P NO-PLACEHOLDER)
  (COND	((NULL NAME)
	 (IF (OR NO-PLACEHOLDER
		 (AND (MEMQ TYPE '(NIL :UNSPECIFIC)) (MEMQ VERSION '(NIL :UNSPECIFIC))))
	     NIL
	     ""))
	((LISTP NAME)
	 (IF NO-QUOTE-P
	     (FIRST NAME)
	     (QUOTE-COMPONENT-STRING SELF (FIRST NAME))))
	(T (STRING-OR-WILD SELF NAME NO-QUOTE-P))))

(DEFUN-IN-FLAVOR (ITS-FN2-STRING ITS-PATHNAME-MIXIN) (&OPTIONAL NO-QUOTE-P)
  (COND ((AND (LISTP NAME) (CDR NAME))
	 (IF NO-QUOTE-P (CADR NAME) (QUOTE-COMPONENT-STRING SELF (CADR NAME))))
	((AND (MEMQ TYPE '(NIL :UNSPECIFIC))
	      (MEMQ VERSION '(NIL :UNSPECIFIC)))
	 NIL)
	((EQ VERSION ':OLDEST) "<")
	((OR (EQ VERSION ':UNSPECIFIC) (NOT (MEMQ TYPE '(NIL :UNSPECIFIC))))
	 (STRING-OR-WILD SELF TYPE NO-QUOTE-P))
	((EQ VERSION ':WILD) "*")
	((NOT (MEMQ VERSION '(NIL :UNSPECIFIC :NEWEST))) (FORMAT NIL "~D" VERSION))
	(T ">")))

(DEFMETHOD (:STRING-FOR-HOST ITS-PATHNAME-MIXIN) (&OPTIONAL IGNORE)
  (LET ((DIR (STRING-OR-WILD-DIRECTORY SELF DIRECTORY))
	(FN1 (ITS-FN1-STRING))
	(FN2 (ITS-FN2-STRING))
	(DEFAULT-CONS-AREA PATHNAME-AREA))
    (FORMAT NIL "~A: ~A; ~A ~A" DEVICE DIR FN1 FN2)))

(DEFMETHOD (:STRING-FOR-PRINTING ITS-PATHNAME-MIXIN) ()
  (LET ((DEV (ITS-DEVICE-STRING))
	(DIR (STRING-OR-WILD-DIRECTORY SELF DIRECTORY))
	(FN1 (ITS-FN1-STRING))
	(FN2 (ITS-FN2-STRING))
	(DEFAULT-CONS-AREA PATHNAME-AREA))
    (FORMAT NIL "~A: ~:[~A;~:[ ~]~;~2*~]~@[~A~]~@[ ~A~]"
	    DEV (NULL DIRECTORY)
	    DIR (AND (NULL NAME)
		     (MEMQ TYPE '(NIL :UNSPECIFIC))
		     (MEMQ VERSION '(NIL :UNSPECIFIC)))
	    FN1 FN2)))

(DEFMETHOD (:STRING-FOR-EDITOR ITS-PATHNAME-MIXIN) ()
  (LET ((FN1 (ITS-FN1-STRING))
	(FN2 (ITS-FN2-STRING))
	(DIR (STRING-OR-WILD-DIRECTORY SELF DIRECTORY))
	(DEFAULT-CONS-AREA PATHNAME-AREA))
    (FORMAT NIL "~A ~A ~:[~A: ~;~*~]~A; ~A:"
	    FN1 FN2
	    (OR (MEMBER DEVICE '("DSK" NIL))
		(EQUAL DEVICE (SEND HOST :NAME-AS-FILE-COMPUTER)))
	    DEVICE DIR
	    (SEND HOST :NAME-AS-FILE-COMPUTER))))

(DEFMETHOD (:STRING-FOR-DIRECTORY ITS-PATHNAME-MIXIN) ()
  (LET ((DIR (STRING-OR-WILD-DIRECTORY SELF DIRECTORY))
	(DEFAULT-CONS-AREA PATHNAME-AREA))
    (FORMAT NIL "~:[~A: ~;~*~]~A;"
	    (MEMBER DEVICE '("DSK" NIL))
	    DEVICE DIR)))

(DEFMETHOD (:STRING-FOR-DIRED ITS-PATHNAME-MIXIN) ()
  (LET ((FN1 (ITS-FN1-STRING T))
	(FN2 (ITS-FN2-STRING T))
	(DEFAULT-CONS-AREA PATHNAME-AREA))
    (FORMAT NIL "~6A ~A" FN1 FN2)))

(DEFMETHOD (:FN1 ITS-PATHNAME-MIXIN) ()
  (ITS-FN1-STRING T T))

(DEFMETHOD (:FN2 ITS-PATHNAME-MIXIN) ()
  (ITS-FN2-STRING T))

(DEFMETHOD (:PRIMARY-DEVICE ITS-PATHNAME-MIXIN) () "DSK")
(DEFMETHOD (:QUOTE-CHARACTER ITS-PATHNAME-MIXIN) () #/)

(DEFMETHOD (:CHARACTER-NEEDS-QUOTING-P ITS-PATHNAME-MIXIN) (CH)
  (MEM #'CHAR-EQUAL CH '(#/; #/: #\SP)))

(DEFMETHOD (:HOST-DELIMITER ITS-PATHNAME-MIXIN) () ": ")

;;; For most components, just upcase the string
(DEFMETHOD (:PARSE-COMPONENT-SPEC ITS-PATHNAME-MIXIN) (SPEC)
  (COND ((LISTP SPEC) (MAPCAR #'(LAMBDA (X)
				  (SEND SELF ':PARSE-COMPONENT-SPEC X))
			      SPEC))
	((STRINGP SPEC) (SIX-SIXBIT-CHARACTERS SPEC))
	(T SPEC)))

;; OK to have lists in name slot.
(DEFMETHOD (:PARSE-NAME-SPEC ITS-PATHNAME-MIXIN) (SPEC)
  (SEND SELF :PARSE-COMPONENT-SPEC SPEC))

;;; Parse an its pathname string.   and  are quoting characters.
(DEFMETHOD (:PARSE-NAMESTRING ITS-PATHNAME-MIXIN)
	   (HOST-SPECIFIED NAMESTRING &OPTIONAL (START 0) END)
  (OR END (SETQ END (STRING-LENGTH NAMESTRING)))
  (DO ((I START)
       (J START (1+ J))
       (CH) (TEM)
       (DEV (AND HOST-SPECIFIED (SEND SELF ':PRIMARY-DEVICE)))
       (DIR) (FN1) (FN1P) (FN2)
       (TYP) (VERS))
      ((> J END)
       (COND ((NULL FN2))
	     ((SETQ TEM (NUMERIC-P FN2))
	      (SETQ VERS TEM TYP ':UNSPECIFIC))
	     ((EQUAL FN2 ">")
	      (SETQ VERS ':NEWEST TYP ':UNSPECIFIC))
	     ((EQUAL FN2 "<")
	      (SETQ VERS ':OLDEST TYP ':UNSPECIFIC))
	     ((MEMQ FN2 '(NIL :UNSPECIFIC))
	      (SETQ TYP FN2 VERS ':UNSPECIFIC))
	     (T
	      (SETQ TYP FN2 VERS ':UNSPECIFIC)))
       (VALUES DEV DIR FN1 TYP VERS))
    (SETQ CH (IF (= J END) #\SP (AREF NAMESTRING J)))
    (COND ((MEM #'CHAR-EQUAL CH '(#/ #/))
	   (SETQ J (1+ J)))
	  ((MEM #'CHAR-EQUAL CH '(#/: #/; #/ #\SP #\TAB))
	   (COND (( I J)
		  (SETQ TEM (SIX-SIXBIT-CHARACTERS NAMESTRING T I J))
		  (WHEN (STRING-EQUAL TEM "*")
		    (SETQ TEM :WILD))
		  (SELECTOR CH CHAR-EQUAL
		    (#/: (SETQ DEV TEM))
		    (#/; (SETQ DIR (LIST TEM)))
		    (OTHERWISE
		     (COND (FN2)
			   (FN1P (SETQ FN2 TEM))
			   (T (SETQ FN1 TEM FN1P T)))))))
	   (IF (CHAR-EQUAL CH #/) (SETQ FN1P T))
	   (SETQ I (1+ J))))))

;;; Truncate to six characters
(DEFUN SIX-SIXBIT-CHARACTERS (STRING &OPTIONAL QUOTE-P (START 0) (END (STRING-LENGTH STRING)))
  (DO ((I START (1+ I))
       (NCH 0) (CH)
       (NEED-COPY NIL))
      ((OR ( I END) (= NCH 6))
       (COND ((AND (= START 0) (= I (STRING-LENGTH STRING)) (NOT NEED-COPY))
	      STRING)				;To avoid consing
	     ((NOT NEED-COPY)
	      (SUBSTRING STRING START I))
	     (T
	      (DO ((NSTRING (MAKE-ARRAY NCH ':TYPE 'ART-STRING))
		   (J 0)
		   (K START (1+ K))
		   (CH))
		  (( K I) NSTRING)
		(SETQ CH (AREF STRING K))
		(COND ((NOT (AND QUOTE-P (MEM #'CHAR-EQUAL CH '(#/ #/))))
		       (LET ((CHC (CHAR-CODE CH)))
			 (SETQ CHC (COND ((< CHC #O040) (+ CHC #O040))
					 ((< CHC #O140) CHC)
					 (T (- CHC #O040))))
			 (SETF (AREF NSTRING J) (CODE-CHAR CHC)))
		       (SETQ J (1+ J))))))))
    (SETQ CH (AREF STRING I))
    (IF (AND QUOTE-P (MEM #'CHAR-EQUAL CH '(#/ #/)))
	(SETQ NEED-COPY T)
	(SETQ NCH (1+ NCH)))
    (OR (AND ( (CHAR-CODE CH) #O040) ( (CHAR-CODE CH) #O137))	;Already legal SIXBIT
	(SETQ NEED-COPY T))))

;;; Return number if string is all digits, else NIL
(DEFUN NUMERIC-P (STRING &OPTIONAL PARTIAL-OK SIGN-OK LEADING-ZERO-OK)
  (AND (NEQ STRING :WILD)
       (DO ((I 0 (1+ I))
	    (LEN (STRING-LENGTH STRING))
	    (NUM NIL)
	    (SIGN 1)
	    (CH))
	   (( I LEN)
	    (AND NUM (* NUM SIGN)))
	 (SETQ CH (AREF STRING I))
	 (COND ((AND SIGN-OK
		     (ZEROP I)
		     (MEM #'CHAR-EQUAL CH '(#/+ #/- #/0)))
		(SELECTOR CH CHAR-EQUAL
		  (#/+ (SETQ SIGN 1))
		  (#/- (SETQ SIGN -1))
		  (OTHERWISE (SETQ SIGN 1))))
	       ((AND (ZEROP I) (NOT LEADING-ZERO-OK) (CHAR-EQUAL CH #/0) (> LEN 1))
		(RETURN NIL))
	       ((DIGIT-CHAR-P CH)
		(SETQ NUM (+ (DIGIT-CHAR-P CH) (IF NUM (* NUM 10.) 0))))
	       (PARTIAL-OK
		(RETURN (VALUES (AND NUM (* NUM SIGN)) I)))
	       (T (RETURN NIL))))))

(DEFMETHOD (:INIT-FILE ITS-PATHNAME-MIXIN) (PROGRAM-NAME CANONICAL-TYPE &AUX FN1 FN2)
  (COND ((EQUAL DIRECTORY USER-ID)		;Own directory => program >
	 (SETQ FN1 PROGRAM-NAME
	       FN2 CANONICAL-TYPE))
	(T					;Shared directory => user program
	 (SETQ FN1 USER-ID			; and compiled ones don't work properly
	       FN2 (COND ((MEMQ CANONICAL-TYPE '(NIL :LISP))
			  PROGRAM-NAME)
			 ((EQ CANONICAL-TYPE ':WILD)
			  CANONICAL-TYPE)
			 (T
			  (STRING-APPEND (IF (< (STRING-LENGTH PROGRAM-NAME) 6)
					     PROGRAM-NAME 
					     (SUBSTRING PROGRAM-NAME 0 5))
					 CANONICAL-TYPE))))))
  (SEND SELF ':NEW-PATHNAME ':NAME FN1
			    ':TYPE FN2
			    ':VERSION (AND FN2 ':NEWEST)))

;;; These are for things like the microcode files that need to compact both a name and a type
;;; into one pathname.
(DEFMETHOD (:NEW-TYPE-AND-VERSION ITS-PATHNAME-MIXIN) (NEW-TYPE NEW-VERSION)
  (SETQ NEW-TYPE (SEND SELF :TYPE-FOR-NEW-CANONICAL-TYPE NEW-TYPE NIL NIL))
  (SEND SELF ':NEW-PATHNAME
	     ':TYPE (SIX-SIXBIT-CHARACTERS (FORMAT NIL "~D~A" (\ NEW-VERSION 1000.) NEW-TYPE))
	     ':VERSION ':NEWEST))

(DEFMETHOD (:TYPE-AND-VERSION ITS-PATHNAME-MIXIN) (&AUX TYP VERS I)
  (COND ((STRINGP TYPE)
	 (MULTIPLE-VALUE (VERS I) (NUMERIC-P TYPE T))
	 (AND I (SETQ TYP (SUBSTRING TYPE I)))
	 (VALUES TYP VERS))
	(T (VALUES TYPE TYPE))))

;;; Patch system interface, more kludges for only six character filenames
(DEFMETHOD (:PATCH-FILE-PATHNAME ITS-PATHNAME-MIXIN) (NAM SAME-DIRECTORY-P PATOM TYP
						      &REST ARGS)
  (SELECTQ TYP
    (:SYSTEM-DIRECTORY
     (SEND SELF ':NEW-PATHNAME ':NAME (IF (EQ SAME-DIRECTORY-P :EXPLICIT) PATOM NAM)
		':CANONICAL-TYPE ':PATCH-SYSTEM-DIRECTORY ':VERSION ':NEWEST))
    (:COMPONENT-DIRECTORY
     (SEND SELF ':NEW-PATHNAME ':NAME (WITH-OUTPUT-TO-STRING (STREAM)
					(LET ((SNAME (IF (EQ SAME-DIRECTORY-P :EXPLICIT)
							 PATOM NAM)))
					  (DOTIMES (I (MIN (STRING-LENGTH SNAME) 3))
					    (FUNCALL STREAM ':TYO (AREF SNAME I))))
					(LET ((BASE 10.) (CL:*PRINT-RADIX* NIL))
					  (PRIN1 (\ (CAR ARGS) 1000.) STREAM)))
	   ':CANONICAL-TYPE ':PATCH-COMPONENT-DIRECTORY ':VERSION ':NEWEST))
    (:PATCH-DIRECTORY
     (SEND SELF ':NEW-PATHNAME ':NAME (WITH-OUTPUT-TO-STRING (STREAM)
					(LET ((SNAME (IF (EQ SAME-DIRECTORY-P :EXPLICIT)
							 PATOM NAM)))
					  (DOTIMES (I (MIN (STRING-LENGTH SNAME) 3))
					    (FUNCALL STREAM ':TYO (AREF SNAME I))))
					(LET ((BASE 10.) (CL:*PRINT-RADIX* NIL))
					  (PRIN1 (\ (CAR ARGS) 1000.) STREAM)))
	   ':CANONICAL-TYPE ':PATCH-PATCH-DIRECTORY ':VERSION ':NEWEST))
    (:VC-SOURCE-CHANGE-JOURNAL
     (SEND SELF ':NEW-PATHNAME ':NAME (WITH-OUTPUT-TO-STRING (STREAM)
					(LET ((SNAME (IF (EQ SAME-DIRECTORY-P :EXPLICIT)
							 PATOM NAM)))
					  (DOTIMES (I (MIN (STRING-LENGTH SNAME) 3))
					    (FUNCALL STREAM ':TYO (AREF SNAME I))))
					(LET ((BASE 10.) (CL:*PRINT-RADIX* NIL))
					  (PRIN1 (\ (CAR ARGS) 1000.) STREAM)))
	   ':CANONICAL-TYPE ':VC-SOURCE-CHANGE-JOURNAL ':VERSION ':NEWEST))
    (:PATCH-FILE
     (FUNCALL-SELF ':NEW-PATHNAME ':NAME (FORMAT NIL "~:[~*~;~C~]~D.~D"
						 SAME-DIRECTORY-P PATOM
						 (\ (CAR ARGS) 100.)
						 (\ (CADR ARGS)
						    (IF SAME-DIRECTORY-P 100. 1000.)))
		   ':CANONICAL-TYPE (CADDR ARGS) ':VERSION ':NEWEST))))

(DEFWHOPPER (:QUICK-VIEW-DIRECTORY ITS-PATHNAME-MIXIN) (TO-STREAM)
  (IF (AND (EQ NAME :WILD)
	   (EQ TYPE :WILD)
	   (EQ VERSION :WILD)
	   (NOT (EQUAL DIRECTORY '(:WILD)))
	   (LISTP DIRECTORY)
	   (STRINGP (FIRST DIRECTORY))
	   (NOT (STRING-SEARCH-CHAR #/* (FIRST DIRECTORY))))
      (VIEWF (SEND SELF ':NEW-PATHNAME ':NAME ".FILE." ':TYPE  "(DIR)" ':VERSION ':NEWEST)
	     TO-STREAM)
      (CONTINUE-WHOPPER TO-STREAM)))

  
(PUTPROP ':ITS '() 'ATTRIBUTES)

(DEFMETHOD (:VALID-DEVICE-P ITS-PATHNAME-MIXIN) (DEV)
  (OR (STRINGP DEV) (NULL DEV)))

(DEFMETHOD (:VALID-VERSION-P ITS-PATHNAME-MIXIN) (VRS)
  (OR (AND (FIXNUMP VRS) ( VRS 0))
      (MEMQ VRS '(NIL :WILD :UNSPECIFIC :OLDEST :NEWEST))))

(DEFMETHOD (:VALID-NAME-P ITS-PATHNAME-MIXIN) (NAM)
  (OR (AND (STRINGP NAM)
	   (> (STRING-LENGTH NAM) 0))
      (MEMQ NAM '(NIL :WILD))))

(DEFMETHOD (:VALID-TYPE-P ITS-PATHNAME-MIXIN) (TYP)
  (OR (AND (STRINGP TYP)
	   (> (STRING-LENGTH TYP) 0))
      (MEMQ TYP '(NIL :WILD :UNSPECIFIC))))

(DEFMETHOD (:HEURISTIC-PARSE-MAYBE-HOSTED-PATHNAME ITS-PATHNAME-MIXIN) (STRING)
  (IF
    (LET ((START (STRING-SEARCH-NOT-SET '(#\SP #\TAB #\RETURN) STRING))
	  (COLONX (STRING-SEARCH-CHAR #/: STRING)))
      (IF COLONX
	  (LET ((HOST-END (STRING-REVERSE-SEARCH-NOT-SET '(#\SP #\TAB #\RETURN)
							 STRING COLONX)))
	    (IF HOST-END
		;; No prizes for elegance given here.
		;; We could do a non-auto-add GET-PATHNAME-HOST, which would be
		;; no better or worse than the old system, but this is better.
		;; Doing a net:parse-host would bother the namespace server
		;; every time it encountered DSK:.
		(NOT (MEMBER (SUBSTRING STRING START  (1+ HOST-END)) '("ML" "AI" "MC" "DM")))
		NIL))
	  T))
    (SEND SELF ':PARSE-TRUENAME STRING)
    (PARSE-PATHNAME STRING NIL SELF)))

(DEFMETHOD (:HEURISTIC-PRINT-MAYBE-HOSTED-PATHNAME ITS-PATHNAME-MIXIN) (PATHNAME)
  (LET ((PHOST (SEND PATHNAME ':HOST)))
    (COND ((EQ HOST PHOST) (SEND PATHNAME ':STRING-FOR-HOST))
	  ((AND (EQ (SEND HOST ':SITE) (SEND PHOST ':SITE))
		(EQ (SEND PHOST ':SYSTEM-TYPE) ':ITS))
	   (SEND PATHNAME ':STRING-FOR-PRINTING))
	  (T (FERROR "The pathname ~A is not on a known ITS at site ~A.  It cannot be~@
		     written to an ITS Babyl file."
		     PATHNAME (SEND (SEND HOST ':SITE) ':NAME))))))

;;;  Various TENEX-family pathnames:  TOPS20, TENEX, VMS

(DEFFLAVOR TENEX-FAMILY-PATHNAME-MIXIN ()
	   (MAILBOX-PATHNAME-MIXIN UPPER-CASE-PREFERRED-MIXIN)
  (:REQUIRED-FLAVORS PATHNAME)
  (:REQUIRED-METHODS :PRIMARY-DEVICE :SUPPRESSED-DEVICE-NAMES
   :QUOTE-CHARACTER
   ;:ROOT-DIRECTORY-NAME	;only if hierarchical directories
   ))

;; These messages are careful about consing in PATHNAME-AREA
;; See comment by PATHNAME-AREA

(DEFMETHOD (:DIRECTORY-STRING TENEX-FAMILY-PATHNAME-MIXIN) ()
  (COND ((NULL DIRECTORY) NIL)
	((EQ DIRECTORY ':ROOT) (SEND SELF :ROOT-DIRECTORY-NAME))
	((NLISTP DIRECTORY) (STRING-OR-WILD SELF DIRECTORY))
	(T (WITH-OUTPUT-TO-STRING (S)
	     (LOOP FOR (COMPONENT . REST) ON DIRECTORY DO
	       (SEND S :STRING-OUT (STRING-OR-WILD SELF COMPONENT))
	       (WHEN REST
		 (SEND S :TYO #/.)))))))

;Need a harmless default for non-hierarchical file systems
(DEFMETHOD (:ROOT-DIRECTORY-NAME TENEX-FAMILY-PATHNAME-MIXIN) ()
  ':ROOT)

;;; The root is always explicitly named (as 000000 on VMS, something else
;;; explicit on TOPS-20.).
(DEFMETHOD (:ROOT-ALWAYS-EXPLICIT-P TENEX-FAMILY-PATHNAME-MIXIN) ()
  T)

(DEFUN-IN-FLAVOR (TENEX-FAMILY-VERSION-STRING TENEX-FAMILY-PATHNAME-MIXIN) (&OPTIONAL DIRECTION)
  (WHEN (AND VERSION (OR DIRECTION (NEQ VERSION :NEWEST)))
    (FORMAT NIL "~C~D"
	    (SEND SELF :VERSION-DELIMITER)
	    (SELECTQ VERSION
	      (:NEWEST (IF (EQ DIRECTION :OUTPUT) -1 0))
	      (:OLDEST -2)
	      (:WILD "*")
	      (OTHERWISE VERSION)))))

(DEFMETHOD (:STRING-FOR-HOST TENEX-FAMILY-PATHNAME-MIXIN) (&OPTIONAL DIRECTION)
  (LET ((DIR-DELIM (CAR (SEND SELF :DIRECTORY-DELIMITERS)))
	(DEV (AND DEVICE (STRING-OR-WILD SELF DEVICE)))
	(DIR (SEND SELF :DIRECTORY-STRING))
	(NAM (STRING-OR-WILD SELF NAME))
	(TYP (STRING-OR-WILD SELF TYPE))
	(VER (TENEX-FAMILY-VERSION-STRING DIRECTION))
	(DEFAULT-CONS-AREA PATHNAME-AREA))
    (FORMAT NIL "~@[~A:~]~C~A~C~:[~;~A.~:[~A~;~*~]~@[~A~]~]"
	    DEV (CAR DIR-DELIM) DIR (CDR DIR-DELIM)
	    (OR NAME TYPE VERSION) NAM (NULL TYPE) TYP VER)))

(DEFUN-IN-FLAVOR (TENEX-FAMILY-STRING-FOR-PRINTING TENEX-FAMILY-PATHNAME-MIXIN) (READABLY)
  (LET ((DIR-DELIM (CAR (SEND SELF :DIRECTORY-DELIMITERS)))
	(DEV (STRING-OR-WILD SELF DEVICE))
	(DIR (SEND SELF :DIRECTORY-STRING))
	(NAM (STRING-OR-WILD SELF NAME))
	(TYP (STRING-OR-WILD SELF TYPE))
	(VER (TENEX-FAMILY-VERSION-STRING (IF READABLY :INPUT)))
	(DEFAULT-CONS-AREA PATHNAME-AREA))
    (IF (NULL NAME) (SETQ NAM NIL))
    (IF (NULL TYPE) (SETQ TYP NIL))
    (IF (AND (NULL TYP) VERSION (CHAR= (SEND SELF :VERSION-DELIMITER) #/.))
	(SETQ TYP ""))
    (IF (MEMBER DEVICE (SEND SELF :SUPPRESSED-DEVICE-NAMES)) (SETQ DEV NIL))
    (STRING-APPEND
      (SEND HOST :NAME-AS-FILE-COMPUTER)
      ":"
      (OR DEV "")
      (IF DEV ":" "")
      (IF DIR (CAR DIR-DELIM) "")
      (OR DIR "")
      (IF DIR (CDR DIR-DELIM) "")
      (OR NAM
	  (IF (AND (EQ NAME NIL) (SEND SELF :SUPPORTS-EMPTY-NAME-P) TYP)
	      ""
	      ""))
      (IF TYP "." "")
      (OR TYP "")
      (OR VER ""))))

(DEFMETHOD (:STRING-FOR-PRINTING TENEX-FAMILY-PATHNAME-MIXIN) ()
  (TENEX-FAMILY-STRING-FOR-PRINTING NIL))

(DEFMETHOD (:STRING-FOR-READABLE-PRINTING TENEX-FAMILY-PATHNAME-MIXIN) ()
  (TENEX-FAMILY-STRING-FOR-PRINTING T))

(DEFMETHOD (:STRING-FOR-EDITOR TENEX-FAMILY-PATHNAME-MIXIN) ()
  (LET ((DIR-DELIM (CAR (SEND SELF :DIRECTORY-DELIMITERS)))
	(DEV (STRING-OR-WILD SELF DEVICE))
	(DIR (SEND SELF :DIRECTORY-STRING))
	(NAM (STRING-OR-WILD SELF NAME))
	(TYP (STRING-OR-WILD SELF TYPE))
	(VER (TENEX-FAMILY-VERSION-STRING))
	(DEFAULT-CONS-AREA PATHNAME-AREA))
    (FORMAT NIL "~A.~:[~A~;~*~]~@[~A~] ~:[~A~;~*~]:~@[~C~A~C~] ~A:"
	    NAM
	    (NULL TYPE) TYP
	    (IF (EQ VERSION :NEWEST) NIL VER)
	    (NULL DEVICE) DEV
	    (CAR DIR-DELIM) DIR (CDR DIR-DELIM)
	    (SEND HOST :NAME-AS-FILE-COMPUTER))))

(DEFMETHOD (:STRING-FOR-DIRED TENEX-FAMILY-PATHNAME-MIXIN) ()
  (LET ((NAM (STRING-OR-WILD SELF NAME))
	(TYP (STRING-OR-WILD SELF TYPE))
	(VER (TENEX-FAMILY-VERSION-STRING))
	(DEFAULT-CONS-AREA PATHNAME-AREA))
    (FORMAT NIL "~:[~A~;~*~].~:[~A~;~*~]~@[~A~]"
	    (NULL NAME) NAM
	    (NULL TYPE) TYP
	    VER)))

(DEFMETHOD (:STRING-FOR-DIRECTORY TENEX-FAMILY-PATHNAME-MIXIN) ()
  (LET ((DIR-DELIM (CAR (SEND SELF :DIRECTORY-DELIMITERS)))
	(DEV (STRING-OR-WILD SELF DEVICE))
	(DIR (SEND SELF :DIRECTORY-STRING)))
    (FORMAT NIL "~:[~A:~;~*~]~@[~C~A~C~]"
	  (MEMBER DEVICE (SEND SELF :SUPPRESSED-DEVICE-NAMES)) DEV
	  (CAR DIR-DELIM) DIR (CDR DIR-DELIM))))

(DEFMETHOD (:VERSION-DELIMITER TENEX-FAMILY-PATHNAME-MIXIN) () #/.)
(DEFMETHOD (:DIRECTORY-DELIMITERS TENEX-FAMILY-PATHNAME-MIXIN) () '((#/< . #/>)))
(DEFMETHOD (:SUBDIRECTORY-DELIMITER TENEX-FAMILY-PATHNAME-MIXIN) () #/.)
(DEFMETHOD (:SUPPORTS-EMPTY-NAME-P TENEX-FAMILY-PATHNAME-MIXIN) () NIL)

(DEFMETHOD (:PARSE-COMPONENT-SPEC TENEX-FAMILY-PATHNAME-MIXIN) (SPEC)
  (COND ((LISTP SPEC) (MAPCAR #'(LAMBDA (X)
				  (FUNCALL-SELF ':PARSE-COMPONENT-SPEC X))
			      SPEC))
	((STRINGP SPEC) (TENEX-FAMILY-STRING-UNTIL-DELIM SPEC NIL 0 NIL T NIL
							 (SEND SELF ':QUOTE-CHARACTER)))
	(T SPEC)))  

;(DEFMETHOD (TENEX-FAMILY-PATHNAME-MIXIN :PARSE-STRUCTURED-DIRECTORY-SPEC)
;	   PATHNAME-PASS-THROUGH-SPEC)

;;; If spec has dots in it, then the directory is structured.
(DEFMETHOD (:PARSE-DIRECTORY-SPEC TENEX-FAMILY-PATHNAME-MIXIN) (SPEC)
  (IF (STRINGP SPEC)
      (LOOP WITH IDX = 0
	    WITH (DIR TEM DELIM)
	    WITH QUOTE-CHAR = (SEND SELF :QUOTE-CHARACTER)
	    DO
	(MULTIPLE-VALUE (TEM IDX DELIM)
	  (TENEX-FAMILY-STRING-UNTIL-DELIM SPEC '(#/.) IDX NIL T NIL QUOTE-CHAR))
	(SETQ DIR (IF (AND (MINUSP DELIM) (NULL DIR))
		      TEM
		    (NCONC DIR (NCONS TEM))))
	(WHEN (MINUSP DELIM)
	  (RETURN (SEND SELF :FIXUP-DIRECTORY-SPEC DIR))))
    (SEND SELF :FIXUP-DIRECTORY-SPEC SPEC)))

(DEFMETHOD (:FIXUP-DIRECTORY-SPEC TENEX-FAMILY-PATHNAME-MIXIN) (DIR)
  (COND ((EQUAL DIR "*") '(:WILD))
	((STRINGP DIR)
	 (IF (EQUAL DIR (SEND SELF :ROOT-DIRECTORY-NAME))
	     :ROOT
	   (LIST DIR)))
	((SYMBOLP DIR) DIR)
	(T (IF (AND (NULL (CDR DIR))
		    (EQUAL (CAR DIR) (SEND SELF :ROOT-DIRECTORY-NAME)))
	       :ROOT
	     (LOOP FOR PIECE IN DIR
		   IF (EQUAL PIECE "*")
		     COLLECT :WILD
		   ELSE COLLECT PIECE)))))
  
;;; Parse a TENEX-family pathname string.
(DEFMETHOD (:PARSE-NAMESTRING TENEX-FAMILY-PATHNAME-MIXIN)
	   (HOST-SPECIFIED NAMESTRING &OPTIONAL (START 0) END
				      &AUX (QUOTE-CHAR (SEND SELF ':QUOTE-CHARACTER)))
  (OR END (SETQ END (STRING-LENGTH NAMESTRING)))
  (LET* ((DIR-DELIM-ALIST (FUNCALL-SELF ':DIRECTORY-DELIMITERS))
	 (SUBDIR-DELIM (FUNCALL-SELF ':SUBDIRECTORY-DELIMITER))
	 (ALL-DELIMS (CONS (SEND SELF ':VERSION-DELIMITER)
			   (NCONC (MAPCAR #'CAR DIR-DELIM-ALIST) '(#/: #/. #/; #\SP)))))
    (DO ((IDX (OR (STRING-SEARCH-NOT-CHAR #\SP NAMESTRING START END) END))
	 (TEM) (TEM1) (DELIM)
	 (DIR-DELIM)
	 (DEV)
	 (DIR) (NAM) (TYP) (VERS)
	 (TYPE-BEGUN) (NAME-SUPPLIED-P) (TYPE-SUPPLIED-P)
	 (FOUND-SEMI))
	(( IDX END)
	 (IF (AND TYPE-BEGUN (NOT TYPE-SUPPLIED-P))
	     (SETQ TYP ""))			; "foo." should have "" type.
	 (WHEN (EQUAL NAM "*") (SETQ NAM ':WILD))
	 (WHEN (EQUAL TYP "*") (SETQ TYP ':WILD))
	 (WHEN (AND FOUND-SEMI (NULL VERS))
	   (SETQ VERS :NEWEST))
	 (VALUES (OR DEV (AND HOST-SPECIFIED (FUNCALL-SELF ':PRIMARY-DEVICE)))
		 (SEND SELF ':FIXUP-DIRECTORY-SPEC DIR) NAM TYP VERS))
      (COND ((SETQ DIR-DELIM (CDR (ASSOC (AREF NAMESTRING IDX) DIR-DELIM-ALIST)))
	     (AND DIR
		  (PARSE-PATHNAME-ERROR "Directory occurs twice in ~A" NAMESTRING))
	     (SETQ IDX (1+ IDX))
	     (IF (CHAR= SUBDIR-DELIM DIR-DELIM)
		 (LET ((NIDX (STRING-REVERSE-SEARCH-CHAR SUBDIR-DELIM NAMESTRING END IDX)))
		   (UNLESS NIDX
		     (PARSE-PATHNAME-ERROR "Directory not delimited"))
		   (SETQ DIR (SUBSTRING NAMESTRING IDX NIDX)
			 IDX (1+ NIDX)))
		 (DO () (NIL)
		   (MULTIPLE-VALUE (TEM IDX DELIM)
		     (TENEX-FAMILY-STRING-UNTIL-DELIM NAMESTRING (LIST SUBDIR-DELIM DIR-DELIM)
						      IDX END
						      NIL NIL QUOTE-CHAR))
		   (WHEN (STRING-EQUAL TEM "")
		     (SETQ TEM NIL))
		   (SETQ DIR (NCONC DIR (NCONS TEM)))
		   (AND (CHAR-EQUAL DELIM DIR-DELIM) (RETURN)))))
	    (T
	     (MULTIPLE-VALUE (TEM IDX DELIM)
	       (TENEX-FAMILY-STRING-UNTIL-DELIM NAMESTRING ALL-DELIMS IDX END T T QUOTE-CHAR))
	     (COND ((ASS #'EQUAL DELIM DIR-DELIM-ALIST)	;all these tests have be on EQUAL 
		    (SETQ IDX (1- IDX)))	; because of ugly mixed chars and -1's
		   ((AND (EQUAL DELIM #/;) VERS)	;Attribute like protection
		    (SETQ IDX END)))
	     (WHEN (EQUAL DELIM #/;)
	       (SETQ FOUND-SEMI T))
	     (COND ((EQUAL DELIM #/:)
		    (AND DEV
			 (PARSE-PATHNAME-ERROR "Device occurs twice in ~A" NAMESTRING))
		    (SETQ DEV TEM))
		   ((NOT NAME-SUPPLIED-P)
		    (SETQ NAME-SUPPLIED-P T)
		    (IF (EQUAL DELIM #/.) (SETQ TYPE-BEGUN T))
		    ; ".foo" should have NIL name on TOPS-20 but "" name on VMS.
		    (IF (NOT (OR (AND (EQUAL TEM "")
				      (NOT (SEND SELF ':SUPPORTS-EMPTY-NAME-P)))
				 (EQUAL TEM "")))
			(SETQ NAM TEM))
		    ;; ";23" should have NIL type and version on all systems.
		    (WHEN (EQUAL DELIM #/;)
		      (SETQ TYPE-SUPPLIED-P T)
		      (IF (EQUAL TEM "") (SETQ NAM NIL))))
		   ((NOT TYPE-SUPPLIED-P)	; "..23" should have NIL version
		    (SETQ TYPE-SUPPLIED-P T)
		    (SETQ TYP (IF (EQUAL TEM "") NIL TEM)))
		   ((NULL VERS)
		    (COND ((AND (SETQ TEM1 (NUMERIC-P TEM)) (PLUSP TEM1))
			   (SETQ VERS TEM1))
			  ((STRING-EQUAL TEM "*")
			   (SETQ VERS ':WILD))
			  ((SETQ TEM1 (SEND SELF ':SPECIAL-VERSION TEM))
			   (SETQ VERS TEM1))
			  (T (PARSE-PATHNAME-ERROR
			       "Version must be numeric in ~A" NAMESTRING))))))))))

;;; Internal parsing function, read the next atom from string to one of delims
;;; EOS-OK means it is alright to fall off the end of the string, that is treated
;;; as a delimiter and -1 is returned for the third value.
(DEFUN TENEX-FAMILY-STRING-UNTIL-DELIM (STRING DELIMS &OPTIONAL (START 0) END EOS-OK QUOTE-P
					QUOTE-CHAR &AUX IDX DELIM (NCH 0) (NEED-COPY NIL))
  (DECLARE (VALUES SUBSTRING END DELIM))
  (OR END (SETQ END (STRING-LENGTH STRING)))
  (DO ((I START (1+ I))
       (CHAR))
      (( I END)
       (OR EOS-OK (PARSE-PATHNAME-ERROR "Illegal end of string in ~A" STRING))
       (SETQ IDX END DELIM -1))
    (SETQ CHAR (AREF STRING I))
    (COND ((AND QUOTE-P QUOTE-CHAR (CHAR-EQUAL CHAR QUOTE-CHAR))
	   ;; TOPS-20 quoting character
	   (AND ( (SETQ I (1+ I)) END)
		(PARSE-PATHNAME-ERROR
		  "End of string after quote character in ~A" STRING))
	   (SETQ NEED-COPY T
		 NCH (1+ NCH)))
	  ((MEMQ CHAR DELIMS)
	   (SETQ IDX I DELIM CHAR)
	   (RETURN))
	  (T
	   (SETQ NCH (1+ NCH))
	   (AND (LOWER-CASE-P CHAR)
		(SETQ NEED-COPY T)))))
  (VALUES (COND ((AND (= START 0) (= IDX (STRING-LENGTH STRING)) (NOT NEED-COPY))
		 STRING)			;Avoid consing
		((NOT NEED-COPY)
		 (SUBSTRING STRING START IDX))
		(T
		 (DO ((SUBSTRING (MAKE-ARRAY NCH ':TYPE 'ART-STRING))
		      (I 0)
		      (J START (1+ J))
		      (QUOTE-P NIL)
		      (CHAR))
		     (( J IDX)
		      SUBSTRING)
		   (SETQ CHAR (AREF STRING J))
		   (IF (AND (NOT QUOTE-P) QUOTE-CHAR (CHAR-EQUAL CHAR QUOTE-CHAR))
		       (SETQ QUOTE-P T)
		       (IF QUOTE-P
			   (SETQ QUOTE-P NIL)
			   (SETQ CHAR (CHAR-UPCASE CHAR)))
		       (SETF (AREF SUBSTRING I) CHAR)
		       (SETQ I (1+ I))))))
	  (1+ IDX) DELIM))

(DEFMETHOD (:DIRECTORY-FILE-TYPE TENEX-FAMILY-PATHNAME-MIXIN) ()
  "DIRECTORY")

(DEFUN DEFAULT-DIRECTORY-PATHNAME-AS-FILE (PATHNAME DIRECTORY &AUX DIR NAM)
  (COND ((EQ DIRECTORY ':ROOT)
	 (PARSE-PATHNAME-ERROR "There is no pathname for the root as a file"))
	((OR (ATOM DIRECTORY) (NULL (CDR DIRECTORY)))
	 (SETQ DIR ':ROOT
	       NAM (IF (LISTP DIRECTORY) (CAR DIRECTORY) DIRECTORY)))
	(T
	 (LET ((LAST (LAST DIRECTORY)))
	   (SETQ DIR (LDIFF DIRECTORY LAST)
		 NAM (CAR LAST)))))
  (SEND PATHNAME :NEW-PATHNAME :RAW-DIRECTORY DIR :RAW-NAME NAM
			       :TYPE (SEND PATHNAME :DIRECTORY-FILE-TYPE)))

(DEFMETHOD (:DIRECTORY-PATHNAME-AS-FILE TENEX-FAMILY-PATHNAME-MIXIN) ()
  (IF (EQ DIRECTORY ':ROOT)
      (SEND SELF :NEW-PATHNAME :RAW-DIRECTORY ':ROOT
			       :RAW-NAME (SEND SELF :ROOT-DIRECTORY-NAME)
			       :TYPE (SEND SELF :DIRECTORY-FILE-TYPE)
			       :VERSION 1)
      (DEFAULT-DIRECTORY-PATHNAME-AS-FILE SELF DIRECTORY)))

(DEFMETHOD (:PATHNAME-AS-DIRECTORY TENEX-FAMILY-PATHNAME-MIXIN) ()
  (SEND SELF :NEW-PATHNAME
	:RAW-DIRECTORY (COND ((OR (EQ DIRECTORY :ROOT)
				  (EQUAL DIRECTORY (LIST (SEND SELF :ROOT-DIRECTORY-NAME))))
			      (IF (EQUAL NAME (SEND SELF :ROOT-DIRECTORY-NAME))
				  :ROOT
				  (LIST NAME)))
			     ((LISTP DIRECTORY) (APPEND DIRECTORY (LIST NAME)))
			     (T (FERROR "Cannot get pathname as directory.")))
	:RAW-NAME NIL
	:RAW-TYPE NIL
	:VERSION NIL))

(DEFMETHOD (:VALID-DEVICE-P TENEX-FAMILY-PATHNAME-MIXIN) (DEV)
  (OR (STRINGP DEV) (NULL DEV) (MEMBER DEV (SEND SELF :SUPPRESSED-DEVICE-NAMES))))

;;;; TOPS-20 support
(DEFFLAVOR TOPS20-PATHNAME-MIXIN ()
	   (TOPS20-MAILBOX-PATHNAME-MIXIN HIERARCHICAL-DIRECTORY-MIXIN
	    TENEX-FAMILY-PATHNAME-MIXIN)
  (:REQUIRED-FLAVORS PATHNAME))

(DEFMETHOD (:PRIMARY-DEVICE TOPS20-PATHNAME-MIXIN) () "PS")

(DEFMETHOD (:SUPPRESSED-DEVICE-NAMES TOPS20-PATHNAME-MIXIN) () '(NIL))

(DEFMETHOD (:QUOTE-CHARACTER TOPS20-PATHNAME-MIXIN) () #/)

(DEFMETHOD (:CHARACTER-NEEDS-QUOTING-P TOPS20-PATHNAME-MIXIN) (CH)
  (NOT (OR (UPPER-CASE-P CH)
	   (DIGIT-CHAR-P CH)
	   (MEM #'CHAR-EQUAL CH '(#/# #/$ #/_ #/-))
	   ;;This isn't exactly right
	   (MEM #'CHAR-EQUAL CH '(#/% #/*)))))

(DEFMETHOD (:SPECIAL-VERSION TOPS20-PATHNAME-MIXIN) (STRING)
  (COND ((STRING-EQUAL STRING "0") ':NEWEST)
	((STRING-EQUAL STRING "-2") ':OLDEST)
	((STRING-EQUAL STRING "-3") ':WILD)
	(T NIL)))

(DEFMETHOD (:ROOT-DIRECTORY-NAME TOPS20-PATHNAME-MIXIN) ()
  "ROOT-DIRECTORY")

(DEFMETHOD (:DIRECTORY-DELIMITERS TOPS20-PATHNAME-MIXIN) ()
  '((#/< . #/>) (#/[ . #/])))

(PUTPROP ':TOPS-20 '(:UNDELETE) 'ATTRIBUTES)

;;;; Tenex support
(DEFFLAVOR TENEX-PATHNAME-MIXIN ()
	   (TENEX-MAILBOX-PATHNAME-MIXIN TENEX-FAMILY-PATHNAME-MIXIN))

(DEFMETHOD (:VERSION-DELIMITER TENEX-PATHNAME-MIXIN) () #/;)

(DEFMETHOD (:PRIMARY-DEVICE TENEX-PATHNAME-MIXIN) () "DSK")
(DEFMETHOD (:SUPPRESSED-DEVICE-NAMES TENEX-PATHNAME-MIXIN) () '(NIL "DSK"))

(DEFMETHOD (:CHARACTER-NEEDS-QUOTING-P TENEX-PATHNAME-MIXIN) (CH)
  (NOT (OR (UPPER-CASE-P CH)
	   (DIGIT-CHAR-P CH)
	   (MEM #'CHAR-EQUAL CH
		'(#/! #/" #/# #/$ #/% #/& #/' #/( #/) #/* #/+ #/, #/- #/. #// #/=
		  #/[ #/\ #/] #/^)))))

(DEFMETHOD (:SPECIAL-VERSION TENEX-PATHNAME-MIXIN) (STRING)
  (COND ((STRING-EQUAL STRING "0") ':NEWEST)
	((STRING-EQUAL STRING "-2") ':OLDEST)
	((STRING-EQUAL STRING "-3") ':WILD)
	(T NIL)))

(DEFMETHOD (:QUOTE-CHARACTER TENEX-PATHNAME-MIXIN) ()
  #/)

(DEFMETHOD (:DIRECTORY-PATHNAME-AS-FILE TENEX-PATHNAME-MIXIN) ()
  (FERROR "Tenex directories cannot be accessed as files."))

(PUTPROP ':TENEX '(:UNDELETE) 'ATTRIBUTES)


;;;; VMS support
(DEFFLAVOR VMS-PATHNAME-MIXIN () (VMS-MAILBOX-PATHNAME-MIXIN UPPER-CASE-ONLY-MIXIN
				  MEANINGFUL-ROOT-MIXIN HIERARCHICAL-DIRECTORY-MIXIN
				  TENEX-FAMILY-PATHNAME-MIXIN)
  (:REQUIRED-FLAVORS PATHNAME))

(DEFFLAVOR VMS3-PATHNAME-MIXIN () ()
  (:REQUIRED-FLAVORS VMS-PATHNAME-MIXIN))

(DEFFLAVOR VMS4-PATHNAME-MIXIN () (UPPER-CASE-ONLY-UNDERSCORE-MIXIN)
  (:REQUIRED-FLAVORS VMS-PATHNAME-MIXIN))

(DEFFLAVOR VMS4.4-PATHNAME-MIXIN () (UPPER-CASE-ONLY-MIXIN)
  (:REQUIRED-FLAVORS VMS-PATHNAME-MIXIN))

(DEFPROP DEFINE-VMS-PARAMETER "VMS Version Parameter" SI:DEFINITION-TYPE-NAME)

;;; This produces DEFCONST's for the parameters, rather than making them
;;; constants in the DEFMETHOD, to make it easier to modify them in the field,
;;; in the event of DEC changing things around.
(DEFMACRO DEFINE-VMS-PARAMETER (NAME VMS3 &OPTIONAL (VMS4 VMS3) (VMS4.4 VMS4))
  (LET ((V3NAME (INTERN (STRING-APPEND "VMS-" NAME) "FS"))
	(V4NAME (INTERN (STRING-APPEND "VMS4-" NAME) "FS"))
	(V4.4NAME (INTERN (STRING-APPEND "VMS4.4-" NAME) "FS"))
	(MNAME (INTERN (STRING NAME) PKG-KEYWORD-PACKAGE)))
    `(LOCAL-DECLARE ((SYS:FUNCTION-PARENT ,NAME DEFINE-VMS-PARAMETER))
       (RECORD-SOURCE-FILE-NAME ',NAME 'DEFINE-VMS-PARAMETER NIL)
       (DEFCONST ,V3NAME ',VMS3)
       (DEFCONST ,V4NAME ',VMS4)
       (DEFCONST ,V4.4NAME ',VMS4.4)
       (DEFMETHOD (,MNAME VMS3-PATHNAME-MIXIN) () ,V3NAME)
       (DEFMETHOD (,MNAME VMS4-PATHNAME-MIXIN) () ,V4NAME)
       (DEFMETHOD (,MNAME VMS4.4-PATHNAME-MIXIN) () ,V4.4NAME))))

(DEFMETHOD (:VERSION-DELIMITER VMS-PATHNAME-MIXIN) () #/;)

(DEFINE-VMS-PARAMETER PRIMARY-DEVICE "SYS$DISK")
(DEFMETHOD (:SUPPRESSED-DEVICE-NAMES VMS-PATHNAME-MIXIN) () '(NIL))

(DEFINE-VMS-PARAMETER ROOT-DIRECTORY-NAME "000000")

;;; Let the TOPS-20 parser do the work.  Then take the
;;; result, check it against the more limited VMS constraints, and
;;; parse the directory spec.

(DEFMETHOD (:FIXUP-DIRECTORY-SPEC VMS-PATHNAME-MIXIN) (DIR)
  (COND ((VMS-ROOT-P DIR) ':ROOT)
	((EQUAL DIR "*") ':WILD)
	((ATOM DIR) DIR)
	((EQUAL (CAR DIR) "000000")
	 (IF (NULL (CDR DIR))
	     :ROOT
	   (SEND SELF ':FIXUP-DIRECTORY-SPEC (CDR DIR))))
	(T (WHEN (STRING-EQUAL (CAR DIR) "")
	     (SETF (CAR DIR) ':RELATIVE))
	   (LOOP FOR OLD-2 = NIL THEN OLD-1
		 FOR OLD-1 = NIL THEN COMPL
		 FOR COMPL ON DIR
		 FOR COMP IN DIR
		 WITH RELATIVE-P
		 WHEN (EQUAL COMP "*")
		   DO (SETF (CAR COMPL) ':WILD)
		 WHEN (AND (NOT (NULL COMP))
			   (EQUAL (CAR OLD-1) "")
			   (EQUAL (CAR OLD-2) ""))
		   DO (SETF (CAR OLD-2) ':WILD-INFERIORS)
		      (SETF (CDR OLD-2) (IF (EQUAL COMP "")
					    (CDR COMPL)
					    COMPL))
		 WHEN (EQUAL COMP "-")
		   DO (SETQ RELATIVE-P T)
		      (SETF (CAR COMPL) ':UP)
		 FINALLY (WHEN (AND RELATIVE-P (NEQ (CAR DIR) ':RELATIVE))
			   (SETQ DIR (CONS ':RELATIVE DIR)))
			 (RETURN DIR)))))

(DEFUN VMS-ROOT-P (DIR)
  (COND ((EQ DIR ':ROOT) T)
	((AND DIR (NLISTP DIR))
	 (LET ((COMMA (STRING-SEARCH-CHAR #/, DIR)))
	   (IF COMMA (SETQ DIR (STRING-APPEND (SUBSTRING DIR 0 (1- COMMA))
					      (SUBSTRING DIR (1+ COMMA))))))
	 (LET ((TEMP (NUMERIC-P DIR T NIL T)))
	   (IF TEMP (ZEROP TEMP))))
	(T NIL)))

(DEFMETHOD (:DIRECTORY-STRING VMS-PATHNAME-MIXIN) ()
  (COND ((MEMQ DIRECTORY '(NIL :UNSPECIFIC)) NIL)
	((EQ DIRECTORY ':ROOT) "000000")
	((NLISTP DIRECTORY) (STRING-OR-WILD SELF DIRECTORY))
	(T (WITH-OUTPUT-TO-STRING (STR)
	     (LOOP WITH DIR-LIST = (IF (EQ (CAR DIRECTORY) ':RELATIVE)
				       (IF (EQ (CADR DIRECTORY) ':UP)
					   (CDR DIRECTORY)
					 DIRECTORY)
				     DIRECTORY)
		   FOR FIRST-P = T THEN NIL
		   FOR COMP IN DIR-LIST
		   FOR COMPL ON DIR-LIST
		DO (SELECTQ COMP
		     (:RELATIVE)
		     (:WILD (TYO #/* STR))
		     (:WILD-INFERIORS
		      (IF FIRST-P
			  (PRINC "..." STR)
			(PRINC ".." STR)))
		     (:UP (TYO #/- STR))
		     (NIL (TYO #\ STR))
		     (OTHERWISE (PRINC COMP STR)))
		UNTIL (NULL (CDR COMPL))
		UNLESS (EQ COMP ':WILD-INFERIORS)
		  DO (TYO #/. STR))))))
					

;;; There are no quoting characters possible, sigh.
(DEFMETHOD (:QUOTE-CHARACTER VMS-PATHNAME-MIXIN) () NIL)
(DEFMETHOD (:CHARACTER-NEEDS-QUOTING-P VMS-PATHNAME-MIXIN) (IGNORE) ())
(DEFMETHOD (:DIRECTORY-DELIMITERS VMS-PATHNAME-MIXIN) ()
  '((#/[ . #/]) (#/< . #/>)))
(DEFMETHOD (:SUPPORTS-EMPTY-NAME-P VMS-PATHNAME-MIXIN) () T)

;;; The VMS3 character set is absurdly limited.  devname:<dir.dir.dir>name.typ,
;;; where devname can be alphanumerics plus $ and _, and the rest can be alphanumerics.
;;; VMS4 adds $ and _ to filenames as well.  % and * are wildcards in filenames.
;;; VMS4.4 added - as well.
(DEFINE-VMS-PARAMETER DEVNAME-CHARSET 
		      "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789$_")
(DEFINE-VMS-PARAMETER FILENAME-CHARSET
		      "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789*%"
		      "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789$_*%"
		      "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-$_*%")
(DEFINE-VMS-PARAMETER FILETYPE-CHARSET
		      "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789*%"
		      "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789$_*%"
		      "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-$_*%")

;;; Convert a standard LISPM file type name to a standard VMS file type name.

(DEFMETHOD (:DIRECTORY-FILE-TYPE VMS-PATHNAME-MIXIN) ()
  "DIR")

(DEFMETHOD (:COMPONENT-WILD-P VMS-PATHNAME-MIXIN) (COMPONENT)
  (OR (EQ COMPONENT ':WILD)
      (AND (STRINGP COMPONENT)
	   (STRING-SEARCH-SET "*%" COMPONENT))))

(DEFMETHOD (:DEVICE-WILD-P VMS-PATHNAME-MIXIN) ()
  NIL)

(DEFMETHOD (:WILD-DIRECTORY-P VMS-PATHNAME-MIXIN) (COMPONENT)
  (IF (ATOM COMPONENT)
      (SEND SELF ':COMPONENT-WILD-P COMPONENT)
      (LOOP FOR SUB-COMPONENT IN COMPONENT
	    THEREIS (OR (EQ SUB-COMPONENT ':WILD-INFERIORS)
			(SEND SELF ':COMPONENT-WILD-P SUB-COMPONENT)))))

(DEFINE-VMS-PARAMETER DEVNAME-LENGTH 64.)

(DEFMETHOD (:VALID-DEVICE-P VMS-PATHNAME-MIXIN) (DEVNAME)
  (OR (AND (STRINGP DEVNAME)
	   (NOT (STRING-SEARCH-NOT-SET (SEND SELF :DEVNAME-CHARSET) DEVNAME))
	   (< (STRING-LENGTH DEVNAME) (SEND SELF :DEVNAME-LENGTH)))
      (MEMQ DEVNAME '(NIL :WILD))))

(DEFINE-VMS-PARAMETER FILENAME-LENGTH 9. 39.)

(DEFINE-VMS-PARAMETER MAX-DIRECTORY-LEVEL 8.)

(DEFMETHOD (:VALID-DIRECTORY-COMPONENT-P VMS-PATHNAME-MIXIN) (DIRNAME LEVEL)
  (AND ( LEVEL (SEND SELF :MAX-DIRECTORY-LEVEL))
       (OR (VMS-DEFAULT-PATHNAME-COMPONENT-TEST DIRNAME
						(SEND SELF :FILENAME-CHARSET)
						(SEND SELF :FILENAME-LENGTH))
	   (EQ DIRNAME ':WILD-INFERIORS))))


(DEFMETHOD (:DIRECTORY-PATHNAME-AS-FILE VMS-PATHNAME-MIXIN) ()
  (IF (OR (EQ DIRECTORY :ROOT)
	  (EQUAL DIRECTORY (SEND SELF :ROOT-DIRECTORY-NAME)))
      (IF (EQUAL NAME (SEND SELF :ROOT-DIRECTORY-NAME))
	  (FERROR "The root has no containing directory.")
	  (SEND SELF :NEW-PATHNAME :RAW-DIRECTORY :ROOT
		:RAW-NAME (SEND SELF :ROOT-DIRECTORY-NAME)
		:RAW-TYPE (SEND SELF :DIRECTORY-FILE-TYPE) :VERSION 1))
      (IF (AND (EQ (CAR DIRECTORY) :RELATIVE)
	       (OR (= (LENGTH DIRECTORY) 1)
		   (EQ (CAR (LAST DIRECTORY)) :UP)))
	  (ferror ":directory-pathname-as-file can't be expressed for~@[ the parent of~] ~a"
		  (EQ (CAR (LAST DIRECTORY)) :UP)
		  self)
	  (SEND SELF :NEW-PATHNAME
		:RAW-DIRECTORY (IF (NULL (CDR DIRECTORY))
				   :ROOT
				   (BUTLAST DIRECTORY))
		:RAW-NAME (CAR (LAST DIRECTORY))
		:RAW-TYPE (SEND SELF :DIRECTORY-FILE-TYPE)
		:VERSION 1))))


(DEFMETHOD (:PATHNAME-AS-DIRECTORY VMS-PATHNAME-MIXIN) ()
  (SEND SELF :NEW-PATHNAME
	:RAW-DIRECTORY
	(COND ((OR (EQ DIRECTORY :ROOT)
		   (EQUAL DIRECTORY (LIST (SEND SELF :ROOT-DIRECTORY-NAME))))
	       (IF (EQUAL NAME (SEND SELF :ROOT-DIRECTORY-NAME))
		   :ROOT
		   (LIST NAME)))
	      ((LISTP DIRECTORY) (APPEND DIRECTORY (LIST NAME)))
	      (T (FERROR "Cannot get pathname as directory.")))
	:RAW-NAME NIL
	:RAW-TYPE NIL
	:VERSION NIL))


(DEFMETHOD (:VALID-NAME-P VMS-PATHNAME-MIXIN) (NAM)
  (VMS-DEFAULT-PATHNAME-COMPONENT-TEST NAM
				       (SEND SELF :FILENAME-CHARSET)
				       (SEND SELF :FILENAME-LENGTH)))

(DEFMETHOD (:VALID-NAME VMS-PATHNAME-MIXIN) (NAM)
  (IF (SEND SELF ':VALID-NAME-P NAM)
      NAM
    (VMS-DEFAULT-PATHNAME-COMPONENT NAM
				    (SEND SELF :FILENAME-CHARSET)
				    (SEND SELF :FILENAME-LENGTH))))

(DEFUN VMS-DEFAULT-PATHNAME-COMPONENT-TEST (COMPONENT CHARSET SIZE)
  (OR (MEMQ COMPONENT '(NIL :WILD))
       (AND (STRINGP COMPONENT)
	    (NOT (STRING-SEARCH-NOT-SET CHARSET COMPONENT))
	    (<= (PATHNAME-COMPONENT-MIN-LENGTH COMPONENT) SIZE))))

(DEFUN VMS-DEFAULT-PATHNAME-COMPONENT (COMPONENT CHARSET SIZE)
  (IF (NOT (STRINGP COMPONENT))
      ""
    (LOOP FOR OLD-POS = -1 THEN POS
	  FOR P = (STRING-SEARCH-NOT-SET CHARSET COMPONENT 0)
	        THEN (STRING-SEARCH-NOT-SET CHARSET COMPONENT (1+ P))
	  FOR POS = (OR P (STRING-LENGTH COMPONENT))
	  FOR STR FIRST (SUBSTRING COMPONENT (1+ OLD-POS) POS)
	          THEN (STRING-APPEND STR (SUBSTRING COMPONENT (1+ OLD-POS) POS))
	  UNTIL (NULL P)
	  UNTIL ( (STRING-LENGTH STR) SIZE)
	  FINALLY (RETURN (IF (> (STRING-LENGTH STR) SIZE)
			      (SUBSTRING STR 0 SIZE)
			    STR)))))

(DEFINE-VMS-PARAMETER FILETYPE-LENGTH 3. 39.)

(DEFMETHOD (:VALID-TYPE-P VMS-PATHNAME-MIXIN) (TYP)
  (VMS-DEFAULT-PATHNAME-COMPONENT-TEST TYP
				       (SEND SELF :FILETYPE-CHARSET)
				       (SEND SELF :FILETYPE-LENGTH)))

(DEFMETHOD (:VALID-TYPE VMS-PATHNAME-MIXIN) (TYP)
  (IF (SEND SELF ':VALID-TYPE-P TYP)
      TYP
    (IF (NOT (STRINGP TYP))
	""
      (VMS-DEFAULT-PATHNAME-COMPONENT TYP
				      (SEND SELF :FILETYPE-CHARSET)
				      (SEND SELF :FILETYPE-LENGTH)))))

(DEFMETHOD (:VALID-VERSION-P VMS-PATHNAME-MIXIN) (VERS)
  (OR (MEMQ VERS '(:WILD :NEWEST :OLDEST))
      (NULL VERS)
      (AND (FIXNUMP VERS) ( 0 VERS 65535.))))

(DEFMETHOD (:VALID-VERSION VMS-PATHNAME-MIXIN) (VERS)
  (IF (FUNCALL-SELF ':VALID-VERSION-P VERS)
      VERS
    ':NEWEST))

(DEFMETHOD (:SPECIAL-VERSION VMS-PATHNAME-MIXIN) (STRING)
  (COND ((STRING-EQUAL STRING "0") ':NEWEST)
	((OR (STRING-EQUAL STRING "-0")
	     (STRING-EQUAL STRING "-")) ':OLDEST)
	(T NIL)))

(DEFUN-IN-FLAVOR (VMS-VERSION-STRING VMS-PATHNAME-MIXIN) (&OPTIONAL DIRECTION)
  (WHEN (AND VERSION (OR DIRECTION (NEQ VERSION :NEWEST)))
    (FORMAT NIL "~C~D"
	    (SEND SELF :VERSION-DELIMITER)
	    (SELECTQ VERSION
	      (:NEWEST 0)
	      (:OLDEST "-0")
	      (:WILD "*")
	      (OTHERWISE VERSION)))))

(DEFMETHOD (:STRING-FOR-HOST VMS-PATHNAME-MIXIN) (&OPTIONAL DIRECTION)
  (LET ((DIR-DELIM (CAR (SEND SELF :DIRECTORY-DELIMITERS)))
	(DEV (AND DEVICE (STRING-OR-WILD SELF DEVICE)))
	(DIR (SEND SELF :DIRECTORY-STRING))
	(NAM (STRING-OR-WILD SELF NAME))
	(TYP (STRING-OR-WILD SELF TYPE))
	(VER (VMS-VERSION-STRING DIRECTION))
	(DEFAULT-CONS-AREA PATHNAME-AREA))
    (FORMAT NIL "~@[~A:~]~C~A~C~:[~;~A.~:[~A~;~*~]~@[~A~]~]"
	    DEV (CAR DIR-DELIM) DIR (CDR DIR-DELIM)
	    (OR NAME TYPE VERSION) NAM (NULL TYPE) TYP VER)))

(DEFUN-IN-FLAVOR (VMS-STRING-FOR-PRINTING VMS-PATHNAME-MIXIN) (READABLY)
  (LET ((DIR-DELIM (CAR (SEND SELF :DIRECTORY-DELIMITERS)))
	(DEV (STRING-OR-WILD SELF DEVICE))
	(DIR (SEND SELF :DIRECTORY-STRING))
	(NAM (STRING-OR-WILD SELF NAME))
	(TYP (STRING-OR-WILD SELF TYPE))
	(VER (VMS-VERSION-STRING (IF READABLY :INPUT)))
	(DEFAULT-CONS-AREA PATHNAME-AREA))
    (IF (NULL NAME) (SETQ NAM NIL))
    (IF (NULL TYPE) (SETQ TYP NIL))
    (IF (AND (NULL TYP) VERSION (CHAR= (SEND SELF :VERSION-DELIMITER) #/.))
	(SETQ TYP ""))
    (IF (MEMBER DEVICE (SEND SELF :SUPPRESSED-DEVICE-NAMES)) (SETQ DEV NIL))
    (STRING-APPEND
      (SEND HOST :NAME-AS-FILE-COMPUTER)
      ":"
      (OR DEV "")
      (IF DEV ":" "")
      (IF DIR (CAR DIR-DELIM) "")
      (OR DIR "")
      (IF DIR (CDR DIR-DELIM) "")
      (OR NAM
	  (IF (AND (EQ NAME NIL) (SEND SELF :SUPPORTS-EMPTY-NAME-P) TYP)
	      ""
	      ""))
      (IF TYP "." "")
      (OR TYP "")
      (OR VER ""))))

(DEFMETHOD (:STRING-FOR-PRINTING VMS-PATHNAME-MIXIN) ()
  (VMS-STRING-FOR-PRINTING NIL))

(DEFMETHOD (:STRING-FOR-READABLE-PRINTING VMS-PATHNAME-MIXIN) ()
  (VMS-STRING-FOR-PRINTING T))

(DEFMETHOD (:STRING-FOR-EDITOR VMS-PATHNAME-MIXIN) ()
  (LET ((DIR-DELIM (CAR (SEND SELF :DIRECTORY-DELIMITERS)))
	(DEV (STRING-OR-WILD SELF DEVICE))
	(DIR (SEND SELF :DIRECTORY-STRING))
	(NAM (STRING-OR-WILD SELF NAME))
	(TYP (STRING-OR-WILD SELF TYPE))
	(VER (VMS-VERSION-STRING))
	(DEFAULT-CONS-AREA PATHNAME-AREA))
    (FORMAT NIL "~A.~:[~A~;~*~]~@[~A~] ~:[~A~;~*~]:~@[~C~A~C~] ~A:"
	    NAM
	    (NULL TYPE) TYP
	    (IF (EQ VERSION :NEWEST) NIL VER)
	    (NULL DEVICE) DEV
	    (CAR DIR-DELIM) DIR (CDR DIR-DELIM)
	    (SEND HOST :NAME-AS-FILE-COMPUTER))))

(DEFMETHOD (:STRING-FOR-DIRED VMS-PATHNAME-MIXIN) ()
  (LET ((NAM (STRING-OR-WILD SELF NAME))
	(TYP (STRING-OR-WILD SELF TYPE))
	(VER (VMS-VERSION-STRING))
	(DEFAULT-CONS-AREA PATHNAME-AREA))
    (FORMAT NIL "~:[~A~;~*~].~:[~A~;~*~]~@[~A~]"
	    (NULL NAME) NAM
	    (NULL TYPE) TYP
	    VER)))

(DEFMETHOD (:STRING-FOR-DIRECTORY VMS-PATHNAME-MIXIN) ()
  (LET ((DIR-DELIM (CAR (SEND SELF :DIRECTORY-DELIMITERS)))
	(DEV (STRING-OR-WILD SELF DEVICE))
	(DIR (SEND SELF :DIRECTORY-STRING)))
    (FORMAT NIL "~:[~A:~;~*~]~@[~C~A~C~]"
	  (MEMBER DEVICE (SEND SELF :SUPPRESSED-DEVICE-NAMES)) DEV
	  (CAR DIR-DELIM) DIR (CDR DIR-DELIM))))

;Only 9 character file names and no hyphens allowed
(DEFMETHOD (:INIT-FILE VMS-PATHNAME-MIXIN) (PROGRAM-NAME CANONICAL-TYPE)
  (SEND SELF ':NEW-PATHNAME ':NAME (STRING-APPEND (IF (< (STRING-LENGTH PROGRAM-NAME) 7)
						      PROGRAM-NAME
						      (SUBSTRING PROGRAM-NAME 0 6))
						  "INI")
			    ':CANONICAL-TYPE CANONICAL-TYPE
			    ':VERSION ':NEWEST))

;;; Patch system interface, more kludges for only 9 character VMS filenames
(DEFMETHOD (:PATCH-FILE-NAME VMS-PATHNAME-MIXIN)
	   (SYSTEM-NAME SAME-DIRECTORY-P PATOM &OPTIONAL MAJOR-VERSION MINOR-VERSION)
  (COND (MINOR-VERSION (FORMAT NIL "~:[~*~;~C~]~D"
			       (EQ SAME-DIRECTORY-P :EXPLICIT) PATOM
			       (IF (NUMBERP MINOR-VERSION)
				   ;; Put an upper bound on the length of the namestring
				   (\ MINOR-VERSION (IF (EQ SAME-DIRECTORY-P :EXPLICIT)
							10000.
							100000.))
				   ;; Someone might have supplied "*" (grrr)
				   MINOR-VERSION)))
	(MAJOR-VERSION (WITH-OUTPUT-TO-STRING (STREAM)
			 (LET ((SNAME (IF (EQ SAME-DIRECTORY-P :EXPLICIT) PATOM SYSTEM-NAME)))
			   (SETQ SNAME
				 (HEURISTICATE-NAME-COMPONENT
				   SNAME
				   (- (SEND SELF :FILENAME-LENGTH) 3)
				   (SEND SELF :FILENAME-CHARSET)
				   NIL))
			   (WHEN (STRING-SEARCH (AREF SNAME (1- (STRING-LENGTH SNAME)))
						*DIGITS*)
			     (SETF (AREF SNAME (1- (STRING-LENGTH SNAME))) #\X))
			   (DOTIMES (I (MIN (STRING-LENGTH SNAME) 6))
			     (FUNCALL STREAM ':TYO (AREF SNAME I))))
			 (LET ((BASE 10.) (CL:*PRINT-RADIX* NIL))
			   (PRIN1 (\ MAJOR-VERSION 1000.) STREAM))))
	(T (IF (EQ SAME-DIRECTORY-P :EXPLICIT)
	       PATOM
	       (HEURISTICATE-NAME-COMPONENT SYSTEM-NAME
					    (SEND SELF :FILENAME-LENGTH)
					    (SEND SELF :FILENAME-CHARSET)
					    NIL)))))

#||

(DEFMETHOD (:OLD-PATCH-FILE-PATHNAME VMS-PATHNAME-MIXIN) (NAM SAME-DIRECTORY-P PATOM TYP
						      &REST ARGS)
  (SELECTQ TYP
    (:SYSTEM-DIRECTORY
     (SEND SELF :NEW-DEFAULT-PATHNAME :NAME (IF SAME-DIRECTORY-P PATOM NAM)
	   :TYPE :PATCH-SYSTEM-DIRECTORY :VERSION :NEWEST))
    (:VERSION-DIRECTORY
     (SEND SELF :NEW-DEFAULT-PATHNAME
	   :NAME (WITH-OUTPUT-TO-STRING (STREAM)
		   (LET ((SNAME (IF SAME-DIRECTORY-P PATOM (SCT:SYSTEM-PATCH-ATOM NAM))))
		     (DOTIMES (I (MIN (STRING-LENGTH SNAME) 6))
		       (FUNCALL STREAM :TYO (AREF SNAME I))))
		   (LET ((BASE 10.) (CL:*PRINT-RADIX* NIL))
		     (PRIN1 (\ (CAR ARGS) 1000.) STREAM)))
	   :CANONICAL-TYPE :PATCH-VERSION-DIRECTORY :VERSION :NEWEST))
    (:PATCH-FILE
     (SEND SELF :NEW-DEFAULT-PATHNAME :NAME (FORMAT NIL "~:[~*~;~C~]~DX~D"
						    SAME-DIRECTORY-P PATOM
						    (\ (CAR ARGS) 100.)
						    (\ (CADR ARGS)
						       (IF SAME-DIRECTORY-P 100. 1000.)))
	   :CANONICAL-TYPE (CADDR ARGS) :VERSION :NEWEST))))


||#

(DEFMETHOD (:INIT-FILE VMS4.4-PATHNAME-MIXIN) (PROGRAM-NAME CANONICAL-TYPE)
  (LET* ((SUFFIX "-INIT")
	 (MAX-LENGTH (- (SEND SELF :FILENAME-LENGTH) (STRING-LENGTH SUFFIX))))
    (SEND SELF :NEW-PATHNAME :NAME (STRING-APPEND
				     (IF ( (STRING-LENGTH PROGRAM-NAME) MAX-LENGTH)
					 PROGRAM-NAME
				       (SUBSTRING PROGRAM-NAME 0 MAX-LENGTH))
				     SUFFIX)
			     :CANONICAL-TYPE CANONICAL-TYPE
			     :VERSION :NEWEST)))

(DEFMETHOD (:PATCH-FILE-NAME VMS4.4-PATHNAME-MIXIN)
	   (SYSTEM-NAME SAME-DIRECTORY-P PATOM &OPTIONAL MAJOR-VERSION MINOR-VERSION)
  (LET* ((NAME (FORMAT NIL "~:[~A~*~;~*~A~]"
		 (EQ SAME-DIRECTORY-P :EXPLICIT) SYSTEM-NAME PATOM))
	 (VERS (FORMAT NIL "~@[-~D~]~@[-~D~]"
		 MAJOR-VERSION MINOR-VERSION))
	 (MAX-LENGTH (- (SEND SELF :FILENAME-LENGTH) (STRING-LENGTH VERS))))
    (STRING-APPEND
      (IF ( (STRING-LENGTH NAME) MAX-LENGTH) NAME (SUBSTRING NAME 0 MAX-LENGTH))
      VERS)))

(PUTPROP ':VMS '(:CANT-SET-CREATION-INFO) 'ATTRIBUTES)


;;;; Alto support
(DEFFLAVOR ALTO-PATHNAME-MIXIN ()
	   (BOTH-CASES-SAME-LOWER-PREFERRED-MIXIN TENEX-FAMILY-PATHNAME-MIXIN))

(DEFMETHOD (:VERSION-DELIMITER ALTO-PATHNAME-MIXIN) () #/!)
(DEFMETHOD (:SUBDIRECTORY-DELIMITER ALTO-PATHNAME-MIXIN) () #/>)	;!

(DEFMETHOD (:PRIMARY-DEVICE ALTO-PATHNAME-MIXIN) () :UNSPECIFIC)
(DEFMETHOD (:SUPPRESSED-DEVICE-NAMES ALTO-PATHNAME-MIXIN) () '(NIL :UNSPECIFIC))

(DEFMETHOD (:CHARACTER-NEEDS-QUOTING-P ALTO-PATHNAME-MIXIN) (IGNORE) NIL)

(DEFMETHOD (:SPECIAL-VERSION ALTO-PATHNAME-MIXIN) (IGNORE) NIL)

(DEFMETHOD (:QUOTE-CHARACTER ALTO-PATHNAME-MIXIN) () NIL)

;;; Structured directories are a fraud on the IFS
(DEFMETHOD (:PARSE-DIRECTORY-SPEC ALTO-PATHNAME-MIXIN) (SPEC)
  (SEND SELF ':PARSE-COMPONENT-SPEC SPEC))

(PUTPROP ':ALTO '() 'ATTRIBUTES)

;;;; Unix support

;;; UNIX-FAMILY-PATHNAME-MIXIN is the really basic stuff (used for MS-DOS, too)
;;; BASIC-UNIX-PATHNAME-MIXIN is common to different UNIX file systems
;;; VANILLA-UNIX-PATHNAME-MIXIN is for vanilla UNIX file systems (v7, BSD4.1 etc)
;;; UNIX42-PATHNAME-MIXIN is for 4.2 BSD systems

(DEFFLAVOR UNIX-FAMILY-PATHNAME-MIXIN ()
	(HIERARCHICAL-DIRECTORY-MIXIN MEANINGFUL-ROOT-MIXIN)
  (:REQUIRED-METHODS :DIRECTORY-SEPARATOR :FILENAME-STRING-OUT))

;;; Any character that is legal, doesn't need quoting.
(DEFMETHOD (:CHARACTER-NEEDS-QUOTING-P UNIX-FAMILY-PATHNAME-MIXIN) (IGNORE) ())

(DEFMETHOD (:DIRECTORY-SEPARATORS UNIX-FAMILY-PATHNAME-MIXIN :DEFAULT) ()
  (LIST (SEND SELF :DIRECTORY-SEPARATOR)))

(DEFMETHOD (:DIRECTORY-PATHNAME-AS-FILE UNIX-FAMILY-PATHNAME-MIXIN) ()
  (LET (RAW-DIRECTORY RAW-NAME RAW-TYPE VERSION)
    (COND ((EQ DIRECTORY ':ROOT)
	   (SETQ RAW-DIRECTORY ':ROOT
		 RAW-NAME ""
		 RAW-TYPE ""
		 VERSION ':UNSPECIFIC))
	  ((NLISTP DIRECTORY)
	   (SETQ RAW-DIRECTORY ':ROOT
		 RAW-NAME DIRECTORY
		 RAW-TYPE ':UNSPECIFIC
		 VERSION ':UNSPECIFIC))
	  ((AND (EQ (CAR DIRECTORY) ':RELATIVE)
		(= (LENGTH DIRECTORY) 1))
	   (SETQ RAW-DIRECTORY NIL
		 RAW-NAME "."
		 RAW-TYPE ':UNSPECIFIC
		 VERSION ':UNSPECIFIC))
	  ((AND (EQ (CAR DIRECTORY) ':RELATIVE)
		(= (LENGTH DIRECTORY) 2))
	   (SETQ RAW-DIRECTORY NIL
		 RAW-NAME (CAR (LAST DIRECTORY))
		 RAW-TYPE ':UNSPECIFIC
		 VERSION ':UNSPECIFIC))
	  ((= (LENGTH DIRECTORY) 1)
	   (SETQ RAW-DIRECTORY ':ROOT
		 RAW-NAME (CAR DIRECTORY)
		 RAW-TYPE ':UNSPECIFIC
		 VERSION ':UNSPECIFIC))
	  (T
	   (SETQ RAW-DIRECTORY (BUTLAST DIRECTORY)
		 RAW-NAME (CAR (LAST DIRECTORY))
		 RAW-TYPE ':UNSPECIFIC
		 VERSION ':UNSPECIFIC)))
    (WHEN (EQ RAW-NAME :UP)
      (SETQ RAW-NAME ".."))
    (WHEN (AND (EQ RAW-NAME :WILD)
	       (EQ RAW-TYPE :UNSPECIFIC)
	       (EQ VERSION :UNSPECIFIC))
      (SETQ RAW-TYPE :WILD
	    VERSION :WILD))
    (LET ((DOT (STRING-REVERSE-SEARCH-CHAR #/. RAW-NAME)))
      (WHEN DOT
	(SETQ RAW-TYPE (SUBSTRING RAW-NAME (1+ DOT))
	      RAW-NAME (NSUBSTRING RAW-NAME 0 DOT))))
    (SEND SELF ':NEW-PATHNAME
	  ':RAW-DIRECTORY RAW-DIRECTORY
	  ':RAW-NAME RAW-NAME
	  ':RAW-TYPE RAW-TYPE
	  ':VERSION VERSION)))

(DEFMETHOD (:PATHNAME-AS-DIRECTORY UNIX-FAMILY-PATHNAME-MIXIN) ()
  (FUNCALL-SELF ':NEW-PATHNAME
		':RAW-NAME NIL ':RAW-TYPE NIL ':VERSION ':UNSPECIFIC
		':RAW-DIRECTORY (IF (EQ DIRECTORY ':ROOT)
				    (IF (AND (STRING-EQUAL TYPE "")
					     (OR (STRING-EQUAL NAME "")
						 (STRING-EQUAL NAME ".")))
					':ROOT
				      (LIST (IF (MEMQ TYPE '(NIL :UNSPECIFIC))
						NAME
					      (STRING-APPEND NAME #/. TYPE))))
				  (APPEND (IF (LISTP DIRECTORY) DIRECTORY
					    (NCONS DIRECTORY))
					  (NCONS
					    (IF (MEMQ TYPE '(NIL :UNSPECIFIC))
						NAME
					      (IF (AND (STRING-EQUAL NAME ".")
						       (STRING-EQUAL TYPE ""))
						  :UP
						(STRING-APPEND NAME #/. TYPE))))))))

;;should also handler /../ components, but that's for later -- Kalman
(DEFWHOPPER (:DIRECTORY-MATCH FS:UNIX-FAMILY-PATHNAME-MIXIN) (WILD-DIRECTORY OTHER-DIRECTORY)
  (OR (CONTINUE-WHOPPER WILD-DIRECTORY OTHER-DIRECTORY)
      (LET ((NEW-WILD (IF (and (listp wild-directory)	;can be :ROOT
			       (SCL::SEARCH "." WILD-DIRECTORY :TEST'STRING-EQUAL))
			  (LOOP FOR X IN WILD-DIRECTORY
				UNLESS (STRING-EQUAL X ".")
				  COLLECT X)
			  WILD-DIRECTORY))
	    (NEW-OTHER (IF (and (listp other-directory)	;can be :ROOT
				(SCL::SEARCH "." OTHER-DIRECTORY :TEST'STRING-EQUAL))
			   (LOOP FOR X IN OTHER-DIRECTORY
				 UNLESS (STRING-EQUAL X ".")
				   COLLECT X)
			   OTHER-DIRECTORY)))
	(CONTINUE-WHOPPER NEW-WILD NEW-OTHER))))

(DEFUN UNIX-DEVICE-STRING-OUT (STREAM DEVICE)
  (WHEN (STRINGP DEVICE)
    (FORMAT STREAM "~A:" DEVICE)))

;;; Put the string representing the given directory onto the given stream
(DEFUN UNIX-DIRECTORY-STRING-OUT (STREAM DIRECTORY DIRECTORY-SEPARATOR
				  &OPTIONAL SUPPRESS-FINAL-DELIMITER)
  (COND ((NULL DIRECTORY))
	((EQ DIRECTORY :ROOT)
	 (SEND STREAM :TYO DIRECTORY-SEPARATOR))
	(T
	 (IF (AND (LISTP DIRECTORY)
		  (EQ (CAR DIRECTORY) ':RELATIVE))
	     (POP DIRECTORY)
	     (SEND STREAM :TYO DIRECTORY-SEPARATOR))
	 (LOOP FOR COMPONENT = (IF (LISTP DIRECTORY)
				   (POP DIRECTORY)
				   (PROG1 DIRECTORY
					  (SETQ DIRECTORY NIL)))
	       DO (SEND STREAM :STRING-OUT (SELECTQ COMPONENT
					     (:WILD "*")
					     (:WILD-INFERIORS "**")
					     (:UP "..")
					     (NIL "")
					     (OTHERWISE COMPONENT)))
	       WHEN (OR DIRECTORY
			(NULL SUPPRESS-FINAL-DELIMITER))
	       DO (SEND STREAM :TYO DIRECTORY-SEPARATOR)
	       WHILE DIRECTORY))))

(DEFMETHOD (:STRING-FOR-HOST UNIX-FAMILY-PATHNAME-MIXIN) (&OPTIONAL IGNORE)
  (WITH-OUTPUT-TO-STRING (S)
    (UNIX-DEVICE-STRING-OUT S DEVICE)
    (UNIX-DIRECTORY-STRING-OUT S DIRECTORY (SEND SELF :DIRECTORY-SEPARATOR))
    (SEND SELF :FILENAME-STRING-OUT S)))

(DEFMETHOD (:STRING-FOR-EDITOR UNIX-FAMILY-PATHNAME-MIXIN) ()
  (WITH-OUTPUT-TO-STRING (S)
    (SEND SELF :FILENAME-STRING-OUT S)
    (SEND S :TYO #/SP)
    (UNIX-DEVICE-STRING-OUT S DEVICE)
    (UNIX-DIRECTORY-STRING-OUT S DIRECTORY (SEND SELF :DIRECTORY-SEPARATOR))
    (SEND S :TYO #/SP)
    (SEND S :STRING-OUT (SEND HOST :NAME-AS-FILE-COMPUTER))
    (SEND S :TYO #/:)))

(DEFMETHOD (:STRING-FOR-DIRECTORY UNIX-FAMILY-PATHNAME-MIXIN) ()
  (WITH-OUTPUT-TO-STRING (S)
    (UNIX-DEVICE-STRING-OUT S DEVICE)
    (UNIX-DIRECTORY-STRING-OUT S DIRECTORY (SEND SELF :DIRECTORY-SEPARATOR) T)))

(DEFMETHOD (:STRING-FOR-DIRED UNIX-FAMILY-PATHNAME-MIXIN) ()
  (WITH-OUTPUT-TO-STRING (S)
    (SEND SELF :FILENAME-STRING-OUT S)))

(DEFMETHOD (:PARSE-NAMESTRING UNIX-FAMILY-PATHNAME-MIXIN)
	   (IGNORE NAMESTRING &OPTIONAL (START 0) (END (STRING-LENGTH NAMESTRING)))
  (SETQ START (OR (STRING-SEARCH-NOT-CHAR #\SP NAMESTRING START END) END))
  (LET* ((DEV (IF (EQ DEVICE :UNSPECIFIC)
		  :UNSPECIFIC
		  (LET ((DEV-END (STRING-SEARCH-CHAR #/: NAMESTRING START END))
			(DEV-START START))
		    (WHEN DEV-END
		      (SETQ START (1+ DEV-END))
		      (SUBSTRING NAMESTRING DEV-START DEV-END)))))
	 (DIR (LET ((DIR-END (STRING-REVERSE-SEARCH-SET
			       (SEND SELF :DIRECTORY-SEPARATORS) NAMESTRING END START))
		    (DIR-START START))
		(WHEN DIR-END
		  (SETQ START (SETQ DIR-END (1+ DIR-END)))
		  (NCONC 
		    ;; PREPEND A :RELATIVE IF NO LEADING SLASH, OTHERWISE SKIP SLASHES
		    (COND ((NOT (MEM #'CHAR-EQUAL (AREF NAMESTRING DIR-START)
				     (SEND SELF :DIRECTORY-SEPARATORS)))
			   (NCONS :RELATIVE))
			  (T
			   (SETQ DIR-START
				 (STRING-SEARCH-NOT-SET (SEND SELF :DIRECTORY-SEPARATORS)
							 NAMESTRING DIR-START DIR-END))
			   NIL))
		    (IF (AND DIR-START (< DIR-START DIR-END))
			(LOOP WHILE DIR-START
			      FOR COMPONENT-END = (STRING-SEARCH-SET
						    (SEND SELF :DIRECTORY-SEPARATORS)
						    NAMESTRING DIR-START DIR-END)
			      FOR COMPONENT = NIL
			      DO (COND ((STRING-EQUAL
					  NAMESTRING ".." DIR-START 0 COMPONENT-END)
					(SETQ COMPONENT :UP))
				       ((STRING-EQUAL
					  NAMESTRING "." DIR-START 0 COMPONENT-END)
					(SETQ COMPONENT :NOOP))
				       ((STRING-EQUAL
					  NAMESTRING "*" DIR-START 0 COMPONENT-END)
					(SETQ COMPONENT :WILD))
				       ((STRING-EQUAL
					  NAMESTRING "" DIR-START 0 COMPONENT-END)
					(SETQ COMPONENT NIL))
				       (T
					(SETQ COMPONENT
					      (SUBSTRING
						NAMESTRING DIR-START COMPONENT-END))))
			      UNLESS (EQ COMPONENT :NOOP)
			        COLLECT COMPONENT
			      DO (SETQ DIR-START (STRING-SEARCH-NOT-SET
						   (SEND SELF :DIRECTORY-SEPARATORS)
						   NAMESTRING COMPONENT-END DIR-END)))
			:ROOT)))))
	 (NAMED (NEQ START END))
	 (NAM (AND NAMED
		   (LET ((NAME-END (STRING-REVERSE-SEARCH-CHAR #/. NAMESTRING END START))
			 (NAME-START START))
		     (IF NAME-END
			 (SETQ START NAME-END)
			 (SETQ START END
			       NAME-END END))
		     (COND ((STRING-EQUAL NAMESTRING "" NAME-START 0 NAME-END)
			    NIL)
			   ((STRING-EQUAL NAMESTRING "*" NAME-START 0 NAME-END)
			    :WILD)
			   (T
			    (SUBSTRING NAMESTRING NAME-START NAME-END))))))
	 (TYP (AND NAMED
		   (COND ((EQ START END)
			  (IF (OR (EQ NAM :WILD)
				  (AND (STRINGP NAM)
				       (> (STRING-LENGTH NAM) 0)
				       (CHAR= (AREF NAM (1- (STRING-LENGTH NAM))) #/*)))
			      :WILD :UNSPECIFIC))
			 (T
			  (INCF START)
			  (COND ((STRING-EQUAL NAMESTRING "" START 0 END)
				 NIL)
				((STRING-EQUAL NAMESTRING "*" START 0 END)
				 :WILD)
				(T
				 (SUBSTRING NAMESTRING START END))))))))
    (VALUES DEV DIR NAM TYP :UNSPECIFIC)))

;;;

;;; MSDOS-PATHNAME-MIXIN is for MS-DOS systems.
;;; can't use Unix-family-pathname-mixin anymore because of NFS

(DEFFLAVOR MSDOS-PATHNAME-MIXIN ()
	   (NO-VERSION-MIXIN BOTH-CASES-SAME-LOWER-PREFERRED-MIXIN
	    HIERARCHICAL-DIRECTORY-MIXIN MEANINGFUL-ROOT-MIXIN)
  (:REQUIRED-METHODS :DIRECTORY-SEPARATOR :FILENAME-STRING-OUT))

(DEFMETHOD (:DIRECTORY-SEPARATOR MSDOS-PATHNAME-MIXIN) () #/\)

(DEFMETHOD (:DIRECTORY-SEPARATORS MSDOS-PATHNAME-MIXIN) () '(#/\))

(DEFMETHOD (:PRIMARY-DEVICE MSDOS-PATHNAME-MIXIN) () "C")

;;; Any character that is legal, doesn't need quoting.
(DEFMETHOD (:CHARACTER-NEEDS-QUOTING-P MSDOS-PATHNAME-MIXIN) (IGNORE) ())

(DEFMETHOD (:DIRECTORY-PATHNAME-AS-FILE MSDOS-PATHNAME-MIXIN) ()
  (LET (RAW-DIRECTORY RAW-NAME RAW-TYPE VERSION)
    (COND ((EQ DIRECTORY ':ROOT)
	   (SETQ RAW-DIRECTORY ':ROOT
		 RAW-NAME ""
		 RAW-TYPE ""
		 VERSION ':UNSPECIFIC))
	  ((NLISTP DIRECTORY)
	   (SETQ RAW-DIRECTORY ':ROOT
		 RAW-NAME DIRECTORY
		 RAW-TYPE ':UNSPECIFIC
		 VERSION ':UNSPECIFIC))
	  ((AND (EQ (CAR DIRECTORY) ':RELATIVE)
		(= (LENGTH DIRECTORY) 1))
	   (SETQ RAW-DIRECTORY NIL
		 RAW-NAME "."
		 RAW-TYPE ':UNSPECIFIC
		 VERSION ':UNSPECIFIC))
	  ((AND (EQ (CAR DIRECTORY) ':RELATIVE)
		(= (LENGTH DIRECTORY) 2))
	   (SETQ RAW-DIRECTORY NIL
		 RAW-NAME (CAR (LAST DIRECTORY))
		 RAW-TYPE ':UNSPECIFIC
		 VERSION ':UNSPECIFIC))
	  ((= (LENGTH DIRECTORY) 1)
	   (SETQ RAW-DIRECTORY ':ROOT
		 RAW-NAME (CAR DIRECTORY)
		 RAW-TYPE ':UNSPECIFIC
		 VERSION ':UNSPECIFIC))
	  (T
	   (SETQ RAW-DIRECTORY (BUTLAST DIRECTORY)
		 RAW-NAME (CAR (LAST DIRECTORY))
		 RAW-TYPE ':UNSPECIFIC
		 VERSION ':UNSPECIFIC)))
    (WHEN (EQ RAW-NAME :UP)
      (SETQ RAW-NAME ".."))
    (WHEN (AND (EQ RAW-NAME :WILD)
	       (EQ RAW-TYPE :UNSPECIFIC)
	       (EQ VERSION :UNSPECIFIC))
      (SETQ RAW-TYPE :WILD
	    VERSION :WILD))
    (LET ((DOT (STRING-REVERSE-SEARCH-CHAR #/. RAW-NAME)))
      (WHEN DOT
	(SETQ RAW-TYPE (SUBSTRING RAW-NAME (1+ DOT))
	      RAW-NAME (NSUBSTRING RAW-NAME 0 DOT))))
    (SEND SELF ':NEW-PATHNAME
	  ':RAW-DIRECTORY RAW-DIRECTORY
	  ':RAW-NAME RAW-NAME
	  ':RAW-TYPE RAW-TYPE
	  ':VERSION VERSION)))

(DEFUN MSDOS-PATHNAME-VALIDATE (STRING SYMBOLS LENGTH)
  (TYPECASE STRING
    (:SYMBOL (MEMQ STRING SYMBOLS))
    (:STRING (AND ( 0 (STRING-LENGTH STRING) LENGTH)
		  (LOOP FOR CHAR BEING THE ARRAY-ELEMENTS OF STRING
			ALWAYS (OR (ALPHA-CHAR-P CHAR)
				   (DIGIT-CHAR-P CHAR)
				   (MEM #'CHAR-EQUAL CHAR
					'(#/$ #/& #/# #/@ #/! #/% #/' #/` #/( #/) #/-
					  #/{ #/} #/_ #// #/\))))))))

(DEFMETHOD (:VALID-DEVICE-P MSDOS-PATHNAME-MIXIN) (DEV)
  (TYPECASE DEV
    (:SYMBOL (NULL DEV))
    (:STRING (AND (= (STRING-LENGTH DEV) 1)
		  (NOT (STRING-LESSP DEV "A"))
		  (NOT (STRING-LESSP "Z" DEV))))))

(DEFMETHOD (:VALID-DIRECTORY-COMPONENT-P MSDOS-PATHNAME-MIXIN) (COMPONENT IGNORE)
  (MSDOS-PATHNAME-VALIDATE COMPONENT '(NIL) 8))

(DEFMETHOD (:VALID-NAME-P MSDOS-PATHNAME-MIXIN) (NAM)
  (MSDOS-PATHNAME-VALIDATE NAM '(NIL :WILD) 8))

(DEFMETHOD (:VALID-TYPE-P MSDOS-PATHNAME-MIXIN) (TYP)
  (MSDOS-PATHNAME-VALIDATE TYP '(NIL :WILD :UNSPECIFIC) 3))

(DEFMETHOD (:FILENAME-STRING-OUT MSDOS-PATHNAME-MIXIN) (STREAM &OPTIONAL LENGTH-ONLY-P)
  (LET* ((MINIMUM-POSSIBLE-LENGTH 0)
	 (TYPE-STRING (SELECTQ TYPE
			(:WILD  #/*)
			(NIL (AND NAME #/))
			(:UNSPECIFIC NIL)
			(OTHERWISE
			 (INCF MINIMUM-POSSIBLE-LENGTH (1+ (STRING-LENGTH TYPE)))
			 TYPE)))
	 (NAME-STRING (SELECTQ NAME
			(:WILD #/*)
			(NIL (IF TYPE-STRING #/))
			(OTHERWISE
			 (INCF MINIMUM-POSSIBLE-LENGTH (STRING-LENGTH NAME))
			 NAME))))
    (UNLESS LENGTH-ONLY-P
      (WHEN NAME-STRING
	(SEND STREAM (IF (STRINGP NAME-STRING) :STRING-OUT :TYO) NAME-STRING))
      (WHEN TYPE-STRING
	(SEND STREAM :TYO #/.)
	(SEND STREAM (IF (STRINGP TYPE-STRING) :STRING-OUT :TYO) TYPE-STRING)))
    MINIMUM-POSSIBLE-LENGTH))

(DEFMETHOD (:PATHNAME-AS-DIRECTORY MSDOS-PATHNAME-MIXIN) ()
  (FUNCALL-SELF ':NEW-PATHNAME
		':RAW-NAME NIL ':RAW-TYPE NIL ':VERSION ':UNSPECIFIC
		':RAW-DIRECTORY (IF (EQ DIRECTORY ':ROOT)
				    (IF (AND (STRING-EQUAL TYPE "")
					     (OR (STRING-EQUAL NAME "")
						 (STRING-EQUAL NAME ".")))
					':ROOT
				      (LIST (IF (MEMQ TYPE '(NIL :UNSPECIFIC))
						NAME
					      (STRING-APPEND NAME #/. TYPE))))
				  (APPEND (IF (LISTP DIRECTORY) DIRECTORY
					    (NCONS DIRECTORY))
					  (NCONS
					    (IF (MEMQ TYPE '(NIL :UNSPECIFIC))
						NAME
					      (IF (AND (STRING-EQUAL NAME ".")
						       (STRING-EQUAL TYPE ""))
						  :UP
						(STRING-APPEND NAME #/. TYPE))))))))

(DEFUN MSDOS-DEVICE-STRING-OUT (STREAM DEVICE)
  (WHEN (STRINGP DEVICE)
    (FORMAT STREAM "~A:" DEVICE)))

;;; Put the string representing the given directory onto the given stream
(DEFUN MSDOS-DIRECTORY-STRING-OUT (STREAM DIRECTORY DIRECTORY-SEPARATOR
				  &OPTIONAL SUPPRESS-FINAL-DELIMITER)
  (COND ((NULL DIRECTORY))
	((EQ DIRECTORY :ROOT)
	 (SEND STREAM :TYO DIRECTORY-SEPARATOR))
	(T
	 (IF (AND (LISTP DIRECTORY)
		  (EQ (CAR DIRECTORY) ':RELATIVE))
	     (POP DIRECTORY)
	     (SEND STREAM :TYO DIRECTORY-SEPARATOR))
	 (LOOP FOR COMPONENT = (IF (LISTP DIRECTORY)
				   (POP DIRECTORY)
				   (PROG1 DIRECTORY
					  (SETQ DIRECTORY NIL)))
	       DO (SEND STREAM :STRING-OUT (SELECTQ COMPONENT
					     (:WILD "*")
					     (:WILD-INFERIORS "**")
					     (:UP "..")
					     (NIL "")
					     (OTHERWISE COMPONENT)))
	       WHEN (OR DIRECTORY
			(NULL SUPPRESS-FINAL-DELIMITER))
	       DO (SEND STREAM :TYO DIRECTORY-SEPARATOR)
	       WHILE DIRECTORY))))

(DEFMETHOD (:STRING-FOR-HOST MSDOS-PATHNAME-MIXIN) (&OPTIONAL IGNORE)
  (WITH-OUTPUT-TO-STRING (S)
    (MSDOS-DEVICE-STRING-OUT S DEVICE)
    (MSDOS-DIRECTORY-STRING-OUT S DIRECTORY (SEND SELF :DIRECTORY-SEPARATOR))
    (SEND SELF :FILENAME-STRING-OUT S)))

(DEFMETHOD (:STRING-FOR-EDITOR MSDOS-PATHNAME-MIXIN) ()
  (WITH-OUTPUT-TO-STRING (S)
    (SEND SELF :FILENAME-STRING-OUT S)
    (SEND S :TYO #/SP)
    (MSDOS-DEVICE-STRING-OUT S DEVICE)
    (MSDOS-DIRECTORY-STRING-OUT S DIRECTORY (SEND SELF :DIRECTORY-SEPARATOR))
    (SEND S :TYO #/SP)
    (SEND S :STRING-OUT (SEND HOST :NAME-AS-FILE-COMPUTER))
    (SEND S :TYO #/:)))

(DEFMETHOD (:STRING-FOR-DIRECTORY MSDOS-PATHNAME-MIXIN) ()
  (WITH-OUTPUT-TO-STRING (S)
    (MSDOS-DEVICE-STRING-OUT S DEVICE)
    (MSDOS-DIRECTORY-STRING-OUT S DIRECTORY (SEND SELF :DIRECTORY-SEPARATOR) T)))

(DEFMETHOD (:STRING-FOR-DIRED MSDOS-PATHNAME-MIXIN) ()
  (WITH-OUTPUT-TO-STRING (S)
    (SEND SELF :FILENAME-STRING-OUT S)))

(DEFMETHOD (:PARSE-NAMESTRING MSDOS-PATHNAME-MIXIN)
	   (IGNORE NAMESTRING &OPTIONAL (START 0) (END (STRING-LENGTH NAMESTRING)))
  (SETQ START (OR (STRING-SEARCH-NOT-CHAR #\SP NAMESTRING START END) END))
  (LET* ((DEV (IF (EQ DEVICE :UNSPECIFIC)
		  :UNSPECIFIC
		  (LET ((DEV-END (STRING-SEARCH-CHAR #/: NAMESTRING START END))
			(DEV-START START))
		    (WHEN DEV-END
		      (SETQ START (1+ DEV-END))
		      (SUBSTRING NAMESTRING DEV-START DEV-END)))))
	 (DIR (LET ((DIR-END (STRING-REVERSE-SEARCH-SET
			       (SEND SELF :DIRECTORY-SEPARATORS) NAMESTRING END START))
		    (DIR-START START))
		(WHEN DIR-END
		  (SETQ START (SETQ DIR-END (1+ DIR-END)))
		  (NCONC 
		    ;; PREPEND A :RELATIVE IF NO LEADING SLASH, OTHERWISE SKIP SLASHES
		    (COND ((NOT (MEM #'CHAR-EQUAL (AREF NAMESTRING DIR-START)
				     (SEND SELF :DIRECTORY-SEPARATORS)))
			   (NCONS :RELATIVE))
			  (T
			   (SETQ DIR-START
				 (STRING-SEARCH-NOT-SET (SEND SELF :DIRECTORY-SEPARATORS)
							 NAMESTRING DIR-START DIR-END))
			   NIL))
		    (IF (AND DIR-START (< DIR-START DIR-END))
			(LOOP WHILE DIR-START
			      FOR COMPONENT-END = (STRING-SEARCH-SET
						    (SEND SELF :DIRECTORY-SEPARATORS)
						    NAMESTRING DIR-START DIR-END)
			      FOR COMPONENT = NIL
			      DO (COND ((STRING-EQUAL
					  NAMESTRING ".." DIR-START 0 COMPONENT-END)
					(SETQ COMPONENT :UP))
				       ((STRING-EQUAL
					  NAMESTRING "." DIR-START 0 COMPONENT-END)
					(SETQ COMPONENT :NOOP))
				       ((STRING-EQUAL
					  NAMESTRING "*" DIR-START 0 COMPONENT-END)
					(SETQ COMPONENT :WILD))
				       ((STRING-EQUAL
					  NAMESTRING "" DIR-START 0 COMPONENT-END)
					(SETQ COMPONENT NIL))
				       (T
					(SETQ COMPONENT
					      (SUBSTRING
						NAMESTRING DIR-START COMPONENT-END))))
			      UNLESS (EQ COMPONENT :NOOP)
			        COLLECT COMPONENT
			      DO (SETQ DIR-START (STRING-SEARCH-NOT-SET
						   (SEND SELF :DIRECTORY-SEPARATORS)
						   NAMESTRING COMPONENT-END DIR-END)))
			:ROOT)))))
	 (NAMED (NEQ START END))
	 (NAM (AND NAMED
		   (LET ((NAME-END (STRING-REVERSE-SEARCH-CHAR #/. NAMESTRING END START))
			 (NAME-START START))
		     (IF NAME-END
			 (SETQ START NAME-END)
			 (SETQ START END
			       NAME-END END))
		     (COND ((STRING-EQUAL NAMESTRING "" NAME-START 0 NAME-END)
			    NIL)
			   ((STRING-EQUAL NAMESTRING "*" NAME-START 0 NAME-END)
			    :WILD)
			   (T
			    (SUBSTRING NAMESTRING NAME-START NAME-END))))))
	 (TYP (AND NAMED
		   (COND ((EQ START END)
			  (IF (OR (EQ NAM :WILD)
				  (AND (STRINGP NAM)
				       (> (STRING-LENGTH NAM) 0)
				       (CHAR= (AREF NAM (1- (STRING-LENGTH NAM))) #/*)))
			      :WILD :UNSPECIFIC))
			 (T
			  (INCF START)
			  (COND ((STRING-EQUAL NAMESTRING "" START 0 END)
				 NIL)
				((STRING-EQUAL NAMESTRING "*" START 0 END)
				 :WILD)
				(T
				 (SUBSTRING NAMESTRING START END))))))))
    (VALUES DEV DIR NAM TYP :UNSPECIFIC)))

;;; OS/2 HPFS
(defflavor hpfs-pathname-mixin ()
	   ()
  (:required-flavors msdos-pathname-mixin))

(DEFUN HPFS-PATHNAME-VALIDATE (STRING SYMBOLS)
  (TYPECASE STRING
    (:SYMBOL (MEMQ STRING SYMBOLS))
    (:STRING (LOOP FOR CHAR BEING THE ARRAY-ELEMENTS OF STRING
		   ALWAYS (OR (ALPHA-CHAR-P CHAR)
			      (DIGIT-CHAR-P CHAR)
			      (MEM #'CHAR-EQUAL CHAR
				   '(#/$ #/& #/# #/@ #/! #/% #/' #/` #/( #/) #/- #/~ #/+
				     #/{ #/} #/_ #// #/\ #\. #\space)))))))

(DEFMETHOD (:VALID-DEVICE-P HPFS-PATHNAME-MIXIN) (DEV)
  (TYPECASE DEV
    (:SYMBOL (NULL DEV))
    (:STRING (AND (= (STRING-LENGTH DEV) 1)
		  (NOT (STRING-LESSP DEV "A"))
		  (NOT (STRING-LESSP "Z" DEV))))))

(DEFMETHOD (:VALID-DIRECTORY-COMPONENT-P HPFS-PATHNAME-MIXIN) (COMPONENT IGNORE)
  (HPFS-PATHNAME-VALIDATE COMPONENT '(NIL)))

(DEFMETHOD (:VALID-NAME-P HPFS-PATHNAME-MIXIN) (NAM)
  (HPFS-PATHNAME-VALIDATE NAM '(NIL :WILD)))

(DEFMETHOD (:VALID-TYPE-P HPFS-PATHNAME-MIXIN) (TYP)
  (HPFS-PATHNAME-VALIDATE TYP '(NIL :WILD :UNSPECIFIC)))

;;; zzz should really check total length <= 254 too

;;;

(DEFCONST *UNIX-ILLEGAL-PATHNAME-CHARACTERS* `(#//))

(DEFFLAVOR GENERAL-UNIX-PATHNAME-MIXIN ()
	   (UNIX-MAILBOX-PATHNAME-MIXIN NO-DEVICE-MIXIN
	    LOWER-CASE-PREFERRED-MIXIN UNIX-FAMILY-PATHNAME-MIXIN)
  (:METHOD-COMBINATION :VALID-UNIX-STRING-P (:AND :MOST-SPECIFIC-LAST))
  (:REQUIRED-FLAVORS PATHNAME))

(DEFMETHOD (:DIRECTORY-SEPARATOR GENERAL-UNIX-PATHNAME-MIXIN) () #//)

(DEFMETHOD (:STRING-FOR-WHOLINE GENERAL-UNIX-PATHNAME-MIXIN) ()
  (SEND SELF :STRING-FOR-PRINTING))

(DEFMETHOD (:VALID-UNIX-STRING-P GENERAL-UNIX-PATHNAME-MIXIN :AND) (STRING IGNORE)
  (NOT (STRING-SEARCH-SET *UNIX-ILLEGAL-PATHNAME-CHARACTERS* STRING)))

(DEFMETHOD (PATHNAME-UNIX-NEWEST-VERSION-SHOULD-BE-EXPLICIT GENERAL-UNIX-PATHNAME-MIXIN) ()
  (AND (NETI:HOST-UNIX-VERSIONS-ENABLED HOST :DIRECTORY DIRECTORY)
       (OR (LOOP FOR PATHNAME FIRST SELF THEN (SEND PATHNAME :DIRECTORY-PATHNAME-AS-FILE)
		 FOR CANONICAL-TYPE = (SEND PATHNAME :CANONICAL-TYPE)
		 FOR DIRECTORY = (SEND PATHNAME :RAW-DIRECTORY)
		 THEREIS (AND (KEYWORDP CANONICAL-TYPE)
			      (GET CANONICAL-TYPE :UNIX-NEWEST-VERSION-SHOULD-BE-EXPLICIT))
		 UNTIL (OR (NULL DIRECTORY) (EQ DIRECTORY :ROOT))))))

;;; Invalidate strings that contain zeros or slashes
(DEFWHOPPER (:VALID-DIRECTORY-COMPONENT-P GENERAL-UNIX-PATHNAME-MIXIN)
	    (COMPONENT LEVEL)
  (WHEN (OR (NOT (STRINGP COMPONENT))
	    (SEND SELF :VALID-UNIX-STRING-P COMPONENT NIL))
    (OR (EQ COMPONENT :WILD-INFERIORS)
	(CONTINUE-WHOPPER COMPONENT LEVEL))))

(DEFMETHOD (:VALID-VERSION-P GENERAL-UNIX-PATHNAME-MIXIN) (SPEC)
  (OR (LISP:MEMBER SPEC '(NIL :NEWEST :WILD :UNSPECIFIC))
      (AND (FIXP SPEC) (PLUSP SPEC))))

(DEFMETHOD (:VALID-VERSION GENERAL-UNIX-PATHNAME-MIXIN) (VRS)
  (IF (SEND SELF :VALID-VERSION-P VRS) VRS :NEWEST))

(DEFMETHOD (:VALID-TYPE-P GENERAL-UNIX-PATHNAME-MIXIN) (TYP)
  (TYPECASE TYP
    (:SYMBOL (MEMQ TYP '(NIL :WILD :UNSPECIFIC)))
    (:STRING (SEND SELF :VALID-UNIX-STRING-P TYP T))))

(DEFMETHOD (:VALID-NAME-P GENERAL-UNIX-PATHNAME-MIXIN) (NAM)
  (TYPECASE NAM
    (:SYMBOL (MEMQ NAM '(NIL :WILD)))
    (:STRING (SEND SELF :VALID-UNIX-STRING-P NAM NIL))))

(DEFCONST *UNIX-VERSION-PREFIX* ".~")

(DEFCONST *UNIX-VERSION-SUFFIX* "~")

(DEFUN PARSE-UNIX-VERSION (NAMESTRING &OPTIONAL (START 0) (END (STRING-LENGTH NAMESTRING)))
  (DECLARE (VALUES VERS NEW-END))
  (LET ((SUFFIX (- END (STRING-LENGTH *UNIX-VERSION-SUFFIX*))))
    (IF (AND (>= SUFFIX START)
	     (STRING= NAMESTRING *UNIX-VERSION-SUFFIX* SUFFIX))
	(LET ((PREFIX (STRING-REVERSE-SEARCH *UNIX-VERSION-PREFIX* NAMESTRING SUFFIX)))
	  (IF PREFIX
	      (LET ((VERSION (+ PREFIX (STRING-LENGTH *UNIX-VERSION-PREFIX*))))
		(IF (< VERSION SUFFIX)
		    (SELECTOR (AREF NAMESTRING VERSION) CHAR=
		      ((#/1 #/2 #/3 #/4 #/5 #/6 #/7 #/8 #/9)
		       (IF (STRING-SEARCH-NOT-SET "0123456789" NAMESTRING VERSION SUFFIX)
			   (VALUES NIL END)
			 (VALUES (SYS:PARSE-NUMBER NAMESTRING VERSION SUFFIX 10.) PREFIX)))
		      (#/*
		       (IF (= SUFFIX (1+ VERSION))
			   (VALUES :WILD PREFIX)
			 (VALUES NIL END)))
		      (#/
		       (IF (= SUFFIX (1+ VERSION))
			   (VALUES NIL PREFIX)
			 (VALUES NIL END)))
		      (#/>
		       (IF (= SUFFIX (1+ VERSION))
			   (VALUES :NEWEST PREFIX)
			 (VALUES NIL END)))
		      (OTHERWISE 
			(VALUES NIL END)))
		  (VALUES NIL END)))
	    (VALUES NIL END)))
      (VALUES NIL END))))

(DEFWHOPPER (:PARSE-NAMESTRING GENERAL-UNIX-PATHNAME-MIXIN)
	    (HOST-SPECIFIED NAMESTRING &OPTIONAL (START 0) (END (STRING-LENGTH NAMESTRING)))
  (MULTIPLE-VALUE-BIND (VER END1)
      (PARSE-UNIX-VERSION NAMESTRING START END)
    (MULTIPLE-VALUE-BIND (DEV DIR NAM TYP IGNORE)
	(CONTINUE-WHOPPER HOST-SPECIFIED NAMESTRING START END1)
      (LET ((VERSIONS-ENABLED (NETI:HOST-UNIX-VERSIONS-ENABLED HOST :DIRECTORY DIR)))
	(IF VERSIONS-ENABLED
	    (WHEN (= END END1)
	      (COND ((OR (EQ TYP :WILD)
			 (AND (STRINGP TYP)
			      (> (STRING-LENGTH TYP) 0)
			      (CHAR= (AREF TYP (1- (STRING-LENGTH TYP))) #/*)))
		     (SETQ VER :WILD))
		    ((NOT (NULL TYP))
		     (SETQ VER :NEWEST))))
	  (MULTIPLE-VALUE (DEV DIR NAM TYP VER)
	    (CONTINUE-WHOPPER HOST-SPECIFIED NAMESTRING START (SETQ END1 END)))))
      (WHEN (LISTP DIR)
	(LOOP FOR PAIR ON DIR
	      WHEN (STRING= (CAR PAIR) "**")
		DO (SETF (CAR PAIR) :WILD-INFERIORS)))
      (VALUES DEV DIR NAM TYP VER))))

(DEFWHOPPER (:MERGE-PATHNAMES GENERAL-UNIX-PATHNAME-MIXIN)
	    (DEFAULT &OPTIONAL (DEFAULT-VERSION :NEWEST) (DEFAULT-VC-VERSION :NEWEST))
  (WHEN (AND DIRECTORY (NOT (AND (LISTP DIRECTORY) (EQ (CAR DIRECTORY) :RELATIVE))))
    ;; Since the version we get from :NEW-DEFAULT-PATHNAME will depend upon
    ;; which directory the pathname is in, make sure we don't lose the
    ;; version.  Do this by specifying the eventual directory.  This way if
    ;; at first DEFAULTs directory causes the version to be lost, we'll get
    ;; it back again.
    (SETQ DEFAULT (SEND DEFAULT :NEW-DEFAULT-PATHNAME
			:HOST HOST
			:RAW-DIRECTORY DIRECTORY
			:VERSION (SEND DEFAULT :VERSION))))
  (CONTINUE-WHOPPER DEFAULT DEFAULT-VERSION DEFAULT-VC-VERSION))

;; Output a string that expresses the name and the type as it would appear
;; on UNIX.  A return value indicates the minimum length string which
;; this pathname could represent.
(DEFMETHOD (:FILENAME-STRING-OUT GENERAL-UNIX-PATHNAME-MIXIN) (STREAM &OPTIONAL LENGTH-ONLY-P)
  (LET* ((MINIMUM-POSSIBLE-LENGTH 0)
	 (TYPE-STRING (SELECTQ TYPE
			(:WILD (AND (NOT (OR (EQ NAME :WILD)
					     (AND (STRINGP NAME)
						  (> (STRING-LENGTH NAME) 0)
						  (CHAR= (AREF NAME (1- (STRING-LENGTH NAME)))
							 #/*))))
				    #/*))
			(NIL (AND NAME #/))
			(:UNSPECIFIC NIL)
			(OTHERWISE
			 (INCF MINIMUM-POSSIBLE-LENGTH (1+ (STRING-LENGTH TYPE)))
			 TYPE)))
	 (NAME-STRING (SELECTQ NAME
			(:WILD #/*)
			(NIL (IF TYPE-STRING #/))
			(OTHERWISE
			 (INCF MINIMUM-POSSIBLE-LENGTH (STRING-LENGTH NAME))
			 NAME))))
    (UNLESS LENGTH-ONLY-P
      (WHEN NAME-STRING
	(SEND STREAM (IF (STRINGP NAME-STRING) :STRING-OUT :TYO) NAME-STRING))
      (WHEN TYPE-STRING
	(SEND STREAM :TYO #/.)
	(SEND STREAM (IF (STRINGP TYPE-STRING) :STRING-OUT :TYO) TYPE-STRING)))
    (WHEN (NUMBERP VERSION)
      (INCF MINIMUM-POSSIBLE-LENGTH
	    (+ (STRING-LENGTH *UNIX-VERSION-PREFIX*)
	       (1+ (FLOOR (LISP:LOG VERSION 10.)))
	       (STRING-LENGTH *UNIX-VERSION-SUFFIX*)))
      (UNLESS LENGTH-ONLY-P
	(SEND STREAM :STRING-OUT *UNIX-VERSION-PREFIX*)
	(FORMAT STREAM "~D" VERSION)
	(SEND STREAM :STRING-OUT *UNIX-VERSION-SUFFIX*)))
    MINIMUM-POSSIBLE-LENGTH))

(DEFMETHOD (:STRING-FOR-PRINTING GENERAL-UNIX-PATHNAME-MIXIN) ()
  (LET ((NAME-AS-FILE-COMPUTER (SEND HOST :NAME-AS-FILE-COMPUTER))
	(STRING-FOR-HOST (SEND SELF :STRING-FOR-HOST)))
    (IF (OR (NUMBERP VERSION)
	    (EQ VERSION :UNSPECIFIC)
	    (AND (EQ VERSION :WILD)
		 (OR (EQ TYPE :WILD)
		     (AND (STRINGP TYPE)
			  (> (STRING-LENGTH TYPE) 0)
			  (CHAR= (AREF TYPE (1- (STRING-LENGTH TYPE))) #/*))))
	    (AND (NULL VERSION)
		 (NULL TYPE))
	    (AND (EQ VERSION :NEWEST)
		 (NOT (NULL TYPE))
		 (NOT (EQ TYPE :WILD))
		 (NOT (AND (STRINGP TYPE)
			   (> (STRING-LENGTH TYPE) 0)
			   (CHAR= (AREF TYPE (1- (STRING-LENGTH TYPE))) #/*)))))
	(LET ((*DEFAULT-CONS-AREA* PATHNAME-AREA))
	  (STRING-APPEND NAME-AS-FILE-COMPUTER #/: STRING-FOR-HOST))
      (LET ((VERSION-STRING (SELECTQ VERSION
			      (:WILD #/*)
			      (:NEWEST #/>)
			      (NIL #/)
			      (OTHERWISE (STRING-DOWNCASE (STRING VERSION)))))
	    (*DEFAULT-CONS-AREA* PATHNAME-AREA))
	(STRING-APPEND NAME-AS-FILE-COMPUTER #/: STRING-FOR-HOST
		       *UNIX-VERSION-PREFIX*
		       VERSION-STRING
		       *UNIX-VERSION-SUFFIX*)))))

;;; Support specific to vanilla UNIX systems (with 14 character filename limit)
;;; Almost all of this is just length checking/truncation.

(DEFFLAVOR VANILLA-UNIX-PATHNAME-MIXIN () (GENERAL-UNIX-PATHNAME-MIXIN)
  (:REQUIRED-FLAVORS HIERARCHICAL-DIRECTORY-MIXIN))

(DEFMETHOD (:VALID-COMPONENTS-ALL VANILLA-UNIX-PATHNAME-MIXIN) (DEV DIR NAM TYP VRS)
  (DECLARE (VALUES DEVICE DIRECTORY NAME TYPE VERSION))
  (LET ((MAX-LENGTH 14.))
    (WHEN (AND (STRINGP NAM) (STRINGP TYP)
	       (> (+ (STRING-LENGTH NAM) (STRING-LENGTH TYP) 1)
		  MAX-LENGTH))
      (LET* ((CANONICAL-TYPE (LOOKUP-CANONICAL-TYPE
			       (SEND SELF :SYSTEM-TYPE)
			       (SEND SELF :UNCASE-TYPE TYP)))
	     (TMAX (IF (SYMBOLP CANONICAL-TYPE)
		       (1+ (STRING-LENGTH TYP))
		     (MIN (1+ (STRING-LENGTH TYP))	;Type plus "."
			  (1+ (FIX (* 1\3 MAX-LENGTH)))))))
	(SETQ NAM (NSUBSTRING NAM 0 (MIN (- MAX-LENGTH TMAX) (STRING-LENGTH NAM)))
	      TYP (SUBSTRING TYP 0 (1- TMAX))))))
  (VALUES DEV DIR NAM TYP VRS))

;;; Add a length check for string components
(DEFMETHOD (:VALID-UNIX-STRING-P VANILLA-UNIX-PATHNAME-MIXIN :AND) (STRING TYPE-P)
  (<= (PATHNAME-COMPONENT-MIN-LENGTH STRING) (IF TYPE-P 13. 14.)))

(DEFFLAVOR UNIX-NAME-AND-TYPE-TOO-LONG (PATHNAME (MAX-LENGTH 14.))
	   (INVALID-PATHNAME-COMPONENT)
  :INITABLE-INSTANCE-VARIABLES
  (:GETTABLE-INSTANCE-VARIABLES MAX-LENGTH)
  (:DEFAULT-INIT-PLIST :COMPONENT :NAME
    		       :COMPONENT-DESCRIPTION "name"))

(DEFMETHOD (:REPORT UNIX-NAME-AND-TYPE-TOO-LONG) (STREAM)
  (FORMAT STREAM "Name and type together exceed ~D characters in UNIX pathname ~A."
	  MAX-LENGTH PATHNAME))

;; One argument: a new component, in raw (uncased) form.
(DEFMETHOD (:PROCEED UNIX-NAME-AND-TYPE-TOO-LONG :NEW-COMPONENT)
	   (&OPTIONAL (COMP
			(PROMPT-AND-READ
			  ':STRING
			  "String of ~D characters or less to replace the name /"~A/":"
					     COMPONENT-VALUE)))
  (VALUES ':NEW-COMPONENT COMP))

(COMPILE-FLAVOR-METHODS UNIX-NAME-AND-TYPE-TOO-LONG)

(DEFMETHOD (:VALIDATE VANILLA-UNIX-PATHNAME-MIXIN :AFTER) ()
  (LET ((MINIMUM-POSSIBLE-LENGTH (SEND SELF :FILENAME-STRING-OUT NIL T)))
    (WHEN (> MINIMUM-POSSIBLE-LENGTH 14.)
      (ERROR 'UNIX-NAME-AND-TYPE-TOO-LONG :PATHNAME SELF :COMPONENT-VALUE NAME))))
    
;;; Patch system interface, more kludges for only 14 character UNIX filenames
(DEFMETHOD (:PATCH-FILE-NAME VANILLA-UNIX-PATHNAME-MIXIN)
	   (SYSTEM-NAME SAME-DIRECTORY-P PATOM &OPTIONAL MAJOR-VERSION MINOR-VERSION)
  (LET ((SNAME (IF (EQ SAME-DIRECTORY-P :EXPLICIT) PATOM SYSTEM-NAME)))
    (WHEN (> (STRING-LENGTH SNAME) 6)
      (SETQ SNAME (SUBSTRING SNAME 0 6)))
    (COND (MINOR-VERSION
	   (FORMAT NIL "~D-~D" MAJOR-VERSION MINOR-VERSION))
	  (MAJOR-VERSION
	   (FORMAT NIL "~D" MAJOR-VERSION))
	  (T SNAME))))

#||
(DEFMETHOD (:OLD-PATCH-FILE-PATHNAME VANILLA-UNIX-PATHNAME-MIXIN)
	   (NAM SAME-DIRECTORY-P PATOM TYP &REST ARGS)
   (LET ((SNAME (IF SAME-DIRECTORY-P PATOM (SCT:SYSTEM-PATCH-ATOM NAM))))
     (IF (> (STRING-LENGTH SNAME) 6)
	 (SETQ SNAME (SUBSTRING SNAME 0 6)))
     (SELECTQ TYP
       (:SYSTEM-DIRECTORY
	(FUNCALL-SELF ':NEW-PATHNAME ':NAME SNAME
		      ':CANONICAL-TYPE ':PATCH-SYSTEM-DIRECTORY
		      ':VERSION ':NEWEST))
       (:VERSION-DIRECTORY
	(FUNCALL-SELF ':NEW-PATHNAME ':NAME (FORMAT NIL "~A-~D" SNAME (\ (CAR ARGS) 10000.))
		      ':CANONICAL-TYPE ':PATCH-VERSION-DIRECTORY ':VERSION ':NEWEST))
       (:PATCH-FILE
	(FUNCALL-SELF ':NEW-PATHNAME
		      ':NAME (FORMAT NIL "~A-~D-~D"
				     (SUBSTRING SNAME 0 (MIN 3 (STRING-LENGTH SNAME)))
				     (\ (CAR ARGS) 1000.)
				     (\ (CADR ARGS) 1000.))
		      ':CANONICAL-TYPE (CADDR ARGS) ':VERSION ':NEWEST)))))

||#

(DEFCONST *DIGITS* "01234556789")

(DEFMETHOD (:NEW-TYPE-AND-VERSION VANILLA-UNIX-PATHNAME-MIXIN) (TYP VRS)
  (IF (NOT (TYPEP VRS :FIXNUM))
      (SEND SELF :NEW-PATHNAME :TYPE TYP)
    (LET* ((NTYP (SEND SELF :TYPE-FOR-NEW-CANONICAL-TYPE TYP NIL NIL))
	   (NVRS (FORMAT NIL "~D" VRS))
	   (NAM (SEND SELF :NAME))
	   (NAMLEN (MIN (STRING-LENGTH NAM)
			(- 14. 2 (STRING-LENGTH NTYP) (STRING-LENGTH NVRS))))
	   (NNAM (SUBSTRING (SEND SELF :NAME) 0 NAMLEN)))
      (SEND SELF :NEW-PATHNAME :NAME (FORMAT NIL "~A.~A" NNAM NVRS) :TYPE NTYP))))

(DEFMETHOD (:TYPE-AND-VERSION VANILLA-UNIX-PATHNAME-MIXIN) ()
  (IF (NOT (STRINGP NAME))
      (VALUES NAME VERSION)
    (LET ((END (STRING-REVERSE-SEARCH-NOT-SET *DIGITS* NAME)))
      (IF (OR (NULL END) (= END (1- (STRING-LENGTH NAME))))
	  (VALUES NAME VERSION)
	(VALUES (SUBSTRING NAME 0 (1+ END))
		(SUBSTRING NAME (1+ END) (STRING-LENGTH NAME)))))))

(PUTPROP ':UNIX '(:CANT-SET-AUTHOR) 'ATTRIBUTES)

;;; Support for 4.2 BSD unix with unlimited length file names
(DEFFLAVOR UNIX42-PATHNAME-MIXIN () (GENERAL-UNIX-PATHNAME-MIXIN))

(PUTPROP ':UNIX42 '(:CANT-SET-AUTHOR) 'ATTRIBUTES)

(PUTPROP :ULTRIX '(:CANT-SET-AUTHOR) 'ATTRIBUTES)

(PUTPROP :XENIX '(:CANT-SET-AUTHOR) 'ATTRIBUTES)

;;; Maximum length of any name+type in a unix pathname
(DEFCONST *UNIX42-MAX-COMPONENT-LENGTH* 255.)

(DEFMETHOD (:VALID-COMPONENTS-ALL UNIX42-PATHNAME-MIXIN) (DEV DIR NAM TYP VRS)
  (DECLARE (VALUES DEVICE DIRECTORY NAME TYPE VERSION))
  (WHEN (AND (STRINGP NAM) (STRINGP TYP)
	     (> (+ (STRING-LENGTH NAM) (STRING-LENGTH TYP) 1)
		*UNIX42-MAX-COMPONENT-LENGTH*))
    (LET ((TMAX (MIN (1+ (STRING-LENGTH TYP))	;Type plus "."
		     (1+ (FIX (* 1\3 *UNIX42-MAX-COMPONENT-LENGTH*))))))
      (SETQ NAM (NSUBSTRING NAM 0 (MIN (- *UNIX42-MAX-COMPONENT-LENGTH* TMAX)
				       (STRING-LENGTH NAM)))
	    TYP (SUBSTRING TYP 0 (1- TMAX)))))
  (VALUES DEV DIR NAM TYP VRS))

(DEFMETHOD (:VALID-UNIX-STRING-P UNIX42-PATHNAME-MIXIN :AND) (STRING TYPE-P)
  (<= (PATHNAME-COMPONENT-MIN-LENGTH STRING) (IF TYPE-P
						 (1- *UNIX42-MAX-COMPONENT-LENGTH*)
						 *UNIX42-MAX-COMPONENT-LENGTH*)))

(DEFMETHOD (:VALIDATE UNIX42-PATHNAME-MIXIN :AFTER) ()
  (LET ((MINIMUM-POSSIBLE-LENGTH (SEND SELF :FILENAME-STRING-OUT NIL T)))
    (WHEN (> MINIMUM-POSSIBLE-LENGTH *UNIX42-MAX-COMPONENT-LENGTH*)
      (ERROR 'UNIX-NAME-AND-TYPE-TOO-LONG :PATHNAME SELF
	     :MAX-LENGTH *UNIX42-MAX-COMPONENT-LENGTH*
	     :COMPONENT-VALUE NAME))))


;; Multics family support

(DEFFLAVOR MULTICS-FAMILY-PATHNAME-MIXIN ()
	   (NO-DEVICE-OR-VERSION-MIXIN HIERARCHICAL-DIRECTORY-MIXIN MEANINGFUL-ROOT-MIXIN
	    LOWER-CASE-PREFERRED-MIXIN)
  :ABSTRACT-FLAVOR
  (:REQUIRED-FLAVORS PATHNAME))

(DEFUN-IN-FLAVOR (MULTICS-DIRECTORY-STRING MULTICS-FAMILY-PATHNAME-MIXIN) ()
  (SELECTQ DIRECTORY
    (NIL "")
    (:ROOT "")
    (:WILD (FERROR "Multics pathname can't have :WILD directories."))
    (OTHERWISE
     (IF (LISTP DIRECTORY)
	 (LOOP WITH STRING = (MAKE-ARRAY 32. ':TYPE 'ART-STRING ':FILL-POINTER 0)
	       WITH NEED-> = (NEQ (FIRST DIRECTORY) ':RELATIVE)
	       FOR COMPONENT IN DIRECTORY
	       WHEN NEED->
	       DO (ARRAY-PUSH-EXTEND STRING #/>)
	       DO (SELECTQ COMPONENT
		    (:WILD
		     (STRING-NCONC STRING "**")
		     (SETF NEED-> T))
		    (:WILD-INFERIORS
		     (FERROR "Multics pathnames can't hack :WILD-INFERIORS."))
		    (:RELATIVE)
		    (:UP (ARRAY-PUSH-EXTEND STRING #/<))
		    (NIL (ARRAY-PUSH-EXTEND STRING #\))
		    (OTHERWISE (STRING-NCONC STRING COMPONENT)
			       (SETF NEED-> T)))
	       FINALLY (RETURN STRING))
	 (STRING-APPEND ">" DIRECTORY)))))

(DEFUN-IN-FLAVOR (MULTICS-PATHNAME-FILENAME-STRING MULTICS-FAMILY-PATHNAME-MIXIN) ()
  (SELECTQ TYPE
    (:WILD
     (SELECTQ NAME
       (:WILD "**")
       (NIL ".*.**")
       (OTHERWISE (FORMAT NIL "~A.*.**" NAME))))
    (:UNSPECIFIC
     (SELECTQ NAME
       (:WILD "*")
       (NIL "")
       (OTHERWISE NAME)))
    (NIL
     (SELECTQ NAME
       (:WILD "*.")
       (NIL "")
       (OTHERWISE (FORMAT NIL "~A." NAME))))
    (OTHERWISE
     (FORMAT NIL "~A.~A"
	     (SELECTQ NAME
	       (:WILD "*")
	       (NIL "")
	       (OTHERWISE NAME))
	     TYPE))))

(DEFMETHOD (:DIRECTORY-PATHNAME-AS-FILE MULTICS-FAMILY-PATHNAME-MIXIN)  ()
  (DEFAULT-DIRECTORY-PATHNAME-AS-FILE SELF DIRECTORY))

(DEFMETHOD (:DIRECTORY-FILE-TYPE MULTICS-FAMILY-PATHNAME-MIXIN) ()
  ':UNSPECIFIC)

(DEFMETHOD (:PATHNAME-AS-DIRECTORY MULTICS-FAMILY-PATHNAME-MIXIN) ()
  (FUNCALL-SELF ':NEW-PATHNAME
		':RAW-DIRECTORY (IF (EQ DIRECTORY ':ROOT)
				    NAME
				    (APPEND (IF (LISTP DIRECTORY) DIRECTORY (NCONS DIRECTORY))
					    (NCONS (SELECTQ TYPE
						     ((NIL :UNSPECIFIC) NAME)
						     (OTHERWISE
						      (FORMAT NIL "~A.~A"
							      NAME TYPE))))))
		':RAW-NAME NIL ':RAW-TYPE ':UNSPECIFIC ':VERSION ':UNSPECIFIC))

(DEFMETHOD (:STRING-FOR-HOST MULTICS-FAMILY-PATHNAME-MIXIN) (&OPTIONAL IGNORE)
  (FORMAT NIL "~A>~A"
	  (MULTICS-DIRECTORY-STRING)
	  (MULTICS-PATHNAME-FILENAME-STRING)))

(DEFMETHOD (:STRING-FOR-EDITOR MULTICS-FAMILY-PATHNAME-MIXIN) ()
  (FORMAT NIL "~A ~A ~A:"
	  (MULTICS-PATHNAME-FILENAME-STRING)
	  (MULTICS-DIRECTORY-STRING)
	  (SEND HOST ':NAME-AS-FILE-COMPUTER)))

(DEFMETHOD (:STRING-FOR-DIRECTORY MULTICS-FAMILY-PATHNAME-MIXIN) ()
  (MULTICS-DIRECTORY-STRING))

(DEFMETHOD (:STRING-FOR-DIRED MULTICS-FAMILY-PATHNAME-MIXIN) ()
  (MULTICS-PATHNAME-FILENAME-STRING))

(DEFMETHOD (:PARSE-NAMESTRING MULTICS-FAMILY-PATHNAME-MIXIN)
	   (IGNORE NAMESTRING &OPTIONAL (START 0) END &AUX DIR NAM TYP)
  (UNLESS END (SETQ END (STRING-LENGTH NAMESTRING)))
  (UNLESS (> START END)
    (SETQ START (OR (STRING-SEARCH-NOT-CHAR #\SP NAMESTRING START END) END)))
  (IF (> END START)
      (PROGN
	(LET* ((NUP (LOOP WHILE (CHAR-EQUAL (AREF NAMESTRING START) #/<)
			  COUNT T
			  DO (INCF START)))
	       (DIRX (OR (STRING-REVERSE-SEARCH-CHAR #/> NAMESTRING END START) (1- START)))
	       (TYPX (STRING-SEARCH-CHAR #/. NAMESTRING (1+ DIRX) END)))
	  (COND (TYPX (SETQ NAM (SUBSTRING NAMESTRING (1+ DIRX) TYPX))
		      (SETQ TYP (SUBSTRING NAMESTRING (1+ TYPX) END)))
		((NOT (= DIRX (1- END)))
		 (SETQ NAM (SUBSTRING NAMESTRING (1+ DIRX) END))
		 (SETQ TYP ':UNSPECIFIC)))
	  (SETQ DIR
		(LOOP WITH LIST
		      WITH RELATIVE-P = T
		      UNTIL (< DIRX START)
		      FOR LAST = DIRX THEN FIRST
		      FOR FIRST = (STRING-REVERSE-SEARCH-CHAR #/> NAMESTRING LAST START)
		      DO (IF (= START LAST)
			     (SETQ RELATIVE-P NIL)
			     (LET ((COMPONENT (SUBSTRING NAMESTRING
							 (1+ (OR FIRST (1- START))) LAST)))
			       (PUSH (COND ((STRING-EQUAL COMPONENT "**") ':WILD)
					   ((STRING-EQUAL COMPONENT "") NIL)
					   (T COMPONENT))
				     LIST)))
		      WHILE FIRST
		      FINALLY
		      (IF RELATIVE-P
			  (LOOP REPEAT NUP
				DO (PUSH ':UP LIST)
				FINALLY (PUSH ':RELATIVE LIST))
			  (COND ((NOT (ZEROP NUP))
				 (PARSE-PATHNAME-ERROR
				   "'>' follows '<' in Multics pathname."))
				((NULL LIST) (SETQ LIST ':ROOT))))
		      (RETURN LIST))))
	(SETQ TYP (SELECTOR TYP STRING-EQUAL
		    ("" NIL)
		    (("*" "**" "*.**") ':WILD)
		    (OTHERWISE TYP)))
	(SETQ NAM (SELECTOR NAM STRING-EQUAL
		    ("" NIL)
		    ("*" ':WILD)
		    ("**"
		     (WHEN (EQ TYP ':UNSPECIFIC) (SETQ TYP ':WILD))
		     ':WILD)
		    (OTHERWISE NAM)))
	(VALUES ':UNSPECIFIC DIR NAM TYP ':UNSPECIFIC))
      (VALUES ':UNSPECIFIC NIL NIL NIL ':UNSPECIFIC)))

(DEFMETHOD (:VALID-NAME-P MULTICS-FAMILY-PATHNAME-MIXIN) (NAM)
  (OR (STRINGP NAM) (MEMQ NAM '(NIL :WILD))))

(DEFMETHOD (:VALID-TYPE-P MULTICS-FAMILY-PATHNAME-MIXIN) (TYP)
  (OR (STRINGP TYP) (MEMQ TYP '(NIL :WILD :UNSPECIFIC))))


;;; Multics

(DEFFLAVOR MULTICS-PATHNAME-MIXIN () (MULTICS-MAILBOX-PATHNAME-MIXIN
				      MULTICS-FAMILY-PATHNAME-MIXIN)
  :ABSTRACT-FLAVOR)

(PUTPROP ':MULTICS '(:CANT-SET-CREATION-INFO) 'ATTRIBUTES)


;;; VM/370

(DEFFLAVOR VM370-PATHNAME-MIXIN ()
	   (NO-DIRECTORY-OR-VERSION-MIXIN UPPER-CASE-ONLY-MIXIN)
  (:REQUIRED-FLAVORS PATHNAME))

(DEFMETHOD (:PRIMARY-DEVICE VM370-PATHNAME-MIXIN) () "A")

(DEFMETHOD (:STRING-FOR-HOST VM370-PATHNAME-MIXIN) (&OPTIONAL IGNORE)
  (FORMAT NIL "~A ~A ~A"
	  (STRING-OR-WILD SELF NAME T)
	  (STRING-OR-WILD SELF TYPE T)
	  (STRING-OR-WILD SELF DEVICE T)))

(DEFMETHOD (:VALID-DEVICE-P VM370-PATHNAME-MIXIN) (DEV)
  (OR (NULL DEV)
      (EQ DEV :WILD)
      (AND (STRINGP DEV)
	   (= (STRING-LENGTH DEV) 1)
	   (ALPHA-CHAR-P (AREF DEV 0)))))

(DEFMETHOD (:VALID-DEVICE VM370-PATHNAME-MIXIN) (DEV)
  (IF (SEND SELF :VALID-DEVICE-P DEV)
      DEV
      (SEND SELF :PRIMARY-DEVICE)))

(DEFMETHOD (:VALID-NAME-P VM370-PATHNAME-MIXIN) (NAM) (VM370-VALID-NAME NAM))
(DEFMETHOD (:VALID-TYPE-P VM370-PATHNAME-MIXIN) (TYP) (VM370-VALID-NAME TYP))

(DEFUN VM370-VALID-NAME (COMP)
  (OR (NULL COMP)
      (EQ COMP :WILD)
      (AND (STRINGP COMP)
	   ( 1 (STRING-LENGTH COMP) 8)
	   (LOOP FOR CHAR BEING THE ARRAY-ELEMENTS OF COMP
		 ALWAYS (OR (ALPHA-CHAR-P CHAR)
			    (DIGIT-CHAR-P CHAR)
			    (MEM #'CHAR-EQUAL CHAR '(#\- #\+ #\$ #\# #\@)))))))

(DEFMETHOD (:PARSE-NAMESTRING VM370-PATHNAME-MIXIN)
	   (IGNORE STRING &OPTIONAL (START 0) END &AUX DEV NAM TYP)
  (SETF END (1+ (OR (STRING-REVERSE-SEARCH-NOT-CHAR #\SPACE STRING END START)
		    (1- START))))
  (LET ((I1 (OR (STRING-SEARCH-SET '(#\SPACE #\.) STRING START END)
		END)))
    (SETF NAM (STRING-UPCASE (SUBSTRING STRING START I1)))
    (SELECTOR NAM STRING-EQUAL
      ("" (SETF NAM NIL))
      ("*" (SETF NAM :WILD)))
    (WHEN (< I1 END)
      (IF (CHAR-EQUAL (AREF STRING I1) #\SPACE)
	  (SETF I1 (STRING-SEARCH-NOT-CHAR #\SPACE STRING I1 END))
	  (INCF I1))
      (WHEN I1
	(LET ((I2 (OR (STRING-SEARCH-SET '(#\SPACE #\.) STRING I1 END)
		      END)))
	  (SETF TYP (STRING-UPCASE (SUBSTRING STRING I1 I2)))
	  (SELECTOR TYP STRING-EQUAL
	    ("" (SETF TYP NIL))
	    ("*" (SETF TYP :WILD)))
	  (WHEN (< I2 END)
	    (IF (CHAR-EQUAL (AREF STRING I2) #\SPACE)
		(SETF I2 (STRING-SEARCH-NOT-CHAR #\SPACE STRING I2 END))
		(INCF I2))
	    (WHEN I2
	      (SETF DEV (STRING-UPCASE (SUBSTRING STRING I2 END)))
	      (SELECTOR DEV STRING-EQUAL
		("" (SETF DEV NIL))
		("*" (SETF DEV :WILD)))))))))
  (VALUES DEV :UNSPECIFIC NAM TYP :UNSPECIFIC))
    

(SI:DEFINE-GC-OPTIMIZATION FLUSH-UNTRANSLATABLE-LOGICAL-PATHNAMES :LAYERED-SYSTEM-RELEASE
  (:DOCUMENTATION "Remove all logical pathnames which have no physical counterparts")
  (:ORDER (:BEFORE GC-PATHNAMES))
  (:BEFORE-FLIP (IGNORE)
    (SI:WITH-PROGRESS-REPORT-IF SI:*ENABLE-GC-OPTIMIZATION-REPORTS*
				("flushing untranslatable logical pathnames")
      (LOOP WITH *PATHNAME-INHIBIT-EXPENSIVE-TRANSLATION* = T
	    FOR HOST IN *LOGICAL-PATHNAME-HOST-LIST*
	    DO (LET ((HASH-TABLE (SEND HOST :PATHNAME-HASH-TABLE))
		     (FLUSHCOUNT 0))
		 (MAPHASH (LAMBDA (IGNORE PATHNAME )
			    (WHEN (CATCH 'EXPENSIVE-TRANSLATION
				    (NOT (SEND PATHNAME :TRANSLATABLE-P)))
			      (SEND PATHNAME :REMOVE-LOGICAL-PATHNAME)
			      (INCF FLUSHCOUNT)))
			  HASH-TABLE)
		 (FORMAT T "~&~D pathname~:P without translation flushed from ~A."
			 FLUSHCOUNT HOST))))))

#||
(DEFUN FLUSH-ONE-UNTRANSLATABLE-LOGICAL-PATHNAME (PN)
  (SETQ PN (CL:PATHNAME PN))
  (LET ((*PATHNAME-INHIBIT-EXPENSIVE-TRANSLATION* T))
    (WHEN (CATCH 'EXPENSIVE-TRANSLATION (NOT (SEND PN :TRANSLATABLE-P)))
      (FORMAT T "~&~A untranslatable, all right." PN))))

(DEFUN FIND-NULL-VC-BRANCH-LOGICAL-PATHNAMES (HOST)
  (LOOP WITH HASH-TABLE = (SEND HOST :PATHNAME-HASH-TABLE)
	FOR PATHNAME BEING THE HASH-ELEMENTS OF HASH-TABLE
	WHEN (AND (PATHNAME-VC-VERSION PATHNAME) (NULL (PATHNAME-VC-BRANCH PATHNAME)))
	  COLLECT PATHNAME))

||#

(SI:DEFINE-GC-OPTIMIZATION CONDENSE-PATHNAME-DEFINITIONS-ALISTS :LAYERED-SYSTEM-RELEASE
  (:DOCUMENTATION "Localize all source file definitions lists")
  (:ORDER (:BEFORE GC-PATHNAMES))
  (:BEFORE-FLIP (IGNORE)
    (SI:WITH-PROGRESS-REPORT-IF SI:*ENABLE-GC-OPTIMIZATION-REPORTS*
				("condensing generic pathname definitions alists")
      (LOOP WITH *PATHNAME-INHIBIT-EXPENSIVE-TRANSLATION* = T
	    FOR HOST IN FS:*PATHNAME-HOST-LIST*
	    DO (LOOP WITH HASH-TABLE = (SEND HOST :PATHNAME-HASH-TABLE)
		     FOR PATHNAME BEING THE HASH-ELEMENTS OF HASH-TABLE
		     FOR DEFINITIONS = (CATCH 'EXPENSIVE-TRANSLATION
					 (SEND PATHNAME :GET 'SI:DEFINITIONS))
		     WHEN DEFINITIONS
		       DO (SETF (SEND PATHNAME :GET 'SI:DEFINITIONS)
				(LOOP FOR ALIST ON DEFINITIONS
				      DO (SETF (CAR ALIST) (COPYLIST (CAR ALIST)))
				      FINALLY (RETURN (COPYLIST DEFINITIONS)))))))))

;;; Pathname garbage collection
;;; Note well: this must come -after- the "Flush untranslatable logical pathnames"

(DEFVAR *PATHNAMES-WITH-PROPERTY-LISTS*)
(DEFVAR *PATHNAME-INHIBIT-EXPENSIVE-TRANSLATION* NIL)

(SI:DEFINE-GC-OPTIMIZATION GC-PATHNAMES :LAYERED-SYSTEM-RELEASE
  (:DOCUMENTATION
    "Share components of pathnames, and allow unreferenced pathnames to be GC'd")
  (:ORDER (:AFTER FLUSH-UNTRANSLATABLE-LOGICAL-PATHNAMES))
  (:BEFORE-FLIP (IGNORE)
    ;;; Remove all references to pathnames from hash tables, so that the pathnames
    ;;; that aren't referenced from elsewhere can get garbage-collected.  There are
    ;;; a great many of them, because of intermediate pathnames consed by various
    ;;; pathname-manipulating operations.  Preserve all pathnames that have properties,
    ;;; though, since the interning of pathnames is to guarantee the property list.
    ;;; This relies on FS:PATHNAME-AREA being in FULL-GC-STATIC-AREAS.
    (SI:WITH-PROGRESS-REPORT ("combining pathname strings...")
      (SI:USING-SYSTEM-TEMPORARY-AREA
	;; Do this first.  It will remove VC pathnames from the pathname tables outright.
	;; After they have all been removed (and the objects structure-forwarded), there
	;; should be nothing else which can re-intern them.
	(WHEN (SI:IMMEDIATE-GC-OPTION :REMOVE-VC-INFO)
	  (REMOVE-VERSION-CONTROL-INFO SI:*ENABLE-GC-OPTIMIZATION-REPORTS*))
	(LET ((PATHNAME-STRING-HASH-TABLE
		(CL:MAKE-HASH-TABLE :SIZE 34000. :TEST #'CL:EQUAL :NUMBER-OF-VALUES 0
				    :LOCKING NIL
				    :AREA SI:SYSTEM-TEMPORARY-AREA))
	      (PATHNAME-STRING-COUNT 0)
	      (*PATHNAME-INHIBIT-EXPENSIVE-TRANSLATION* T))
	  (LABELS ((GC-PATHNAME-COMBINE-STRINGS
		      (COMPONENT-LOC)
		     (LET ((STRING (LOCATION-CONTENTS COMPONENT-LOC)))
		       (TYPECASE STRING
			 ((:STRING :LIST)
			  (SCL:MODIFY-HASH
			    PATHNAME-STRING-HASH-TABLE STRING
			    #'(LAMBDA (KEY IGNORE FOUNDP)
				(DECLARE (SYS:DOWNWARD-FUNCTION))
				(IF FOUNDP
				    (PROGN (UNLESS (EQ KEY STRING)
					     (INCF PATHNAME-STRING-COUNT)
					     (SETF (LOCATION-CONTENTS COMPONENT-LOC) KEY))
					   KEY)
				    (PROGN (WHEN (LISTP KEY)
					     (LOOP FOR X ON KEY
						   DO (GC-PATHNAME-COMBINE-STRINGS
							(LOCF (FIRST X)))))
					   (INCF PATHNAME-STRING-COUNT)
					   KEY)))))))))
	    (SETQ *PATHNAMES-WITH-PROPERTY-LISTS* NIL)
	    ;; Do all the logical pathnames first, since otherwise they will
	    ;; put things back in the physical hosts' hash tables.
	    ;; Copy both lists before iterating, because they get destructively
	    ;; modified by pulling hosts to the front.
	    (LOOP WITH HOSTS = (APPEND *LOGICAL-PATHNAME-HOST-LIST* *PATHNAME-HOST-LIST* NIL)
		  FOR HOST IN HOSTS
		  AS HT = (SEND HOST :PATHNAME-HASH-TABLE)
		  AS N-INTERESTING = 0
		  DOING (LOOP FOR P BEING THE HASH-ELEMENTS OF HT DO
			  (CATCH 'EXPENSIVE-TRANSLATION
			    (LET ((PLIST (SEND P :PLIST)))
			      ;; Flush this, only Wobblies ever need it
			      (CL:REMF PLIST :BINARY-SOURCE-FILE-ORIGINAL-TRUENAME)
			      ;; Do this after getting the plist, since getting the plist
			      ;; of a logical-pathname updates its translated-pathname
			      (SEND P :BEFORE-FULL-GC #'GC-PATHNAME-COMBINE-STRINGS)
			      ;; Physical pathnames that correspond to logical ones don't count
			      (UNLESS (AND (CL:GETF PLIST 'BACK-TRANSLATION-ALIST)
					   (NOT (TYPEP P 'LOGICAL-PATHNAME)))
				(WHEN (EQ (CAR PLIST) 'BACK-TRANSLATION-ALIST)
				  (SETQ PLIST (CDDR PLIST)))	;this property doesn't count
				(UNLESS (NULL PLIST)
				  (PUSH-IN-AREA P *PATHNAMES-WITH-PROPERTY-LISTS*
						SI:SYSTEM-TEMPORARY-AREA)
				  (INCF N-INTERESTING))))))
			(SI:GC-OPTIMIZATION-REPORT "~&~:D pathnames on ~A: have properties.~%"
						   N-INTERESTING HOST)
		  COLLECT N-INTERESTING INTO LIST
		  FINALLY
		    (SI:GC-OPTIMIZATION-REPORT "~D strings and lists combined into ~D."
		      PATHNAME-STRING-COUNT
		      (CL:HASH-TABLE-COUNT PATHNAME-STRING-HASH-TABLE))
		    ;; Wait until the end to disable pathname creation, since the :PLIST method
		    ;; above can cause pathnames to be consed.
		    (SETQ *INHIBIT-PATHNAME-CREATION* T)
		    (LOOP FOR HOST IN HOSTS
			  FOR N-INTERESTING IN LIST
			  ;; Instead of clrhash, make a new table that is only
			  ;; as big as the number with property lists.
			  ;; Some pathname without plists may not be garbage,
			  ;; but probably not too many.
			  DO (SEND HOST :PATHNAME-HASH-TABLE T T N-INTERESTING)))
	    (SETQ *PATHNAMES-WITH-PROPERTY-LISTS*
		  (COPYLIST *PATHNAMES-WITH-PROPERTY-LISTS*
			    SI:REORDERING-LIST-AREA))))))
    ;; Condense some data structures
    (SETQ *CANONICAL-TYPES-ALIST* (SI:COPYTREE-AND-LEAVES *CANONICAL-TYPES-ALIST*
							  PERMANENT-STORAGE-AREA)
	  *DEFAULT-CANONICAL-TYPES* (SI:COPYTREE-AND-LEAVES *DEFAULT-CANONICAL-TYPES*
							    PERMANENT-STORAGE-AREA))) 
  (:AFTER-RECLAIM-OLDSPACE (IGNORE)
    ;; Re-enable pathnames globally.
    (SETQ *INHIBIT-PATHNAME-CREATION* NIL)
    (SI:WITH-PROGRESS-REPORT ("interning pathnames")
      (VARIABLE-MAKUNBOUND *PATHNAMES-WITH-PROPERTY-LISTS*)	;It did its job
      (SI:MAP-OVER-OBJECTS-IN-AREA
	PATHNAME-AREA #'SI:REGION-PREDICATE-STRUCTURE
	#'(LAMBDA (IGNORE IGNORE X IGNORE IGNORE)
	    (WHEN (AND (INSTANCEP X) (TYPEP X 'PATHNAME))
	      (CL:SETF (CL:GETHASH
			 (SEND X :HASH-KEY) 
			 (SEND (PATHNAME-HOST X) :PATHNAME-HASH-TABLE))
		       X))))
      ;;Now flush any pathname hosts with only their sample pathname.
      (SETF *PATHNAME-HOST-LIST*
	    (COPYLIST
	      (DEL-IF #'(LAMBDA (HOST)
			  (AND ( (CL:HASH-TABLE-COUNT (SEND HOST :PATHNAME-HASH-TABLE)) 1)
			       (TYPEP HOST 'NET:HOST)))
		      *PATHNAME-HOST-LIST*)
	      PATHNAME-AREA))
      ;;Now restore links between logical and physical pathnames.
      (DOLIST (HOST (COPYLIST *PATHNAME-HOST-LIST*))
	(MAPHASH #'(LAMBDA (IGNORE X)
		     ;; If this is a translation of a logical pathname, link
		     ;; them back together, undoing what was done by
		     ;; (:before-full-gc logical-pathname).
		     ;; Don't do this for logical pathnames, because
		     ;; :GET would re-create physical pathnames.
		     (DOLIST (ELEM (SEND X :GET 'BACK-TRANSLATION-ALIST))
		       (DOLIST (LOGICAL-PATHNAME (CDR ELEM))
			 (SEND LOGICAL-PATHNAME :TRANSLATED-PATHNAME))))
		 (SEND HOST :PATHNAME-HASH-TABLE))))
    (WHEN (SI:IMMEDIATE-GC-OPTION :REMOVE-VC-INFO)
      ;; Disable VC pathname parsing in this world
      (SETQ FS:*VC-PATHNAME-PARSING-ENABLED* NIL))
    NIL))


;;--- This must be updated for each major D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")and0 minor release
(DEFCONST *VC-FILE-VERSION-OFFSET* 3000.)

;; Must be called inside of SI:USING-SYSTEM-TEMPORARY-AREA
(DEFUN REMOVE-VERSION-CONTROL-INFO (&OPTIONAL (REPORT T))
  (LOOP WITH *PATHNAME-INHIBIT-EXPENSIVE-TRANSLATION* = T
	WITH FLUSH-COUNT = 0
	FOR HOST IN (APPEND *LOGICAL-PATHNAME-HOST-LIST* *PATHNAME-HOST-LIST* NIL)
	AS PHT = (SEND HOST :PATHNAME-HASH-TABLE)
	DOING
    (WITH-STACK-ARRAY (REPAIRS (SEND PHT :FILLED-ELEMENTS) :FILL-POINTER 0)
      ;; First create a list of the VC pathnames and what they should turn into
      (LOOP FOR PATHNAME BEING THE HASH-ELEMENTS OF PHT
	    DOING
	(WHEN (PATHNAME-VC-P PATHNAME)
	  (LET ((NEW-PATHNAME (FLATTEN-VERSION-CONTROL-PATHNAME PATHNAME)))
	    ;; Save the old pathname and what it should turn into
	    (ARRAY-PUSH-EXTEND REPAIRS (CONS-IN-AREA PATHNAME NEW-PATHNAME
						     SI:SYSTEM-TEMPORARY-AREA)))))
      ;; Ensure that all of the properties of the old pathname get onto
      ;; the new pathname.  When that's done, forward the old pathname
      ;; object to the new one.  It isn't necessary to remove the old
      ;; pathname from the hash-table, since the rest of the pathname GC
      ;; will flush unused pathnames.
      (LOOP FOR (OLD . NEW) BEING THE ARRAY-ELEMENTS OF REPAIRS 
	    DOING
	(LOOP FOR (INDICATOR VALUE) ON (SEND OLD :PROPERTY-LIST) BY 'CDDR
	      DO (SEND NEW :PUTPROP VALUE INDICATOR))
	(STRUCTURE-FORWARD OLD NEW))
      (INCF FLUSH-COUNT (FILL-POINTER REPAIRS)))
	FINALLY
	  (WHEN REPORT
	    (FORMAT T "~&Replaced ~D Version Control pathnames with flat pathnames"
	      FLUSH-COUNT))))

(DEFUN FLATTEN-VERSION-CONTROL-PATHNAME (PATHNAME)
  (LET* ((VERSION (SEND PATHNAME :VERSION))
	 (VC-VERSION (SEND PATHNAME :VC-VERSION))
	 ;; Here is what this does, if *VC-FILE-VERSION-OFFSET* is 1200:
	 ;;  FOO.LISPDEVO.NEWEST         FOO.LISP
	 ;;  FOO.LISP.NEWESTDEVO.NEWEST  FOO.LISP.NEWEST
	 ;;  FOO.LISPDEVO.2		  FOO.LISP.1202
	 ;;  FOO.LISP.NEWESTDEVO.2	  FOO.LISP.1202
	 ;;  FOO.LISP.1DEVO.2		  FOO.LISP.1202
	 ;;  FOO.LISP.1DEVO.NEWEST	  FOO.LISP.NEWEST
	 (NEW-VERSION (COND ((NUMBERP VC-VERSION)
			     (+ *VC-FILE-VERSION-OFFSET* VC-VERSION))
			    ((OR (EQ VC-VERSION :NEWEST)
				 (NULL VC-VERSION))	;shouldn't happen, but...
			     (IF (NULL VERSION) NIL :NEWEST))
			    (T (FERROR "Don't know how to handle ~A" PATHNAME))))
	 (NEW-PATHNAME (SEND PATHNAME :NEW-PATHNAME
				      :VERSION NEW-VERSION
				      :VC-BRANCH NIL
				      :VC-VERSION NIL)))
    NEW-PATHNAME))

(DEFUN FLAT-VERSION-FROM-VC-VERSION-AND-VERSION (VC-VERSION VERSION)
  (LET* ((NEW-VERSION (COND ((NUMBERP VC-VERSION)
			     (+ *VC-FILE-VERSION-OFFSET* VC-VERSION))
			    ((OR (EQ VC-VERSION :NEWEST)
				 (NULL VC-VERSION))	;shouldn't happen, but...
			     (IF (NULL VERSION) NIL :NEWEST))
			    (T (FERROR "Don't know how to handle ~S x ~S"
				 VC-VERSION VERSION)))))
    NEW-VERSION))
