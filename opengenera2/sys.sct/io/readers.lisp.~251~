;; -*- Base: 8; Mode: Lisp; Package: System-internals -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;; Functions for reading different things from streams.
;; Written by Carl Hoffman for Release 6.

;; The first group of functions in this file reads from either interactive or non-interactive
;; streams, and reads from STANDARD-INPUT by default.  The second group of functions reads
;; only from interactive streams, and reads from QUERY-IO by default.

(DEFCONST KBD-STANDARD-INTERCEPTED-CHARACTERS
	  '(#\ABORT #\m-ABORT #\SUSPEND #\m-SUSPEND))

(DEFCONST KBD-STANDARD-ABORT-CHARACTERS
	  '(#\ABORT #\m-ABORT))

(DEFCONST KBD-STANDARD-SUSPEND-CHARACTERS
	  '(#\SUSPEND #\m-SUSPEND))

(DEFVAR-RESETTABLE KBD-INTERCEPTED-CHARACTERS KBD-STANDARD-INTERCEPTED-CHARACTERS)

(DEFMACRO CHECK-DELIMITER-ARG (VAR)
  `(CHECK-ARG ,VAR
	      (OR (CHARACTERP ,VAR)
		  (AND (CL:LISTP ,VAR) (EVERY ,VAR #'CHARACTERP)))
	      "a character, a list of characters, or NIL"))

(DEFMACRO CHECK-BASE-ARG (VAR)
  `(CHECK-ARG ,VAR
	      (OR (NULL ,VAR) (FIXP ,VAR))
	      "an integer or NIL"))

;; Cons the buffer before entering the input editor so that we don't re-cons it each time
;; the input editor forces a rescan.  If we throw out of this function, then RETURN-ARRAY
;; the buffer.

(DEFUN READ-DELIMITED-STRING
       (&OPTIONAL (DELIMITERS #\END) STREAM (EOF NIL) &REST MAKE-ARRAY-ARGS)
  (DECLARE
    (ARGLIST
      &OPTIONAL (DELIMITERS #\END) (STREAM STANDARD-INPUT) (EOF NIL)
      &REST (MAKE-ARRAY-ARGS '(100. :TYPE ART-STRING))))
  (DECLARE (VALUES STRING EOF DELIMITER DELIMITER-ARG))
  (OR STREAM (SETQ STREAM STANDARD-INPUT))
  (CHECK-DELIMITER-ARG DELIMITERS)
  ;; In Rel 6, this function accepted an INPUT-EDITOR-OPTIONS argument before the &REST
  ;; argument.  Allow NIL there now for compatibility.  Flush this code in Rel 8.
  (IF (AND MAKE-ARRAY-ARGS (NULL (CAR MAKE-ARRAY-ARGS)))
      (POP MAKE-ARRAY-ARGS))
  ;; DELIMITERS may be either a character or a list of characters.
  (COERCE-TO-LIST DELIMITERS
    ;; Merge :TYPE 'ART-STRING into MAKE-ARRAY-ARGS, if a :TYPE option isn't present already.
    (WITH-STACK-LIST* (REAL-MAKE-ARRAY-ARGS NIL :TYPE 'ART-STRING (CDR MAKE-ARRAY-ARGS))
      (IF (MEMQ :TYPE MAKE-ARRAY-ARGS) (SETQ REAL-MAKE-ARRAY-ARGS MAKE-ARRAY-ARGS))
      (SETF (CAR REAL-MAKE-ARRAY-ARGS) (OR (CAR MAKE-ARRAY-ARGS) 100.))
      (LET ((BUFFER NIL))
	(UNWIND-PROTECT
	    (MULTIPLE-VALUE-PROG1
	      (PROGN
		(SETQ BUFFER (APPLY #'MAKE-ARRAY REAL-MAKE-ARRAY-ARGS))
		;; Don't set up activation characters if already in the input editor.
		;; This is important for READLINE since <Return> cannot be an activation
		;; character if several lines are being read in one editing context.
		(WITH-INPUT-EDITING-OPTIONS-IF (AND DELIMITERS (NOT RUBOUT-HANDLER))
					       ((:ACTIVATION 'MEMQ DELIMITERS))
		  ;; If invoking the input editor, then blips will delimit the string so that
		  ;; the delimiters can be quoted, so don't pass the delimiters on to
		  ;; READ-DELIMITED-STRING-INTERNAL.
		  (LET ((OLD-STATE RUBOUT-HANDLER))
		    (WITH-INPUT-EDITING (STREAM)
		      (READ-DELIMITED-STRING-INTERNAL
			(IF (OR OLD-STATE (NOT RUBOUT-HANDLER)) DELIMITERS)
			STREAM EOF BUFFER)))))
	      (SETQ BUFFER NIL))
	  (IF BUFFER (RETURN-ARRAY BUFFER)))))))

;; If END is non-NIL, then this function has not been called by READ-DELMITED-STRING and this
;; function should return when the array is filled rather than calling ADJUST-ARRAY-SIZE.  If
;; the array has a fill-pointer, then keep updating it for the benefit of input editor
;; commands which may wish to look at the buffer.

(DEFUN READ-DELIMITED-STRING-INTERNAL (DELIMITERS STREAM EOF BUFFER &OPTIONAL BEGIN END)
  (DECLARE (VALUES STRING EOF DELIMITER DELIMITER-ARG ENDING-INDEX))
  (LOOP WITH LENGTH = (ARRAY-LENGTH BUFFER)
	FOR INDEX FROM (OR BEGIN 0) DO
	(WHEN (ARRAY-HAS-LEADER-P BUFFER)
	  (SETF (FILL-POINTER BUFFER) INDEX))
	(WHEN (AND END ( INDEX END))
	  (RETURN (VALUES BUFFER NIL NIL NIL INDEX)))
	AS CHAR = (SEND STREAM :ANY-TYI EOF) DO
	(COND ((OR (NULL CHAR)
		   (LISTP CHAR)
		   (MEM #'CHAR-EQUAL CHAR DELIMITERS))
	       (LET (RETURN-CHAR RETURN-ARG)
		 (COND ((LISTP CHAR)
			(IF (NEQ (FIRST CHAR) :ACTIVATION)
			    (FERROR "Unexpected blip returned by the input editor - ~S" CHAR))
			(SETQ RETURN-CHAR (SECOND CHAR) RETURN-ARG (THIRD CHAR)))
		       ((CHARACTERP CHAR)
			(SETQ RETURN-CHAR CHAR)))
		 ;; This can only make the buffer smaller, so no need to save the value
		 ;; returned by ADJUST-ARRAY-SIZE.
		 (UNLESS (OR (ARRAY-HAS-LEADER-P BUFFER) END)
		   (ADJUST-ARRAY-SIZE BUFFER INDEX))
		 (IF END
		     (RETURN (VALUES BUFFER (NULL CHAR) RETURN-CHAR RETURN-ARG INDEX))
		     (RETURN (VALUES BUFFER (NULL CHAR) RETURN-CHAR RETURN-ARG)))))
	      (T (WHEN (CHAR-FAT-P CHAR)
		   (IF (AND END (NOT (ASSURE-FAT-STRING BUFFER T)))
		       (FERROR "Attempt to read the character ~O into an array of type ~A.~@
				An array of type ART-FAT-STRING or ART-16B is needed."
			       CHAR (ARRAY-TYPE BUFFER))
		       (SETQ BUFFER (ASSURE-FAT-STRING BUFFER))))
		 (WHEN (= INDEX LENGTH)
		   (SETQ BUFFER
			 (ADJUST-ARRAY-SIZE
			   BUFFER 
			   (INCF LENGTH
				 (IF (< (%STRUCTURE-TOTAL-SIZE BUFFER) PAGE-SIZE)
				     (MAX (ARRAY-LENGTH BUFFER) 100.)
				     (// (ARRAY-LENGTH BUFFER) 4))))))
		 (ASET CHAR BUFFER INDEX)))))

;No recursive-p argument is necessary because the input being read does not
;contain expressions.  The eof arguments are necessary, unlike for CL:READ-DELIMITED-LIST,
;because the input being read is not necessarily enclosed in balanced delimiters.
(DEFUN SCL:READ-DELIMITED-STRING (DELIMITERS &OPTIONAL STREAM EOF-ERROR-P EOF-VALUE
				  &REST MAKE-ARRAY-ARGS)
  (DECLARE (VALUES STRING EOF-VALUE DELIMITER DELIMITER-ARG))
  (MULTIPLE-VALUE-BIND (STRING EOF DELIMITER DELIMITER-ARG)
      (LEXPR-FUNCALL #'READ-DELIMITED-STRING DELIMITERS STREAM
		     (AND EOF-ERROR-P "READ-DELIMITED-STRING reached EOF before a delimiter")
		     MAKE-ARRAY-ARGS)
    (VALUES STRING (AND EOF EOF-VALUE) DELIMITER DELIMITER-ARG)))

;; EOF-OPTION is a value to return if EOF is encountered before reading
;; any characters.  The second value returned (EOF) is T if the EOF was
;; seen, nil if not.  READ-DELIMITED-STRING-INTERNAL is called instead
;; of READ-DELIMITED-STRING when invoking the input editor from this
;; function so that the buffer won't be reconsed each time a rescan
;; occurs.  The input editor must be invoked from this function, rather
;; than inside READ-DELIMITED-STRING, so that echoing the newline works
;; correctly.  The :LINE keyword to WITH-INPUT-EDITING must be used for
;; correct interaction with preemptable reading.
(DEFUN READLINE (&REST READ-ARGS)
  (DECLARE (ARGLIST &OPTIONAL (STREAM STANDARD-INPUT) EOF-OPTION))
  (DECLARE (VALUES STRING EOF DELIMITER DELIMITER-ARG))
  (MACROLET ((RETURN-VALUES-FOR-READLINE (READ-FORM)
	       `(MULTIPLE-VALUE-BIND (STRING EOF DELIMITER DELIMITER-ARG)
		    ,READ-FORM
		  (IF (AND EOF (STRING-EQUAL "" STRING))
		      (VALUES (READLINE-EOF STREAM EOF-OPTION) EOF DELIMITER DELIMITER-ARG)
		      (VALUES STRING EOF DELIMITER DELIMITER-ARG)))))
    (MULTIPLE-VALUE-BIND (STREAM EOF-OPTION)
	(DECODE-READ-ARGS READ-ARGS T)
      (COND
	;; If already inside the input editor, then return a string delimited by a newline.
	(RUBOUT-HANDLER
	 (RETURN-VALUES-FOR-READLINE
	   (READ-DELIMITED-STRING #\RETURN STREAM)))
	;; If the stream is interactive, then invoke the input editor.
	;; Echo a newline after reading the string, but not if the input was preempted.
	;; (:PREEMPTABLE or :FULL-RUBOUT)
	((SEND STREAM :INTERACTIVE)
	 (LET ((BUFFER NIL))
	   (UNWIND-PROTECT
	       (PROGN
		 (SETQ BUFFER (MAKE-ARRAY 100. :TYPE 'ART-STRING))
		 (MULTIPLE-VALUE-PROG1
		   (WITH-INPUT-EDITING (STREAM :LINE)
		     (RETURN-VALUES-FOR-READLINE
		       (READ-DELIMITED-STRING-INTERNAL NIL STREAM NIL BUFFER)))
		   (SETQ BUFFER NIL)))
	     (IF BUFFER (RETURN-ARRAY BUFFER)))))
	;; If the stream does line-reading and is not an interactive stream, let it do the work.
	((OPERATION-HANDLED-P STREAM :LINE-IN)
	 (RETURN-VALUES-FOR-READLINE (SEND STREAM ':LINE-IN T)))
	;; If we see an immediate EOF, return EOF to the caller.
	;; Otherwise, take the characters up to EOF as a line, but return a second value of T.
	(T 
	 (LET ((CHAR (SEND STREAM :TYI)))
	   (COND ((NULL CHAR)
		  (VALUES (READLINE-EOF STREAM EOF-OPTION) 'T NIL NIL))
		 (T
		  (SEND STREAM ':UNTYI CHAR)
		  (RETURN-VALUES-FOR-READLINE
		    (READ-DELIMITED-STRING #\RETURN STREAM))))))))))

(DEFUN READLINE-EOF (STREAM EOF-OPTION)
  (IF (EQ EOF-OPTION 'NO-EOF-OPTION)
      (ERROR 'END-OF-FILE ':STREAM STREAM ':FORMAT-STRING "READLINE encountered an EOF in ~S")
      EOF-OPTION))

;; Trim Return as well as Space and Tab since the user might accidentally type c-O
;; at the end of the line in the input editor.

(DEFUN READLINE-TRIM (&OPTIONAL (STREAM STANDARD-INPUT) (EOF-OPTION 'NO-EOF-OPTION))
  (DECLARE (VALUES STRING EOF DELIMITER DELIMITER-ARG))
  (MULTIPLE-VALUE-BIND (STRING EOF DELIMITER DELIMITER-ARG)
      (READLINE STREAM EOF-OPTION)
    (VALUES (IF (STRINGP STRING) (STRING-TRIM-WHITESPACE STRING) STRING)
	    EOF DELIMITER DELIMITER-ARG)))

;; Like READLINE-TRIM, except returns NIL instead of the empty string.

(DEFUN READLINE-OR-NIL (&OPTIONAL (STREAM STANDARD-INPUT) (EOF-OPTION 'NO-EOF-OPTION))
  (DECLARE (VALUES STRING-OR-NIL EOF DELIMITER DELIMITER-ARG))
  (MULTIPLE-VALUE-BIND (STRING EOF DELIMITER DELIMITER-ARG)
      (READLINE-TRIM STREAM EOF-OPTION)
    (VALUES (IF (AND STRING (PLUSP (STRING-LENGTH STRING))) STRING)
	    EOF DELIMITER DELIMITER-ARG)))

;; General purpose parser for reading an object on a line, and then parsing it after trimming
;; the whitespace.

(DEFPROP BLANK-LINE-ERROR T :ERROR-REPORTER)

(DEFUN BLANK-LINE-ERROR (STREAM)
  (IF RUBOUT-HANDLER
      (SEND STREAM :BEEP)
      (FERROR "Blank line read from ~S" STREAM)))

(DEFUN READ-TOKEN (&OPTIONAL STREAM OR-NIL PARSE-FUNCTION &REST PARSE-ARGS)
  (DECLARE (DOWNWARD-FUNARG PARSE-FUNCTION))
  (OR STREAM (SETQ STREAM STANDARD-INPUT))
  (OR PARSE-FUNCTION (SETQ PARSE-FUNCTION #'CL:IDENTITY))
  (WITH-INPUT-EDITING (STREAM :LINE)
    (LOOP FOR STRING = (READLINE-OR-NIL STREAM) DO
	  (COND (STRING
		 (RETURN (VALUES (LEXPR-FUNCALL PARSE-FUNCTION STRING PARSE-ARGS)
				 STRING)))
		(OR-NIL
		 (RETURN NIL))
		(T (BLANK-LINE-ERROR STREAM))))))

;; General purpose parsers for reading a list of objects on a line, separated by commas or
;; whitespace.  READ-STRING-LIST and READ-STRING-LIST-FROM-STRING take exactly the same
;; parsers.  The difference between (READ-STRING-LIST) and (READ-STRING-LIST-FROM-STRING
;; (READLINE)) is that parse-time errors are signalled immediately in the former.

(DEFUN READ-STRING-LIST (&OPTIONAL STREAM (DELIMITERS #/,) (OR-NIL T)
			 PARSE-FUNCTION &REST PARSE-ARGS)
  (DECLARE (DOWNWARD-FUNARG PARSE-FUNCTION))
  (OR STREAM (SETQ STREAM STANDARD-INPUT))
  (OR PARSE-FUNCTION (SETQ PARSE-FUNCTION #'STRING-TRIM-WHITESPACE))
  (CHECK-DELIMITER-ARG DELIMITERS)
  (COERCE-TO-LIST DELIMITERS
    (WITH-STACK-LIST* (NEW-DELIMITERS #\RETURN DELIMITERS)
      (UNLESS (AND (SEND STREAM :INTERACTIVE) (NOT RUBOUT-HANDLER))
	(SETF DELIMITERS NEW-DELIMITERS))
      (WITH-INPUT-EDITING (STREAM :LINE)
	(LOOP WITH CHAR
	      WITH STRING
	      FOR OR-NIL = OR-NIL THEN T
	      DO (LOOP DO (SETQ CHAR (SEND STREAM :ANY-TYI))
		       WHILE (OR (AND (LISTP CHAR)
				      (NOT OR-NIL)
				      (PROGN (BLANK-LINE-ERROR STREAM) T))
				 (AND (CHARACTERP CHAR)
				      (MEM #'CHAR-EQUAL CHAR DELIMITERS))))
	      WHILE (AND (CHARACTERP CHAR) (NOT (CHAR-EQUAL CHAR #\RETURN)))
	      DO (SEND STREAM :UNTYI CHAR)
	      (MULTIPLE-VALUE (STRING NIL CHAR)
		(READ-DELIMITED-STRING DELIMITERS STREAM))
	      COLLECT (LEXPR-FUNCALL PARSE-FUNCTION STRING PARSE-ARGS)
	      WHILE (AND (CHARACTERP CHAR)
			 (NOT (CHAR-EQUAL CHAR #\RETURN))
			 (MEM #'CHAR-EQUAL CHAR DELIMITERS)))))))

(DEFUN READ-STRING-LIST-FROM-STRING (STRING &OPTIONAL (START 0) END (DELIMITERS #/,)
				     PARSE-FUNCTION &REST PARSE-ARGS)
  (DECLARE (DOWNWARD-FUNARG PARSE-FUNCTION))
  (OR END (SETQ END (STRING-LENGTH STRING)))
  (OR PARSE-FUNCTION (SETQ PARSE-FUNCTION #'STRING-TRIM-WHITESPACE))
  (COERCE-TO-LIST DELIMITERS
    (LOOP FOR I = (STRING-SEARCH-NOT-SET DELIMITERS STRING (OR J START) END)
	  WHILE I
	  FOR J = (STRING-SEARCH-SET DELIMITERS STRING I END)
	  COLLECT (LEXPR-FUNCALL PARSE-FUNCTION (SUBSTRING STRING I (OR J END)) PARSE-ARGS)
	  WHILE J)))

(DEFUN READ-STRING-LIST-WITH-STRING (&OPTIONAL STREAM (DELIMITERS #/,) (OR-NIL T)
				     PARSE-FUNCTION &REST PARSE-ARGS)
  (DECLARE (DOWNWARD-FUNARG PARSE-FUNCTION))
  (OR STREAM (SETQ STREAM STANDARD-INPUT))
  (OR PARSE-FUNCTION (SETQ PARSE-FUNCTION #'STRING-TRIM-WHITESPACE))
  (CHECK-DELIMITER-ARG DELIMITERS)
  (WITH-INPUT-EDITING (STREAM :LINE)
    (LOOP FOR STRING = (READLINE-OR-NIL STREAM) DO
	  (COND (STRING
		 (RETURN (LEXPR-FUNCALL #'READ-STRING-LIST-FROM-STRING
					STRING 0 NIL DELIMITERS
					PARSE-FUNCTION PARSE-ARGS)))
		(OR-NIL (RETURN NIL))
		(T (BLANK-LINE-ERROR STREAM))))))

(DEFUN READ-TOKEN-LIST (&OPTIONAL STREAM (OR-NIL T) PARSE-FUNCTION &REST PARSE-ARGS)
  (DECLARE (DOWNWARD-FUNARG PARSE-FUNCTION))
  (LEXPR-FUNCALL #'READ-STRING-LIST STREAM '(#\SPACE #\TAB #\,) OR-NIL
		 PARSE-FUNCTION PARSE-ARGS))

(DEFUN READ-TOKEN-LIST-FROM-STRING (&OPTIONAL STRING PARSE-FUNCTION &REST PARSE-ARGS)
  (DECLARE (DOWNWARD-FUNARG PARSE-FUNCTION))
  (LEXPR-FUNCALL #'READ-STRING-LIST-FROM-STRING STRING 0 NIL '(#\SPACE #\TAB #\,)
		 PARSE-FUNCTION PARSE-ARGS))

(DEFUN READ-TOKEN-LIST-WITH-STRING
       (&OPTIONAL STREAM (OR-NIL T) PARSE-FUNCTION &REST PARSE-ARGS)
  (DECLARE (DOWNWARD-FUNARG PARSE-FUNCTION))
  (LEXPR-FUNCALL #'READ-STRING-LIST-WITH-STRING STREAM '(#\SPACE #\TAB #\,) OR-NIL
		 PARSE-FUNCTION PARSE-ARGS))

;; Don't use PARSE-NUMBER since it only knows now to parse integers.
;; READ-NUMBER can be used to read any Lisp object which is NUMBERP.
;; READ-INTEGER can be used to read any Lisp object which is FIXP.

(DEFUN PARSE-NUMBER-INTERNAL (STRING INPUT-BASE)
  (LET ((IBASE INPUT-BASE)
	(*READ-EXTENDED-IBASE-SIGNED-NUMBER* T)
	(*READ-EXTENDED-IBASE-UNSIGNED-NUMBER* T))
    (IGNORE-ERRORS (READ-FROM-STRING STRING))))

(DEFUN PARSE-NUMBER-1 (STRING OR-NIL INPUT-BASE)
  (UNLESS INPUT-BASE (SETQ INPUT-BASE 10.))
  (LET ((NUMBER (PARSE-NUMBER-INTERNAL STRING INPUT-BASE)))
    (IF (NUMBERP NUMBER)
	NUMBER
	(PARSE-FERROR
	  "~[~8;An octal number~10;A decimal number~:;A number in base ~:*~D~]~
	   ~:[~;, or ~ for none,~] is required."
	  INPUT-BASE OR-NIL #\RETURN))))

(DEFUN READ-NUMBER (&OPTIONAL STREAM INPUT-BASE OR-NIL)
  (CHECK-BASE-ARG INPUT-BASE)
  (READ-TOKEN STREAM OR-NIL #'PARSE-NUMBER-1 OR-NIL INPUT-BASE))

(DEFUN READ-NUMBER-LIST (&OPTIONAL STREAM INPUT-BASE (OR-NIL T))
  (CHECK-BASE-ARG INPUT-BASE)
  (READ-TOKEN-LIST STREAM OR-NIL #'PARSE-NUMBER-1 OR-NIL INPUT-BASE))

(DEFUN PARSE-INTEGER (STRING OR-NIL INPUT-BASE FROM TO)
  (UNLESS INPUT-BASE (SETQ INPUT-BASE 10.))
  (LET ((INTEGER (PARSE-NUMBER-INTERNAL STRING INPUT-BASE)))
    (IF (AND (FIXP INTEGER)
	     (OR (NOT FROM) ( INTEGER FROM))
	     (OR (NOT TO) ( INTEGER TO)))
	INTEGER
	(PARSE-FERROR
	  "~[~8;An octal integer~10;A decimal integer~:;An integer in base ~:*~D~]~
	   ~:[~4*~; between ~VR and ~VR~]~
	   ~:[~2*~; greater than or equal to ~VR~]~
	   ~:[~2*~; less than or equal to ~VR~]~
	   ~:[~;, or ~ for none,~] is required."
	  INPUT-BASE
	  (AND FROM TO) INPUT-BASE FROM INPUT-BASE TO
	  (AND FROM (NOT TO)) INPUT-BASE FROM
	  (AND (NOT FROM) TO) INPUT-BASE TO
	  OR-NIL #\RETURN))))

(DEFUN READ-INTEGER (&OPTIONAL STREAM INPUT-BASE OR-NIL FROM TO)
  (CHECK-BASE-ARG INPUT-BASE)
  (READ-TOKEN STREAM OR-NIL #'PARSE-INTEGER OR-NIL (OR INPUT-BASE 10.) FROM TO))

(DEFUN READ-INTEGER-LIST (&OPTIONAL STREAM INPUT-BASE (OR-NIL T) FROM TO)
  (CHECK-BASE-ARG INPUT-BASE)
  (READ-TOKEN-LIST STREAM OR-NIL #'PARSE-INTEGER OR-NIL (OR INPUT-BASE 10.) FROM TO))

(DEFUN PARSE-DATE (STRING PAST-P NEVER-P BASE-TIME)
  (IF (AND NEVER-P (EQUAL STRING "never"))
      NIL
      (WITH-PARSE-FERROR (TIME:PARSE-ERROR)
	(TIME:PARSE-UNIVERSAL-TIME STRING 0 NIL (NOT PAST-P) BASE-TIME))))

(DEFUN READ-DATE (&OPTIONAL STREAM PAST-P NEVER-P BASE-TIME OR-NIL)
  (READ-TOKEN STREAM OR-NIL #'PARSE-DATE PAST-P NEVER-P BASE-TIME))

(DEFUN PARSE-INTERVAL-OR-NEVER (STRING)
  (WITH-PARSE-FERROR (TIME:PARSE-ERROR)
    (TIME:PARSE-INTERVAL-OR-NEVER STRING)))

(DEFUN READ-INTERVAL-OR-NEVER (&OPTIONAL STREAM OR-NIL)
  (READ-TOKEN STREAM OR-NIL #'PARSE-INTERVAL-OR-NEVER))

(DEFUN PARSE-KEYWORD (STRING)
  (INTERN1 (STRING-UPCASE-IF-NECESSARY STRING) PKG-KEYWORD-PACKAGE))

(DEFUN READ-KEYWORD (&OPTIONAL STREAM OR-NIL)
  (READ-TOKEN STREAM OR-NIL #'PARSE-KEYWORD))

(DEFUN READ-KEYWORD-LIST (&OPTIONAL STREAM (OR-NIL T))
  (READ-TOKEN-LIST STREAM OR-NIL #'PARSE-KEYWORD))

(DEFUN PARSE-CLASS (STRING)
  (LET ((KEYWORD (INTERN1 (STRING-UPCASE-IF-NECESSARY STRING) PKG-KEYWORD-PACKAGE)))
    (UNLESS (MEMQ KEYWORD NETI:*ALL-CLASSES*)
      (PARSE-FERROR "~A is not a known class." KEYWORD))
    KEYWORD))

(DEFUN READ-CLASS (&OPTIONAL STREAM OR-NIL)
  (READ-TOKEN STREAM OR-NIL #'PARSE-CLASS))

(DEFUN READ-CLASS-LIST (&OPTIONAL STREAM (OR-NIL T))
  (READ-TOKEN-LIST STREAM OR-NIL #'PARSE-CLASS))

(DEFUN PARSE-ANY-FONT (STRING &OPTIONAL NO-ERROR-P LOADED-P)
  (SETQ STRING (STRING-UPCASE-IF-NECESSARY STRING))
  (LET ((SYMBOL (INTERN-SOFT STRING PKG-FONTS-PACKAGE)))
    (IF (AND SYMBOL
	     (OR (NULL LOADED-P)
		 (BOUNDP SYMBOL)))
	(IF (BOUNDP SYMBOL)
	    (SYMEVAL SYMBOL)
	    SYMBOL)
	(IF NO-ERROR-P
	    NIL
	    (PARSE-FERROR "~A is not a known font." STRING)))))

(DEFUN PARSE-FONT (STRING)
  (SETQ STRING (STRING-UPCASE-IF-NECESSARY STRING))
  (LET ((SYMBOL (INTERN-SOFT STRING PKG-FONTS-PACKAGE)))
    (IF (AND SYMBOL (BOUNDP SYMBOL))
	(SYMEVAL SYMBOL)
	(PARSE-FERROR "~A is not a known font." STRING))))

(DEFUN READ-FONT (&OPTIONAL STREAM OR-NIL)
  (READ-TOKEN STREAM OR-NIL #'PARSE-FONT))

(DEFUN READ-FONT-LIST (&OPTIONAL STREAM (OR-NIL T))
  (READ-TOKEN-LIST STREAM OR-NIL #'PARSE-FONT))

;; Only echo a newline if some input is typed or NO-NEWLINE is NIL.  Otherwise, don't
;; echo anything so that a default or "[None]" can be displayed after the prompt.
;; Returned values:
;;  1) A pathname, possibly taken from a default.
;;  2) The actual string typed, or NIL if an activation character was typed immediately.
;;  3) The activation character -- Return, Line, or End.

(defsubst mem-char (char list)
  (cl:member char list :test #'char-equal))

(defsubst ass-char (char list)
  (cl:find char list :test #'char-equal :key #'car))

(DEFUN READ-PATHNAME (&OPTIONAL STREAM DEFAULT (DEFAULT-VERSION :NEWEST DEFAULT-VERSION-P)
		      NO-NEWLINE
		      &AUX TYPE)
  (DECLARE (VALUES PATHNAME STRING DELIMITER))
  (OR STREAM (SETQ STREAM STANDARD-INPUT))
  ;; Here we handle a default of NIL, a pathname, a defaults-alist, or a string.
  ;; We produce a fully-specified pathname from this.  Be careful not to break
  ;; this to not take a default-alist.  --RWK
  (SETQ DEFAULT (FS:COERCE-PATHNAME-DEFAULTS DEFAULT))
  ;; If a default version is given, make sure it is valid before entering WITH-PARSE-FERROR.
  (WHEN DEFAULT-VERSION-P 
    (FS:MERGE-PATHNAMES "x" NIL DEFAULT-VERSION))
  (SETQ TYPE (SEND DEFAULT :TYPE))
  (WITH-INPUT-EDITING-OPTIONS ((:INPUT-HISTORY-DEFAULT (STRING DEFAULT))
			       (:ACTIVATION 'MEM-CHAR '(#\RETURN #\LINE #\END #\COMPLETE)))
    (WITH-INPUT-EDITING (STREAM)
      (MULTIPLE-VALUE-BIND (STRING IGNORE DELIMITER)
	  (READLINE-OR-NIL STREAM)
	(COND ((OR (EQL DELIMITER #\COMPLETE)
		   (AND (EQL DELIMITER #\END) STRING))
	       (MULTIPLE-VALUE-BIND (COMPLETE-STRING SUCCESS)
		   (FS:COMPLETE-PATHNAME
		     DEFAULT (OR STRING "") TYPE DEFAULT-VERSION :READ)
		 (SEND STREAM :REPLACE-INPUT NIL COMPLETE-STRING)
		 (COND ((AND (EQ SUCCESS :OLD) (CHAR-EQUAL DELIMITER #\END))
			(IF (NOT NO-NEWLINE) (SEND STREAM :TYO #\NEWLINE))
			(VALUES (FS:MERGE-PATHNAMES COMPLETE-STRING DEFAULT DEFAULT-VERSION)
				COMPLETE-STRING
				DELIMITER))
		       (T (IF (NULL SUCCESS) (SEND STREAM :BEEP))
			  (SEND STREAM :FORCE-RESCAN)))))
	      (T (IF (OR STRING (NOT NO-NEWLINE)) (SEND STREAM :TYO #\NEWLINE))
		 (IF (NOT STRING)
		     (VALUES DEFAULT NIL DELIMITER)
		     (WITH-PARSE-FERROR (FS:PATHNAME-ERROR)
		       (VALUES (FS:MERGE-PATHNAMES STRING DEFAULT DEFAULT-VERSION)
			       STRING
			       DELIMITER)))))))))

(DEFUN READ-PATHNAME-LIST (&OPTIONAL STREAM DEFAULT (OR-NIL T))
  (READ-STRING-LIST STREAM #/, OR-NIL
		    (LAMBDA (STRING DEFAULT)
		      (WITH-PARSE-FERROR (FS:PATHNAME-ERROR)
			(FS:MERGE-PATHNAMES STRING DEFAULT)))
		    DEFAULT))

(DEFUN READ-FUNCTION-SPEC (&OPTIONAL STREAM DEFINED-P)
  (OR STREAM (SETQ STREAM STANDARD-INPUT))
  (WITH-INPUT-EDITING (STREAM :END-ACTIVATION)
    (LET ((FORM (READ STREAM)))
      (IF (AND (LISTP FORM)
	       (= (LENGTH FORM) 2)
	       (MEMQ (CAR FORM) '(QUOTE FUNCTION))
	       (VALIDATE-FUNCTION-SPEC (CADR FORM)))
	  (SETQ FORM (CADR FORM)))
      (COND ((NOT (VALIDATE-FUNCTION-SPEC FORM))
	     (PARSE-FERROR "~S is not a valid function spec." FORM))
	    ((AND DEFINED-P (NOT (FDEFINEDP FORM)))
	     (PARSE-FERROR "~S is not a defined function." FORM))
	    (T FORM)))))

(DEFMACRO CHECK-CLASS-ARG (CLASS)
  `(PROGN
     (WHEN (STRINGP ,CLASS)
       (SETQ ,CLASS (INTERN (STRING-UPCASE-IF-NECESSARY ,CLASS) PKG-KEYWORD-PACKAGE)))
     (CHECK-ARG ,CLASS
		(MEMQ ,CLASS NETI:*ALL-CLASSES*)
		"the name of a class")))

(DEFUN PARSE-OBJECT (STRING CLASS)
  (WITH-PARSE-FERROR (NET:OBJECT-NOT-FOUND)
    (NET:FIND-OBJECT-NAMED CLASS STRING)))

(DEFUN READ-OBJECT (&OPTIONAL STREAM CLASS OR-NIL)
  (CHECK-CLASS-ARG CLASS)
  (READ-TOKEN STREAM OR-NIL #'PARSE-OBJECT CLASS))

(DEFUN READ-OBJECT-LIST (&OPTIONAL STREAM CLASS (OR-NIL T))
  (CHECK-CLASS-ARG CLASS)
  (READ-TOKEN-LIST-WITH-STRING STREAM OR-NIL #'PARSE-OBJECT CLASS))

;; HOST-TYPE must be one of:
;;   :PHYSICAL    -- Input must be accepted by NET:PARSE-HOST
;;   :CHAOS-ONLY  -- Input must be accepted by NET:PARSE-HOST and must have a chaos address
;;   :OR-LOCAL    -- Input must either be "local" or accepted by NET:PARSE-HOST
;;   :PATHNAME    -- Input must either be accepted by FS:GET-PATHNAME-HOST (which also accepts "local")
;;   :OR-PATHNAME -- Input must either be accepted by FS:GET-PATHNAME-HOST or NET:PARSE-HOST

(DEFUN PARSE-HOST-1 (STRING HOST-TYPE)
  (WITH-PARSE-FERROR ((UNKNOWN-HOST-NAME FS:UNKNOWN-PATHNAME-HOST))
    (SELECTQ HOST-TYPE
      (:PHYSICAL
       (NET:PARSE-HOST STRING))
      (:CHAOS-ONLY
       (LET ((HOST (NET:PARSE-HOST STRING)))
	 (UNLESS (SEND HOST :BEST-CHAOS-ADDRESS)
	   (PARSE-FERROR "~A does not have a CHAOS address" HOST))
	 HOST))
      (:OR-LOCAL
       (IF (STRING-EQUAL STRING "LOCAL")
	   NET:LOCAL-HOST
	   (NET:PARSE-HOST STRING)))
      (:PATHNAME
       (FS:GET-PATHNAME-HOST STRING))
      (:OR-PATHNAME
       (OR (FS:GET-PATHNAME-HOST STRING T T)
	   (NET:PARSE-HOST STRING)))
      (OTHERWISE
       (FERROR "~S is not a known host-type keyword" HOST-TYPE)))))

(DEFUN READ-HOST (&OPTIONAL STREAM DEFAULT OR-NIL HOST-TYPE)
  (OR HOST-TYPE (SETQ HOST-TYPE :PHYSICAL))
  (CHECK-ARG DEFAULT
	     (OR (NULL DEFAULT)
		 (TYPEP DEFAULT 'NET:HOST)
		 (STRINGP DEFAULT)
		 (SYMBOLP DEFAULT))
	     "a network host or the name of a host or NIL")
  (WHEN DEFAULT
    (SETQ DEFAULT (PARSE-HOST-1 DEFAULT HOST-TYPE))
    (SETQ OR-NIL T))
  (OR (READ-TOKEN STREAM OR-NIL #'PARSE-HOST-1 HOST-TYPE)
      DEFAULT))

(DEFUN READ-HOST-LIST (&OPTIONAL STREAM HOST-TYPE (OR-NIL T))
  (OR HOST-TYPE (SETQ HOST-TYPE :PHYSICAL))
  (READ-TOKEN-LIST-WITH-STRING STREAM OR-NIL #'PARSE-HOST-1 HOST-TYPE))

;; The portion of this file from here to the end deals only with interactive streams.  These
;; functions either use the input editor or do input-editor-like things, such as prompting and
;; providing help.  READ-CHARACTER and READLINE-NO-ECHO are the two reading functions do not
;; use the input editor.

(DEFPROP CHECK-INTERACTIVE-STREAM T :ERROR-REPORTER)

(DEFUN CHECK-INTERACTIVE-STREAM (STREAM)
  (UNLESS (SEND STREAM :INTERACTIVE)
    (FERROR "This function may only be invoked on interactive streams.~@
	     ~S is not an interactive stream." STREAM)))

(DEFUN DISCARD-CHARACTERS (STREAM CHARACTERS)
  (COERCE-TO-LIST CHARACTERS
    (LOOP FOR CHAR = (SEND STREAM :ANY-TYI) DO
      (UNLESS (MEMQ CHAR CHARACTERS)
	(SEND STREAM :UNTYI CHAR)
	(RETURN))))
  ;; Suppress compiler warning
  NIL)

(DEFUN DISCARD-WHITESPACE (STREAM)
  (DISCARD-CHARACTERS STREAM *WHITESPACE*))

;; Display help information.  This is used by the input editor, READ-CHARACTER, and
;; READLINE-NO-ECHO.

(DEFUN DISPLAY-HELP-OPTION (STREAM HELP)
  (DECLARE (DOWNWARD-FUNARG HELP))
  (COND ((STRINGP HELP)
	 (FORMAT STREAM HELP STREAM))
	;; Add SYMBOLP so that undefined help functions will get undefined function errors.
	((OR (SYMBOLP HELP) (FUNCTIONP HELP))
	 (FUNCALL HELP STREAM))
	((AND (LISTP HELP)
	      (COND ((STRINGP (CAR HELP))
		     (LEXPR-FUNCALL #'FORMAT STREAM HELP)
		     T)
		    ((OR (SYMBOLP (CAR HELP)) (FUNCTIONP (CAR HELP)))
		     (LEXPR-FUNCALL (CAR HELP) STREAM (CDR HELP))
		     T))))
	(T (FERROR "~S is not a valid help option." HELP))))

;; Possibly display a prompt, which may be specified as a format string or a function.  This
;; is used by the input editor, READ-CHARACTER, and READLINE-NO-ECHO.  Return the X and Y
;; coordinates of the point before the prompt, whether or not a prompt was printed.  PROMPT
;; may be NIL or a list of NIL as a way of saying "no prompt".

(DEFUN DISPLAY-PROMPT-OPTION (STREAM PROMPT &OPTIONAL (FRESH-LINE T) (REASON NIL))
  (DECLARE (DOWNWARD-FUNARG PROMPT))
  (WHEN (AND (IF (LISTP PROMPT) (CAR PROMPT) PROMPT) FRESH-LINE)
    (SEND STREAM :FRESH-LINE))
  (MULTIPLE-VALUE-BIND (X Y)
      (SEND STREAM :READ-CURSORPOS)
    (WHEN PROMPT
      (FLET ((SHOW-PROMPT ()
	       (DECLARE (DOWNWARD-FUNCTION))
	       (LET ((*PRINT-PRETTY* NIL)	;Don't put carriage returns in prompts
		     (SCL:*PRINT-ABBREVIATE-QUOTE* T))
		 (COND ((SI:SOME-STRING PROMPT)
			(FORMAT STREAM PROMPT STREAM))
		       ((FUNCTIONP PROMPT)
			(FUNCALL PROMPT STREAM REASON))
		       ((AND (LISTP PROMPT)
			     (LET ((CP (CAR PROMPT)))
			       (COND ((NULL CP)
				      T)
				     ((SI:SOME-STRING CP)
				      (LEXPR-FUNCALL #'FORMAT STREAM PROMPT)
				      T)
				     ((FUNCTIONP CP)
				      (LEXPR-FUNCALL CP STREAM REASON (CDR PROMPT))
				      T)))))
		       (T (FERROR "~S is not a valid prompt option." PROMPT)))
		 )))
	(IF (OPERATION-HANDLED-P STREAM :DISPLAY-PROMPT)
	    (SEND STREAM :DISPLAY-PROMPT #'SHOW-PROMPT)
	    (SHOW-PROMPT))))
    (VALUES X Y)))

;; If STATUS is :SELECTED, then return T when WINDOW is no longer selected.
;; If STATUS is :EXPOSED, then return T when WINDOW is no longer exposed or selected.

(DEFUN READ-CHARACTER-WINDOW-STATUS (WINDOW STATUS)
  (SELECTQ STATUS
    (:SELECTED
     (NEQ (SEND WINDOW :STATUS) :SELECTED))
    (:EXPOSED
     (NOT (MEMQ (SEND WINDOW :STATUS) '(:EXPOSED :SELECTED))))))

;; This function does the grunge work for READ-CHARACTER and READLINE-NO-ECHO.  The special
;; treatment of intercepted characters wouldn't be necessary if the I/O buffer contained
;; information that an intercepted character had been handled.  READ-FORM depends upon
;; this calling :ANY-TYI-NO-HANG rather than :ANY-TYI since it returns to the old input buffer
;; image rather than redrawing it.  Fixed when recursive input editing is fully implemented.
;; Also, since :LISTEN is allowed to lie, this can't use :ANY-TYI since it might go blocked.
(DEFUN READ-CHARACTER-INTERNAL (STREAM PROMPT-X PROMPT-Y
				&KEY 
				(ANY-TYI NIL) (NO-HANG NIL) (EOF NIL)
				(NOTIFICATION T) (PROMPT NIL) (HELP NIL)
				(REFRESH T) (SUSPEND T) (ABORT T) (TIMEOUT NIL)
				(INPUT-WAIT NIL) (input-block nil) (INPUT-WAIT-HANDLER NIL)
				(WHOSTATE NIL)
				(STATUS NIL) (PRESENTATION-CONTEXT NIL)
				&ALLOW-OTHER-KEYS)
  ;; STATUS can be either NIL, :EXPOSED, or :SELECTED.
  ;; This option only has an effect when the stream is a window.
  (WHEN STATUS
    (COND ((OPERATION-HANDLED-P STREAM :STATUS)
	   (SETQ STREAM (FOLLOW-SYN-STREAM STREAM))
	   (CHECK-ARG STATUS
		      (MEMQ STATUS '(NIL :EXPOSED :SELECTED))
		      "one of NIL, :EXPOSED, or :SELECTED"))
	  (T (SETQ STATUS NIL))))
  ;; Save ourselves some trouble if not doing input from a dynamic window.
  (WHEN (AND PRESENTATION-CONTEXT
	     (NOT (OPERATION-HANDLED-P STREAM :MOUSE-MOTION-PENDING)))
    (SETQ PRESENTATION-CONTEXT NIL))
  ;; Loop displaying the prompt.
  (LOOP NAMED TOP
	WITH KBD-INTERCEPTED-CHARACTERS = (AND ABORT KBD-STANDARD-ABORT-CHARACTERS)
	WITH NOTIFICATION-CELL = (AND NOTIFICATION (SEND STREAM :NOTIFICATION-CELL))
	WITH START-TIME = (TIME)
	DO
    ;; Loop discarding EOFs and blips.  Also loop in case a notification is
    ;; taken away from us or if Function Clear-Input is typed.
    (LOOP WITH CHAR
	  WITH NOTE
	  DO
      (UNLESS NO-HANG
	(IF (NOT (OR INPUT-WAIT
		     (AND NOTIFICATION-CELL
			  (NOT (EQL *CURRENT-PROCESS* (SEND-IF-HANDLES STREAM :PROCESS))))
		     STATUS))
	    (IF TIMEOUT
		(PROCESS::WITH-PROCESS-BLOCK-TIMEOUT ((// TIMEOUT 60s0) TIMER)
		  (SEND STREAM :INPUT-WAIT WHOSTATE 'process::verify-function
			(LAMBDA (STREAM NOTIFICATION-CELL TIMER PRESENTATION-CONTEXT)
			  (DECLARE (SYS:DOWNWARD-FUNCTION))
			  (OR (and input-block (funcall input-block))
			      (AND NOTIFICATION-CELL
				   (LOCATION-CONTENTS NOTIFICATION-CELL))
			      (NOT (PROCESS::TIMER-PENDING-P TIMER))
			      (AND PRESENTATION-CONTEXT
				   (DW::MOUSE-MOTION-PENDING STREAM))))
			(OR (SEND-IF-HANDLES STREAM :WINDOW-FOR-INPUT-WAIT)
			    (FOLLOW-SYN-STREAM STREAM)) NOTIFICATION-CELL
			TIMER PRESENTATION-CONTEXT))
		(SEND STREAM :INPUT-WAIT WHOSTATE 'process::verify-function
		      (LAMBDA (STREAM NOTIFICATION-CELL PRESENTATION-CONTEXT)
			(DECLARE (SYS:DOWNWARD-FUNCTION))
			(OR (and input-block (funcall input-block))
			    (AND NOTIFICATION-CELL
				 (LOCATION-CONTENTS NOTIFICATION-CELL))
			    (AND PRESENTATION-CONTEXT
				 (DW::MOUSE-MOTION-PENDING STREAM))))
		      (OR (SEND-IF-HANDLES STREAM :WINDOW-FOR-INPUT-WAIT)
			  (FOLLOW-SYN-STREAM STREAM)) NOTIFICATION-CELL PRESENTATION-CONTEXT))
	    (SEND STREAM :INPUT-WAIT WHOSTATE
		  (LAMBDA (STREAM INPUT-WAIT NOTIFICATION-CELL STATUS
			   TIMEOUT START-TIME PRESENTATION-CONTEXT)
		    (DECLARE (SYS:DOWNWARD-FUNCTION))
		    (OR (AND INPUT-WAIT
			     (FUNCALL INPUT-WAIT))
			(and input-block (funcall input-block))
			(AND NOTIFICATION-CELL
			     (LOCATION-CONTENTS NOTIFICATION-CELL))
			(AND STATUS
			     (READ-CHARACTER-WINDOW-STATUS STREAM STATUS))
			(AND TIMEOUT
			     (TIME-ELAPSED-P TIMEOUT START-TIME))
			(AND PRESENTATION-CONTEXT
			     (DW::MOUSE-MOTION-PENDING STREAM))))
		  (OR (SEND-IF-HANDLES STREAM :WINDOW-FOR-INPUT-WAIT)
		      (FOLLOW-SYN-STREAM STREAM))
		  INPUT-WAIT NOTIFICATION-CELL STATUS
		  TIMEOUT START-TIME PRESENTATION-CONTEXT)))
      (WHEN INPUT-WAIT-HANDLER
	(FUNCALL INPUT-WAIT-HANDLER))
      (WHEN PRESENTATION-CONTEXT
	(DW::UPDATE-HIGHLIGHTED-PRESENTATION STREAM))
      (COND ((AND TIMEOUT (TIME-ELAPSED-P TIMEOUT START-TIME))
	     (RETURN-FROM TOP :TIMEOUT))
	    ((READ-CHARACTER-WINDOW-STATUS STREAM STATUS)
	     (RETURN-FROM TOP :STATUS))
	    ((AND NOTIFICATION-CELL
		  (SETQ NOTE (SEND STREAM :RECEIVE-NOTIFICATION)))
	     (COND ((EQ NOTIFICATION :RETURN)
		    (RETURN-FROM TOP `(:NOTIFICATION . ,NOTE)))
		   ;; Normal case
		   ((EQ (FOLLOW-SYN-STREAM STREAM)
			(FOLLOW-SYN-STREAM TERMINAL-IO))
		    (CLEAR-TO-CURSORPOS STREAM PROMPT-X PROMPT-Y)
		    (DISPLAY-NOTIFICATION STREAM NOTE :STREAM))
		   ;; Following complicated cases for zmail and the editor.
		   ((SEND TERMINAL-IO :EXPOSED-P)
		    (TV:DISPLAY-NOTIFICATION TERMINAL-IO NOTE :STREAM))
		   ((AND (SEND QUERY-IO :EXPOSED-P)
			 (TV:NOTIFICATION-FITS NOTE QUERY-IO))
		    (SEND-IF-HANDLES QUERY-IO :PREPARE-FOR-TYPEOUT)
		    (TV:DISPLAY-NOTIFICATION QUERY-IO NOTE :WINDOW)
		    (SEND-IF-HANDLES QUERY-IO :TYPEOUT-STAYS))
		   (T
		    (TV:POP-UP-NOTIFICATION NOTE STREAM)))
	     (RETURN))
	    ((SETQ CHAR
		   (CONDITION-CASE ()
			(SEND STREAM :ANY-TYI-NO-HANG T)
		      (END-OF-FILE
			(IF EOF (RETURN-FROM TOP NIL))
			(SEND STREAM :BEEP)
			NIL)))
	     (COND ((AND SUSPEND (MEMQ CHAR KBD-STANDARD-SUSPEND-CHARACTERS))
		    (KBD-INTERCEPT-CHARACTER CHAR)
		    (SEND STREAM :FRESH-LINE)
		    (SEND STREAM :TYO #\NEWLINE)
		    (RETURN))
		   ((NOT (CHARACTERP CHAR))
		    (WHEN (AND PRESENTATION-CONTEXT (LISTP CHAR))
		      (LET ((NEW-CHAR (DW::PRESENTATION-INPUT-BLIP-HANDLER CHAR STREAM)))
			(WHEN (OR (NULL NEW-CHAR)
				  (EQ (FIRST NEW-CHAR) 'DW:DEAD-BLIP))
			  (RETURN))		;Handled, but not to be returned to the user
			(UNLESS (EQ NEW-CHAR CHAR)	;Unhandled, do ANY-TYI check below
			  (RETURN-FROM TOP NEW-CHAR))))	;Converted into presentation blip
		    (IF ANY-TYI
			(RETURN-FROM TOP CHAR)
			(TYI-BLIP-HANDLER CHAR STREAM)))
		   ((AND REFRESH (CHAR-EQUAL CHAR #\REFRESH))
		    (SEND STREAM :CLEAR-WINDOW)
		    (RETURN))
		   ((AND HELP (CHAR-EQUAL CHAR #\HELP))
		    (DISPLAY-HELP-OPTION STREAM HELP)
		    (RETURN))
		   (T (RETURN-FROM TOP (VALUES CHAR PROMPT-X PROMPT-Y)))))
	    (NO-HANG (RETURN-FROM TOP NIL))))
    ;; Notification, Refresh, or Help.  Redisplay the prompt.
    (MULTIPLE-VALUE (PROMPT-X PROMPT-Y)
      (DISPLAY-PROMPT-OPTION STREAM PROMPT))))

;; Called by (PROMPT-AND-READ :CHARACTER) and FQUERY.  The :FRESH-LINE keyword is for the
;; benefit of FQUERY, and doesn't matter unless you give the :PROMPT keyword too.

(DEFUN READ-CHARACTER (&OPTIONAL STREAM
		       &REST KEYWORDS &KEY
		       (FRESH-LINE T) (ANY-TYI NIL) (NO-HANG NIL) (EOF NIL)
		       (NOTIFICATION T) (PROMPT NIL) (HELP NIL)
		       (REFRESH T) (SUSPEND T) (ABORT T) (TIMEOUT NIL)
		       (INPUT-WAIT NIL) (input-block nil) (INPUT-WAIT-HANDLER NIL)
		       (WHOSTATE NIL)
		       (STATUS NIL) (PRESENTATION-CONTEXT NIL))
  ;; Suppress compiler warning, but keep keyword checking.
  ANY-TYI NO-HANG EOF NOTIFICATION HELP REFRESH SUSPEND ABORT TIMEOUT
  INPUT-WAIT input-block INPUT-WAIT-HANDLER WHOSTATE STATUS PRESENTATION-CONTEXT
  (OR STREAM (SETQ STREAM QUERY-IO))
  (CHECK-INTERACTIVE-STREAM STREAM)
  (MULTIPLE-VALUE-BIND (PROMPT-X PROMPT-Y)
      (DISPLAY-PROMPT-OPTION STREAM PROMPT FRESH-LINE)
    (VALUES (LEXPR-FUNCALL #'READ-CHARACTER-INTERNAL STREAM PROMPT-X PROMPT-Y KEYWORDS))))

;; Used for reading passwords and encryption keys.  Called by FS:PROMPT-FOR-USER-AND-PASSWORD.

(DEFUN READLINE-NO-ECHO (&OPTIONAL STREAM 
			 &REST KEYWORDS &KEY
			 (TERMINATORS '(#\RETURN #\LINE #\END))
			 (FULL-RUBOUT NIL)
			 (NOTIFICATION T) (PROMPT NIL) (HELP NIL))
  ;; Suppress compiler warning, but keep keyword checking.
  NOTIFICATION HELP
  (OR STREAM (SETQ STREAM QUERY-IO))
  (CHECK-INTERACTIVE-STREAM STREAM)
  (MULTIPLE-VALUE-BIND (PROMPT-X PROMPT-Y)
      (DISPLAY-PROMPT-OPTION STREAM PROMPT)
    (COERCE-TO-LIST TERMINATORS
      (LOOP WITH LINE = (MAKE-ARRAY 40. :TYPE 'ART-STRING :FILL-POINTER 0)
	    WITH CHAR
	    DO
	    (MULTIPLE-VALUE (CHAR PROMPT-X PROMPT-Y)
	      (LEXPR-FUNCALL #'READ-CHARACTER-INTERNAL STREAM PROMPT-X PROMPT-Y KEYWORDS))
	    (COND ((CL:MEMBER CHAR TERMINATORS)
		   (SEND STREAM :TYO
			 (IF (MEM-CHAR CHAR '(#\RETURN #\LINE #\END)) #\NEWLINE CHAR))
		   (RETURN (VALUES LINE CHAR)))
		  ((COND ((EQL CHAR #\RUBOUT)
			  (IF (ZEROP (FILL-POINTER LINE))
			      (SEND STREAM :BEEP)
			      (DECF (FILL-POINTER LINE)))
			  T)
			 ((EQL CHAR #\CLEAR-INPUT)
			  (SETF (FILL-POINTER LINE) 0)
			  T))
		   (IF (AND (ZEROP (FILL-POINTER LINE)) FULL-RUBOUT)
		       (RETURN NIL)))
		  ((OR (NULL CHAR)
		       (NOT (GRAPHIC-CHAR-P CHAR)))
		   (SEND STREAM :BEEP))
		  (T (ARRAY-PUSH-EXTEND LINE CHAR)))))))

;; These functions don't take an EOF-OPTION argument the way READ and READ-FOR-TOP-LEVEL do
;; since they are intended for interactive use only.

;; READ-EXPRESSION is like READ-FOR-TOP-LEVEL, and does three other interactive-only things:
;;   1. It filters out EOFs encountered at top level.
;;   2. It adds   and c-? as input editor commands.
;;   3. Enables mathing paren blinking, if the stream supports it.
;; In the system, READ-FOR-TOP-LEVEL is only called on interactive streams, so perhaps it
;; should just be flushed or changed to do what this function does.

(DEFUN READ-EXPRESSION (&OPTIONAL STREAM
			&KEY (COMPLETION-ALIST NIL)
			     (COMPLETION-DELIMITERS NIL)
			     (PRESENTATION-TYPE 'SYS:EXPRESSION))
  (OR STREAM (SETQ STREAM STANDARD-INPUT))
  (WITH-STACK-LIST (COM-LISP-COMPLETE #\COMPLETE 'COM-LISP-COMPLETE
				      COMPLETION-ALIST COMPLETION-DELIMITERS)
    (WITH-STACK-LIST (COM-LISP-DISPLAY-COMPLETIONS #\c-? 'COM-LISP-DISPLAY-COMPLETIONS
						   COMPLETION-ALIST COMPLETION-DELIMITERS)
      (WITH-INPUT-EDITING-OPTIONS-IF
	  COMPLETION-ALIST
	  ((:EDITOR-COMMAND COM-LISP-COMPLETE COM-LISP-DISPLAY-COMPLETIONS)
	   (:MOUSE-COMPLETION 'COM-LISP-MOUSE-COMPLETE
	    COMPLETION-ALIST COMPLETION-DELIMITERS))
	(WITH-INPUT-EDITING-OPTIONS ((:BLINK-MATCHING-CHARACTER :LISP))
	  (WITH-INPUT-EDITING (STREAM :END-ACTIVATION)
	    (MULTIPLE-VALUE-BIND (VALUE TYPE)
		(READ-INTERNAL-1 STREAM :PRESENTATION-TYPE PRESENTATION-TYPE)
	      (WHEN (AND (EQ VALUE 'EOF) (EQ TYPE 'SPECIAL-TOKEN))
		(WHEN (SEND STREAM :RESCANNING-P)
		  (SEND STREAM :ANY-TYI))
		(BEEP)
		(SEND STREAM :FORCE-RESCAN))
	      VALUE)))))))

;; This is like READ-EXPRESSION, except that it assumes that the returned value is going to
;; be immediately given to EVAL.  This can be called by the PROMPT-AND-READ-KEYWORDS
;; :EVAL-FORM and :EVAL-FORM-OR-END.  Binding RUBOUT-HANDLER to NIL is necessary so that we
;; can call FQUERY while inside the input editor.

;; Can't hack Space since it delimites the region to complete.

(DEFVAR *READ-FORM-EDIT-TRIVIAL-ERRORS-P* T)
(DEFVAR *READ-FORM-COMPLETION-ALIST* NIL)
(DEFVAR *READ-FORM-COMPLETION-DELIMITERS* '(#/- #/: #\SPACE))
(DEFVAR-RESETTABLE *READ-FORM-ENVIRONMENT* NIL)

;;--- yuck - do these exist anywhere else?
(DEFUN BOUNDP-IN-ENVIRONMENT (SYM ENV)
  (OR (ASSQ SYM (SI:ENV-VARIABLES ENV))
      (BOUNDP SYM)))

(DEFUN SYMEVAL-IN-ENVIRONMENT (SYM ENV &AUX VAL)
  (COND ((SETQ VAL (ASSQ SYM (SI:ENV-VARIABLES ENV)))
	 (CDR VAL))
	(T (SYMEVAL SYM))))

(DEFUN FBOUNDP-IN-ENVIRONMENT (SYM ENV)
  (OR (NOT (NULL (LOCAL-FUNCTION-DEFINITION SYM ENV)))
      (FBOUNDP SYM)))

(DEFUN FSYMEVAL-IN-ENVIRONMENT (SYM ENV)
  (OR (LOCAL-FUNCTION-DEFINITION SYM ENV)
      (FSYMEVAL SYM)))

(DEFUN READ-FORM (&OPTIONAL STREAM
		  &KEY (EDIT-TRIVIAL-ERRORS-P *READ-FORM-EDIT-TRIVIAL-ERRORS-P*)
		       (COMPLETION-ALIST      *READ-FORM-COMPLETION-ALIST*)
		       (COMPLETION-DELIMITERS *READ-FORM-COMPLETION-DELIMITERS*)
		       (ENVIRONMENT	      *READ-FORM-ENVIRONMENT*)
		       (PRESENTATION-TYPE 'SYS:FORM PRESENTATION-TYPE-P))
  (WHEN (OR ENVIRONMENT EDIT-TRIVIAL-ERRORS-P)
    (UNLESS PRESENTATION-TYPE-P
      (SETQ PRESENTATION-TYPE `((SYS:FORM)
				,@(WHEN ENVIRONMENT
				    `(:ENVIRONMENT ,ENVIRONMENT))
				,@(WHEN EDIT-TRIVIAL-ERRORS-P
				    `(:EDIT-TRIVIAL-ERRORS-P ,EDIT-TRIVIAL-ERRORS-P))))))
  (OR STREAM (SETQ STREAM STANDARD-INPUT))
  (LABELS ((BODY ()
	     (MULTIPLE-VALUE-BIND (FORM FLAG)
		 (READ-EXPRESSION STREAM
				  :COMPLETION-ALIST COMPLETION-ALIST
				  :COMPLETION-DELIMITERS COMPLETION-DELIMITERS
				  :PRESENTATION-TYPE NIL)
	       (WHEN EDIT-TRIVIAL-ERRORS-P
		 (LABELS ((PACKAGE-DWIM (NOUN1 NOUN2 ADJECTIVE SYMBOL OFFSET EVAL PREDICATE)
			    (UNLESS DBG:*DEFER-PACKAGE-DWIM*
			      (LET ((REJECTS NIL)
				    (QUERY-IO STREAM)
				    (RUBOUT-HANDLER NIL))
				(DBG:MAP-OVER-LOOKALIKE-SYMBOLS
				  (GET-PNAME SYMBOL) PKG-GLOBAL-PACKAGE
				  (LAMBDA (SYM)
				    (UNLESS (MEMQ SYM REJECTS)
				      (WHEN (FUNCALL PREDICATE SYM)
					(WHEN (DBG:PACKAGE-DWIM-QUERY NOUN2
								      SYM SYMBOL OFFSET EVAL)
					  (RETURN-FROM PACKAGE-DWIM SYM)))
				      (PUSH SYM REJECTS))))))
			    (PARSE-FERROR "The ~A ~S is ~A." NOUN1 SYMBOL ADJECTIVE)))
		   (COND ((AND (SYMBOLP FORM)
			       (NOT (BOUNDP-IN-ENVIRONMENT FORM ENVIRONMENT))
			       (NOT (LT:SYMBOL-MACRO-P FORM ENVIRONMENT)))
			  (SETQ FORM
				(PACKAGE-DWIM
				  "variable" "value" "unbound" FORM 1
				  (LAMBDA (SYMBOL) (EVAL SYMBOL ENVIRONMENT))
				  (LAMBDA (SYMBOL)
				    (AND (NOT (KEYWORDP SYMBOL))
					 (OR (BOUNDP-IN-ENVIRONMENT SYMBOL ENVIRONMENT)
					     (LT:SYMBOL-MACRO-P SYMBOL ENVIRONMENT)))))))
			 ((AND (LISTP FORM)
			       (SYMBOLP (CAR FORM))
			       (NOT (FBOUNDP-IN-ENVIRONMENT (CAR FORM) ENVIRONMENT)))
			  (SETQ FORM
				(CONS (PACKAGE-DWIM
					"function" "definition" "undefined" (CAR FORM) 2
					(LAMBDA (SYMBOL)
					  (FSYMEVAL-IN-ENVIRONMENT SYMBOL ENVIRONMENT))
					(LAMBDA (SYMBOL)
					  (FBOUNDP-IN-ENVIRONMENT SYMBOL ENVIRONMENT)))
				      (CDR FORM)))))))
	       (VALUES FORM FLAG))))
    (IF PRESENTATION-TYPE
	(WITH-INPUT-EDITING (STREAM :END-ACTIVATION)
	  (DW:WITH-PRESENTATION-INPUT-EDITOR-CONTEXT (STREAM PRESENTATION-TYPE) ()
	       (BODY)))
      (BODY))))

;; The call to READ-EXPRESSION should be outside the CONDITION-CASE so that if a
;; non-PARSE-ERROR condition is signalled while inside READ-EXPRESSION, it won't be caught by
;; the input editor.

(DEFUN READ-AND-EVAL (&OPTIONAL STREAM (CATCH-ERRORS T)
		      &KEY (ENVIRONMENT *READ-FORM-ENVIRONMENT*))
  (OR STREAM (SETQ STREAM STANDARD-INPUT))
  (DW:WITH-PRESENTATION-INPUT-CONTEXT ('FORM :STREAM STREAM) ()
    (WITH-INPUT-EDITING (STREAM :END-ACTIVATION)
      (LET ((FORM (READ-EXPRESSION STREAM)))
	(WITH-PARSE-FERROR-IF CATCH-ERRORS (ERROR)
	  (EVAL FORM ENVIRONMENT))))))

;; This is like READ-EXPRESSION, except if one of the delimiter characters is typed and the
;; input buffer is empty or contains only whitespace, then the values NIL, the character code
;; of the character, and the numeric argument to the character are returned.

(DEFUN READ-OR-CHARACTER (&OPTIONAL DELIMITERS STREAM READER
			  &REST READER-ARGS &KEY PRESENTATION-TYPE &ALLOW-OTHER-KEYS)
  (DECLARE (DOWNWARD-FUNARG READER))
  (OR STREAM (SETQ STREAM STANDARD-INPUT))
  (OR READER (SETQ READER #'READ-EXPRESSION))
  (LABELS ((PEEK-CHAR (STREAM)
	     (IF (NOT PRESENTATION-TYPE)
		 (SEND STREAM :ANY-TYI)
	       (DW:WITH-PRESENTATION-INPUT-EDITOR-CONTEXT (STREAM PRESENTATION-TYPE)
							  (BLIP)
		    (SEND STREAM :ANY-TYI)
		  (T (RETURN-FROM READ-OR-CHARACTER
		       (DW:PRESENTATION-BLIP-OBJECT BLIP)))))))
    (COERCE-TO-LIST DELIMITERS
      (WITH-CLIM-COMPATIBLE-INPUT-EDITING (STREAM)
	(WITH-INPUT-EDITING-OPTIONS ((:ACTIVATION
				       'READ-OR-CHARACTER-ACTIVATION-P STREAM DELIMITERS))
	  ;; Discard whitespace, EOFs, and non-delimiting activators.
	  (LOOP FOR CHAR = (PEEK-CHAR STREAM) DO
	    (COND ((OR (NULL CHAR)
		       (AND (LISTP CHAR)
			    (EQ (FIRST CHAR) :ACTIVATION)
			    (NOT (MEMQ (SECOND CHAR) DELIMITERS))
			    (NOT (DW::ACCEPT-ACTIVATION-P (SECOND CHAR)))))
		   (SEND STREAM :BEEP))
		  ((MEMQ CHAR *WHITESPACE*))
		  (T (SEND STREAM :UNTYI CHAR)
		     (RETURN))))
	  ;; If the character is one of the delimiters, return it.
	  ;; Otherwise, invoke the reader.
	  (LET ((CHAR (PEEK-CHAR STREAM)))
	    (COND ((AND (LISTP CHAR)
			(EQ (FIRST CHAR) :ACTIVATION))
		   (VALUES NIL :CHARACTER (SECOND CHAR) (THIRD CHAR)))
		  (T (SEND STREAM :UNTYI CHAR)
		     (CL:APPLY READER STREAM READER-ARGS)))))))))

(DEFUN READ-OR-CHARACTER-ACTIVATION-P (CHAR STREAM DELIMITERS)
  (OR (CHAR-EQUAL CHAR #\END)
      (AND (MEMQ CHAR DELIMITERS)
	   (NOT (AND (OPERATION-HANDLED-P STREAM :INPUT-BUFFER)
		     (STRING-SEARCH-NOT-SET *WHITESPACE* (SEND STREAM :INPUT-BUFFER)))))
      (DW::ACCEPT-ACTIVATION-P CHAR)))

;; This is like READ-EXPRESSION, but if ” is typed and there are no characters or only
;; whitespace in the input buffer, then the values NIL and :END are returned.  This is used by
;; the PROMPT-AND-READ keywords :EXPRESSION-OR-END and :EVAL-FORM-OR-END.

(DEFUN READ-OR-END (&OPTIONAL STREAM READER)
  (DECLARE (ARGLIST &OPTIONAL (STREAM STANDARD-INPUT) READER))
  (OR STREAM (SETQ STREAM STANDARD-INPUT))
  (MULTIPLE-VALUE-BIND (VALUE FLAG)
      (READ-OR-CHARACTER #\END STREAM READER)
    (VALUES VALUE (IF (EQ FLAG :CHARACTER) :END FLAG))))

;; Some people still have this in their init file.
;; Leave it here in case we decide to try other command loop experiments.

(DEFUN EXPERIMENTAL-COMMAND-LOOP-ON (&OPTIONAL (ON-P T))
  ON-P ;Ignored
  T)

(DEFUN (EXPERIMENTAL-COMMAND-LOOP-ON  :UNDO-FUNCTION) (IGNORE)
  '(EXPERIMENTAL-COMMAND-LOOP-ON NIL))

;; Completion

;;; Try to rearrange a multi-column enumeration in this many rows or as
;;; close to it as possible without exceeding it, if the enumeration was
;;; originally arranged in fewer rows than this number.
(DEFVAR *OPTIMAL-NUMBER-OF-ROWS* 4)

;;; General row-major-to-column-major inverter: if items are to be
;;; ordered down columns, invert the list so a row-wise dump across
;;; NCOLS columns will produce that tabulation, with needed blank spaces
;;; to fill out a rectangular array placed in the last *row*.

(DEFUN COLUMN-INVERT-LIST (LIST NCOLS)
  (CHECK-ARG LIST CL:LISTP "an item list or list of strings")	
  (IF ( NCOLS 1)
      LIST
    (LOOP WITH LIM = (LENGTH LIST)
	  WITH OLD-ARRAY = (LOOP WITH ARRAY = (MAKE-ARRAY LIM)
				 FOR ITEM IN LIST
				 FOR I UPFROM 0
				 DO (ASET ITEM ARRAY I)
				 FINALLY (RETURN ARRAY))
	  WITH LINES = (// (1- (+ LIM NCOLS)) NCOLS)
	  WITH N-LONG-COLS = (1+ (\ (1- LIM) NCOLS))
	  FOR J FROM 0 TO (1- LIM) 
	  AS NTH-ONE = (1- (+ (MIN (\ J NCOLS) N-LONG-COLS)	; long columns past
			      (* (1- LINES) (\ J NCOLS))	; plus column idx*len
			      (1+ (// J NCOLS))))	; plus row number
	  COLLECT (AREF OLD-ARRAY NTH-ONE))))

;; Type out a list of items with as many as will fit on each line.
;; Items line up in columns which are as wide as the widest item.

(DEFUN DISPLAY-ITEM-LIST (STREAM TYPE LIST &OPTIONAL ITEM-STRING (ORDER-COLUMNWISE T))
  (SEND STREAM :FRESH-LINE)
  ;; Do nothing if empty list
  (WHEN LIST
    (LET* ((SPACE-WIDTH (SEND STREAM :CHARACTER-WIDTH #\SPACE))
	   ;; wire in 2-space indentation for now
	   (INDENTATION (* 2 SPACE-WIDTH))
	   (INSIDE-WIDTH (SEND STREAM :INSIDE-WIDTH))
	   ;; Compute the maximum width of any item, in pixels.
	   (MAXL (LOOP FOR ITEM IN LIST
		       AS STRING = (STRING (IF (LISTP ITEM) (CAR ITEM) ITEM))
		       MAXIMIZE (SEND STREAM :STRING-LENGTH STRING)))
	   ;; How many items go on each line (except the last)?
	   (N (MAX (MIN (// (- INSIDE-WIDTH INDENTATION)
			    (+ MAXL SPACE-WIDTH))
			(LENGTH LIST))
		   1)))  ;Always print something, even if continuation

      ;;; If the number of rows needed, using the maximum columns that
      ;;; will fit, exceeds the optimal number (parameter above), adjust
      ;;; the number of columns so that it is the minimum number that
      ;;; will produce this number of rows.  If the number of rows
      ;;; needed does NOT exceed the optimal number, find the minimum
      ;;; number of columns that will make the number of rows equal the
      ;;; optimum, or come as close as possible without exceeding it.
      (SETQ N
	    (LET ((ELEMENTS (LENGTH LIST)))
	      (LOOP FOR COLS FROM (1- N) ABOVE 0
		    FOR OLD-ROWS = (+ (// ELEMENTS N) (SIGNUM (\ ELEMENTS N)))
			THEN ROWS
		    AS ROWS = (+ (// ELEMENTS COLS) (SIGNUM (\ ELEMENTS COLS)))
		    WHEN (> ROWS *OPTIMAL-NUMBER-OF-ROWS*)
		      DO (RETURN
			   (+ (// ELEMENTS OLD-ROWS) (SIGNUM (\ ELEMENTS OLD-ROWS))))
		    FINALLY (RETURN 1))))
      ;; if items are to be ordered down columns, invert the list so a
      ;; row-wise dump across N columns will produce that tabulation
      (WHEN ORDER-COLUMNWISE
	(SETQ LIST (COLUMN-INVERT-LIST LIST N)))
      ;; Now print the items and store the data in the table.
      ;; Move to a new line when we exhaust a line, and after printing all
      ;; the items.  I counts from 1 thru N on each line.
      (DO ((I 1 (1+ I))
	   (LIST LIST (CDR LIST))
	   ;; Adjust item spacing according to available extra space; compute spacing per-col
	   (WIDTH-PER
	     (LET* ((TOTAL-WIDTH 0)
		    (WIDTH-PER
		      (LOOP FOR COL FROM 1 TO N
			    AS COL-MAX =
			       (+ SPACE-WIDTH
				  (LOOP FOR ITEM IN (NTHCDR (1- COL) LIST)
					    BY #'(LAMBDA (L) (NTHCDR N L))
					AS STRING = (STRING (IF (LISTP ITEM) (CAR ITEM) ITEM))
					MAXIMIZE (SEND STREAM :STRING-LENGTH STRING)))
			    DO (INCF TOTAL-WIDTH COL-MAX)
			    COLLECT TOTAL-WIDTH))
		    (EXTRA-SPACE-PER
		      ;; wire in (max of) 2 space extra padding between columns
		      (MIN (* 2 SPACE-WIDTH)
			   (// (- INSIDE-WIDTH INDENTATION TOTAL-WIDTH) N))))
	       (LOOP FOR WIDTH-LIST ON WIDTH-PER
		     FOR I FROM 1
		     AS (COL-WIDTH . NIL) = WIDTH-LIST
		     DO (SETF (CAR WIDTH-LIST) (+ COL-WIDTH (* I EXTRA-SPACE-PER))))
	       WIDTH-PER)))
	  ((NULL LIST))
	;; Space out and output next item, or move to new line.
	(WHEN ( I N)
	  ;; Not end of line, space out for next item.
	  ;; Very important: :INCREMENT-CURSORPOS handles exceptions before taking effect!
	  (SEND STREAM :INCREMENT-CURSORPOS
		(- (+ INDENTATION (IF (> I 1) (NTH (1- (1- I)) WIDTH-PER) 0))
		   (SEND STREAM :READ-CURSORPOS))
		0)
	  ;; Actually make this item.
	  (COND ((NOT (LISTP (CAR LIST)))
		 (SEND STREAM :ITEM TYPE (CAR LIST)))
		(ITEM-STRING
		 (SEND STREAM :ITEM TYPE (CAAR LIST)))
		(T
		 (SEND STREAM :ITEM TYPE (CDAR LIST) "~A" (CAAR LIST)))))
	(WHEN (OR ( I N) (NULL (CDR LIST)))
	    ;; End of line.
	    (SEND STREAM :TYO #\NEWLINE)
	    (SETQ I 0))))))

;; Binding RUBOUT-HANDLER to NIL is necessary so that we can call FQUERY while inside the
;; input editor.

(DEFVAR *DISPLAY-COMPLETIONS-THRESHOLD* 50.)

(DEFUN DISPLAY-COMPLETIONS (STREAM POSSIBILITIES &OPTIONAL TYPE DOCUMENTER SORTED?)
  (LET ((LEN (LENGTH POSSIBILITIES)))
    (COND ((ZEROP LEN)
	   (FORMAT STREAM
		   "~&There are no possible completions of the text you have typed."))
	  ((= LEN 1)
	   (FORMAT STREAM
		   "~&The only possible completion of the text you have typed is ")
	   (SEND STREAM :ITEM TYPE (CAAR POSSIBILITIES))
	   (COND (DOCUMENTER
		  (FORMAT STREAM ":~2%")
		  (FUNCALL DOCUMENTER (CAR POSSIBILITIES)))
		 (T (SEND STREAM :TYO #/.))))
	  ((OR (NOT *DISPLAY-COMPLETIONS-THRESHOLD*)
	       (< LEN *DISPLAY-COMPLETIONS-THRESHOLD*)
	       (LET ((QUERY-IO STREAM)
		     (RUBOUT-HANDLER NIL))
		 (FQUERY NIL
			 "There are ~D possibilities, do you really want to see them all? "
			 LEN)))
	   (FORMAT STREAM
		   "~&These are the possible completions of the text you have typed:~2%")
	   (IF SORTED?
	       (DISPLAY-ITEM-LIST STREAM TYPE POSSIBILITIES T)
	       (DISPLAY-ITEM-LIST STREAM TYPE
				  (SORT (MAPCAR #'CAR POSSIBILITIES) #'STRING-LESSP)))))))

(DEFVAR *NAMED-COMPLETION-ALISTS*
	'((:ZMACS ZWEI:*ZMACS-COMPLETION-AARRAY*)
	  (:FLAVORS *ALL-FLAVOR-NAMES-AARRAY*)
	  (:DOCUMENTATION (FIND-SAGE-COMPLETION-ALIST))
	  ;; Obsolete.  For compatibility with Rel 6 only.  Flush in Rel 8.
	  (:SAGE (FIND-SAGE-COMPLETION-ALIST))))

(DEFUN FIND-SAGE-COMPLETION-ALIST ()
  (WHEN (PKG-FIND-PACKAGE "SAGE" :FIND)
    (SYMEVAL (INTERN "*TOPIC-AARRAY*" "SAGE"))))

(DEFUN FIND-COMPLETION-ALIST (ALIST)
  (IF (KEYWORDP ALIST)
      (LET ((FORM (CADR (ASSQ ALIST *NAMED-COMPLETION-ALISTS*))))
	(WHEN FORM
	  (EVAL FORM)))
      ALIST))

(DEFUN FIND-COMPLETION-ALIST-SIZE (ALIST)
  (LET ((FOUND-ALIST (FIND-COMPLETION-ALIST ALIST)))
    (TYPECASE FOUND-ALIST
      (:ARRAY
       (ARRAY-ACTIVE-LENGTH FOUND-ALIST))
      (:LIST
       (LENGTH FOUND-ALIST))
      (OTHERWISE
	(FERROR "ALIST must be an AARRAY, an ALIST, ~
		 or a symbol known by SI:*NAMED-COMPLETION-ALISTS*")))))

;; These two forms:
;;     (ZWEI:COMPLETE-STRING "foo" '(("Foo1") ("Foo2")) NIL)
;;     (ZWEI:COMPLETE-STRING "Foo" '(("Foo1") ("Foo2")) NIL)
;; return exactly the same values.  There is no way to tell that the case changed.
;; This function is like ZWEI:COMPLETE-STRING, except that COMPLETED-P is T in this case.

(DEFUN COMPLETE-STRING (STRING ALIST DELIMITERS
			&OPTIONAL (COMPLETE-TO-DELIMITER NIL) (IGNORE-TRAILING-SPACE NIL))
  (DECLARE (VALUES COMPLETE-STRING POSSIBILITIES COMPLETED-P))
  (MULTIPLE-VALUE-BIND (COMPLETE-STRING POSSIBILITIES COMPLETED-P)
      (ZWEI:COMPLETE-STRING STRING (FIND-COMPLETION-ALIST ALIST) DELIMITERS
			    NIL NIL COMPLETE-TO-DELIMITER IGNORE-TRAILING-SPACE)
    (VALUES
      COMPLETE-STRING
      POSSIBILITIES
      (OR
	;; Some new characters were added to the end of STRING
	COMPLETED-P
	;; Or the case changed
	(AND POSSIBILITIES (NOT (STRING= COMPLETE-STRING STRING)))))))

;; Read with completion from an alist or aarray.  If the user types <Return> and no completion
;; is possible, then the current input is returned as a string.  This must also handle c-/ and
;; <Help>.  Should <Help> be handled by the READ-XXX functions rather than PROMPT-AND-READ?
;; READLINE-OR-NIL can't be used if Space is going to do completion.

;;; There are some unresolved user-interface issues here having to do with
;;; the difference between the partial-completion trigger characters and the
;;; delimiters used to divide the completion candidates into chunks.  In
;;; particular the decision about whether or not to insert the trigger char
;;; into the input buffer must be considered carefully.  The common case of
;;; using SPACE for both a completion trigger and a delimiter is handled
;;; correctly by this code so that ZMACS-style completion of commands and
;;; multi-word strings feels right.  Things are not quite as good when the
;;; trigger is SPACE and the delimiter is, say, HYPHEN (e.g. completing
;;; flavor names).  At least the user can always use COMPLETE, which will
;;; never insert anything.  Using HYPHEN as both a trigger and a delimiter
;;; for flavor names actually works pretty well.
;;;
;;; The arg PARTIAL-COMPLETERS used to be called COMPLETE-ON-SPACE.  None of
;;; the callers have been changed to pass in a list of completers, and a value
;;; of T is interpreted to mean that SPACE is used as the only partial completion
;;; trigger for upward compatability.  -York 6/5/85

(DEFUN READ-COMPLETE-STRING (ALIST DELIMITERS &OPTIONAL STREAM
			     (IMPOSSIBLE-IS-OK T) (OR-NIL T) (PARTIAL-COMPLETERS T))
  (OR STREAM (SETQ STREAM QUERY-IO))
  ;; Compatability with forer COMPLETE-ON-SPACE argument which occupied the
  ;; same parameter position.
  (WHEN (EQ PARTIAL-COMPLETERS T)
    (SETQ PARTIAL-COMPLETERS '(#\SPACE)))
  (COERCE-TO-LIST DELIMITERS
    (STACK-LET ((HELP `(#\HELP READ-COMPLETE-STRING-HELP ,ALIST ,DELIMITERS))
		(DISPLAY-COMPLETIONS `(#\c-? COM-DISPLAY-COMPLETIONS ,ALIST ,DELIMITERS)))
      (WITH-INPUT-EDITING-OPTIONS ((:ACTIVATION 'MEM-CHAR '(#\RETURN #\LINE #\END #\COMPLETE))
				   (:EDITOR-COMMAND HELP DISPLAY-COMPLETIONS)
				   (:MOUSE-COMPLETION 'COM-MOUSE-COMPLETE))
	(WITH-INPUT-EDITING-OPTIONS-IF (NOT (NULL PARTIAL-COMPLETERS))
				       ((:RESCAN 'MEM-CHAR PARTIAL-COMPLETERS)
					(:BLIP-CHARACTER 'MEM-CHAR PARTIAL-COMPLETERS))
	  (WITH-STACK-ARRAY (STRING 100. :TYPE 'ART-FAT-STRING :LEADER-LENGTH 1)
	    (WITH-INPUT-EDITING (STREAM :LINE)
	      ;; The fill pointer must be reset after each throw.
	      (SETF (FILL-POINTER STRING) 0)
	      ;; This only affects space characters when PARTIAL-COMPLETERS is NIL
	      ;; or when rescanning.
	      (DISCARD-WHITESPACE STREAM)
	      (LOOP FOR CHAR = (SEND STREAM :ANY-TYI)
		    DO
		(COND ((NULL CHAR)
		       (SEND STREAM :BEEP))
		      ((LISTP CHAR)
		       (UNLESS (MEMQ (FIRST CHAR) '(:ACTIVATION :BLIP-CHARACTER))
			 (FERROR "Unexpected blip returned by the input editor - ~S" CHAR))  
		       (LET ((COMPLETER (SECOND CHAR)))
			 (IF (ZEROP (FILL-POINTER STRING))
			     ;; I don't know if this special-case treatment of zero-length
			     ;; input is warrented. If there is only one completion in the
			     ;; alist and the user hits RETURN, maybe that completion should
			     ;; be returned.  -York
			     (COND ((MEM-CHAR COMPLETER PARTIAL-COMPLETERS)
				    (SEND STREAM :REPLACE-INPUT 0 (STRING COMPLETER)))
				   ((OR (CHAR-EQUAL COMPLETER #\COMPLETE)
					(NOT OR-NIL))
				    (SEND STREAM :BEEP))
				   (T (RETURN NIL)))
			     ;; user has typed something
			     (MULTIPLE-VALUE-BIND (COMPLETE-STRING POSSIBILITIES COMPLETED-P)
				 (COMPLETE-STRING STRING ALIST DELIMITERS
						  ;; only complete as far as next delimiter
						  ;; if partial-completer triggered rescan
						  (MEM-CHAR COMPLETER PARTIAL-COMPLETERS)
						  ;; ignore trailing space if attempting to
						  ;; exit the read
						  (MEM-CHAR COMPLETER
							    '(#\RETURN #\LINE #\END)))
			       ;; If some completion occurred, update the display.
			       (WHEN COMPLETED-P
				 (SEND STREAM :REPLACE-INPUT NIL COMPLETE-STRING))

			       ;; decide when to insert the completion trigger char
			       (WHEN (MEM-CHAR COMPLETER PARTIAL-COMPLETERS)
				 ;; Insert the char only if the completion
				 ;; doesn't end in one of the delimiters.
				 (WHEN (OR (CDR POSSIBILITIES)
					   IMPOSSIBLE-IS-OK)
				   ;; more than one possibility
				   (UNLESS
				     (AND COMPLETED-P
					  (MEM #'CHAR-EQUAL
					       (AREF COMPLETE-STRING
						     (1- (STRING-LENGTH COMPLETE-STRING)))
					       DELIMITERS))
				     (SEND STREAM :REPLACE-INPUT 0 (STRING COMPLETER)))))
			       
			       ;; decide whether to return or try for more
			       (COND ((MEM-CHAR COMPLETER '(#\RETURN #\END #\LINE))
				      (IF (OR (ASSOC (STRING-RIGHT-TRIM
						       PARTIAL-COMPLETERS
						       COMPLETE-STRING)
						     POSSIBILITIES)
					      IMPOSSIBLE-IS-OK)
					  ;; User asked for termination and we have a valid
					  ;; completion or IMPOSSIBLE-IS-OK
					  (RETURN (VALUES COMPLETE-STRING POSSIBILITIES))
					  ;; Otherwise indicate failure
					  (SEND STREAM :BEEP)))
				      ;; If he hit  , notify if no completion happened
				     ((CHAR-EQUAL COMPLETER #\COMPLETE)
				      (UNLESS COMPLETED-P
					(SEND STREAM :BEEP))))
			       ;; If we haven't returned by now, try reading some more
			       (SEND STREAM :FORCE-RESCAN)))))

		      ;; non-blip characters
		      (T (ARRAY-PUSH-EXTEND STRING CHAR)))))))))))

;; If there are fewer than this many entries in the completion alist, then the † key will
;; list them.  Otherwise, it will just print a general information message.  c-? can be used
;; to list every entry in the completion alist.

(DEFVAR *READ-COMPLETE-STRING-HELP-THRESHOLD* 100.)

(DEFUN READ-COMPLETE-STRING-HELP (STREAM ALIST DELIMITERS)
  (IF (OR (STRING-SEARCH-NOT-SET *WHITESPACE* (SEND STREAM :INPUT-BUFFER))
	  (NOT *READ-COMPLETE-STRING-HELP-THRESHOLD*)
	  (< (FIND-COMPLETION-ALIST-SIZE ALIST) *READ-COMPLETE-STRING-HELP-THRESHOLD*))
      (COM-DISPLAY-COMPLETIONS STREAM ALIST DELIMITERS)
      (SEND STREAM :DISPLAY-HELP)))

;; This function can be written in terms of READ-COMPLETE-STRING or READ-EXPRESSION.
;; Using READ-COMPLETE-STRING has these advantages:
;;   1. Package names may be abbreviated.  READ-EXPRESSION will give a read-time error.
;;   2. The flavor name may be typed in the wrong package.  The correct symbol will be
;;	determined from the list of possibilities.
;;   3. ” will complete and activate, rather than just activate.

(DEFUN READ-FLAVOR-NAME (&OPTIONAL STREAM (IMPOSSIBLE-IS-OK T))
  (OR STREAM (SETQ STREAM QUERY-IO))
  (WITH-INPUT-EDITING (STREAM)
    (MULTIPLE-VALUE-BIND (COMPLETE-STRING POSSIBILITIES)
	(READ-COMPLETE-STRING :FLAVORS '(#/- #/:) STREAM T NIL NIL)
      (OR (CADR (ASSOC COMPLETE-STRING POSSIBILITIES))
	  (LET ((NAME (READ-FROM-STRING COMPLETE-STRING)))
	    (WHEN (AND (NOT IMPOSSIBLE-IS-OK) (NOT (FLAVOR:FIND-FLAVOR NAME NIL)))
	      (PARSE-FERROR "~S is not the name of a flavor" NAME))
	    NAME)))))

;; (DEFUN READ-FLAVOR-NAME (&OPTIONAL STREAM (IMPOSSIBLE-IS-OK T))
;;   (OR STREAM (SETQ STREAM STANDARD-INPUT))
;;   (WITH-INPUT-EDITING (STREAM :END-ACTIVATION)
;;     (LET ((NAME (READ-EXPRESSION STREAM
;;				    :COMPLETION-ALIST :FLAVORS
;;				    :COMPLETION-DELIMITERS '(#/- #/:))))
;;       (WHEN (AND (NOT IMPOSSIBLE-IS-OK) (NOT (GET NAME 'FLAVOR)))
;;	   (PARSE-FERROR "~S is not the name of a flavor" NAME))
;;       NAME)))

(DEFUN READ-PRINTER (STREAM &OPTIONAL DEFAULT OR-NIL)
  (CHECK-ARG DEFAULT
	     (OR (NULL DEFAULT)
		 (TYPEP DEFAULT 'PRINTER))
	     "a printer or NIL")
  (MULTIPLE-VALUE-BIND (NIL LIST-OF-STUFF)
      (READ-COMPLETE-STRING (HARDCOPY:GET-HARDCOPY-DEVICE-ALIST)
			    '(#\SP)		;delimiters
			    STREAM
			    ()			;impossible-is-ok
			    (OR DEFAULT OR-NIL)	;or-nil
			    )
    (IF LIST-OF-STUFF
	(CDR (FIRST LIST-OF-STUFF))
	DEFAULT)))

;; General purpose prompting and reading facility.
;; Syntax is either:
;;    (PROMPT-AND-READ TYPE FORMAT-STRING &REST FORMAT-ARGS)
;;    (PROMPT-AND-READ (TYPE . TYPE-ARGS) FORMAT-STRING &REST FORMAT-ARGS)

;; TYPE determines the type of reading which will take place.  The PROMPT-AND-READ property of
;; TYPE is expected to be a dispatch function which reads from QUERY-IO and which accepts
;; TYPE-ARGS as arguments.  By convention, TYPE-ARGS is an alternating list of keywords and
;; values.  DEFINE-PROMPT-AND-READ-TYPE enforces this.  The dispatch function may enable
;; further input editor options, and then pass them on to a more primitive function (such as
;; READLINE or READ) or invoke the input editor directly.  It is the responsibility of the
;; dispatch function to provide input editing if it is needed.  The dispatch function may also
;; bind *PROMPT-AND-READ-VISIBLE-SUFFIX* to modify a caller-supplied prompt.

;; A deficiency with the current design is that there is no way to filter one of the keyword
;; arguments before passing it to either of the dispatch functions.  Some examples of how this
;; would be used:
;;   Parse the :DEFAULT argument to :PATHNAME
;;   Parse the :DEFAULT argument to :HOST
;;   Prompt the user if the :CLASS argument to :OBJECT is NIL.

(DEFVAR *PROMPT-AND-READ-TYPES* NIL :LOCALIZE T)
(DEFVAR *PROMPT-AND-READ-ECHO*)
(DEFVAR *PROMPT-AND-READ-VISIBLE-SUFFIX*)

(DEFUN PROMPT-AND-READ-DESCRIBE-TYPE (STREAM TYPE-KEYWORD TYPE-ARGS)
  (LET ((TYPE-DESCRIPTION (GET TYPE-KEYWORD 'PROMPT-AND-READ-DESCRIPTION)))
    (IF TYPE-DESCRIPTION
	(LEXPR-FUNCALL TYPE-DESCRIPTION STREAM TYPE-ARGS)
	(FORMAT STREAM "a ~A" TYPE-KEYWORD))))

(DEFUN PROMPT-AND-READ-PROMPT (STREAM IGNORE TYPE-KEYWORD TYPE-ARGS PROMPT)
  (IF (CAR PROMPT)
      (PROGN (LEXPR-FUNCALL #'FORMAT STREAM PROMPT)
	     (WHEN *PROMPT-AND-READ-VISIBLE-SUFFIX*
	       (LEXPR-FUNCALL #'FORMAT STREAM *PROMPT-AND-READ-VISIBLE-SUFFIX*)))
      (PROGN (SEND STREAM :STRING-OUT "Enter ")
	     (PROMPT-AND-READ-DESCRIBE-TYPE STREAM TYPE-KEYWORD TYPE-ARGS)
	     (SEND STREAM :STRING-OUT ": "))))

(DEFUN PROMPT-AND-READ-HELP (STREAM CONTINUATION TYPE-KEYWORD TYPE-ARGS)
  (SEND STREAM :STRING-OUT "You are being prompted to enter ")
  (PROMPT-AND-READ-DESCRIBE-TYPE STREAM TYPE-KEYWORD TYPE-ARGS)
  (SEND STREAM :LINE-OUT ".")
  (UNLESS (STRING-SEARCH-NOT-SET *WHITESPACE* (SEND STREAM :INPUT-BUFFER))
    (APPLY (CAR CONTINUATION) (CDR CONTINUATION))))

(DEFUN PROMPT-AND-READ-INTERNAL (FUNCTION TYPE-KEYWORD TYPE-ARGS PROMPT)
  (LET ((*PROMPT-AND-READ-VISIBLE-SUFFIX* NIL))
    (WITH-INPUT-EDITING-OPTIONS
	(((:PROMPT :OVERRIDE) #'PROMPT-AND-READ-PROMPT TYPE-KEYWORD TYPE-ARGS PROMPT)
	 (:MERGED-HELP #'PROMPT-AND-READ-HELP TYPE-KEYWORD TYPE-ARGS))
      (LET ((VALUES (MULTIPLE-VALUE-LIST
		      (LEXPR-SEND-IF-HANDLES QUERY-IO :PROMPT-AND-READ TYPE-KEYWORD PROMPT))))
	(IF (CAR VALUES)
	    (VALUES-LIST (CDR VALUES))
	    (LEXPR-FUNCALL FUNCTION TYPE-ARGS))))))

(DEFUN PROMPT-AND-READ (TYPE &OPTIONAL FORMAT-STRING &REST FORMAT-ARGS)
  (LET (FUNCTION TYPE-KEYWORD TYPE-ARGS)
    ;; Destructure TYPE inside the CHECK-ARG in case it is given a new value by the debugger.
    (CHECK-ARG TYPE
	       (PROGN 
		 (IF (LISTP TYPE)
		     (SETQ TYPE-ARGS (CDR TYPE)
			   TYPE-KEYWORD (CAR TYPE))
		     (SETQ TYPE-ARGS NIL
			   TYPE-KEYWORD TYPE))
		 (IF (SYMBOLP TYPE-KEYWORD)
		     (SETQ FUNCTION (GET TYPE-KEYWORD 'PROMPT-AND-READ))))
	       "a valid type keyword")
    (CHECK-INTERACTIVE-STREAM QUERY-IO)
    (WITH-STACK-LIST* (PROMPT FORMAT-STRING FORMAT-ARGS)
      (IF (NOT RUBOUT-HANDLER)
	  (PROMPT-AND-READ-INTERNAL FUNCTION TYPE-KEYWORD TYPE-ARGS PROMPT)
	  (WITH-IE-TYPEIN (QUERY-IO)
	    (PROMPT-AND-READ-INTERNAL FUNCTION TYPE-KEYWORD TYPE-ARGS PROMPT))))))

(DEFPROP DEFINE-PROMPT-AND-READ-TYPE "PROMPT-AND-READ type" DEFINITION-TYPE-NAME)

(DEFMACRO DEFINE-PROMPT-AND-READ-TYPE (KEYWORD BVL DESCRIPTION &BODY BODY)
  (CHECK-ARG-TYPE KEYWORD :SYMBOL)
  (CHECK-ARG BVL CL:LISTP "a list of keyword arguments")
  (CHECK-ARG DESCRIPTION
	     (OR (STRINGP DESCRIPTION) (CL:LISTP DESCRIPTION))
	     "a FORMAT string; a list of a FORMAT string and arguments; or a form to evaluate")
  (IF BVL (PUSH '&KEY BVL))
  `(LOCAL-DECLARE ((FUNCTION-PARENT ,KEYWORD DEFINE-PROMPT-AND-READ-TYPE))
     (RECORD-SOURCE-FILE-NAME ',KEYWORD 'DEFINE-PROMPT-AND-READ-TYPE)
     (ADD-PROMPT-AND-READ-KEYWORD ',KEYWORD)
     (DEFUN (,KEYWORD PROMPT-AND-READ) ,BVL . ,BODY)
     ,(IF (NULL DESCRIPTION)
	  `(NREMPROP ',KEYWORD 'PROMPT-AND-READ-DESCRIPTION)
	  `(DEFUN (,KEYWORD PROMPT-AND-READ-DESCRIPTION) (STANDARD-OUTPUT . ,BVL)
	     ,@(MAPCAR (LAMBDA (X)
			 (COND ((ATOM X) X)
			       ((ATOM (CAR X)) (CAR X))
			       (T (CADR (CAR X)))))
		       (CDR BVL))
	     ,(COND ((STRINGP DESCRIPTION)
		     `(FORMAT T ,DESCRIPTION))
		    ((STRINGP (CAR DESCRIPTION))
		     `(FORMAT T . ,DESCRIPTION))
		    (T DESCRIPTION))))
     ))

(DEFUN ADD-PROMPT-AND-READ-KEYWORD (KEYWORD)
  (UNLESS (MEMQ KEYWORD *PROMPT-AND-READ-TYPES*)
    (SETF *PROMPT-AND-READ-TYPES* (NCONC *PROMPT-AND-READ-TYPES* (NCONS KEYWORD)))))

(DEFUN DESCRIBE-OR-NIL-OPTION (OR-NIL &OPTIONAL CHARACTER)
  (OR CHARACTER (SETQ CHARACTER #\RETURN))
  (WHEN OR-NIL
    (FORMAT T ", or ~ for none" CHARACTER)))

(DEFUN DESCRIBE-TOKEN (OR-NIL FORMAT-STRING &REST FORMAT-ARGS)
  (LEXPR-FUNCALL #'FORMAT T FORMAT-STRING FORMAT-ARGS)
  (DESCRIBE-OR-NIL-OPTION OR-NIL))

(DEFUN DESCRIBE-TOKEN-LIST (OR-NIL SEPARATOR FORMAT-STRING &REST FORMAT-ARGS)
  (FORMAT T "a list of ~1{~:}, separated by ~A" FORMAT-STRING FORMAT-ARGS SEPARATOR)
  (DESCRIBE-OR-NIL-OPTION OR-NIL))

(DEFINE-PROMPT-AND-READ-TYPE :CHARACTER () "a character"
  (SEND QUERY-IO :FRESH-LINE)
  (LET ((CHAR (READ-CHARACTER QUERY-IO :PROMPT (INPUT-EDITOR-OPTION :PROMPT))))
    (FORMAT QUERY-IO "~C" CHAR)
    CHAR))

(DEFINE-PROMPT-AND-READ-TYPE :SYMBOL
			     ()
			     "a symbol"
  (WITH-INPUT-EDITING (QUERY-IO :END-ACTIVATION)
    (LET ((FORM (READ QUERY-IO)))
      (UNLESS (SYMBOLP FORM)
	(PARSE-FERROR "A symbol is required"))
      FORM)))

(DEFINE-PROMPT-AND-READ-TYPE :STRING
			     ()
			     "a line of text"
  (SETQ *PROMPT-AND-READ-ECHO* T)
  (READLINE QUERY-IO))

(DEFINE-PROMPT-AND-READ-TYPE :STRING-TRIM
			     ()
			     "a line of text (whitespace will be trimmed)"
  (READLINE-TRIM QUERY-IO))

(DEFINE-PROMPT-AND-READ-TYPE :STRING-OR-NIL
			     ()
			     (DESCRIBE-TOKEN T "a line of text (whitespace will be trimmed)")
  (READLINE-OR-NIL QUERY-IO))

(DEFINE-PROMPT-AND-READ-TYPE :STRING-LIST
			     ((OR-NIL T))
			     (DESCRIBE-TOKEN-LIST OR-NIL "commas" "strings")
  (READ-STRING-LIST QUERY-IO #/, OR-NIL))

(DEFUN DESCRIBE-DELIMITED-STRING-TYPE (DELIMITER VISIBLE-DELIMITER OR-NIL)
  (SETQ DELIMITER (OR DELIMITER VISIBLE-DELIMITER #\END))
  (COERCE-TO-LIST DELIMITER
    (FORMAT T "one or more lines of text, ~
	       delimited by ~{~#[~;~~:;~ or ~]~}~
	       ~:[~;, or just ~:[~~;a delimiter~] for none~]"
	    DELIMITER OR-NIL (CDR DELIMITER) (CAR DELIMITER))))

(DEFUN PROMPT-AND-READ-DELIMITED-STRING (DELIMITER VISIBLE-DELIMITER BUFFER-SIZE OR-NIL)
  (CHECK-DELIMITER-ARG DELIMITER)
  (CHECK-DELIMITER-ARG VISIBLE-DELIMITER)
  (CHECK-ARG BUFFER-SIZE (OR (NULL BUFFER-SIZE) (FIXP BUFFER-SIZE)) "an integer, or NIL")
  (SETQ *PROMPT-AND-READ-ECHO* T)
  (MULTIPLE-VALUE-BIND (STRING EOF DELIMITER DELIMITER-ARG)
      (COND ((NOT VISIBLE-DELIMITER)
	     (READ-DELIMITED-STRING (OR DELIMITER #\END) QUERY-IO NIL NIL BUFFER-SIZE))
	    ((NOT DELIMITER)
	     (COERCE-TO-LIST VISIBLE-DELIMITER
	       (WITH-STACK-LIST (*PROMPT-AND-READ-VISIBLE-SUFFIX*
				  "(delimiter ~{~#[~;~~:;~ or ~]~}) "
				  VISIBLE-DELIMITER)
		 (READ-DELIMITED-STRING VISIBLE-DELIMITER QUERY-IO NIL NIL BUFFER-SIZE))))
	    (T (FERROR "The :DELIMITER and :VISIBLE-DELIMITER options are mutually exclusive.")))
    (VALUES (IF (AND OR-NIL (EQUAL STRING "")) NIL STRING)
	    EOF DELIMITER DELIMITER-ARG)))

(DEFINE-PROMPT-AND-READ-TYPE :DELIMITED-STRING
			     (DELIMITER VISIBLE-DELIMITER BUFFER-SIZE OR-NIL)
			     (DESCRIBE-DELIMITED-STRING-TYPE DELIMITER VISIBLE-DELIMITER OR-NIL)
  (PROMPT-AND-READ-DELIMITED-STRING DELIMITER VISIBLE-DELIMITER BUFFER-SIZE OR-NIL))

(DEFINE-PROMPT-AND-READ-TYPE :DELIMITED-STRING-OR-NIL
			     (DELIMITER VISIBLE-DELIMITER BUFFER-SIZE)
			     (DESCRIBE-DELIMITED-STRING-TYPE DELIMITER VISIBLE-DELIMITER T)
  (PROMPT-AND-READ-DELIMITED-STRING DELIMITER VISIBLE-DELIMITER BUFFER-SIZE T))

(DEFINE-PROMPT-AND-READ-TYPE :COMPLETE-STRING
			     (ALIST DELIMITERS (IMPOSSIBLE-IS-OK T) (OR-NIL T) (COMPLETE-ON-SPACE T))
			     (DESCRIBE-TOKEN OR-NIL "a string with completion")
  (READ-COMPLETE-STRING ALIST DELIMITERS QUERY-IO IMPOSSIBLE-IS-OK OR-NIL COMPLETE-ON-SPACE))

(DEFINE-PROMPT-AND-READ-TYPE :FLAVOR-NAME
			     ((IMPOSSIBLE-IS-OK T))
			     "the name of a flavor"
  (READ-FLAVOR-NAME QUERY-IO IMPOSSIBLE-IS-OK))

;; The types :DECIMAL-NUMBER, :OCTAL-NUMBER, :NUMBER-OR-NIL, :DECIMAL-NUMBER-OR-NIL,
;; :OCTAL-NUMBER-OR-NIL, :PAST-DATE, :DATE-OR-NEVER, :PAST-DATE-OR-NEVER are obsolete since
;; they can be specified with keyword arguments to :NUMBER and :DATE.  They exist only for
;; compatibility with old code and for compatibility with CVV, which doesn't yet have
;; parameterized types.

(DEFUN DESCRIBE-NUMBER-TYPE (INPUT-BASE OR-NIL)
  (UNLESS INPUT-BASE (SETQ INPUT-BASE 10.))
  (FORMAT T "~[~8;an octal number~10;a decimal number~:;a number in base ~:*~D~]"
	  INPUT-BASE)
  (DESCRIBE-OR-NIL-OPTION OR-NIL))

;; The keyword :INPUT-RADIX was used in Rel 5.  It was made obsolete in Rel 6 by the keyword
;; :BASE, which is also used by the CP :NUMBER type reader.  :INPUT-RADIX should not be
;; documented.

(DEFINE-PROMPT-AND-READ-TYPE :NUMBER
			     (((:BASE INPUT-BASE)) INPUT-RADIX OR-NIL)
			     (DESCRIBE-NUMBER-TYPE (OR INPUT-BASE INPUT-RADIX) OR-NIL)
  (READ-NUMBER QUERY-IO (OR INPUT-BASE INPUT-RADIX) OR-NIL))

(DEFINE-PROMPT-AND-READ-TYPE :NUMBER-OR-NIL
			     (((:BASE INPUT-BASE)) INPUT-RADIX)
			     (DESCRIBE-NUMBER-TYPE (OR INPUT-BASE INPUT-RADIX) T)
  (READ-NUMBER QUERY-IO (OR INPUT-BASE INPUT-RADIX) T))

(DEFINE-PROMPT-AND-READ-TYPE :DECIMAL-NUMBER
			     (OR-NIL)
			     (DESCRIBE-NUMBER-TYPE 10. OR-NIL)
  (READ-NUMBER QUERY-IO 10. OR-NIL))

(DEFINE-PROMPT-AND-READ-TYPE :DECIMAL-NUMBER-OR-NIL
			     ()
			     (DESCRIBE-NUMBER-TYPE 10. T)
  (READ-NUMBER QUERY-IO 10. T))

(DEFINE-PROMPT-AND-READ-TYPE :OCTAL-NUMBER
			     (OR-NIL)
			     (DESCRIBE-NUMBER-TYPE 8 OR-NIL)
  (READ-NUMBER QUERY-IO 8 OR-NIL))

(DEFINE-PROMPT-AND-READ-TYPE :OCTAL-NUMBER-OR-NIL
			     ()
			     (DESCRIBE-NUMBER-TYPE 8 T)
  (READ-NUMBER QUERY-IO 8 T))

(DEFUN DESCRIBE-INTEGER-TYPE (INPUT-BASE OR-NIL FROM TO)
  (UNLESS INPUT-BASE (SETQ INPUT-BASE 10.))
  (FORMAT T "~[~8;an octal integer~10;a decimal integer~:;an integer in base ~:*~D~]~
	     ~:[~4*~; between ~VR and ~VR~]~
	     ~:[~2*~; greater than or equal to ~VR~]~
	     ~:[~2*~; less than or equal to ~VR~]"
	  INPUT-BASE
	  (AND FROM TO) INPUT-BASE FROM INPUT-BASE TO
	  (AND FROM (NOT TO)) INPUT-BASE FROM
	  (AND (NOT FROM) TO) INPUT-BASE TO)
  (DESCRIBE-OR-NIL-OPTION OR-NIL))

(DEFINE-PROMPT-AND-READ-TYPE :INTEGER
			     (((:BASE INPUT-BASE)) OR-NIL FROM TO)
			     (DESCRIBE-INTEGER-TYPE INPUT-BASE OR-NIL FROM TO)
  (READ-INTEGER QUERY-IO INPUT-BASE OR-NIL FROM TO))

(DEFUN DESCRIBE-NUMBER-LIST-TYPE (INPUT-BASE OR-NIL)
  (UNLESS INPUT-BASE (SETQ INPUT-BASE 10.))
  (FORMAT T "~[~8;a list of octal numbers~10;a list of decimal numbers~:;a list of numbers in base ~:*~D~]"
	  INPUT-BASE)
  (DESCRIBE-OR-NIL-OPTION OR-NIL))

(DEFINE-PROMPT-AND-READ-TYPE :NUMBER-LIST
			     (((:BASE INPUT-BASE)) (OR-NIL T))
			     (DESCRIBE-NUMBER-LIST-TYPE INPUT-BASE OR-NIL)
  (READ-NUMBER-LIST QUERY-IO INPUT-BASE OR-NIL))

(DEFUN DESCRIBE-INTEGER-LIST-TYPE (INPUT-BASE OR-NIL FROM TO)
  (UNLESS INPUT-BASE (SETQ INPUT-BASE 10.))
  (FORMAT T "~[~8;a list of octal integers~10;a list of decimal integers~:;a list of integers in base ~:*~D~]~
	     ~:[~4*~; between ~VR and ~VR~]~
	     ~:[~2*~; greater than or equal to ~VR~]~
	     ~:[~2*~; less than or equal to ~VR~]"
	  INPUT-BASE
	  (AND FROM TO) INPUT-BASE FROM INPUT-BASE TO
	  (AND FROM (NOT TO)) INPUT-BASE FROM
	  (AND (NOT FROM) TO) INPUT-BASE TO)
  (DESCRIBE-OR-NIL-OPTION OR-NIL))

(DEFINE-PROMPT-AND-READ-TYPE :INTEGER-LIST
			     (((:BASE INPUT-BASE)) (OR-NIL T) FROM TO)
			     (DESCRIBE-INTEGER-LIST-TYPE INPUT-BASE OR-NIL FROM TO)
  (READ-INTEGER-LIST QUERY-IO INPUT-BASE OR-NIL FROM TO))

(DEFUN DESCRIBE-DATE-TYPE (PAST-P NEVER-P BASE-TIME OR-NIL)
  (FORMAT T "a date~
	     ~:[~; in the past~]~
	     ~@[ using ~\TIME\ as the base~]~
	     ~:[~;, or /"never/"~]~
	     ~:[~;, or ~ for /"never/"~]"
	  PAST-P BASE-TIME NEVER-P OR-NIL #\RETURN))

(DEFINE-PROMPT-AND-READ-TYPE :DATE
			     (PAST-P NEVER-P BASE-TIME OR-NIL)
			     (DESCRIBE-DATE-TYPE PAST-P NEVER-P BASE-TIME OR-NIL)
  (READ-DATE QUERY-IO PAST-P NEVER-P BASE-TIME OR-NIL))

(DEFINE-PROMPT-AND-READ-TYPE :PAST-DATE
			     (NEVER-P BASE-TIME OR-NIL)
			     (DESCRIBE-DATE-TYPE T NEVER-P BASE-TIME OR-NIL)
  (READ-DATE QUERY-IO T NEVER-P BASE-TIME OR-NIL))

(DEFINE-PROMPT-AND-READ-TYPE :DATE-OR-NEVER
			     (PAST-P BASE-TIME OR-NIL)
			     (DESCRIBE-DATE-TYPE PAST-P T BASE-TIME OR-NIL)
  (READ-DATE QUERY-IO PAST-P T BASE-TIME OR-NIL))

(DEFINE-PROMPT-AND-READ-TYPE :PAST-DATE-OR-NEVER
			     (BASE-TIME OR-NIL)
			     (DESCRIBE-DATE-TYPE T T BASE-TIME OR-NIL)
  (READ-DATE QUERY-IO T T BASE-TIME OR-NIL))

(DEFINE-PROMPT-AND-READ-TYPE :TIME-INTERVAL-OR-NEVER
			     ()
			     "a time interval, or /"never/""
  (READ-INTERVAL-OR-NEVER QUERY-IO))

(DEFUN DESCRIBE-PATHNAME-TYPE (DEFAULT VISIBLE-DEFAULT OR-NIL)
  (FORMAT T "a pathname, with ~A as the default"
	  (OR DEFAULT VISIBLE-DEFAULT (FS:DEFAULT-PATHNAME)))
  (DESCRIBE-OR-NIL-OPTION OR-NIL #\END))

(DEFUN DESCRIBE-PATHNAME-LIST-TYPE (DEFAULT VISIBLE-DEFAULT OR-NIL)
  (FORMAT T "a list of pathnames, separated by commas,~% with ~A as the default"
	  (OR DEFAULT VISIBLE-DEFAULT (FS:DEFAULT-PATHNAME)))
  (DESCRIBE-OR-NIL-OPTION OR-NIL))

(DEFMACRO WITH-VISIBLE-DEFAULT (VISIBLE-DEFAULT-VAR &BODY BODY)
  `(WITH-STACK-LIST (*PROMPT-AND-READ-VISIBLE-SUFFIX* "(default ~A) " ,VISIBLE-DEFAULT-VAR)
     . ,BODY))

(DEFUN PROMPT-AND-READ-PATHNAME (DEFAULT VISIBLE-DEFAULT DEFAULT-VERSION OR-NIL)
  (MULTIPLE-VALUE-BIND (PATHNAME STRING DELIMITER)
      (COND ((NOT VISIBLE-DEFAULT)
	     (READ-PATHNAME QUERY-IO DEFAULT DEFAULT-VERSION T))
	    ((NOT DEFAULT)
	     (WITH-VISIBLE-DEFAULT VISIBLE-DEFAULT
	       (READ-PATHNAME QUERY-IO VISIBLE-DEFAULT DEFAULT-VERSION T)))
	    (T (FERROR "The :DEFAULT and :VISIBLE-DEFAULT options are mutually exclusive.")))
    (COND
      ;; A pathname was typed.  If the pathname was completed, i.e. input was terminated
      ;; with End, then don't re-echo.
      ((STRINGP STRING)
       (IF (EQL DELIMITER #\END) (SETQ *PROMPT-AND-READ-ECHO* T))
       PATHNAME)
      ;; The :PREEMPTABLE input editor option was specified, and a blip is being returned.
      ((NOT (NULL STRING))
       (VALUES PATHNAME STRING))
      ;; If nothing was typed, either echo [None] or the default, depending upon
      ;; the value of OR-NIL.
      (T (SETQ *PROMPT-AND-READ-ECHO* T)
	 (COND ((AND (EQL DELIMITER #\END) OR-NIL)
		(SEND QUERY-IO :LINE-OUT "[None]")
		NIL)
	       (T (SEND PATHNAME :PRINT-SELF QUERY-IO NIL NIL)
		  (SEND QUERY-IO :TYO #\NEWLINE)
		  PATHNAME))))))

(DEFINE-PROMPT-AND-READ-TYPE :PATHNAME
			     (DEFAULT VISIBLE-DEFAULT DEFAULT-VERSION OR-NIL)
			     (DESCRIBE-PATHNAME-TYPE DEFAULT VISIBLE-DEFAULT OR-NIL)
  (PROMPT-AND-READ-PATHNAME DEFAULT VISIBLE-DEFAULT DEFAULT-VERSION OR-NIL))

;; In CVV, Return means NIL.
;; In P&R, Return means accept the default and End means NIL.
;; This should be made consistent.

(DEFINE-PROMPT-AND-READ-TYPE :PATHNAME-OR-NIL
			     (DEFAULT VISIBLE-DEFAULT DEFAULT-VERSION)
			     (DESCRIBE-PATHNAME-TYPE DEFAULT VISIBLE-DEFAULT T)
  (PROMPT-AND-READ-PATHNAME DEFAULT VISIBLE-DEFAULT DEFAULT-VERSION T))

(DEFINE-PROMPT-AND-READ-TYPE :PATHNAME-LIST
			     (DEFAULT VISIBLE-DEFAULT (OR-NIL T))
			     (DESCRIBE-PATHNAME-LIST-TYPE DEFAULT VISIBLE-DEFAULT OR-NIL)
  (COND ((NOT VISIBLE-DEFAULT)
	 (READ-PATHNAME-LIST QUERY-IO DEFAULT OR-NIL))
	((NOT DEFAULT)
	 (WITH-VISIBLE-DEFAULT VISIBLE-DEFAULT
	   (READ-PATHNAME-LIST QUERY-IO VISIBLE-DEFAULT OR-NIL)))
	(T (FERROR "The :DEFAULT and :VISIBLE-DEFAULT options are mutually exclusive."))))

(DEFINE-PROMPT-AND-READ-TYPE :EXPRESSION
			     ()
			     "an expression"
  (READ-EXPRESSION QUERY-IO))

(DEFINE-PROMPT-AND-READ-TYPE :EXPRESSION-OR-END
			     ()
			     "an expression, or ” for none"
  (MULTIPLE-VALUE-BIND (FORM FLAG)
      (READ-OR-END QUERY-IO)
    (WHEN (EQ FLAG :END)
      (SETQ *PROMPT-AND-READ-ECHO* T)
      (SEND QUERY-IO :LINE-OUT "[End]"))
    (VALUES FORM FLAG)))

(DEFINE-PROMPT-AND-READ-TYPE :EVAL-FORM
			     ((ENVIRONMENT *READ-FORM-ENVIRONMENT*))
			     "a form to be evaluated"
  (EVAL-FORM-INTERNAL #'(LAMBDA (&OPTIONAL STREAM)
			  (READ-FORM STREAM :ENVIRONMENT ENVIRONMENT))
		      ENVIRONMENT))

(DEFINE-PROMPT-AND-READ-TYPE :EVAL-FORM-OR-END
			     ((ENVIRONMENT *READ-FORM-ENVIRONMENT*))
			     "a form to be evaluated, or ” for none"
  (EVAL-FORM-INTERNAL #'READ-OR-END ENVIRONMENT
		      #'(LAMBDA (&OPTIONAL STREAM)
			  (READ-FORM STREAM :ENVIRONMENT ENVIRONMENT))))

(DEFUN EVAL-FORM-INTERNAL (FUNCTION ENVIRONMENT &REST ARGUMENTS)
  (DECLARE (SYS:DOWNWARD-FUNARG FUNCTION))
  (SETQ *PROMPT-AND-READ-ECHO* T)
  (DO () (NIL)
    (MULTIPLE-VALUE-BIND (FORM FLAG)
	(LEXPR-FUNCALL FUNCTION QUERY-IO ARGUMENTS)
      (WHEN (EQ FLAG :END)
	(SEND QUERY-IO :STRING-OUT "[End]")
	(RETURN (VALUES NIL :END)))
      (LET ((VALUE (LET ((*INPUT-EDITOR-OPTIONS* NIL))
		     (EVAL FORM ENVIRONMENT))))	;Evaluate in the right environment
	(IF (OR (CL:CONSTANTP FORM)
		(LET ((QUERY-IO QUERY-IO)
		      (PRINLEVEL DBG:*ERROR-MESSAGE-PRINLEVEL*)
		      (PRINLENGTH DBG:*ERROR-MESSAGE-PRINLENGTH*)
		      (SCL:*PRINT-STRING-LENGTH* DBG:*ERROR-MESSAGE-STRING-LENGTH*))
		  (FQUERY () "Value is ~S, okay? " VALUE)))
	    (RETURN VALUE))))))

;; Like :EVAL-FORM-OR-END, etc., except that we do not do the evaluation here
(DEFINE-PROMPT-AND-READ-TYPE :FORM
			     ((ENVIRONMENT *READ-FORM-ENVIRONMENT*))
			     "a form to be evaluated, or ” for none"
  (EVAL-FORM-OR-CHARACTERS '() '() ENVIRONMENT))

(DEFINE-PROMPT-AND-READ-TYPE :FORM-OR-END
			     ((ENVIRONMENT *READ-FORM-ENVIRONMENT*))
			     "a form to be evaluated, or ” for none"
  (EVAL-FORM-OR-CHARACTERS '(#\END) '(:END) ENVIRONMENT))

(DEFINE-PROMPT-AND-READ-TYPE :FORM-OR-RETURN
			     ((ENVIRONMENT *READ-FORM-ENVIRONMENT*))
			     "a form to be evaluated, or Return for default"
  (EVAL-FORM-OR-CHARACTERS '(#\RETURN) '(:RETURN) ENVIRONMENT))

(DEFINE-PROMPT-AND-READ-TYPE :FORM-OR-RETURN-OR-END
			     ((ENVIRONMENT *READ-FORM-ENVIRONMENT*))
			     "a form to be evaluated, or Return for default, or ” for none"
  (EVAL-FORM-OR-CHARACTERS '(#\RETURN #\END) '(:RETURN :END) ENVIRONMENT))

(DEFUN EVAL-FORM-OR-CHARACTERS (CHARACTERS FLAGS ENVIRONMENT)
  (MULTIPLE-VALUE-BIND (VALUE FLAG CHAR)
      (READ-OR-CHARACTER CHARACTERS QUERY-IO
			 #'(LAMBDA (&OPTIONAL STREAM)
			     (READ-FORM STREAM :ENVIRONMENT ENVIRONMENT)))
    (SELECTQ FLAG
      (:CHARACTER
       (VALUES NIL
	       (NTH (FIND-POSITION-IN-LIST CHAR CHARACTERS) FLAGS)))
      (OTHERWISE VALUE))))

(DEFUN DESCRIBE-HOST-TYPE (HOST-TYPE DEFAULT OR-NIL)
  (OR HOST-TYPE (SETQ HOST-TYPE :PHYSICAL))
  (FORMAT T "~A~@[, with ~A as the default~]"
	  (SELECTQ HOST-TYPE
	    (:PHYSICAL "a network host")
	    (:CHAOS-ONLY "a host on the Chaosnet")
	    (:OR-LOCAL "a network host, or /"local/"")
	    (:PATHNAME "a pathname host")
	    (:OR-PATHNAME "a network host or a pathname host"))
	  (AND DEFAULT
	       (LET ((HOST (PARSE-HOST-1 DEFAULT HOST-TYPE)))
		 (OR (SEND-IF-HANDLES HOST :PRETTY-NAME)
		     HOST))))
  (DESCRIBE-OR-NIL-OPTION OR-NIL))

(DEFUN DESCRIBE-HOST-LIST-TYPE (HOST-TYPE OR-NIL)
  (OR HOST-TYPE (SETQ HOST-TYPE :PHYSICAL))
  (FORMAT T "a list of ~A, separated by spaces"
	  (SELECTQ HOST-TYPE
	    (:PHYSICAL "network hosts")
	    (:CHAOS-ONLY "hosts on the Chaosnet")
	    (:OR-LOCAL "network hosts, or /"local/"")
	    (:PATHNAME "pathname hosts")
	    (:OR-PATHNAME "network hosts or pathname hosts")))
  (DESCRIBE-OR-NIL-OPTION OR-NIL))

(DEFINE-PROMPT-AND-READ-TYPE :HOST
			     (HOST-TYPE DEFAULT OR-NIL)
			     (DESCRIBE-HOST-TYPE HOST-TYPE DEFAULT OR-NIL)
  (READ-HOST QUERY-IO DEFAULT OR-NIL HOST-TYPE))

(DEFINE-PROMPT-AND-READ-TYPE :HOST-OR-LOCAL
			     (DEFAULT OR-NIL)
			     (DESCRIBE-HOST-TYPE :OR-LOCAL DEFAULT OR-NIL)
  (READ-HOST QUERY-IO DEFAULT OR-NIL :OR-LOCAL))

(DEFINE-PROMPT-AND-READ-TYPE :PATHNAME-HOST
			     (DEFAULT OR-NIL)
			     (DESCRIBE-HOST-TYPE :PATHNAME DEFAULT OR-NIL)
  (READ-HOST QUERY-IO DEFAULT OR-NIL :PATHNAME))

(DEFINE-PROMPT-AND-READ-TYPE :HOST-OR-PATHNAME-HOST
			     (DEFAULT OR-NIL)
			     (DESCRIBE-HOST-TYPE :OR-PATHNAME DEFAULT OR-NIL)
  (READ-HOST QUERY-IO DEFAULT OR-NIL :OR-PATHNAME))

(DEFINE-PROMPT-AND-READ-TYPE :HOST-LIST
			     (HOST-TYPE (OR-NIL T))
			     (DESCRIBE-HOST-LIST-TYPE HOST-TYPE OR-NIL)
  (READ-HOST-LIST QUERY-IO HOST-TYPE OR-NIL))

(DEFINE-PROMPT-AND-READ-TYPE :KEYWORD
			     (OR-NIL)
			     (DESCRIBE-TOKEN OR-NIL "a keyword")
  (READ-KEYWORD QUERY-IO OR-NIL))

(DEFINE-PROMPT-AND-READ-TYPE :KEYWORD-LIST
			     ((OR-NIL T))
			     (DESCRIBE-TOKEN-LIST OR-NIL "spaces" "keywords")
  (READ-KEYWORD-LIST QUERY-IO OR-NIL))

(DEFINE-PROMPT-AND-READ-TYPE :FONT
			     (OR-NIL)
			     (DESCRIBE-TOKEN OR-NIL "a font")
  (READ-FONT QUERY-IO OR-NIL))

(DEFINE-PROMPT-AND-READ-TYPE :FONT-LIST
			     ((OR-NIL T))
			     (DESCRIBE-TOKEN-LIST OR-NIL "spaces" "fonts")
  (READ-FONT-LIST QUERY-IO OR-NIL))

(DEFINE-PROMPT-AND-READ-TYPE :CLASS
			     (OR-NIL)
			     (DESCRIBE-TOKEN OR-NIL "a namespace class")
  (READ-CLASS QUERY-IO OR-NIL))

(DEFINE-PROMPT-AND-READ-TYPE :OBJECT
			     (CLASS OR-NIL)
			     (DESCRIBE-TOKEN OR-NIL "a namespace object of class ~A" CLASS)
  (READ-OBJECT QUERY-IO CLASS OR-NIL))

(DEFINE-PROMPT-AND-READ-TYPE :OBJECT-LIST
			     (CLASS (OR-NIL T))
			     (DESCRIBE-TOKEN-LIST OR-NIL "spaces" "namespace objects of class ~A" CLASS)
  (READ-OBJECT-LIST QUERY-IO CLASS OR-NIL))

(DEFINE-PROMPT-AND-READ-TYPE :FUNCTION-SPEC
			     (DEFINED-P)
			     ("a function spec~:[~; which must already be defined~]" DEFINED-P)
  (READ-FUNCTION-SPEC QUERY-IO DEFINED-P))

(DEFINE-PROMPT-AND-READ-TYPE :PRINTER
			     (DEFAULT OR-NIL)
			     (DESCRIBE-TOKEN (AND OR-NIL (NULL DEFAULT))
					     "a printer~@[ (default ~A)~]"
					     (AND DEFAULT
						  (OR (SEND-IF-HANDLES DEFAULT :PRETTY-NAME)
						      DEFAULT)))
  (READ-PRINTER QUERY-IO DEFAULT OR-NIL))

(DEFUN ELECTRIC-PROMPT-AND-READ (TYPE &OPTIONAL FORMAT-STRING &REST FORMAT-ARGS)
  (LET* ((*PROMPT-AND-READ-ECHO* NIL)
	 (VALUES (MULTIPLE-VALUE-LIST
		   (LEXPR-FUNCALL #'PROMPT-AND-READ TYPE FORMAT-STRING FORMAT-ARGS)))
	 (OBJECT (CAR VALUES))
	 (TYPE-KEYWORD (IF (SYMBOLP TYPE) TYPE (CAR TYPE)))
	 (PRINTER (SELECTQ TYPE-KEYWORD
		    ((:EXPRESSION :EXPRESSION-OR-END) 'PRIN1)
		    (:STRING-TRIM 'PRINC)
		    (T (CAR (GET TYPE-KEYWORD 'TV:CHOOSE-VARIABLE-VALUES-KEYWORD))))))
    ;; The cold load stream doesn't support :BUFFER-X
    (IF (AND PRINTER
	     (NOT *PROMPT-AND-READ-ECHO*)
	     (OPERATION-HANDLED-P QUERY-IO :BUFFER-X))
	(LET ((X1 (SEND QUERY-IO :BUFFER-X))
	      (Y1 (SEND QUERY-IO :BUFFER-Y)))
	  (MULTIPLE-VALUE-BIND (X2 Y2)
	      (SEND QUERY-IO :READ-CURSORPOS)
	    (SEND QUERY-IO :CLEAR-BETWEEN-CURSORPOSES X1 Y1 X2 Y2)
	    (SEND QUERY-IO :SET-CURSORPOS X1 Y1)
	    (FUNCALL PRINTER OBJECT QUERY-IO)
	    (SEND QUERY-IO :FRESH-LINE))))
    (VALUES-LIST VALUES)))

(DEFUN PROMPT-AND-READ-TEST (&OPTIONAL ELECTRIC? &AUX VALUES)
  (LOOP FOR TYPE IN *PROMPT-AND-READ-TYPES* DO
	(FORMAT QUERY-IO "~2&")
	(LOOP WHILE (FQUERY NIL "Test ~S? " TYPE) DO
	      (SETQ VALUES
		    (MULTIPLE-VALUE-LIST
		      (IF ELECTRIC?
			  (ELECTRIC-PROMPT-AND-READ TYPE)
			  (PROMPT-AND-READ TYPE))))
	      (FORMAT QUERY-IO "~&Value~:[s are ~{~S~^, ~}~; is ~{~S~}~]."
		      (= (LENGTH VALUES) 1) VALUES))))

;; Fun and games

(DEFVAR *ARROW-BASELINE* 2)
(DEFVAR *ARROW-X-RATIO* 2)
(DEFVAR *ARROW-Y-RATIO* 5)
(DEFVAR *ARROW-SHADOW-P* T)

(DEFUN ARROW-PROMPT (STREAM IGNORE)
  (IF (NOT (OPERATION-HANDLED-P STREAM :DRAW-LINE))
      (SEND STREAM :STRING-OUT "> ")
      (MULTIPLE-VALUE-BIND (X1 Y1)
	  (SEND STREAM :READ-CURSORPOS)
	(LET* ((HEIGHT (- (SEND STREAM :LINE-HEIGHT) (SEND STREAM :VSP) *ARROW-BASELINE*))
	       (ARROW-X (// HEIGHT *ARROW-X-RATIO*))
	       (ARROW-Y (// HEIGHT *ARROW-Y-RATIO*))
	       (X2 (+ X1 (- HEIGHT (* 2 ARROW-Y))))
	       (X3 (+ X2 ARROW-X))
	       (Y2 (+ Y1 ARROW-Y))
	       (Y3 (+ Y1 (// HEIGHT 2)))
	       (Y4 (+ Y1 (- HEIGHT ARROW-Y)))
	       (Y5 (+ Y1 HEIGHT)))
	  (SEND STREAM :DRAW-LINES :DRAW X1 Y2 X2 Y2 X2 Y1 X3 Y3 X2 Y5 X2 Y4 X1 Y4 X1 Y2)
	  (WHEN *ARROW-SHADOW-P*
	    (LET ((X1P (1+ X1))
		  (X2P (1- X2))
		  (Y4P (1- Y4)))
	      (SEND STREAM :DRAW-LINE X2P Y1 X2P (1- Y2))
	      (SEND STREAM :DRAW-LINE X2P (1+ Y4) X2P Y5)
	      (SEND STREAM :DRAW-LINE X1P (1+ Y2) X1P Y4P)
	      (SEND STREAM :DRAW-LINE X1P Y4P X2 Y4P)))
	  (SEND STREAM :INCREMENT-CURSORPOS
		(MAX 0 (- (* 2 HEIGHT) (SEND STREAM :CHAR-WIDTH))) 0)
	  (SEND STREAM :TYO #\SPACE)))))

(DEFUN MAKE-CHARACTER-PROMPTER (CHARACTER &OPTIONAL CHARACTER-STYLE)
  "Makes a prompt function that prints a specified character."
  #'(NAMED-LAMBDA CHARACTER-PROMPTER (STREAM IGNORE)
		  (WITH-CHARACTER-STYLE (CHARACTER-STYLE STREAM)
		    (CL:WRITE-CHAR CHARACTER STREAM))
		  (CL:WRITE-CHAR #\SPACE STREAM)))
