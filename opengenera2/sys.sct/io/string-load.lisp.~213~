;D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");; -*- Syntax: Common-Lisp; Base: 10; Mode: LISP; Package: SYSTEM-INTERNALS; Lowercase: Yes; Fonts: CPTFONT,CPTFONTI,CPTFONTCB -*-

(2 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB");;; Input encapsulating stream for reading from "fat" files.
0;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>


1;;; The compute-proceed-types-error-mixin should be mixed into any error flavor whose
;;; proceed options depend on parts of the environment in effect when the condition is
;;; signalled which would be reset before the debugger checks the proceed types (e.g.,
;;; defvar-standard variables).  This flavor provides a 2compute-proceed-types1 generic function
;;; which is invoked after the condition is instantiated to determine the setting for
;;; 2dbg:proceed-types1. The 2compute-proceed-types0 1generic function receives a single argument,
;;; the0 1value of the 2:proceed-types1 init option and should only return proceed types listed
;;; therein.  The 2compute-proceed-types0 1generic function is combined using
;;; 2:append :base-flavor-last1.
;;;   (This flavor probably belongs in SYS:DEBUGGER;CONDITION.LISP.)

0(defflavor compute-proceed-types-error-mixin ()
	   ()
  (:required-flavors error))

(defmethod (make-instance compute-proceed-types-error-mixin :after) (&key proceed-types
								     &allow-other-keys)
  (setq dbg:proceed-types (compute-proceed-types self proceed-types)))

(defgeneric compute-proceed-types (error acceptable-proceed-types)
  (:method-combination :append))


1;;; Error flavor mixin for those errors which offer reading the file as uninterpreted
;;; characters as one of their proceed types.

0(defflavor retry-file-as-string-char-file-error-mixin
	(stream
	 (retry-without-escape-processing *retry-without-escape-processing*))
	   ()
  (:required-flavors compute-proceed-types-error-mixin error))

1;;; Always allow the 2:retry-file-as-string-char-file1 proceed type if someone is prepared
;;; to handle it as it is implemented by2 throw1'ing which means that the signaller doesn't
;;; have to know how to handle it.
0(defmethod (compute-proceed-types retry-file-as-string-char-file-error-mixin :append)
	   (ignore)
  (when (assq stream retry-without-escape-processing)
    '(:retry-file-as-string-char-file)))

(defmethod (:proceed retry-file-as-string-char-file-error-mixin
		     :retry-file-as-string-char-file)
	   ()
  (let ((retry-item (assq stream retry-without-escape-processing)))
    (when retry-item
      (*throw (cdr retry-item) nil))))

(defmethod (:document-proceed-type retry-file-as-string-char-file-error-mixin
				   :retry-file-as-string-char-file)
	   (report-stream)
  (format report-stream "Retry reading ~A as an uninterpreted character file."
	  (cl:pathname stream)))


1;;; A mixin used by those error flavors which support the 2:use-type-zero1 and
;;; 2:define-type-as-undefined-style1 proceed options.  The error flavors must provide
;;; appropriate 2:report1 and 2:document-proceed-type1 methods.

0(defflavor escape-loading-stream-type-index-error-mixin ((type-index -1))
	   ()
  (:required-methods :report
		     #|| (:case :document-proceed-type :use-type-zero)
			 (:case :document-proceed-type :define-type-as-undefined-style) ||#)
  :initable-instance-variables)

(defmethod (compute-proceed-types escape-loading-stream-type-index-error-mixin :append)
	   (acceptable-proceed-types)
  (subset #'(lambda (proceed-type) (memq proceed-type acceptable-proceed-types))
	  '(:define-type-as-undefined-style :use-type-zero)))

(defmethod (:proceed escape-loading-stream-type-index-error-mixin :use-type-zero) ()
  :use-type-zero)

(defmethod (:proceed escape-loading-stream-type-index-error-mixin
		     :define-type-as-undefined-style)
	   ()
  :define-type-as-undefined-style)


1;;; Define an escape decoding error flavor and its necessary methods.
0(defmacro define-escape-decoding-error (error instance-variables (&key type-index-error)
					(&rest report-error-code)
					&body proceed-options)
  (declare (zwei:indentation 2 7 3 3 4 1))
  (labels ((include-proceed-method (name)
	     (or (not type-index-error)
		 (not (memq name '(:define-type-as-undefined-style :use-type-zero)))))
	   (build-reporting-method (method-name qualifier reporting-code)
	     (let ((method-fspec (if qualifier `(,method-name ,error ,qualifier)
				   `(,method-name ,error))))
	       (if (stringp (first reporting-code))
		   `(defmethod ,method-fspec (report-stream) (format report-stream
								     ,@reporting-code))
		 `(defmethod ,method-fspec (report-stream) ,@reporting-code)))))
    (dolist (proceed-option proceed-options)
      (scl:destructuring-bind (name &body document-option-code) proceed-option
	(cl:check-type name keyword)
	(ignore document-option-code)))
    (when type-index-error
      (dolist (required-option '(:define-type-as-undefined-style :use-type-zero))
	(cl:assert (cl:member required-option proceed-options :key #'first) ()
		   "~S must be specified as a proceed option with :TYPE-INDEX-ERROR T."
		   required-option)))
    (let ((proceed-types (loop for (proceed-type) in proceed-options
			       when (include-proceed-method proceed-type)
				 collect proceed-type))
	  (proceed-and-document-methods))
      (dolist (proceed-option proceed-options)
	(scl:destructuring-bind (name &body document-option-code) proceed-option
	  (when (include-proceed-method name)
	    (push `(defmethod (:proceed ,error ,name) () ,name) proceed-and-document-methods))
	  (push (build-reporting-method :document-proceed-type name document-option-code)
		proceed-and-document-methods)))
      `(local-declare ((sys:function-parent ,error define-escape-decoding-error))
	 (defflavor ,error ,instance-variables
		    (,@(when type-index-error
			 '(escape-loading-stream-type-index-error-mixin))
		     escape-loading-stream-decoding-error)
	   ,@(when instance-variables
	       '(:initable-instance-variables)))
	 ,(build-reporting-method :report nil report-error-code)
	 ,@(when proceed-types
	     `((defmethod (compute-proceed-types ,error :append) (acceptable-proceed-types)
		 (subset #'(lambda (proceed-type)
			     (memq proceed-type acceptable-proceed-types))
			 ',proceed-types))))
	 ,@(nreverse proceed-and-document-methods)
	 (compile-flavor-methods ,error)))))

(defprop define-escape-decoding-error "Epsilon decoding error" si:definition-type-name)


1;;; Conditions which may be signalled by streams built on 2escape-loading-stream-mixin1.

;;; The base flavor.
0(defflavor escape-loading-stream-decoding-error (stream)
	   (retry-file-as-string-char-file-error-mixin compute-proceed-types-error-mixin
	    error)
  :initable-instance-variables
  :abstract-flavor
  (:required-methods :report))			1;we're never actually signalled ourselves.


;;; The actual error flavors.

0(define-escape-decoding-error escape-loading-stream-unknown-password-version
			      ((version 0))
	()
    ("Unknown epsilon encoding version ~D encountered~@[ in ~A~]."
     version (send-if-handles stream :pathname))
  (:continue-processing
    "Continue reading from the stream while processing escape sequences ~
     defined by the current encoding version (~D)."
    *escape-format-version*))

(define-escape-decoding-error escape-loading-stream-invalid-type-specification
			      ((contained-error nil))
	()
    ("Unable to parse character type specification~@[ in ~A~]:~%~4T~~A~"
     (send-if-handles stream :pathname) contained-error)
  )

(define-escape-decoding-error escape-loading-stream-unknown-escape-code
			      ((escape-code -1))
	()
    ("Unknown escape character ~3,'0D. encountered~@[ in ~A~]."
     escape-code (send-if-handles stream :pathname))
  (:insert-escape-sequence
    "Insert the escape sequence into the stream and resume processing."))

(define-escape-decoding-error escape-loading-stream-undefined-type-index
			      ()
	(:type-index-error t)
    ("Attempt to select character type ~D which is not defined~@[ in ~A~]."
     type-index (send-if-handles stream :pathname))
  (:define-type-as-undefined-style
    "Define type ~D to use the style ~S reserved for undefined types."
    type-index (unparse-character-style *undefined-character-style*))
  (:use-type-zero
    (multiple-value-bind (type-zero-bits type-zero-character-set
			  type-zero-character-set-offset type-zero-style)
	(send stream :get-character-type 0)
      (format report-stream "Define type ~D to use the same definition ~
			     (:BITS ~D :CHARSET (~A ~D) :STYLE ~S) as type 0."
	      type-index type-zero-bits (send type-zero-character-set :name)
	      type-zero-character-set-offset (unparse-character-style type-zero-style)))))

(define-escape-decoding-error escape-loading-stream-invalid-type-index
			      ()
	(:type-index-error t)
    ("Attempt to select the invalid character type ~S~@[ in ~A~]."
     type-index (send-if-handles stream :pathname))
  (:define-type-as-undefined-style
    "Use the style ~S reserved for undefined types." (unparse-character-style
						       *undefined-character-style*))
  (:use-type-zero
    (multiple-value-bind (type-zero-bits type-zero-character-set
			  type-zero-character-set-offset type-zero-style)
	(send stream :get-character-type 0)
      (format report-stream "Use type 0 (:BITS ~D :CHARSET (~A ~D) :STYLE ~S)."
	      type-zero-bits (send type-zero-character-set :name)
	      type-zero-character-set-offset (unparse-character-style type-zero-style)))))

(define-escape-decoding-error escape-loading-stream-invalid-type-definition
			      (contained-error)
	(:type-index-error t)
    ("Error in the definition of character type ~D~@[ in ~A~]~%~4T~~A~."
     type-index (send-if-handles stream :pathname) contained-error)
  (:define-type-as-undefined-style
    "Define type ~D to use the style ~S reserved for undefined types."
    type-index (unparse-character-style *undefined-character-style*))
  (:use-type-zero
    (multiple-value-bind (type-zero-bits type-zero-character-set
			  type-zero-character-set-offset type-zero-style)
	(send stream :get-character-type 0)
      (format report-stream "Define type ~D to use the same definition ~
			     (:BITS ~D :CHARSET (~A ~D) :STYLE ~S) as type 0."
	      type-index type-zero-bits (send type-zero-character-set :name)
	      type-zero-character-set-offset (unparse-character-style type-zero-style)))))

(define-escape-decoding-error escape-loading-stream-invalid-diagram
			      (contained-error)
	()
    ("Error while converting a diagram to its internal form~@[ in ~A~]:~@~4T~~A~"
     (send-if-handles stream :pathname) contained-error)
  (:return-invalid-diagram
    "Insert a special diagram into the stream to mark the position of this invalid diagram.")
  (:insert-escape-sequence
    "Insert the escape sequence into the stream and resume processing."))


1;;; Standard handlers for the above conditions:

;;; Proceed from the error in the simplest way possible.
0(defun escape-loading-stream-decoding-error-simple-handler (condition)
  (dolist (choice *escape-error-simple-proceed-options*)
    (when (send condition :proceed-type-p choice)
      (return (send condition :proceed choice)))))

1;;; Ask the user how we should proceed.
0(defun escape-loading-stream-decoding-error-query-handler (condition)
  (let* ((proceed-types (subset #'(lambda (proceed-type)
				    (assq proceed-type *escape-error-query-handler-choices*))
				(send condition :proceed-types)))
	 (proceed-choices (subset #'(lambda (choice) (memq (first choice) proceed-types))
				  *escape-error-query-handler-choices*)))
    (when proceed-types
      (flet ((explain-choices (stream)
	       (declare (sys:downward-function))
	       1;; 2fquery1 will ask that we print our message on 2query-io1 --
0	       1;;    However, 2query-io1 may be bound to a Zwei window's typein window which
0	       1;;    is a very small area.  Therefore, if 2query-io1 doesn't go to the same
0	       1;;    final destination as 2standard-output1, we'll assume that it's a typein
0	       1;;    window and, therefore, we'll reprint the error message to allow the
0	       1;;    user to read it more easily.
0	       (when (neq (si:follow-syn-stream stream)
			  (si:follow-syn-stream standard-output))
		 (format standard-output "~&~A~2%" condition))
	       (format standard-output "~&Choose from one of these possible actions:~%")
	       (loop for (proceed-type choice-string) in proceed-choices
		     do (format standard-output "~&~4T~A~16T~~A~~%" choice-string
				(with-output-to-string (text)
				  (send condition :document-proceed-type proceed-type text))))
	       (format standard-output "~%")))
	(let ((choice
		(fquery `(:choices ,proceed-choices
			  :type :readline
			  :fresh-line t
			  :beep t
			  :help-function ,#'explain-choices)
			"~A~%What corrective action should be taken?  "
			condition)))
	  1;; 2fquery1 is guarenteed to returned one of the acceptable choices.
0	  (send condition :proceed choice))))))


1;;; Condition which is signalled by 2with-open-character-file1 if asked to read a binary file
0(defflavor binary-file-read-as-character-file-error (stream)
	   (retry-file-as-string-char-file-error-mixin compute-proceed-types-error-mixin
	    error)
  :initable-instance-variables
  :readable-instance-variables)

(defmethod (:report binary-file-read-as-character-file-error) (report-stream)
  (format report-stream "Attempt to read the binary file ~A as a character file."
	  (cl:pathname stream)))

(compile-flavor-methods binary-file-read-as-character-file-error)

1;;; Standard handlers for the above condition:

;;; Retry reading the file with 2:element-type cl:string-char1 if that proceed option
;;; is enabled as is done by the 0with-open-character-file1 macro.
0(defun binary-file-read-as-character-file-error-simple-handler (condition)
  (when (send condition :proceed-type-p :retry-file-as-string-char-file)
    (send condition :proceed :retry-file-as-string-char-file)))

1;;; Asks the user to read the file with 2:element-type cl:string-char1 if that proceed
;;; option is enabled as is done by the 2with-open-character-file1 macro.
0(defun binary-file-read-as-character-file-error-query-handler (condition)
  (when (send condition :proceed-type-p :retry-file-as-string-char-file)
    (let ((stream (binary-file-read-as-character-file-error-stream condition)))
      (when (fquery `(:choices ,format:yes-or-no-p-choices
		      :type :readline
		      :beep t)
	      "~A is a binary file.  ~
	        Do you want to read it as an uninterpreted character file?  "
	      (cl:pathname stream))
	(send condition :proceed :retry-file-as-string-char-file)))))


1;;; 2with-open-character-file1 Macro --  Tries to read a file as a character file.
;;;    The environment for reading the file is setup to allow the proceed option of reading
;;;    the file with 2:element-type cl:string-char1 if the file is binary or an error occurs
;;;    during escape proceessing.  The caller of this macro is responsible for providing
;;;    handlers for the 2binary-file-read-as-character-file-error1 and
;;;    2escape-loading-stream-decoding-error1 conditions if the debugger interface is not
;;;    acceptable.
0(defmacro with-open-character-file ((stream-variable filename &rest open-options) &body body)
  `(with-open-character-file-internal
     ,filename
     (named-lambda with-open-character-file-internal (,stream-variable)
       (declare (sys:downward-function))
       ,@body)
     ,@open-options))

(defun with-open-character-file-internal (filename user-code &rest open-options
							     &key (element-type :default)
							     &allow-other-keys)
  (declare (sys:downward-funarg user-code))
  (let ((retry-on-error t)
	(retry-tag (gensym)))
    (flet ((read-file ()
	     (with-open-stream
	         (stream
		   (cl:apply #'open filename
			     :element-type (if retry-on-error element-type 'cl:string-char)
			     open-options))
	       (let-if retry-on-error
		       ((*retry-without-escape-processing*
			  `((,stream . ,retry-tag) ,@*retry-without-escape-processing*)))
		 (when retry-on-error
		   (let ((stream-element-type (cl:stream-element-type stream)))
		     (unless (cl:subtypep 'cl:string-char stream-element-type)
		       (signal 'binary-file-read-as-character-file-error :stream stream))))
		 (funcall user-code stream)))))
      (catch retry-tag
	(return-from with-open-character-file-internal
	  (read-file)))
      (setq retry-on-error nil)
      (read-file))))

#||
1;;; Example of using the 2with-open-character-file1 macro --
;;;    If any errors occur during reading, the user is queried as to what should be done.
;;;    The 2abort-read-tag1 is used to throw back to our caller if the user should refuse
;;;    to read a binary file.  If an escape processing error occurs, the user's only
;;;    abort mechanism is to hit the Abort key.
0(defun read-character-file (filename &optional (output-stream standard-output)
					       (abort-read-tag 'abort-reading))
  (condition-case ()
       (condition-bind ((binary-file-read-as-character-file-error
			  #'binary-file-read-as-character-file-error-query-handler)
			(escape-loading-stream-decoding-error
			  #'escape-loading-stream-decoding-error-query-handler))
	 (with-open-character-file (input-stream filename :direction :input)
	   (stream-copy-until-eof input-stream output-stream)))
     (binary-file-read-as-character-file-error (*throw abort-read-tag t))))
||#

#||
(with-string-dumping-stream (*character-stream* kbin-context :stream stream)
  ;; Dynamic extent, *CHARACTER-STREAM* can be lexical or dynamic.
 )

(with-string-loading-stream (*character-stream* stream)
 )
||#

(defflavor basic-loading-stream ((escape-quote nil))
	   ()
  :gettable-instance-variables
  (:initable-instance-variables escape-quote)
  (:settable-instance-variables escape-quote))

(defmethod (make-instance basic-loading-stream :after) (&rest ignore)
  (send self :reset-state))

(defmethod (:reset-state basic-loading-stream :default) (&optional (reset-mappings t))
  (ignore reset-mappings))

1;; Reset our state whenever we reset the underlying stream.
0(defmethod (:reset basic-loading-stream :after) ()
  (send self :reset-state))

(cl:defstruct (character-type-table :grouped-array
				    #+IGNORE :named	1;2defstruct1 is too stupid
0				    (:constructor nil)
				    (:copier nil)      
				    (:print-function print-character-type-table)
				    :size-symbol)
  bits
  style
  style-index
  character-set
  character-set-offset
  character-set-index
  character-set-code-offset)

(defsubst make-character-type-table (&key (times 1))
  (make-array (* times character-type-table-size)
	      :named-structure-symbol 'character-type-table
	      :leader-list `(nil character-type-table)))

(defun print-character-type-table (ctt stream depth)
  (ignore depth)
  (sys:printing-random-object (ctt stream :typep)))

(defsubst copy-character-type-table (ctt)
  (and ctt
       (let ((new (make-character-type-table :times (cl:truncate (cl:length ctt)
								 character-type-table-size))))
	 (copy-array-contents ctt new)
	 new)))

(defsubst character-type-defined-p (ctt character-type)
  (let ((ctt-index (* character-type character-type-table-size)))
    (and ctt
	 ( 0 ctt-index (1- (array-length ctt)))
	 (character-type-table-bits ctt-index ctt))))


1;;; Although it may look like we duplicate some of the buffered stream protocol
;;; here, we aren't, really.  We do not give out buffers0.1  We are just encaching
;;; the information we got from doing a 2:read-input-buffer1, and working with that.
;;; Hence, this is necessarily separate from the buffering code in 2sys:io;stream1.

0(defflavor escape-loading-stream-mixin
	((unread-char-tank nil)
	 (unread-byte-tank nil)			1;Shared with other flavors.
0	 initial-options
	 (loading-fat nil)			1;T = we're expecting fat characters
0	 (character-type-table (make-character-type-table :times 30.))
	 current-type
	 current-bits
	 current-style-index
	 current-character-set-index
	 current-code-offset
	 current-char-type
	 input-buffer-p
	 (input-buffer nil)
	 input-buffer-origin
	 input-buffer-start
	 input-buffer-end
	 (style-stack)
	 (return-diagrams-as-lines nil)
	 (escape-loading-which-operations)
	 (escape-loading-which-operations-cache-valid))
	(character-stream)
  (:settable-instance-variables loading-fat return-diagrams-as-lines)
  (:initable-instance-variables loading-fat return-diagrams-as-lines)
  (:required-methods :read-input-buffer-1 :advance-input-buffer-1 read-pointer-handled-p)
  (:default-init-plist :escape-quote (char-subindex #\))
  (:required-flavors basic-loading-stream))

(defmethod (make-instance escape-loading-stream-mixin) (&rest options)
  (ignore options)				1;Doesn't include items from 2:default-init-plist
0  (cl:setf initial-options nil
	   (cl:getf initial-options :escape-quote) escape-quote
	   (cl:getf initial-options :loading-fat) loading-fat
	   (cl:getf initial-options :return-diagrams-as-lines) return-diagrams-as-lines))

(defwhopper-subst (:send-if-handles escape-loading-stream-mixin) (operation &rest operands)
  (cl:case operation
    (:read-location
      ;; Ask if we can handle it.  Normally, this involves asking the
      ;; indirect-stream whether IT can handle it.  Really, this should be
      ;; doing a 2:read-location0 of the inferior stream, not 2:read-pointer0!
     (when (read-pointer-handled-p self)
       (lexpr-continue-whopper operation operands)))
    (otherwise (lexpr-continue-whopper operation operands))))

(defwhopper-subst (:operation-handled-p escape-loading-stream-mixin) (operation)
  (cl:case operation
    (:read-location
      (read-pointer-handled-p self))
    (otherwise (continue-whopper operation))))

(defwhopper-subst (:which-operations escape-loading-stream-mixin ) ()
  (multiple-value-bind (read-location-p stream)
      (read-pointer-handled-p self)
    (if (and escape-loading-which-operations
	     (eql stream escape-loading-which-operations-cache-valid))
	escape-loading-which-operations
      (let ((result (continue-whopper)))
	(unless read-location-p
	  (setq result (remove :read-location
			       (remove :set-location result))))
	(setq escape-loading-which-operations result
	      escape-loading-which-operations-cache-valid stream)
	result))))

(defmethod (:reset-minimal-internal-state escape-loading-stream-mixin) ()
  (setq loading-fat nil
	unread-char-tank nil
	unread-byte-tank nil
	current-type 0
	current-bits 0
	current-style-index 0
	current-character-set-index 0
	current-code-offset 0
	current-char-type 0)
  (when style-stack
    (setf (fill-pointer style-stack) 0)))

(defmethod (:reset-internal-state escape-loading-stream-mixin) ()
  (send self :reset-minimal-internal-state)
  (fill-array character-type-table nil nil)
  (send self :new-character-type 0 0 '(nil 0) '(nil nil nil) "CPTFONT")
  (send self :set-character-type 0))

1;;; Separate method to allow Zmail to encapsulate it.
0(defmethod (:reset-loading-fat escape-loading-stream-mixin) ()
  (setq loading-fat nil))

(defmethod (:reset-state escape-loading-stream-mixin :after) (&optional (reset-mappings t))
  (if reset-mappings
      (send self :reset-internal-state)
      (send self :reset-minimal-internal-state))
  (setq escape-quote (cl:getf initial-options :escape-quote)
	loading-fat (cl:getf initial-options :loading-fat)
	return-diagrams-as-lines (cl:getf initial-options :return-diagrams-as-lines)))

;;;--- does this deserve optimization for the flat-file case, or (not loading-fat)?

(cl:defstruct (escape-loading-stream-state
		(:conc-name elss-)
		(:constructor make-elss))
  loading-fat
  underlying-pointer
  correction-for-buffered-data
  character-type-table
  style-stack
  current-type
  current-bits
  current-style-index
  current-character-set-index
  current-code-offset
  current-char-type
  unread-char-tank) 

(defsubst copy-style-stack (array)
  (and array (plusp (fill-pointer array))
       (cl:make-array (array-active-length array) :initial-contents array
		      :leader-list (list-array-leader array))))

(defmethod (:read-location escape-loading-stream-mixin) ()
  (make-elss
    :loading-fat loading-fat
    :underlying-pointer (send self :read-pointer-1)
    :correction-for-buffered-data
    (- 
      (if input-buffer
	  (- input-buffer-start input-buffer-origin)
	  0)
      (cl:etypecase unread-byte-tank
	((or cl:null cl:vector) 0)		;it its an array, its the input buffer
						;and was taken care of above.
	(cl:list (cl:length unread-byte-tank))
	((cl:unsigned-byte 8) 1)))
    :character-type-table (copy-character-type-table character-type-table)
    :style-stack (copy-style-stack style-stack)
    :current-type current-type
    :current-bits current-bits
    :current-style-index current-style-index
    :current-character-set-index current-character-set-index
    :current-char-type current-char-type
    :unread-char-tank unread-char-tank))

(defmethod (:set-location escape-loading-stream-mixin) (elss)
  (cl:check-type elss escape-loading-stream-state
		 "an ESCAPE-LOADING-STREAM-STATE")
  (send self :reset)
  (send self :set-pointer-1 (+ (elss-underlying-pointer elss)
			       (elss-correction-for-buffered-data elss)))
  (setq loading-fat (elss-loading-fat elss)
	character-type-table (copy-character-type-table (elss-character-type-table elss))
	style-stack (copy-style-stack (elss-style-stack elss))
	current-type (elss-current-type elss)
	current-bits (elss-current-bits elss)
	current-style-index (elss-current-style-index elss)
	current-character-set-index (elss-current-character-set-index elss)
	current-char-type (elss-current-char-type elss)
	unread-char-tank (elss-unread-char-tank elss)))

1;;; When we go back to the beginning, return to our original assumptions about fonts.

0(defmethod (:set-pointer escape-loading-stream-mixin :before) (pointer)
  (ignore pointer)
  (unless (zerop pointer)
    (ferror ":SET-POINTER cannot work on character streams, except to character 0.~@
              Use :READ-LOCATION/:SET-LOCATION."))
  (setq unread-char-tank nil)
  (setq current-type 0
	current-bits 0
	current-style-index 0
	current-character-set-index 0
	current-code-offset 0
	current-char-type 0))

1;;; Convert a byte to a character, using the current character type.

0(defsubst-in-flavor (make-current-char escape-loading-stream-mixin) (byte)
  (int-char (dpb current-char-type %%char-all-but-subindex
		 (+ byte current-code-offset))))

1;;; Input one character

0(defmethod (:tyi escape-loading-stream-mixin) (&optional eof)
  (if unread-char-tank
      (prog1 unread-char-tank
	     (setq unread-char-tank nil))
      (loop for byte = (send self :read-byte eof)
	    when (null byte)
	      return eof
	    while (eql byte escape-quote)
	    for new-byte = (send self :process-escape)
	    until new-byte
	    finally
	      (return (if (null new-byte)
			  (if (= byte (char-subindex #\Return))
			      1;; An unquoted 0#\Return1 always is the standard return character.
0			      #\Return
1			      ;; Ordinary character to be returned in current style and set.
0			      (make-current-char byte))
			  (if (numberp new-byte)
1			      ;; This loop terminates only if the byte is a normal character or
0			      1;; a call to the 2:process-escape1 method returns a byte to insert.
0			      (make-current-char new-byte)
1			      ;; A diagram, no doubt.
0			      new-byte))))))

(defmethod (:untyi escape-loading-stream-mixin) (char)
  (when unread-char-tank
    (ferror "An attempt was made to unread character ~S, but ~S has already been unread."
	    char unread-char-tank))
  (setq unread-char-tank char))

(defmethod (:read-input-buffer-1 escape-loading-stream-mixin :before) (ignore ignore)
  (when unread-char-tank
    (ferror "There was an attempt to read an input buffer when there are un-read bytes.")))

1;;; Check the holding tanks for pending input before going to the stream.
0(defwhopper (:listen escape-loading-stream-mixin) ()
  (or unread-char-tank
      (continue-whopper)))

1;;; The 2:read-byte1 method first gets bytes from our input buffer, if
;;; we have gotten one from our underlying stream.  When that is exhausted,
;;; we just get the characters from the underlying stream.

0(defwhopper (:read-byte escape-loading-stream-mixin) (&optional eof)
  (cl:etypecase unread-byte-tank
    ((cl:unsigned-byte 8)
     (prog1 unread-byte-tank
	    (setq unread-byte-tank nil)))
    (null (if (not input-buffer-p)
	      (continue-whopper eof)
	    (unless (and input-buffer
			 (< input-buffer-start input-buffer-end))
	      (send self :setup-next-input-buffer nil eof))
	    (when input-buffer
	      (prog1 (aref input-buffer input-buffer-start)
		     (incf input-buffer-start)
		     (when ( input-buffer-start input-buffer-end)
		       (send self :advance-input-buffer-1 input-buffer-start)
		       (setq input-buffer nil))))))
    (list (pop unread-byte-tank))
    ((cl:vector (cl:unsigned-byte 8))
     (ferror "Trying to read bytes when we have given unread bytes out as an input buffer.~@
	      That input buffer has not yet been advanced."))))


(defmethod (:unread-byte escape-loading-stream-mixin) (byte)
  (cl:etypecase unread-byte-tank
    (null (setq unread-byte-tank byte))
    ((cl:unsigned-byte 8)
     (setq unread-byte-tank (list byte unread-byte-tank)))
    (list
      (push byte unread-byte-tank))
    ((cl:vector (cl:unsigned-byte 8))
     (ferror "Unable to unread byte ~D; we have given out our unread byte tank~@
	      as an input buffer without acknowledging any input.")))
1  ;; We can flush the input buffer because the byte being unread must have been
0  1;; acknowledged.
0  (setq input-buffer nil)
  (send self :advance-input-buffer-1 input-buffer-start))

(defmethod (:grow-character-type-table escape-loading-stream-mixin) (required-size)
  (let ((new-table (make-character-type-table :times (ceiling (* required-size 3/2)))))
    (copy-array-contents character-type-table new-table)
    (setq character-type-table new-table)))

(defmethod (:validate-character-type-specification escape-loading-stream-mixin) (spec)
  (let* ((character-type (car spec))
	 (new-type-definition (cdr spec))
	 (type-index-valid (and (cl:integerp character-type) ( 0 character-type)))
	 (type-already-defined (and type-index-valid
				    (character-type-defined-p character-type-table
							      character-type))))
    (macrolet
        ((signal-and-handle-condition (condition &rest condition-init-keywords)
	   `(signal-proceed-case (() ,condition ,@condition-init-keywords)
	      (:use-type-zero
		1;; Use the same definition as type 0.
0		(cond ((and type-index-valid (zerop character-type))
		       (setq new-type-definition '(0 (nil 0) (nil nil nil) "")))
		      ((and type-index-valid (> character-type 0))
		       (multiple-value-bind (type-zero-bits type-zero-charset
					     type-zero-charset-offset type-zero-style)
			   (send self :get-character-type 0)
			 (setq new-type-definition `(,type-zero-bits
						     (,type-zero-charset
						      ,type-zero-charset-offset)
						     ,type-zero-style ""))))
		      (t
		       (setq character-type 0
			     new-type-definition nil))))
	      (:define-type-as-undefined-style
		1;; Use the standard character set, no bits, and the special undefined style
0		(when (or (not type-index-valid)
			  (zerop character-type))	1;Don't want type 0 to be "undefined".
0		  (let ((next-type-index
			  (/ (array-length character-type-table) character-type-table-size)))
		    (setq character-type next-type-index)))
		(setq new-type-definition `(0 (nil 0) ,*undefined-character-style* ""))))))
      (unless (and type-index-valid
		   (or type-already-defined new-type-definition))
	1;; Index is invalid (not an integer or negative) or undefined --
0	1;;    Signal the appropriate condition and handle the possible proceed options.
0	(signal-and-handle-condition (if type-index-valid
					 'escape-loading-stream-undefined-type-index
					 'escape-loading-stream-invalid-type-index)
				     :stream self :type-index character-type))
      (when new-type-definition
	1;; Caller is going to define a new type -- Verify the definition.
0	(condition-case (.error.)
	     (validate-character-type-definition new-type-definition)
	   (error
	     (signal-and-handle-condition 'escape-loading-stream-invalid-type-definition
					  :stream self :type-index character-type
					  :contained-error .error.))
	   )))
    (values character-type new-type-definition)))

1;;; Uses 2ferror1 as our callers will have appropriate handlers -- (See also Zmail)
0(defun validate-character-type-definition (type-definition)
  (scl:destructuring-bind (bits (charset-name charset-offset) style default-font &rest other)
			  type-definition
    (unless (cl:typep bits '(cl:unsigned-byte 4.))
      (ferror "Invalid bits value ~D in character type definition ~S." bits type-definition))
    (unless (cl:typep charset-name '(or null
					standard-character-set
					(and string (cl:satisfies lookup-character-set))))
      (ferror "Invalid character set name ~S in character type definition ~S."
	      charset-name type-definition))
    (unless (cl:typep charset-offset '(cl:rational 0 (256.)))
      (ferror "Invalid character set offset ~D in character type definition ~S."
	      charset-offset type-definition))
    1;; Make a very simple syntax check on the character style --
0    1;;    We don't want to catch the real error here as it would preclude letting the user
0    1;;    use the proceed options supplied by 2parse-character-style1 to form a proper style.
0    (unless (cl:typep style '(or null
				 (cl:structure character-style)
				 (and list (cl:satisfies (lambda (x) (= (length x) 3))))))
      (ferror "Invalid character style ~S in character type definition ~S."
	      style type-definition))
    (unless (cl:typep default-font 'string)
      (ferror "Invalid default font name ~S in character type definition ~S."
	      default-font type-definition))
    (when other
      (ferror "Extraneous forms (~S) in character type definition ~S." other type-definition))
    ))

(defmethod (:set-character-type escape-loading-stream-mixin) (character-type)
  (let ((tbl-idx (* character-type character-type-table-size)))
    (setq current-type character-type
	  current-bits (character-type-table-bits tbl-idx character-type-table)
	  current-style-index (character-type-table-style-index tbl-idx character-type-table)
	  current-character-set-index (character-type-table-character-set-index
					tbl-idx character-type-table)
	  current-code-offset (character-type-table-character-set-code-offset
				tbl-idx character-type-table)
	  current-char-type (ldb %%char-all-but-subindex
				 (dpb current-bits %%char-bits
				      (dpb current-style-index %%char-style
					   (dpb current-character-set-index %%char-char-set
						0)))))))

(defmethod (:get-character-type escape-loading-stream-mixin) (character-type)
  (declare (values bits character-set character-set-offset style))
  (let ((tbl-idx (* character-type character-type-table-size)))
    (if (and ( 0 tbl-idx (1- (array-length character-type-table)))
	     (character-type-table-bits tbl-idx character-type-table))
	(values (character-type-table-bits tbl-idx character-type-table)
		(character-type-table-character-set tbl-idx character-type-table)
		(character-type-table-character-set-offset tbl-idx character-type-table)
		(character-type-table-style tbl-idx character-type-table))
      (when (zerop tbl-idx)			1;type 0 should always appear defined.
0	(values 0 nil 0 '(nil nil nil))))))

1;;; If we have any of 2(:fix :roman :normal)1, substitue
;;; 2nil1, since we judge that to be the most probable intent

0;;; There is a strong convention that 2(:fix :roman :normal)0 is the`default default'
;;; which is factored out of styles stored in files.
(defvar *file-absolute-default-character-style*
	(parse-character-style '(:fix :roman :normal))
  "Files factor out 2(:fix :roman :normal)0 from the default character style.")

(defun canonicalize-character-style (style)
  (let* ((family (cs-family style))
	 (new-family (if (eq family :fix) nil family))
	 (face (cs-face style))
	 (new-face (if (eq face :roman) nil face))
	 (size (cs-size style))
	 (new-size (if (eq size :normal) nil size)))
    (unless (or (eq family :device-font)
		(and (eq family new-family)
		     (eq face new-face)
		     (eq size new-size)))
      (setq style (intern-character-style new-family new-face new-size)))
    style))

1;;; Initialize character types from a list of fonts, as obtained from the
;;; attribute list of the file.  Release 6 compatability.

0(defmethod (:set-types-from-font-list escape-loading-stream-mixin) (fonts)
  (loop for i from 0
	for keyfont in (if (atom fonts) (list fonts) fonts)
	for font = (intern (string keyfont) (symbol-package 'fonts:cptfont))
	do (multiple-value-bind (style char-set offset)
	       (backtranslate-font font si:*b&w-screen*)
1	     0(setq style (canonicalize-character-style style))
	     (stack-let ((char-set-spec (list (send char-set :name) offset)))
	       (send self :new-character-type i 0 char-set-spec style keyfont))))
1  ;; Make the new bindings take effect.
0  (send self :set-character-type 0))

2;;; Handles the escape sequence.  Returns T if the escape character was escaped and
;;; should be used as an input byte, otherwise returns NIL.

1;;; 2:process-escape1 can only be called when the caller has acknowledged all
;;; bytes via 2:update-input-buffer-pointer.1  This is so it can read and unread
;;; bytes without interference with the buffering.

0(defmethod (:process-escape escape-loading-stream-mixin) ()
  (if (not loading-fat)
      (send self :check-password)
    (let ((byte (send self :read-byte)))
      (or (when (= byte escape-quote) byte)
	  (when (= byte (char-subindex #\return)) byte)
	  (block process-real-escape-sequence
	    (select byte
	      (((char-subindex #\())
	       (send self :unread-byte byte)
	       (let ((spec (condition-case (.error.)
				(scl:with-standard-io-environment
				  (letf ((loading-fat nil)
					 (current-type 0)
					 (current-bits 0)
					 (current-style-index 0)
					 (current-character-set-index 0)
					 (current-code-offset 0)
					 (current-char-type 0))
				    (condition-bind
				      ((sys:external-symbol-not-found
					 (named-lambda condition-bind (condition)
					   (sys:proceed condition :internal))))
				      (cl:read self))))
			      (error
				1;; Only proceed type for the following error never returns.
0				(signal 'escape-loading-stream-invalid-type-specification
					:stream self :contained-error .error.)))))
		 (multiple-value-bind (index definition)
		     (send self :validate-character-type-specification spec)
		   (when definition
		     (lexpr-send self :new-character-type index definition))
		   (when (null style-stack)
		     (setq style-stack
			   (make-array 10. :type 'art-fixnum :fill-pointer 0)))
		   (array-push style-stack current-type)
		   (send self :set-character-type index))))
	      (((char-subindex #\))
	       (send self :check-password 2))
	      (((char-subindex fat-unpassword-character))
	       (send self :reset-loading-fat))
	      (((char-subindex #\*))
	       (send self :set-character-type (if style-stack (array-pop style-stack) 0)))
	      (((char-subindex #\#))
	       (let ((diagram-terminated-by-eof))
		 (labels ((return-string (string &optional include-escape-sequence)
			    (unless diagram-terminated-by-eof
			      (send self :unread-byte (char-subindex #\Return)))
			    (loop for i downfrom (1- (array-active-length string)) to 0
				  do (send self :unread-byte (char-subindex (aref string i))))
			    (when include-escape-sequence
			      (send self :unread-byte (char-subindex #\#))
			      (return-from process-real-escape-sequence escape-quote))))
		   (with-stack-array (contents 100 :type 'art-string :fill-pointer 0)
		     (cl:loop
			(let ((byte (send self :read-byte nil)))
			  (when (or (null byte) (= byte (char-subindex #\Return)))
			    (setq diagram-terminated-by-eof (null byte))
			    (return))
			  (array-push-extend contents (code-char byte))))
		     (if return-diagrams-as-lines
			 (condition-case (.error.)
			      (return-from process-real-escape-sequence
				(zwei:diagram-escape-convert contents))
			    (error
			      (signal-proceed-case (() 'escape-loading-stream-invalid-diagram
						       :stream self :contained-error .error.)
				(:insert-escape-sequence
				  (return-string contents t))
				(:return-invalid-diagram
				  (return-from process-real-escape-sequence
				    (make-instance 'zwei:invalid-line-diagram
						   :original-contents contents))))))
		       (return-string "<Diagram line>"))))))
	      (otherwise
	       (if (< byte (char-subindex #\0))
		   (signal-proceed-case (() 'escape-loading-stream-unknown-escape-code
					    :stream self :escape-code byte)
		     (:insert-escape-sequence
		       (send self :unread-byte byte)
		       (return-from process-real-escape-sequence escape-quote)))
		 (let ((raw-index (- byte (char-subindex #\0))))
		   (multiple-value-bind (real-index definition)
		       (send self :validate-character-type-specification (list raw-index))
		     (when definition
		       (lexpr-send self :new-character-type real-index definition))
		     (when (null style-stack)
		       (setq style-stack
			     (make-array 10. :type 'art-fixnum :fill-pointer 0)))
		     (array-push style-stack current-type)
		     (send self :set-character-type real-index))))))
	    nil)))))

(defmethod (:check-password escape-loading-stream-mixin) (&optional (start 1))
  (loop named outer
	for i from start below (string-length *fat-password*)	;We've already seen some
	for password-byte = (char-subindex (aref *fat-password* i))
	for byte = (send self :read-byte)
	when (not (eql byte password-byte))
	  do (when byte (send self :unread-byte byte))	;May be at EOF
	     (loop for bi downfrom (1- i) above 0	;Don't put the  back.
		   for password-byte = (char-subindex (aref *fat-password* bi))
		   do (send self :unread-byte password-byte)
		   finally (return-from outer escape-quote))
	finally
	  1;; We now know it's for real with probability 1-1/(expt 127 10) or better
0	  (let ((version (send self :read-byte)))
	    (send self :reset-internal-state)	1;Rel-6 stuff no longer matters.
0						1;also, if there are two passwords in a
0						1;row, the second one serves as a
0						1;`reset state' command.
0	    (setq loading-fat t)
	    (cl:case version
	      (1 nil)
	      (2 (loop for i below (string-length *fat-password-message*)
		       for message-byte = (char-subindex (aref *fat-password-message* i))
		       for byte = (send self :read-byte)
		       when (not (eql byte message-byte))
			 do (when byte (send self :unread-byte byte))	;May be at EOF
			    (return-from outer escape-quote)))
	      (otherwise
		(signal-proceed-case (() 'escape-loading-stream-unknown-password-version
					 :stream self :version version)
		  (:continue-processing)))))))

(defmethod (:set-japanese escape-loading-stream-mixin) (size &aux font)
  (setq loading-fat t)
  (selectq size
    (12. (setq size :normal
	       font "JIS12")
	 (send self :set-types-from-font-list
	       'fonts:(CPTFONT CPTFONTB CPTFONT CPTFONTI CPTFONTB)))
    (16. (setq size :large
	       font "JIS16")
	 (send self :set-types-from-font-list
	       'fonts:(CPTFONT CPTFONTB TR12 TR12B TR12I)))
    (48. (setq size :huge
	       font "JIS48")
	 (send self :set-types-from-font-list
	       'fonts:(DUTCH20 DUTCH20B TR12 TR12B TR12I)))
    (otherwise					1;Also known as 224.
0     (setq size :very-large
	   font "JIS24")
     (send self :set-types-from-font-list
	   'fonts:(DUTCH20 DUTCH20B TR12 TR12B TR12I))))
  (loop for i from 10				2;10 is wired into Japanese files
0	for j from 0
	repeat 54				1;Number of 128-char fonts in old days
0	do
    (send self :new-character-type i 0 `("JAPANESE" ,(* j 1/2)) `(nil nil ,size) font)))

(defmethod (:new-character-type escape-loading-stream-mixin) (type-index bits char-set style
							      default-font &rest ignore)
  2(ignore default-font)0		(3 0 (NIL 0) (NIL :BOLD-ITALIC NIL) "CPTFONTBI");Someday, use this to provide for unknown styles.
0  (setq loading-fat t)
  (when ( type-index (/ (array-length character-type-table) character-type-table-size))
    (send self :grow-character-type-table type-index))
  (setq style (parse-character-style style))
  (let ((tbl-idx (* type-index character-type-table-size)))
    (cl:setf (character-type-table-bits tbl-idx character-type-table) bits
	     (character-type-table-style tbl-idx character-type-table) style
	     (character-type-table-style-index tbl-idx character-type-table)
	       (style-index style t)))
  (lexpr-send self :parse-character-set type-index char-set)
  (when (= type-index current-type)
    (send self :set-character-type current-type)))

(defmethod (:parse-character-set escape-loading-stream-mixin)
	   (type-index name offset)
  (multiple-value-bind (offset half)
      (floor offset)
    (let* ((char-set (lookup-character-set name))
	   (index (send char-set :decode-offset offset))
	   (tbl-idx (* type-index character-type-table-size)))
      (cl:setf (character-type-table-character-set tbl-idx character-type-table) char-set
	       (character-type-table-character-set-offset tbl-idx character-type-table)
	         offset
	       (character-type-table-character-set-index tbl-idx character-type-table)
		 index
	       (character-type-table-character-set-code-offset tbl-idx character-type-table)
	         (* half 256.)))))

;;; 3Returns are not legal inside escape sequences!

0(defmethod (:line-in escape-loading-stream-mixin) (&optional leader)
  (declare (values line eof-p))
1  ;; 3string1 is not made until needed to avoid calling 3adjust-array-size1 except when
  ;; strings cross buffer boundaries.
0  (if input-buffer-p
      (loop with type = 'sys:art-string
1	      ;; If we have put back any characters, get an initial string,
	      ;; initializing it with the contents of the untyi tanks.
0	    with string = (loop while unread-char-tank
				for char = (send self :tyi)
				when (char-equal char #\Return)
				  do (return-from :line-in
				       (values
					 (cl:make-array (length initial-contents)
							:element-type
							  (cdr (assq type
								     cli::*array-element-types*
								     ))
							:leader-length (and (numberp leader)
									    leader)
							:initial-contents initial-contents)
					 nil))
				when (char-fat-p char)
				  do (setq type 'sys:art-fat-string)
				collect char into initial-contents
				finally
				  (when initial-contents
				    (return
				      (cl:make-array (length initial-contents)
						     :element-type
						       (cdr (assq type
								  cli::*array-element-types*))
						     :leader-length (and (numberp leader)
									 leader)
						     :initial-contents initial-contents))))
	    with string-index = (if string
				    (string-length string)
				    0)
	    with (end-index cr-flag escape-flag)
	    when (and (neq type 'sys:art-fat-string)
		      ( current-char-type 0))
	      do (setq type 'sys:art-fat-string)
		 (when string
		   (let ((new-string (make-array string-index
						 :leader-length (and (numberp leader) leader)
						 :type 'sys:art-fat-string)))
		     (copy-array-contents string new-string)
		     (setq string new-string)))
	    unless (and input-buffer (< input-buffer-start input-buffer-end))
	      unless (send self :setup-next-input-buffer nil nil)
		do
		  (when (null string)
		    (setq string (make-array string-index
					     :type type
					     :leader-length (and (numberp leader) leader))))
		  (when (numberp leader)
		    (setf (fill-pointer string) string-index))
		  (return (values string t))
	    with new-string-index and new-buffer-index
1	      ;; See if this buffer has a return or an escape
0	    do (multiple-value (end-index escape-flag cr-flag)
		 (%escape-or-return-search escape-quote input-buffer
					   input-buffer-start input-buffer-end))
	    when (not (null end-index))
	      do (setq new-buffer-index (1+ end-index)
		       new-string-index (+ string-index (- end-index input-buffer-start)))
	    else do (setq new-buffer-index input-buffer-end
			  new-string-index (+ string-index
					      (- input-buffer-end input-buffer-start)))
	    when (null string)
1	      ;;Make a string to return or save the end of this packet in.
0	      do (setq string (make-array new-string-index
					  :type type
					  :leader-length (and (numberp leader) leader)))
1		 ;;Was some stuff from previous packet, make room.
0	    else do (setq string (adjust-array-size string new-string-index))
	    do (copy-array-string-portion-coercing-internal
		 input-buffer input-buffer-start new-buffer-index
		 string string-index new-string-index
		 current-bits current-style-index current-character-set-index
		 current-code-offset)
	       (send self :update-input-buffer-pointer new-buffer-index)
	       (setq string-index new-string-index)
	    when escape-flag
	      do (let ((byte (send self :process-escape)))
		   (when byte
		     (when (instancep byte)
		       (return (values byte nil)))
		     (let ((char (make-current-char byte)))
		       (if (char-equal char #\Return)
			   1;; It's a Return of some type; it's the end of the line.
0			   (setq cr-flag t
				 escape-flag nil)
			 (adjust-array-size string (1+ string-index))
			 (setf (aref string string-index) char)
			 (incf string-index)))))
	    when (and (not escape-flag)		1;When we are processing up to the CR
0		      (not (null cr-flag)))	1;and this buffer is enough to satisfy
0	      do (when (numberp leader)
		   (setf (fill-pointer string) string-index))
		 (return (values string nil)))
      1;; Must use 3:tyi1.
0      (let* ((length-so-far 0)
	     (type 'art-string)
	     (line (make-array 80 :type type
				  :leader-length (and (numberp leader) leader))))
	(declare (sys:array-register line))
	(loop for ch = (send self :tyi)
	      until (null ch)			1;i.e. EOF
0	      when (instancep ch)
		1;; A diagram --
0		1;;    The 3:tyi1 method (via 3:process-escape1) has already checked that
0		1;;    3return-diagrams-as-lines1 is not 3nil1.
0		return (values ch nil)
	      until (char-equal ch #\cr)
	      when (and (not (zerop (char-type ch)))
			(= (array-type-field line) art-string))
1		;; Time to switch line types to hold bigger characters.
0		do (setq type 'art-fat-string)
		   (let ((new-line (make-array (array-length line) :type type
					       :leader-length (and (numberp leader) leader))))
		     (copy-array-portion line 0 length-so-far new-line 0 length-so-far)
		     (setq line new-line))
1		   ;;We have an ordinary character, stick it on the end of the line
0	      when ( length-so-far (array-length line))
		do (setq line (adjust-array-size line (/ (* length-so-far 3) 2)))
	      do (setf (aref line (prog1 length-so-far (incf length-so-far))) ch)
	      finally
1		;;Adjust size and active-length of line
0		(adjust-array-size line length-so-far)
		(when (array-has-leader-p line)
		  (setf (fill-pointer line) length-so-far))
		(return (values line (null ch)))))))

1;;; This mostly borrows from the 3:string-line-in1 methods in 3buffered-line-input-mixin
1;;; and 3unbuffered-line-input-mixin1, but modified along the lines of 3:line-in1 above.
0(defmethod (:string-line-in escape-loading-stream-mixin)
	   (eof line &optional (start 0) end)
  (declare (values length-so-far eof-p more-on-line-p))
1  ;; Default the 3end1 argument in the usual fashion
  ;; Use 3length1 rather than 3active-length1, of course, since we're storing into the string
0  (if input-buffer-p
      3;; Fast case, we have input buffering
0      (loop with leader-p = (array-has-leader-p line)
	    with string-index = start
	    with (end-index escape-flag cr-flag)
	    initially
	      (when (null end)
		(setq end (array-length line)))
	      (loop while unread-char-tank
		    while (< string-index end)
		    for char = (send self :tyi)
		    if (char-equal char #\Return)
		      do (when leader-p (setf (fill-pointer line) string-index))
			 (return-from :string-line-in (values string-index nil nil))
		    else
		      do (setf (aref line string-index) char)
			 (incf string-index))
	    1;; Need to read 3unread-byte-tank1 here!
0	    unless (and input-buffer (< input-buffer-start input-buffer-end))
	      unless (send self :setup-next-input-buffer nil eof)
		do (when leader-p
		     (setf (fill-pointer line) string-index))
		   (return (values string-index t nil))
1	    ;; Now see if this buffer has a CR, and copy out the appropriate amount.
0	    for string-remaining = (- end string-index)
	    for input-buffer-stop-search = (min input-buffer-end
						(+ input-buffer-start string-remaining))
	    do (multiple-value (end-index escape-flag cr-flag)
		 (%escape-or-return-search escape-quote input-buffer input-buffer-start
					   input-buffer-stop-search))
	    with length-remaining
	    when (not (null end-index))
	      do (setq length-remaining (- end-index input-buffer-start))
	    else do (setq length-remaining (- input-buffer-end input-buffer-start))
	    as length-of-xfer = (min string-remaining length-remaining)
	    as full = (> length-remaining string-remaining)
	    do (copy-array-string-portion-coercing-internal
		 input-buffer input-buffer-start (+ input-buffer-start length-of-xfer)
		 line string-index (+ string-index length-of-xfer)
		 current-bits current-style-index current-character-set-index
		 current-code-offset)
	    do (send self :update-input-buffer-pointer (+ input-buffer-start length-of-xfer
							  (if end-index 1 0)))
	       (incf string-index length-of-xfer)
	    when escape-flag
	      do (let ((byte (send self :process-escape)))
		   (when byte
		     (when (instancep byte)
		       (return (values 0 nil nil byte)))
		     (let ((char (make-current-char byte)))
		       (cond ((char-equal char #\Return)
			      (setq cr-flag t))
			     (( string-remaining 0)
			      (send self :unread-byte byte))
			     (t
			      (setf (aref line string-index) char)
			      (incf string-index))))))
	    when cr-flag
	      do (when leader-p (setf (fill-pointer line) string-index))
		 (return (values string-index nil full))
	    when full				1;No carriage return.
0	      do (and leader-p (setf (fill-pointer line) string-index))
		 (return (values string-index nil t)))
      3;; :TYI case; we don't have input buffering.
0      (let ((line line))
	(declare (array-register line))
	(when (null end)
	  (setq end (array-length line)))
	(loop with length-so-far = start
	      with leader-p = (array-has-leader-p line)
	      when ( length-so-far end)
		do (let ((new-ch (send self :tyi)))
		     (unless (or (null new-ch)
				 (and (not (instancep ch)) (char-equal new-ch #\Cr)))
		       (send self :untyi new-ch))
		     (when leader-p (setf (fill-pointer line) length-so-far))
		     (return (values length-so-far
				     (null new-ch)
				     (or (instancep ch) (char-not-equal new-ch #\CR)))))
	      as ch = (send self :tyi)
	      when (null ch)			1;If got EOF.
0		do (and eof (error 'end-of-file ':stream self ':format-string eof))
		   (if leader-p (setf (fill-pointer line) length-so-far))
		   (return (values length-so-far t nil))
	      when (instancep ch)
1		;; A diagram --
0		1;;    The 3:tyi1 method (via 3:process-escape1) has already checked that
0		1;;    3return-diagrams-as-lines1 is not 3nil1.
0		return (values 0 nil nil ch)
	      when (char-equal ch #\Return)
		do (if leader-p (setf (fill-pointer line) length-so-far))
		   (return (values length-so-far nil nil))
	      do (setf (aref line length-so-far) ch)
		 (incf length-so-far)))))

1;;; These next three are essentially subroutines of the above, not part of the
;;; indirect stream protocol.0  (Actually, I'm not so sure anymore.  A symptom of
1;;; 0the need for remodularization. --RWK)
1;;; Get an input buffer from our encapsulated stream, and prepare to do input from it.

;;; The unread-byte-tank will be one of the following:
;;;  3null1 -- Empty
;;;  3(cl:unsigned-byte 8)1  -- a single byte
;;;  3list1 -- Several bytes, available for input
;;;  3(cl:vector (cl:unsigned-byte 8))1 -- Several bytes, given out as an input buffer.

0(defmethod (:setup-next-input-buffer escape-loading-stream-mixin) (no-hang-p eof)
  (cl:etypecase unread-byte-tank
    (null
      (multiple-value (input-buffer input-buffer-start input-buffer-end)
	(send self :read-input-buffer-1 eof no-hang-p))
      (setq input-buffer-origin input-buffer-start))
    ((cl:unsigned-byte 8)
     (setq unread-byte-tank (cl:make-array 1 :element-type '(cl:unsigned-byte 8)
					   :initial-element unread-byte-tank)))
    (list
      (setq unread-byte-tank
	    (cl:coerce unread-byte-tank '(cl:vector (cl:unsigned-byte 8)))))
    ((cl:vector (cl:unsigned-byte 8))
     (ferror "Setting up input buffer twice without advancing it between.")))
  (when unread-byte-tank
    (setq input-buffer unread-byte-tank
	  input-buffer-start 0
	  input-buffer-origin 0
	  input-buffer-end (cl:length unread-byte-tank)))
  (values input-buffer (not input-buffer)))

(defwhopper (:read-pointer escape-loading-stream-mixin) ()
  (- (if (not input-buffer)
	 (continue-whopper)
	 (+ (- input-buffer-start input-buffer-origin)
	    (continue-whopper)))
     (if unread-char-tank 1 0)))
			    
(defwhopper (:advance-input-buffer-1 escape-loading-stream-mixin) (new-pointer)
  (cl:etypecase unread-byte-tank
    (null (continue-whopper new-pointer))
    ((or list (cl:unsigned-byte 8))
     (continue-whopper new-pointer))
    ((cl:vector (cl:unsigned-byte 8))
     (setq unread-byte-tank (cl:coerce (cl:subseq unread-byte-tank new-pointer) 'list)))))

1;;; Note that we have consumed a portion of our input buffer.

0(defmethod (:update-input-buffer-pointer escape-loading-stream-mixin) (index)
  (setq input-buffer-start index)
  (when ( input-buffer-start input-buffer-end)
    (send self :advance-input-buffer-1 input-buffer-start)
    (setq input-buffer nil)))

1;;; There should also be a string-string version of this.

0(defun copy-array-string-portion-coercing
       (from-string from-start from-end to-string to-start to-end
	&key (bits 0) (style *null-style*)
	(char-set nil) (char-set-offset 0))
  (let* ((style-index (style-index style t))
	 (char-set (lookup-character-set char-set))
	 (char-set-index (send char-set :decode-offset char-set-offset)))
    (copy-array-string-portion-coercing-internal from-string from-start from-end
					   to-string to-start to-end
					   bits style-index char-set-index 0)))

(defun copy-array-string-portion-coercing-internal
       (from-string from-start from-end to-string to-start to-end
	bits style-index char-set-index current-code-offset)
  (let ((char-stuff (dpb bits %%char-bits
			 (dpb style-index %%char-style
			      (dpb char-set-index %%char-char-set
				   current-code-offset)))))
    (if (and (= char-stuff 0)
	     (= (array-type-field from-string) art-string))
	(copy-array-portion from-string from-start from-end to-string to-start to-end)
      (let* ((from-length (- from-end from-start))
	     (to-length (- to-end to-start)))
1	;;Until compiler is fixed about array register arguments
0	(let ((from-string from-string) (to-string to-string))
	  (declare (compiler:array-register-1d from-string to-string))
	  (let ((index-from from-start)
		(index-to to-start))
	    (let ((elements (min from-length to-length)))
	      (loop repeat elements
		    do  (%1d-aset (int-char (+ char-stuff (%1d-aref from-string index-from)))
				 to-string index-to)
		       (incf index-from)
		       (incf index-to)))
	    (when (< index-to to-end)
	      (loop do (%1d-aset #\  to-string index-to)
		       (incf index-to)
		    while (< index-to to-end)))))))))


(defflavor indirect-escape-input-stream ()
	   (escape-loading-stream-mixin indirect-input-stream-mixin
	    input-stream
	    basic-loading-stream))

(defmethod (fs:%file-stream-file-element-type indirect-escape-input-stream) ()
  'cl:character)

(compile-flavor-methods indirect-escape-input-stream)

(defun %array-search (object array start end)
  (let ((array array))
    (declare (compiler:array-register array))
    (do ((i start (1+ i)))
	(( i end) nil)
      (when (eql (aref array i) object)
	(return i)))))

1;;; Search for an escape character or a Return character.
;;; Returns second and third values saying whether an escape or a return were found.

0(defun %escape-or-return-search (escape array start end)
  (declare (values index escape-p return-p))
  (let ((array array))
    (declare (compiler:array-register array))
    (loop with return-subindex = (char-subindex #\return) ;saves a push-constant
	  for i from start below end
	  for byte = (aref array i)
	  when (= byte escape)
	    do (return (values i t))
	  when (= byte return-subindex)
	    do (return (values i nil t)))))

1;;; "Easy-to-use" resource of epsilon decoding streams.

0(defflavor epsilon-decoding-input-stream
	((buffered-stream (make-instance 'buffered-character-to-8bit-input-stream
					 :stream nil))
	 (unbuffered-stream (make-instance 'unbuffered-character-to-8bit-input-stream
					   :stream nil)))
	(indirect-escape-input-stream)
  )

(defmethod (make-instance epsilon-decoding-input-stream :after) (&rest ignore)
  (when stream
    1;; If the caller supplied an initial stream, we must be certain to invoke 3:set-stream
1    ;; on the stream to insure that all proper setup takes place while being careful to0 1not
    ;; lose the caller's original option settings.
0    (let ((initial-stream stream))
      (setf stream nil)
      (lexpr-send self :set-stream initial-stream initial-options))))

(defmethod (:set-stream epsilon-decoding-input-stream)
	     (new-stream &key (reset-mappings t)
			      ((:escape-quote new-escape-quote) (char-subindex #\))
			      ((:loading-fat new-loading-fat))
			      ((:return-diagrams-as-lines new-return-diagrams-as-lines)))
1  ;; Put the new setttable options where the 3:reset-state1 message will find them later.
0  (cl:setf (cl:getf initial-options :escape-quote) new-escape-quote
	   (cl:getf initial-options :loading-fat) new-loading-fat
	   (cl:getf initial-options :return-diagrams-as-lines) new-return-diagrams-as-lines)
  1;; Setup the new stream.
0  (cl:setf (indirect-stream-stream buffered-stream) nil
	   (indirect-stream-stream unbuffered-stream) nil)
  (multiple-value-bind (actual-new-stream)
      (cond ((null new-stream) nil)
1	    ;; The following tests are kludges! --
	    ;;    The stream protocol should provide generic functions to determine whether
	    ;;    a stream is buffered/unbuffered.  Without them, we
	    ;;    must rely on checking for specific flavors or for support of the specific
0	    1;;    methods used by the 3buffered-character-to-8bit-stream1 flavor.
0	    ((cl:subtypep (cl:stream-element-type new-stream) '(cl:unsigned-byte 8))
	     new-stream)
	    ((cl:typep new-stream 'binary-stream)
	     (error "~S is a binary non-8bit stream." new-stream))
	    ((and (operation-handled-p new-stream :read-input-buffer)
		  (operation-handled-p new-stream :advance-input-buffer))
	     (setf (indirect-stream-stream buffered-stream) new-stream)
	     buffered-stream)
	    (t
	     (setf (indirect-stream-stream unbuffered-stream) new-stream)
	      unbuffered-stream))
    1;; Use the I.V. accessor instead of directly setting the I.V. to guarentee that
    ;; all appropriate side effects for setting the stream take place.
0    (setf (indirect-stream-stream self) actual-new-stream))
  1;; Now get back to our initial state.
0  (send self :reset-state reset-mappings))

(defmethod (:reset-state epsilon-decoding-input-stream :after) (&optional (reset-mappings t))
  (ignore reset-mappings)
  (send buffered-stream :discard-current-input-buffer)
  (send unbuffered-stream :discard-current-input-buffer))

(defmethod (:finish-input epsilon-decoding-input-stream) (&optional (check-complete t))
  (when (and stream input-buffer-p input-buffer)
    (send stream :advance-input-buffer input-buffer-start)
    (when check-complete
      (when (or unread-byte-tank unread-char-tank)
	(error "Stream ~S is being discarded, but input is not complete." self)))))

(defmethod (:set-stream epsilon-decoding-input-stream :before) (&rest ignore)
  (send self :finish-input nil))

(compile-flavor-methods epsilon-decoding-input-stream)

(defresource epsilon-decoding-input-stream (stream
					     &key (flavor 'epsilon-decoding-input-stream)
						  (escape-quote (char-subindex #\))
						  loading-fat
						  return-diagrams-as-lines)
  :constructor (make-instance flavor :stream nil
				     :escape-quote escape-quote
				     :loading-fat loading-fat
				     :return-diagrams-as-lines return-diagrams-as-lines)
  :matcher (eq (cl:type-of object) flavor)
  :initializer (send object :set-stream stream :escape-quote escape-quote
					       :loading-fat loading-fat
					       :return-diagrams-as-lines
					         return-diagrams-as-lines)
  :deinitializer (progn
		   (send object :set-stream nil)
		   (send object :reset-state)))



;;; ****************************************************************

;;; The following section is a a reimplementation of the above
;;; epsilon-decoding streams, but as buffered streams, as opposed to
;;; unbuffered.  This way is MUCH faster, and is expected to replace the
;;; above implementation, once we're sure it works right.

;;; states an encapsulating stream can be in:
;;;  :thin	default initial state, reading plain thin chars
;;;  :unstyled	password seen, no current style
;;;  :styled	loading with some kind of style coercion


;;;
;;; using a buffered string-char stream as our internal stream, do
;;; xlation buffer-at-a-time
;;;
(defflavor buffered-epsilon-encapsulating-input-mixin
	(
	 ;; state vars for style-hacking
	 state					; one of the above state kwds
	 character-type-table			; a grouped array of (?).  Kernsian.
	 current-type				; current type (style) number.
	 current-high-bits			; the value that goes into the
						;  %%char-all-but-subindex of a char
	 current-offset				; current offset in current char-set

	 style-stack				; vector of fixnums
	 escape-quote				; char (or code) of the escape char

	 ;; stuff used by check-password
	 leftover-buffer			; copy of tail end of last buffer,
						;  if saw a spurious escape sequence
						;  split across buffer boundaries
	 leftover-buffer-length			; nbytes in last-buffer

	 ;; diagram-ology.
	 return-diagrams-as-lines		; see the process-diagram-line method
	 pending-diagram-line			; temporary holding place for diag line

	 ;; housekeeping aids
	 current-buffer-resource		; resource we're getting bufs out of now
	 last-snapshot-state			; for read-location etc, see below
	 advance-p				; flag for next-input-buffer.  see below
	 current-buffer-position		; inner-stream's value from :read-position
						;  corresponding to the current buffer
	 fonts-preloaded			; Fonts attribute has been preloaded into
						;  style definitions for Rel6 compatibility
	 )
	(indirect-stream-mixin)
  (:required-flavors basic-buffered-input-stream)
  (:settable-instance-variables return-diagrams-as-lines)
  (:initable-instance-variables ;; stream
   return-diagrams-as-lines
   escape-quote))

(defmethod (make-instance buffered-epsilon-encapsulating-input-mixin :after) (&rest ignore)
  (setq state ':thin
	current-type 0
	current-high-bits 0
	character-type-table (make-character-type-table)
	current-offset 0
	style-stack nil
	leftover-buffer nil
	leftover-buffer-length nil
	return-diagrams-as-lines nil
	pending-diagram-line nil
	current-buffer-resource 'thin-string-buffer
	last-snapshot-state nil
	current-buffer-position 0
	advance-p nil
	fonts-preloaded nil
	)
  (send self ':reset-internal-state)
  (send self ':revert-to-thin-mode))		; somewhat misleading, but does the right thing

(defmethod (:reset-internal-state buffered-epsilon-encapsulating-input-mixin) ()
  (fill-array character-type-table nil nil)
  (send self :new-character-type 0 0 '(nil 0) '(nil nil nil) "CPTFONT")
  )

;;; pop back to thin-char mode, leave style state alone
(defmethod (:revert-to-thin-mode buffered-epsilon-encapsulating-input-mixin) ()
  (setq state ':thin)
  nil)

;;; ****************************************************************

;;; copy a portion of source-buffer to target-buffer, watching out for
;;; the escape-quote character

(defmethod (scan-for-epsilon-while-copying buffered-epsilon-encapsulating-input-mixin)
	   (source-buffer source-start source-end
			  target-buffer target-start)
  (declare (values epsilon-index-or-nil))
  (let* ((epsilon-index (%string-search-exact-char escape-quote source-buffer
						   source-start source-end)))
    (when epsilon-index
      (setq source-end epsilon-index))
    (copy-array-portion source-buffer source-start source-end
			target-buffer target-start
			(+ target-start (- source-end source-start)))
    epsilon-index))


(defmethod (scan-for-epsilon-while-fattening buffered-epsilon-encapsulating-input-mixin)
	   (source-buffer source-start source-end
			  target-buffer target-start)
  (declare (values epsilon-index-or-nil))
  (let ((source-buffer source-buffer)
	(target-buffer target-buffer))
    (declare (sys:array-register source-buffer target-buffer))
    (loop for i from source-start below source-end
	  for j from target-start
	  for elt = (aref source-buffer i)
	  when (eql elt escape-quote)
	    return i
	  do (setf (aref target-buffer j) 
		   (if (eql elt #\return)
		       #\return			; never fatten returns...
		       ;; int-char doesn't inline ?!?
		       (sys:%make-pointer sys:dtp-character
					  (%logdpb current-high-bits %%char-all-but-subindex
						   (+ (char-int elt) current-offset))))))))


(defmethod (:discard-input-buffer buffered-epsilon-encapsulating-input-mixin) (buf)
  (deallocate-resource current-buffer-resource buf)
  (cl:case state
    ((:thin :unstyled)   
     (setq current-buffer-resource 'thin-string-buffer))
    (:styled 
      (setq current-buffer-resource 'fat-string-buffer))))

;;;
;;; Our old friend, the next-input-buffer method.  read the inner
;;; stream's input buffer, and allocate a buffer to be handed to our
;;; client.  translate all of the inner stream's buffer, up to and
;;; including, but not past, any epsilons we find, to characters of the
;;; appropriate type, given our current state.  DON'T Advance the inner
;;; stream's buffer past what we've used.
;;;
;;; There's (yet another) screw here to do with rewinding.  Some kinds
;;; of inner streams don't really support rewinding; they just allow you
;;; to reset their pointer in the current buffer.  That means there'd
;;; better be a buffer there to reset the pointer in.  That, in turn,
;;; means we can't advance-input-buffer on the inner stream at the time
;;; we'd like to; rather, we must set the ADVANCE-P flag, to indicate
;;; that next time we're called, we must do the advance.  This allows
;;; clients (like read-attribute-list) to read our buffer, then do a
;;; set-pointer to rewind to zero.  ADVANCE-P can be either a fixnum, ie
;;; the amount to pass to advance-input-buffer, or T, meaning advance
;;; with no arg.
;;;
(defmethod (:next-input-buffer buffered-epsilon-encapsulating-input-mixin) (wait-p)
  (declare (values buffer start end))
  (ignore wait-p)				; for now
  (when advance-p				; need to advance?
    (send stream ':advance-input-buffer (and (fixnump advance-p) advance-p))
    (setq advance-p nil))			; zap the flag
  (snapshot-state self)				; encache state in case of :read-location
  (setq current-buffer-position (send stream ':read-pointer))
  (block next-input-buffer			; why do I have to do this?
    (let ((used-leftovers nil))
      (multiple-value-bind (inner-buf inner-start inner-end)
	  (if leftover-buffer
	      (progn
		(setq used-leftovers t)
		(values leftover-buffer 0 leftover-buffer-length))
	      (send stream ':read-input-buffer))
	(unless inner-buf
	  (return-from next-input-buffer (values nil nil nil)))
	(let ((buf (allocate-resource current-buffer-resource (- inner-end inner-start)))
	      (idx 0)				; idx into target buffer
	      (epsilon-index nil))

	  ;; first dispatch on state to right copy loop
	  (cl:case state
	    ((:thin :unstyled)
	     (setq epsilon-index
		   (scan-for-epsilon-while-copying self 
						   inner-buf inner-start inner-end
						   buf idx)))
	    (:styled
	      (setq epsilon-index
		    (scan-for-epsilon-while-fattening self 
						      inner-buf inner-start inner-end
						      buf idx))))
	  
	  (if (null epsilon-index)
	      (progn
		(setq idx (- inner-end inner-start))	; resultant buffer length
      		(unless used-leftovers
		  #+ignore
		  ;; can't do the advance yet, cause somebody might try to
		  ;; rewind.  instead, set the flag saying we should
		  ;; advance next time.
		  (send stream ':advance-input-buffer)	; tell inner stream we've eaten it
		  #-ignore
		  (setq advance-p t)))
	      (progn
		;; if there's an escape in the raw-buffer, we'll only process up to
		;; and including it, not past it.  that's because :process-escape
		;; and co. are doing operations on the inner stream which chould
		;; cause it to fall off the end of the current buffer and get the
		;; next one.  to avoid getting screwed by that, we'll exit and go
		;; thru the upper-level logic again.

		(setq idx (- epsilon-index inner-start))
		;; advance to past epsilon or end of buffer...
		(if used-leftovers 
		    (progn
		      (deallocate-resource 'thin-string-buffer (cl:shiftf leftover-buffer nil))
		      (setq used-leftovers nil))
		    (send stream ':advance-input-buffer (1+ epsilon-index)))
		(let ((escape-result (send self ':process-escape)))	; and deal with the escape
		  (when escape-result 
		    (setf (aref buf idx) escape-result)
		    (incf idx)))))
	  ;; if we had junk left over, deallocate it now
	  (when used-leftovers
	    (deallocate-resource 'thin-string-buffer (cl:shiftf leftover-buffer nil))
	    (setq leftover-buffer-length nil))
	  (values buf 0 idx))))))

;;;
;;; process an escape code.  this is mostly cribbed from (method
;;; :process-escape escape-loading-stream-mixin)
;;;
(defmethod (:process-escape buffered-epsilon-encapsulating-input-mixin) ()
  (declare (values char-or-nil))
  (cond ((eq state ':thin)			; haven't yet done anything with epsilons?
	 (send self ':check-password 1))	; no.  see if it's the password string

	(t					; we've already seen an escape
	 (let* ((next-char (send stream ':tyi)))	; get char after esc
	   (or (when (eql next-char escape-quote)
		 (sys:%make-pointer sys:dtp-character
				    (%logdpb current-high-bits %%char-all-but-subindex
					     (+ (char-int escape-quote) current-offset))))
	       (when (eql next-char #\return) 
		 (sys:%make-pointer sys:dtp-character
				    (%logdpb current-high-bits %%char-all-but-subindex
					     (+ (char-int #\Return) current-offset))))
	       (block process-real-escape-sequence
		 (select next-char
		   (#\(
		    (send stream ':untyi next-char)	; put it back
		    (send self ':process-style-spec))	; so this guy can read it
		   (#\
		    (send self ':check-password 2))
		   (fat-unpassword-character	; #\pi
		    (send self ':revert-to-thin-mode))
		   (#\*
		    (send self ':set-style-number
			  (if style-stack (array-pop style-stack) 0))
		    nil)
		   (#\#
		    (send self ':process-diagram-line))
		   (otherwise
		    (if (char-lessp next-char #\0)
			(signal-proceed-case (() 'escape-loading-stream-unknown-escape-code
					      ':stream self
					      ':escape-code (char-code next-char))
			  (:insert-escape-sequence
			    (send stream ':untyi next-char)
			    (return-from process-real-escape-sequence escape-quote)))
			(send self ':process-style-code next-char)))))
	       nil)))))


;;;
;;; this gets run the first time we see an epsilon.  checks to make sure
;;; this epsilon is introducing the start of style-ified text.  This is
;;; a bit grosser than necessary, as the password message is many bytes
;;; long.  We attempt to just check the data in the inner-stream's
;;; current input buffer, but if that fails, we copy the tail of his
;;; buffer into a temp, so that we can look at the next one.
;;;
(defmethod (:check-password buffered-epsilon-encapsulating-input-mixin) (&optional (start 1))
  (multiple-value-bind (inner-buf inner-start inner-end)
      (send stream ':read-input-buffer)
    (if (> (- inner-end inner-start) 
	   (- (+ (string-length *fat-password*)
		 (string-length *fat-password-message*)
		 1)
	      start))
	(send self ':check-password-the-easy-way inner-buf inner-start start)
	(send self ':check-password-the-hard-way start))))

(defmethod (:check-password-the-easy-way buffered-epsilon-encapsulating-input-mixin)
	   (inner-buf inner-start nbytes-seen)
  (block check
    ;; inner-buf could be either a row of 8bs or string-chars, so make
    ;; an intdirect array onto it.  it's not all that fast, but we don't
    ;; care so much about being fast here.
    (with-stack-array (string-inner-buf (array-length inner-buf)
					:element-type 'cl:string-char
					:displaced-to inner-buf)
      (let* ((pw-start inner-start)
	     (pw-end (- (+ pw-start (string-length *fat-password*)) nbytes-seen))
	     (version-code (char-code (aref string-inner-buf pw-end)))
	     (pwm-start (+ 1 pw-end))
	     (pwm-end (+ pwm-start (string-length *fat-password-message*))))
	;; start by looking at this one.  if it matches, try the rest
	(cond ((zerop				; yow! are we *nix weenies yet?
		 (string-compare string-inner-buf *fat-password* pw-start nbytes-seen pw-end))
	       (setq state ':unstyled)		; seen passwd, but no style yet
	       (cl:case version-code
		 (1				; old version?  just advance past version
		   (send stream ':advance-input-buffer (1+ pw-end))
		   nil)
		 (2				; current version.  check for rest of msg
		   (if (zerop (string-compare string-inner-buf *fat-password-message*
					      pwm-start 0 pwm-end))
		       ;; matches.  advance past the whole works
		       (send stream ':advance-input-buffer pwm-end)
		       (return-from check escape-quote)) ; no match, just return the quote char
		   nil)
		 (t
		   (signal-proceed-case (() 'escape-loading-stream-unknown-password-version
					 ':stream self ':version version-code)
		     (:continue-processing)))))
	      (t
	       ;; false alarm; there wasn't any kind of password there
	       escape-quote))))))


(defmethod (:check-password-the-hard-way buffered-epsilon-encapsulating-input-mixin) 
	   (nbytes-seen)
  (let ((raw-chars-read nil))
    (flet ((get-next-char ()
	     (let ((ch (send stream ':tyi)))
	       (push ch raw-chars-read)
	       ch)))
      ;; first check the *fat-password*
      (unless
	(when (loop for idx from nbytes-seen below (string-length *fat-password*)
		    for ch = (get-next-char)
		    do (unless (eql ch (aref *fat-password* idx))
			 (return nil))
		    finally (return t))
	  ;; ok, that much matches.  try the version number
	  (setq state ':unstyled)
	  (let ((version-code (char-code (get-next-char))))
	    (cl:case version-code
	      (1				; version 1 file?  We're done
		t)
	      (2				; version 2?  check message
		(loop for idx from 0 below (string-length *fat-password-message*)
		      for ch = (get-next-char)
		      while (eql ch (aref *fat-password-message* idx))
		      finally (return t)))
	      (t
		(signal-proceed-case (() 'escape-loading-stream-unknown-password-version
				      ':stream self ':version version-code)
		  (:continue-processing))))))
	;; oops, something in all those tests failed.  Put all the
	;; collected chars in a buffer to be 'read' next time we call
	;; next-input-buffer
	(when leftover-buffer
	  (error "Internal error, about to throw out leftover buffer ~S" leftover-buffer)
	  (deallocate-resource 'thin-string-buffer leftover-buffer))
	(setq leftover-buffer (allocate-resource 'thin-string-buffer (length raw-chars-read)))
	(setq leftover-buffer-length (length raw-chars-read))
	(loop for i from 0 below leftover-buffer-length
	      do (setf (aref leftover-buffer (- leftover-buffer-length i 1))
		       (pop raw-chars-read)))
	escape-quote))))


;;;
;;; things used by that guy
;;;
(defmethod (:process-style-spec buffered-epsilon-encapsulating-input-mixin) ()
  (let ((spec (condition-case (.error.)
		   (scl:with-standard-io-environment
		     (condition-bind
		       ((sys:external-symbol-not-found
			  (named-lambda condition-bind (condition)
			    (sys:proceed condition :internal))))
		       (cl:read stream)))
		 (error
		   ;; Only proceed type for the following error never returns.
		   (signal 'escape-loading-stream-invalid-type-specification
			   ':stream self ':contained-error .error.)))))
    (multiple-value-bind (index definition)
	(send self ':validate-character-type-specification spec)
      (when definition
	(lexpr-send self ':new-character-type index definition))
      (when (null style-stack)
	(setq style-stack
	      (zl:make-array 10. ':type 'art-fixnum ':fill-pointer 0)))
      (array-push style-stack current-type)
      (send self ':set-style-number index)))
  nil)


(defmethod (:process-diagram-line buffered-epsilon-encapsulating-input-mixin) ()
  (block process-real-escape-sequence		; do I need this?
    (let ((diagram-terminated-by-eof))
      (labels ((return-string (string &optional include-escape-sequence)
		 (when leftover-buffer
		   (error "Internal error, about to throw out leftover buffer ~S" 
			  leftover-buffer)
		   (deallocate-resource 'thin-string-buffer leftover-buffer))
		 (setq leftover-buffer 
		       (allocate-resource 'thin-string-buffer
					  (+ 2 (string-length string))
					  1))	; want a fill-pointer
		 (setf (fill-pointer leftover-buffer) 0)
		 (when include-escape-sequence
		   (scl:vector-push #\# leftover-buffer))
		 (scl:vector-push-portion-extend	; won't extend, here...
		   leftover-buffer string)
		 (unless diagram-terminated-by-eof
		   (scl:vector-push #\return leftover-buffer))
		 (setq leftover-buffer-length (string-length leftover-buffer))
		 nil
		 ))
	(with-stack-array (contents 100 :type 'art-string :fill-pointer 0)
	  (cl:loop
	     (let ((char (send stream ':tyi)))
	       (when (or (null char) (eql char #\return))
		 (setq diagram-terminated-by-eof (null char))
		 (return))
	       (array-push-extend contents char)))
	  (if return-diagrams-as-lines
	      (condition-case (.error.)
		   (progn
		     (when pending-diagram-line
		       (error "Attempt to cache diagram line when there's already one cached"))
		     (setq pending-diagram-line 
			   (zwei:diagram-escape-convert contents))
		     (return-from process-real-escape-sequence nil))		       
		 (error
		   (signal-proceed-case (() 'escape-loading-stream-invalid-diagram
					 :stream self :contained-error .error.)
		     (:insert-escape-sequence
		       (return-string contents t))
		     (:return-invalid-diagram
		       (return-from process-real-escape-sequence
			 (make-instance 'zwei:invalid-line-diagram
					:original-contents contents))))))
	      (return-string "<Diagram line>")))))))


(defmethod (:process-style-code buffered-epsilon-encapsulating-input-mixin)
	   (style-code)
  (let ((raw-code (- (char-code style-code) (char-code #\0))))
    (multiple-value-bind (real-index definition)	; get system's style index from local one
	(send self ':validate-character-type-specification (list raw-code))
      (when definition
	(lexpr-send self ':new-character-type real-index definition))
      (when (null style-stack)
	(setq style-stack
	      (zl:make-array 10. ':type 'art-fixnum ':fill-pointer 0)))
      (array-push style-stack current-type)	; stack the old style
      (send self ':set-style-number real-index)
      nil)))


(defmethod (:set-style-number buffered-epsilon-encapsulating-input-mixin) (style-number)
  (let ((tbl-idx (* style-number character-type-table-size)))
    (setq current-type style-number)		; remember the type code
    (let ((current-bits (character-type-table-bits tbl-idx character-type-table))
	  (current-style-index (character-type-table-style-index tbl-idx character-type-table))
	  (current-character-set-index (character-type-table-character-set-index
					 tbl-idx character-type-table)))
      (setq current-high-bits 
	    (%logldb %%char-all-but-subindex
		     (%logdpb current-bits %%char-bits
			      (%logdpb current-style-index %%char-style
				       (%logdpb current-character-set-index %%char-char-set
						0))))))
    (setq current-offset (character-type-table-character-set-code-offset
			   tbl-idx character-type-table))
    (setq state (if (zerop style-number)
		    ':unstyled ':styled))	; say we're now doing styled chars
    ))


;;; Initialize character types from a list of fonts, as obtained from the
;;; attribute list of the file.  Release 6 compatability.

(defmethod (:set-types-from-font-list buffered-epsilon-encapsulating-input-mixin) (fonts)
  (loop for i from 0
	for keyfont in (if (atom fonts) (list fonts) fonts)
	for font = (intern (string keyfont) (symbol-package 'fonts:cptfont))
	do (multiple-value-bind (style char-set offset)
	       (backtranslate-font font si:*b&w-screen*)
	     (setq style (canonicalize-character-style style))
	     (stack-let ((char-set-spec (list (send char-set :name) offset)))
	       (send self :new-character-type i 0 char-set-spec style keyfont))))
  ;; Make the new bindings take effect.
  (send self :set-style-number 0)
  (setq fonts-preloaded t))

;;; this is used by various of the error handlers for
;;; unrecognized-style-number, etc.
(defmethod (:get-character-type buffered-epsilon-encapsulating-input-mixin) (character-type)
  (declare (values bits character-set character-set-offset style))
  (let ((tbl-idx (* character-type character-type-table-size)))
    (if (and ( 0 tbl-idx (1- (array-length character-type-table)))
	     (character-type-table-bits tbl-idx character-type-table))
	(values (character-type-table-bits tbl-idx character-type-table)
		(character-type-table-character-set tbl-idx character-type-table)
		(character-type-table-character-set-offset tbl-idx character-type-table)
		(character-type-table-style tbl-idx character-type-table))
      (when (zerop tbl-idx)			;type 0 should always appear defined.
	(values 0 nil 0 '(nil nil nil))))))

;;; Set character types from the Japanese attribute -- Release 6 compatability.
(defmethod (:set-japanese buffered-epsilon-encapsulating-input-mixin) (size)
  (let ((font))
    (cl:case size
      (12.
	(setq size :normal
	      font "JIS12")
	(send self :set-types-from-font-list 'fonts:(CPTFONT CPTFONTB CPTFONT CPTFONTI
						     CPTFONTB)))
      (16.
	(setq size :large
	      font "JIS16")
	(send self :set-types-from-font-list 'fonts:(CPTFONT CPTFONTB TR12 TR12B TR12I)))
      (48.
	(setq size :huge
	      font "JIS48")
	(send self :set-types-from-font-list 'fonts:(DUTCH20 DUTCH20B TR12 TR12B TR12I)))
      (otherwise
	;; Also known as 24.
	(setq size :very-large
	      font "JIS24")
	(send self :set-types-from-font-list 'fonts:(DUTCH20 DUTCH20B TR12 TR12B TR12I))))
    (loop for i from 10				3; 10 is wired into Japanese files.
0	  for j from 0
	  repeat 54				; Number of 128-char fonts in old days.
	  do
      (send self :new-character-type i 0 `("JAPANESE" ,(* j 1/2)) `(nil nil ,size) font))))

;;;
;;; more internal methods, cribbed from the same place
;;;
(defmethod (:validate-character-type-specification buffered-epsilon-encapsulating-input-mixin)
	   (spec)
  (let* ((character-type (car spec))
	 (new-type-definition (cdr spec))
	 (type-index-valid (and (cl:integerp character-type) ( 0 character-type)))
	 (type-already-defined (and type-index-valid
				    (character-type-defined-p character-type-table
							      character-type))))
    (macrolet
        ((signal-and-handle-condition (condition &rest condition-init-keywords)
	   `(signal-proceed-case (() ,condition ,@condition-init-keywords)
	      (:use-type-zero
		;; Use the same definition as type 0.
		(cond ((and type-index-valid (zerop character-type))
		       (setq new-type-definition '(0 (nil 0) (nil nil nil) "")))
		      ((and type-index-valid (> character-type 0))
		       (multiple-value-bind (type-zero-bits type-zero-charset
					     type-zero-charset-offset type-zero-style)
			   (send self :get-character-type 0)
			 (setq new-type-definition `(,type-zero-bits
						     (,type-zero-charset
						      ,type-zero-charset-offset)
						     ,type-zero-style ""))))
		      (t
		       (setq character-type 0
			     new-type-definition nil))))
	      (:define-type-as-undefined-style
		;; Use the standard character set, no bits, and the special undefined style
		(when (or (not type-index-valid)
			  (zerop character-type))	;Don't want type 0 to be "undefined".
		  (let ((next-type-index
			  (/ (array-length character-type-table) character-type-table-size)))
		    (setq character-type next-type-index)))
		(setq new-type-definition `(0 (nil 0) ,*undefined-character-style* ""))))))
      (unless (and type-index-valid
		   (or type-already-defined new-type-definition))
	;; Index is invalid (not an integer or negative) or undefined --
	;;    Signal the appropriate condition and handle the possible proceed options.
	(signal-and-handle-condition (if type-index-valid
					 'escape-loading-stream-undefined-type-index
					 'escape-loading-stream-invalid-type-index)
				     :stream self :type-index character-type))
      (when new-type-definition
	;; Caller is going to define a new type -- Verify the definition.
	(condition-case (.error.)
	     (validate-character-type-definition new-type-definition)
	   (error
	     (signal-and-handle-condition 'escape-loading-stream-invalid-type-definition
					  :stream self :type-index character-type
					  :contained-error .error.))
	   )))
    (values character-type new-type-definition)))


(defmethod (:new-character-type buffered-epsilon-encapsulating-input-mixin)
	   (type-index bits char-set style default-font &rest ignore)
  (ignore default-font)		;Someday, use this to provide for unknown styles.
  (when ( type-index (/ (array-length character-type-table) character-type-table-size))
    (send self ':grow-character-type-table type-index))
  (setq style (parse-character-style style))
  (let ((tbl-idx (* type-index character-type-table-size)))
    (cl:setf (character-type-table-bits tbl-idx character-type-table) bits
	     (character-type-table-style tbl-idx character-type-table) style
	     (character-type-table-style-index tbl-idx character-type-table)
	       (style-index style t)))
  (lexpr-send self ':parse-character-set type-index char-set)
  (when (= type-index current-type)
    (send self ':set-style-number current-type)))


(defmethod (:grow-character-type-table buffered-epsilon-encapsulating-input-mixin)
	   (required-size)
  (let ((new-table (make-character-type-table :times (ceiling (* required-size 3/2)))))
    (copy-array-contents character-type-table new-table)
    (setq character-type-table new-table)))


(defmethod (:parse-character-set buffered-epsilon-encapsulating-input-mixin)
	   (type-index name offset)
  (multiple-value-bind (offset half)
      (floor offset)
    (let* ((char-set (lookup-character-set name))
	   (index (send char-set :decode-offset offset))
	   (tbl-idx (* type-index character-type-table-size)))
      (cl:setf (character-type-table-character-set tbl-idx character-type-table) char-set
	       (character-type-table-character-set-offset tbl-idx character-type-table)
	         offset
	       (character-type-table-character-set-index tbl-idx character-type-table)
		 index
	       (character-type-table-character-set-code-offset tbl-idx character-type-table)
	         (* half 256.)))))



;;; ****************************************************************

;;; read-location and set-location
;;;
;;; :next-input-buffer, above, will update the inner-stream's location,
;;; and cache the current style-index, every time it's called.
;;; :read-location returns a structure containing the inner-stream's
;;; location corresponding to the start of this buffer, the style-index,
;;; and a clone of the type-table.

(defstruct (epsilon-decoding-state (:type :array) (conc-name eds-))
  inner-stream-location				; inner-stream loc at BEGINNING this buf
  outer-stream-offset				; offset into buf when read-loc called

  ;; copies of the IV's of the same names from the stream

  state						; one of the above state kwds
  character-type-table				; a grouped array of (?).  Kernsian.
  current-type					; current type (style) number.
  current-high-bits				; the value that goes into the
						;  %%char-all-but-subindex of a char
  current-offset				; current offset in current char-set

  style-stack					; vector of fixnums
  )

;;; snapshot current stream state into state block
(defmethod (snapshot-state buffered-epsilon-encapsulating-input-mixin) ()
  (let ((block (or last-snapshot-state
		   (setq last-snapshot-state (make-epsilon-decoding-state)))))
    (declare (sys:array-register block))
    (setf (eds-inner-stream-location block) (send stream ':read-location))
    (setf (eds-outer-stream-offset block) 0)	; beginning of buf, not really needed here...
    (setf (eds-state block) state)		; current epsilon-state of stream

    (when (and (eds-character-type-table block)
	       (< (array-length (eds-character-type-table block))
		  (array-length character-type-table)))	; grown since we built it?
      (setf (eds-character-type-table block) nil))	; flush it.
    (if (eds-character-type-table block)
	(copy-array-contents character-type-table	; copy data to new 
			     (eds-character-type-table block))
	(setf (eds-character-type-table block)	; clone it
	      (copy-character-type-table character-type-table)))
    (setf (eds-current-type block) current-type)
    (setf (eds-current-high-bits block) current-high-bits)
    (setf (eds-current-offset block) current-offset)

    (when style-stack
      (unless (eds-style-stack block)
	(setf (eds-style-stack block)
	      (zl:make-array 10. ':type 'art-fixnum 
			     ':fill-pointer (fill-pointer style-stack))))
      (copy-array-contents style-stack (eds-style-stack block)))))

(defmethod (:read-location buffered-epsilon-encapsulating-input-mixin) ()
  ;; not sure if this error is legit.
;  (unless stream-input-buffer
;    (error "Attempt to :read-location when no input buffer!"))
  ;; it's not.  if no current input buffer, force one.
  (unless stream-input-buffer
    (send self ':read-input-buffer))
  (unless last-snapshot-state			; in case we're called twice in a row.
    (snapshot-state self))
  (setf (eds-outer-stream-offset last-snapshot-state)	; stash away the current stream-input-index
	stream-input-index)
  (cl:shiftf last-snapshot-state nil))		; return this struct, and zap if for next time


(defmethod (:set-location buffered-epsilon-encapsulating-input-mixin) (block)
  (let ((block block))
    (declare (sys:array-register block))
  ;; set the inner-stream's location to the cached one, and set all the
  ;; outer stream's IV's to the values from the EDS.  Then do a bunch of
  ;; TYI's to force the outer stream's stream-input-index up to the
  ;; cached value.  We don't do that last part with
  ;; :advance-input-buffer or whatever, because we're not guaranteed
  ;; that the inner stream's buffers will be in the same places they
  ;; were when we read it the first time.
    (send self ':advance-input-buffer)		; flush current-input-buffer
    (send stream ':set-location (eds-inner-stream-location block))
    (setq state (eds-state block))
    (setq character-type-table (copy-character-type-table (eds-character-type-table block)))
    (setq current-type (eds-current-type block))
    (setq current-high-bits (eds-current-high-bits block))
    (setq current-offset (eds-current-offset block))
    (if (eds-style-stack block)
	(progn 
	  (unless style-stack 
	    (setq style-stack (zl:make-array 10. ':type 'art-fixnum 
					     ':fill-pointer (fill-pointer 
							      (eds-style-stack block)))))
	  (copy-array-contents (eds-style-stack block) style-stack))
	(setq style-stack nil))
    (loop repeat (eds-outer-stream-offset block)
	  do (send self ':tyi))))


;;; ****************************************************************

;;; other things, not really related to epsilon-encapsulation

(defmethod (:read-pointer buffered-epsilon-encapsulating-input-mixin) ()
  (and current-buffer-position
       (+ current-buffer-position (or (and stream-input-buffer stream-input-index) 0))))

;;; primary method for this comes from indirect-stream-mixin
(defmethod (:set-pointer buffered-epsilon-encapsulating-input-mixin :before) (p)
  (unless (zerop p)
    (error ":SET-POINTER is only supported for pointer value 0"))
  (setq advance-p nil)				; flush any pending advances!
  (send self ':discard-current-input-buffer)
  (setq stream-input-index nil)			; so as not to confuse read-pointer
  (when leftover-buffer
    (deallocate-resource 'thin-string-buffer (cl:shiftf leftover-buffer nil)))
  (setq leftover-buffer-length 0)
  ;; If we had style state, don't blow it away, just set ourselves back
  ;; to thin or unstyled mode.  This preserves font info that was shoved in explicitly
  ;; by the file-access-path-open whopper (for rel-6 compatibility), and is
  ;; innocuous for rel-7 files, as re-processing the password etc will simply 
  ;; restore the state we already have.
  (if fonts-preloaded
      (send self :set-style-number 0)
      (setq state ':thin)))


(defwhopper (:tyi buffered-epsilon-encapsulating-input-mixin) (&rest args)
  (if pending-diagram-line
      (cl:shiftf pending-diagram-line nil)
      (lexpr-continue-whopper args)))


(defwhopper (:line-in buffered-epsilon-encapsulating-input-mixin) (&optional leader)
  (declare (values line eof-p))
  (if pending-diagram-line
      (values (cl:shiftf pending-diagram-line nil) nil)
      (continue-whopper leader)))


(defwhopper (:string-line-in buffered-epsilon-encapsulating-input-mixin)
	    (eof line &optional (start 0) end)
  (declare (values length-so-far eof-p more-on-line-p diag))
  (if pending-diagram-line
      (values 0 nil nil (cl:shiftf pending-diagram-line nil))
      (continue-whopper eof line start end)))

;;;
;;; make sure buffers get flushed
;;;
(defmethod (unencapsulate-stream buffered-epsilon-encapsulating-input-mixin :before) ()
  (send self ':discard-current-input-buffer)
  (when leftover-buffer
    (deallocate-resource 'thin-string-buffer (cl:shiftf leftover-buffer nil))))


(defmethod (:close buffered-epsilon-encapsulating-input-mixin :before) (&optional abort-p)
  (ignore abort-p)
  (when leftover-buffer
    (deallocate-resource 'thin-string-buffer (cl:shiftf leftover-buffer nil))))


;;; ****************************************************************

;;; use this one for inner streams that deal in string-chars, and have
;;; already done ascii->lispm translation
(defflavor string-char-epsilon-mixin 
	()
	()
  (:required-flavors buffered-epsilon-encapsulating-input-mixin)
  (:default-init-plist :escape-quote #\))

;;; Heads up!  An instantiable flavor!
(defflavor string-char-epsilon-input-stream 
	()
	(string-char-epsilon-mixin 
	 buffered-epsilon-encapsulating-input-mixin
	 si:character-stream
	 si:buffered-line-input-mixin
	 si:buffered-input-stream
	 future-common-lisp:file-stream))

(compile-flavor-methods string-char-epsilon-input-stream)
