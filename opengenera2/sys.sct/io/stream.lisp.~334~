;;; -*- Mode:LISP; Package:SYSTEM-INTERNALS; Base:8 -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; Flavor basis for streams

;;; To make a buffered stream:
;;; For input, define :NEXT-INPUT-BUFFER &OPTIONAL NO-HANG-P => ARRAY START END END-OF-RECORD
;;;		      :DISCARD-INPUT-BUFFER ARRAY
;;; For output, define :NEW-OUTPUT-BUFFER => ARRAY START END
;;;		       :SEND-OUTPUT-BUFFER ARRAY END END-OF-RECORD
;;;		       :DISCARD-OUTPUT-BUFFER ARRAY

;;; To make :SET-POINTER work, define :SET-BUFFER-POINTER NEW-POINTER => REAL-NEW-POINTER
;;; where REAL-NEW-POINTER should be such that the next :NEXT-INPUT-BUFFER will access the
;;; desired position somewhere in the buffer.

;;; To make binary streams, mix with
;;; for input	SI:BUFFERED-INPUT-BINARY-STREAM
;;; for output	SI:BUFFERED-OUTPUT-BINARY-STREAM
;;; for both	SI:BUFFERED-BINARY-STREAM

;;; and one of UNSIGNED-BYTE-8-STREAM or UNSIGNED-BYTE-16-STREAM to define :ELEMENT-TYPE.

;;; To make character streams, mix with
;;; for input	SI:BUFFERED-INPUT-CHARACTER-STREAM
;;; for output 	SI:BUFFERED-OUTPUT-CHARACTER-STREAM
;;; for both	SI:BUFFERED-CHARACTER-STREAM

;;; To make a character stream that does character set translation or compression or something
;;; like that, define a wrapper on :TYI (:TYO) that does the translation.  Then mix with
;;; for input	SI:BUFFERED-TYI-INPUT-STREAM
;;; for output	SI:BUFFERED-TYO-OUTPUT-STREAM
;;; for both	SI:BUFFERED-TYI-TYO-STREAM

;;; There are mixins in this file (SI:ASCII-TRANSLATING-INPUT-STREAM-MIXIN and
;;;	SI:ASCII-TRANSLATING-OUTPUT-STREAM-MIXIN) for translating between ASCII and Lisp
;;;	machine character set, both for buffered and unbuffered streams.

;;; For file streams, the mixin SI:FILE-STREAM-MIXIN handles the pathname and
;;; printing nicely.  Use this for :PROBE openings (since they cannot do I/O).
;;; For input file streams, use SI:INPUT-FILE-STREAM-MIXIN.
;;; For output file streams, use SI:OUTPUT-FILE-STREAM-MIXIN.
;;; These make you interact with the who-line correctly.

;;; Base flavors

(DEFFLAVOR STREAM () ()
  (:REQUIRED-METHODS :ELEMENT-TYPE)
  (:DOCUMENTATION :BASE-FLAVOR "All streams are built on this.
    This flavor is mostly for TYPEP, but also provides default methods for messages
    which all streams, input or output, are required to handle."))

(DEFMETHOD (:CLOSE STREAM :DEFAULT) (&OPTIONAL MODE)
  MODE	;ignored
  NIL)

(DEFMETHOD (:CLOSE-WITH-REASON STREAM :DEFAULT) (REASON &OPTIONAL MODE)
  REASON
  (SEND SELF ':CLOSE MODE))

;;; Streams are binary until proven otherwise
(DEFMETHOD (:CHARACTERS STREAM) ()
  (LET ((ELEMENT-TYPE (SEND SELF :ELEMENT-TYPE)))
    (CL:SUBTYPEP 'CL:STRING-CHAR ELEMENT-TYPE)))

(DEFMETHOD (:ELEMENT-TYPE STREAM :DEFAULT) ()
  (LET ((BYTE-SIZE (SEND-IF-HANDLES SELF :BYTE-SIZE)))
    `(CL:UNSIGNED-BYTE ,(OR BYTE-SIZE 16.))))

(DEFMETHOD (:DIRECTION STREAM) () NIL)

(DEFMETHOD (:INTERACTIVE STREAM) () NIL)

;;;

(DEFFLAVOR INPUT-STREAM () (STREAM)
  (:REQUIRED-METHODS :LISTEN :TYI :UNTYI)
  (:DOCUMENTATION :BASE-FLAVOR "All input streams are built on this."))

(DEFMETHOD (:ANY-TYI INPUT-STREAM :DEFAULT) (&OPTIONAL EOF)
  (SEND SELF ':TYI EOF))

(DEFMETHOD (:CLEAR-INPUT INPUT-STREAM :DEFAULT) ()
  (LOOP WHILE (SEND SELF :TYI-NO-HANG)))

(DEFMETHOD (:DIRECTION INPUT-STREAM) () ':INPUT)

(DEFMETHOD (:READ-UNTIL-EOF INPUT-STREAM :DEFAULT) ()
  (LOOP WHILE (SEND SELF ':TYI)))

(DEFMETHOD (:STRING-IN INPUT-STREAM :DEFAULT) (EOF STRING &OPTIONAL (START 0) END)
  (DECLARE (VALUES INDEX EOF-P))
  ;; Default the END argument in the usual fashion
  ;; Use length rather than active-length, of course, since we're storing into the string
  (LET ((STRING STRING))
    (DECLARE (ARRAY-REGISTER STRING))
    (WHEN (NULL END)
      (SETQ END (ARRAY-LENGTH STRING)))
    (LOOP WHILE (< START END)
	  AS CH = (SEND SELF ':TYI)
	  WHILE CH
	  DO (SETF (AREF STRING (PROG1 START (INCF START))) CH)
	  FINALLY (WHEN (ARRAY-HAS-LEADER-P STRING)
		    (SETF (FILL-POINTER STRING) START))
		  (WHEN (AND (NULL CH) EOF)
		    (ERROR 'END-OF-FILE ':STREAM SELF ':FORMAT-STRING EOF))
		  (RETURN (VALUES START (NULL CH))))))

(DEFMETHOD (:TYI-NO-HANG INPUT-STREAM :DEFAULT) (&OPTIONAL EOF)
  (WHEN (SEND SELF :LISTEN) (SEND SELF :TYI (OR EOF T))))

(DEFMETHOD (:CLEAR-EOF INPUT-STREAM :DEFAULT) ()
  NIL)

(DEFMETHOD (:TYIPEEK INPUT-STREAM :DEFAULT) (&OPTIONAL EOF)
  (LET ((TEM (SEND SELF ':TYI EOF)))
    (WHEN TEM (SEND SELF :UNTYI TEM))
    TEM))

(DEFMETHOD (:INPUT-WAIT INPUT-STREAM :DEFAULT) (&OPTIONAL WHOSTATE FUNCTION &REST ARGUMENTS)
  (PROCESS-WAIT (OR WHOSTATE "Input Wait")
		#'(LAMBDA (STREAM FUNCTION ARGUMENTS)
		    (OR (AND FUNCTION (APPLY FUNCTION ARGUMENTS))
			(SEND STREAM :LISTEN)))
		SELF FUNCTION ARGUMENTS))

(DEFMETHOD (STREAM-INPUT-BLOCK INPUT-STREAM :DEFAULT)
	   (&OPTIONAL WHOSTATE FUNCTION &REST ARGUMENTS)
  (LEXPR-SEND SELF :INPUT-WAIT WHOSTATE FUNCTION ARGUMENTS))

;;;

(DEFFLAVOR OUTPUT-STREAM () (STREAM)
  (:REQUIRED-METHODS :TYO)
  (:METHOD-ORDER :TYO)
  (:DOCUMENTATION :BASE-FLAVOR "All output streams are built on this."))

(DEFMETHOD (:DIRECTION OUTPUT-STREAM) () ':OUTPUT)

(DEFMETHOD (:STRING-OUT OUTPUT-STREAM :DEFAULT) (STRING &OPTIONAL (START 0) END)
  (LET ((STRING STRING))
    (DECLARE (ARRAY-REGISTER STRING))
    (OR END (SETQ END (ARRAY-ACTIVE-LENGTH STRING)))
    (DO ((I START (1+ I))) (( I END))
      (SEND SELF ':TYO (AREF STRING I)))))

(DEFMETHOD (:CLEAR-OUTPUT OUTPUT-STREAM :DEFAULT) ()
  NIL)

(DEFMETHOD (:FORCE-OUTPUT OUTPUT-STREAM :DEFAULT) ()
  NIL)

(DEFMETHOD (:FINISH OUTPUT-STREAM :DEFAULT) ()
  NIL)

(DEFMETHOD (:FINISH OUTPUT-STREAM :BEFORE) ()
  (SEND SELF ':FORCE-OUTPUT))

(DEFMETHOD (:EOF OUTPUT-STREAM :DEFAULT) ()
  (SEND SELF ':FINISH))

(DEFMETHOD (:BEEP OUTPUT-STREAM :DEFAULT) (&REST IGNORE)
  NIL)

(DEFMETHOD (:WITH-CHARACTER-STYLE OUTPUT-STREAM :DEFAULT)
	   (NEW-STYLE CONTINUATION XSTREAM &OPTIONAL BIND-LINE-HEIGHT)
  (DECLARE (SYS:DOWNWARD-FUNARG CONTINUATION))
  (IGNORE NEW-STYLE BIND-LINE-HEIGHT)
  (FUNCALL CONTINUATION XSTREAM))

(DEFMETHOD (:OUTPUT-AS-PRESENTATION OUTPUT-STREAM)
	   (CONTINUATION XSTREAM &REST KEYS
	    &KEY (OBJECT NIL) (TYPE T) (CHECK-TYPE DW::*PRESENT-CHECKS-TYPE*)
	    &ALLOW-OTHER-KEYS)
  (IGNORE KEYS)
  (DW::CHECK-PRESENTATION-TYPE CHECK-TYPE OBJECT TYPE)
  (FUNCALL CONTINUATION XSTREAM)
  NIL)

(DEFMETHOD (:OUTPUT-AS-PRESENTATION-1 OUTPUT-STREAM)
	   (CONTINUATION CONTINUATION-ARGS &REST KEYS
	    &KEY (OBJECT NIL) (TYPE T) (CHECK-TYPE DW::*PRESENT-CHECKS-TYPE*)
	    &ALLOW-OTHER-KEYS)
  (IGNORE KEYS)
  (DW::CHECK-PRESENTATION-TYPE CHECK-TYPE OBJECT TYPE)
  (APPLY CONTINUATION CONTINUATION-ARGS)
  NIL)

;;;

;;;--- D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI"):BIDIRECTIONAL0?! what you say to OPEN is :IO.  This
;;;--- is probably wrong, but things depend on it.
;;;--- fixed when we invent a Generic Function protocol here.
(DEFFLAVOR BIDIRECTIONAL-STREAM () (INPUT-STREAM OUTPUT-STREAM))

(DEFMETHOD (:DIRECTION BIDIRECTIONAL-STREAM) () ':BIDIRECTIONAL)

;;; Character Streams

(DEFFLAVOR CHARACTER-STREAM () (STREAM))

(DEFMETHOD (:CHARACTERS CHARACTER-STREAM) () T)

(DEFMETHOD (:ELEMENT-TYPE CHARACTER-STREAM) () 'CHARACTER)

(DEFFLAVOR STRING-CHAR-STREAM () (CHARACTER-STREAM))	;to avoid breaking old typep

(DEFMETHOD (:CHARACTERS STRING-CHAR-STREAM) () T)

(DEFMETHOD (:ELEMENT-TYPE STRING-CHAR-STREAM) () 'CL:STRING-CHAR)


;;; Binary streams, 8 and 16-bit unsigned

(DEFFLAVOR BINARY-STREAM () (STREAM))

(DEFMETHOD (:CHARACTERS BINARY-STREAM) ()
  NIL)

(DEFMETHOD (:ELEMENT-TYPE BINARY-STREAM) ()
  (LET ((BS (SEND-IF-HANDLES SELF :BYTE-SIZE)))
    (IF BS `(CL:UNSIGNED-BYTE ,BS)
	`CL:UNSIGNED-BYTE)))

(DEFFLAVOR UNSIGNED-BYTE-8-STREAM ()
	   (BINARY-STREAM))

(DEFMETHOD (:ELEMENT-TYPE UNSIGNED-BYTE-8-STREAM) ()
  '(CL:UNSIGNED-BYTE 8))

(DEFMETHOD (:BYTE-SIZE UNSIGNED-BYTE-8-STREAM) ()
  8.)

(DEFFLAVOR UNSIGNED-BYTE-16-STREAM () (BINARY-STREAM))

(DEFMETHOD (:ELEMENT-TYPE UNSIGNED-BYTE-16-STREAM) ()
  '(CL:UNSIGNED-BYTE 16.))

(DEFMETHOD (:BYTE-SIZE UNSIGNED-BYTE-16-STREAM) ()
  16.)



;; Obsolete message names

(DEFMETHOD (:CLEAR-SCREEN OUTPUT-STREAM :DEFAULT) (&OPTIONAL MARGINS-P)
  (SEND SELF :CLEAR-WINDOW MARGINS-P))

(COMPILER:MAKE-MESSAGE-OBSOLETE :CLEAR-SCREEN
				"use the :CLEAR-WINDOW message instead")

(DEFMETHOD (:CLEAR-EOL OUTPUT-STREAM :DEFAULT) ()
  (SEND SELF :CLEAR-REST-OF-LINE))

(COMPILER:MAKE-MESSAGE-OBSOLETE :CLEAR-EOL
				"use the :CLEAR-REST-OF-LINE message instead")



;;; Things to mix in for unbuffered streams.

;;; Pointer Remembering

(DEFFLAVOR UNBUFFERED-INPUT-POINTER-REMEMBERING-MIXIN
	((INPUT-POINTER-BASE 0))
	()
  :ABSTRACT-FLAVOR
  (:REQUIRED-FLAVORS INPUT-STREAM)
  (:REQUIRED-METHODS :SET-BUFFER-POINTER))

(DEFMETHOD (:READ-POINTER UNBUFFERED-INPUT-POINTER-REMEMBERING-MIXIN) ()
  INPUT-POINTER-BASE)

(DEFMETHOD (:SET-POINTER UNBUFFERED-INPUT-POINTER-REMEMBERING-MIXIN) (POSITION)
  (UNLESS (= POSITION INPUT-POINTER-BASE)
    (SEND SELF :SET-BUFFER-POINTER POSITION)
    (SETQ INPUT-POINTER-BASE POSITION))
  INPUT-POINTER-BASE)

(DEFMETHOD (:TYI UNBUFFERED-INPUT-POINTER-REMEMBERING-MIXIN :AFTER) (&OPTIONAL IGNORE)
  (INCF INPUT-POINTER-BASE))

(DEFMETHOD (:UNTYI UNBUFFERED-INPUT-POINTER-REMEMBERING-MIXIN :AFTER) (IGNORE)
  (DECF INPUT-POINTER-BASE))

(DEFMETHOD (:READ-LOCATION UNBUFFERED-INPUT-POINTER-REMEMBERING-MIXIN) ()
  (SEND SELF :READ-POINTER))

(DEFMETHOD (:SET-LOCATION UNBUFFERED-INPUT-POINTER-REMEMBERING-MIXIN) (POSITION)
  (SEND SELF :SET-POINTER POSITION))
;;;

(DEFFLAVOR UNBUFFERED-OUTPUT-POINTER-REMEMBERING-MIXIN
	((OUTPUT-POINTER-BASE 0))
	()
  :ABSTRACT-FLAVOR
  (:REQUIRED-FLAVORS OUTPUT-STREAM)
  (:REQUIRED-METHODS :TYO))

(DEFMETHOD (:READ-POINTER UNBUFFERED-OUTPUT-POINTER-REMEMBERING-MIXIN) ()
  OUTPUT-POINTER-BASE)

(DEFMETHOD (:TYO UNBUFFERED-OUTPUT-POINTER-REMEMBERING-MIXIN :AFTER) (IGNORE &OPTIONAL IGNORE)
  (INCF OUTPUT-POINTER-BASE))

;;; Character Streams

(DEFFLAVOR UNBUFFERED-LINE-INPUT-MIXIN () ()
  :ABSTRACT-FLAVOR
  (:REQUIRED-FLAVORS CHARACTER-STREAM INPUT-STREAM))

(DEFMETHOD (:LINE-IN UNBUFFERED-LINE-INPUT-MIXIN) (&OPTIONAL LEADER)
  (DECLARE (VALUES LINE EOF-P))
  (LET ((LENGTH-SO-FAR 0)
	(LINE NIL))
    (LOOP FOR CH = (SEND SELF ':TYI)
	  UNTIL (NULL CH)			;i.e. EOF
	  UNTIL (CHAR-EQUAL CH #\CR)
	  DO (IF LINE
		 (WHEN (AND (CHAR-FAT-P CH)
			    (NOT (STRING-FAT-P LINE)))
		   (LET ((NEW-LINE (MAKE-ARRAY (ARRAY-LENGTH LINE) :TYPE 'ART-FAT-STRING
					       :LEADER-LENGTH (AND (NUMBERP LEADER) LEADER))))
		     (COPY-ARRAY-PORTION LINE 0 LENGTH-SO-FAR NEW-LINE 0 LENGTH-SO-FAR)
		     (SETQ LINE NEW-LINE)))
		 (SETF LINE (MAKE-ARRAY 80 :TYPE (IF (CHAR-FAT-P CH)
						     'ART-FAT-STRING
						     'ART-STRING)
					:LEADER-LENGTH (AND (NUMBERP LEADER) LEADER))))
	     ;;We have an ordinary character, stick it on the end of the line
	  WHEN ( LENGTH-SO-FAR (ARRAY-LENGTH LINE))
	    DO (SETQ LINE (ADJUST-ARRAY-SIZE LINE (CEILING (* LENGTH-SO-FAR 3\2))))
	  DO (SETF (AREF LINE (PROG1 LENGTH-SO-FAR (INCF LENGTH-SO-FAR))) CH)
	  FINALLY
	    ;;Adjust size and active-length of line
	    (WHEN LINE
	      (ADJUST-ARRAY-SIZE LINE LENGTH-SO-FAR)
	      (WHEN (ARRAY-HAS-LEADER-P LINE)
		(SETF (FILL-POINTER LINE) LENGTH-SO-FAR)))
	    (RETURN (VALUES LINE (NULL CH))))))

(DEFMETHOD (:STRING-LINE-IN UNBUFFERED-LINE-INPUT-MIXIN)
	   (EOF LINE &OPTIONAL (START 0) END)
  (DECLARE (VALUES LENGTH-SO-FAR EOF-P MORE-ON-LINE-P))
  ;; Default the END argument in the usual fashion
  ;; Use length rather than active-length, of course, since we're storing into the string
  (LET ((LINE LINE))
    (DECLARE (ARRAY-REGISTER LINE))
    (WHEN (NULL END)
      (SETQ END (ARRAY-LENGTH LINE)))
    (LOOP WITH LENGTH-SO-FAR = START
	  WITH LEADER-P = (ARRAY-HAS-LEADER-P LINE)
	  WHEN ( LENGTH-SO-FAR END)
	    DO (LET ((NEW-CH (SEND SELF ':TYI)))
		 (UNLESS (OR (NULL NEW-CH) (CHAR= NEW-CH #\CR))
		   (SEND SELF ':UNTYI NEW-CH))
		 (IF LEADER-P (SETF (FILL-POINTER LINE) LENGTH-SO-FAR))
		 (RETURN (VALUES LENGTH-SO-FAR (NULL NEW-CH) (AND NEW-CH
								  (CHAR NEW-CH #\CR)))))
	  AS CH = (SEND SELF ':TYI)
	  WHEN (NULL CH)			;if got eof
	    DO (AND EOF (ERROR 'END-OF-FILE ':STREAM SELF ':FORMAT-STRING EOF))
	       (IF LEADER-P (SETF (FILL-POINTER LINE) LENGTH-SO-FAR))
	       (RETURN (VALUES LENGTH-SO-FAR T NIL))
	  WHEN (CHAR= CH #\CR)
	    DO (IF LEADER-P (SETF (FILL-POINTER LINE) LENGTH-SO-FAR))
	       (RETURN (VALUES LENGTH-SO-FAR NIL NIL))
	  DO (SETF (AREF LINE LENGTH-SO-FAR) CH)
	     (INCF LENGTH-SO-FAR))))

(DEFFLAVOR UNBUFFERED-LINE-INPUT-STREAM ()
	   (UNBUFFERED-LINE-INPUT-MIXIN CHARACTER-STREAM INPUT-STREAM)
  (:DOCUMENTATION :COMBINATION "Input stream with :LINE-IN but no buffering.
Used with input streams which only support :TYI."))

;;;

(DEFFLAVOR LINE-OUTPUT-STREAM-MIXIN () ()
  (:REQUIRED-METHODS :STRING-OUT)
  (:REQUIRED-FLAVORS CHARACTER-STREAM OUTPUT-STREAM)
  (:DOCUMENTATION :MIXIN "Output stream with :LINE-OUT.
Used for buffered and unbuffered streams."))

(DEFMETHOD (:LINE-OUT LINE-OUTPUT-STREAM-MIXIN) (LINE &OPTIONAL (START 0) END)
  (SEND SELF ':STRING-OUT LINE START END)
  (SEND SELF ':TYO #\CR))

(DEFMETHOD (:FRESH-LINE LINE-OUTPUT-STREAM-MIXIN :DEFAULT) ()
  (SEND SELF ':TYO #\CR)
  T)

;;; ASCII Translation

;;; Unbuffered ASCII -> LM

(DEFFLAVOR ASCII-TRANSLATING-INPUT-STREAM-MIXIN ((CR-FLAG)) ()
  :ABSTRACT-FLAVOR
  (:REQUIRED-FLAVORS CHARACTER-STREAM INPUT-STREAM)
  (:REQUIRED-METHODS :TYI :UNTYI)
  (:DOCUMENTATION :MIXIN "An input stream that translates characters from ASCII into Lisp Machine character set for :TYI method."))

(DEFWHOPPER (:TYI ASCII-TRANSLATING-INPUT-STREAM-MIXIN) (&OPTIONAL EOF)
  (LET ((CH (CONTINUE-WHOPPER EOF)))
    (WHEN (AND CH
	       (PROG1 CR-FLAG (SETF CR-FLAG NIL))
	       (= CH #O012))
      (SETF CH (CONTINUE-WHOPPER EOF)))
    (WHEN CH
      (WHEN (= CH #O015)
	(SETF CR-FLAG T))
      (ASCII-TO-CHAR CH))))

(DEFWHOPPER (:TYI-NO-HANG ASCII-TRANSLATING-INPUT-STREAM-MIXIN) (&OPTIONAL EOF)
  (LET ((CH (CONTINUE-WHOPPER EOF)))
    (WHEN (AND CH
	       (PROG1 CR-FLAG (SETF CR-FLAG NIL))
	       (= CH #O012))
      (SETF CH (CONTINUE-WHOPPER EOF)))
    (WHEN CH
      (WHEN (= CH #O015)
	(SETF CR-FLAG T))
      (ASCII-TO-CHAR CH))))

(DEFWHOPPER (:TYIPEEK ASCII-TRANSLATING-INPUT-STREAM-MIXIN) (&OPTIONAL EOF)
  (IF CR-FLAG
      (LET ((TEM (SEND SELF :TYI EOF)))
	(WHEN TEM (SEND SELF :UNTYI TEM))
	TEM)
      (LET ((CH (CONTINUE-WHOPPER EOF)))
	(WHEN CH
	  (ASCII-TO-CHAR CH)))))

(DEFWHOPPER (:UNTYI ASCII-TRANSLATING-INPUT-STREAM-MIXIN) (CH)
  (CONTINUE-WHOPPER (CHAR-TO-ASCII CH)))

(DEFWHOPPER (:LISTEN ASCII-TRANSLATING-INPUT-STREAM-MIXIN) ()
  (AND (CONTINUE-WHOPPER)
       (OR (NOT CR-FLAG)
	   (PROGN (SETF CR-FLAG NIL)
		  (LET ((CH (SEND SELF :TYI)))
		    (IF (CHAR= CH #\LINE)
			(CONTINUE-WHOPPER)
			(PROGN (SEND SELF :UNTYI CH)
			       T)))))))

;;; Unbuffered LM -> ASCII

(DEFFLAVOR ASCII-TRANSLATING-OUTPUT-STREAM-MIXIN () ()
  :ABSTRACT-FLAVOR
  (:REQUIRED-FLAVORS CHARACTER-STREAM OUTPUT-STREAM)
  (:REQUIRED-METHODS :TYO)
  (:DOCUMENTATION :MIXIN "An output stream that translates characters from Lisp Machine character set into ASCII for :TYO method."))

(DEFWHOPPER (:TYO ASCII-TRANSLATING-OUTPUT-STREAM-MIXIN) (CH)
  (COND ((CHAR= CH #\CR)
	 (CONTINUE-WHOPPER #O015)
	 (CONTINUE-WHOPPER #O012))
	(T (CONTINUE-WHOPPER (CHAR-TO-ASCII CH)))))



;;; Buffered streams

(DEFFLAVOR BASIC-BUFFERED-INPUT-STREAM
	((STREAM-INPUT-BUFFER NIL)
	 (STREAM-INPUT-INDEX NIL)
	 STREAM-INPUT-LIMIT)
	(INPUT-STREAM)
  :GETTABLE-INSTANCE-VARIABLES
  (:REQUIRED-METHODS :NEXT-INPUT-BUFFER :DISCARD-INPUT-BUFFER :INPUT-WAIT)
  (:DOCUMENTATION :COMBINATION
   "Input stream with a buffer.  Defines :TYI, :TYI-NO-HANG, and :UNTYI methods.
Requires the method :NEXT-INPUT-BUFFER, which takes a NO-HANG-P argument.  If input is
immediately available, then an array, a starting index, and an ending index are returned.  If
no input is available or the stream is at EOF, then those three values are NIL.  If the stream
is at EOF, then a fourth value of T is returned.  The method :DISCARD-INPUT-BUFFER is also
required.  It takes the array back and throws it away someplace."))

;;; Returns non-NIL if any usable input was to be found.
(DEFMETHOD (:SETUP-NEXT-INPUT-BUFFER BASIC-BUFFERED-INPUT-STREAM) (NO-HANG-P EOF &AUX AT-EOF)
  (LOOP DOING
	(SEND SELF ':DISCARD-CURRENT-INPUT-BUFFER)
	(MULTIPLE-VALUE (STREAM-INPUT-BUFFER STREAM-INPUT-INDEX STREAM-INPUT-LIMIT AT-EOF)
	  (SEND SELF ':NEXT-INPUT-BUFFER NO-HANG-P))
	WHEN (AND (NULL STREAM-INPUT-BUFFER) EOF (OR AT-EOF (NOT NO-HANG-P)))
	DO (ERROR 'END-OF-FILE ':STREAM SELF ':FORMAT-STRING EOF)
	WHILE (AND STREAM-INPUT-BUFFER
		   ( STREAM-INPUT-INDEX STREAM-INPUT-LIMIT)
		   (NOT AT-EOF)))
  (VALUES STREAM-INPUT-BUFFER AT-EOF))

(DEFMETHOD (:DISCARD-CURRENT-INPUT-BUFFER BASIC-BUFFERED-INPUT-STREAM) ()
  (COND (STREAM-INPUT-BUFFER
	 ;; Pretend that the index has reached the end, so that input remembering will work.
	 (SETQ STREAM-INPUT-INDEX STREAM-INPUT-LIMIT)
	 (SEND SELF ':DISCARD-INPUT-BUFFER
	       (PROG1 STREAM-INPUT-BUFFER (SETQ STREAM-INPUT-BUFFER NIL))))))

(DEFMETHOD (:TYI BASIC-BUFFERED-INPUT-STREAM) (&OPTIONAL EOF)
  (UNLESS (AND STREAM-INPUT-BUFFER (< STREAM-INPUT-INDEX STREAM-INPUT-LIMIT))
    (SEND SELF :SETUP-NEXT-INPUT-BUFFER NIL EOF))
  (WHEN STREAM-INPUT-BUFFER
    (PROG1 (AREF STREAM-INPUT-BUFFER STREAM-INPUT-INDEX)
	   (INCF STREAM-INPUT-INDEX))))

(DEFMETHOD (:TYI-NO-HANG BASIC-BUFFERED-INPUT-STREAM) (&OPTIONAL EOF)
  (UNLESS (AND STREAM-INPUT-BUFFER (< STREAM-INPUT-INDEX STREAM-INPUT-LIMIT))
    (SEND SELF :SETUP-NEXT-INPUT-BUFFER T (OR EOF T)))
  (WHEN STREAM-INPUT-BUFFER
    (PROG1 (AREF STREAM-INPUT-BUFFER STREAM-INPUT-INDEX)
	   (INCF STREAM-INPUT-INDEX))))

(DEFMETHOD (:TYIPEEK BASIC-BUFFERED-INPUT-STREAM) (&OPTIONAL EOF)
  (UNLESS (AND STREAM-INPUT-BUFFER (< STREAM-INPUT-INDEX STREAM-INPUT-LIMIT))
    (SEND SELF :SETUP-NEXT-INPUT-BUFFER NIL EOF))
  (WHEN STREAM-INPUT-BUFFER
    (AREF STREAM-INPUT-BUFFER STREAM-INPUT-INDEX)))

(DEFMETHOD (:UNTYI BASIC-BUFFERED-INPUT-STREAM) (CH)
  (IF (AND STREAM-INPUT-BUFFER
	   (> STREAM-INPUT-INDEX 0)
	   (EQL (AREF STREAM-INPUT-BUFFER (1- STREAM-INPUT-INDEX)) CH))
      (DECF STREAM-INPUT-INDEX)
      (FERROR "Attempt to :UNTYI something different than last :TYI'ed.")))

(DEFWHOPPER (:LISTEN BASIC-BUFFERED-INPUT-STREAM) ()
  (BLOCK BASIC-BUFFERED-INPUT-STREAM-LISTEN
    (WHEN STREAM-INPUT-BUFFER
      (IF (< STREAM-INPUT-INDEX STREAM-INPUT-LIMIT)
	  (RETURN-FROM BASIC-BUFFERED-INPUT-STREAM-LISTEN T)
	  ;; discard the input buffer so the :LISTEN method doesn't have
	  ;; to do this same check.
	  (SEND SELF :DISCARD-CURRENT-INPUT-BUFFER)))
    (CONTINUE-WHOPPER)))

;; Part of the contract of :LISTEN is never to signal errors, since it is often sent from
;; inside of wait functions.  This method catches all errors so that they will happen in the
;; user process rather than in the scheduler.  Input stream implementations should provide
;; their own :LISTEN method, rather than using this one.

(DEFMETHOD (:LISTEN BASIC-BUFFERED-INPUT-STREAM :DEFAULT) ()
  (CONDITION-CASE ()
      (MULTIPLE-VALUE-BIND (BUFFER AT-EOF)
	  (SEND SELF :SETUP-NEXT-INPUT-BUFFER T NIL)
	(OR (NOT (NULL BUFFER)) AT-EOF))
    (ERROR T)))

(DEFWHOPPER (:INPUT-WAIT BASIC-BUFFERED-INPUT-STREAM)
	    (&OPTIONAL WHOSTATE FUNCTION &REST ARGUMENTS)
  (UNLESS (AND STREAM-INPUT-BUFFER
	       (< STREAM-INPUT-INDEX STREAM-INPUT-LIMIT))
    ;; Discard the input buffer so the :LISTEN method doesn't have to do this same check.
    (WHEN STREAM-INPUT-BUFFER
      (SEND SELF :DISCARD-CURRENT-INPUT-BUFFER))
    (LOOP DO (LEXPR-CONTINUE-WHOPPER WHOSTATE FUNCTION ARGUMENTS)
	  UNTIL (OR (AND FUNCTION (APPLY FUNCTION ARGUMENTS))
		    (AND STREAM-INPUT-BUFFER
			 (< STREAM-INPUT-INDEX STREAM-INPUT-LIMIT))
		    (MULTIPLE-VALUE-BIND (BUFFER AT-EOF)
			(SEND SELF :SETUP-NEXT-INPUT-BUFFER T NIL)
		      (OR BUFFER AT-EOF))))))

(DEFWHOPPER (STREAM-INPUT-BLOCK BASIC-BUFFERED-INPUT-STREAM)
	    (&OPTIONAL WHOSTATE FUNCTION &REST ARGUMENTS)
  (UNLESS (AND STREAM-INPUT-BUFFER
	       (< STREAM-INPUT-INDEX STREAM-INPUT-LIMIT))
    ;; Discard the input buffer so the :LISTEN method doesn't have to do this same check.
    (WHEN STREAM-INPUT-BUFFER
      (SEND SELF :DISCARD-CURRENT-INPUT-BUFFER))
    (LOOP DO (LEXPR-CONTINUE-WHOPPER WHOSTATE FUNCTION ARGUMENTS)
	  UNTIL (OR (AND FUNCTION (APPLY FUNCTION ARGUMENTS))
		    (AND STREAM-INPUT-BUFFER
			 (< STREAM-INPUT-INDEX STREAM-INPUT-LIMIT))
		    (MULTIPLE-VALUE-BIND (BUFFER AT-EOF)
			(SEND SELF :SETUP-NEXT-INPUT-BUFFER T NIL)
		      (OR BUFFER AT-EOF))))))

(DEFMETHOD (:CLEAR-INPUT BASIC-BUFFERED-INPUT-STREAM) ()
  (LOOP WHILE (SEND SELF :SETUP-NEXT-INPUT-BUFFER T NIL)))

(DEFMETHOD (:READ-UNTIL-EOF BASIC-BUFFERED-INPUT-STREAM) ()
  (LOOP WHILE (SEND SELF :SETUP-NEXT-INPUT-BUFFER NIL NIL)))

(DEFMETHOD (:CLOSE BASIC-BUFFERED-INPUT-STREAM :BEFORE) (&OPTIONAL IGNORE)
  (SEND SELF ':DISCARD-CURRENT-INPUT-BUFFER))

(DEFMETHOD (:CLOSE-WITH-REASON BASIC-BUFFERED-INPUT-STREAM :BEFORE) (IGNORE &OPTIONAL IGNORE)
  (SEND SELF ':DISCARD-CURRENT-INPUT-BUFFER))

;;;

(DEFFLAVOR BUFFERED-INPUT-STREAM () (BASIC-BUFFERED-INPUT-STREAM)
  (:DOCUMENTATION :COMBINATION "Buffered input stream with :READ-INPUT-BUFFER.
Used for all buffered input streams for which :TYI doesn't have wrappers to do
translation or such."))

;;; This next flavor exists so that binary-only methods can be hung off of it.
(DEFFLAVOR BUFFERED-INPUT-BINARY-STREAM () (BUFFERED-INPUT-STREAM BINARY-STREAM)
  (:DOCUMENTATION :COMBINATION "Buffered input stream with :READ-INPUT-BUFFER.
Used for all buffered input streams for which :TYI doesn't have wrappers to do
translation or such."))

(DEFMETHOD (:GET-INPUT-BUFFER BUFFERED-INPUT-STREAM) (&OPTIONAL EOF)
  (UNLESS (AND STREAM-INPUT-BUFFER (< STREAM-INPUT-INDEX STREAM-INPUT-LIMIT))
    (SEND SELF :SETUP-NEXT-INPUT-BUFFER NIL EOF))
  (VALUES STREAM-INPUT-BUFFER STREAM-INPUT-INDEX 
	  (AND STREAM-INPUT-INDEX
	       (- STREAM-INPUT-LIMIT STREAM-INPUT-INDEX))))

(DEFMETHOD (:READ-INPUT-BUFFER BUFFERED-INPUT-STREAM) (&OPTIONAL EOF NO-HANG-P)
  (UNLESS (AND STREAM-INPUT-BUFFER (< STREAM-INPUT-INDEX STREAM-INPUT-LIMIT))
    (SEND SELF :SETUP-NEXT-INPUT-BUFFER NO-HANG-P EOF))
  (VALUES STREAM-INPUT-BUFFER STREAM-INPUT-INDEX STREAM-INPUT-LIMIT))

(DEFMETHOD (:STRING-IN BUFFERED-INPUT-STREAM) (EOF STRING &OPTIONAL (START 0) END)
  (DECLARE (VALUES LEN EOF-P))
  ;; Default the END argument in the usual fashion
  ;; Use length rather than active-length, of course, since we're storing into the string
  (WHEN (NULL END)
    (SETQ END (ARRAY-LENGTH STRING)))
  (LOOP WITH POS = START
	WHILE (< POS END)
	UNLESS (AND STREAM-INPUT-BUFFER (< STREAM-INPUT-INDEX STREAM-INPUT-LIMIT))
	DO (SEND SELF :SETUP-NEXT-INPUT-BUFFER NIL EOF)
	WHILE STREAM-INPUT-BUFFER
	AS AMT = (MIN (- END POS) (- STREAM-INPUT-LIMIT STREAM-INPUT-INDEX))
	DO (COPY-ARRAY-PORTION STREAM-INPUT-BUFFER STREAM-INPUT-INDEX
			       (INCF STREAM-INPUT-INDEX AMT)
			       STRING POS (INCF POS AMT))
	FINALLY (WHEN (ARRAY-HAS-LEADER-P STRING)
		  (SETF (FILL-POINTER STRING) POS))
	(RETURN (VALUES POS (NULL STREAM-INPUT-BUFFER)))))

(DEFMETHOD (:ADVANCE-INPUT-BUFFER BUFFERED-INPUT-STREAM) (&OPTIONAL NEW-INDEX)
  (COND (NEW-INDEX
	 (OR (AND ( NEW-INDEX 0)
		  ( NEW-INDEX STREAM-INPUT-LIMIT))
	     (FERROR "New index out of range"))
	 (SETQ STREAM-INPUT-INDEX NEW-INDEX))
	(T
	 (SEND SELF ':DISCARD-CURRENT-INPUT-BUFFER))))



(DEFFLAVOR BUFFERED-RECORD-INPUT-STREAM-MIXIN
	((AT-EOF))
	()
  (:REQUIRED-FLAVORS BASIC-BUFFERED-INPUT-STREAM))

(DEFWHOPPER (:SETUP-NEXT-INPUT-BUFFER BUFFERED-RECORD-INPUT-STREAM-MIXIN) (NO-HANG-P EOF)
  (IF AT-EOF
      (IF EOF
	  (ERROR 'SYS:END-OF-FILE :STREAM SELF :FORMAT-STRING EOF)
	  (VALUES NIL T))
      (MULTIPLE-VALUE-BIND (BUFFER NEW-AT-EOF)
	  (CONTINUE-WHOPPER NO-HANG-P NIL)
	(SETF AT-EOF NEW-AT-EOF)
	(WHEN (AND (NULL BUFFER) NEW-AT-EOF)
	  (ERROR 'END-OF-RECORD-FILE :STREAM SELF))
	(VALUES BUFFER NEW-AT-EOF))))

(DEFMETHOD (:DISCARD-CURRENT-RECORD BUFFERED-RECORD-INPUT-STREAM-MIXIN) ()
  (UNLESS AT-EOF
    (SEND SELF :READ-UNTIL-EOF))
  (SETF AT-EOF NIL))



(DEFFLAVOR BASIC-BUFFERED-OUTPUT-STREAM
	((STREAM-OUTPUT-BUFFER NIL)
	 (STREAM-OUTPUT-INDEX NIL)
	 STREAM-OUTPUT-LIMIT)
	(OUTPUT-STREAM)
  (:GETTABLE-INSTANCE-VARIABLES STREAM-OUTPUT-BUFFER STREAM-OUTPUT-INDEX STREAM-OUTPUT-LIMIT)
  (:REQUIRED-METHODS :NEW-OUTPUT-BUFFER :SEND-OUTPUT-BUFFER :DISCARD-OUTPUT-BUFFER)
  (:DOCUMENTATION :COMBINATION "Output stream with a buffer.  Only gives a :TYO method.
Required methods are :NEW-OUTPUT-BUFFER, which returns three values, an array, starting index,
and ending index into which characters can be stuffed.  And :SEND-OUTPUT-BUFFER takes the
array and the ending output index reached, and transmit to the particular device.
:DISCARD-OUTPUT-BUFFER takes the array and should forget about sending the buffered data."))

(DEFMETHOD (:SETUP-NEW-OUTPUT-BUFFER BASIC-BUFFERED-OUTPUT-STREAM) ()
  (SEND SELF ':SEND-CURRENT-OUTPUT-BUFFER NIL)
  (MULTIPLE-VALUE (STREAM-OUTPUT-BUFFER STREAM-OUTPUT-INDEX STREAM-OUTPUT-LIMIT)
    (SEND SELF ':NEW-OUTPUT-BUFFER)))

(DEFMETHOD (:SEND-CURRENT-OUTPUT-BUFFER BASIC-BUFFERED-OUTPUT-STREAM) (EXPLICIT)
  (WHEN STREAM-OUTPUT-BUFFER
    (SEND SELF ':SEND-OUTPUT-BUFFER
	  ;; If aborted out of write, prefer losing data to
	  ;; getting links circular.
	  (PROG1 STREAM-OUTPUT-BUFFER (SETQ STREAM-OUTPUT-BUFFER NIL))
	  STREAM-OUTPUT-INDEX EXPLICIT)))

(DEFMETHOD (:DISCARD-CURRENT-OUTPUT-BUFFER BASIC-BUFFERED-OUTPUT-STREAM) ()
  (WHEN STREAM-OUTPUT-BUFFER
    (SEND SELF ':DISCARD-OUTPUT-BUFFER (PROG1 STREAM-OUTPUT-BUFFER
					      (SETQ STREAM-OUTPUT-BUFFER NIL)))))

(DEFMETHOD (:TYO BASIC-BUFFERED-OUTPUT-STREAM) (CH)
  (LOOP UNTIL (AND STREAM-OUTPUT-BUFFER
		   (< STREAM-OUTPUT-INDEX STREAM-OUTPUT-LIMIT))
	DO (SEND SELF ':SETUP-NEW-OUTPUT-BUFFER)
	FINALLY (SETF (AREF STREAM-OUTPUT-BUFFER STREAM-OUTPUT-INDEX) CH)
		(INCF STREAM-OUTPUT-INDEX)))

(DEFMETHOD (:CLEAR-OUTPUT BASIC-BUFFERED-OUTPUT-STREAM :BEFORE) ()
  (SEND SELF :DISCARD-CURRENT-OUTPUT-BUFFER))

(DEFMETHOD (:FORCE-OUTPUT BASIC-BUFFERED-OUTPUT-STREAM) ()
  (SEND SELF ':SEND-CURRENT-OUTPUT-BUFFER T))

(DEFMETHOD (:CLOSE BASIC-BUFFERED-OUTPUT-STREAM :BEFORE) (&OPTIONAL ABORTP)
  (IF ABORTP
      (SEND SELF ':DISCARD-CURRENT-OUTPUT-BUFFER)
      (SEND SELF ':SEND-CURRENT-OUTPUT-BUFFER T)))

(DEFMETHOD (:CLOSE-WITH-REASON BASIC-BUFFERED-OUTPUT-STREAM :BEFORE) (IGNORE &OPTIONAL ABORTP)
  (IF ABORTP
      (SEND SELF ':DISCARD-CURRENT-OUTPUT-BUFFER)
      (SEND SELF ':SEND-CURRENT-OUTPUT-BUFFER T)))

;;;

(DEFFLAVOR BUFFERED-OUTPUT-STREAM
	()
	(BUFFERED-FAST-STRING-OUT-MIXIN BASIC-BUFFERED-OUTPUT-STREAM)
  (:DOCUMENTATION :COMBINATION "Buffered output stream with :STRING-OUT.
Should be used for all output streams which do not have wrappers on :TYO to do translation
or such like."))

(DEFFLAVOR BUFFERED-OUTPUT-BINARY-STREAM
	()
	(BUFFERED-OUTPUT-STREAM BINARY-STREAM)
  (:DOCUMENTATION :COMBINATION "Buffered output stream with :STRING-OUT.
Should be used for all output streams which do not have wrappers on :TYO to do translation
or such like."))

;;;

(DEFFLAVOR UNSIGNED-BYTE-8-WITH-CHARACTER-OUTPUT-MIXIN
	((BINARY-STREAM-CHARACTER-STREAM NIL))
	(UNSIGNED-BYTE-8-STREAM)
  (:DOCUMENTATION :MIXIN "This provides the THIN-CHARACTER-STREAM
generic function for a binary stream.  This generic function returns
a stream that one can do thin string output operations to. It translates 
the strings to 8bit bytes and sends them along."))

(DEFGENERIC THIN-CHARACTER-STREAM (BINARY-STREAM)
  (:FUNCTION
    (IF (EQ BINARY-STREAM 'IGNORE)
	'IGNORE
	(OR (AND (INSTANCEP BINARY-STREAM)
		 (FUNCALL (FLAVOR:GENERIC THIN-CHARACTER-STREAM) BINARY-STREAM))
	    (AND CL:(SUBTYPEP (STREAM-ELEMENT-TYPE SI:BINARY-STREAM) 'CHARACTER)
		 BINARY-STREAM)
	    (AND CL:(SUBTYPEP (STREAM-ELEMENT-TYPE SI:BINARY-STREAM) '(UNSIGNED-BYTE 8))
		 (MAKE-INSTANCE '8BIT-BINARY-STREAM-ASSOCIATED-THIN-CHARACTER-STREAM
				:STREAM BINARY-STREAM))
	    (ERROR "~S does not handle ~S." BINARY-STREAM 'THIN-CHARACTER-STREAM))))
  (:METHOD (STREAM :DEFAULT) NIL))

(DEFMETHOD (THIN-CHARACTER-STREAM UNSIGNED-BYTE-8-WITH-CHARACTER-OUTPUT-MIXIN) ()
  (UNLESS BINARY-STREAM-CHARACTER-STREAM
    (SETQ BINARY-STREAM-CHARACTER-STREAM
	  (MAKE-INSTANCE '8BIT-BINARY-STREAM-ASSOCIATED-THIN-CHARACTER-OUTPUT-STREAM
			 :STREAM SELF)))
  BINARY-STREAM-CHARACTER-STREAM)

(DEFFLAVOR 8BIT-BINARY-STREAM-ASSOCIATED-THIN-CHARACTER-OUTPUT-STREAM
	(STREAM)
	(LINE-OUTPUT-STREAM-MIXIN CHARACTER-STREAM OUTPUT-STREAM)
  (:INITABLE-INSTANCE-VARIABLES STREAM))

(DEFMETHOD (:UNCLAIMED-MESSAGE 8BIT-BINARY-STREAM-ASSOCIATED-THIN-CHARACTER-OUTPUT-STREAM)
	   (MESSAGE &REST ARGS)
  (CL:APPLY STREAM MESSAGE ARGS))

(DEFMETHOD (:FORCE-OUTPUT 8BIT-BINARY-STREAM-ASSOCIATED-THIN-CHARACTER-OUTPUT-STREAM) ()
  (SEND STREAM :FORCE-OUTPUT))

(DEFMETHOD (:STRING-OUT 8BIT-BINARY-STREAM-ASSOCIATED-THIN-CHARACTER-OUTPUT-STREAM)
	   (STRING &OPTIONAL (START 0) END)
  (UNLESS END (SETQ END (ARRAY-ACTIVE-LENGTH STRING)))
  (SYS:WITH-STACK-ARRAY (BINARY-ARRAY (- END START)
				      :TYPE 'ART-8B
				      :DISPLACED-TO STRING
				      :DISPLACED-INDEX-OFFSET START)
    (IF 
      (AND (STRINGP STRING) (STRING-FAT-P STRING))
      ;; we have to thin by force. This needs checks for nonzero character set.
      (LOOP FOR X BEING THE ARRAY-ELEMENTS OF STRING FROM START BELOW END
	    DO (SEND STREAM :TYO (CHAR-CODE X)))
      (SEND STREAM :STRING-OUT BINARY-ARRAY))))

(DEFMETHOD (:TYO 8BIT-BINARY-STREAM-ASSOCIATED-THIN-CHARACTER-OUTPUT-STREAM) (CH)
  (SEND STREAM :TYO (CHAR-CODE CH)))

;;;

(DEFFLAVOR UNSIGNED-BYTE-8-WITH-CHARACTER-INPUT-MIXIN
	((BINARY-STREAM-CHARACTER-STREAM NIL))
	(UNSIGNED-BYTE-8-STREAM)
  (:DOCUMENTATION :MIXIN "This provides the THIN-CHARACTER-STREAM
generic function for a binary stream.  This generic function returns
a stream that one can do thin string input operations to. It translates 
the bytes to thin characters."))

(DEFMETHOD (THIN-CHARACTER-STREAM UNSIGNED-BYTE-8-WITH-CHARACTER-INPUT-MIXIN) ()
  (UNLESS BINARY-STREAM-CHARACTER-STREAM
    (SETQ BINARY-STREAM-CHARACTER-STREAM
	  (MAKE-INSTANCE '8BIT-BINARY-STREAM-ASSOCIATED-THIN-CHARACTER-INPUT-STREAM
			 :STREAM SELF)))
  BINARY-STREAM-CHARACTER-STREAM)

(DEFFLAVOR 8BIT-BINARY-STREAM-ASSOCIATED-THIN-CHARACTER-INPUT-STREAM
	(STREAM)
	(UNBUFFERED-LINE-INPUT-MIXIN CHARACTER-STREAM INPUT-STREAM)
  (:INITABLE-INSTANCE-VARIABLES STREAM)
  (:DOCUMENTATION "Stream that hangs off of a binary stream but will read
characters."))

(DEFMETHOD (:TYI 8BIT-BINARY-STREAM-ASSOCIATED-THIN-CHARACTER-INPUT-STREAM)
	   (&OPTIONAL EOF)
  (LET ((CH (SEND STREAM :TYI EOF)))
    (IF (NUMBERP CH)
	(CODE-CHAR CH)
	CH)))

(DEFMETHOD (:UNTYI 8BIT-BINARY-STREAM-ASSOCIATED-THIN-CHARACTER-INPUT-STREAM) (CH)
  (SEND STREAM :UNTYI (CHAR-CODE CH)))

(DEFMETHOD (:LISTEN 8BIT-BINARY-STREAM-ASSOCIATED-THIN-CHARACTER-INPUT-STREAM) ()
  (SEND STREAM :LISTEN))

(DEFMETHOD (:UNCLAIMED-MESSAGE 8BIT-BINARY-STREAM-ASSOCIATED-THIN-CHARACTER-INPUT-STREAM)
	   (MESSAGE &REST ARGS)
  (CL:APPLY STREAM MESSAGE ARGS))

;;Needs to be explictly provided since FILE-POSITION does :OPERATION-HANDLED-P on it.
(DEFMETHOD (:SET-POINTER 8BIT-BINARY-STREAM-ASSOCIATED-THIN-CHARACTER-INPUT-STREAM) (TO)
  (SEND STREAM :SET-POINTER TO))

;;;--- This commented out code is a non-functional attempt to make both of the 
;;;--- streams be buffered.  It's problem is that the "where are we in the buffer"
;;;--- variables are not shared by the two streams, and they would have to be.
;;;--- I (bim) haven't yet figured out a tolerably clean way to do that, so it
;;;--- ain't done for now.
;
;(DEFMETHOD (:NEXT-INPUT-BUFFER 8BIT-BINARY-STREAM-ASSOCIATED-THIN-CHARACTER-INPUT-STREAM)
;	   (NO-HANG-P)
;  (MULTIPLE-VALUE-BIND (BINARY-BUFFER BINARY-START-X BINARY-END-X)
;      (SEND STREAM :READ-INPUT-BUFFER NIL NO-HANG-P)
;    (COND
;      ((AND (NULL BINARY-BUFFER) (NULL BINARY-START-X)) ; No input available
;       NIL)
;      ((AND (NULL BINARY-BUFFER) BINARY-START-X) ; At EOF
;       (VALUES NIL NIL NIL T))
;      ;; okay, we have data to return.
;      ;; the question is, is it in a form that we can display onto or not?
;      ((= (ARRAY-ELEMENT-SIZE BINARY-BUFFER) (ARRAY-BITS-PER-ELEMENT SYS:ART-STRING))
;       (VALUES
;	 (MAKE-ARRAY (- BINARY-END-X BINARY-START-X) :TYPE SYS:ART-STRING
;		     :DISPLACED-TO BINARY-BUFFER
;		     :DISPLACED-INDEX-OFFSET BINARY-START-X)
;	 0
;	 (- BINARY-END-X BINARY-START-X)))
;      (T ;; too bad, we have to cons
;       (LET ((CHAR-BUFFER 
;	       (MAKE-ARRAY (- BINARY-END-X BINARY-START-X)
;			   :TYPE SYS:ART-STRING)))
;	 (DECLARE (SYS:ARRAY-REGISTER CHAR-BUFFER)
;		  (SYS:ARRAY-REGISTER BINARY-BUFFER))
;	 (LOOP FOR BYTE BEING THE ARRAY-ELEMENTS OF BINARY-BUFFER FROM BINARY-START-X
;	       BELOW BINARY-END-X
;	       FOR CHAR-X FROM 0
;	       DO (SETF (AREF CHAR-BUFFER CHAR-X) (CODE-CHAR BYTE)))
;	 (VALUES CHAR-BUFFER 0 (- BINARY-END-X BINARY-START-X)))))))

;(DEFMETHOD (:DISCARD-INPUT-BUFFER 8BIT-BINARY-STREAM-ASSOCIATED-THIN-CHARACTER-INPUT-STREAM)
;	   (BUFFER)
;  (IGNORE BUFFER)
;  ;; it don't matter which buffer, since only the last one can be outstanding.
;  (SEND STREAM :ADVANCE-INPUT-BUFFER NIL))
;
;(DEFMETHOD (:INPUT-WAIT 8BIT-BINARY-STREAM-ASSOCIATED-THIN-CHARACTER-INPUT-STREAM)
;	   (&REST I-W-ARGS)
;  (CL:APPLY STREAM :INPUT-WAIT I-W-ARGS))

;;;
   ;;; Bidirectional flavor
;;;

(DEFFLAVOR UNSIGNED-BYTE-8-WITH-CHARACTER-IO-MIXIN
	((BINARY-STREAM-CHARACTER-STREAM NIL))
	(UNSIGNED-BYTE-8-STREAM)
  (:DOCUMENTATION :MIXIN "This provides the THIN-CHARACTER-INPUT-STREAM
and THIN-CHARACTER-OUTPUT-STREAM generic function for a binary stream."))

(DEFMETHOD (THIN-CHARACTER-STREAM UNSIGNED-BYTE-8-WITH-CHARACTER-IO-MIXIN) ()
  (UNLESS BINARY-STREAM-CHARACTER-STREAM
    (SETQ BINARY-STREAM-CHARACTER-STREAM
	  (MAKE-INSTANCE '8BIT-BINARY-STREAM-ASSOCIATED-THIN-CHARACTER-STREAM
			 :STREAM SELF)))
  BINARY-STREAM-CHARACTER-STREAM)

(DEFFLAVOR 8BIT-BINARY-STREAM-ASSOCIATED-THIN-CHARACTER-STREAM
	(STREAM)
	(BIDIRECTIONAL-STREAM
	 8BIT-BINARY-STREAM-ASSOCIATED-THIN-CHARACTER-INPUT-STREAM
	 8BIT-BINARY-STREAM-ASSOCIATED-THIN-CHARACTER-OUTPUT-STREAM)
  (:INITABLE-INSTANCE-VARIABLES STREAM))

(COMPILE-FLAVOR-METHODS 
  8BIT-BINARY-STREAM-ASSOCIATED-THIN-CHARACTER-OUTPUT-STREAM
  8BIT-BINARY-STREAM-ASSOCIATED-THIN-CHARACTER-INPUT-STREAM
  8BIT-BINARY-STREAM-ASSOCIATED-THIN-CHARACTER-STREAM)
  
;;;

(DEFFLAVOR BUFFERED-FAST-STRING-OUT-MIXIN () ()
  (:REQUIRED-FLAVORS BASIC-BUFFERED-OUTPUT-STREAM))

(DEFMETHOD (:STRING-OUT BUFFERED-FAST-STRING-OUT-MIXIN) (STRING &OPTIONAL (START 0) END)
  (OR END (SETQ END (ARRAY-ACTIVE-LENGTH STRING)))
  (LOOP WHILE (< START END)
	UNLESS STREAM-OUTPUT-BUFFER
	  DO (SEND SELF ':SETUP-NEW-OUTPUT-BUFFER)
	AS AMT = (MIN (- END START) (- STREAM-OUTPUT-LIMIT STREAM-OUTPUT-INDEX))
	DO (COPY-ARRAY-PORTION STRING START (SETQ START (+ START AMT))
			       STREAM-OUTPUT-BUFFER STREAM-OUTPUT-INDEX
			       (SETQ STREAM-OUTPUT-INDEX (+ STREAM-OUTPUT-INDEX AMT)))
	WHEN (< START END)
	  DO (SEND SELF ':SEND-CURRENT-OUTPUT-BUFFER NIL)))

(DEFMETHOD (:GET-OUTPUT-BUFFER BUFFERED-FAST-STRING-OUT-MIXIN) ()
  (UNLESS (AND STREAM-OUTPUT-BUFFER
	       (< STREAM-OUTPUT-INDEX STREAM-OUTPUT-LIMIT))
    (SEND SELF ':SETUP-NEW-OUTPUT-BUFFER))
  (VALUES STREAM-OUTPUT-BUFFER STREAM-OUTPUT-INDEX STREAM-OUTPUT-LIMIT))

(DEFMETHOD (:ADVANCE-OUTPUT-BUFFER BUFFERED-FAST-STRING-OUT-MIXIN) (&OPTIONAL INDEX)
  (IF (NOT (NULL INDEX))
      (SETQ STREAM-OUTPUT-INDEX INDEX)
      (SETQ STREAM-OUTPUT-INDEX STREAM-OUTPUT-LIMIT)
      (SEND SELF ':SEND-CURRENT-OUTPUT-BUFFER NIL)))




;;; Mixins for remembering where you are in a stream.
;;; These exist in both buffered and unbuffered forms.

;;; Buffered Input

(DEFFLAVOR INPUT-POINTER-REMEMBERING-MIXIN
	((INPUT-POINTER-BASE 0)
	 (STREAM-INPUT-LOWER-LIMIT 0))
	()
  (:REQUIRED-FLAVORS BASIC-BUFFERED-INPUT-STREAM)
  ;; :SET-BUFFER-POINTER is sent when a :SET-POINTER request goes beyond the current buffer.
  ;; It should return the real position set and arrange for the next :NEXT-INPUT-BUFFER
  ;; to contain the desired position in it someplace.
  (:REQUIRED-METHODS :SET-BUFFER-POINTER)
  (:DOCUMENTATION :MIXIN "Buffered input stream with :SET-POINTER and :READ-POINTER methods."
		  ))

(DEFMETHOD (:SET-BUFFER-POINTER INPUT-POINTER-REMEMBERING-MIXIN) (NEW-POINTER)
  (FERROR "Cannot set pointer on ~S to ~D" SELF NEW-POINTER))

;;; Obsolete shorthand message, but in the manual, so keep for a while.
(DEFMETHOD (:REWIND INPUT-POINTER-REMEMBERING-MIXIN) ()
  (SEND SELF ':SET-POINTER 0))

(DEFMETHOD (:SET-POINTER INPUT-POINTER-REMEMBERING-MIXIN) (NEW-POINTER)
  (LOOP AS NEW-RELATIVE-POINTER = (+ (- NEW-POINTER INPUT-POINTER-BASE)
				     STREAM-INPUT-LOWER-LIMIT)
;	for count from 1
	WHEN (AND STREAM-INPUT-INDEX (= NEW-RELATIVE-POINTER STREAM-INPUT-INDEX))
	RETURN T				;Fast check
	UNTIL (IF STREAM-INPUT-BUFFER
		  (AND ( NEW-RELATIVE-POINTER STREAM-INPUT-LOWER-LIMIT)
		       ;;used to be "<" below, this would loop infinitely if you tried
		       ;;to set pointer to the end of a binary file (so you'd get EOF). -- Reti
		       ( NEW-RELATIVE-POINTER STREAM-INPUT-LIMIT))
		  (= NEW-RELATIVE-POINTER STREAM-INPUT-LOWER-LIMIT))
	DO (SEND SELF ':DISCARD-CURRENT-INPUT-BUFFER)
;	   (when (> count 2) (si:dbg))
	   (SETQ INPUT-POINTER-BASE (SEND SELF ':SET-BUFFER-POINTER NEW-POINTER))
	   (SEND SELF ':SETUP-NEXT-INPUT-BUFFER NIL NIL)
	FINALLY (SETQ STREAM-INPUT-INDEX NEW-RELATIVE-POINTER)))

(DEFMETHOD (:DISCARD-CURRENT-INPUT-BUFFER INPUT-POINTER-REMEMBERING-MIXIN :BEFORE) ()
  (WHEN STREAM-INPUT-BUFFER
    (INCF INPUT-POINTER-BASE (- STREAM-INPUT-LIMIT STREAM-INPUT-LOWER-LIMIT))
    (SETQ STREAM-INPUT-LOWER-LIMIT STREAM-INPUT-LIMIT)))

(DEFMETHOD (:SETUP-NEXT-INPUT-BUFFER INPUT-POINTER-REMEMBERING-MIXIN :AFTER)
	   (IGNORE IGNORE)
  (AND STREAM-INPUT-BUFFER
       (SETQ STREAM-INPUT-LOWER-LIMIT STREAM-INPUT-INDEX)))

(DEFMETHOD (:READ-POINTER INPUT-POINTER-REMEMBERING-MIXIN) ()
  (+ INPUT-POINTER-BASE (IF STREAM-INPUT-INDEX
			    (- STREAM-INPUT-INDEX STREAM-INPUT-LOWER-LIMIT)
			    0)))

(DEFMETHOD (:READ-LOCATION INPUT-POINTER-REMEMBERING-MIXIN) ()
  (SEND SELF :READ-POINTER))


(DEFMETHOD (:SET-LOCATION INPUT-POINTER-REMEMBERING-MIXIN) (LOCATION)
  (SEND SELF :SET-POINTER LOCATION))


;;; Buffered Output

(DEFFLAVOR OUTPUT-POINTER-REMEMBERING-MIXIN
	((OUTPUT-POINTER-BASE 0)
	 (STREAM-OUTPUT-LOWER-LIMIT 0))
	()
  (:SETTABLE-INSTANCE-VARIABLES OUTPUT-POINTER-BASE)
  (:REQUIRED-FLAVORS BASIC-BUFFERED-OUTPUT-STREAM)
  (:DOCUMENTATION :MIXIN "Buffered output stream with :READ-POINTER method."))

(DEFMETHOD (:SEND-CURRENT-OUTPUT-BUFFER OUTPUT-POINTER-REMEMBERING-MIXIN :BEFORE)
	   (&REST IGNORE)
  (WHEN STREAM-OUTPUT-BUFFER
    (INCF OUTPUT-POINTER-BASE (- STREAM-OUTPUT-INDEX STREAM-OUTPUT-LOWER-LIMIT))
    (SETQ STREAM-OUTPUT-LOWER-LIMIT STREAM-OUTPUT-INDEX)))

(DEFMETHOD (:SETUP-NEW-OUTPUT-BUFFER OUTPUT-POINTER-REMEMBERING-MIXIN :AFTER) ()
  (SETQ STREAM-OUTPUT-LOWER-LIMIT STREAM-OUTPUT-INDEX))

(DEFMETHOD (:READ-POINTER OUTPUT-POINTER-REMEMBERING-MIXIN) ()
  (+ OUTPUT-POINTER-BASE (IF STREAM-OUTPUT-INDEX
			    (- STREAM-OUTPUT-INDEX STREAM-OUTPUT-LOWER-LIMIT)
			    0)))

;We send a :GET-OLD-DATA (args are buffer and ending index) if it is
;necessary to fill the beginning of the output buffer with the current
;contents of the file in order to avoid clobbering data that we are
;supposed to be skipping over.
(DEFMETHOD (:SET-POINTER OUTPUT-POINTER-REMEMBERING-MIXIN) (NEW-POINTER)
  (DO ((BUFFER-RELOADED NIL T)) (())
    (LET ((NEW-RELATIVE-POINTER (+ (- NEW-POINTER OUTPUT-POINTER-BASE)
				   STREAM-OUTPUT-LOWER-LIMIT)))
      ;; Does the buffer we have now include the desired pointer?
      (IF (IF STREAM-OUTPUT-BUFFER
	      (AND ( NEW-RELATIVE-POINTER STREAM-OUTPUT-LOWER-LIMIT)
		   (< NEW-RELATIVE-POINTER STREAM-OUTPUT-LIMIT))
	    (= NEW-RELATIVE-POINTER STREAM-OUTPUT-LOWER-LIMIT))
	  (PROGN (AND BUFFER-RELOADED
		      ( STREAM-OUTPUT-LOWER-LIMIT NEW-RELATIVE-POINTER)
		      (SEND SELF ':GET-OLD-DATA
			    STREAM-OUTPUT-BUFFER STREAM-OUTPUT-LOWER-LIMIT))
		 (RETURN (SETQ STREAM-OUTPUT-INDEX NEW-RELATIVE-POINTER))))
      ;; No, get another buffer after specifying where in the file we want.
      (SEND SELF ':SEND-CURRENT-OUTPUT-BUFFER NIL)
      (SETQ OUTPUT-POINTER-BASE
	    (SEND SELF ':SET-BUFFER-POINTER NEW-POINTER))
      (SEND SELF ':SETUP-NEW-OUTPUT-BUFFER))))


;;; Mixin to mix with flavors having its required flavors to allow interspersed
;;; input and output operations and pointer reading and setting.

(DEFFLAVOR BIDIRECTIONAL-POINTER-REMEMBERING-MIXIN ()
	   ()
  (:REQUIRED-FLAVORS
   SI:INPUT-POINTER-REMEMBERING-MIXIN
   SI:BUFFERED-INPUT-STREAM
   SI:OUTPUT-POINTER-REMEMBERING-MIXIN
   SI:BUFFERED-OUTPUT-STREAM))

(DEFMETHOD (:NEXT-INPUT-BUFFER BIDIRECTIONAL-POINTER-REMEMBERING-MIXIN :BEFORE) (&REST IGNORE)
  (SEND SELF ':SEND-CURRENT-OUTPUT-BUFFER NIL))

(DEFMETHOD (:NEW-OUTPUT-BUFFER BIDIRECTIONAL-POINTER-REMEMBERING-MIXIN :BEFORE) ()
  (SEND SELF ':DISCARD-CURRENT-INPUT-BUFFER))

(DEFMETHOD (:SET-POINTER BIDIRECTIONAL-POINTER-REMEMBERING-MIXIN :BEFORE) (IGNORE)
  (SEND SELF ':DISCARD-CURRENT-INPUT-BUFFER)
  (SEND SELF ':SEND-CURRENT-OUTPUT-BUFFER NIL))

(DEFMETHOD (:SET-POINTER BIDIRECTIONAL-POINTER-REMEMBERING-MIXIN :AFTER) (VAL)
  (IF (NULL SI:STREAM-INPUT-BUFFER)
      (SEND SELF ':SET-BUFFER-POINTER VAL)))

(DEFWHOPPER (:READ-POINTER BIDIRECTIONAL-POINTER-REMEMBERING-MIXIN) ()
  (IF (AND SI:STREAM-OUTPUT-BUFFER
	   SI:STREAM-INPUT-BUFFER)
      (FERROR "Bidirectional stream ~S has both input and output buffers at :READ-POINTER"
	      SELF))
  (IF SI:STREAM-OUTPUT-BUFFER
      (+ SI:OUTPUT-POINTER-BASE (- SI:STREAM-OUTPUT-INDEX SI:STREAM-OUTPUT-LOWER-LIMIT))
      (CONTINUE-WHOPPER)))



; LINE input and output

; This comes in two different flavors, depending on whether the stream is buffered
; or unbuffered

(DEFFLAVOR BUFFERED-SMART-FRESH-LINE-MIXIN
	((LAST-CHARACTER-OUTPUT #\CR))
	()
  (:REQUIRED-FLAVORS CHARACTER-STREAM BASIC-BUFFERED-OUTPUT-STREAM)
  (:DOCUMENTATION :MIXIN "Provides a smart :FRESH-LINE method that looks at the buffer
to see if there's a nearby carriage return."))

(DEFMETHOD (:SEND-CURRENT-OUTPUT-BUFFER BUFFERED-SMART-FRESH-LINE-MIXIN :BEFORE)
	   (&OPTIONAL IGNORE)
  (WHEN (AND STREAM-OUTPUT-BUFFER (PLUSP STREAM-OUTPUT-INDEX))
    (SETQ LAST-CHARACTER-OUTPUT (AREF STREAM-OUTPUT-BUFFER (1- STREAM-OUTPUT-INDEX)))))

(DEFMETHOD (:FRESH-LINE BUFFERED-SMART-FRESH-LINE-MIXIN) ()
  (UNLESS (CHAR= (IF (AND STREAM-OUTPUT-BUFFER (PLUSP STREAM-OUTPUT-INDEX))
		     (AREF STREAM-OUTPUT-BUFFER (1- STREAM-OUTPUT-INDEX))
		     LAST-CHARACTER-OUTPUT)
		 #\CR)
    (SEND SELF ':TYO #\CR)
    T))

;;;

(DEFFLAVOR BUFFERED-LINE-INPUT-MIXIN () ()
  :ABSTRACT-FLAVOR
  (:REQUIRED-FLAVORS CHARACTER-STREAM BUFFERED-INPUT-STREAM))

(DEFMETHOD (:LINE-IN BUFFERED-LINE-INPUT-MIXIN) (&OPTIONAL LEADER)
  (DECLARE (VALUES LINE EOF-P))
  ;; STRING is not made until needed to avoid calling ADJUST-ARRAY-SIZE except when
  ;; strings cross buffer boundaries.
  (LOOP WITH STRING = NIL
	AND STRING-INDEX = 0
	UNLESS (AND STREAM-INPUT-BUFFER (< STREAM-INPUT-INDEX STREAM-INPUT-LIMIT))
	  UNLESS (SEND SELF :SETUP-NEXT-INPUT-BUFFER NIL NIL)
	    DO (WHEN (NULL STRING)
		 (SETQ STRING (MAKE-ARRAY STRING-INDEX
					  ':TYPE (IF (STRING-FAT-P STREAM-INPUT-BUFFER)
						     'ART-FAT-STRING
						     'ART-STRING)
					  ':LEADER-LENGTH (AND (NUMBERP LEADER) LEADER))))
	       (WHEN (NUMBERP LEADER)
		 (SETF (FILL-POINTER STRING) STRING-INDEX))
	       (RETURN (VALUES STRING T))
	       ;; Now see if this buffer has a CR, and copy out the appropriate amount
	AS CR-INDEX = (%STRING-SEARCH-EXACT-CHAR #\Return STREAM-INPUT-BUFFER
						 STREAM-INPUT-INDEX STREAM-INPUT-LIMIT)
	WITH NEW-STRING-INDEX AND NEW-BUFFER-INDEX
	WHEN (NOT (NULL CR-INDEX))
	  DO (SETQ NEW-BUFFER-INDEX (1+ CR-INDEX)
		   NEW-STRING-INDEX (+ STRING-INDEX (- CR-INDEX STREAM-INPUT-INDEX)))
	ELSE DO (SETQ NEW-BUFFER-INDEX STREAM-INPUT-LIMIT
		      NEW-STRING-INDEX (+ STRING-INDEX
					  (- STREAM-INPUT-LIMIT STREAM-INPUT-INDEX)))
	;; the new buffered epsilon-encapsulating stream implementation
	;; can change buffer flavors (thin -> fat) in the middle of a
	;; line.  Check for that here, and remake our buffer if needed.
	WHEN (AND STRING 
		  (STRING-FAT-P STREAM-INPUT-BUFFER)
		  (NOT (STRING-FAT-P STRING)))
	  ;; Oops.  copy it
	  DO (LET ((NEW-STRING (MAKE-ARRAY NEW-STRING-INDEX ':TYPE 'ART-FAT-STRING
					   ':LEADER-LENGTH (AND (NUMBERP LEADER) LEADER))))
	       (COPY-ARRAY-PORTION STRING 0 STRING-INDEX NEW-STRING 0 STRING-INDEX)
	       (SETQ STRING NEW-STRING))

	WHEN (NULL STRING)
	  ;;Make a string to return or save the end of this packet in.
	  DO (SETQ STRING (MAKE-ARRAY NEW-STRING-INDEX
				      ':TYPE (IF (STRING-FAT-P STREAM-INPUT-BUFFER)
						 'ART-FAT-STRING
						 'ART-STRING)
				      ':LEADER-LENGTH (AND (NUMBERP LEADER) LEADER)))
	     ;;Was some stuff from previous packet, make room.
	ELSE DO (ADJUST-ARRAY-SIZE STRING NEW-STRING-INDEX)
	DO (COPY-ARRAY-PORTION STREAM-INPUT-BUFFER STREAM-INPUT-INDEX NEW-BUFFER-INDEX
			       STRING STRING-INDEX NEW-STRING-INDEX)
	   (SETQ STREAM-INPUT-INDEX NEW-BUFFER-INDEX
		 STRING-INDEX NEW-STRING-INDEX)
	WHEN (NOT (NULL CR-INDEX))		;This buffer is enough to satisfy
	  DO (WHEN (NUMBERP LEADER) (SETF (FILL-POINTER STRING) STRING-INDEX))
	     (RETURN (VALUES STRING NIL))))

;;;
;;; Combine benefits of :line-in and :string-in.
;;; Get a line into an array passed in as an argument, and avoid consing.
;;;
(DEFMETHOD (:STRING-LINE-IN BUFFERED-LINE-INPUT-MIXIN)
	   (EOF LINE &OPTIONAL (START 0) END)
  (DECLARE (VALUES LENGTH-SO-FAR EOF-P MORE-ON-LINE-P))
  ;; Default the END argument in the usual fashion
  ;; Use length rather than active-length, of course, since we're storing into the string
  (WHEN (NULL END)
    (SETQ END (ARRAY-LENGTH LINE)))
  (LOOP WITH LEADER-P = (ARRAY-HAS-LEADER-P LINE)
	WITH STRING-INDEX = START
	UNLESS (AND STREAM-INPUT-BUFFER (< STREAM-INPUT-INDEX STREAM-INPUT-LIMIT))
	UNLESS (SEND SELF :SETUP-NEXT-INPUT-BUFFER NIL EOF)
	DO (WHEN LEADER-P
	     (SETF (FILL-POINTER LINE) STRING-INDEX))
           (RETURN (VALUES STRING-INDEX T NIL))
	;; Now see if this buffer has a CR, and copy out the appropriate amount
	AS CR-INDEX = (%STRING-SEARCH-EXACT-CHAR #\CR STREAM-INPUT-BUFFER STREAM-INPUT-INDEX
						 STREAM-INPUT-LIMIT)
	AS BUFFER-REMAINING = (- END STRING-INDEX)
	WITH LENGTH-REMAINING
	WHEN (NOT (NULL CR-INDEX))
	DO (SETQ LENGTH-REMAINING (- CR-INDEX STREAM-INPUT-INDEX))
	ELSE DO (SETQ LENGTH-REMAINING (- STREAM-INPUT-LIMIT STREAM-INPUT-INDEX))
	AS LENGTH-OF-XFER = (MIN BUFFER-REMAINING LENGTH-REMAINING)
	AS FULL = (> LENGTH-REMAINING BUFFER-REMAINING)
	DO (COPY-ARRAY-PORTION
	     STREAM-INPUT-BUFFER STREAM-INPUT-INDEX (+ STREAM-INPUT-INDEX LENGTH-OF-XFER)
	     LINE STRING-INDEX (+ STRING-INDEX LENGTH-OF-XFER))
	(INCF STREAM-INPUT-INDEX LENGTH-OF-XFER)
	(INCF STRING-INDEX LENGTH-OF-XFER)
	WHEN (NOT (NULL CR-INDEX))
	DO (AND LEADER-P (SETF (FILL-POINTER LINE) STRING-INDEX))
	(IF (NOT FULL) (INCF STREAM-INPUT-INDEX 1))	;skip Carret, since we know its there.
	(RETURN (VALUES STRING-INDEX NIL FULL))
        WHEN FULL				;no carriage return
	DO (AND LEADER-P (SETF (FILL-POINTER LINE) STRING-INDEX))
	(RETURN (VALUES STRING-INDEX NIL T))))

(DEFFLAVOR BUFFERED-LINE-INPUT-STREAM ()
	   (BUFFERED-LINE-INPUT-MIXIN CHARACTER-STREAM BUFFERED-INPUT-STREAM)
  (:DOCUMENTATION :COMBINATION "Input stream with buffering and :LINE-IN."))

;;; Mixins for doing translation between ASCII and the LISP Machine character set.
;;; They are provided in both buffered and unbuffered forms.
;;; As you might expect, the buffered forms are faster.
;;; Make sure you put these in the right place in your flavor definition,
;;; ordering is very important.

;;; Buffered ASCII -> LM

(DEFFLAVOR ASCII-TRANSLATING-BUFFERED-INPUT-STREAM-MIXIN
	((AT-BUFFER)
	 (AT-STRING)
	 AT-START
	 AT-END
	 (AT-CR-FLAG))
	()
  :ABSTRACT-FLAVOR
  (:REQUIRED-FLAVORS CHARACTER-STREAM BUFFERED-INPUT-STREAM))

(DEFWHOPPER (:NEXT-INPUT-BUFFER ASCII-TRANSLATING-BUFFERED-INPUT-STREAM-MIXIN)
	    (&OPTIONAL NO-WAIT-P)
  (WHEN (NULL AT-BUFFER)
    (MULTIPLE-VALUE (AT-BUFFER AT-START AT-END)
      (CONTINUE-WHOPPER NO-WAIT-P))
    (WHEN AT-BUFFER
      (WHEN (NULL AT-STRING)
	;; There presently isn't any way to say :CHARACTERS NIL
	;; :BYTE-SIZE 8.  When fully switched to character
	;; objects, will need to distinguish LISPM character
	;; streams with ART-STRING buffers of characters from
	;; ASCII character streams with ART-8B buffers of
	;; fixnums that get converted to LISPM character objects
	;; inside here.  Until CHAOS and DIAL converted to know
	;; when to use ART-8B, accept ART-STRING here.
	(UNLESS (= 8 (ARRAY-ELEMENT-BYTE-SIZE AT-BUFFER))
	  (FERROR "Underlying buffer has bad element size."))
	(SETF AT-STRING (MAKE-ARRAY 2048. :TYPE 'ART-STRING :DISPLACED-TO AT-BUFFER)))
      (SI:CHANGE-INDIRECT-ARRAY AT-STRING (ARRAY-TYPE AT-STRING) (LIST AT-END)
				AT-BUFFER 0)))
  (WHEN AT-BUFFER
    (WHEN AT-CR-FLAG
      (WHEN (= (AREF AT-BUFFER AT-START) #O012) (INCF AT-START))
      (SETF AT-CR-FLAG NIL))
    (LOOP WITH OLD-START = AT-START
	  WHILE (< AT-START AT-END)
	  FOR CH = (AREF AT-BUFFER AT-START)
	  WHEN (< CH #O040)
	    DO (SETF (AREF AT-STRING AT-START) (ASCII-TO-CHAR CH))
	  DOING
      (INCF AT-START)
      (WHEN (= CH #O015)
	(LET ((USER-END AT-START))
	  (IF (< AT-START AT-END)
	      (WHEN (= (AREF AT-BUFFER AT-START) #O012)
		(INCF AT-START))
	      (SETF AT-CR-FLAG T))
	  (RETURN (VALUES AT-STRING OLD-START USER-END))))
	  FINALLY
	    (RETURN (VALUES AT-STRING OLD-START AT-END)))))

(DEFWHOPPER (:DISCARD-INPUT-BUFFER ASCII-TRANSLATING-BUFFERED-INPUT-STREAM-MIXIN) (IGNORE)
  (UNLESS (< AT-START AT-END)
    (CONTINUE-WHOPPER AT-BUFFER)
    (SETF AT-BUFFER NIL)))

;;; When closing, we want to really discard buffer all the way, advance state past anything
;;; intermediate.  This really doesn't mean that the user hasn't read all the input.  There
;;; may be one character (#o012) and at-cr-flag so that :next-input-buffer wouldn't return
;;; it.
(DEFMETHOD (:CLOSE ASCII-TRANSLATING-BUFFERED-INPUT-STREAM-MIXIN :BEFORE) (&OPTIONAL IGNORE)
  (WHEN AT-BUFFER
    (SETQ AT-START AT-END)
    (SETQ AT-CR-FLAG NIL)))

;;; Note: With a little more state, this could reposition to anyplace inside the current
;;; AT-BUFFER. We don't have that state now.

(DEFMETHOD (:SET-BUFFER-POINTER ASCII-TRANSLATING-BUFFERED-INPUT-STREAM-MIXIN) (IGNORE)
  (ERROR ":SET-POINTER outside of the current buffer is not supported for ~
          ASCII-TRANSLATING-BUFFERED-INPUT-STREAM-MIXIN"))


;;; Some useful combinations

(DEFFLAVOR BUFFERED-INPUT-CHARACTER-STREAM ()
	   (INPUT-POINTER-REMEMBERING-MIXIN BUFFERED-LINE-INPUT-STREAM)
  (:DOCUMENTATION :COMBINATION "A buffered input character stream, gives :LINE-IN."))

(DEFFLAVOR BUFFERED-OUTPUT-CHARACTER-STREAM ()
	   (LINE-OUTPUT-STREAM-MIXIN CHARACTER-STREAM
	    BUFFERED-SMART-FRESH-LINE-MIXIN BUFFERED-OUTPUT-STREAM)
  (:DOCUMENTATION :COMBINATION "A buffered output character stream, gives :LINE-OUT."))

(DEFFLAVOR BUFFERED-CHARACTER-STREAM ()
	   (BIDIRECTIONAL-STREAM
	    BUFFERED-INPUT-CHARACTER-STREAM BUFFERED-OUTPUT-CHARACTER-STREAM)
  (:DOCUMENTATION :COMBINATION "A bidrection character stream, :LINE-IN and :LINE-OUT."))

(DEFFLAVOR BUFFERED-STREAM ()
	   (BIDIRECTIONAL-STREAM BUFFERED-INPUT-STREAM BUFFERED-OUTPUT-STREAM)
  (:DOCUMENTATION :COMBINATION "A bidirection buffered stream."))

(DEFFLAVOR BUFFERED-BINARY-STREAM ()
	   (BIDIRECTIONAL-STREAM BUFFERED-INPUT-BINARY-STREAM BUFFERED-OUTPUT-BINARY-STREAM)
  (:DOCUMENTATION :COMBINATION "A bidirection buffered stream."))

(DEFFLAVOR BUFFERED-TYI-INPUT-STREAM ()
	   (INPUT-POINTER-REMEMBERING-MIXIN UNBUFFERED-LINE-INPUT-MIXIN CHARACTER-STREAM
	    BASIC-BUFFERED-INPUT-STREAM)
  (:DOCUMENTATION :COMBINATION
   "A buffered character input stream for use with :TYI wrappers."))

(DEFFLAVOR BUFFERED-TYO-OUTPUT-STREAM ()
	   (LINE-OUTPUT-STREAM-MIXIN CHARACTER-STREAM BASIC-BUFFERED-OUTPUT-STREAM)
  (:DOCUMENTATION :COMBINATION
   "A buffered character output stream for use with :TYO wrappers."))

(DEFFLAVOR BUFFERED-TYI-TYO-STREAM ()
	   (BIDIRECTIONAL-STREAM BUFFERED-TYI-INPUT-STREAM BUFFERED-TYO-OUTPUT-STREAM)
  (:DOCUMENTATION :COMBINATION
   "A bidirectional buffered character stream, for use with :TYI and :TYO wrappers."))



;;; Flavors for use with file computers

(DEFFLAVOR FUTURE-COMMON-LISP:FILE-STREAM () ()
  :ABSTRACT-FLAVOR)

;;; For use with :PROBE OPEN calls
(DEFFLAVOR FILE-STREAM-MIXIN
	((PATHNAME NIL))
	(FUTURE-COMMON-LISP:FILE-STREAM)
  (:REQUIRED-METHODS :TRUENAME :PLIST)
  (:INITABLE-INSTANCE-VARIABLES PATHNAME)
  (:GETTABLE-INSTANCE-VARIABLES PATHNAME)
  (:DOCUMENTATION :MIXIN "Streams for use with file computers, as returned by OPEN."))

(DEFMETHOD (:PRINT-SELF FILE-STREAM-MIXIN) (STREAM IGNORE IGNORE)
  (SI:PRINTING-RANDOM-OBJECT (SELF STREAM :TYPEP)
    (PRIN1 (STRING PATHNAME) STREAM)))

(DEFMETHOD (:GET FILE-STREAM-MIXIN) (INDICATOR)
  (LET ((PLIST (SEND SELF ':PLIST)))
    (GET (LOCF PLIST) INDICATOR)))

(DEFMETHOD (:CREATION-DATE FILE-STREAM-MIXIN) ()
  (SEND SELF ':GET ':CREATION-DATE))

(DEFMETHOD (:AUTHOR FILE-STREAM-MIXIN) ()
  (SEND SELF ':GET ':AUTHOR))

(DEFMETHOD (:BYTE-SIZE FILE-STREAM-MIXIN) ()
  (SEND SELF ':GET ':BYTE-SIZE))

(DEFMETHOD (:INFO FILE-STREAM-MIXIN) ()
  (CONS (SEND SELF ':TRUENAME) (SEND SELF ':CREATION-DATE)))

(DEFMETHOD (:PROPERTIES FILE-STREAM-MIXIN) ()
  (SEND (SEND SELF ':TRUENAME) ':PROPERTIES))

(DEFMETHOD (:GENERIC-PATHNAME-AND-PLIST FILE-STREAM-MIXIN) (&AUX GENERIC-PATHNAME)
  (VALUES PATHNAME
	  (SEND PATHNAME ':PROPERTY-LIST-LOCATION)
	  (SETQ GENERIC-PATHNAME (SEND PATHNAME ':GENERIC-PATHNAME))
	  (SEND GENERIC-PATHNAME ':PROPERTY-LIST-LOCATION)))

(DEFMETHOD (:CHANGE-PROPERTIES FILE-STREAM-MIXIN :DEFAULT) (&REST ARGS)
  (LEXPR-FUNCALL (SEND SELF ':TRUENAME) ':CHANGE-PROPERTIES ARGS))

;; For streams returned by OPEN.
(DEFFLAVOR FILE-DATA-STREAM-MIXIN
	((FILE-ACCESS-PATH NIL)
	 (TRANSLATED-PATHNAME)
	 (PROCESS SI:CURRENT-PROCESS)
	 (SI:STRING-FOR-WHOLINE ""))
	(FILE-STREAM-MIXIN)
  (:INITABLE-INSTANCE-VARIABLES FILE-ACCESS-PATH PROCESS TRANSLATED-PATHNAME)
  (:GETTABLE-INSTANCE-VARIABLES TRANSLATED-PATHNAME)
  (:SETTABLE-INSTANCE-VARIABLES SI:STRING-FOR-WHOLINE)
  (:WRITABLE-INSTANCE-VARIABLES (FS:FILE-DATA-STREAM-PROCESS PROCESS))
  (:REQUIRED-FLAVORS STREAM)
  (:REQUIRED-METHODS :READ-POINTER :LENGTH)
  (:DOCUMENTATION :MIXIN "Streams which can actually do file I/O."))

(DEFMETHOD (:RENAME FILE-DATA-STREAM-MIXIN :AFTER) (NEW-PATHNAME)
  (SETQ SI:STRING-FOR-WHOLINE (SEND NEW-PATHNAME :STRING-FOR-WHOLINE)))

(DEFMETHOD (:INIT FILE-DATA-STREAM-MIXIN :AFTER) (IGNORE)
  (WHEN PATHNAME
    (UNLESS TRANSLATED-PATHNAME
      (SETQ TRANSLATED-PATHNAME (SEND PATHNAME ':TRANSLATED-PATHNAME))))
  (WHEN FILE-ACCESS-PATH
    (SEND FILE-ACCESS-PATH ':ADD-STREAM SELF)))

(DEFMETHOD (:SET-PATHNAME FILE-DATA-STREAM-MIXIN :AFTER) (IGNORE)
  (SETQ TRANSLATED-PATHNAME (SEND PATHNAME ':TRANSLATED-PATHNAME)))

;; Always delete the stream from ALL-OPEN-STREAMS even if you abort from the close.
(DEFWRAPPER (:CLOSE FILE-DATA-STREAM-MIXIN) (IGNORE . BODY)
  `(UNWIND-PROTECT
     (PROGN . ,BODY)
     (AND FILE-ACCESS-PATH (SEND FILE-ACCESS-PATH ':DELETE-STREAM SELF))))

(DEFMETHOD (:WHO-LINE-INFORMATION FILE-DATA-STREAM-MIXIN) (&AUX COUNT LENGTH PERCENT)
  (SETQ COUNT (SEND SELF ':READ-POINTER))
  (AND (SETQ LENGTH (SEND SELF ':LENGTH))
       (NOT (ZEROP LENGTH))
       (SETQ PERCENT (// (* 100. COUNT) LENGTH)))
  (VALUES TRANSLATED-PATHNAME (SEND SELF ':DIRECTION) COUNT PERCENT))

(DEFFLAVOR INPUT-FILE-STREAM-MIXIN
	()
	(FILE-DATA-STREAM-MIXIN)
  (:REQUIRED-FLAVORS INPUT-POINTER-REMEMBERING-MIXIN)
  (:DOCUMENTATION :MIXIN "Streams for use with input files."))

(DEFFLAVOR OUTPUT-FILE-STREAM-MIXIN
	()
	(FILE-DATA-STREAM-MIXIN)
  (:REQUIRED-FLAVORS OUTPUT-POINTER-REMEMBERING-MIXIN)
  (:DOCUMENTATION :MIXIN "Streams for use with output files."))

(DEFMETHOD (:LENGTH OUTPUT-FILE-STREAM-MIXIN) () NIL)



(DEFFLAVOR DIRECT-ACCESS-BUFFERED-INPUT-STREAM-MIXIN
	((REMAINING-REQUESTED-COUNT NIL))		;How many bytes asked for are left.
	()
  (:REQUIRED-FLAVORS BASIC-BUFFERED-INPUT-STREAM INPUT-POINTER-REMEMBERING-MIXIN)
  (:REQUIRED-METHODS :NEXT-INPUT-BUFFER :READ-BYTES))

(DEFWHOPPER (:READ-BYTES DIRECT-ACCESS-BUFFERED-INPUT-STREAM-MIXIN) (COUNT &OPTIONAL FILEPOS)
  (IF (NULL FILEPOS)
      (SETQ FILEPOS (SEND SELF ':READ-POINTER)))
  (SEND SELF ':DISCARD-CURRENT-INPUT-BUFFER)
  (PROG1
    (IF (PLUSP COUNT)				;There's apparently a market for :R-B of 0..
	(CONTINUE-WHOPPER COUNT FILEPOS))
    (SETQ REMAINING-REQUESTED-COUNT COUNT)
    (WHEN STREAM-INPUT-BUFFER
      (LET ((THIS-WHACK (- STREAM-INPUT-LIMIT STREAM-INPUT-INDEX)))
	(COND (( THIS-WHACK REMAINING-REQUESTED-COUNT)
	       (SETQ STREAM-INPUT-LIMIT (+ STREAM-INPUT-INDEX REMAINING-REQUESTED-COUNT))
	       (SETQ REMAINING-REQUESTED-COUNT 0)
	       (IF (PLUSP COUNT)		;don't bother him if 0 call.
		   (SEND SELF ':READ-LAST-BYTE)))
	      (T (DECF REMAINING-REQUESTED-COUNT THIS-WHACK)
		 (IF (ZEROP REMAINING-REQUESTED-COUNT)
		     (SEND SELF ':READ-LAST-BYTE))))))))

(DEFWHOPPER (:DISCARD-INPUT-BUFFER DIRECT-ACCESS-BUFFERED-INPUT-STREAM-MIXIN) (BUF)
  (CONTINUE-WHOPPER BUF)
  (IF (EQL REMAINING-REQUESTED-COUNT 0)
      (SEND SELF ':DISCARD-LAST-BYTE)))

(DEFMETHOD (:READ-BYTES DIRECT-ACCESS-BUFFERED-INPUT-STREAM-MIXIN :DEFAULT)
	   (IGNORE &OPTIONAL FILEPOS)		;Yeah, optional, right.
  (WHEN FILEPOS
    (SEND SELF ':SET-POINTER FILEPOS)
    (WHEN (NULL STREAM-INPUT-BUFFER)
      (SEND SELF ':SET-BUFFER-POINTER FILEPOS))))

(DEFMETHOD (:DISCARD-LAST-BYTE DIRECT-ACCESS-BUFFERED-INPUT-STREAM-MIXIN :DEFAULT) ())

(DEFMETHOD (:READ-LAST-BYTE DIRECT-ACCESS-BUFFERED-INPUT-STREAM-MIXIN :DEFAULT) ())

(DEFWHOPPER (:NEXT-INPUT-BUFFER DIRECT-ACCESS-BUFFERED-INPUT-STREAM-MIXIN) (NO-HANG-P)
  (COND ((NULL REMAINING-REQUESTED-COUNT)
	 (FERROR "Attempt to read from direct-access input-stream ~S without having ~
		 prefetched bytes." SELF))
	((EQ REMAINING-REQUESTED-COUNT ':PASS)
	 (CONTINUE-WHOPPER NO-HANG-P))
	((ZEROP REMAINING-REQUESTED-COUNT)
	 (SEND SELF ':DISCARD-CURRENT-INPUT-BUFFER)
	 NIL)
	(T (MULTIPLE-VALUE-BIND (BUF START END)
	       (CONTINUE-WHOPPER NO-HANG-P)
	     (COND ((NULL BUF)
		    (SEND SELF ':READ-LAST-BYTE)
		    NIL)
		   (T (LET ((THIS-WHACK (MIN REMAINING-REQUESTED-COUNT (- END START))))
			(SETQ END (+ START THIS-WHACK))
			(DECF REMAINING-REQUESTED-COUNT THIS-WHACK)
			(IF (ZEROP REMAINING-REQUESTED-COUNT)
			    (SEND SELF ':READ-LAST-BYTE)))
		      (VALUES BUF START END)))))))

(DEFWHOPPER (:SET-POINTER DIRECT-ACCESS-BUFFERED-INPUT-STREAM-MIXIN) (FILEPOS)
  (LET-GLOBALLY ((REMAINING-REQUESTED-COUNT ':PASS))
    (CONTINUE-WHOPPER FILEPOS))) 

(DEFFLAVOR DIRECT-ACCESS-BUFFERED-OUTPUT-STREAM-MIXIN
	()
	()
  (:REQUIRED-FLAVORS BASIC-BUFFERED-OUTPUT-STREAM))



(DEFFLAVOR INPUT-STREAM-EXCEPTION-MIXIN
	((INPUT-EXCEPTION NIL)
	 (INPUT-EXCEPTION-PROCESS NIL))
	())

(DEFMETHOD (:INPUT-EXCEPTION-LOCATION INPUT-STREAM-EXCEPTION-MIXIN) ()
  (LOCF INPUT-EXCEPTION))

(DEFMETHOD (:SET-INPUT-EXCEPTION INPUT-STREAM-EXCEPTION-MIXIN) (CONDITION-NAME &REST ARGS)
  (SETQ INPUT-EXCEPTION (AND CONDITION-NAME (CONS CONDITION-NAME (COPYLIST ARGS))))
  (LET ((PROC (SEND-IF-HANDLES SELF :PROCESS)))
    (WHEN PROC (PROCESS:WAKEUP PROC)))
  (WHEN INPUT-EXCEPTION-PROCESS
    (PROCESS:WAKEUP INPUT-EXCEPTION-PROCESS))
  INPUT-EXCEPTION)

(DEFMETHOD (:CHECK-INPUT-EXCEPTION INPUT-STREAM-EXCEPTION-MIXIN) ()
  (LOOP WHILE INPUT-EXCEPTION
	DO (APPLY #'SIGNAL (CL:SHIFTF INPUT-EXCEPTION NIL))))

(DEFMETHOD (:INPUT-EXCEPTION-WAIT INPUT-STREAM-EXCEPTION-MIXIN) (WHOSTATE FUNCTION &REST ARGS)
  (SETF INPUT-EXCEPTION-PROCESS *CURRENT-PROCESS*)
  (LOOP DO (PROCESS:BLOCK-AND-POLL-WAIT-FUNCTION
	      WHOSTATE
	      (IF (PROCESS::FALSE-VERIFY-FUNCTION FUNCTION (FIRST ARGS))
		  1.
		  (MAX .25 PROCESS::*PROCESS-WAIT-INTERVAL*))
	      #'(LAMBDA ()
		  (OR (NOT (NULL INPUT-EXCEPTION))
		      (NOT (NULL (APPLY FUNCTION ARGS))))))
	WHILE INPUT-EXCEPTION
	DO (APPLY #'SIGNAL (CL:SHIFTF INPUT-EXCEPTION NIL)))
  (SETF INPUT-EXCEPTION-PROCESS NIL))

(DEFMETHOD (STREAM-INPUT-EXCEPTION-BLOCK INPUT-STREAM-EXCEPTION-MIXIN)
	   (WHOSTATE FUNCTION &REST ARGS)
  (SETF INPUT-EXCEPTION-PROCESS *CURRENT-PROCESS*)
  (LOOP DO (PROCESS:BLOCK-PROCESS WHOSTATE
				  #'(LAMBDA ()
				      (OR (NOT (NULL INPUT-EXCEPTION))
					  (APPLY FUNCTION ARGS))))
	WHILE INPUT-EXCEPTION
	DO (APPLY #'SIGNAL (CL:SHIFTF INPUT-EXCEPTION NIL)))
  (SETF INPUT-EXCEPTION-PROCESS NIL))

;;;

(DEFFLAVOR OUTPUT-STREAM-EXCEPTION-MIXIN
	((OUTPUT-EXCEPTION NIL)
	 (OUTPUT-EXCEPTION-PROCESS NIL))
	())

(DEFMETHOD (:OUTPUT-EXCEPTION-LOCATION OUTPUT-STREAM-EXCEPTION-MIXIN) ()
  (LOCF OUTPUT-EXCEPTION))

(DEFMETHOD (:SET-OUTPUT-EXCEPTION OUTPUT-STREAM-EXCEPTION-MIXIN) (CONDITION-NAME &REST ARGS)
  (SETQ OUTPUT-EXCEPTION (AND CONDITION-NAME (CONS CONDITION-NAME (COPYLIST ARGS))))
  (LET ((PROC (SEND-IF-HANDLES SELF :PROCESS)))
    (WHEN PROC (PROCESS:PROCESS-WAKEUP PROC)))
  (WHEN OUTPUT-EXCEPTION-PROCESS
    (PROCESS:WAKEUP OUTPUT-EXCEPTION-PROCESS))
  OUTPUT-EXCEPTION)

(DEFMETHOD (:CHECK-OUTPUT-EXCEPTION OUTPUT-STREAM-EXCEPTION-MIXIN) ()
  (LOOP WHILE OUTPUT-EXCEPTION
	DO (APPLY #'SIGNAL (CL:SHIFTF OUTPUT-EXCEPTION NIL))))

(DEFMETHOD (:OUTPUT-EXCEPTION-WAIT OUTPUT-STREAM-EXCEPTION-MIXIN)
	   (WHOSTATE FUNCTION &REST ARGS)
  (SETF OUTPUT-EXCEPTION-PROCESS *CURRENT-PROCESS*)
  (LOOP DO (PROCESS:BLOCK-AND-POLL-WAIT-FUNCTION
	      WHOSTATE
	      (IF (PROCESS::FALSE-VERIFY-FUNCTION FUNCTION (FIRST ARGS))
		  1.
		  (MAX .25 PROCESS::*PROCESS-WAIT-INTERVAL*))
	      #'(LAMBDA ()
		  (OR (NOT (NULL OUTPUT-EXCEPTION))
		      (NOT (NULL (APPLY FUNCTION ARGS))))))
	WHILE OUTPUT-EXCEPTION
	DO (APPLY #'SIGNAL (CL:SHIFTF OUTPUT-EXCEPTION NIL)))
  (SETF OUTPUT-EXCEPTION-PROCESS NIL))

(DEFMETHOD (STREAM-OUTPUT-EXCEPTION-BLOCK OUTPUT-STREAM-EXCEPTION-MIXIN)
	   (WHOSTATE FUNCTION &REST ARGS)
  (SETF OUTPUT-EXCEPTION-PROCESS *CURRENT-PROCESS*)
  (LOOP DO (PROCESS:BLOCK-PROCESS WHOSTATE
				  #'(LAMBDA ()
				      (OR (NOT (NULL OUTPUT-EXCEPTION))
					  (APPLY FUNCTION ARGS))))
	WHILE OUTPUT-EXCEPTION
	DO (APPLY #'SIGNAL (CL:SHIFTF OUTPUT-EXCEPTION NIL)))
  (SETF OUTPUT-EXCEPTION-PROCESS NIL))


;;; Protocols for dealing with TCP and friends versus .  The problem solved here
;;; is that we now have some streams that do not offer the buffered stream protocol
;;; (indirect-escape-input-stream) that encapsulate streams that are buffered
;;; and cannot set-pointer after the second input buffer has been read. So the traditional
;;; trick of reading an input buffer directly in FS:READ-ATTRIBUTE-LIST does not
;;; help, and this ball of hair is used instead.

(DEFINE-METHOD-COMBINATION DAEMON-WITH-DYNAMIC-OVERRIDE
			   (&KEY (ORDER ':MOST-SPECIFIC-FIRST)
				 HOOK-FUNCTION)
  ((BEFORE "before" :EVERY :MOST-SPECIFIC-FIRST (:BEFORE))
   (PRIMARY "primary" :FIRST ORDER :DEFAULT)
   (AFTER "after" :EVERY :MOST-SPECIFIC-LAST (:AFTER)))
  `(PROGN
     (FUNCALL ,HOOK-FUNCTION)
     (FLAVOR::MULTIPLE-VALUE-PROG2
       ,(FLAVOR::CALL-COMPONENT-METHODS BEFORE)
       ,(FLAVOR::CALL-COMPONENT-METHOD PRIMARY)
       ,(FLAVOR::CALL-COMPONENT-METHODS AFTER)))) 

(DEFFLAVOR UNREWINDABLE-BUFFERED-INPUT-STREAM-MIXIN
	((NEXT-INPUT-BUFFER-HOOK #'IGNORE))
	()
  (:REQUIRED-FLAVORS BASIC-BUFFERED-INPUT-STREAM)
  (:METHOD-COMBINATION
   :SETUP-NEXT-INPUT-BUFFER
   (DAEMON-WITH-DYNAMIC-OVERRIDE :HOOK-FUNCTION NEXT-INPUT-BUFFER-HOOK))
  (:METHOD-COMBINATION
   :DISCARD-INPUT-BUFFER
   (DAEMON-WITH-DYNAMIC-OVERRIDE :HOOK-FUNCTION NEXT-INPUT-BUFFER-HOOK))
  (:METHOD-COMBINATION
   :DISCARD-CURRENT-INPUT-BUFFER
   (DAEMON-WITH-DYNAMIC-OVERRIDE :HOOK-FUNCTION NEXT-INPUT-BUFFER-HOOK))
  (:DOCUMENTATION :MIXIN
   "Mix this in to any buffered stream where the real medium does not support
:SET-POINTER 0 and it is necessary to read attribute lists."))

(DEFMETHOD (STREAM-WITH-NEXT-INPUT-BUFFER-HOOK UNREWINDABLE-BUFFERED-INPUT-STREAM-MIXIN)
	   (CONTINUATION HOOK)
  (LETF ((NEXT-INPUT-BUFFER-HOOK HOOK))
    (FUNCALL CONTINUATION)))

(DEFMACRO WITH-STREAM-NEXT-INPUT-BUFFER-HOOK ((STREAM HOOK) &BODY BODY)
  `(STREAM-WITH-NEXT-INPUT-BUFFER-HOOK ,STREAM
				      #'(LAMBDA ()
					  (LET ((,STREAM ,STREAM))
					    ,@BODY))
				      ,HOOK))

(DEFGENERIC STREAM-SUPPORTS-SET-POINTER-0 (STREAM)
  (:FUNCTION
    (OR (NOT (INSTANCEP STREAM))		;our protocol avails us not.
	(FUNCALL (FLAVOR:GENERIC STREAM-SUPPORTS-SET-POINTER-0) STREAM))))

(DEFMETHOD (STREAM-SUPPORTS-SET-POINTER-0 STREAM) () T)
(DEFMETHOD (STREAM-SUPPORTS-SET-POINTER-0 UNREWINDABLE-BUFFERED-INPUT-STREAM-MIXIN) () NIL)

(defgeneric cursorpos-unit-supported-p (stream unit)
  (:function
    (if (not (instancep stream)) t		;our protocol avails us not.
	(funcall (flavor:generic cursorpos-unit-supported-p) stream unit)))
  (:method (stream :default) (ignore unit) t))				;Assume that stream supports
						;full protocol unless it denies it.


;;;
;;; Buffer resources used by various character streams
;;;

(defsubst make-string-buffer (element-type length  &optional leader-length)
  (cl:make-array length ':element-type element-type ':leader-length leader-length))

(defsubst match-string-buffer (buf length &optional leader-length)
  (and (>= (array-total-size buf) length)
       (eq leader-length			; array-leader-length returns NIL if no leader
	   (array-leader-length buf))))

(defresource thin-string-buffer (length &optional leader-length)
  :constructor (make-string-buffer 'cl:string-char length leader-length)
  :matcher (match-string-buffer object length leader-length)
  :initial-copies 0)

(defresource fat-string-buffer (length &optional leader-length)
  :constructor (make-string-buffer 'cl:character length leader-length)
  :matcher (match-string-buffer object length leader-length)
  :initial-copies 0)


;;;
;;; Fast(er) ascii-translating mixins, for buffered streams.
;;;

;;; Input side.  This is pretty straight-forward; we just whop
;;; :next-input-buffer, do the translation, and pass the results up to
;;; the application.

(defflavor fast-ascii-translating-input-mixin
	((at-input-system-buffer nil)		; buffer we get from underlying stream
	 at-input-user-buffer			; a thin-string, passed upstairs to user
	 (at-cr-flag nil))				; flag for cr 
	() 
  (:required-flavors si:buffered-input-stream))


(defwhopper (:next-input-buffer fast-ascii-translating-input-mixin) (&optional no-hang-p)
  (declare (values buf start end))
  (multiple-value-bind (inner-buf inner-start inner-end)
      (continue-whopper no-hang-p)
    (when inner-buf				; we get anything from downstairs?
      (setq at-input-system-buffer inner-buf)	; save this for discard time
      (setq at-input-user-buffer 
	    (allocate-resource 'thin-string-buffer (- inner-end inner-start)))
      (let ((from-buf inner-buf)
	    (to-buf at-input-user-buffer)
	    (ascii-translation *ascii-to-char*))
	(declare (sys:array-register from-buf to-buf ascii-translation))
	(loop for from-idx from inner-start below inner-end
	      with to-idx = 0
	      for ascii-code = (aref from-buf from-idx)
	      do
	  (cond ((and at-cr-flag (= ascii-code (ascii-code :lf)))
		 nil				; do nothing
		 )
		(t 
		 (setq at-cr-flag (= ascii-code (ascii-code :cr)))
		 (setf (aref to-buf to-idx) (aref ascii-translation ascii-code))
		 (incf to-idx)))
	      finally (return (values at-input-user-buffer 0 to-idx)))))))


(defwhopper (:discard-input-buffer fast-ascii-translating-input-mixin) (buf)
  (unless (eq buf at-input-user-buffer)
    (error "Attempt to discard random buffer ~S" buf))
  (deallocate-resource 'thin-string-buffer (scl:shiftf at-input-user-buffer nil))
  (continue-whopper at-input-system-buffer))

;;; Output side.  This is rather trickier.  The screw here is that you
;;; can't whop get-output-buffer and send-output-buffer in a similar
;;; fashion to the input side, above, because you can't tell how much
;;; the data will expand.  Therefore we use the following algorithm (due
;;; to Kalman):
;;;
;;; At new-output-buffer time, we grab the inner buffer, and return a
;;; buffer of the SAME size to the client.  At send-output-buffer time,
;;; we run the translate loop until we've filled the inner buffer.
;;; That'll usually leave some extra, because the data expanded on us.
;;; So, we keep a holding-buffer for the extra, and continue with the
;;; send-output-buffer.  The next time we get a new-output-buffer, we
;;; copy in the leftovers from the previous time, and return the buffer
;;; to the client, minus the extra from the previous pass.
;;;
;;; Note that the stuff in the extra buffer is NOT translated.  This is
;;; done so that we can do STRING-OUT's of it at force-output time.
;;;
(defflavor fast-ascii-translating-output-mixin
	(at-output-user-buffer			; buf we hand upstairs
	 at-output-system-buffer		; buf we get from n-o-b continuation
	 at-output-start			; start idx of system-buffer
	 at-output-end				; end idx of system-buffer
	 (at-temp-buffer nil)			; holding cell for overflows
	 at-temp-buffer-size			; allocated size
	 (at-temp-buffer-nbytes 0)		; nbytes valid in holding cell
	 (at-lf-flag nil)			; pending LF needed
	 )
	()
  (:required-flavors buffered-output-stream))


;;;
;;; This one's tricky.  We want to return a buffer that's the same size
;;; as the one we get back from the continuation, minus whatever bytes
;;; were pending, due to overflow the last time around.  Ie, if the
;;; continuation buys us a buffer with bounds of 0 and 128, and we had
;;; 20 bytes left over from last time, we'll stick the leftovers at the
;;; front of the buffer, and return it with bounds of 20 and 128.
;;;
(defwhopper (:new-output-buffer fast-ascii-translating-output-mixin) ()
  (multiple-value-bind (buf start end)
      (continue-whopper)			; get the real one
    (setq at-output-system-buffer buf
	  at-output-start start
	  at-output-end end)
    ;; If there's anything left over, try to just use that buffer,
    ;; rather than allocating a new one.  It's safe to use the
    ;; temp-buffer iff the TOTAL size of the temp (ignoring how much of
    ;; it is used as leftovers) is at least as big as the size of the
    ;; system buffer.  That way, when we send this output buffer, the
    ;; data will at least fill the system output buffer.  There may, of
    ;; course, be more leftovers; they'll get a new buffer allocated for
    ;; them.
    (if (and at-temp-buffer
	     (>= at-temp-buffer-size (- end start)))
	(progn
	  ;; it's ok, existing buf's big enough
	  (setq at-output-user-buffer at-temp-buffer
		at-temp-buffer nil))
	(progn
	  ;; no existing buf, or not big enough, get a new one
	  (setq at-output-user-buffer
		(allocate-resource 'thin-string-buffer (- end start)))
	  (when at-temp-buffer
	    (copy-array-portion at-temp-buffer 0 at-temp-buffer-nbytes
				at-output-user-buffer 0 at-temp-buffer-nbytes)
	    (deallocate-resource 'thin-string-buffer (cl:shiftf at-temp-buffer nil)))))
    (let ((temp-buffer-nbytes at-temp-buffer-nbytes))
      (setq at-temp-buffer-nbytes 0)
      (values at-output-user-buffer 
	      temp-buffer-nbytes
	      (max (- end start) temp-buffer-nbytes)))))


(defwhopper (:discard-output-buffer fast-ascii-translating-output-mixin) (buf)
  (unless (eq buf at-output-user-buffer)
    (error "Attempt to discard random buffer ~S" buf))
  (deallocate-resource 'thin-string-buffer (scl:shiftf at-output-user-buffer nil))
  ;; This shouldn't be necessary; stream protocol should ensure that
  ;; there's never a temp buffer when this is called, as any leftover
  ;; bytes would have been transferred to a real buffer.
  ;; (when at-temp-buffer
  ;;   (deallocate-resource 'thin-string-buffer (scl:shiftf at-temp-buffer nil)))
  (continue-whopper at-output-system-buffer))

(defwhopper (:send-output-buffer fast-ascii-translating-output-mixin) (buf from-end force)
  (let ((to-idx at-output-start)		; starting index into system-buffer
	(to-buf at-output-system-buffer)
	(from-idx 0)				; always start at 0 in user-buf
	(from-buf buf)
	(ascii-translation *char-to-ascii*))
    (declare (sys:array-register from-buf to-buf ascii-translation))

    ;; first deal with any dangling LF's
    (when (and at-lf-flag
	       (< to-idx at-output-end))	; sure, be paranoid...
      (setf (aref to-buf to-idx) (ascii-code :lf))
      (incf to-idx)
      (setq at-lf-flag nil))

    ;; now do the buffer we've got
    (loop while (< from-idx from-end)		; try to process whole user-buffer
	  while (< to-idx at-output-end)	;  but stop at end of system-buffer
	  for chr-code = (char-code (aref from-buf from-idx))
	  do (if (= chr-code (char-code #\return))
		 (progn
		   (setf (aref to-buf to-idx) (ascii-code :cr))
		   (if (= to-idx (1- at-output-end))
		       (setq at-lf-flag t)
		       (progn 
			 (incf to-idx)
			 (setf (aref to-buf to-idx) (ascii-code :lf)))))
		 (setf (aref to-buf to-idx) (aref ascii-translation chr-code)))
	     (incf to-idx)
	     (incf from-idx))

    ;; now, if there's data left over, leave it as leftovers for next time
    (let ((leftover-bytes (- from-end from-idx)))
      (setq at-temp-buffer-nbytes leftover-bytes)
      (when (plusp leftover-bytes)
	;; move the data over to the left side of the buffer, and keep
	;; the buffer around in the temp slot.
	(when at-temp-buffer			; paranoia check
	  (error "Internal error!  Already have a temp buffer?"))

	(copy-array-portion buf from-idx from-end
			    buf 0 leftover-bytes)
	(setq at-temp-buffer buf)
	;; (setq at-temp-buffer-size from-end)	; not strictly accurate, as this is the
						;  end value we passed upstairs at 
						;  new-output-buffer time.  Close, though,
						;  and faster than array-total-size
	(setq at-temp-buffer-size (array-total-size at-temp-buffer))
	))	  

    (unless (eq buf at-temp-buffer)
      ;; unlike the input side, :send-output-buffer is expected to
      ;; deallocate its buffer
      (deallocate-resource 'thin-string-buffer buf))
    
    (setq at-output-user-buffer nil)

    ;; whew! now continue-whopper to send the  inner buf
    (continue-whopper at-output-system-buffer to-idx force)))

;;; make sure we flush leftover stuff 
(defwhopper (:force-output fast-ascii-translating-output-mixin) ()
  (continue-whopper)				; let the other buffered up stuff percolate out
  (loop until (zerop at-temp-buffer-nbytes)	; typically only once...
	for buf = (cl:shiftf at-temp-buffer nil)
	for nbytes = (cl:shiftf at-temp-buffer-nbytes 0)
	do 
    ;; gross but effective...
    (send self ':string-out buf 0 nbytes)
    (deallocate-resource 'thin-string-buffer buf))
  (continue-whopper))


(defmethod (:close fast-ascii-translating-output-mixin :before) (&optional abort-p)
  (unless abort-p
    (send self ':force-output))
  (when at-temp-buffer
    (deallocate-resource 'thin-string-buffer (cl:shiftf at-temp-buffer nil))))


;;;
;;; Array register caching streams
;;;
;;; The basic idea here is that it's expensive to do things like TYI on
;;; many kinds of buffered streams, as that involves an aref of an array
;;; that's typically indirect, and thus slow to access.  This is
;;; particularly painful on I-machines, as the aref microcode must trap
;;; to lisp to do the array decode.  That means that it takes about 60
;;; usec to the the aref, as opposed to 3.  Yuck.  The usual trick of
;;; declaring the thing array-register doesn't help here, as you're only
;;; doing one aref.
;;;
;;; The solution is to get the results of declaring things
;;; array-register by underhanded means.  At :setup-next-input-buffer
;;; time, we explicitly setup the array, and cache the values.  Then we
;;; can mung certain methods in such a way as to use the cached values,
;;; instead of trapping every time.
;;;



;;;
;;; the base input flavor
;;;
(defflavor areg-caching-buffered-input-stream-mixin
	(cached-input-buffer-values		; storage for the 4 values from setup-1d-array.
	 cached-input-buffer-base)		; pointer to base of it
	()
  (:required-flavors basic-buffered-input-stream))


(defmethod (make-instance areg-caching-buffered-input-stream-mixin :after) (&rest ignore)
  (setf cached-input-buffer-values (make-array 4 :area (sys:%area-number self)))
  (setf cached-input-buffer-base 
	#+imach (locf (aref cached-input-buffer-values 0))
	#+3600 (sys:%make-pointer-offset dtp-locative
					 (locf (aref cached-input-buffer-values 0))
					 -1)))


;;;
;;; The macro that hides the magic.
;;;
(defmacro-in-flavor (with-cached-input-array-register areg-caching-buffered-input-stream-mixin)
		    ((array-var) &body body)
  (let* ((new-array-var (gensym))
	 (control-var (gensym))
	 (base-var (gensym))
	 (length-var (gensym))
	 (munged-body
	   (loop for form in body 
		 collect
		   (lt:copyforms #'(lambda (form kind usage)
				     (ignore kind)
				     (when (and (eq usage 'eval)
						(listp form)
						(= (length form) 3)
						(eq (first form) 'aref)
						(eq (second form) array-var))
				       (setq form
					     `(sys:fast-aref-1 ,(third form) ,control-var)))
				     form)
				 form))))
    #+IMACH
    `(with-block-registers (1)
       (setf (%block-register 1) cached-input-buffer-base)
       (let ((,new-array-var (%block-read 1))
	     (,control-var (%block-read 1))
	     (,base-var (%block-read 1 :prefetch nil))
	     (,length-var (%block-read 1 :prefetch nil)))
	 ;; inhibit var foo unused warnings
	 (ignore ,array-var ,new-array-var ,base-var ,length-var)
	 ,@munged-body))
    #+3600
    (let ((pointer-gensym (gensym)))
      `(let* ((,pointer-gensym cached-input-buffer-base)
	      (,new-array-var (%p-contents-increment-pointer ,pointer-gensym))
	      (,control-var (%p-contents-increment-pointer ,pointer-gensym))
	      (,base-var (%p-contents-increment-pointer ,pointer-gensym))
	      (,length-var (%p-contents-increment-pointer ,pointer-gensym)))
	 ;; inhibit var foo unused warnings
	 (ignore ,array-var ,new-array-var ,base-var ,length-var)
	 ,@munged-body))))

;;; ought to be able to do better than this...
(zwei:defindentation (with-cached-input-array-register 1 1))

;;;
;;; set up the IVs after getting a new buffer
;;;
(defmethod (:setup-next-input-buffer areg-caching-buffered-input-stream-mixin :after)
	   (&rest ignore)
  (when stream-input-buffer
    (cl:multiple-value-bind (buffer control-word base-address length)
	(sys:setup-1d-array stream-input-buffer)
      (let ((cached-input-buffer-vals cached-input-buffer-values))
	(declare (sys:array-register cached-input-buffer-vals))
	(setf (aref cached-input-buffer-vals 0) buffer)
	(setf (aref cached-input-buffer-vals 1) control-word)
	(setf (aref cached-input-buffer-vals 2) base-address)
	(setf (aref cached-input-buffer-vals 3) length)
	nil))))

;;;
;;; Flush 'em when discarding a buffer
;;;
(defmethod (:discard-input-buffer areg-caching-buffered-input-stream-mixin :before)
	   (&rest ignore)
  (let ((cached-input-buffer-vals cached-input-buffer-values))
    (declare (sys:array-register cached-input-buffer-vals))
    (setf (aref cached-input-buffer-vals 0) nil)
    (setf (aref cached-input-buffer-vals 1) nil)
    (setf (aref cached-input-buffer-vals 2) nil)
    (setf (aref cached-input-buffer-vals 3) nil)
    nil))

;;;
;;; methods that make use of the magic
;;;

(defmethod (:tyi areg-caching-buffered-input-stream-mixin) (&optional eof)
  (unless (and stream-input-buffer (< stream-input-index stream-input-limit))
    (send self :setup-next-input-buffer nil eof))
  (when stream-input-buffer
    (with-cached-input-array-register (stream-input-buffer)
      (prog1 (aref stream-input-buffer stream-input-index)
	     (incf stream-input-index)))))

(defmethod (:tyi-no-hang areg-caching-buffered-input-stream-mixin) (&optional eof)
  (unless (and stream-input-buffer (< stream-input-index stream-input-limit))
    (send self :setup-next-input-buffer t (or eof t)))
  (when stream-input-buffer
    (with-cached-input-array-register (stream-input-buffer)
      (prog1 (aref stream-input-buffer stream-input-index)
	     (incf stream-input-index)))))

(defmethod (:tyipeek areg-caching-buffered-input-stream-mixin) (&optional eof)
  (unless (and stream-input-buffer (< stream-input-index stream-input-limit))
    (send self :setup-next-input-buffer nil eof))
  (when stream-input-buffer
    (with-cached-input-array-register (stream-input-buffer)
      (aref stream-input-buffer stream-input-index))))

;;;
;;; Similar stuff for output side
;;;
(defflavor areg-caching-buffered-output-stream-mixin
	(cached-output-buffer-values
	 cached-output-buffer-base)
	()
  (:required-flavors basic-buffered-output-stream))

(defmethod (make-instance areg-caching-buffered-output-stream-mixin :after) (&rest ignore)
  (setq cached-output-buffer-values (make-array 4 :area (sys:%area-number self)))
  (setf cached-output-buffer-base 
	#+imach (locf (aref cached-output-buffer-values 0))
	#+3600 (sys:%make-pointer-offset dtp-locative
					 (locf (aref cached-output-buffer-values 0))
					 -1)))

(defmacro-in-flavor (with-cached-output-array-register areg-caching-buffered-output-stream-mixin)
		    ((array-var) &body body)
  (let* ((new-array-var (gensym))
	 (control-var (gensym))
	 (base-var (gensym))
	 (length-var (gensym))
	 (munged-body
	   (loop for form in body 
		 collect
		   (lt:copyforms #'(lambda (form kind usage)
				   (ignore kind)
				   (when (and (eq usage 'eval)
					      (listp form)
					      (= (length form) 4)
					      (eq (first form) 'aset)
					      (eq (third form) array-var))
				     (setq form
					   `(sys:fast-aset-1 ,(second form) ,(fourth form)
							     ,control-var)))
				   form)
			       form))))
    #+IMACH
    `(with-block-registers (1)
       (setf (%block-register 1) cached-output-buffer-base)
       (let ((,new-array-var (%block-read 1))
	     (,control-var (%block-read 1))
	     (,base-var (%block-read 1 :prefetch nil))
	     (,length-var (%block-read 1 :prefetch nil)))
	 ;; inhibit var foo unused warnings
	 (ignore ,array-var ,new-array-var ,base-var ,length-var)
	 ,@munged-body))
    #+3600
    (let ((pointer-gensym (gensym)))
      `(let* ((,pointer-gensym cached-output-buffer-base)
	      (,new-array-var (%p-contents-increment-pointer ,pointer-gensym))
	      (,control-var (%p-contents-increment-pointer ,pointer-gensym))
	      (,base-var (%p-contents-increment-pointer ,pointer-gensym))
	      (,length-var (%p-contents-increment-pointer ,pointer-gensym)))
	 ;; inhibit var foo unused warnings
	 (ignore ,array-var ,new-array-var ,base-var ,length-var)
	 ,@munged-body))))

;;; ought to be able to do better than this...
(zwei:defindentation (with-cached-output-input-array-register 1 1))

(defmethod (:setup-new-output-buffer areg-caching-buffered-output-stream-mixin :after) 
	   (&rest ignore)
  (when stream-output-buffer
    (cl:multiple-value-bind (buffer control-word base-address length)
	(sys:setup-1d-array stream-output-buffer)
      (let ((cached-output-buffer-vals cached-output-buffer-values))
	(declare (sys:array-register cached-output-buffer-vals))
	(setf (aref cached-output-buffer-vals 0) buffer)
	(setf (aref cached-output-buffer-vals 1) control-word)
	(setf (aref cached-output-buffer-vals 2) base-address)
	(setf (aref cached-output-buffer-vals 3) length)
	nil))))

(defmethod (:discard-output-buffer areg-caching-buffered-output-stream-mixin :before)
	   (&rest ignore)
  (let ((cached-output-buffer-vals cached-output-buffer-values))
    (declare (sys:array-register cached-output-buffer-vals))
    (setf (aref cached-output-buffer-vals 0) nil)
    (setf (aref cached-output-buffer-vals 1) nil)
    (setf (aref cached-output-buffer-vals 2) nil)
    (setf (aref cached-output-buffer-vals 3) nil)
    nil))

(defmethod (:send-output-buffer areg-caching-buffered-output-stream-mixin :before)
	   (&rest ignore)
  (let ((cached-output-buffer-vals cached-output-buffer-values))
    (declare (sys:array-register cached-output-buffer-vals))
    (setf (aref cached-output-buffer-vals 0) nil)
    (setf (aref cached-output-buffer-vals 1) nil)
    (setf (aref cached-output-buffer-vals 2) nil)
    (setf (aref cached-output-buffer-vals 3) nil)
    nil))

(defmethod (:tyo areg-caching-buffered-output-stream-mixin) (ch)
  (loop until (and stream-output-buffer
		   (< stream-output-index stream-output-limit))
	do (send self ':setup-new-output-buffer)
	finally 
	  (with-cached-output-array-register (stream-output-buffer)
	    (setf (aref stream-output-buffer stream-output-index) ch))
	  (incf stream-output-index)))

