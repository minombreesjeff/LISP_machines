;;; -*- Mode: LISP; Package: FILE-SYSTEM; Base: 8; Lowercase: Yes -*-
;;; File access path handling, generic user file protocol implementation.
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;;; Pathname interface
(defflavor active-pathname-mixin () ()
  (:required-flavors remote-pathname))

(defmethod (:all-directories active-pathname-mixin) (options)
  (send (send host ':file-access-path self ':all-directories) ':all-directories self options))

(defmethod (:change-properties active-pathname-mixin) (ignore &rest properties)
  (lexpr-send (send host ':file-access-path self ':change-properties)
	      ':change-properties self properties))

(defmethod (:complete-string active-pathname-mixin) (string options)
  (send (send host ':file-access-path self ':complete-string)
	':complete-string self string options))

(defmethod (:create-directory active-pathname-mixin) (&optional ignore &rest options)
  (lexpr-send (send host ':file-access-path self ':create-directory)
	      ':create-directory self options))

(defmethod (:create-link active-pathname-mixin) (link-to &rest options)
  (lexpr-send (send host ':file-access-path self ':create-link)
	      ':create-link self link-to options))

(defmethod (:delete active-pathname-mixin) ()
  (send (send host ':file-access-path self ':delete) ':delete self))

(defmethod (:directory-list active-pathname-mixin) (options)
  (send (send host ':file-access-path self ':directory-list) ':directory-list self options))

(defmethod (:expunge active-pathname-mixin) (&rest options)
  (lexpr-send (send host ':file-access-path self ':expunge) ':expunge self options))

(defmethod (:homedir active-pathname-mixin) ()
  (send (send host ':file-access-path self ':homedir) ':homedir self t))

(defmethod (:quiet-homedir active-pathname-mixin) ()
  (let ((fap (send host :file-access-path self :quiet-homedir t)))
    (if fap
	(send fap :homedir self nil)
	(send host :default-homedir (or (send si:*user* :host-user-id host) "FOO")))))

(defmethod (:multiple-file-plists active-pathname-mixin) (files options)
  (send (send host ':file-access-path self ':multiple-file-plists)
	':multiple-file-plists files options))

(defmethod (:open active-pathname-mixin) (pathname &rest options)
  (cl:apply #'file-access-path-open
	    (send host ':file-access-path self ':open)
	    self pathname options))

(defmethod (:properties active-pathname-mixin) ()
  (send (send host ':file-access-path self ':properties) ':properties self))

(defmethod (:rename active-pathname-mixin) (new-pathname)
  (send (send host ':file-access-path self ':rename) ':rename self new-pathname))

(defmethod (:undelete active-pathname-mixin) ()
  (send (send host ':file-access-path self ':undelete) ':undelete self))

;;;This is an efficiency side-door for OPEN.
(defgeneric pathname-file-access-path (pathname operation)
  (declare (values file-access-path-object)))

(defmethod (pathname-file-access-path active-pathname-mixin) (operation)
  (send host :file-access-path self operation))


;;;; Host interface

(defflavor host-not-accessible-for-file (host) (file-request-failure)
  :initable-instance-variables
  :gettable-instance-variables)

(defmethod (:report-without-pathname host-not-accessible-for-file) (stream)
  (format stream "The host ~A is not accessible in any way for file operations." host))

(defflavor basic-active-pathname-host
	((file-access-paths nil))
	(net:pathname-host-mixin)
  (:required-flavors net:basic-host))

(defflavor active-pathname-host () (basic-active-pathname-host))

(defmethod (:file-access-path active-pathname-host) (&optional pathname operation dont-create)
  ;;++ Some types of access might want to look at the pathname to check.
  ;;could send a message to see whether access path works for pathname operation combo?
  (when (and (null file-access-paths) (not dont-create))
    (condition-case ()
	(condition-bind ((net:host-does-not-support-service
			   #'neti:host-does-not-support-protocol-specify-path-handler))
	  (push (net:invoke-service-on-host :file self pathname operation)
		file-access-paths))
      (net:host-does-not-support-service
	(error 'host-not-accessible-for-file
	       :host self :pathname pathname :operation operation))))
  (first file-access-paths))

(defwhopper (:file-access-path active-pathname-host)
	    (&optional pathname operation dont-create)
  (if (and pathname (pathname-vc-p pathname))
      (cond ((or ;; Binary file types are never VC files.
		 (not (null (get (send pathname :canonical-type) :binary-file-byte-size)))
		 ;; Explicitly specified null VC branch and version.
		 (and (equal (pathname-vc-branch pathname) "")
		      (equal (pathname-vc-version pathname) "")))
	     (continue-whopper (send pathname :new-pathname
					      :vc-branch nil :vc-version nil)
			       operation dont-create))
	    ((not *vc-pathname-parsing-enabled*)
	     ;; If VC pathname parsing is disabled, but we somehow have a VC
	     ;; pathname, just be forgiving and do the "right thing".
	     (continue-whopper (flatten-version-control-pathname pathname)
			       operation dont-create))
	    ((and *vc-pathname-parsing-enabled*
		  (memq :version-control cl:*features*))
	     ;; I guess Version Control is loaded...
	     (make-instance 'vc-file-access-path-encapsulation
			    :file-access-path (continue-whopper pathname operation dont-create)
			    ))
	    (t
	     (error "The use of Version Control pathnames isn't supported yet.")))
    (continue-whopper pathname operation dont-create)))

;; These two aren't a pathname interface, but are called by the
;; user.  Hence, a bit more user-interface is included.
(defun enable-capabilities (host &rest capabilities)
  (setq host (net:parse-host host))
  (unless capabilities (setq capabilities (send host ':default-enable-capabilities)))
  (unless capabilities
    (error "No capabilities specified, and there are no default capabilities for ~A."
	   host))
  (when capabilities
    (lexpr-send host ':enable-capabilities capabilities)))

(defun disable-capabilities (host &rest capabilities)
  (setq host (net:parse-host host))
  (unless capabilities
    (setq capabilities
	  (or capabilities
	      (send host :default-disable-capabilities)
	      (send host ':default-enable-capabilities))))
  (unless capabilities
    (error "No capabilities specified, and there are no default capabilities for ~A."
	   host))
  (lexpr-send host ':disable-capabilities capabilities))

(defmethod (:default-enable-capabilities basic-active-pathname-host) ()
  nil)

(defmethod (:default-disable-capabilities basic-active-pathname-host) ()
  nil)

(defmethod (:enable-capabilities basic-active-pathname-host) (&rest capabilities)
  (lexpr-send (send self ':file-access-path nil ':enable-capabilities)
	      ':enable-capabilities capabilities))

(defmethod (:disable-capabilities basic-active-pathname-host) (&rest capabilities)
  (lexpr-send (send self ':file-access-path nil ':disable-capabilities)
	      ':disable-capabilities capabilities))

(defvar *remember-capabilities* t)

;; Remember which capabilities have been turned on, and which have
;; been turned off, so that new host units can be enabled or
;; disabled apropriately.  When enabling, we add to the :ENABLED-CAPABILITIES property, and
;; remove from :DISABLED-CAPABILITIES.  When disabling, we do the reverse.
(defmethod (:record-capability basic-active-pathname-host) (capability add-key remove-key)
  (when *remember-capabilities*
    (let ((add-list (send self ':get add-key))
	  (remove-list (send self ':get remove-key)))
      (or (member capability add-list)
	  (push capability add-list))
      (setq remove-list (delete capability remove-list))
      (send self ':putprop add-list add-key)
      (send self ':putprop remove-list remove-key))))


(defmethod (:host-user-id basic-active-pathname-host) ()
  (send (send self ':file-access-path) ':host-user-id))

(defmethod (:set-host-user-id basic-active-pathname-host) (new-user-id)
  (send (send self ':file-access-path) ':set-host-user-id new-user-id))

(defmethod (:file-reset basic-active-pathname-host) (&optional forget-p)
  (loop for path in file-access-paths
	do (send path ':reset))
  (and forget-p (setq file-access-paths nil)))

(defmethod (:login basic-active-pathname-host) (login-p)
  (loop for path in file-access-paths
	do (file-access-path-login path login-p)))

(defmethod (:reset-host-user-id basic-active-pathname-host) ()
  (loop for path in file-access-paths
	do (send path ':send-if-handles ':reset-host-user-id)))

(defmethod (:open-streams basic-active-pathname-host) ()
  (loop for path in file-access-paths
	append (send path ':open-streams)))

(defmethod (:peek-file-system-p basic-active-pathname-host) ()
  (not (null file-access-paths)))

(defmethod (:peek-file-system-header basic-active-pathname-host) ()
  (list '(:pre-process-function chaos:peek-chaos-conn-insert-hostat)	;sigh
	(tv:scroll-parse-item
	  :leader 3
	  `(:mouse-item
	    (nil :kbd (send :peek-host-menu ,self tv:item)
		 :documentation "Menu of useful things to do to this host.")
	    :string ,(format nil "Host ~A" self)))))

(defmethod (:peek-file-system basic-active-pathname-host) ()
  (tv:scroll-maintain-list `(lambda () (cdr ',(locate-in-instance self 'file-access-paths)))
			   #'(lambda (access-path)
			       (append '(())
				       (send access-path ':peek-file-system-header)
				       ;; I think this is making up for a bug in LIST method
				       ;; combination.
				       (append '(())
					 (send access-path ':peek-file-system))))))

(defmethod (:default-homedir basic-active-pathname-host :default) (user-id)
  (let* ((*default-directory-recursion-flag* t)
	 (sample (send self :sample-pathname))
	 (dir (condition-case ()
		  (send sample :parse-directory-spec user-id)
		(error (send sample :default-default-directory)))))
    (send sample :new-default-pathname
	  :device (send sample :primary-device)
	  :directory dir
	  :name nil :type nil :version nil)))


;;;; Operating system dependent types

;;; Pathnames
(defflavor random-pathname () (random-pathname-mixin active-pathname-mixin remote-pathname))

(defflavor tops20-pathname () (tops20-pathname-mixin active-pathname-mixin remote-pathname))

(defflavor tenex-pathname () (tenex-pathname-mixin active-pathname-mixin remote-pathname)) 

(defflavor alto-pathname () (alto-pathname-mixin active-pathname-mixin remote-pathname)) 

(defflavor vms-pathname () (vms3-pathname-mixin vms-pathname-mixin
			    active-pathname-mixin remote-pathname)) 

(defflavor vms4-pathname () (vms4-pathname-mixin vms-pathname-mixin
			     active-pathname-mixin remote-pathname)) 

(defflavor vms4.4-pathname () (vms4.4-pathname-mixin vms-pathname-mixin
			       active-pathname-mixin remote-pathname))

(defflavor msdos-pathname () (msdos-pathname-mixin active-pathname-mixin remote-pathname))

(defflavor hpfs-pathname () (hpfs-pathname-mixin msdos-pathname-mixin
			     active-pathname-mixin remote-pathname))

(defflavor unix-pathname () (vanilla-unix-pathname-mixin
			     active-pathname-mixin remote-pathname)) 

(defflavor unix42-pathname () (unix42-pathname-mixin active-pathname-mixin remote-pathname))

(defflavor multics-pathname () (multics-pathname-mixin active-pathname-mixin remote-pathname))

(defflavor its-pathname () (its-pathname-mixin active-pathname-mixin remote-pathname))

(defflavor vm370-pathname () (vm370-pathname-mixin active-pathname-mixin remote-pathname))

(defflavor neti:random-host () (neti:random-host-mixin active-pathname-host net:host))

(defmethod (:pathname-flavor neti:random-host) ()
  'random-pathname)

(defflavor tops20-tenex-active-host-mixin () ()
  (:required-flavors active-pathname-host))

(defmethod (:default-enable-capabilities tops20-tenex-active-host-mixin) ()
  '("ALL"))

(defprop :tops-20 tops20-host net:host-type-flavor)

(defflavor tops20-host () (net:host-tops20-mixin tops20-tenex-active-host-mixin
			   active-pathname-host net:host))

(defmethod (:pathname-flavor tops20-host) ()
  'tops20-pathname)

(defprop :tenex tenex-host net:host-type-flavor)

(defflavor tenex-host () (net:host-tenex-mixin tops20-tenex-active-host-mixin
			  active-pathname-host net:host))

(defmethod (:pathname-flavor tenex-host) ()
  'tenex-pathname)

(defprop :vms vms-host net:host-type-flavor)
(defprop :vms4 vms-host net:host-type-flavor)
(defprop :vms4.4 vms-host net:host-type-flavor)

(defflavor vms-host () (net:host-vms-mixin active-pathname-host net:host))

(defmethod (:pathname-flavor vms-host) ()
  (cl:ecase (send self :system-type)
    (:vms 'vms-pathname)
    (:vms4 'vms4-pathname)
    (:vms4.4 'vms4.4-pathname)))

(defmethod (:default-enable-capabilities vms-host) ()
  '("SYSPRV"))

(defprop :msdos msdos-host net:host-type-flavor)

(defflavor msdos-host () (neti:host-msdos-mixin active-pathname-host net:host))

(defmethod (:pathname-flavor msdos-host) ()
  'msdos-pathname)

(defprop :os//2 os2-host net:host-type-flavor)

(defflavor os2-host () (neti:host-msdos-mixin active-pathname-host net:host))

(defmethod (:pathname-flavor os2-host) ()
  'hpfs-pathname)

(defprop :unix unix-host net:host-type-flavor)

(defflavor unix-host () (net:host-unix-mixin active-pathname-host net:host))

(defmethod (:pathname-flavor unix-host) ()
  (if (memq (send self :system-type) '(:unix42 :ultrix)) 'unix42-pathname 'unix-pathname))

(defprop :unix42 unix-host net:host-type-flavor)

(defprop :ultrix unix-host net:host-type-flavor)

(defprop :xenix unix-host net:host-type-flavor)

(defprop :multics multics-host net:host-type-flavor)

(defflavor multics-host () (net:host-multics-mixin active-pathname-host net:host))

(defmethod (:pathname-flavor multics-host) ()
  'multics-pathname)

(defprop :its its-host net:host-type-flavor)

(defflavor its-host () (net:host-its-mixin active-pathname-host net:host))

(defmethod (:pathname-flavor its-host) ()
  'its-pathname)

(defprop :alto alto-host net:host-type-flavor)
(defprop :tftpsp alto-host net:host-type-flavor)	;for MIT-SPOOLER
(defprop :ifs alto-host net:host-type-flavor)		;for MIT-IFS
(defprop :spruce alto-host net:host-type-flavor)	;for MIT-TREMONT

(defflavor alto-host () (net:host-alto-mixin tops20-tenex-active-host-mixin
			 active-pathname-host net:host))

(defmethod (:pathname-flavor alto-host) ()
  'alto-pathname)

(defprop :vm370 vm370-host net:host-type-flavor)
(defprop :vm vm370-host net:host-type-flavor)

(defflavor vm370-host () (neti:host-vm370-mixin active-pathname-host net:host))

(defmethod (:pathname-flavor vm370-host) ()
  'vm370-pathname)

;;; These system type are known not to have file systems.
(defprop :minits net:host net:host-type-flavor)

(defun add-file-computer (host)
  (unless (typep host 'net:basic-host)
    (setq host (net:parse-host host)))
  (send host ':maybe-decache-name-as-file-computer)
  (without-interrupts
    (si:push* host *pathname-host-list*)))

(defgeneric file-access-path-open
	    (file-access-path translated-pathname pathname &rest open-keywords))
						    
;; --- D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")Default is 30 minutes.
0(cl:defparameter *default-file-control-connection-lifetime* 108000. "in 60ths of a second")

1;;; Set the default from the site object.
0(defun set-default-file-control-connection-lifetime ()
  (let ((default (or (send net:*local-site* :get :default-file-control-lifetime)
		     (send net:*local-site* :user-get :default-file-control-lifetime))))
    (when default
      (condition-case (error)
	   (cond
	     ((stringp default)
	      (condition-case (error)
		   1;; Is it a string specifying a time-interval?
0		   (setq *default-file-control-connection-lifetime*
			 (accept-from-string 'time:time-interval-60ths default))
		 (error
		   1;; Is it a string of an integer (this will throw to the outside
		   ;;  condition-case in the event of an error).
0		   (setq *default-file-control-connection-lifetime*
			 (si:parse-integer default nil 10. 0 si:*largest-fixnum*)))))
	     ((numberp default)
	      (setq *default-file-control-connection-lifetime* default)))
	 (error)))))

(add-initialization "Set default file-control-lifetime"
		    '(set-default-file-control-connection-lifetime)
		    '(site normal))

;;;; Base flavor for generic file access handling.
(defflavor file-access-path
	(host
	 (open-streams nil)
	 ;; Next two not always meaningful (e.g. for FEP:)
	 service-access-path
	 (control-connection-lifetime *default-file-control-connection-lifetime*)
	 )
	()
  (:method-combination :peek-file-system-header (:list :most-specific-last)
                       :peek-file-system (:list :most-specific-last))
  (:initable-instance-variables host service-access-path)
  (:gettable-instance-variables host open-streams control-connection-lifetime)
  )

;;; >>> Must come after DEFFLAVOR for cold load. <<<
(defgeneric file-access-path-login (file-access-path login-p &key force-password)
  (:method (file-access-path)
   (ignore login-p force-password)))

(defmethod (make-instance file-access-path) (&rest ignore)
  (when host
  (let ((ccl (send host ':get ':file-control-lifetime)))
    (when ccl
      (let ((ccl-parsed 
	      (condition-case (error)
		   (cl:parse-integer ccl :radix 10. :sign-allowed nil)
		 (error
		   (tv:notify
		     nil "File Access Path: Invalid FILE-CONTROL-LIFETIME ~S for host ~A. ~A"
		     ccl host (dbg:report-string error))
		   (return-from make-instance nil)))))
	(setq control-connection-lifetime ccl-parsed))))))

(defmethod (:print-self file-access-path) (stream ignore slashify)
  (if slashify
      (si:printing-random-object (self stream :typep)
	(princ self stream))
    (princ (send host ':short-name) stream)
    (when (variable-boundp service-access-path)
      (format stream " using ~A"
	      (neti:protocol-name (neti:service-access-path-protocol service-access-path))))))

(defmethod (:add-stream file-access-path) (stream)
  (push stream open-streams)
  (fs:add-open-stream stream))

(defmethod (:delete-stream file-access-path) (stream)
  (setq open-streams (delq stream open-streams))
  (fs:delete-open-stream stream))

(defmethod (:close-all-files file-access-path) (&key (mode :abort)
						     (query-each nil)
						     (verbose nil))
  ;; This didn't formerly type out (before I added the :verbose keyword argument)
  ;; so I propagated that `bug' by defaulting the argument to NIL.  However, all
  ;; other methods for :close-all-files default the argument to T, so maybe this
  ;; should, too? -kmp 19-Sep-89
  (loop for stream in open-streams
	nconc (si:close-open-file stream :mode mode :query query-each :verbose verbose)))

(defmethod (:reset file-access-path :default) ())

;;; The default is not to have completion at all
;;+++ replaces something on PATHNAME
(defmethod (:complete-string file-access-path) (default string ignore)
  default
  (values string nil nil))

;;+++ replaces something on PATHNAME; subfun used to be a DEFUN-METHOD.
(defmethod (:multiple-file-plists file-access-path) (files options)
  (cl:apply #'default-pathname-multiple-file-plists files options))

;;+++ replaces something on PATHNAME
(defmethod (:undelete file-access-path) (pathname)
  (change-file-properties pathname t ':deleted nil))

;;+++ replaces something on PATHNAME
;;; This isn't implemented as a separate file subprotocol, just use the directory
;;; 11/18/82- Sys 221 - We can at least recognize and generate file-not-found for
;;; all servers.  Directory-not-found will still signal.
(defmethod (:properties file-access-path) (pathname)
  (simulate-file-properties-with-directory-list pathname))

(defun simulate-file-properties-with-directory-list (pathname)  
  (let ((dir (send pathname ':directory-list '(:deleted))))
    (cond ((null (cdr dir))
	   (error 'file-not-found-for-properties ':pathname pathname))
	  (t (values (cadr dir) (get (car dir) ':settable-properties))))))

;;; For things in which homedir is not a meaningful concept, the quiet-user-homedir
;;; function still gets called, so return any old thing.
(defmethod (:homedir file-access-path) (pathname ignore)
  (make-pathname ':host host
		 ':device (send pathname ':primary-device)
		 ':directory '("FOO")))

;;; This is a list of messages for which a different error is signalled.
;;+++ some of these replace something on PATHNAME too.
(defvar *known-file-operations*
  '(:all-directories :change-properties :create-directory :create-link
    :delete :directory-list :expunge :homedir :open :rename))

(defmethod (:unclaimed-message file-access-path) (operation &rest args)
  (if (memq operation *known-file-operations*)
      (error 'unknown-operation ':operation operation)
    (signal-proceed-case ((new-message) 'si:unclaimed-message
					':object self
					':message operation
					':arguments (copylist args))
      (:new-message (lexpr-funcall self new-message args)))))

(defmethod (:peek-file-system-header file-access-path) ()
  (tv:scroll-parse-item
    `(:mouse
      (nil :kbd (send :peek-file-access-path-menu ,self)
	   :documentation "Menu of useful things to do to this file access path.")
      :string ,(format nil " Access path to ~A" self))))

(defmethod (:peek-file-system file-access-path :default) ()
  (tv:scroll-maintain-list `(lambda () (send ',self ':open-streams))
			   #'(lambda (stream) (send stream ':peek-file-system 3))))

;;;; Some other access path mixins.

;;; This defined the :DIRECTORY-LIST operation in terms of the :DIRECTORY-STREAM ascii stream operation.
;;; Used by QFILE.
(defflavor directory-stream-file-access-path-mixin () ()
  (:required-methods :directory-stream :properties-stream)
  (:required-flavors file-access-path))

(defmethod (:directory-list directory-stream-file-access-path-mixin) (pathname options)
  (with-open-stream (stream (send self ':directory-stream pathname (remq ':sorted options)))
    (if (errorp stream)
	stream
      (loop with in-order-p = t
	    with last-pathname
	    with should-be-sorted = (memq ':sorted options)
	    as entry = (read-directory-stream-entry stream pathname)
	    until (null entry)
	    collect entry into dir-list
	    when (and should-be-sorted in-order-p last-pathname (car entry)
		      (not (send last-pathname ':sort-lessp (car entry))))
	      do (setq in-order-p nil)
	    when (car entry)
	      do (setq last-pathname (car entry))
	    finally
	    (and should-be-sorted (not in-order-p)
		 (let ((null-elem (assq nil dir-list)))
		   (and null-elem (setq dir-list (delq null-elem dir-list)))
		   (setq dir-list (sortcar dir-list #'pathname-lessp))
		   (and null-elem (push null-elem dir-list))))
	    (return dir-list)))))

(defmethod (:properties directory-stream-file-access-path-mixin) (pathname &optional handle)
  (condition-case ()
      (with-open-stream (stream (send self ':properties-stream pathname handle))
	(let ((changeables
		(loop with line = (funcall stream ':line-in)
		      with len = (array-active-length line)
		      with index = 0
		      as token-start = (string-search-not-char #\sp line index)
		      while token-start
		      as token-end = (or (%string-search-char #\sp line token-start len) len)
		      as token-len = (- token-end token-start)
		      collect (loop named foo
				    for x in *known-directory-properties*
				    do (loop for y in (cdr x)
					     when (%string-equal line token-start
								 (get-pname y) 0
								 token-len)
					     do (return-from foo y))
				    finally (return (intern
						      (substring line token-start token-end)
						      si:pkg-keyword-package)))
		      do (setq index token-end))))
	  (values (read-directory-stream-entry stream pathname) changeables)))
    ;;Compatibility with earlier releases.
    (unknown-operation
      (simulate-file-properties-with-directory-list pathname))))


;;; Access paths for which logging in, user names, homedirs, etc. are a
;;; meaningful concept.

(defgeneric file-access-path-add-capability-improves-access (file-access-path) 
  "T if a sensible response to an access problem is to add a capability"
  (:method (file-access-path) nil))

(defgeneric file-access-path-login-improves-access (file-access-path)
  "T if a sensible response to an access problem is to login"
  (:method (file-access-path) nil))

(defflavor user-file-access-path
	((host-user-id nil)
	 (host-password nil)			;Remembered under user option
	 (homedir-pathname nil))
	(file-access-path)
  (:gettable-instance-variables homedir-pathname)
  (:settable-instance-variables homedir-pathname))

(defmethod (:host-user-id user-file-access-path) ()
  (when (null host-user-id)
    (multiple-value (host-user-id host-password)
      (send si:*user* ':host-user-id host)))
  (values host-user-id host-password))

(defvar *remember-passwords* nil "Remember the last password given to each host.
Note that it is very easy for someone else to access this information once remembered.")

(defmethod (:set-host-user-id user-file-access-path) (new-user-id &optional new-password)
  (setq host-user-id new-user-id)
  (when (and new-password *remember-passwords*)
    (setq host-password new-password)))

;; *** New Error System ***
;; An optional argument should say whether this information is important.
;; If not, and the connection can't be established, punt and return a good guess.
;; There should probably be some state somewhere in hosts which says that the
;; last time a connection was attempted, it failed.
;; This can replace all the QUIET-HOMEDIR bullshit.
;;; CARE-A-LOT-P means go to the trouble of finding out if not known.
(defmethod (:homedir user-file-access-path) (pathname care-a-lot-p)
  (cond (homedir-pathname)
	((not care-a-lot-p)
	 (send host :default-homedir (or (send self :host-user-id) "FOO")))
	(t
	 (send self :update-homedir pathname)
	 homedir-pathname)))

;;++ These replace methods on PATHNAME for :HOMEDIR and :QUIET-HOMEDIR
(defmethod (:update-homedir user-file-access-path :default) (pathname)
  (setq homedir-pathname
	(let ((default (send self :homedir pathname nil)))
	  (prompt-and-read
	    `(:pathname :default ,default)
	    "What is the home directory for user ~A on host ~A (default to ~A)? "
	    (send self :host-user-id) host default))))

(defmethod (fs:file-access-path-login user-file-access-path :default) (&rest ignore))

(defmethod (:reset-host-user-id user-file-access-path) ()
  (setq host-user-id nil
	host-password nil
	homedir-pathname nil))

(defmethod (:peek-file-system-header user-file-access-path) ()
  (tv:scroll-parse-item
    " "
    `(:function,#'cdr
      (,(locate-in-instance self 'host-user-id)) nil
      ("~:[Not logged in~;~:*User ID: ~A~]"))))

;;;; Passwords

;;; This is the highest level function.  It is not called by any file code.  It is called
;;; by the tape software (SYS: LMTAPE; RTAPE-USER).
(defun file-get-user-id-and-password (host &optional host-user-id)
  (get-user-id-and-password (send host ':file-access-path) host-user-id nil t))

;;; This is the function called by the login code for each access path.
;;; It is called if not logged in, or if login fails.
;;; HOST-USER-ID is the user name being used for this host, or NIL if not known yet.
;;; HOST-PASSWORD is the password being used for this host.  Actually it is only important
;;;  whether or not it is NIL.
;;; CONDITION is the condition that got us here, such as INVALID-PASSWORD.  NIL means we
;;;  got here because of not being logged in before sending a command.
(defun get-user-id-and-password (access-path host-user-id host-password condition)
  (declare (values host-user-id host-password))
  ;; Some access paths may not distinguish various login failures -- for them we
  ;; must assume we need as much as possible.
  (let* ((funny-condition (cond ((null condition) nil)
				((symbolp condition)
				 (setq condition nil)
				 t)
				(t
				 (not (or (typep condition 'not-logged-in)
					  (typep condition 'unknown-user)
					  (typep condition 'invalid-password))))))
	 (logged-in (and (instancep condition)
			 (not (typep condition 'not-logged-in))))
	 (print-error-message (cond (funny-condition t)
				    ((not logged-in) nil)
				    ((and (null host-password)
					  (typep condition 'invalid-password))
				     nil)
				    (t t)))
	 (need-new-user (cond ((not logged-in)
			       (multiple-value (host-user-id host-password)
				 (send access-path ':host-user-id))
			       (null host-user-id))
			      ((typep condition 'unknown-user) t)
			      (t (null host-user-id))))
	 (need-password (or funny-condition
			    (and condition
				 (typep condition 'invalid-password)))))
    (multiple-value-bind (type uid pass)
	(signal 'login-required
		':access-path access-path ':host-user-id host-user-id
		':original-condition condition
		':print-error-message print-error-message
		':need-new-user need-new-user ':need-password need-password
		':proceed-types '(:password))
      (if (eq type ':password)
	  (setq host-user-id uid host-password pass)
	(multiple-value (uid pass)
	  (send access-path ':prompt-for-user-and-password
		host-user-id condition print-error-message
		need-new-user need-password))
	(unless (and (null pass) (eq host-user-id uid))
	  (setq host-user-id uid host-password pass)))))
  (send access-path ':set-host-user-id host-user-id host-password)
  (values host-user-id host-password))

(defflavor login-required
	(access-path
	 (host-user-id nil)
	 (original-condition nil)
	 (print-error-message t)
	 (need-new-user t) (need-password t))
	(condition)
  :initable-instance-variables
  :gettable-instance-variables)

(defmethod (:report login-required) (stream)
  (format stream "Host ~A requires login~@[ for user ~A~]~@[:  ~A~]"
	  (send access-path ':host) host-user-id original-condition))

(defmethod (:proceed login-required :password) (&optional (uid nil uidp) pwd)
  (or uidp (multiple-value (uid pwd)
	     (send access-path ':prompt-for-user-and-password
		   host-user-id original-condition print-error-message
		   need-new-user need-password)))
  (values ':password uid pwd))

(compile-flavor-methods login-required)

(defmethod (:prompt-for-user-and-password user-file-access-path)
	   (host-user condition print-error-message need-new-user need-password)
  (prompt-for-user-and-password host host-user condition print-error-message
				need-new-user need-password
				(send self ':allow-anonymous-logins)
				(send self ':no-passwords)))

(defun prompt-for-user-and-password (host host-user-id condition print-error-message
				     need-new-user need-password
				     allow-anonymous no-passwords
				     &aux (stream query-io) password char)
  (declare (values user-id password))
  (cond ((and print-error-message condition)
	 (send stream ':fresh-line)
	 (send condition ':report-without-pathname stream)))
  (loop doing
    (when need-new-user
      ;; Temporary.  To be flushed when the input editor really has a typein stream.
      (si:with-ie-typein (query-io)
	(loop doing
	  (setq host-user-id
		(prompt-and-read
		  :string-or-nil
		  "Enter user name for host ~A~@[, or type ~*~:C to login anonymously~]: "
		  host allow-anonymous #\return))
	  (when host-user-id
	    (loop-finish))
	  (when allow-anonymous
	    ;; Do not leave as NIL, so that a login failure will print the error message.
	    ;; :allow-anonymous-login can return a string or T.  Use the string if returned
	    (setq host-user-id (if (stringp allow-anonymous) allow-anonymous "ANONYMOUS")
		  password
		  (destructuring-bind (user host)
		      (send si:*user* :mail-address)
		    ;; It would be easy to use the ZMAIL functions for this stuff but we don't
		    ;; want to be dependent on ZMAIL here since that is loaded later
		    (let ((domain-name (send host :internet-domain-name)))
		      (unless domain-name
			(cond ((neti:ns-eq (send (send host :primary-name) :namespace)
					   neti:*domain-namespace*)
			       (setq domain-name (send host :name)))
			      (t
			       (setq domain-name
				     (format nil "~A~@[.~A~]" host
					     (send (send (send host :primary-name) :namespace)
					      :internet-domain-name))))))
		      (format nil "~A@~A" user domain-name))))
	    (loop-finish))
	  (beep))))
    (when (or no-passwords (not need-password))
      (loop-finish))
    ;; Temporary.  To be flushed when the input editor really has a typein stream.
    (si:with-ie-typein (query-io)
      (multiple-value (password char)
	(with-stack-list (prompt "Password for logging in to ~A as ~A (or ~:C to change user id): "
				 host host-user-id #\escape)
	  (readline-no-echo stream
			    :terminators '(#\return #\line #\end #\escape)
			    :prompt prompt)))
      (unless (char-equal char #\escape)
	(loop-finish))
      (send stream ':string-out " [New user id]"))
    (setq need-new-user t
	  need-password nil
	  password nil))
  (values host-user-id password))

1;;; Return T or a string if anonymous login is allowed.  The string is used if returned.
0(defmethod (:allow-anonymous-logins user-file-access-path) () ())

(defmethod (:no-passwords user-file-access-path) () ())

(defflavor no-password-access-path-mixin () ()
  (:required-flavors user-file-access-path))

(defmethod (:no-passwords no-password-access-path-mixin) () t)

(defflavor allow-anonymous-logins-access-path-mixin () ()
  (:required-flavors user-file-access-path))

(defmethod (:allow-anonymous-logins allow-anonymous-logins-access-path-mixin) () t)

;;; Log in or out all open connections.
(defun file-login (login-p)
  (loop for host in *pathname-host-list*
	do (send host ':send-if-handles ':login login-p)
	unless login-p
	do (send host ':send-if-handles ':reset-host-user-id)))

(add-initialization "File Login" '(file-login t) '(login))
(add-initialization "File Logout" '(file-login nil) '(logout))

(defun file-host-reset ()
  (dolist (host *pathname-host-list*)
    (send host ':send-if-handles ':file-reset)))

(add-initialization "Reset file hosts" '(file-host-reset) '(:system))

(defun forget-all-file-access-paths ()
  (dolist (host *pathname-host-list*)
    (send host ':send-if-handles ':file-reset t)))

;Moved to before NETI:RESET, since this might try to use the network
;(ADD-INITIALIZATION "Forget All File Access Paths" '(FORGET-ALL-FILE-ACCESS-PATHS)
;		    '(:SYSTEM-SHUTDOWN))

(si:define-gc-optimization forget-all-file-access-paths :layered-ids-release
  (:documentation "Reset all file access paths")
  (:before-flip (ignore)
    (forget-all-file-access-paths)))

;;;; Service interface

(defprop define-file-protocol net:define-protocol zwei:definition-function-spec-type)

(defmacro define-file-protocol (protocol-name (base-medium) &body options)
  (let ((access-path-flavor nil)
	(access-path-flavor-function nil)
	(saved-options))
    (loop for option in options
	  unless (selectq (car option)
		   (:access-path-flavor
		    (if (atom (cadr option))
			(setq access-path-flavor (cadr option))
		      (setq access-path-flavor-function
			    `(defun ,(intern (format nil "~A-FILE-ACCESS-PATH-FLAVOR-FUNCTION"
						     protocol-name))
				    . ,(cdr option))))
		    t))
	  collect option into saved
	  finally (setq saved-options saved))
    (unless (or access-path-flavor access-path-flavor-function)
      (ferror "You must specify the access path flavor for ~A" protocol-name))
    `(progn 'compile
       ,@(and access-path-flavor-function
	      `((local-declare ((function-parent ,protocol-name net:define-protocol))
		  ,access-path-flavor-function)))
       (net:define-protocol ,protocol-name (:file ,base-medium)
	 ,@(and access-path-flavor-function
		`((:property :access-path-flavor-function
		   ,(cadr access-path-flavor-function))))
	 ,@(and access-path-flavor
		`((:property :access-path-flavor ,access-path-flavor)))
	 (:invoke invoke-file-service)
	 . ,saved-options))))

(defun invoke-file-service (service-access-path &rest ignore)
  (let* ((host (neti:service-access-path-host service-access-path))
	 (protocol (neti:service-access-path-protocol service-access-path))
	 (flavor (getl (locf (neti:protocol-property-list protocol))
		       '(:access-path-flavor :access-path-flavor-function))))
    (setq flavor (selectq (first flavor)
		   (:access-path-flavor (second flavor))
		   (:access-path-flavor-function (funcall (second flavor) host))))
    (make-instance flavor ':host host ':service-access-path service-access-path)))

;;;; Encapsulation for fonted characters.
;;; Mix this into any access path supporting the :open protocol, that encodes characters
1;;; by means of the epsilon-escape protocol.

;;; The access-path must support (2 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB"):fake-characters t1, meaning to open it as a character file,
;;; but return a binary stream.  2:characters :without-fonts1 means what 2:characters t1 used
;;; to mean, namely 2:element-type 'cl:string-char1.

0(defflavor font-encapsulating-access-path-mixin ()
	   ())

1;;; This whopper provides support for the %return-binary-stream-for-character-file
;;; keyword, which is used by file servers and other consenting adults to 
;;; get a stream of 8 bit bytes that they can trans-ship to the network.
;;; In addition, these streams have to support a protocol for finding out the 
;;; underlying file type, which is the %file-stream-file-element-type protocol.

0;;; On or about 7/11/89, jrd did some work on revamping this stuff.  The
;;; overall strategy is the same, but in the new regime, the 'outer'
;;; epsilon-encapsulating stream is a buffered stream, and the 'inner'
;;; stream is a string-char stream, as opposed to a binary stream.
(defwhopper (file-access-path-open font-encapsulating-access-path-mixin)
	    (real-pathname
	      command-pathname
	      &rest rest-list
	      &key
	      if-exists
	      (direction ':input)
	      element-type
	      ((%return-binary-stream-for-character-file
		 %return-binary-stream-for-character-file))
	      &allow-other-keys)
  (si:with-rem-keywords (rest-list rest-list '(%return-binary-stream-for-character-file))
    (flet ((continue (&optional force-binary-p)
	     (if force-binary-p
		 (with-stack-list* (new-rest-list :fake-characters t rest-list)
		   (lexpr-continue-whopper real-pathname command-pathname
					   new-rest-list))
		 (lexpr-continue-whopper real-pathname command-pathname
					 rest-list))))
      (cl:case direction
	(:input
	  (if (or (eq element-type :default)
		  (and (cl:subtypep element-type 'cl:character)
		       (not (cl:subtypep element-type 'cl:string-char))))
	      (let ((stream nil))
		(unwind-protect-case ()
		    (progn
		      (setq stream (continue %return-binary-stream-for-character-file))
		     
		      ;; One of the most scrutinized (at least by jrd)
		      ;; pieces of code in the system.  Decide whether to
		      ;; return the stream we just got back from the
		      ;; continuation, or to wrap it with an epsilon
		      ;; decoding stream.  Conditions under which we DO
		      ;; want to encapsulate:
		      ;;
		      ;; We were NOT instructed (by %return-binary-...)
		      ;;   not to encapsulate, and...  
		      ;; The inner-stream deals in characters, as
		      ;;   indicated by the :CHARACTERS message.
		      ;;
		      ;; Note that this scheme didn't work in the bad old
		      ;; days of binary inner streams, as :characters
		      ;; didn't tell you anything, so you had to use
		      ;; Benson's kludge of returning a second value from
		      ;; the continuation.  That's no longer necessary,
		      ;; we always use a character-ish stream when
		      ;; hacking character files.
		      ;; 
		      (if (or %return-binary-stream-for-character-file
			      (not (send stream ':characters)))
			  stream
			  (let* ((char-stream (make-instance 'si:string-char-epsilon-input-stream
							     :stream stream))
				 (attribute-list
				   (let ((cl:*error-output* 'si:null-stream))
				     ;; having shut up the bloody bazuki,
				     ;; go fish for some attributes without bitching
				     ;; about others that are busted.
				     (fs:read-attribute-list nil char-stream)))
				 (fonts (cl:getf attribute-list :fonts))
				 (japanese (cl:getf attribute-list :japanese)))
			    ;; Set Japanese first, so Fonts: can explicitly override.
			    (when japanese
			      (send char-stream :set-japanese japanese))
			    (when fonts
			      (send char-stream :set-types-from-font-list fonts))
			    (delete-open-stream stream)	;Hide the underlying stream
			    (add-open-stream char-stream)
			    char-stream)))
		  (:abort
		    (when stream
		      (send stream :close :abort)))))
	      (continue)))
	(:output
	  (if (and (cl:subtypep element-type 'cl:character)
		   (not (cl:subtypep element-type 'cl:string-char)))
	      (if %return-binary-stream-for-character-file (continue t)
		  (let ((stream nil))
		    (unwind-protect
			(let* ((stream-off-bof-p 
				 (plusp (send (setq stream (continue))
					      :read-pointer)))
			       (appending (and stream-off-bof-p
					       (eql if-exists ':append)))
			       (char-stream (make-instance 'si:string-char-epsilon-output-stream
							   ':stream stream)))
			  (when appending
			    (send char-stream :reset-character-style-state))
			  (delete-open-stream stream)	;Hide the underlying stream
			  (add-open-stream char-stream)
			  (setq stream nil)	;Don't close it
			  char-stream)
		      (when stream
			(send stream :close :abort)))))
	      (continue)))
	(otherwise (continue))))))

(defun returned-binary-stream-for-character-file-p (stream)
  (and (equal (send stream :element-type) '(cl:unsigned-byte 8.))
       (cl:subtypep (%file-stream-file-element-type stream) 'cl:character)))

1;;; These are the element types supported by most access paths.

0(defconst *widely-supported-types*
	  '(cl:character cl:string-char
	    (cl:unsigned-byte 8) (cl:unsigned-byte 16.) (cl:unsigned-byte *)))

(defun check-stream-element-type (element-type &key
				  protocol
				  (legal-types *widely-supported-types*)
				  (signalling-function #'ferror)
				  (test #'cl:subtypep))
  (when element-type
    (unless (or (eq element-type :default)
		(cl:member element-type legal-types	1;Already decoded, just check
0			   :test test))
      (funcall signalling-function
	       "~A is not a supported stream element type~:[~*~; for ~A~]."
	       (if (fboundp 'print-type-description)
		   (let ((str (with-output-to-string (str)
				(print-type-description element-type str))))
		     (setf (aref str 0)
			   (char-upcase (aref str 0)))
		     str)
		   "<Cold load can't print type>")
	       protocol protocol))))

1;;; Generic function protocol that holds up the other end of the Release 7
;;; file server semi-kludge.  Returns the element type of the file
;;; on the other end of the stream, which is potentially different from the
;;; element type of the stream itself.

0(defgeneric %file-stream-file-element-type (stream)
  "Returns the element type as stored by the file system, even if different
from that of the stream.  Encapsulating streams are expected to pass this
through."
  (:method (si:stream)
   (let ((element-type (send self :element-type)))
     (if (eq element-type 'cl:string-char) 'cl:character
	 element-type))))

(defflavor %file-stream-stored-file-element-type-mixin
	(file-stored-element-type)
	()
  (:writable-instance-variables (%file-stream-file-element-type file-stored-element-type))
  (:initable-instance-variables (%file-stream-file-element-type file-stored-element-type)))

(defun element-type-from-old-fs-info (characters-p byte-size)
  (cond ((eq characters-p ':without-fonts) 'cl:string-char)
	((eq characters-p ':default) ':default)
	(characters-p 'cl:character)
	((eq byte-size ':default) '(cl:unsigned-byte *))	;can anything handle this?
	((null byte-size) '(cl:unsigned-byte 16.))
	((< byte-size 32.)			;characters nil but no byte size.
	 `(cl:unsigned-byte ,byte-size))
	(t 'cl:fixnum)))
