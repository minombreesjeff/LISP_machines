;;; -*- Mode: Lisp; Syntax: Zetalisp; Package: File-system; Base: 8; Lowercase: T -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;;  Logical pathnames


;;;  Logical pathname translation is driven by two tables.  The first is an
;;;  alist of wild-carded logical pathnames paired with wild-carded physical
;;;  pathnames.  This is the TRANSLATION table.  The second is a table of
;;;  rules, keyed by the system-type of the destination host and a wild-card
;;;  pathname.
;;;
;;;  The actual translation of logical pathnames is performed by translation rules.
;;;  These rules are defined on a global, per-host, or per-host-per-site basis.
;;;
;;;   Each translation rule is of the form:
;;;   pattern-pathname transformation-type &rest transformation-arguments
;;;
;;;  When a :TRANSLATED-PATHNAME message is sent to a logical pathname, first
;;;  the table of translation is searched to find a pattern which matches the
;;;  pathname being translated.  The resulting pair of wild logical pathname
;;;  and wild physical pathname are then retained for the translation rule
;;;  to be invoked.  The system-type of the physical pathname is used as one
;;;  part of the pattern for the search for the translation rule.
;;;
;;;  Once the translation-pair is found in the translation table,
;;;  the table of translations is searched for a pattern-pathname which
;;;  matches the original pathname.  When one is found, the transformation-function
;;;  associated with the transformation-type is called on the logical pathname and
;;;  physical pathname of the translation-pair, the pathname being translated, and the
;;;  transformation-arguments.
;;;
;;;  The transformation-function can return either NIL, meaning to continue the search, or
;;;  a physical pathname to use as the result of translating that pathname.  If the
;;;  search terminates without finding a match, the normal translation mechanism is allowed
;;;  to translate the pathname.
;;;
;;;  The search proceeds in the order given, but to allow certain optimizations, the
;;;  order is constrained to be from least-abstract pathname to most-abstract.
;;;  "Abstractness" for this purpose can be defined in general terms as how many
;;;  wild-cards a pathname has, how far to the left.
;;;
;;;  To be more precise, consider the pathname components DIRECTORY, NAME, TYPE, and VERSION,
;;;  in that order.  We consider VERSION to be the least-abstract place for a wildcard to
;;;  appear, and DIRECTORY to be the most.  We only are concerned with whether there is
;;;  any wildcard in the component; thus "*-MIC" and "*" are both equally abstract.
;;;  Thus we can rate the abstractness of any pathname on a scale of 0 to 15, by assigning
;;;  binary weights:  VERSION=1, TYPE=2, NAME=4, and DIRECTORY=8.
;;;
;;;  The following transformation types are defined:
;;;
;;;  :TRANSLATE-WILD
;;;    This is the "usual" translation rule.  It uses :TRANSLATE-WILD-PATHNAME-REVERSIBLE
;;;    to perform the translation, as specified by the translation pair.
;;;
;;;  :VMS-HEURISTICATE
;;;    This translation rule tries hard to make understandable VMS pathnames out of
;;;    longer, hypenated filenames.  It works for both :VMS and :VMS4 hosts.
;;;    Produces usually-understandable, hopefully-unique, legal names and directories.
;;;
;;;  :VMS-HEURISTICATE-NAME
;;;    like :VMS-HEURISTICATE but only heuristicates the name.
;;;
;;;   :VMS-HEURISTICATE-DIRECTORY
;;;    like :VMS-HEURISTICATE but only heuristicates the directory.
;;;
;;;  :NEW-PATHNAME &rest arglist
;;;    The arglist is made up of keyword pairs like to :NEW-PATHNAME, using
;;;    :DEVICE, :DIRECTORY, :NAME, :TYPE, and :VERSION.  (The :RAW- versions are NOT
;;;    supported).  The translation is performed as in :TRANSLATE-WILD, but with the
;;;    indicated components substituted before creating the pathname.
;;;
;;;  :VMS-NEW-PATHNAME &rest arglist
;;;     Like :NEW-PATHNAME, but performs VMS heuristics on the directory like
;;;     :VMS-HEURISTICATE-DIRECTORY.
;;;
;;;  :VMS-FONT &optional renamings
;;;    The :NAME component of the pathname is parsed into NAME, SIZE, and FACE.
;;;    (the SIZE is made up of digits near the right side of the filename, with
;;;     the FACE being the characters (if any) on the right, and the NAME being
;;;     the characters on the left.)  If a pathname does not have any digits, the
;;;    transformation does not apply.  The RENMAINGS argument is an ALIST, of the
;;;    form (... (name replacement) ...).  The NAME component is looked up in the
;;;    renamings alist, and if found, the replacment value is used in it's place.
;;;    Then then name (or its replacment) is examined to see if it will fit in
;;;    the available space, and truncated if necessary.  Then the result is taken
;;;    together with the SIZE and FACE to produce a new filename.
;;;    The directory component is subject to full heuristication.
;;;
;;;  :VMS-MICROCODE
;;;    The :NAME component is parsed into words.  Each word is looked up in the
;;;    alist *UNIX-MICROCODE-TRANSLATION-ALIST*.  If found, it is replaced with
;;;    the replacement (a single character, except "MIC" maps to "") found in the
;;;    second element of the alist bucket.  This sequence of characters is then
;;;    concatenated to produce the new filename.
;;;    The directory component is subject to full heuristication.
;;;
;;;  :UNIX-FONT &optional renamings
;;;    See :VMS-FONT; the same, but restricts to UNIX restraints.
;;;
;;;  :UNIX-MICROCODE
;;;    The :NAME component is parsed into words, and substitutions made from
;;;    *UNIX-MICROCODE-TRANSLATION-ALIST*, as for :VMS-MICROCODE.  Then, if
;;;    the name ends in a digit, a "+" is added to separate it from the version
;;;    number (or "" if NIL or "*" if :WILD), which then follows.  This is then
;;;    used as the :NAME component.  The type is handled via the normal mechanisms.
;;;
;;;  :UNIX-TYPE-AND-VERSION &optional renamings
;;;    The :NAME component is matched against the RENAMINGS alist.  If it is found,
;;;    the second element of the alist bucket is used instead.  Then, if the last
;;;    character of the name (or the replacement) is a digit, a "+" is added to
;;;    the end.  Then, the version number (or "" if NIL or "*" if :WILD) is added
;;;    to the end.  This is then used as the :NAME component.  The type is handled
;;;    via the normal mechanisms.
;;;
;;;  :SITE-DIRECTORY &rest arglist
;;;    Substitutes the :SITE-DIRECTORY attribute from the local site object, for the
;;;    host and directory.  The arglist is like for :NEW-PATHNAME.
;;;
;;;  :ISO9660-HEURISTICATE
;;;    ISO9660 pathnames are limited to 31 characters in each component; for the
;;;    "name", the limit applies to the name, type, and intervening period taken
;;;    together.  The character set is limited to uppercase letters, numbers, and
;;;    underscores.  So each component is upcased, "-" are changed to "_", and other
;;;    punctuation is dropped.  Then each is truncated if necessary to 31 characters.

;;; Matching takes place IN THE REVERSE OF THE ORDER OF DEFINITIONS.
;;; But before that, it looks for wild version, type, name, and directory
;;; in that order, in increasing binary order.

;;; Pathname to match against, function, and extra arguments.
;;; The function is called against the pathname which matched plus the extra arguments.

(defstruct (translation-rule :list :conc-name (:make-list (:area pathname-area)))
  key
  system-type
  pathname
  type
  arguments)


;;; Find any translation for this component for this type of system.
;;; Return the translated pathname.  Searches accross all :WILD matchers
;;; that may wish to talk to this (up to 16 combinations to try, but we
;;; eliminate the redundant ones).  Hopefully most of them will come up
;;; empty.

(defmacro generate-new-translate-internal-calls-cases (var pathname from-pathname to-pathname
						       system-type directory nam type version)
  `(or
     ,@(loop for i to #o17
	     collect
	     `(unless (not (zerop (logand ,var ,i)))
		(send self :translate-internal ,pathname ,from-pathname ,to-pathname
		      ;; The following makes up the hash key
		      ,system-type
		      ,(if (ldb-test (byte 1 3) i) :wild directory)
		      ,(if (ldb-test (byte 1 2) i) :wild nam)
		      ,(if (ldb-test (byte 1 1) i) :wild type)
		      ,(if (ldb-test (byte 1 0) i) :wild version))))
     (send self :invoke-translation pathname from-pathname to-pathname
	   *default-translation-rule*)))


(defun compute-wild-mask (pathname)
  (let ((directory (send pathname :raw-directory))
	(nam (send pathname :raw-name))
	(type (send pathname :raw-type))
	(version (send pathname :version))
	(mask 0))
    (when (or (eq (send pathname :directory) :wild)
	      (null directory))
      (setf (ldb-test (byte 1 3) mask) 1))
    (when (or (eq (send pathname :name) :wild)
	      (null nam))
      (setf (ldb-test (byte 1 2) mask) 1))
    (when (or (eq (send pathname :type) :wild)
	      (null type))
      (setf (ldb-test (byte 1 1) mask) 1))
    (when (or (eq (send pathname :version) :wild)
	      (null version))
      (setf (ldb-test (byte 1 0) mask) 1))
    mask))

(defvar *check-for-multiple-translations* t)	;T or :EXTRA

(defflavor logical-host
	   (name				;logical device name
	    (default-host)			;Default host that turns into
	    (translations)			;Alist of wild logical to physical
	    (permanent-translation-rules)	;Rules for translating added by programs
						; (like DEFSYSTEM).
	    (site-translation-rules)		;Rules for translating at this site
	    (translation-rules)			;Rules for handling of actual translations
	    (translation-rule-table)
	    (translation-tick 0)		;Changes when the translations change
	    (old-global-translation-rules)	;To notice when this changes.
	    (journal-directory-table (cl:make-hash-table)))	;cache of these
  (net:no-device-host-mixin net:pathname-host-mixin net:basic-host)
  (:gettable-instance-variables name translation-rule-table)
  (:initable-instance-variables name default-host translations translation-rules)
  (:settable-instance-variables default-host translations translation-rules
   site-translation-rules permanent-translation-rules old-global-translation-rules
   translation-tick))

(defflavor logical-pathname
	((translated-pathname nil)	;A cache to save time, also for property moving
	 (translation-tick nil))	;Host's tick when TRANSLATED-PATHNAME was valid
	(no-device-mixin hierarchical-directory-no-patch-mixin upper-case-only-mixin
			 pathname))

(defvar *default-translation-rule*
	(make-translation-rule type :translate-wild))

(defvar *global-translation-rules* nil)

(defmethod (make-instance logical-host) (&rest ignore)
  (setq translation-rule-table (neti:make-pathname-hash-table self)))

(defmethod (:pathname-flavor logical-host) () 'logical-pathname)

;;; Must not be the same as the physical host!
;;; Even though :LOGICAL doesn't have interesting canonical-type properties, this
;;; method is still needed in order to detect cross-system defaulting; all pathnames
;;; are expected to understand the :SYSTEM-TYPE message.
(defmethod (:system-type logical-host) ()
  :logical)

(defmethod (:attributes logical-host) ()
  (and (loop for tran in translations
	     for opnh = default-host then pnh
	     for pn = (translation-physical-pathname tran)
	     for pnh = (send pn :host)
	     always (or (null opnh) (eq pnh opnh)))
       default-host ; avoid explosions ... 
       (send default-host ':attributes)))

(defmethod (:all-hosts logical-host) ()
  (loop with hosts = (when default-host (list default-host))
	for tran in translations
	for pn = (translation-physical-pathname tran)
	for pnh = (send pn :host)
	unless (memq pnh hosts)
	  do (push pnh hosts)
	finally (return hosts)))

(defmethod (:default-host logical-host :before) ()
  (unless default-host
    (when translations
      (setq default-host
	    (send (translation-physical-pathname (first translations)) :host)))))

(defmethod (:pathname-hash-table-initial-size logical-host) ()
  1800.)

(defstruct (logical-pathname-translation :list (:conc-name translation-))
  logical-pathname
  physical-pathname)

(defmethod (:set-default-host logical-host :after) (ignore)
  (incf translation-tick))

(defmethod (:set-translations logical-host :after) (ignore)
  (incf translation-tick))

(defmethod (:set-translation-rules logical-host :after) (ignore)
  (send self :set-translation-rules-internal))

(defmethod (:set-site-translation-rules logical-host :after) (ignore)
  (send self :set-translation-rules-internal))

(defmethod (:set-permanent-translation-rules logical-host :after) (ignore)
  (send self :set-translation-rules-internal))

(defmethod (:update-global-translation-rules logical-host) ()
  (unless (eq *global-translation-rules* old-global-translation-rules)
    (setq old-global-translation-rules *global-translation-rules*)
    (send self :set-translation-rules-internal)))

;;;

(defun-in-flavor (record-one-patch-system-rule logical-host) (system-name sys-pattern)
  (loop with default-cons-area = pathname-area
	with sys-arguments = (list-in-area pathname-area system-name :system-directory)
	with sys-name = (send sys-pattern :name)
	with cmp-name = (format nil "~A-*" sys-name)
	with cmp-pattern = (send sys-pattern :new-pathname :name cmp-name
				 :type :patch-component-directory)
	with cmp-arguments = (list-in-area pathname-area system-name :component-directory)
	with pdr-name = (format nil "~A-*" sys-name)
	with pdr-pattern = (send sys-pattern :new-pathname :name pdr-name
				 :type :patch-patch-directory)
	with pdr-arguments = (list-in-area pathname-area system-name :patch-directory)
	with pat-name = (format nil "~A-*-*" sys-name)
	with pat-pattern = (send sys-pattern :new-pathname :name pat-name :type :wild)
	with pat-arguments = (list-in-area pathname-area system-name :patch-file)
	for sys-type in neti:all-system-types
	do
    (send self :enter-translation-rule-internal 
	  (make-translation-rule system-type sys-type
				 pathname sys-pattern
				 type 'patch-file
				 arguments sys-arguments)
	  t)
    (send self :enter-translation-rule-internal 
	  (make-translation-rule system-type sys-type
				 pathname cmp-pattern
				 type 'patch-file
				 arguments cmp-arguments)
	  t)
    (send self :enter-translation-rule-internal 
	  (make-translation-rule system-type sys-type
				 pathname pdr-pattern
				 type 'patch-file
				 arguments pdr-arguments)
	  t)
    (send self :enter-translation-rule-internal 
	  (make-translation-rule system-type sys-type
				 pathname pat-pattern
				 type 'patch-file
				 arguments pat-arguments)
	  t)))  

(defmethod (logical-host-record-patch-system-translation logical-host)
	   (system-name sys-pattern)
  (setf sys-pattern (send sys-pattern :new-pathname :version :wild))
  (let ((old-pattern (gethash system-name journal-directory-table)))
    (when (not (eq old-pattern sys-pattern))
      (setf (gethash system-name journal-directory-table) sys-pattern)
      (if (null old-pattern)
	  (record-one-patch-system-rule system-name sys-pattern)
	  (send self :set-translation-rules-internal)))))

(defmethod (:set-translation-rules-internal logical-host) ()
  (sys:without-aborts ("Logical host ~A's translation rule table is being rebuilt." self)
    (incf translation-tick)
    (clrhash translation-rule-table)
    (send self :set-translation-rules-internal-1
	  (parse-translation-rules *global-translation-rules* self))
    (send self :set-translation-rules-internal-1 translation-rules t)
    (send self :set-translation-rules-internal-1 site-translation-rules t)
    ;; Don't let the user site overwrite the permanent translation rules
    ;; or patches won't work.  The PATCH-FILE translation rule will go
    ;; through normal translation for the directory component.
    (send self :set-translation-rules-internal-1 permanent-translation-rules t)
    (maphash #'record-one-patch-system-rule journal-directory-table)
    nil))

(defmethod (:set-translation-rules-internal-1 logical-host) (tran-rules &optional set-key)
  (loop for rule in tran-rules
	do (send self :enter-translation-rule-internal rule set-key)))

(defun parse-translation-rules (tran-rules &optional set-host)
  (loop for (system-type . rules) in tran-rules
	nconc (loop for (pathname type . arguments) in rules
		    when set-host
		      do (setq pathname (send (parse-pathname pathname)
					      :new-pathname :host set-host))
		    collect (make-translation-rule system-type system-type
						   pathname pathname
						   type type
						   arguments arguments))))

(defmethod (:enter-translation-rule logical-host) (system-type pathname type arguments)
  (setq pathname (parse-pathname pathname)
	arguments (copy-into-pathname-area arguments))
  (unless (eq (send pathname :host) self)
    (ferror "~A Translation rule for host ~A uses pathname ~A,~@
	     which is not a pathname on host ~A."
	    type self pathname self))
  (let ((rule (make-translation-rule system-type system-type
				     pathname pathname
				     type type
				     arguments arguments)))
    (send self :enter-translation-rule-internal rule t)))

(defmethod (:enter-translation-rule-internal logical-host) (rule &optional set-key)
  (let ((key (translation-rule-key rule)))
    (unless key
      (setq key (send self :get-translation-rule-key
		      (translation-rule-system-type rule)
		      (translation-rule-pathname rule)))
      (when set-key
	(setq key (copy-into-pathname-area key))
	(setf (translation-rule-key rule) key)))
    (let ((bucket (gethash key translation-rule-table)))
      (unless (member rule bucket)
	(setf (gethash key translation-rule-table)
	      (nconc bucket (ncons-in-area rule pathname-area)))))))


(defmethod (:get-translation-rule-key logical-host) (system-type pathname)
  (with-pathname-hash-key (pathname key1a)
    (with-stack-list* (key1 system-type key1a)
      ;; KEY2 is faster, and always correct, but part of KEY1 may already exist
      ;; in the pathname area.
      ;; If KEY1 is the right thing, we'll use it to save space.
      ;; If wildcards are hairy enough, however, they will be different.
      (with-stack-list (key2 system-type
			     (if (send pathname :wild-directory-p
				       (send pathname :raw-directory))
				 :wild
				 (or (send pathname :raw-directory) :wild))
			     (if (send pathname :wild-name-p (send pathname :raw-name))
				 :wild
				 (or (send pathname :raw-name) :wild))
			     (if (send pathname :wild-type-p (send pathname :raw-type))
				 :wild
				 (or (send pathname :raw-type) :wild))
			     (if (send pathname :wild-version-p (send pathname :version))
				 :wild
				 (or (send pathname :version) :wild)))
	(copy-into-pathname-area
	  (if (equal key1 key2)
	      key1
	      key2))))))

(defmethod (:invalidate-translations logical-host) ()
  (incf translation-tick))

;;; The condition signalled when no translation can be found to match the
;;; pattern being signaled.  This is caught by the :TRANSLATABLE-P
;;; message, and also provides for prompting to define a translation.

(defflavor undefined-logical-pathname-translation (logical-pathname) (pathname-error)
  :initable-instance-variables
  :gettable-instance-variables)

(defmethod (:report undefined-logical-pathname-translation) (stream)
  (format stream "The logical pathname ~A: ~A is not defined"
	  (send (send logical-pathname ':host) ':name)
	  (send logical-pathname ':string-for-directory)))

(defmethod (:document-proceed-type undefined-logical-pathname-translation :define-directory)
	   (stream)
  (let ((logical-host (send logical-pathname ':host)))
    (cond ((send logical-pathname ':raw-translatable-p)
	   (format stream "Logical directory ~A: ~A is now defined; proceed"
		   (send logical-host ':name) (send logical-pathname ':string-for-directory)))
	  (t
	   (format stream "Define logical directory ~A: ~A on a physical host."
		   (send logical-host ':name)
		   (send logical-pathname ':string-for-directory))))))

(defmethod (:proceed undefined-logical-pathname-translation :define-directory)
	   (&optional (physical-pathname
			(if (send logical-pathname ':raw-translatable-p)
			    nil
			    (prompt-for-new-physical-directory logical-pathname))))
  (values ':define-directory physical-pathname))

D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");;; Condition used by :translated-pathname that is caught by :TRANSLATABLE-P.
0(defflavor untranslatable-relative-logical-pathname (logical-pathname) (pathname-error)
  :initable-instance-variables
  :gettable-instance-variables)

(defmethod (:report untranslatable-relative-logical-pathname) (stream)
  (format stream "The logical pathname ~A is a relative pathname and cannot be translated"
	  logical-pathname))

(defun prompt-for-new-physical-directory (logical-pathname)
  (let ((lhost (send logical-pathname :host)) cpath)
    (loop with uhd = (send (quiet-user-homedir (send lhost :default-host))
			   :new-default-pathname
			   :name nil :type nil :version nil)
	  as new-path = (prompt-and-read :string-trim
				     "Type a pathname, whose directory component~@
				      will be the translation of directory ~A on host ~A, ~@
				      for example, ~A  ...  "
				     (send logical-pathname :string-for-directory)
				     lhost uhd)
	  as path = (parse-pathname new-path nil uhd)
	  do
	  (cond ((null (send path :directory))
		 (format query-io
			 "~&~A isn't quite the right thing - it has no directory component."
			 path))
		((null (send path :device))
		 (format query-io
			 "~&~A isn't quite the right thing - it has no device component."
			 path))
		;; Really need a way to probe for directories...
		((send path :name)
		 (cond ((send path :operation-handled-p :pathname-as-directory)
			(setq cpath (send (send path :pathname-as-directory)
					  :new-pathname :name nil :type nil
					  :version nil))
			(cond ((cl:y-or-n-p
				 "~A doesn't look like a directory pathname.~@
				 Did you mean ~A? " path cpath)
			       (return
				 (send cpath :string-for-host)))))
		       (t (format query-io "~&A seems to be a lot more than a directory spec."
				  path))))
		(t
		 (return (send path :string-for-host)))))))

(compile-flavor-methods undefined-logical-pathname-translation
			untranslatable-relative-logical-pathname)


 
(defmethod (:translate-raw logical-host) (pathname)
  (loop named found-translation
	do
    (loop for (logical-pathname physical-pathname) in translations
	  do
      (when (send logical-pathname :pathname-match pathname)
	(return-from found-translation
	  (values logical-pathname physical-pathname))))
    (signal-proceed-case ((physical-directory)
			  'undefined-logical-pathname-translation
			  :logical-pathname pathname)
      (:define-directory
	;; The proceeder may give NIL, meaning just try again.
	(when physical-directory
	  (change-logical-pathname-directory
	    self pathname physical-directory)))))) 

(defmethod (:translate-from-to logical-pathname) ()
  (multiple-value-bind (from-pathname to-pathname)
      (send host :translate-raw self)
    (let ((target-system-type (send (send to-pathname :host) :system-type)))
      (when (or name type version)
	(let* ((to-directory (send (send self :new-pathname :raw-name nil
					 :raw-type nil :version nil)
				   :translated-pathname)))
	  (setq target-system-type (send to-directory :system-type))))
      (values from-pathname to-pathname target-system-type))))

(defmethod (:translate logical-host) (pathname)
  (multiple-value-bind (from-pathname to-pathname target-system-type)
      (send pathname :translate-from-to)
    (let ((directory (or (send pathname :raw-directory) :wild))
	  (nam (or (send pathname :raw-name) :wild))
	  (type (or (send pathname :raw-type) :wild))
	  (version (or (send pathname :version) :wild))
	  (mask (compute-wild-mask pathname)))
      ;; Remember last back-translation, so we can look for it.
      (let* ((tran (generate-new-translate-internal-calls-cases mask pathname
								from-pathname to-pathname
								target-system-type
								directory nam type version)))
	(when *check-for-multiple-translations*
	  (check-translation pathname tran))
	tran))))

(defun check-translation (pathname tran)
  (let* ((host (send pathname :host))
	 (alist (when tran (send tran :get 'back-translation-alist)))
	 (bucket (assq host alist)))
    (if bucket
	(unless (or (eq (follow-structure-forwarding (second bucket))
			(follow-structure-forwarding pathname))
		    (and (eq (send tran :version) :unspecific)	;Unix and other cripples
			 (eq (follow-structure-forwarding
			       (send (second bucket) :new-pathname :version nil))
			     (follow-structure-forwarding
			       (send pathname :new-pathname :version nil)))))
	  (fsignal "Attempt to translate ~A to ~A.~@
		    We had previously gotten this pathname as a translation of ~A.~@
		    Files may be overwritten accidentally if you proceed."
		   pathname tran (second bucket))
	  (push (follow-structure-forwarding pathname) (cdr bucket)))
      (setq bucket `(,host ,(follow-structure-forwarding pathname)))
      (push bucket alist)
      (send tran :putprop alist 'back-translation-alist)))
  tran)


;;; DIRECTORY, NAME, TYPE, and VERSION happen to be the four
;;; things that make up a LOGICAL-PATHNAME's hash key.
;;; The final hash key for our hash table is the target-system's
;;; system type plus the LOGICAL-PATHNAME's hash key, with :WILD
;;; substituted whenever a component is wild in any way ("FOO*"
;;; counts as much as :WILD for this hash).

(defmethod (:translate-internal logical-host) (pathname from-pathname to-pathname
							&rest key)
  (declare (arglist pathname from-pathname to-pathname
		    system-type directory name type version))
  (let ((tran-list (gethash key translation-rule-table)))
    (loop for etran in tran-list
	  for epath = (translation-rule-pathname etran)
	  for val = (and (send epath :pathname-match pathname)
			 (send self :invoke-translation pathname
			       from-pathname to-pathname etran))
	  thereis val)))
  
;;; This takes the function that matched, and the TRANSLATION that it matched,
;;; and returns the translated pathname.

(defmethod (:invoke-translation logical-host) (pathname from-pathname to-pathname translation)
  (let ((type (translation-rule-type translation))
	(match-path (translation-rule-pathname translation))
	(arguments (translation-rule-arguments translation)))
    (if type
	(let ((fun (get type 'translation-function)))
	  (unless fun
	    (ferror "~S is an unknown extended translation type." type))
	  (lexpr-funcall fun match-path pathname from-pathname to-pathname arguments))
      ;; Must be an old string-style
      (send (lexpr-send pathname :new-pathname arguments) :translated-pathname))))

#||

(defun test-rule (rule pattern pathname from to &rest args)
  (let ((rule-fun (get rule 'translation-function)))
    (unless rule-fun (ferror "~S is not a translation rule." rule))
    (let* ((default (make-pathname :host "SYS" :name :wild :type :wild :version :wild))
	   (pattern (parse-pathname pattern))
	   (pathname (merge-pathnames (parse-pathname pathname nil pattern) default))
	   (from (merge-pathnames (parse-pathname from nil pattern) default))
	   (to (merge-pathnames (parse-pathname to) default)))
      (lexpr-funcall rule-fun pattern pathname from to args))))

||#

;;; the other-arguments can be one of :DO-DIRECTORY, :DO-NAME, or :SUBSTITUTE
;;; This, via the magic of lexical closures, lets us perform whatever processing
;;; we want on the translated components, while still in our own lexical environment.
;;; :DO-DIRECTORY and :DO-NAME say to HEURISTICATE-NAME-COMPONENT before giving us
;;; the directory and name, respectively.  :SUBSTITUTE is passed to 
;;; HEURISTICATE-NAME-COMPONENT if it is called.
;;; :DO-DIRECTORY and :DO-NAME require the target pathname support the :FILENAME-CHARSET
;;; and :FILENAME-LENGTH messages.  Currently only VMS does, so this is only used for
;;; VMS pathnames.  VMS is the only one that has a real need, anyway.

(defmacro rule-new-pathname ((pathname from to &key &allow-other-keys &rest other-arguments)
			     &body body)
  (unless body
    (setq body '((values host device directory name type version))))
  `(heuristicate-internal ,pathname ,from ,to ,@other-arguments
			  :function
			  #'(lambda (host device directory name type version)
			      host device directory name type version
			      ,@body)))

(defun heuristicate-internal (pathname from to &rest args
			      &key substitute do-directory do-name function &allow-other-keys)
  (lexpr-funcall #'new-pathname-rule-internal
    pathname from to
    :function #'(lambda (host device directory name type version)
		  (when do-name
		    (setq name
			  (heuristicate-name-component
			    name (send to :filename-length)
			    (send to :send-if-handles :filename-charset)
			    substitute)))
		  (when (and do-directory (listp directory))
		    ;; Compute the new directory names, triming to fit
		    (setq directory
			  (loop for d in directory
				collect (heuristicate-name-component
					  d (send to :filename-length)
					  (send to :send-if-handles :filename-charset)
					  substitute))))
		  (funcall function host device directory name type version))
    args))

(defun heuristicate-name-component (name filename-length filename-charset substitute)
  (if (not (stringp name))
      name
    (loop for oi = -1 then i
	  for i = (or (if filename-charset
			  (string-search-not-set filename-charset name (1+ oi))
			(string-search #/- name (1+ oi)))
		      (string-length name))
	  while ( i oi)
	  for delim = (and ( oi 0) (aref name oi))
	  for alt-delim = (second (assq delim substitute))
	  when alt-delim
	    collect (string alt-delim) into pieces
	    and sum (string-length (string alt-delim)) into length
	  for piece = (substring name (1+ oi) i)
	  collect piece into pieces
	  sum (string-length piece) into length
	  finally
	    (if ( length filename-length)
		(return (apply #'string-append pieces))
	      (return (heuristicate-name-component-internal
			pieces length filename-length substitute))))))

;;; Take a list of strings, and their total length, and trim them down to a target length.
;;; Trims evenly from all the pieces, but if uneven, takes off more from the earlier strings.
;;; Prefers to take pieces from strings by removing vowels.

(defun heuristicate-name-component-internal (pieces length target-length substitute)
  (apply #'string-append
	 (heuristicate-name-component-internal-1 pieces length target-length substitute)))

(defun heuristicate-name-component-internal-1 (pieces length target-length substitute)
  (loop with remaining-length = length
	with max-length = (loop for p in pieces maximize (string-length p))
	for length-this-try downfrom (1- max-length)
	until ( remaining-length target-length)
	do (loop for p in pieces
		 for l on pieces
		 until ( remaining-length target-length)
		 for remove-n = (if (and (= (string-length p) 1)
					 (assq (aref p 0) substitute))
				    1
				  (max (- (string-length p) length-this-try) 0))
		 for next-char = nil then (and (> (string-length shortened-string) 0)
					       (aref shortened-string 
						     (1- (string-length shortened-string))))
		 for shortened-string = (shorten-string p remove-n next-char)
		 do (setf (car l) shortened-string)
		    (decf remaining-length remove-n))
	finally (return pieces)))

(defun shorten-string (string remove-n &optional next-char)
  (if (< remove-n 0)
      string
    (loop with str = (loop for c being the array-elements of string
			   collect c into list
			   finally (return (nreverse list)))
	    ;; Double letters?  Prime cannidate for removal.
	  for nc = next-char then c
	  for c in str
	  for not-start-p = (cdr str) then (cdr not-start-p)
	  for remove-p = (and (> remove-n 0)
			      (or (and not-start-p
				       (memq c '(#\A #\a #\E #\e #\I #\i #\O #\o #\U #\u)))
				  (eql c nc)))
	  when (not remove-p)
	    collect c into list
	  when remove-p
	    do (decf remove-n)
	  finally
	    (return (apply #'string-append (nreverse (nthcdr remove-n list)))))))

(defun new-pathname-rule-internal (pathname from to
				   &key function
				   (host nil host-p)
				   (device nil device-p)
				   (directory nil directory-p)
				   (name nil name-p)
				   (type nil type-p)
				   (version nil version-p)
				   (vc-branch nil vc-branch-p)
				   (vc-version nil vc-version-p)
				   &allow-other-keys)
  (let* ((*suppress-target-wild-total-match* t)
	 (hst (send to :host)))
    (multiple-value-bind (canonical-type original-type)
	(send pathname :canonical-type)
      (multiple-value-bind (dev dir nam typ vrs vcb vcv)
	  (send from :translate-wild-internal to
		:unspecific
		(send pathname :directory)
		(send pathname :name)
		(send pathname :type)
		(send pathname :version)
		canonical-type original-type
		(send pathname :vc-branch) (send pathname :vc-version))
	(when function
	  (multiple-value (hst dev dir nam typ vrs)
	    (funcall function hst dev dir nam typ vrs)))
	(when hst
	  (make-pathname :host (if host-p host hst)
			 :device (if device-p device dev)
			 :directory (if directory-p directory dir)
			 :name (if name-p name nam)
			 :type (if type-p type typ)
			 :version (if version-p version vrs)
			 :vc-branch (if vc-branch-p vc-branch vcb)
			 :vc-version (if vc-version-p vc-version vcv)
			 ))))))

(defun heuristicate-wild-component (string from to length
				    &key wild-heuristic constant-heuristic)
  (let ((pieces))
    (flet ((collect-subcomponent (piece)
	     (push piece pieces)
	     piece)
	   (heuristicate-subcomponent (ignore)
	     (if wild-heuristic
		 (funcall wild-heuristic (pop pieces))
	       (pop pieces))))
      (translate-wild-string from to string
			     :wild-heuristic #'collect-subcomponent)
      (setq pieces (nreverse pieces))
      (setq pieces
	    (heuristicate-name-component-internal-1
	      pieces
	      (loop for p in pieces
		    sum (string-length p))
	      length
	      nil))
      (translate-wild-string from to string
			     :wild-heuristic #'heuristicate-subcomponent
			     :constant-heuristic constant-heuristic))))

(defun wild-component-fixed-length (string)
  (if (eq string :wild)
      (values 0 t)
    (let ()
      (declare (sys:array-register a))
      (loop with flag
	    for ch being the array-elements of string using (sequence a)
	    count (char ch #\*) into size
	    when (char= ch #\*)
	      do (setq flag t)
	    finally (return (values size flag))))))

;;; Here are the actual translation rules.

(defun (:new-pathname translation-function) (ignore pathname from to &rest args)
  (lexpr-funcall #'new-pathname-rule-internal pathname from to args))

(defun (:translate-wild translation-function) (ignore pathname from to)
  (send from :translate-wild-pathname-reversible to pathname))

(defvar *default-tops20-directory-levels* 3.
  "How many levels to assume may need translation on TOPS20")

(defvar *tops-20-max-field-size* 39.)

(defun (:tops20-heuristicate-directory translation-function)
       (ignore pathname from to &optional (levels *default-tops20-directory-levels*))
  (labels ((compute-fixed-allocation (to-directory)
	    (loop with (csize cwild)
		  with levs = levels
		  for dirlist = to-directory then (cdr dirlist)
		  for to-dir = (car dirlist)
		  do (multiple-value (csize cwild)
		       (wild-component-fixed-length to-dir))
		  when cwild
		    do (decf levs)
		  sum csize into size
		  while (cdr dirlist)
		  sum 1 into size
		  finally (return (+ size levs)))))
    (let* ((to-directory (send to :directory))
	   (fixed-allocation (compute-fixed-allocation to-directory))
	   (remaining-size (- *tops-20-max-field-size* fixed-allocation))
	   (remaining-levels levels)
	   (from-directory (send from :directory))
	   (to-directory (send to :directory))
	   (in-directory (send pathname :directory)))
      (labels ((record-result-size (result)
		 (setq remaining-levels (max 1 (1- remaining-levels)))
		 (decf remaining-size (string-length result))
		 result)
	       (heuristicate-wild-dir-string (datum from to)
		 (let ((len (// remaining-size remaining-levels)))
		   (heuristicate-wild-component datum from to len
						:wild-heuristic #'record-result-size)))
	       (heuristicate-wild-dir-string-entire (datum)
		 (let ((len (// remaining-size remaining-levels)))
		   (record-result-size (heuristicate-name-component datum len nil nil)))))
	(rule-new-pathname (pathname from to)
	  (setq directory
		(translate-wild-list-general
		  from-directory to-directory
		  in-directory
		  :translate #'heuristicate-wild-dir-string
		  :wild-heuristic #'heuristicate-wild-dir-string-entire))
	  (values host device directory name type version))))))

(defun (:vms-new-pathname translation-function) (ignore pathname from to &rest args)
  (lexpr-funcall #'heuristicate-internal pathname from to
		 :do-directory t
		 :function
		 #'(lambda (host device directory name type version)
		     (values host device directory name type version))
		 args))

(defun (:vms-heuristicate-name translation-function) (ignore pathname from to
						      &optional substitute)
  (rule-new-pathname (pathname from to :substitute substitute :do-name t)))

(defun (:vms-heuristicate-directory translation-function) (ignore pathname from to
							   &optional substitute)
  (rule-new-pathname (pathname from to :substitute substitute :do-directory t)))

(defun (:vms-heuristicate translation-function) (ignore pathname from to
						 &optional substitute)
  (rule-new-pathname (pathname from to :substitute substitute :do-directory t :do-name t)))


(defun (:vms-font translation-function) (ignore pathname from to &optional renamings)
  (let* ((name (send pathname :raw-name))
	 (length (string-length name))
	 (numbers-begin (string-reverse-search-set *digits* name))
	 (substitutions (when (eq (send (send to :host) :system-type) :vms4)
			  '((#/- #/_)))))
    (when numbers-begin
      (rule-new-pathname (pathname from to :substitute substitutions
				   :do-directory t)
	(let* ((numbers-begin (string-reverse-search-set *digits* name))
	       (letters-begin (or (string-reverse-search-not-set *digits* name numbers-begin)
				  numbers-begin))
	       (face (substring name (1+ numbers-begin) length))
	       (size (substring name (1+ letters-begin) (1+ numbers-begin)))
	       (font (substring name 0 (1+ letters-begin)))
	       (max-len (- (send to :filename-length)
			   (max 4 (+ (string-length face)
				     (string-length size))))))
	  ;; apply any renamings
	  (setq font (or (second (assoc font renamings)) font))
	  ;; Strip it down to size
	  (setq font
		(heuristicate-name-component font (min max-len (string-length font))
					     (send to :filename-charset) substitutions))
	  ;; When it now ends in a digit, either append or replace last char.
	  (when (string-search (aref font (1- (string-length font))) *digits*)
	    (if (= (string-length font) max-len)
		(setf (aref font (1- (string-length font))) #\X)
	      (setq font (string-append font "X"))))
	  (values host device directory (string-append font size face) type version))))))

(defun (:unix-font translation-function) (ignore pathname from to
					  &optional renamings (name-size 14.))
  (let* ((name (send pathname :raw-name))
	 (length (string-length name))
	 (numbers-begin (string-reverse-search-set *digits* name)))
    (when numbers-begin
      (rule-new-pathname (pathname from to)
	(let* ((numbers-begin (string-reverse-search-set *digits* name))
	       (letters-begin (or (string-reverse-search-not-set *digits* name numbers-begin)
				  numbers-begin))
	       (face (substring name (1+ numbers-begin) length))
	       (size (substring name (1+ letters-begin) (1+ numbers-begin)))
	       (font (substring name 0 (1+ letters-begin)))
	       (uname (or (second (assoc font renamings)) font))
	       (max-len (- name-size 1
			   (max 4 (+ (string-length size) (string-length face)))
			   (string-length type))))
	  (setq uname
		(heuristicate-name-component uname
					     (min max-len (string-length uname))
					     nil '((#/- #/-))))
	  (values host device directory (string-append uname size face) type version))))))

(defun (:unix-type-and-version translation-function)
       (ignore pathname from to &optional rename (size 14.))
  (let ((name (send pathname :raw-name)))
    (when (stringp name)
      (rule-new-pathname (pathname from to)
	(let ((demark "")
	      (old-version (send pathname :version)))
	  ;; If the last character is a number, we append a "+"
	  (when (string-search (aref name (1- (string-length name))) *digits*)
	    (setq demark "+"))
	  (setq old-version (cond ((eq old-version :wild) "*")
				  ((fixp old-version) (format nil "~D" old-version))))
	  (when old-version
	    (let* ((utype (selectq type
			    ((:unspecific nil) "")
			    (:wild "*")
			    (otherwise type)))
		   (len (+ (string-length utype) (string-length old-version)
			   1 (string-length demark))))
	      (when (> len (- size 2))
		(ferror "Cannot translate pathname ~A due to size limitations."
			pathname))
	      (let ((nlen (- size len))
		    (uname (or (second (assoc name rename)) name)))
		(when (> (string-length uname) nlen)
		  (setq uname (heuristicate-name-component uname nlen nil
							   '((#/- #/-)))))
		(values host device directory
			(string-upcase (string-append uname demark old-version))
			type version)))))))))

;;; Translations for each "word" in a microcode file name.
(defvar *unix-microcode-translation-alist*
	'(("TMC5" "M")
	  ("IFU" "I")
	  ("TAPE" "T")
	  ("FPA" "F")
	  ("IO4" "4")
	  ("ST506" "S")
	  ("COLOR" "C")
	  ("MIC" "")))

(defun rename-unix-microcode-file (name)
  (lexpr-funcall #'string-append
		 (loop for i first 0 then (1+ pos)
		       for pos = (string-search "-" name i)
		       for piece = (substring name i pos)
		       collect (or (second (assoc piece *unix-microcode-translation-alist*))
				   piece)
		       while pos)))

(defun (:unix-microcode translation-function) (ignore pathname from to
					       &optional (size 14.))
  (let ((old-name (send pathname :raw-name))
	(old-version (send pathname :version)))
    (when (stringp old-name)
      (rule-new-pathname (pathname from to)
	(let ((demark "")
	      (utype (selectq type
		       ((:unspecific nil) "")
		       (:wild "*")
		       (otherwise type))))
	  (setq old-version (cond ((eq old-version :wild) "*")
				  ((fixp old-version) (format nil "~D" old-version))))
	  (when old-version
	    (let* ((len (+ (string-length utype) (string-length old-version)
			   1 (string-length demark)))
		   (uname (rename-unix-microcode-file name)))
	      ;; If the last character is a number, we append a "+"
	      (when (string-search (aref uname (1- (string-length uname))) *digits*)
		(setq demark "+"))
	      (when (> (+ len (string-length uname))
		       size)
		(ferror "Cannot translate pathname ~A due to size limitations." pathname))
	      (values host device directory
		      (string-upcase (string-append uname demark old-version))
		      type version))))))))

(defun (:vms-microcode translation-function) (ignore pathname from to)
  (let ((old-name (send pathname :raw-name)))
    (when (stringp old-name)
      (rule-new-pathname (pathname from to :do-directory t)
	(let ((uname (rename-unix-microcode-file old-name)))
	  (when (> (string-length uname) (send to :filename-length))
	    (ferror "Cannot translate pathname ~A due to size limitations." pathname))
	  (values host device directory uname type version))))))

(defvar *digits-or-wild* "0123456789*")

(defun parse-patch-file-pathname (name canonical-type)
  (declare (values name major minor))
  (selectq canonical-type
    (:patch-system-directory name)
    ((:patch-patch-directory :patch-component-directory)
     (let ((end (string-reverse-search-not-set *digits-or-wild* name)))
       (unless end
	 (ferror "~A is not a valid patch version directory name" name))
       (values (substring name 0 end) (parse-number name (1+ end) nil 10. t))))
    (otherwise
     (let* ((end2 (string-reverse-search-not-set *digits-or-wild* name))
	    (end1 (string-reverse-search-not-set *digits-or-wild* name end2)))
       (when end1
	 (flet ((parse-number-or-wild (string start end)
				      (or (parse-number string start end 10. t)
					  (substring string start end))))
	   (let* ((major (parse-number-or-wild name (1+ end1) end2))
		  (minor (parse-number-or-wild name (1+ end2) nil))
		  (name (substring name 0 end1)))
	     (when (and major minor (> (string-length name) 0))
	       (values name major minor)))))))))

(defun canonical-type-to-patch-type (canonical-type)
  (selectq canonical-type
    (:patch-system-directory :system-directory)
    (:patch-component-directory :component-directory)
    (:patch-patch-directory :patch-directory)
    (otherwise :patch-file)))

(defvar *bootstrapping-system-definition* nil)
(defun (patch-file translation-function) (pattern pathname from to system-name
					  &optional file-type)
  from to file-type
  (when *pathname-inhibit-expensive-translation*
    (throw 'expensive-translation nil))
  (flet
    ((translate (system patch-atom journal-directory)
       (let ((canonical-type (send pathname :canonical-type)))
	 (multiple-value-bind (parsed-name major minor)
	     (parse-patch-file-pathname (send pathname :name) canonical-type)
	   (let ((pattern-parsed-name (parse-patch-file-pathname (send pattern :name)
								 canonical-type)))
	     (if system
		 (when (and journal-directory parsed-name
			    (string-equal pattern-parsed-name parsed-name))
		   (let* ((directory journal-directory)
			  (same-directory-p #---ignore t
					    #+++ignore (si:patch-directory-same-directory-p
							 journal-directory))
			  (patom "PATCH")
			  (patch-type (canonical-type-to-patch-type canonical-type))
			  (phys-dir (send directory :translated-pathname))
			  (patch-pathname (send phys-dir :patch-file-pathname
						patch-atom same-directory-p patom patch-type
						major minor canonical-type)))
		     (send patch-pathname :new-version (send pathname :version))))
	       (when (and major pattern-parsed-name parsed-name
			  (string-equal pattern-parsed-name parsed-name))
		 (ferror "~A looks like a patch file pathname for the ~A system.~@
			   Somehow we have been asked to translate that system before~@
			   it is loaded.  We cannot translate it until the system is loaded."
		   pathname pattern-parsed-name))))))))
    (if *bootstrapping-system-definition*
	(destructuring-bind (system patch-atom journal-directory)
	    *bootstrapping-system-definition*
	  (translate system patch-atom journal-directory))
      ;; This should not attempt to read in a sysdcl file on its own
      (let* ((system (sct:find-system-named system-name nil t))
	     (patch-atom (when system (sct:system-patch-atom system)))
	     (journal-directory (when system (sct:system-journal-directory system))))
	(when (and patch-atom journal-directory)
	  (translate system patch-atom journal-directory))))))

;;; Note that there can only be *ONE* translation rule that handles all
;;; target operating systems, because the type of the host in SYS: SITE; may not
;;; agree with the type of the host in the site object.

(defun (:site-directory translation-function) (rule pathname from to &rest args)
  rule from to					;We use the namespace entry...
  (let* ((site-dir-path (get-site-directory))
	 (site-dir (send site-dir-path :directory))
	 (path-dir (send pathname :directory))
	 (rest-dir (make-list (1- (length path-dir)) :initial-value :wild))
	 ;; we simulate :WILD-INFERIORS, since Unix and TOPS-20 don't support it.
	 (new-to-pattern (send site-dir-path :new-pathname
			       :directory (append site-dir rest-dir)
			       :name :wild :type :wild :version :wild))
	 (new-from-pattern (fs:make-pathname :host "SYS"
					     :directory (list* "SITE" rest-dir)
					     :name :wild :type :wild :version :wild)))
    (lexpr-funcall #'heuristicate-internal pathname new-from-pattern new-to-pattern
		   :do-name (unless (or (get (locf args) :name)
					(get (locf args) :raw-name))
			      (send new-to-pattern :operation-handled-p
				    :filename-length))
		   :substitute (send new-to-pattern :send-if-handles
				     :filename-charset-alternates)
		   :function #'(lambda (host device directory name type version)
				 (values host device directory name type version))
		   args)))

(defun (:iso9660-heuristicate translation-function) (ignore pathname from to)
  (rule-new-pathname (pathname from to)
    (flet ((do-component (component maxlen)
	     (setf component
		   (lisp:remove-if-not #'(lambda (char)
					   (let ((code (char-code char)))
					     (or (<= (char-code #\A) code (char-code #\Z))
						 (<= (char-code #\0) code (char-code #\9))
						 (eql code (char-code #\-))
						 (eql code (char-code #\_))
						 (eql code (char-code #\*)))))
				       (string-upcase component)))
	     (when (< maxlen (string-length component))
	       (setf component (substring component 0 maxlen)))
	     component))
      (when (stringp name)
	(setq name (do-component name (- 30. (if (stringp type) (string-length type) 0)))))
      (when (listp directory)
	;; Compute the new directory names, triming to fit
	(setq directory
	      (mapcar #'(lambda (component)
			  (do-component component 31.))
		      directory)))
      (values host device directory name type version))))


;;;; Logical pathnames

(defmethod (:string-for-printing logical-pathname) ()
  (let ((nam (if name (string-or-wild self name) (and (or type version) "")))
	(typ (if type (string-or-wild self type) (and version "")))
	(ver (selectq version
	       (:newest "NEWEST")
	       (:oldest "OLDEST")
	       (:wild "*")
	       (otherwise version)))
	(default-cons-area pathname-area))
    (with-output-to-string (s)
      (send s :string-out (send host :name-as-file-computer))
      (send s :tyo #/:)
      (when directory
	(send s :string-out (send self :string-for-directory)))
      (when nam
	(send s :string-out nam))
      (when typ
	(send s :tyo #/.)
	(send s :string-out typ)
	(when (or ver (equal typ ""))
	  (send s :tyo #/.))
	(when ver
	  (if (numberp ver)
	      (si:print-integer ver 10. s)
	      (send s :string-out ver)))))))

(defmethod (:string-for-directory logical-pathname) ()
  (let ((default-cons-area pathname-area))
    (if (atom directory)
	(format nil "~A;" (string-or-wild self directory))
	(with-output-to-string (s)
	  (dolist (component directory)
	    (cond ((memq component '(:relative :up)))
		  ((eq component ':wild-inferiors) (send s :string-out "**"))
		  (t (send s :string-out (string-or-wild self component))))
	    (send s :tyo #/;))))))

(defun string-upcase-if-string (string)
  (if (stringp string) (si:string-upcase-if-necessary string) string))

(defmethod (:parse-namestring logical-pathname) (ignore namestring &optional (start 0) end)
  (or end (setq end (string-length namestring)))
  (loop with dir and nam and namp and typ and typp and vers
	with token and token-end and token-start
	finally (return (values ':unspecific (nreverse dir) (string-upcase-if-string nam)
				(string-upcase-if-string typ) vers))
	for scan-start upfrom start below end
	as ch = (aref namestring scan-start)
	unless (mem #'char-equal ch '(#\sp #\tab))
	do (setq token-end nil)
           (unless (mem #'char-equal ch '(#/; #/.))
	     (setq token-start scan-start)
	     (loop for check-token-end upfrom token-start below end
		   as cch = (aref namestring check-token-end)
		   when (char-equal cch #/)
		   do (if (= check-token-end (1- end))
			  (parse-pathname-error "Quote character  as last in string!?"))
		      (if token-end
			  (return (setq cch #\sp scan-start (1- check-token-end))))
		      (incf check-token-end)
		   else when (mem #'char-equal cch '(#/; #/.))
		   return (progn (if (null token-end)
				     (setq token-end check-token-end))
				 (setq ch cch scan-start check-token-end))	;will skip
		   else when (mem #'char-equal cch '(#\sp #\tab))
		   do  (if (null token-end)
			   (setq token-end check-token-end))
		   else 
		   do  (if token-end
			   (return (setq cch #\sp
					 scan-start (1- check-token-end))))
		   finally (if (null token-end)
			       (setq token-end end cch #\sp scan-start end))))
	   (setq token
		 (cond ((and (char-equal ch #/;) (null token-end)) :relative)
		       ((null token-end) nil)
		       ((and (char-equal (aref namestring token-start) #/)
			     (= token-end (1+ token-start)))
			nil)
		       ((and (char-equal (aref namestring token-start) #/*)
			     (= token-end (1+ token-start)))
			':wild)
		       ((and (char-equal (aref namestring token-start) #/*)
			     (= token-end (+ 2 token-start))
			     (char-equal (aref namestring (1+ token-start)) #\*))
			:wild-inferiors)
		       (t (unquote-logical-string namestring token-start token-end))))
	   (selector ch char-equal
	     ((#/;) (cond ((eq token :relative)
			 (if (null dir)
			     (push :relative dir)
			   (parse-pathname-error "Relative in middle of directory.")))
			((not (null token))	;Not relativizer
			 (push (string-upcase-if-string token) dir))
			((memq (car dir) '(:relative :up))
			 (push ':up dir))
			(t (push token dir))))
	     (otherwise
	      (cond (vers)
		    (typp (setq vers (cond ((string-equal token ">") ':newest)
					   ((string-equal token "<") ':oldest)
					   ((string-equal token "NEWEST") ':newest)
					   ((string-equal token "OLDEST") ':oldest)
					   ((memq token '(:wild nil)) token)
					   ((numeric-p token))	;return the number.
					   (t (parse-pathname-error
						"Version not numeric")))))
		    (namp (setq typ token typp t))
		    (t (setq nam token namp t)))))))

(defmethod (:quote-character logical-pathname) () #/)

(defmethod (:character-needs-quoting-p logical-pathname) (ch)
  (mem #'char-equal ch '(#/; #/ #\sp #/. #\tab)))

(defun unquote-logical-string (string &optional (start 0) (end (string-length string)))
  (do ((i start (1+ i))
       (nch 0) (ch)
       (need-copy nil))
      (( i end)
       (cond ((and (= start 0) (= i (string-length string)) (not need-copy))
	      string)				;To avoid consing
	     ((not need-copy)
	      (substring string start i))
	     (t
	      (do ((nstring (make-array nch ':type 'art-string))
		   (j 0)
		   (k start (1+ k))
		   (ch))
		  (( k i) nstring)
		(setq ch (aref string k))
		(cond ((not (char-equal ch #/))
		       (aset ch nstring j)
		       (setq j (1+ j))))))))
    (setq ch (aref string i))
    (if (char-equal ch #/)
	(setq need-copy t)
	(setq nch (1+ nch)))))

(defun logical-pathname-pass-on (self ignore message &rest rest)
  (lexpr-send (send self :translated-pathname) message rest))

(defmethod (:string-for-host logical-pathname) logical-pathname-pass-on)
(defmethod (:string-for-editor logical-pathname) logical-pathname-pass-on)
(defmethod (:string-for-wholine logical-pathname) logical-pathname-pass-on)
(defmethod (:change-properties logical-pathname) logical-pathname-pass-on)
(defmethod (:expunge logical-pathname) logical-pathname-pass-on)
(defmethod (:open logical-pathname) logical-pathname-pass-on)
(defmethod (:delete logical-pathname) logical-pathname-pass-on)
(defmethod (:rename logical-pathname) logical-pathname-pass-on)
(defmethod (:create-directory logical-pathname) logical-pathname-pass-on)
(defmethod (:create-link logical-pathname) logical-pathname-pass-on)
(defmethod (:parse-truename logical-pathname) logical-pathname-pass-on)
(defmethod (:string-for-dired logical-pathname) logical-pathname-pass-on)
(defmethod (:properties logical-pathname) logical-pathname-pass-on)
;;; These need to be passed on since otherwise the information on how they were created
;;; will be lost.
(defmethod (:new-type-and-version logical-pathname) logical-pathname-pass-on)

;;; To find the property-list, we get it from the translated pathname.
(defmethod (:get logical-pathname) logical-pathname-pass-on)
(defmethod (:property-list-location logical-pathname) logical-pathname-pass-on)
(defmethod (:plist logical-pathname) logical-pathname-pass-on)
(defmethod (:push-property logical-pathname) logical-pathname-pass-on)
(defmethod (:remprop logical-pathname) logical-pathname-pass-on)
(defmethod (:getl logical-pathname) logical-pathname-pass-on)
(defmethod (:set-property-list logical-pathname) logical-pathname-pass-on)
(defmethod (:property-list logical-pathname) logical-pathname-pass-on)
(defmethod (:putprop logical-pathname) logical-pathname-pass-on)
(defmethod (pathname-file-access-path logical-pathname) logical-pathname-pass-on)
  

(defmethod (:multiple-file-plists logical-pathname) (pathnames options)
  (cl:apply #'multiple-file-plists pathnames options)
  )

;; This version completes logical pathnames into logical pathnames
(defmethod (:complete-string logical-pathname) (string options)
  (let* ((parsed (parse-pathname string host))
	 (with-directory (if (send parsed :directory)
			     parsed
			     (send parsed :new-directory (send self :directory))))
	 (translated (send with-directory :translated-pathname)))
    (multiple-value-bind (nstring success)
	(multiple-value-bind (canonical-type original-type)
	    (send self :canonical-type)
	  (send (send translated :new-default-pathname
		      :name (send self :name)
		      :canonical-type canonical-type :original-type original-type)
		:complete-string
		(send translated :string-for-host) options))
      (values
	(send 
	  (send self :back-translated-pathname
		(parse-pathname nstring (send translated :host)))
	  :string-for-printing)
	success t))))

;;; Pass on, except that any star matching in the directory field is against
;;; logical directories, not translated directories.
(defmethod (:directory-list logical-pathname) (options)
  (if (not (send self :directory-wild-p))
      (send (send self :translated-pathname) :directory-list options)
    (si:eliminate-duplicates
      (loop for (logical-pathname physical-pathname) in (send host :translations)
	    with first = t
	    for wild-p = (send logical-pathname :directory-wild-p)
	    when (and (not wild-p)
		      (send self :directory-match
			    directory
			    (send logical-pathname :raw-directory)))
	      ;; This logical-pathname pattern isn't wild.  See if it would be included in our
	      ;; wild-card directory.
	      nconc (logical-pathname-directory-list-internal
		      logical-pathname
		      (send self :new-pathname
			    :raw-directory (send logical-pathname :raw-directory))
		      physical-pathname (locf first) options)
	    when (and wild-p
		      (send self :directory-match
			    (send logical-pathname :raw-directory)
			    directory))
	      ;; This wild-card directory component is a superset of ours.
	      nconc (logical-pathname-directory-list-internal logical-pathname self
							      physical-pathname
							      (locf first) options))
      #'(lambda (x y)
	  (eq (car x) (car y))))))

(defun logical-pathname-directory-list-internal (logical-pathname source-pathname
						 physical-pathname
						 first options)
  (condition-case (list-or-error)
      (send (send logical-pathname ':translate-wild-pathname-reversible
		  physical-pathname source-pathname)
	    ':directory-list options)
    (directory-not-found nil)
    (:no-error
     (unless (cdr first) (pop list-or-error))
     (setf (cdr first) nil)
     list-or-error)))

(defmethod (:directory-pathname-as-file logical-pathname) ()
  (default-directory-pathname-as-file self directory))

(defmethod (:directory-file-type logical-pathname) ()
  nil)

(defmethod (:up-directory-level logical-pathname) ()
  (cond ((atom directory)
	 (ferror "Directory not suitable for going up a level: ~A" self))
	((= (length directory) 1)
	 (ferror "Cannot go up a level from a top-level directory: ~A" self))
	(t (values
	     (send self ':new-raw-directory
		   (butlast directory))
	     (car (last directory))))))

(defmethod (:remove-logical-pathname logical-pathname) ()
  (when translated-pathname
    (send translated-pathname :set-property-list nil)
    (setq translation-tick nil)
    (setq translated-pathname nil))
  (send (send host :pathname-hash-table) :rem-hash (send self :hash-key)))


;; Sometimes a logical pathname gets asked for its home directory; this happens
;; from VALID-DIRECTORY, which comes up during back-translation.  Since logical
;; hosts dont have :HOST-USER-ID methods, the usual inherited method from
;; PATHNAME doesn't work; there really isn't any right answer.  So ERROR gets
;; faked up by this method.  Normally this will only serve as a default that
;; will get overridden by an explicitly-specified directory, so normally
;; nobody will ever see this.
(defmethod (:homedir logical-pathname) ()
  (send self :quiet-homedir))


(defmethod (:valid-directory-component-p logical-pathname) (dirname ignore)
  (or (stringp dirname)
      (memq dirname '(:relative :up nil :wild :wild-inferiors))))

(defmethod (:valid-directory logical-pathname) (dirname)
  (cond ((stringp dirname)
	 (list dirname))
	((send self ':valid-directory-p dirname)
	 dirname)
	((listp dirname)
	 (send self ':valid-directory (car (last dirname))))
	(t '("ERROR"))))

(defmethod (:translatable-p logical-pathname) ()
  (or (eql translation-tick (send host :translation-tick))
      (condition-case ()
	  (send self :translated-pathname)
	((undefined-logical-pathname-translation
	   invalid-pathname-component
	   untranslatable-relative-logical-pathname)
	 nil)
	(:no-error t))))

;;; If PATHNAME is a physical pathname that could have come from a logical
;;; pathname on SELF's host, get that logical pathname.  Otherwise just
;;; return PATHNAME, no matter whether it's logical or physical.

(defmethod (:back-translated-pathname logical-pathname) (pathname)
  (or (second (assq host (send pathname :get 'back-translation-alist)))
      (send host :back-translated-pathname pathname)))

;;; *** This should look for rules to invert.  Punt for now.

(defmethod (:back-translated-pathname logical-host) (pathname)
  (loop for trans in translations
	when (send (translation-physical-pathname trans) ':pathname-match pathname)
	return (send (translation-physical-pathname trans)
		     ':translate-wild-pathname-reversible
		     (translation-logical-pathname trans)
		     pathname)
	finally (return pathname)))

;;; Translate to a physical pathname, using the cached translation if it is valid.
;;; If the translation changes, copy any properties from the old physical pathname
;;; to the new one.

(defmethod (:translated-pathname logical-pathname) ()
  (if (and (eql translation-tick (send host :translation-tick))
	   (eq (send host :old-global-translation-rules) *global-translation-rules*))
      translated-pathname
    ;; Cache not valid or not computed yet.  Compute the translation the slow way.
    (let ((old-translated-pathname translated-pathname)
	  (new-translation-tick (send host :translation-tick))
	  (new-translated-pathname
	    (cond ((null directory)
		     (make-pathname :host (send host :default-host)
				    :raw-device nil :raw-directory nil
				    :name name
				    :canonical-type (send self :canonical-type)
				    :version version
				    :vc-branch vc-branch
				    :vc-version vc-version
				    ))
		  ((and (listp directory)
			(memq ':relative directory))
		   (signal 'untranslatable-relative-logical-pathname :logical-pathname self))
		  (t (send host :translate self)))))
	;; If the physical pathname changed, copy any properties.
	(unless (eq new-translated-pathname old-translated-pathname)
	  (loop for (ind val) on (if old-translated-pathname
				     (send old-translated-pathname :property-list)
				     flavor:property-list)
			 by 'cddr
		with new-plist = (send new-translated-pathname :property-list-location)
		unless (get new-plist ind)
		  do (putprop new-plist val ind))
	  (if old-translated-pathname
	      (send old-translated-pathname :set-property-list nil)
	      (setq flavor:property-list nil)))
	;; save the translation
	(setq translated-pathname new-translated-pathname)
	(setq translation-tick new-translation-tick)
	new-translated-pathname))) 

(defmethod (:raw-translatable-p logical-pathname) ()
  ;;No, don't return NIL....
  (when (and (listp directory)
	     (memq ':relative directory))
    (ferror "~A is a relative pathname, which may not be translated." self))
  (loop for (logical-pathname physical-pathname) in (send host ':translations)
	do (ignore physical-pathname)
	thereis (send logical-pathname ':pathname-match self)))

(defmethod (:before-full-gc logical-pathname) (ignore)
  (when translated-pathname
    ;; Allow physical pathname to be GC'ed if not otherwise referenced.
    (setq flavor:property-list (send translated-pathname :property-list))
    (setq translated-pathname nil translation-tick nil)))

(defmethod (:record-patch-system-translation logical-pathname) (system-name sys-pattern)
  (logical-host-record-patch-system-translation host system-name sys-pattern))


(defmethod (:quiet-homedir logical-pathname) ()
  (neti:pathname-host-get-pathname host ':unspecific '("ERROR") nil nil nil nil nil nil))

(defwhopper (:pathname-match logical-pathname) (other-pathname &optional (match-host t))
  (if (typep other-pathname 'logical-pathname)
      (continue-whopper other-pathname match-host)
    (let ((back-pathname (send self :back-translated-pathname other-pathname)))
      (continue-whopper back-pathname match-host))))

(defmethod (:patch-file-name logical-pathname)
	   (system-name same-directory-p patom &optional major-version minor-version)
  (format nil "~:[~A~*~;~*~A~]~@[-~D~]~@[-~D~]"
	  (eq same-directory-p :explicit) system-name patom major-version minor-version))

;;; Is this correct about the various places that the property list can be?
(defmethod (:property-list-no-translation logical-pathname) ()
  (if translated-pathname
      (send translated-pathname :property-list)
      flavor:property-list))

;;; Same question.
(defmethod (:set-property-list-no-translation logical-pathname) (plist merge-p)
  (when translated-pathname
    (setq flavor:property-list (send translated-pathname :property-list)))
  (if (and merge-p flavor:property-list)
      (loop for (ind val) on plist by 'cddr do
	(unless (cl:getf flavor:property-list ind)
	  (setf (cl:getf flavor:property-list ind) val)))
      (setq flavor:property-list plist))
  (when translated-pathname
    (send translated-pathname :set-property-list flavor:property-list)))

(defmethod (:property-list-no-translation pathname) () flavor:property-list)
(defmethod (:set-property-list-no-translation pathname) (plist ignore)
  (setq flavor:property-list plist))

;;; Define a new logical pathname host.  The actual translations to physical pathnames
;;; are defined by a file on SYS:SITE; which is different at each site.
;;; :NO-SEARCH-FOR-SHADOWED-PHYSICAL is same as for SET-LOGICAL-PATHNAME-HOST
;;; How :NO-SEARCH-FOR-SHADOWED-PHYSICAL is supposed to be passed to the
;;; SET-LOGICAL-PATHNAME-HOST form is not clear.
(defun make-logical-pathname-host (name &key no-search-for-shadowed-physical)
  no-search-for-shadowed-physical		;should do something useful with this
  (setq name (string name))
  (if (get-logical-pathname-host name t)
      (format error-output "~&Warning: the logical host ~A is already defined." name)
      (let ((file (make-sys-site :name name
				 :type :logical-pathname-directory-translations
				 :version :newest)))
	(let ((module (sct:find-module-named (sct:find-system-named
					       'logical-pathnames-translation-files t)
					     'logical-pathnames-translation-files)))
	  (setf (sct:module-inputs module)
		(append (sct:module-inputs module) (list `(,file ,file)))))
	(let ((truename (cl:load file :verbose t :default-package "FS")))
	  (unless (get-logical-pathname-host name t)
	    (ferror "Loading the file ~A failed to define a logical host named ~A.
The file is supposed to contain a form such as (FS:SET-LOGICAL-PATHNAME-HOST ~:*~S
						:PHYSICAL-HOST ...
						:TRANSLATIONS ...)"
		    truename name))))))


;;; :NO-TRANSLATE suppresses the mapping of :PROPERTY-LIST
;;; over all the pathnames on the logical host.  If this is suppressed,
;;; properties will not be moved from the old physical pathname to the
;;; new one when changing the mapping of a logical pathname.
;;; The consequences of this are unknown.
;;; :NO-SEARCH-FOR-SHADOWED-PHYSICAL means look only in existing pathname hosts
;;; for a host with the same name as the logical host.  That means you may get
;;; surprised later when a physical host gets added with qualified names.

(defun set-logical-pathname-host (logical-host &key physical-host
				  translations (rules nil rules-supplied-p)
				  (site-rules nil site-rules-supplied-p)
				  (no-translate t)
				  no-search-for-shadowed-physical)
  ;; Error checking of the logical host name
  (setq logical-host (string-upcase logical-host))
  (let ((i (string-search-set '(#\sp #\tab #\cr #/| #/:) logical-host)))
    (when i
      (ferror "~S cannot be the name of a logical pathname host~@
		because it contains a ~:C character."
	      logical-host (aref logical-host i))))
  (when (or (string-equal logical-host *local-fs-host*)
	    (string-equal logical-host "")
	    (and (%string-equal logical-host 0 "FEP" 0 3)
		 (not (string-SEARCH-NOT-SET "0123456789" logical-host 3))))
    (ferror "The pathname host name ~S is reserved" logical-host))
  
  ;; Find the physical host translated into
  (when (not (null physical-host))
    (setq physical-host (or (get-pathname-host physical-host t)
			    (let ((host (net:parse-host physical-host)))
			      (add-file-computer host)
			      host)))
    (when (typep physical-host 'logical-host)
      (ferror "The logical host, ~S, may not be used as the physical host"
	      physical-host)))

  ;; Make patchable systems retranslate their logical pathnames 
  ;; since the translations may be wrong as of now.  
  (when (variable-boundp #'sct:invalidate-all-system-pathname-translations)
    (sct:invalidate-all-system-pathname-translations))
  ;; See if the logical host name is already in use
  (let ((log (get-pathname-host logical-host t no-search-for-shadowed-physical)))
    (unless (typep log 'logical-host)
      (let ((shadowed-physical log)
	    (shadowed-name (and log (send log ':name-as-file-computer))))
	(setq log (make-instance 'logical-host ':name logical-host))
	(without-interrupts
	  (push log *logical-pathname-host-list*))
	(cond ((null shadowed-physical))
	      ((equal shadowed-name logical-host)
	       (format error-output
		       "~2&Warning: the host ~A must now be referred to as ~A: in pathnames,~@
			since ~A is now a logical pathname host.  ~
			This affects ~[no~:;~:*~D~] extant pathnames.~%"
		       shadowed-physical
		       (send shadowed-physical ':name-as-file-computer)
		       logical-host 
		       (let ((ht (send shadowed-physical :pathname-hash-table nil)))
			 (if (null ht) 0 (send ht ':filled-elements))))
	       (send shadowed-physical ':maybe-decache-name-as-file-computer))
	      (t (format error-output
			 "~2&Warning: the nickname ~A: for the physical host ~A~@
			  will now refer instead to the logical pathname host ~A.~@
			  Use ~A: in pathnames.~%"
			 logical-host shadowed-physical logical-host shadowed-name))))
      (when (null translations)
	;; In case anybody creates one with no translations, don't leave
	;; these instance variables unbound.
	(send log ':set-translations nil)))
    
    ;; Initialize (or alter) the logical host
    (if physical-host
	(send log ':set-default-host physical-host)
      (setq physical-host (or (send log ':default-host)
			      (parse-pathname-find-colon (second (first translations)))))
      (send log :set-default-host physical-host))
    (when translations
      (send log ':set-translations
	    (loop for (logical-pathname-string physical-pathname-string) in translations
		  with logical-template =
		  (send (send log ':sample-pathname) ':new-pathname
			':directory nil ':name ':wild ':type ':wild ':version ':wild)
		  with physical-template =
		  (let ((sample (send physical-host ':sample-pathname)))
		    (send sample ':new-pathname
			  ':device (send sample ':primary-device) ':directory nil
			  ':name ':wild ':type ':wild ':version ':wild))
		  with logical-pathname and physical-pathname
		  do (setq logical-pathname
			   (parse-pathname
			     ;; make conversion a lot easier...
			     (if (and (stringp logical-pathname-string)
				      (not (string-search-char #/; logical-pathname-string)))
				 (string-append logical-pathname-string #/;)
				 logical-pathname-string)
			     nil logical-template))
		  do (setq physical-pathname
			   (parse-pathname physical-pathname-string nil physical-template))
		  do (setq logical-pathname
			   (merge-pathnames logical-pathname logical-template ':wild)
			   ;; Give the template the same directory as the parsed physical pathname,
			   ;; to increase the chance of the wild components merging consistently 
			   ;; with said pathname.  For example, under Un*x, version merging happens
			   ;; differently depending on whether the directory has a .SCT in it.
			   physical-pathname
			   (merge-pathnames physical-pathname
					    (send (send physical-template
							':new-directory (send physical-pathname ':directory))
						  ':new-pathname
						  ':name ':wild
						  ':type ':wild
						  ':version ':wild)
					    ':wild))
		  when (null (send logical-pathname ':directory))
		  do (ferror "No directory specified in ~A, ~
				   you probably forgot some delimiter characters."
			     logical-pathname)
		  when (null (send physical-pathname ':directory))
		  do (ferror "No directory specified in ~A, ~
				   you probably forgot some delimiter characters."
			     physical-pathname)
		  do (let ((direction "translating"))
		       (condition-case (.error.)
			   (progn (send logical-pathname :translate-wild-pathname-reversible
					physical-pathname logical-pathname)
				  (SETQ DIRECTION "back-translating")
				  (send physical-pathname :translate-wild-pathname-reversible
					logical-pathname physical-pathname) )
			 (error (ferror "Illegal translation, ~A  ~A.~@
				 The translation pair above does not allow ~A without error.~@
				 Check the :TRANSLATIONS argument in the call to ~
				 FS:SET-LOGICAL-PATHNAME-HOST~@
				 for the logical host ~A.  ~
				 This probably can be found in the file~@
				 ~A.~@
~@
				 The error you would encounter in ~A is:~@
				 ~~A~"
				 logical-pathname physical-pathname
				 direction (send logical-pathname :host)
				 (send (make-sys-site
					 :name (send (send logical-pathname :host) :name)
					 :type :logical-pathname-directory-translations)
				       :translated-pathname)
				 direction .error.))))
		  collect (make-logical-pathname-translation
			    logical-pathname logical-pathname
			    physical-pathname physical-pathname))))
    
    (unless (or rules-supplied-p site-rules-supplied-p translations)
      (send log :update-global-translation-rules))
    (when rules-supplied-p
      (set-translation-rules nil rules log))
    (when (or site-rules-supplied-p translations)
      (set-translation-rules t site-rules log))

    ;; Transfer properties from the old physical pathname to the new one
    ;; As a side-effect this creates and interns all the new physical pathnames
    (unless no-translate
      (catch-error-restart (error "Skip retranslating logical pathnames in ~A." log)
	(loop with hash-table = (send log :pathname-hash-table)
	      for path being the hash-elements of hash-table
	      do (send path :translatable-p))))
    log))

(zwei:defindentation (set-logical-pathname-host 0 4 1 1 2 1))

(defun set-translation-rules (site-p rules host)
  (let ((parsed-rules (parse-translation-rules rules host)))
    (if site-p
	(send host :set-site-translation-rules parsed-rules)
      (send host :set-translation-rules parsed-rules))))

(defun change-logical-pathname-directory (logical-host logical-directory physical-directory
					  &aux tran)
  (let* ((log-host (get-pathname-host logical-host))
	 (phys-host (send log-host :default-host))
	 (log-sample (send (send log-host :sample-pathname) :new-pathname
			   :name :wild :type :wild :version :wild))
	 (phys-sample (send (send phys-host :sample-pathname) :new-pathname
			    :name :wild :type :wild :version :wild))
	 (log-pathname
	   (typecase logical-directory
	     (:string (if (string-search-char #/; logical-directory)
			  (parse-pathname logical-directory log-host)
			(send log-sample :new-pathname :directory (list logical-directory))))
	     (:list (send log-sample :new-directory logical-directory))
	     (pathname logical-directory)
	     (otherwise (ferror "Don't know how to get a logical directory from ~S."
				logical-directory))))
	 (phys-pathname
	   (typecase physical-directory
	     (:string (parse-pathname physical-directory phys-host))
	     (:list (send phys-sample :new-directory physical-directory))
	     (pathname physical-directory)
	     (otherwise (ferror "Don't know how to get a physical directory from ~S."
				physical-directory)))))
    (setq log-pathname
	  (merge-pathnames log-pathname
			   (send log-pathname :new-pathname
				 :name :wild :type :wild :version :wild)
			   :wild))
    (setq phys-pathname
	  (merge-pathnames phys-pathname
			   (send phys-pathname :new-pathname
				 :name :wild :type :wild :version :wild)
			   :wild))
    (and (null (send log-pathname :directory))
	 (ferror
	   "No directory specified in ~A, you probably forgot some delimiter characters."
	   log-pathname))
    (and (null (send phys-pathname :directory))
	 (ferror
	   "No directory specified in ~A, you probably forgot some delimiter characters."
	   phys-pathname))
    (if (null (setq tran (assq log-pathname (send log-host :translations))))
	(push (make-logical-pathname-translation
		logical-pathname log-pathname
		physical-pathname phys-pathname)
	      (send log-host :translations))
	(setf (translation-physical-pathname tran) phys-pathname))))

;;;; Kludges for bootstrapping from a world without flavors loaded.
(defun canonicalize-cold-load-pathnames ()
  (format t "~&Canonicalizing cold load pathnames...")
  ;; Make pathnames for all files initially loaded, and setup their properties
  ;; The entries in SI:*COLD-LOADED-FILE-PROPERTY-LISTS* look like this:
  ;;  (unparsed-pathname property-list generic-property-list)
  (dolist (elem si:*cold-loaded-file-property-lists*)
    (let* ((pathname (default-pathname (first elem)))
	   (generic-pathname (send pathname ':generic-pathname)))
      ;; Fix up the pathname's property list
      (loop for (prop val) on (second elem) by 'cddr do
	;; No properties need to be transmogrified
	(send pathname ':putprop val prop))
      ;; Fix up the generic pathname's property list
      (loop for (prop val) on (third elem) by 'cddr do
	;;Cold load generator does not know how to put in instances, it makes
	;;strings instead.  Also, during MINI loading, calls to MAKE-FASLOAD-PATHNAME
	;;are saved just as lists.  Note: we do not back translate this pathname, so
	;;that we really remember the machine it was compiled on.
	(selectq prop
	  (:file-id-package-alist
	   (let ((entry (first val)))
	     (setf (first entry)
		   (pkg-find-package (or (first entry) si:pkg-system-internals-package)))
	     (let ((info (second entry)))
	       (when (stringp (car info))
		 (setf (car info) (default-pathname (car info)))))))
	  (:qfasl-source-file-unique-id
	   (cond ((stringp val)
		  (setq val (default-pathname val)))
		 ((listp val)
		  (setq val (apply #'make-fasload-pathname val))))))
	(send generic-pathname ':putprop val prop))))
  ;; It has done its job
  (setq si:*cold-loaded-file-property-lists* nil)
  ;; Replace all strings saved on symbols with pathnames
  (mapatoms-all #'(lambda (symbol)
		    (let ((val (get symbol :source-file-name)))
		      (when (and val (or (stringp val) (listp val)))
			(setf (get symbol :source-file-name)
			      (canonicalize-source-file-name-property val symbol))))
		    (when (get symbol 'si:initialization-list)
		      (dolist (init (symeval symbol))
			(let ((val (si:init-source-file init)))
			  (when val
			    (setf (si:init-source-file init)
				  (canonicalize-source-file-name-property-1 val))))))))
  ;; Store source file names from the cold load
  (setq si:*function-spec-hash-tables* (cl:make-hash-table :test #'eq))
  (dolist (elem si:cold-load-function-property-lists)
    (si:function-spec-putprop (first elem)
			      (if (eq (second elem) ':source-file-name)
				  (canonicalize-source-file-name-property
				    (third elem) (first elem))
				  (third elem))
			      (second elem)))
  (dolist (flavor *all-flavor-names*)
    (let ((fl (flavor:find-flavor flavor)))
      (loop for mh in (flavor::flavor-local-functions fl)
	    as x = (getl (locf (flavor::method-holder-plist mh)) '(:source-file-name))
	    do (when x
		 (setf (cadr x) (canonicalize-source-file-name-property
				  (cadr x) (flavor::method-holder-function-spec mh)))))
      (loop for mte in (flavor::flavor-method-table fl) do
	(loop for mh in (cdr mte)
	      as x = (getl (locf (flavor::method-holder-plist mh)) '(:source-file-name))
	      do (when x
		   (setf (cadr x) (canonicalize-source-file-name-property
				    (cadr x) (flavor::method-holder-function-spec mh))))))))
  (format t "Done."))

(defun canonicalize-source-file-name-property (property &optional fspec (type 'defun))
  (let ((canonicalized-property
	  (if (atom property)
	      (canonicalize-source-file-name-property-1 property)
	      (dolist (type property)
		(do l (cdr type) (cdr l) (null l)
		    (rplaca l (canonicalize-source-file-name-property-1 (car l)))))
	      property)))
    (when fspec
      (if (atom canonicalized-property)
	  (si:record-source-file-name-2 fspec type canonicalized-property)
	  (loop for (type . canonicals) in canonicalized-property
		do (loop for canon in canonicals
			 do (si:record-source-file-name-2 fspec type canon)))))
    canonicalized-property))

(defun canonicalize-source-file-name-property-1 (name)
  (send (default-pathname name) ':generic-pathname))


;;; Called when the time parser comes in, canonicalize times made before then
(defun canonicalize-cold-loaded-times ()
  (si:with-progress-report ("canonicalizing cold load times")
    (mapc #'(lambda (host)
	      (if (send host ':pathname-hash-table nil)	;Don't create until needed
		  (canonicalize-host-cold-loaded-times (send host ':pathname-hash-table))))
	  *pathname-host-list*)
    ;; If being called from loading a file, that file needs to be fixed too.
    (when (variable-boundp si:fasl-stream)
      (let ((date (send si:fasl-stream ':get ':creation-date)))
	(when (stringp date)
	  (send si:fasl-stream ':putprop
		(parse-directory-date-property date 0) ':creation-date)))))
  nil)

(defun canonicalize-host-cold-loaded-times (hash-table)
  (maphash #'(lambda (ignore val &aux alist)
	       (and (setq alist (send val :get :file-id-package-alist))
		    (dolist (id alist)
		      (let ((info (cadr id)))
			(and (stringp (cdr info))
			     (rplacd info
				     (parse-directory-date-property (cdr info) 0)))))))
	   hash-table))

(defun make-sys-site (&key name type version)
  (make-pathname :host "SYS"
		 :directory '("SITE")
		 :name name
		 :type type
		 :version version))

(defun find-sys-site (&key name type version)
  (let ((basic-path (send (make-sys-site :name name :version version) :translated-pathname)))
    (or (fs:find-file-with-type basic-path type)
	(send basic-path :new-pathname :type type))))

(defvar *cached-site-directory* nil)

;;; I think this is the right value, but just in case...
(defvar *missing-translation-file-action* :warn
  "NIL means no action, T means error, :WARN means issue a namespace warning.")


(defun get-site-directory (&optional (error-p t))
  (let ((site-directory (send net:*local-site* ':site-directory)))
    (block failure
      (when (null site-directory)
	(maybe-namespace-warn error-p
			      "The local site (~A) is missing the :SITE-DIRECTORY attribute"
			      (send net:*local-site* ':name))
	(return-from failure *cached-site-directory*))
      (when (null (string-search-char #/: site-directory))
	(maybe-namespace-warn error-p
			      "The :SITE-DIRECTORY site attribute, ~S, ~
			       does not contain a host"
			      site-directory)
	(return-from failure *cached-site-directory*))
      (let ((pathname (send (parse-pathname site-directory) ':new-pathname
			    :name nil :type nil :version nil)))
	(when (null (send pathname ':directory))
	  (maybe-namespace-warn error-p
				"The :SITE-DIRECTORY site attribute, ~S, ~
			         does not contain a directory"
				site-directory)
	  (return-from failure *cached-site-directory*))
	pathname))))


(defun maybe-invalidate-sys-translations (&optional force-p)
  (let ((new-site-directory (get-site-directory :warn)))
    (when (or force-p (neq *cached-site-directory* new-site-directory))
      (send (get-pathname-host "SYS") :invalidate-translations)
      (unless (neti:ns-eq net:*local-site* neti:*distribution-site*)
	(load-new-logical-host-translations *missing-translation-file-action*))
      (setq *cached-site-directory* new-site-directory))))

(add-initialization "Invalidate SYS translations" '(maybe-invalidate-sys-translations) nil
		    'si:site-initialization-list)

(defun maybe-namespace-warn (error-p format-string &rest format-args)
  (declare (dbg:error-reporter))
  (let ((function (selectq error-p
		    (:warn #'neti:namespace-warning)
		    (t #'ferror))))
    (lexpr-funcall function format-string format-args)))

;;; This is called when changing the site to load files of logical directory translations.
;;; These files are of the form SYS:SITE;foo TRANSLATIONS, where foo is the name of
;;; a logical host.  The SYS:SITE; comes from the SITE-DIRECTORY attribute of the site.
;;; This could do (MAKE-SYSTEM 'LOGICAL-PATHNAMES-TRANSLATION-FILES
;;;			       ':RELOAD ':NO-RELOAD-SYSTEM-DECLARATION ':NOCONFIRM)
;;; but it does it manually because it's doing all this error-checking anyway.
(defun load-new-logical-host-translations (&optional (error-p t))
  (catch-error-restart (error "Skip changing logical pathnames")
    (let ((pathnames
	    (with-automatic-login-to-sys-host
	      (loop for name in (if *logical-pathname-host-list*
				    (loop for host in *logical-pathname-host-list*
					  collect (send host ':name))
				    '("SYS"))	;Nothing defined yet, will need SYS.
		    if (cl:load (make-sys-site
				  :name name
				  :type :logical-pathname-directory-translations
				  :version :newest)
				:verbose nil
				:if-does-not-exist (if (eq error-p t) :error nil)
				:default-package "FS")
		      collect (make-sys-site
				:name name
				:type :logical-pathname-directory-translations
				:version :newest)
		    else do (when (eq error-p :warn)
			      (neti:namespace-warning "Translation file for ~A not found."
						      name))))))
      (when (variable-boundp #'sct:find-system-named)
	(let ((module (sct:find-module-named (sct:find-system-named
					       'logical-pathnames-translation-files t)
					     'logical-pathnames-translation-files)))
	  (when module
	    (loop for p in pathnames
		  collect `(,p ,p) into inputs
		  finally (setf (sct:module-inputs module) inputs))))))))

(defvar *describe-logical-host-fquery-choices*
	'(:CHOICES
	  (((T "Yes.") #/Y #\SP #/T)
	   ((NIL "No.") #/N #\RUBOUT))))


;;; Return a function that queries until told to proceed without
;;; querying.

(defun make-describe-logical-host-query-proceed (&key (proceed-message "Proceed.")
						      (skip-message "Skip.")
						      (indent 0))
  (let ((query-proceed nil)
	(choices (get (locf *describe-logical-host-fquery-choices*) :choices)))
    (when proceed-message
      (setq choices
	    (append choices `(((proceed ,proceed-message) #/P)))))
    (when skip-message
      (setq choices
	    (append choices `(((skip ,skip-message) #/S)))))
    (let ((options `(:choices ,choices)))
      #'(lambda (skip-test &optional format-string &rest format-arguments)
	  (if skip-test
	      (eq query-proceed 'skip)
	    (unless (eq query-proceed 'skip)
	      (or query-proceed
		  (with-indentation (query-io indent)
		    (let ((result (lexpr-funcall #'fquery options
						 format-string format-arguments)))
		      (selectq result
			(skip
			 (setq query-proceed result)
			 nil)
			(proceed
			 (setq query-proceed result))
			(otherwise result)))))))))))

(defun describe-logical-host (host)
  (setq host (get-pathname-host host))
  (check-arg-type host logical-host)
  (format t "~&Logical host ~A:~@
	     ~:[~*~;default physical host:  ~A~]~%"
	  (send host :name)
	  (send host :default-host)
	  (send host :default-host))
  (describe-logical-host-translations host)
  (when (y-or-n-p "Do you want to see the translation rules?")
    (with-indentation (standard-output 2)
      (with-indentation (query-io 2)
	(describe-logical-host-translation-rules host))))
  host)

(defun describe-logical-host-translations (host)
  (loop for (from to) in (send host :translations)
	do (format t "~&~A  ~A~%" from to)))

(defun describe-logical-host-translation-rules (host)
  (when (y-or-n-p "Do you want to see them in search order?")
    (with-indentation (standard-output 2)
      (with-indentation (query-io 2)
	(describe-logical-host-translation-rules-search host))))
  (when (y-or-n-p "Do you want to see them by group?")
    (with-indentation (standard-output 2)
      (with-indentation (query-io 2)
	(describe-logical-host-translation-rules-by-group host)))))

(defun describe-logical-host-translation-rules-by-group (host)
  (let ((query (make-describe-logical-host-query-proceed
		 :proceed-message "Proceed with rest of groups."
		 :skip-message "Skip rest of groups.")))
    (when (funcall query nil "Show Permanent rules?")
      (format t "~&Permanent rules:")
      (with-indentation (standard-output 2)
	(with-indentation (query-io 2)
	  (describe-logical-host-translation-rules-by-group-1
	    host (send host :permanent-translation-rules)))))
    (when (funcall query nil "Show Site rules?")
      (format t "~&Site rules:")
      (with-indentation (standard-output 2)
	(with-indentation (query-io 2)
	  (describe-logical-host-translation-rules-by-group-1
	    host (send host :site-translation-rules)))))
    (when (funcall query nil "Show logical host-specific translation rules?")
      (format t "~&Logical host-specific translation rules:")
      (with-indentation (standard-output 2)
	(with-indentation (query-io 2)
	  (describe-logical-host-translation-rules-by-group-1
	    host (send host :translation-rules)))))
    (when (funcall query nil "~&Show global translation rules?")
      (format t "~&Show global translation rules:")
      (with-indentation (standard-output 2)
	(with-indentation (query-io 2)
	  (describe-logical-host-translation-rules-by-group-1
	    host *global-translation-rules*))))))

(defun describe-logical-host-translation-rules-by-group-1 (host rule-list)
  (loop with rules
	for rule in rule-list
	for system = (translation-rule-system-type rule)
	for bucket = (assq system rules)
	unless bucket
	  do (setq bucket (ncons system))
	     (push bucket rules)
	do (setf (cdr bucket)
		 (nconc (cdr bucket) (ncons rule)))
	finally
	  (setq rules (sortcar rules #'alphalessp))
	  (describe-logical-host-translation-rules-search-1 host rules)))

(defun describe-logical-host-translation-rules-search (host)
  (loop with rules
	for hash-bucket being the hash-elements of (send host :translation-rule-table)
	    with-key key
	for (system . nil) = key
	for bucket = (assq system rules)
	unless bucket
	  do (setq bucket (ncons system))
	     (push bucket rules)
	do (setf (cdr bucket)
		 (append hash-bucket (cdr bucket)))
	finally
	  (setq rules (sortcar rules #'alphalessp))
	  (describe-logical-host-translation-rules-search-1 host rules)))

(defun describe-logical-host-translation-rules-search-1 (host rules)
  (if (null rules)
      (format t "  [none]")
    (loop with query = (make-describe-logical-host-query-proceed
			 :proceed-message "Proceed for this system type."
			 :skip-message "Skip remaining system types.")
	  for rule-list in rules
	  until (funcall query 'skip-test)
	  do (describe-logical-host-translation-system-rule-list host rule-list query))))

(defun describe-logical-host-translation-system-rule-list (host system-rule-list query)
  (destructuring-bind (system-type . rule-list) system-rule-list
    (when (funcall query nil "Do you want to see them for ~A? " system-type)
      (format t "~&Rules for ~A:" system-type)
      (setq rule-list
	    (stable-sort rule-list
			 #'(lambda (rule1 rule2)
			     (let ((key1 (or (translation-rule-key rule1)
					     (send host :get-translation-rule-key
						   system-type
						   (translation-rule-pathname rule1))))
				   (key2 (or (translation-rule-key rule2)
					     (send host :get-translation-rule-key
						   system-type
						   (translation-rule-pathname rule2)))))
			       (rule-key-lessp key1 key2)))))
      (with-indentation (standard-output 2)
	(describe-logical-host-translation-rules-search-2 rule-list)))))

(defun rule-key-lessp (key1 key2)
  (loop for part1 in key1
	for part2 in key2
	always (or (and (neq part1 :wild) (eq part2 :wild))
		   (and (neq part1 :wild) (neq part2 :wild)))
	thereis (and (neq part1 :wild) (eq part2 :wild))))


(defun describe-logical-host-translation-rules-search-2 (bucket)
  (if (null bucket)
      (format t "  [none]")
    (loop for rule in bucket
	  do (describe-rule rule))))

(defun describe-rule (rule)
  (format t "~&  ~A >>> ~S ~{~S~^, ~}" 
	  (translation-rule-pathname rule)
	  (translation-rule-type rule)
	  (translation-rule-arguments rule)))
