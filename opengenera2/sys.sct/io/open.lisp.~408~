;;; -*- Mode: LISP; Package: FILE-SYSTEM; Base: 8 -*-

;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;;; Global interface functions, and random file stuff

;;; For Maclisp compatibility, the OPEN function accepts an option name
;;; or a list of options (a single arg), as an alternative to
;;; keywords and values.  These option names can be in any package.

;;; Possible keywords and values include the following:
;;; Keyword	     Possible Values	Default		Comment
;;; :DIRECTION		:INPUT		:INPUT
;;;			:OUTPUT
;;;			:APPEND				Will err if the file doesn't exist.
;;;			NIL				This is a probe opening,
;;;							no data is transfered.
;;; :ELEMENT-TYPE	type specifier	CHARACTER	Common-Lisp types.  This subsumes
;;;							:CHARACTERS and :BYTE-SIZE.
;;;			:DEFAULT			whatever the file says it is.
;;; :CHARACTERS		boolean		T		T if file is textual data.
;;;			:DEFAULT
;;; :BYTE-SIZE		NIL		NIL		16 for binary files.
;;;							System-dependent fixed value for
;;;							text files.
;;;			:DEFAULT			Whatever size the file says it is.
;;;			fixnum
;;; :ERROR		T		T		Do nothing special if an error occurs
;;;			NIL				Return error if operation error occurs
;;;			:REPROMPT			If operation error occurs, prompt
;;;							the user for a new pathname, and retry
;;; :INHIBIT-LINKS	boolean		NIL
;;; :DELETED		boolean		NIL
;;; :PRESERVE-DATES	boolean		NIL		Do not update reference or
;;;							modification dates.
;;; :ESTIMATED-LENGTH   fixnum				Estimate of size of file.

(DEFUN (COMPILER:STYLE-CHECKER OBSOLETE-ARGUMENTS OPEN) (OPEN-FORM)
  (SCL:DESTRUCTURING-BIND (IGNORE &OPTIONAL PATHNAME &REST KEYS)
     OPEN-FORM
    (IGNORE PATHNAME)				;arg number check gets this.
    (LOOP WITH KEY = T FOR ARG IN KEYS
	  DO
      (WHEN KEY
	(WHEN (AND (LISTP ARG)
		   (EQ (CAR ARG) 'QUOTE)
		   (NOT (SYMBOLP (SECOND ARG))))
	  (WARN "~S is not a symbol, and is therefore not a valid keyword for ~S.~@
It may be an obsolete ~S argument, or it may just be an error."
		(SECOND ARG)
		'OPEN
		'OPEN)))
      (SETQ KEY (NOT KEY))
      FINALLY
	(UNLESS KEY
	  (WARN "Odd number of arguments in call to ~S. This may result from obsolete~@
syntax."
		'OPEN)))))

;;; Define the directions for OPEN that are in CL and/or generally widespread.

(DEFINE-OPEN-DIRECTION :INPUT :INPUT)
(DEFINE-OPEN-DIRECTION :OUTPUT :OUTPUT)
(DEFINE-OPEN-DIRECTION :IO :OUTPUT)
(DEFINE-OPEN-DIRECTION :PROBE :INPUT)
(DEFINE-OPEN-DIRECTION :PROBE-LINK :INPUT)
(DEFINE-OPEN-DIRECTION :PROBE-DIRECTORY :INPUT)
(DEFINE-OPEN-DIRECTION :BLOCK-INPUT :INPUT)
(DEFINE-OPEN-DIRECTION :BLOCK :OUTPUT)
(DEFINE-OPEN-DIRECTION :TRUNCATE :OUTPUT)

;;; obsolete but still accepted. 
(DEFINE-OPEN-DIRECTION :IN :INPUT)
(DEFINE-OPEN-DIRECTION :OUT :OUTPUT)


;;; Supply a reasonable arglist for open...
(DEFUN OPEN (PATHNAME &REST ALL-ARGUMENTS
	     &KEY
	     (DIRECTION :INPUT)
	     (ELEMENT-TYPE 'SCL:CHARACTER ELEMENT-TYPE-P)
	     (IF-EXISTS NIL IF-EXISTS-P)
	     (IF-DOES-NOT-EXIST NIL IF-DOES-NOT-EXIST-P)
	     (ERROR T ERROR-P)			;This is ZL, but we still need it
	     INHIBIT-LINKS
	     (CHARACTERS T CHARACTERS-P)
	     (BYTE-SIZE NIL BYTE-SIZE-P)
	     &ALLOW-OTHER-KEYS)
  "OPEN takes additional keywords depending on the item being opened."
  (DECLARE (ARGLIST PATHNAME &REST ACCESS-PATH-SPECIFIC-AND-ZL-COMPATIBLE-KEYWORDS
		    &KEY (DIRECTION :INPUT)
			 (ELEMENT-TYPE 'SCL:CHARACTER)
			 (IF-EXISTS '|See-CltL|)
			 (IF-DOES-NOT-EXIST '|See-CLtL|)
			 (ERROR T)			;SCL
		    &ALLOW-OTHER-KEYS))
  (CL:CHECK-TYPE ERROR (CL:MEMBER T NIL :REPROMPT))
  (FORCE-USER-TO-LOGIN)				;---is this really the right place for this?
  (SETQ PATHNAME (CL:MERGE-PATHNAMES PATHNAME (FS:DEFAULT-PATHNAME)))	;Works on streams
  (SETQ DIRECTION
	(CL:CASE DIRECTION
	  (:OUT ':OUTPUT)
	  (:IN ':INPUT)
	  ((NIL) ':PROBE)
	  (T DIRECTION)))
  (WHEN INHIBIT-LINKS
    (UNLESS (EQ DIRECTION ':PROBE)
      (ERROR "INHIBIT-LINKS only meaningful for :PROBE opening."))
    (SETQ DIRECTION ':PROBE-LINK))
  (LET ((DIRECTION-TYPE (GET DIRECTION 'OPEN-DIRECTION-TYPE)))
    (UNLESS DIRECTION-TYPE (ERROR "Undefined :DIRECTION value ~S" DIRECTION))
    
    ;; decide whether to handle specific errors and return specific values for CL.
    ;; CLtL page 421
    (WHEN (EQ DIRECTION-TYPE ':OUTPUT)
      (UNLESS IF-EXISTS-P
	(SETQ IF-EXISTS
	      (IF (MEMQ (SEND PATHNAME :VERSION) '(:NEWEST :UNSPECIFIC))
		  ':NEW-VERSION
		  ':ERROR))))
    (UNLESS IF-DOES-NOT-EXIST-P
      (SETQ IF-DOES-NOT-EXIST
	    ;; This default is an unfortunate feature of CL that we don't need
	    ;; to generalize via the DIRECTION-TYPE mechanism.
	    (COND ((EQ DIRECTION :PROBE) NIL)
		  ((OR (EQ DIRECTION-TYPE ':INPUT)
		       (CL:MEMBER IF-EXISTS '(:OVERWRITE :APPEND)))
		   ':ERROR)
		  ((AND (EQ DIRECTION-TYPE ':OUTPUT)
			(NOT (CL:MEMBER IF-EXISTS '(:OVERWRITE :APPEND))))
		   ':CREATE)))))
  (LET ((CATCH-IF-EXISTS
	  (AND (OR (NULL ERROR-P) ERROR)	; explicit :ERROR NIL turns this off.
	       (NULL IF-EXISTS)
	       (NOT (MEMQ DIRECTION '(:INPUT :PROBE)))))
	(CATCH-IF-DOES-NOT-EXIST
	  (AND (OR (NULL ERROR-P) ERROR)
	       (NULL IF-DOES-NOT-EXIST))))
    (COND ((AND ELEMENT-TYPE-P
		(OR CHARACTERS-P BYTE-SIZE-P))
	   (ERROR "OPEN called with both :ELEMENT-TYPE and :CHARACTERS or :BYTE-SIZE"))
	  ((NULL ELEMENT-TYPE-P)
	   (SETQ ELEMENT-TYPE
		 (COND ((AND CHARACTERS-P (EQ CHARACTERS ':WITHOUT-FONTS)) 'CL:STRING-CHAR)
		       ((AND CHARACTERS-P
			     (NEQ DIRECTION ':OUTPUT)
			     (EQ CHARACTERS ':DEFAULT)) ':DEFAULT)
		       ((AND CHARACTERS-P CHARACTERS) 'CL:CHARACTER)
		       ((AND BYTE-SIZE-P
			     (NEQ DIRECTION ':OUTPUT)
			     (EQ BYTE-SIZE ':DEFAULT))
			'(CL:UNSIGNED-BYTE *))
		       (BYTE-SIZE-P (IF (AND BYTE-SIZE (NUMBERP BYTE-SIZE))
					`(CL:UNSIGNED-BYTE ,BYTE-SIZE)
					;; :BYTE-SIZE NIL ??
					`(CL:UNSIGNED-BYTE 16.)))
		       ;; :CHARACTERS NIL, no :BYTE-SIZE.  I think this means 16, not :DEFAULT.
		       ((AND CHARACTERS-P (NULL CHARACTERS))
			`(CL:UNSIGNED-BYTE 16.))
		       (T ELEMENT-TYPE)))))	;just take the default default (CHARACTERS).
    ;; remove those keywords that are only interpreted by us
    ;; or which were canonicalized here, leaving the &rest arg obsolete.
    (SI:WITH-REM-KEYWORDS (F-A-P-ARGS ALL-ARGUMENTS
				      '(:DIRECTION :ELEMENT-TYPE
					:IF-EXISTS :IF-DOES-NOT-EXIST
					:CHARACTERS :BYTE-SIZE
					:ERROR))
      ;;+++ extension to common lisp -- restart handlers for common cases.
      (LOOP DO
	(BLOCK RETRY-OPEN
	  (CATCH-ERROR-RESTART (ERROR "Retry OPEN using a different pathname")
	    (CATCH-ERROR-RESTART (ERROR "Retry OPEN of ~A" PATHNAME)
	      (CONDITION-CASE-IF (NEQ ERROR T) (.ERROR.)
		   (RETURN-FROM OPEN
		     (CONDITION-CASE-IF CATCH-IF-EXISTS (.ERROR.)
			  (CONDITION-CASE-IF CATCH-IF-DOES-NOT-EXIST (.ERROR.)
			       (CL:APPLY
				 #'FILE-ACCESS-PATH-OPEN
				 (PATHNAME-FILE-ACCESS-PATH PATHNAME ':OPEN)
				 (SEND PATHNAME :TRANSLATED-PATHNAME)
				 PATHNAME
				 :DIRECTION DIRECTION
				 :ELEMENT-TYPE ELEMENT-TYPE
				 ;;--- The underlying file access paths are not expected
				 ;;--- to run around returning NIL.  They are expected
				 ;;--- to signal. Just because CL don't have an error system
				 ;;--- does not mean that we have to not use ours.
				 ;;--- these cases make this clear to the callees.
				 :IF-EXISTS (OR IF-EXISTS ':ERROR)
				 :IF-DOES-NOT-EXIST (OR IF-DOES-NOT-EXIST ':ERROR)
				 F-A-P-ARGS)
			     (FILE-NOT-FOUND (RETURN-FROM OPEN (IF ERROR-P .ERROR. NIL))))
			(FILE-ALREADY-EXISTS (RETURN-FROM OPEN (IF ERROR-P .ERROR. NIL)))))
		 (FILE-OPERATION-FAILURE
		   (UNLESS ERROR
		     (RETURN-FROM OPEN .ERROR.))
		   ;;:error :reprompt case. 
		   (SETQ PATHNAME
			 (PROMPT-FOR-NEW-PATHNAME PATHNAME .ERROR. 'OPEN))
		   (RETURN-FROM RETRY-OPEN NIL))))
	      (RETURN-FROM RETRY-OPEN NIL))
	  (SETQ PATHNAME
		(PROMPT-FOR-NEW-PATHNAME PATHNAME NIL 'OPEN)))))))

(DEFUN PROMPT-FOR-NEW-PATHNAME (PATHNAME ERROR OPERATION)
  (SCL:ACCEPT 'CL:PATHNAME :DEFAULT PATHNAME
	      :PROMPT
	      (FORMAT NIL "~:[~2*~;Error~@[ during ~A~]:  ~A~%~]~
Use what pathname instead"
		     ERROR OPERATION ERROR)))

;; Various file access paths talk to protocols that don't know from element-type,
;; only from byte size.  This function supports them.
;; This desperately needs support from the type system, and for now
;; imposes some stringent limitations.
;; Can return NIL if given unknown type specification, and :DEFAULT for (UNSIGNED-BYTE *).
;; Caller should probably call CHECK-STREAM-ELEMENT-TYPE first if it cannot handle these.
(DEFUN BYTE-SIZE-FROM-ELEMENT-TYPE (ELEMENT-TYPE)
  (COND ((EQ ELEMENT-TYPE :DEFAULT) :DEFAULT)
	((CL:SUBTYPEP ELEMENT-TYPE 'SCL:CHARACTER) 8.)
	((CL:SUBTYPEP ELEMENT-TYPE 'SCL:STRING-CHAR) 8.)
	((CL:SUBTYPEP ELEMENT-TYPE 'CL:UNSIGNED-BYTE)
	 (BLOCK BYTE-SIZE
	   (WHEN (LISTP ELEMENT-TYPE)
	     (CL:CASE (FIRST ELEMENT-TYPE)
	       (CL:UNSIGNED-BYTE
		 (UNLESS (EQ (SECOND ELEMENT-TYPE) 'CL:*)
		   (RETURN-FROM BYTE-SIZE (SECOND ELEMENT-TYPE))))
	       (CL:INTEGER
		 (WHEN (AND (EQL (SECOND ELEMENT-TYPE) 0)
			    (FIXP (THIRD ELEMENT-TYPE))
			    (PLUSP (THIRD ELEMENT-TYPE)))
		   (RETURN-FROM BYTE-SIZE (CL:INTEGER-LENGTH (THIRD ELEMENT-TYPE)))))))
	   :DEFAULT))
	))

(DEFUN FIND-FILE-WITH-TYPE (PATHNAME CANONICAL-TYPE)
  (SETQ PATHNAME (FS:PARSE-PATHNAME PATHNAME))
  (IF (SEND PATHNAME ':TYPE)
      PATHNAME
    (LOOP FOR TYPE IN (SEND PATHNAME ':TYPES-FOR-CANONICAL-TYPE CANONICAL-TYPE)
	  FOR PROBE = (PROBEF (SEND PATHNAME ':NEW-PATHNAME ':TYPE TYPE))
	  WHEN PROBE
	    RETURN PROBE)))

(DEFUN CLOSE (STREAM &OPTIONAL ABORTP)
  (SEND STREAM ':CLOSE ABORTP))

;;;Truename of something to be renamed, deleted, or copied.  Not transparent to links.
(DEFUN LINK-OPAQUE-TRUENAME (FILE &OPTIONAL (ERROR-P T) OPAQUE-TO-DIRECTORY-LINKS)
  (SETQ FILE (PARSE-PATHNAME FILE))	;better be defaulted
  (LET ((TN (IF ERROR-P
		(WITH-OPEN-FILE (STREAM FILE :DIRECTION :PROBE-LINK :IF-DOES-NOT-EXIST :ERROR)
		  (SEND STREAM :TRUENAME))
		(CATCH-ERROR-RESTART ((FILE-OPERATION-FAILURE SYS:HOST-NOT-RESPONDING)
				      "Say that file ~A is not there" FILE)
		  (WITH-OPEN-FILE-CASE (STREAM FILE :DIRECTION :PROBE-LINK
						    :IF-DOES-NOT-EXIST :ERROR)
		    (FILE-NOT-FOUND NIL)
		    (:NO-ERROR (SEND STREAM :TRUENAME)))))))
    ;; This masks directory links (this -is- LINK-OPAQUE-TRUENAME, right?) and
    ;; logical devices (VMS etc.)
    (WHEN TN
      (IF OPAQUE-TO-DIRECTORY-LINKS
	  (SEND TN :NEW-PATHNAME
		:HOST (SEND FILE :HOST) 
		:RAW-DEVICE (SEND FILE :RAW-DEVICE)
		:RAW-DIRECTORY (SEND FILE :RAW-DIRECTORY)
		:RAW-NAME (SEND FILE :RAW-NAME)
		:RAW-TYPE (SEND FILE :RAW-TYPE))
	  TN))))

(DEFUN DIRECTORY-LINK-OPAQUE-DIRLIST (PATHNAME &REST OPTIONS)
  (SETQ PATHNAME (PARSE-PATHNAME PATHNAME))
  (LET ((RESULT (LEXPR-FUNCALL #'DIRECTORY-LIST PATHNAME OPTIONS)))
    (IF (SEND PATHNAME :DIRECTORY-WILD-P)
	RESULT					;Release 7+ --- there are major issues here,
	;; this whole function is gross kludgery.
	(CONS (CAR RESULT)
	      ;; This is a lot of consing, but a little compared to what just happened.
	      (LOOP WITH RAWDIR = (SEND PATHNAME :RAW-DIRECTORY)
		    WITH RAWDEV = (SEND PATHNAME :RAW-DEVICE)
		    WITH RAWNAM = (SEND PATHNAME :RAW-NAME)
		    WITH RAWTYP = (SEND PATHNAME :RAW-TYPE)
		    WITH HOST = (SEND PATHNAME :HOST)
		    INITIALLY
		      (WHEN (OR (NOT (STRINGP RAWNAM))
				(STRING-SEARCH #\* RAWNAM))
			(SETQ RAWNAM NIL))
		      (WHEN (OR (NOT (STRINGP RAWTYP))
				(STRING-SEARCH #\* RAWTYP))
			(SETQ RAWTYP NIL))
		    FOR NODE IN (CDR RESULT)
		    FOR (THISPATH . PLIST) = NODE
		    COLLECT (LIST* (SEND THISPATH :NEW-PATHNAME
					 :HOST HOST
					 :RAW-DIRECTORY RAWDIR
					 :RAW-DEVICE RAWDEV
					 :RAW-NAME (OR RAWNAM
						       (SEND THISPATH :RAW-NAME))
					 :RAW-TYPE (OR RAWTYP
						       (SEND THISPATH :RAW-TYPE)))
				   ':TRUENAME THISPATH PLIST))))))

;; Returns three values: the target pathname 
;;			 the truename of the source pathname
;;			 the truename of the target pathname
(DEFUN RENAMEF (STRING-OR-STREAM NEW-NAME &OPTIONAL (ERROR-P T) &AUX STREAM)
  (DECLARE (VALUES NEW-NAME OLD-TRUENAME NEW-TRUENAME))
  (FORCE-USER-TO-LOGIN)
  (IF (OR (STRINGP STRING-OR-STREAM)
	  (TYPEP STRING-OR-STREAM 'PATHNAME))	;Not a stream
      (SETQ STRING-OR-STREAM (MERGE-PATHNAMES STRING-OR-STREAM)
	    NEW-NAME (PARSE-PATHNAME NEW-NAME NIL STRING-OR-STREAM))	;don't merge yet...
      (SETQ STREAM STRING-OR-STREAM))
  (LET (FROM-TRUENAME TO-TRUENAME THE-ERROR
	(FROM-PATHNAME
	  (COND (STREAM (SEND STREAM ':TRUENAME))
		;; Iff MERGE-PATHNAMES will inherit the version, we must find it first.
		((AND (MEMQ (SEND STRING-OR-STREAM ':VERSION) '(:OLDEST :NEWEST))
		      ;;has been merged
		      (OR (EQ (SEND NEW-NAME ':VERSION) ':WILD)
			  (NOT (OR (SEND NEW-NAME ':NAME)
				   (SEND NEW-NAME ':TYPE)
				   (SEND NEW-NAME ':VERSION)))))
		 (OR (LINK-OPAQUE-TRUENAME STRING-OR-STREAM T)
		     STRING-OR-STREAM))   ;Get error later
		(T STRING-OR-STREAM))))		;guaranteed to be the true name
    (SETQ NEW-NAME (MERGE-PATHNAMES NEW-NAME FROM-PATHNAME ':NEWEST))
    (UNLESS (NETI:NS-EQ (SEND (SEND FROM-PATHNAME :TRANSLATED-PATHNAME) ':HOST)
			(SEND (SEND NEW-NAME :TRANSLATED-PATHNAME) ':HOST))
      (ERROR 'RENAME-ACROSS-HOSTS ':PATHNAME FROM-PATHNAME ':NEW-PATHNAME NEW-NAME))
    ;;Wild-merging feature: renaming a.b to c.* should give c.b.
    (IF (SEND NEW-NAME ':WILD-P)
	(SETQ NEW-NAME (SEND FROM-PATHNAME
			     ':TRANSLATE-WILD-PATHNAME NEW-NAME FROM-PATHNAME)))
    (ERROR-RESTART (ERROR "Retry RENAME of ~A to ~A" FROM-PATHNAME NEW-NAME)
      (CONDITION-CASE-IF (NOT ERROR-P) (.ERROR.)
	  (MULTIPLE-VALUE (FROM-TRUENAME TO-TRUENAME)
	    (SEND (OR STREAM FROM-PATHNAME) ':RENAME (SEND NEW-NAME :TRANSLATED-PATHNAME)))
	(FILE-OPERATION-FAILURE (SETQ THE-ERROR .ERROR.))))
    (COND (THE-ERROR)
	  ((AND FROM-TRUENAME TO-TRUENAME (INSTANCEP FROM-TRUENAME))
	   (VALUES NEW-NAME FROM-TRUENAME TO-TRUENAME))
	  (T (VALUES NEW-NAME FROM-PATHNAME NEW-NAME)))))

(DEFUN DELETEF (STRING-OR-STREAM &OPTIONAL (ERROR-P T))
  (AND (OR (STRINGP STRING-OR-STREAM)
	   (TYPEP STRING-OR-STREAM 'PATHNAME))		;Not a stream
       (SETQ STRING-OR-STREAM (MERGE-PATHNAMES STRING-OR-STREAM)))
  (FORCE-USER-TO-LOGIN)
  (ERROR-RESTART (ERROR "Retry DELETE of ~A"
			(IF (TYPEP STRING-OR-STREAM 'PATHNAME)
			    STRING-OR-STREAM
			    (SEND STRING-OR-STREAM ':PATHNAME)))
    (CONDITION-CASE-IF (NOT ERROR-P) (.ERROR.)
	(PROGN (SEND STRING-OR-STREAM ':DELETE) T)
      (FILE-OPERATION-FAILURE .ERROR.))))

(DEFUN UNDELETEF (PATHNAME &OPTIONAL (ERROR-P T))
  (SETQ PATHNAME (MERGE-PATHNAMES PATHNAME))
  (FORCE-USER-TO-LOGIN)
  (ERROR-RESTART (ERROR "Retry UNDELETE of ~A" PATHNAME)
    (CONDITION-CASE-IF (NOT ERROR-P) (.ERROR.)
	(PROGN (SEND PATHNAME ':UNDELETE) T)
      (FILE-OPERATION-FAILURE .ERROR.))))

;;; Returns NIL if file not found, truename if file exists, or signals an error.
(DEFUN PROBEF (FILE)
  (CATCH-ERROR-RESTART ((FILE-OPERATION-FAILURE SYS:HOST-NOT-RESPONDING)
			"Return NIL from PROBE to say file ~A is not there" FILE)
    (LET ((OPENING (CONDITION-CASE ()
			(OPEN FILE ':DIRECTION ':PROBE)
		      (FILE-NOT-FOUND NIL))))
      (IF OPENING
	  (SEND OPENING :TRUENAME)
	  NIL))))

(DEFUN VIEWF (FILE &OPTIONAL (OUTPUT-STREAM STANDARD-OUTPUT) (ELEMENT-TYPE :DEFAULT))
  (SEND OUTPUT-STREAM :FRESH-LINE)
  (CONDITION-CASE (.ERROR.)
       (CONDITION-BIND ((SI:BINARY-FILE-READ-AS-CHARACTER-FILE-ERROR
			  #'SI:BINARY-FILE-READ-AS-CHARACTER-FILE-ERROR-QUERY-HANDLER)
			(SI:ESCAPE-LOADING-STREAM-DECODING-ERROR
			  #'SI:ESCAPE-LOADING-STREAM-DECODING-ERROR-QUERY-HANDLER))
	 (SI:WITH-OPEN-CHARACTER-FILE (FILE-STREAM FILE :PRESERVE-DATES T
							:ELEMENT-TYPE ELEMENT-TYPE)
	   (VIEWF-STREAM FILE FILE-STREAM OUTPUT-STREAM)
	   (SEND FILE-STREAM :TRUENAME)))
     (FS:FILE-OPERATION-FAILURE
       (DBG:REPORT .ERROR. OUTPUT-STREAM)
       NIL)
     (SI:BINARY-FILE-READ-AS-CHARACTER-FILE-ERROR
       NIL)))

(DEFUN VIEWF-STREAM (FILE FILE-STREAM OUTPUT-STREAM)
  (IGNORE FILE)
  (WHEN (OPERATION-HANDLED-P OUTPUT-STREAM :SET-DEFAULT-CHARACTER-STYLE)
    (LET* ((PATHNAME (SEND FILE-STREAM :PATHNAME))
	   (PLIST (READ-ATTRIBUTE-LIST PATHNAME FILE-STREAM)))
      (LET ((CSTYLE (CL:GETF PLIST :DEFAULT-CHARACTER-STYLE)))
	(WHEN CSTYLE
	  (LET ((OSTYLE (SEND OUTPUT-STREAM :DEFAULT-CHARACTER-STYLE)))
	    (UNWIND-PROTECT
		(PROGN
		  (SEND OUTPUT-STREAM :SET-DEFAULT-CHARACTER-STYLE CSTYLE)
		  (STREAM-COPY-UNTIL-EOF FILE-STREAM OUTPUT-STREAM))
	      (SEND OUTPUT-STREAM :SET-DEFAULT-CHARACTER-STYLE OSTYLE)))
	  (RETURN-FROM VIEWF-STREAM)))))
  (STREAM-COPY-UNTIL-EOF FILE-STREAM OUTPUT-STREAM))

(DEFUN LISTF (PATH &OPTIONAL (OUTPUT-STREAM STANDARD-OUTPUT))
  (SETQ PATH (PARSE-PATHNAME PATH))
  (SETQ PATH (MERGE-PATHNAMES PATH
	       (SEND PATH ':NEW-PATHNAME ':NAME ':WILD ':TYPE ':WILD ':VERSION ':WILD)
	       ':WILD))
  (CONDITION-CASE (ERROR)
      (SEND PATH ':QUICK-VIEW-DIRECTORY OUTPUT-STREAM)
    (FILE-OPERATION-FAILURE (FORMAT OUTPUT-STREAM "~&Can't list ~A:  ~A" PATH ERROR))))


(DEFUN (COMPILER:STYLE-CHECKER COPYF-OLD-ELEMENT-TYPE COPYF) (FORM)
  ;; this will pick up uses of the constant keywords
  (DESTRUCTURING-BIND (COPYF F-P T-P &KEY CHARACTERS BYTE-SIZE &ALLOW-OTHER-KEYS) FORM
    (IGNORE COPYF F-P T-P)
    (WHEN (OR CHARACTERS BYTE-SIZE)
      (WARN ":CHARACTERS and :BYTE-SIZE are obsolete. Use :ELEMENT-TYPE"))))

(DEFVAR *DEBUGGING-COPYF* NIL)

(DEFMACRO WITH-COPYF-CREATE-DIRECTORIES ((CREATE-DIRECTORIES) &BODY BODY)
  `(LET ((*COPYF-DNF-SWITCH* ,CREATE-DIRECTORIES))
     (DECLARE (SPECIAL *COPYF-DNF-SWITCH*))
     (DO () (NIL)
       (CATCH 'COPYF-TARGET-RETRY
	 (RETURN
	   (CONDITION-BIND-IF ,CREATE-DIRECTORIES
			      ((DIRECTORY-NOT-FOUND #'COPYF-DNF-HANDLER))
	     . ,BODY))))))

(DEFUN COPYF (FROM-PATHNAME TO-PATHNAME
	      &KEY
	      (ELEMENT-TYPE ':DEFAULT ELEMENT-TYPE-P)
	      (CHARACTERS ':DEFAULT CHARACTERS-P)
	      (BYTE-SIZE NIL BYTE-SIZE-P)
	      (COPY-CREATION-DATE T)
	      (COPY-AUTHOR T)
	      (REPORT-STREAM NIL)
	      (CREATE-DIRECTORIES ':QUERY)
	      (IF-EXISTS NIL IF-EXISTS-P)
	      &AUX DESCRIP TO-ELEMENT-TYPE
	      )
  (COND ((AND ELEMENT-TYPE-P
	      (OR CHARACTERS-P BYTE-SIZE-P))
	 (ERROR "Both :ELEMENT-TYPE and one of the obsolete keywords ~@
:CHARACTERS and :BYTE-SIZE specified to COPYF"))
	((OR CHARACTERS-P BYTE-SIZE-P)
	 (SETQ ELEMENT-TYPE
	       (ELEMENT-TYPE-FROM-OLD-FS-INFO CHARACTERS BYTE-SIZE))
	 (WHEN (EQUAL ELEMENT-TYPE '(CL:UNSIGNED-BYTE *))	;not a good idea here
	   (SETQ ELEMENT-TYPE ':DEFAULT))))
  (SETQ FROM-PATHNAME (MERGE-PATHNAMES FROM-PATHNAME)
	TO-PATHNAME (PARSE-PATHNAME TO-PATHNAME NIL FROM-PATHNAME))	;don't merge yet...
  
  ;;
  ;; Unfortunately, if we are trying to copy and name/type/version
  ;; preserve, we must find the link-opaque truename in order to get the
  ;; target name, and we cannot get it from the open stream if a link was
  ;; involved.
  ;;
  (IF (AND (MEMQ (SEND FROM-PATHNAME ':VERSION) '(:NEWEST :OLDEST))
	   (OR (EQ (SEND TO-PATHNAME ':VERSION) ':WILD)
	       (NOT (OR (SEND TO-PATHNAME ':NAME)
			(SEND TO-PATHNAME ':TYPE)
			(SEND TO-PATHNAME ':VERSION)))))
      (SETQ FROM-PATHNAME (LINK-OPAQUE-TRUENAME FROM-PATHNAME T)))
  (SETQ TO-PATHNAME (MERGE-PATHNAMES TO-PATHNAME FROM-PATHNAME ':NEWEST))
  ;;wild-merging feature: copying a.b to c.* should give c.b.
  (IF (SEND TO-PATHNAME ':WILD-P)
      (SETQ TO-PATHNAME (SEND FROM-PATHNAME
			      ':TRANSLATE-WILD-PATHNAME TO-PATHNAME FROM-PATHNAME)))

  (WHEN (EQ ELEMENT-TYPE ':DEFAULT)		;we cannot trust the f-a-p's to
						;do canonical type processing
						;yet, because there wasn't time to
						;finish that job in rel7.
    ;;the right modularity would be for those f-a-p's (unix,vms) that need
    ;;canonical type heuristication to do it.
    ;;some f-a-p's already do, but it isn't proved that they all do yet.
    (MULTIPLE-VALUE-BIND (CT-ET CT-ET-DEFINITIVE)
	(DEFAULT-ELEMENT-TYPE-FROM-CANONICAL-TYPE (SEND FROM-PATHNAME :CANONICAL-TYPE))
      (WHEN CT-ET-DEFINITIVE (SETQ ELEMENT-TYPE CT-ET))
      (WHEN *DEBUGGING-COPYF*
	(IF CT-ET-DEFINITIVE
	    (FORMAT T "~&Defaulting element type to ~S from canonical type ~S."
		    ELEMENT-TYPE
		    (SEND FROM-PATHNAME :CANONICAL-TYPE))
	    (FORMAT T "~&Defaulting element type via ':DEFAULT to open.")))))

  (ERROR-RESTART ((ERROR) "Retry copying ~A to ~A." FROM-PATHNAME TO-PATHNAME)
    (WITH-OPEN-FILE (ISTREAM FROM-PATHNAME
			     ':DIRECTION ':INPUT
			     ':ELEMENT-TYPE ELEMENT-TYPE)

      ;; After opening the input file, figure out what element type to use for
      ;; the copy, if we don't already know.
      (WHEN (AND (EQ ELEMENT-TYPE ':DEFAULT)
		 (EQ (%FILE-STREAM-FILE-ELEMENT-TYPE ISTREAM) 'CL:CHARACTER))
        ;; If we get a CHARACTER stream, 'decapsulate' it and
	;; set the element type to STRING-CHAR, so the copying will
	;; be much more efficient by not decoding and re-encoding epsilons.
	;; NB!  This assumes there's only one kind of character encoding in
	;; the world; this'll have to be redone, with help at the access-path
	;; level, when any of the X3J13-proposed things become real.
	;;
	(WHEN (OPERATION-HANDLED-P ISTREAM 'SI:UNENCAPSULATE-STREAM)
	  (WHEN *DEBUGGING-COPYF*
	    (FORMAT T "~&Decapsulating ~S" ISTREAM))
	  (SETQ ISTREAM (SI:UNENCAPSULATE-STREAM ISTREAM))
	  (WHEN *DEBUGGING-COPYF*
	    (FORMAT T " -> ~S" ISTREAM))
	  (SETQ ELEMENT-TYPE 'CL:STRING-CHAR)
	  (WHEN *DEBUGGING-COPYF*
	    (FORMAT T "~&Setting element-type to ~S" ELEMENT-TYPE))))

      (IF (EQ ELEMENT-TYPE ':DEFAULT)
	  ;; assume that whatever kind of stream we are reading we can write.
	  (SETQ TO-ELEMENT-TYPE (%FILE-STREAM-FILE-ELEMENT-TYPE ISTREAM))
	  (SETQ TO-ELEMENT-TYPE ELEMENT-TYPE))

      (SETQ FROM-PATHNAME (OR (SEND-IF-HANDLES ISTREAM :TRUENAME) FROM-PATHNAME))
      (WHEN COPY-AUTHOR
	(SETQ COPY-AUTHOR
	      (OR (SEND-IF-HANDLES ISTREAM ':AUTHOR)
		  (GET
		    (CONDITION-CASE ()		;try to get props
			 (FS:FILE-PROPERTIES FROM-PATHNAME)
		       (ERROR '(NIL)))
		    ':AUTHOR))))
      ;;--- print-type-description?
      (SETQ DESCRIP (COND ((CL:SUBTYPEP 'CL:STRING-CHAR TO-ELEMENT-TYPE)  "text")
			  ((EQUAL TO-ELEMENT-TYPE '(CL:UNSIGNED-BYTE 16.)) "binary")
			  ((EQ TO-ELEMENT-TYPE 'CL:FIXNUM)
			   "byte-size 32.")
			  (T (FORMAT NIL "byte-size ~D."
				     (SECOND TO-ELEMENT-TYPE)	;ycch!
				     ))))
      (WITH-COPYF-CREATE-DIRECTORIES (CREATE-DIRECTORIES)
	(WITH-OPEN-FILE (OSTREAM TO-PATHNAME
				 ':DIRECTION ':OUTPUT
				 ':ELEMENT-TYPE TO-ELEMENT-TYPE
				 ':IF-EXISTS
				 (IF IF-EXISTS-P
				     IF-EXISTS
				     (IF (EQ (SEND TO-PATHNAME ':VERSION) ':NEWEST)
					 ':NEW-VERSION
					 ':SUPERSEDE))
				 ':ESTIMATED-LENGTH
				 (OR (SEND ISTREAM ':SEND-IF-HANDLES ':LENGTH) 0))
	  (WHEN OSTREAM
	    (WHEN REPORT-STREAM
	      (FORMAT REPORT-STREAM "~&Copying ~A to ~A (~A)"
		      FROM-PATHNAME TO-PATHNAME DESCRIP))
	    (WHEN *DEBUGGING-COPYF*
	      (FORMAT T "~&Input stream-element-type ~S, output stream-element-type ~S."
		      (CL:STREAM-ELEMENT-TYPE ISTREAM)
		      (CL:STREAM-ELEMENT-TYPE OSTREAM)))
	    (STREAM-COPY-UNTIL-EOF ISTREAM OSTREAM)
	    (WHEN (OR COPY-CREATION-DATE COPY-AUTHOR)	
	      (SEND OSTREAM ':EOF)		; make sure the data is all in the file
	      (WHEN COPY-CREATION-DATE
		(SETQ COPY-CREATION-DATE
		      (SEND-IF-HANDLES ISTREAM :CREATION-DATE)))
	      (COPY-AUTHOR-AND-CREATION-DATE OSTREAM COPY-AUTHOR COPY-CREATION-DATE
					     (OR REPORT-STREAM ERROR-OUTPUT)))
	    (CLOSE ISTREAM)			;so copy a.b.1  a.b.1 can :supersede right.
	    (CLOSE OSTREAM)
	    (SETQ TO-PATHNAME
		  (OR (SEND-IF-HANDLES OSTREAM ':TRUENAME) TO-PATHNAME))
	    (WHEN REPORT-STREAM
	      (FORMAT REPORT-STREAM "~&Copied ~A to ~A (~A)"
		      FROM-PATHNAME TO-PATHNAME DESCRIP)))))))
  TO-PATHNAME)

(DEFUN COPYF-DNF-HANDLER (ERROR)
  (LET ((PATHNAME (SEND ERROR ':PATHNAME)))
    (DECLARE (SPECIAL *COPYF-DNF-SWITCH*))
    (WHEN (OR (EQ *COPYF-DNF-SWITCH* T)
	      (FQUERY FORMAT:YES-OR-NO-P-OPTIONS
		      "~A~%Shall I attempt to create the directory ~A:~A? "
		      ERROR
		      (SEND (SEND PATHNAME ':HOST) ':NAME-AS-FILE-COMPUTER)
		      (SEND PATHNAME ':STRING-FOR-DIRECTORY)))
      (IF (CREATE-DIRECTORIES-RECURSIVELY PATHNAME)
	  (THROW 'COPYF-TARGET-RETRY NIL)))
    NIL))


(DEFUN CREATE-DIRECTORIES-RECURSIVELY (PATH)
  ;; Recursion doesn't make any sense for a logical pathname.
  (SETF PATH (SEND PATH :TRANSLATED-PATHNAME))
  (BLOCK CREATE-DIRECTORIES-RECURSIVELY
    (ERROR-RESTART (ERROR "Retry creating ~A:~A."
			  (SEND (SEND PATH :HOST) :NAME-AS-FILE-COMPUTER)
			  (SEND PATH :STRING-FOR-DIRECTORY))
      (CONDITION-CASE (ERROR)
	  (SEND PATH :CREATE-DIRECTORY)		;create the directory
	;; The directory already exists.  We win big.
	(FS:DIRECTORY-ALREADY-EXISTS
	  (RETURN-FROM CREATE-DIRECTORIES-RECURSIVELY T))
	;; Parent does not exist.  Try to create it (recursively).
	(FS:DIRECTORY-NOT-FOUND
	  (UNLESS (CREATE-DIRECTORIES-RECURSIVELY (SEND PATH :DIRECTORY-PATHNAME-AS-FILE))
	    ;; Failed.  We fail too.
	    (RETURN-FROM CREATE-DIRECTORIES-RECURSIVELY NIL))
	  ;; Succeeded.  Now retry creating the directory.  
	  ;; If this fails, we don't catch the error.
	  (SEND PATH :CREATE-DIRECTORY))
	;; Never heard of directory creation.
	((SYS:UNCLAIMED-MESSAGE FS:UNKNOWN-OPERATION)
	 (FSIGNAL "The operating system and//or file server on ~A does not support~@
		  remote directory creation.  Cannot create ~A.  If you wish to, create~@
		  it on the system itself, and then type ~C to continue."
		  (SEND PATH :HOST) (SEND PATH :STRING-FOR-DIRECTORY) #\RESUME)
	 ;; User must have resumed.  Hope for the best.
	 (RETURN-FROM CREATE-DIRECTORIES-RECURSIVELY T))))
    ;; Tell the user that we did something.
    (FORMAT T "~&Created ~A:~A."
	    (SEND (SEND PATH :HOST) :NAME-AS-FILE-COMPUTER)
	    (SEND PATH :STRING-FOR-DIRECTORY))
    T))


(DEFUN COPY-FILE-GUESS-BYTE-SIZE (PATHNAME &AUX PROP)
  (LET ((CANTYPE (SEND PATHNAME ':CANONICAL-TYPE)))
    (COND ((STRINGP CANTYPE) (VALUES NIL ':DEFAULT))
	  ((SETQ PROP (GET CANTYPE ':BINARY-FILE-BYTE-SIZE))
	   (VALUES PROP NIL))
	  (T (VALUES NIL ':DEFAULT)))))

(DEFUN COPY-AUTHOR-AND-CREATION-DATE (STREAM NEW-AUTHOR NEW-CREATION-DATE
				      &OPTIONAL (REPORT-STREAM ERROR-OUTPUT))
  ;;Make sure to check zwei:com-copy-file if you change this  --swm
  (LET ((ATTRIBUTES (GET (SEND (SEND (SEND STREAM ':TRUENAME) ':HOST) ':SYSTEM-TYPE)
			 'ATTRIBUTES)))
    (PROG FUNCTION ()
	  ;; Don't even try if operating system not likely to do it.
	  (WHEN (MEMQ ':CANT-SET-CREATION-INFO ATTRIBUTES) (RETURN NIL))
	  (WHEN (OR (MEMQ ':CANT-SET-CREATION-DATE ATTRIBUTES)
		    (MEMQ ':CANT-SET-AUTHOR ATTRIBUTES))
	    (GO TRY-SEPARATELY))
	  (WHEN (AND NEW-AUTHOR NEW-CREATION-DATE)
	    (CONDITION-CASE ()
		 (SEND STREAM ':CHANGE-PROPERTIES T ':CREATION-DATE NEW-CREATION-DATE
		       ':AUTHOR NEW-AUTHOR)
	       (FS:FILE-OPERATION-FAILURE (GO TRY-SEPARATELY))
	       (FS:UNKNOWN-OPERATION (RETURN NIL))
	       (:NO-ERROR (RETURN-FROM FUNCTION NIL))))
       TRY-SEPARATELY
	  (WHEN (AND NEW-CREATION-DATE (NOT (MEMQ ':CANT-SET-CREATION-DATE ATTRIBUTES)))
	    (CONDITION-CASE-IF REPORT-STREAM (ERROR)
		 (SEND STREAM ':CHANGE-PROPERTIES T ':CREATION-DATE NEW-CREATION-DATE)
	       (FS:FILE-OPERATION-FAILURE
		 (FORMAT REPORT-STREAM "~&Can't set creation date because ~A" ERROR))
	       (FS:UNKNOWN-OPERATION NIL)))
	  (WHEN (AND NEW-AUTHOR (NOT (MEMQ ':CANT-SET-AUTHOR ATTRIBUTES)))
	    (CONDITION-CASE-IF REPORT-STREAM (ERROR)
		 (SEND STREAM ':CHANGE-PROPERTIES T ':AUTHOR NEW-AUTHOR)
	       (FS:FILE-OPERATION-FAILURE
		 (FORMAT REPORT-STREAM "~&Can't set author because ~A" ERROR))
	       (FS:UNKNOWN-OPERATION NIL))))))

;(DEFVAR USER-HOMEDIRS NIL)
(DEFVAR USER-PERSONAL-NAME "")		        ;Full name, last name first
(DEFVAR USER-PERSONAL-NAME-FIRST-NAME-FIRST "") ;Full name, first name first
(DEFVAR USER-GROUP-AFFILIATION #/-)
(DEFVAR USER-LOGIN-MACHINE NIL)

;;; QUIET-USER-HOMEDIR is like USER-HOMEDIR except never requires
;;; login
(DEFUN QUIET-USER-HOMEDIR (&OPTIONAL (HOST USER-LOGIN-MACHINE))
  (USER-HOMEDIR-INTERNAL HOST :QUIET-HOMEDIR))

(DEFUN USER-HOMEDIR (&OPTIONAL (HOST USER-LOGIN-MACHINE))
  (FORCE-USER-TO-LOGIN)
  (USER-HOMEDIR-INTERNAL HOST :HOMEDIR))

;;; Don't do *ANYTHING* in this which will require the user to log in
;;; if called from QUIET-USER-HOMEDIR.
(DEFUN USER-HOMEDIR-INTERNAL (HOST MESSAGE)
  (SETQ HOST (GET-PATHNAME-HOST HOST))
  (WHEN (TYPEP HOST 'LOGICAL-HOST)
    (SETQ HOST (SEND HOST ':DEFAULT-HOST)))	;Just in case
  (SEND (SEND HOST :SAMPLE-PATHNAME) MESSAGE))


;;; The following two variables and two functions make up a protocol for anonymously
;;; logging into the sys host if necessary.  "Necessary" has two components here: 1>
;;; the machine is not logged in and 2> is trying to do an operation for which being
;;; logged in is required, such as accessing a file on a file server.
;;;
;;; Operations for which logging in is required generally incorporate a call to
;;; FS:FORCE-USER-TO-LOGIN.  OPEN is such a function.  Normally, if the machine is
;;; not logged in, this will result in a prompt to the user.  However, if a caller
;;; of OPEN, or whatever "login-required" function, has enclosed the call in a
;;; FS:WITH-AUTOMATIC-LOGIN-TO-SYS-HOST form, then the machine is silently logged
;;; in as LISP-MACHINE.
;;;
;;; This macro and function are organized to deal correctly with two problems:
;;;
;;; 1> Nested invocations of WITH-AUTOMATIC-LOGIN-TO-SYS-HOST will correctly set
;;;    the conditions for an automatic login, and undo it with a LOGOUT, at the
;;;    outermost level.
;;;
;;; 2> Invocation of WITH-AUTOMATIC-LOGIN-TO-SYS-HOST in multiple processes
;;;    will work; that is, one process reaching the end of its [possibly nested]
;;;    invocations won't logout if another process is within a similar form.
;;;
;;; 3> Warm-booting won't cause us to attempt operations for which we should be
;;;    logged-in without first logging in.
;;;
;;; 4> If an automatic login has been invoked, but the user has logged in as a
;;;    real user during the enclosed operation (such as loading patches), then no
;;;    LOGOUT is done.
(DEFVAR-RESETTABLE *AUTOMATICALLY-LOGIN-TO-SYS-HOST* NIL NIL)
(DEFVAR *HAD-TO-AUTOMATICALLY-LOGIN-TO-SYS-HOST* NIL)
(DEFVAR *AUTOMATICALLY-LOGIN-TO-SYS-HOST-LOCK* (PROCESS:MAKE-LOCK "Automatic Login"))
(DEFVAR *INVOCATIONS-OF-AUTOMATIC-LOGIN-TO-SYS-HOST* 0)

(DEFUN WITH-AUTOMATIC-LOGIN-TO-SYS-HOST-INTERNAL (CONTINUATION)
  (IF (NOT (NULL *AUTOMATICALLY-LOGIN-TO-SYS-HOST*))
      ;; There is already a with-automatic-login-to-sys-host pending
      ;; in this process, just execute the body.
      (FUNCALL CONTINUATION)
    (LET ((*AUTOMATICALLY-LOGIN-TO-SYS-HOST* NIL)
	  ;; Save the remote login state in case force-user-to-login has to login-to-sys-host
	  (SAVED-REMOTE-LOGIN-STATE NETI:REMOTE-LOGIN-ON))
      (UNWIND-PROTECT
	  (PROGN
	    (WITHOUT-INTERRUPTS
	      (SETF *AUTOMATICALLY-LOGIN-TO-SYS-HOST* T)
	      (INCF *INVOCATIONS-OF-AUTOMATIC-LOGIN-TO-SYS-HOST*))
	    (FUNCALL CONTINUATION))
	(PROCESS:WITH-LOCK (*AUTOMATICALLY-LOGIN-TO-SYS-HOST-LOCK*)
	  (SETQ NETI:REMOTE-LOGIN-ON SAVED-REMOTE-LOGIN-STATE)	;Restore remote-login state
	  (WHEN (AND *AUTOMATICALLY-LOGIN-TO-SYS-HOST*
		     (ZEROP (MAX (DECF *INVOCATIONS-OF-AUTOMATIC-LOGIN-TO-SYS-HOST*) 0))
		     *HAD-TO-AUTOMATICALLY-LOGIN-TO-SYS-HOST*
		     (SI:LOGGED-IN-TO-SYS-HOST))
	    (LOGOUT)
	    (SETF *HAD-TO-AUTOMATICALLY-LOGIN-TO-SYS-HOST* NIL)))))))

(DEFMACRO WITH-AUTOMATIC-LOGIN-TO-SYS-HOST (&BODY BODY)
  `(WITH-AUTOMATIC-LOGIN-TO-SYS-HOST-INTERNAL
     (DW::NAMED-CONTINUATION WITH-AUTOMATIC-LOGIN-TO-SYS-HOST ()
       ,@BODY)))

(DEFUN FORCE-USER-TO-LOGIN ()
  (WHEN (EQ SI:*USER* SI:*NOT-LOGGED-IN-USER*)
    (FLET ((LOGIN ()
	     (LOOP WHILE (EQ SI:*USER* SI:*NOT-LOGGED-IN-USER*) DOING	;LOGIN is sometimes a no-op. [eh?]
	       (WHEN *AUTOMATICALLY-LOGIN-TO-SYS-HOST*
		 (PROCESS:WITH-LOCK (*AUTOMATICALLY-LOGIN-TO-SYS-HOST-LOCK*)
		   (WHEN (EQ SI:*USER* SI:*NOT-LOGGED-IN-USER*)
		     (LET ((NETI:*INHIBIT-VALIDITY-CHECKING* T))
		       (SI:LOGIN-TO-SYS-HOST))
		     ;; Enable remote login when we have forced a login to sys-host so the
		     ;; system is accessible remotely, in case of blowouts (mostly on the
		     ;; NXP).
		     (NET:REMOTE-LOGIN-ON :NOTIFY)
		     (SETQ *HAD-TO-AUTOMATICALLY-LOGIN-TO-SYS-HOST* T)
		     (RETURN T))))
	       (WHEN (EQ SI:*USER* SI:*NOT-LOGGED-IN-USER*)
		 (SEND QUERY-IO :BEEP)
		 (FORMAT QUERY-IO "Please login.")
		 (LET ((ARGUMENTS (CP:READ-COMMAND-ARGUMENTS 'SI:COM-LOGIN :STREAM QUERY-IO)))
		   (EVAL (CP:TURN-COMMAND-INTO-FORM 'SI:COM-LOGIN ARGUMENTS)))))))
      (IF RUBOUT-HANDLER
	  (SI:WITH-IE-TYPEIN (QUERY-IO)
	    (LOGIN))
	(LOGIN)))))

#|| 
;;; Some sketchy test code to verify that multiprocess, non-simply-nested
;;; invocations of WITH-AUTOMATIC-LOGIN-TO-SYS-HOST really work.
(DEFUN TEST-WALTSH ()
  (FLET ((FORK (&REST FUNARGS)
	     (LOOP FOR F IN FUNARGS DO (PROCESS-RUN-FUNCTION 'FORK F))))
    (FORK
      (LAMBDA ()
	(FS:WITH-AUTOMATIC-LOGIN-TO-SYS-HOST
	  (CL:SLEEP 10)
	  (FS:WITH-AUTOMATIC-LOGIN-TO-SYS-HOST
	    (WITH-OPEN-FILE (STREAM "fep0:>boot.boot")
	      (DBG:WHISTLE :DIRECTION :DOWN)
	      STREAM))))
      (LAMBDA ()
	(CL:SLEEP 2)
	(FS:WITH-AUTOMATIC-LOGIN-TO-SYS-HOST
	  (WITH-OPEN-FILE (STREAM "fep0:>boot.boot")
	    (DBG:WHISTLE :DIRECTION :UP)
	    STREAM)))
      (LAMBDA ()
	(CL:SLEEP 5)
	(FS:WITH-AUTOMATIC-LOGIN-TO-SYS-HOST
	  (WITH-OPEN-FILE (STREAM "fep0:>boot.boot")
	    (BEEP)
	    (CL:SLEEP 10)
	    STREAM))))
    (CL:SLEEP 10)
    (FORK
      (LAMBDA ()
	(FS:WITH-AUTOMATIC-LOGIN-TO-SYS-HOST
	  (WITH-OPEN-FILE (STREAM "fep0:>boot.boot")
	    (BEEP :FLASH)
	    (CL:SLEEP 1)
	    STREAM)))
      (LAMBDA ()
	(FS:WITH-AUTOMATIC-LOGIN-TO-SYS-HOST
	  (WITH-OPEN-FILE (STREAM "fep0:>boot.boot")
	    (BEEP :FLASH)
	    (CL:SLEEP 1)
	    STREAM)))
      (LAMBDA ()
	(FS:WITH-AUTOMATIC-LOGIN-TO-SYS-HOST
	  (WITH-OPEN-FILE (STREAM "fep0:>boot.boot")
	    (BEEP :FLASH)
	    (CL:SLEEP 1)
	    STREAM))))))
||#

;; This is for compatibility, since some people seem to have it in their init files.
(DEFUN FILE-HOST-USER-ID (UID HOST)
  (SEND HOST ':SET-HOST-USER-ID UID))

;;; Used by MAKE-SYSTEM for fast INFO access
(DEFUN MULTIPLE-FILE-PLISTS (FILENAMES &REST OPTIONS)
  (FORCE-USER-TO-LOGIN)
  ;; All this kludging around is because :MULTIPLE-FILE-PLISTS is required
  ;; to return its CAR's EQ to the original inputs.
  (LET ((HOST-PATHNAME-ALIST NIL))
    (LOOP FOR PATHNAME IN FILENAMES
	  AS M-PATHNAME = (MERGE-PATHNAMES PATHNAME)
	  AS T-PATHNAME = (SEND M-PATHNAME :TRANSLATED-PATHNAME)
	  AS FAP = (SEND (PATHNAME-HOST T-PATHNAME) :FILE-ACCESS-PATH T-PATHNAME :MULTIPLE-FILE-PLISTS)
	  AS HOST-LIST = (CL:ASSOC FAP HOST-PATHNAME-ALIST)
	  DO
      (IF HOST-LIST
	  (PUSH `(,M-PATHNAME . ,T-PATHNAME) (CDR HOST-LIST))
	  (SETQ HOST-PATHNAME-ALIST
		(CL:ACONS FAP `((,M-PATHNAME . ,T-PATHNAME))
			  HOST-PATHNAME-ALIST))))
    (LOOP FOR (FAP . FINAL-ANSWER) IN HOST-PATHNAME-ALIST
	  DO
      (LET* ((TRANSLATED-PATHNAMES
	       (LOOP FOR (NIL . TRANSLATION) IN FINAL-ANSWER COLLECT TRANSLATION))
	     (TRANSLATED-RESULT
	       (SEND FAP :MULTIPLE-FILE-PLISTS TRANSLATED-PATHNAMES OPTIONS)))
	;; We trust the (lower) implementation to retain EQ'ness as it had in the past.
	;; This may take N^2 to sort out, but it's right.
	(LOOP FOR (KEYPATH . PROPS) IN TRANSLATED-RESULT
	      DO (LOOP FOR NODE IN FINAL-ANSWER
		       AS (NIL . TRANSLATION) = NODE
		       WHEN (EQ TRANSLATION KEYPATH)
			 RETURN (RPLACD NODE PROPS)
		       FINALLY (FERROR
				 "Properties for ~A received but not requested." KEYPATH)))
	(LOOP FOR (LOGPATH . PROPS) IN FINAL-ANSWER
						;If still a pathname, we didn't find it.
	      DO (IGNORE LOGPATH)
	      WHEN (AND PROPS (ATOM PROPS))
		DO (FERROR "Properties for ~A requested but not received." PROPS))))
    (LOOP FOR (NIL . FINAL-ANSWER) IN HOST-PATHNAME-ALIST APPENDING FINAL-ANSWER)))

;;; Old name for compatibility
(DEFUN MULTIPLE-FILE-PROPERTY-LISTS (BINARY-P FILENAMES)
  (MULTIPLE-FILE-PLISTS FILENAMES ':CHARACTERS (NOT BINARY-P)))

;;;; Directory stuff

;;; This is the only function user interface to the directory listing
;;; stuff.  It returns a list of lists, one for each file.  The format
;;; of these lists is (PATHNAME . PLIST).  The currently defined indicators
;;; for PLIST are:
;;; :ACCOUNT <string>
;;; :AUTHOR <string>
;;; :BLOCK-SIZE <number>
;;; :BYTE-SIZE <number>
;;; :CREATION-DATE <universal-date>
;;; :DELETED <boolean>
;;; :DONT-DELETE <boolean>
;;; :DONT-DUMP <boolean>
;;; :DONT-REAP <boolean>
;;; :DUMPED <boolean>
;;; :GENERATION-RETENTION-COUNT <number>
;;; :LENGTH-IN-BLOCKS <number>
;;; :LENGTH-IN-BYTES <number>
;;; :LINK-TO <string>
;;; :OFFLINE <boolean>
;;; :PHYSICAL-VOLUME <string>
;;; :PROTECTION <string>
;;; :READER <string>
;;; :REFERENCE-DATE <universal-date>
;;; :TEMPORARY <boolean>

;;; A pathname of NIL is treated specially and gives properties for all
;;; the files listed.  The indicators for this "pathname" are:
;;; :SETTABLE-PROPERTIES <list-of-indicators, or just T>
;;; :BLOCK-SIZE  <number>
;;; :PHYSICAL-VOLUME-FREE-BLOCKS alist of (<string> . <number>)
;;; :DISK-SPACE-DESCRIPTION <string>

;;; The currently defined OPTIONS are:
;;; :NOERROR - return error instance if FILE-OPERATION-FAILURE occurs.
;;; :DELETED - also (rather than exclusively) list deleted files.
;;; :NO-EXTRA-INFO - only include enough information for listing directory as in DIRED.
;;; :SORTED - we want the directory sorted at least so that
;;;   multiple versions of a file are consecutive in increasing version order.
(DEFUN DIRECTORY-LIST (FILENAME &REST OPTIONS)
  (FORCE-USER-TO-LOGIN)
  (SETQ FILENAME (MERGE-PATHNAMES FILENAME
				  (SEND (DEFAULT-PATHNAME) :NEW-PATHNAME
					:NAME ':WILD :TYPE ':WILD :VERSION ':WILD)
				  ':WILD))
  (CONDITION-CASE-IF (MEMQ ':NOERROR OPTIONS) (.ERROR.)
      (ERROR-RESTART (ERROR "Retry DIRECTORY-LIST of ~A" FILENAME)
	(SEND FILENAME ':DIRECTORY-LIST OPTIONS))
    (FILE-OPERATION-FAILURE .ERROR.)))

;;; Defaults are dumb.
(DEFMETHOD (:DIRECTORY-LIST PATHNAME) (OPTIONS)
  OPTIONS
  (ERROR 'UNKNOWN-OPERATION ':OPERATION ':DIRECTORY-LIST))

;; For things such as CHAOS-PATHNAME which work through a :DIRECTORY-STREAM
(DEFFLAVOR DIRECTORY-STREAM-MIXIN () ()
  (:REQUIRED-METHODS :DIRECTORY-STREAM)
  (:REQUIRED-FLAVORS PATHNAME))

(DEFMETHOD (:DIRECTORY-LIST DIRECTORY-STREAM-MIXIN) (OPTIONS)
  (WITH-OPEN-STREAM (STREAM (SEND SELF ':DIRECTORY-STREAM (REMQ ':SORTED OPTIONS)))
    (IF (ERRORP STREAM)
	STREAM
      (LOOP WITH IN-ORDER-P = T
	    WITH LAST-PATHNAME
	    WITH SHOULD-BE-SORTED = (MEMQ ':SORTED OPTIONS)
	    AS ENTRY = (READ-DIRECTORY-STREAM-ENTRY STREAM SELF)
	    UNTIL (NULL ENTRY)
	    COLLECT ENTRY INTO DIR-LIST
	    WHEN (AND SHOULD-BE-SORTED IN-ORDER-P LAST-PATHNAME (CAR ENTRY)
		      (NOT (SEND LAST-PATHNAME ':SORT-LESSP (CAR ENTRY))))
	      DO (SETQ IN-ORDER-P NIL)
	    WHEN (CAR ENTRY)
	      DO (SETQ LAST-PATHNAME (CAR ENTRY))
	    FINALLY
	    (AND SHOULD-BE-SORTED (NOT IN-ORDER-P)
		 (LET ((NULL-ELEM (ASSQ NIL DIR-LIST)))
		   (AND NULL-ELEM (SETQ DIR-LIST (DELQ NULL-ELEM DIR-LIST)))
		   (SETQ DIR-LIST (SORTCAR DIR-LIST #'PATHNAME-LESSP))
		   (AND NULL-ELEM (PUSH NULL-ELEM DIR-LIST))))
	    (RETURN DIR-LIST)))))

;;; These are the understood indicators
;;; Format is ((PARSER-FROM-STRING PRINTER TYPE-FOR-CHOOSE-VARIABLE-VALUES) . INDICATORS)
(DEFVAR *KNOWN-DIRECTORY-PROPERTIES*
  '(((PARSE-DIRECTORY-BOOLEAN-PROPERTY PRIN1 :BOOLEAN)
     :DELETED :DONT-DELETE :DONT-DUMP :DONT-REAP :DELETE-PROTECT :SUPERSEDE-PROTECT
     :NOT-BACKED-UP :OFFLINE :TEMPORARY :CHARACTERS :DUMPED :DIRECTORY)
    ((PARSE-RANDOM-SEXP PRINT-RANDOM-SEXP :SEXP)
     :FLAVOR)
    ((SUBSTRING PRINC :STRING)
     :ACCOUNT :AUTHOR :LINK-TO :PHYSICAL-VOLUME :PROTECTION :VOLUME-NAME :PACK-NUMBER
     :READER :DISK-SPACE-DESCRIPTION :COMMENT)
    ((PARSE-NUMBER PRINT-DECIMAL-PROPERTY :NUMBER)
     :BLOCK-SIZE :BYTE-SIZE :LENGTH-IN-BLOCKS :LENGTH-IN-BYTES)
    ((PARSE-NUMBER PRINT-DECIMAL-PROPERTY :NUMBER-OR-NIL)
     :GENERATION-RETENTION-COUNT :DEFAULT-GENERATION-RETENTION-COUNT)
    ((PARSE-DIRECTORY-DATE-PROPERTY PRINT-DIRECTORY-DATE-PROPERTY :DATE)
     :CREATION-DATE :FILE-CREATION-DATE :MODIFICATION-DATE)
    ((PARSE-DIRECTORY-DATE-PROPERTY PRINT-DIRECTORY-DATE-PROPERTY :DATE-OR-NEVER)
     :REFERENCE-DATE :INCREMENTAL-DUMP-DATE :COMPLETE-DUMP-DATE :DATE-LAST-EXPUNGED
     :EXPIRATION-DATE)
    ((PARSE-KEYWORD-LIST PRINT-KEYWORD-LIST :KEYWORD-LIST)
     :SETTABLE-PROPERTIES :LINK-TRANSPARENCIES :DEFAULT-LINK-TRANSPARENCIES)
    ((PARSE-DIRECTORY-FREE-SPACE PRINT-DIRECTORY-FREE-SPACE)
     :PHYSICAL-VOLUME-FREE-BLOCKS)
    ((TIME:PARSE-INTERVAL-OR-NEVER TIME:PRINT-INTERVAL-OR-NEVER :TIME-INTERVAL-OR-NEVER)
     :AUTO-EXPUNGE-INTERVAL)
    ((LMFS:PARSE-LMFS-ACL-PROPERTY LMFS:PRINT-LMFS-ACL-PROPERTY LMFS:LMFS-ACL-CVV-PROPERTY)
     :LMFS-DIRECTORY-ACL)
    ((TV:PARSE-STRING-OR-NIL TV:PRINT-STRING-OR-NIL :STRING-OR-NIL)
     :DONT-DELETE-REASON)))

(DEFUN DEFAULT-ELEMENT-TYPE-FROM-CANONICAL-TYPE (CT)
  (COND ((AND (SYMBOLP CT) (GET CT :BINARY-FILE-BYTE-SIZE))
	 (VALUES `(CL:UNSIGNED-BYTE ,(GET CT :BINARY-FILE-BYTE-SIZE)) T))
	(T `CL:CHARACTER)))

;; To implement arbitrary formats of directory streams, this could be
;; made a message to the pathname.
(DEFUN READ-DIRECTORY-STREAM-ENTRY (STREAM DEFAULTING-PATHNAME &AUX PATH EOF IND FUN)
  (MULTIPLE-VALUE (PATH EOF)
    (SEND STREAM ':LINE-IN))
  (IF EOF NIL
    (IF (PLUSP (ARRAY-ACTIVE-LENGTH PATH))
	(SETQ PATH (FS:MERGE-PATHNAMES
		     (SEND DEFAULTING-PATHNAME ':PARSE-TRUENAME PATH)
		     DEFAULTING-PATHNAME))
	(SETQ PATH NIL))
    ;; This is a little hairy to try to avoid page faults when interning.
    (LOOP AS LINE = (SEND STREAM ':LINE-IN)
	  AS LEN = (ARRAY-ACTIVE-LENGTH LINE)
	  UNTIL (ZEROP LEN)
	  AS I = (%STRING-SEARCH-CHAR #\SP LINE 0 LEN)
	  DO (LOOP NAMED FOO
		   FOR X IN *KNOWN-DIRECTORY-PROPERTIES*
		   DO (LOOP FOR Y IN (CDR X)
			    WHEN (%STRING-EQUAL LINE 0 (GET-PNAME Y) 0 I)
			    DO (SETQ IND Y FUN (CAAR X))
			    (RETURN-FROM FOO NIL))
		   FINALLY (SETQ IND (INTERN (SUBSTRING LINE 0 I) SI:PKG-KEYWORD-PACKAGE)
				 FUN #'SUBSTRING))
	  NCONC (LIST* IND (OR (NULL I) (SEND FUN LINE (1+ I))) NIL) INTO PLIST
	  FINALLY (RETURN (CONS PATH PLIST)))))



;;; Really nice printing for ZWEI's Change File Properties
(DEFPROP :DONT-DELETE "Don't Delete" ZWEI:PRETTY-NAME)
(DEFPROP :DONT-REAP "Don't Reap" ZWEI:PRETTY-NAME)

;;; Nifty, handy function for adding new ones
(DEFUN PUSH-DIRECTORY-PROPERTY-ON-TYPE (TYPE PROP)
  (LET ((X (OR (DOLIST (E *KNOWN-DIRECTORY-PROPERTIES*)
		 (IF (EQ (CADDAR E) TYPE) (RETURN E)))
	       (FERROR "Unknown property type: ~A" TYPE))))
    (OR (MEMQ TYPE (CDR X))
	(PUSH PROP (CDR X)))))


(DEFUN PARSE-RANDOM-SEXP (STRING START)
  (SCL:WITH-STANDARD-IO-ENVIRONMENT
    (READ-FROM-STRING STRING NIL START)))

(DEFUN PRINT-RANDOM-SEXP (SEXP &OPTIONAL (STREAM STANDARD-OUTPUT))
  (SCL:WITH-STANDARD-IO-ENVIRONMENT
    (PRIN1 SEXP STREAM)))


(DEFVAR *USE-FULL-PARSER* NIL
  "If T, then try using the full TIME:PARSE parser for FILE server date-time strings")

;;; Fast date parser for simple case of MM/DD/YY HH:MM:SS
(DEFUN PARSE-DIRECTORY-DATE-PROPERTY (STRING START &OPTIONAL END &AUX FLAG)
  (OR END (SETQ END (ARRAY-ACTIVE-LENGTH STRING)))
  (BLOCK PARSE-DIRECTORY-DATE-PROPERTY
    (BLOCK GIVE-UP
      (UNLESS (AND (OR (= END (+ START 8))
		       (SETQ FLAG (= END (+ START 17.))))
		   (CHAR= (AREF STRING (+ START 2)) #//)
		   (CHAR= (AREF STRING (+ START 5)) #//)
		   (OR (NULL FLAG)
		       (AND (CHAR= (AREF STRING (+ START 8)) #\SP)
			    (CHAR= (AREF STRING (+ START 11.)) #/:)
			    (CHAR= (AREF STRING (+ START 14.)) #/:))))
	(RETURN-FROM GIVE-UP))
      (LET (DAY MONTH YEAR HOURS MINUTES SECONDS)
	(SETQ MONTH (PARSE-DIRECTORY-DATE-PROPERTY-1 STRING START)
	      DAY (PARSE-DIRECTORY-DATE-PROPERTY-1 STRING (+ START 3))
	      YEAR (PARSE-DIRECTORY-DATE-PROPERTY-1 STRING (+ START 6)))
	(UNLESS (AND ( 1 MONTH 12.)
		     ( 1 DAY (TIME:MONTH-LENGTH MONTH YEAR)))
	  (RETURN-FROM GIVE-UP))
	(IF (NOT FLAG)
	    (SETQ HOURS 0 MINUTES 0 SECONDS 0)
	    (SETQ HOURS (PARSE-DIRECTORY-DATE-PROPERTY-1 STRING (+ START 9))
		  MINUTES (PARSE-DIRECTORY-DATE-PROPERTY-1 STRING (+ START 12.))
		  SECONDS (PARSE-DIRECTORY-DATE-PROPERTY-1 STRING (+ START 15.)))
	    (UNLESS (AND ( 0 HOURS 23.) ( 0 MINUTES 59.) ( 0 SECONDS 59.))
	      (RETURN-FROM GIVE-UP)))
	(RETURN-FROM PARSE-DIRECTORY-DATE-PROPERTY
	  (TIME:ENCODE-UNIVERSAL-TIME SECONDS MINUTES HOURS DAY MONTH YEAR))))
    (UNLESS *USE-FULL-PARSER*
      (FSIGNAL "The FILE server violated protocol: ~S is not in the right date-time format.
Please report this bug.  To try using the full time parser, set FS:*USE-FULL-PARSER* to T
and try again." (SUBSTRING STRING START END)))
    ;; Not in standard simple format.
    (CONDITION-CASE ()
	(TIME:PARSE-UNIVERSAL-TIME STRING START END)
      (TIME:PARSE-ERROR NIL))))

(DEFUN PARSE-DIRECTORY-DATE-PROPERTY-1 (STRING START)
  (+ (* (- (CHAR-CODE (AREF STRING START)) (CHAR-CODE #/0)) 10.)
     (- (CHAR-CODE (AREF STRING (1+ START))) (CHAR-CODE #/0))))

;;; Printer which always prints MM/DD/YY HH:MM:SS
(DEFUN PRINT-DIRECTORY-DATE-PROPERTY (UT STREAM)
  (MULTIPLE-VALUE-BIND (SEC MIN HR DAY MON YR)
      (TIME:DECODE-UNIVERSAL-TIME UT)
    (FORMAT STREAM "~2,'0D//~2,'0D//~2,'0D ~2,'0D:~2,'0D:~2,'0D"
	    MON DAY YR HR MIN SEC)))

(DEFUN PARSE-DIRECTORY-BOOLEAN-PROPERTY (STRING START)
  (READ-FROM-STRING STRING NIL START))

;; Treat an empty string or a string with only whitespace like a blank line.

(DEFUN PARSE-KEYWORD-LIST (STRING START)
  (OR (READ-STRING-LIST-FROM-STRING STRING START NIL #\SPACE
				    #'(LAMBDA (STRING)
					(SI:INTERN1 (STRING-UPCASE STRING) PKG-KEYWORD-PACKAGE)))
      T))

(DEFUN PRINT-KEYWORD-LIST (PROPERTIES &OPTIONAL (STREAM STANDARD-OUTPUT))
  (AND (LISTP PROPERTIES)
       (DO ((TAIL PROPERTIES (CDR TAIL))) ((NULL TAIL))
	 (SEND STREAM ':STRING-OUT (GET-PNAME (CAR TAIL)))
	 (IF (CDR TAIL) (SEND STREAM ':TYO #\SP)))))

(DEFUN PARSE-DIRECTORY-FREE-SPACE (STRING START &AUX LIST)
  (DO ((I START (1+ I))
       (J)
       (VOL))
      (NIL)
    (OR (SETQ J (STRING-SEARCH-CHAR #/: STRING I))
	(RETURN))
    (SETQ VOL (SUBSTRING STRING I J))
    (SETQ I (STRING-SEARCH-CHAR #/, STRING (SETQ J (1+ J))))
    (PUSH (CONS VOL (PARSE-NUMBER STRING J I)) LIST)
    (OR I (RETURN)))
  (NREVERSE LIST))

(DEFUN PRINT-DIRECTORY-FREE-SPACE (ALIST &OPTIONAL (STANDARD-OUTPUT STANDARD-OUTPUT))
  (DO ((TAIL ALIST (CDR TAIL)))
      ((NULL TAIL))
    (PRINC (CAAR TAIL))
    (PRINC ":")
    (PRINC (CDAR TAIL))
    (IF (CDDR TAIL) (PRINC ","))))
    
(DEFUN PRINT-DECIMAL-PROPERTY (PROP STREAM)
  (LET ((BASE 10.) (CL:*PRINT-RADIX* NIL))
    (PRIN1 PROP STREAM)))

(DEFMETHOD (:QUICK-VIEW-DIRECTORY PATHNAME) (TO-STREAM &AUX TEM)
  (LET ((LIST (DIRECTORY-LIST SELF ':SORTED ':FAST)))
    (FORMAT TO-STREAM "~&~A:" SELF)
    (COND ((AND LIST (NULL (CAAR LIST)))
	   (COND ((SETQ TEM (GET (CAR LIST) ':DISK-SPACE-DESCRIPTION))
		  (FORMAT TO-STREAM "~%~A" TEM)))
	   (POP LIST)))
    (LOOP WITH LAST-DIR = NIL
	  FOR FIRST FIRST T THEN NIL
	  FOR (PATH) IN LIST
	  UNLESS (EQUAL LAST-DIR (SEND PATH ':RAW-DIRECTORY))
	  DO (SETQ LAST-DIR (SEND PATH ':RAW-DIRECTORY))
	     (IF (OR (NOT FIRST)
		     (NOT (EQUAL LAST-DIR (SEND SELF ':RAW-DIRECTORY))))
		 (FORMAT TO-STREAM "~%~A" (SEND PATH ':STRING-FOR-DIRECTORY)))
	  DO (FORMAT TO-STREAM "~% ~A" (SEND PATH ':STRING-FOR-DIRED)))))

;;; List all directories w.r.t. the pathname.  The only option currently
;;; defined is :NOERROR, which causes the function to return an error
;;; instance if a FILE-OPERATION-FAILURE occurs.  A successful return
;;; returns a plist, as in :DIRECTORY-LIST, of pathnames with one for
;;; each directory.  Currently the only non-nil fields in these
;;; pathnames are host, directory, and device, but this may be changed
;;; later on by some options.  Also, there are no properties defined
;;; yet.

;;; First argument may be a host name for convenience
(DEFUN ALL-DIRECTORIES (&OPTIONAL (PATHNAME USER-LOGIN-MACHINE) &REST OPTIONS &AUX TEM)
  (FORCE-USER-TO-LOGIN)
  (IF (AND (OR (STRINGP PATHNAME) (TYPEP PATHNAME 'NET:BASIC-HOST))
	   (SETQ TEM (GET-PATHNAME-HOST PATHNAME T)))
      (SETQ PATHNAME (SEND (SEND TEM ':SAMPLE-PATHNAME) ':NEW-DIRECTORY ':WILD))
      (SETQ PATHNAME (MERGE-PATHNAMES PATHNAME)))
  (CONDITION-CASE-IF (MEMQ ':NOERROR OPTIONS) (.ERROR.)
      (ERROR-RESTART (ERROR "Retry ALL-DIRECTORIES of ~A" PATHNAME)
	(SEND PATHNAME ':ALL-DIRECTORIES OPTIONS))
    (FILE-OPERATION-FAILURE .ERROR.)))

;;; Default is to complain that it can't be done.
(DEFMETHOD (:ALL-DIRECTORIES PATHNAME) (OPTIONS)
  OPTIONS
  (ERROR 'UNKNOWN-OPERATION ':OPERATION ':ALL-DIRECTORIES))

;;; Attempt to complete a pathname string STRING.  DEFAULTS, TYPE and VERSION are as
;;; for DEFAULT-PATHNAME.  Currently recognized options are:
;;; :DELETED - recognize deleted files.
;;; :READ - file is to be used for input.
;;; :WRITE - file is to be used for output.
;;; :OLD - only pre-existing files are allowed.
;;; :NEW-OK - non-existant files are allowed.
;;; Values of SUCCESS are:
;;; :OLD - there is an old file by this name
;;; :NEW - this is a new file, but some completion has been accomplished.
;;; NIL - no completion was possible with the given string and/or defaults.

;;; An interim idea to shadow the "heuristication" in logical pathnames.
(DEFF HEURISTIC-COMPLETE-PATHNAME 'COMPLETE-PATHNAME)
(COMPILER:MAKE-OBSOLETE HEURISTIC-COMPLETE-PATHNAME
			"Heuristic completion, which only applied to logical pathnames, is 
now performed by FS:COMPLETE-PATHNAME for logical pathnames.  Use it.")

(DEFUN COMPLETE-PATHNAME (DEFAULTS STRING TYPE VERSION &REST OPTIONS &AUX PATHNAME)
  (DECLARE (VALUES STRING SUCCESS))
  (BLOCK COMPLETE-PATHNAME
    (FORCE-USER-TO-LOGIN)
    (MULTIPLE-VALUE-BIND (HOST START END)
	(CONDITION-CASE ()
	    (PARSE-PATHNAME-FIND-COLON STRING)
	  (UNKNOWN-PATHNAME-HOST (RETURN-FROM COMPLETE-PATHNAME (VALUES STRING NIL))))
      (SETQ START (OR (STRING-SEARCH-NOT-CHAR #\SP STRING START END) END)
	    STRING (SUBSTRING STRING START END))
      (SETQ PATHNAME (DEFAULT-PATHNAME DEFAULTS HOST TYPE VERSION)))
    (WHEN (AND (NULL TYPE)
	       (AND (TYPEP DEFAULTS 'PATHNAME)
		    (NULL (SEND DEFAULTS :TYPE))))
      (SETQ PATHNAME (SEND PATHNAME :NEW-PATHNAME :TYPE NIL)))
    (ERROR-RESTART (ERROR "Retry completing ~S" STRING)
      (MULTIPLE-VALUE-BIND (RESULT SUCCESS LOGICAL-P)
	  (SEND PATHNAME :COMPLETE-STRING
			 (STRING-THIN STRING :REMOVE-BITS T)
			 OPTIONS)
	(WHEN (AND (STRINGP RESULT) (NOT LOGICAL-P))
	  (SETQ RESULT (STRING-APPEND
			 (SEND (SEND PATHNAME :HOST) :NAME-AS-FILE-COMPUTER)
			 ;; Space makes logical pathnames look prettier, but CP
			 ;; just can't hack these spaces yet.  We can try again
			 ;; when CP is more robust.
			 (SEND PATHNAME :HOST-DELIMITER) #+IGNORE #\SP
			 RESULT)))
	(VALUES RESULT SUCCESS)))))

;;; Alter properties as returned by DIRECTORY-LIST.  PROPERTIES is a
;;; PLIST with the same indicators as returned by that.
(DEFUN CHANGE-FILE-PROPERTIES (PATHNAME ERROR-P &REST PROPERTIES)
  (FORCE-USER-TO-LOGIN)
  (SETQ PATHNAME (MERGE-PATHNAMES PATHNAME))
  (CONDITION-CASE-IF (NOT ERROR-P) (.ERROR.)
      (ERROR-RESTART (ERROR "Retry CHANGE-FILE-PROPERTIES of ~A" PATHNAME)
	(LEXPR-FUNCALL PATHNAME ':CHANGE-PROPERTIES T PROPERTIES)
	T)
    (FILE-OPERATION-FAILURE .ERROR.)))

(DEFF CHANGE-PATHNAME-PROPERTIES 'CHANGE-FILE-PROPERTIES)  ;Obsolete old name

;;; Find the properties, like those returned by DIRECTORY-LIST, of a single file.
;;; Returns a plist whose car is the truename and whose cdr is the properties.
(DEFUN FILE-PROPERTIES (PATHNAME &OPTIONAL (ERROR-P T))
  (DECLARE (VALUES PROPERTIES SETTABLE-PROPERTIES))
  (FORCE-USER-TO-LOGIN)
  (SETQ PATHNAME (MERGE-PATHNAMES PATHNAME))
  (CONDITION-CASE-IF (NOT ERROR-P) (.ERROR.)
      (ERROR-RESTART (ERROR "Retry getting file properties of ~A" PATHNAME)
	(SEND PATHNAME ':PROPERTIES))
    (FILE-OPERATION-FAILURE .ERROR.)))


(DEFUN EXPUNGE-DIRECTORY (PATHNAME &REST OPTIONS &AUX EROPT)
  (FORCE-USER-TO-LOGIN)
  (SETQ PATHNAME (MERGE-PATHNAMES PATHNAME
				  (SEND (DEFAULT-PATHNAME) ':NEW-PATHNAME
					':TYPE ':WILD ':VERSION ':WILD)
				  ':WILD))
  (CONDITION-CASE-IF (AND (SETQ EROPT (MEMQ ':ERROR OPTIONS))
			  (NULL (CADR EROPT)))
		     (.ERROR.)
      (ERROR-RESTART (ERROR "Retry EXPUNGE of ~A" PATHNAME)
	(LEXPR-FUNCALL PATHNAME ':EXPUNGE OPTIONS))
    (FILE-OPERATION-FAILURE .ERROR.)))

(DEFMETHOD (:EXPUNGE PATHNAME) (&REST IGNORE)
  (ERROR 'UNKNOWN-OPERATION ':OPERATION ':EXPUNGE))

;;;; Handle File property lists

;;; If no :MODE property is in the file's -*- line, and the file type is on
;;; this list, then the corresponding :MODE property is put on the file's
;;; plist.  This helps losers who don't have -*- lines get the right mode on
;;; TWENEX, etc.  Writers of editor major modes should push associations onto
;;; this list.  Note well: this list gets RASSQ'ed by Zwei to get file types
;;; back from major modes, so the "appropriate" file type should appear earliest
;;; on the list if the major mode is duplicated.  This list starts out as NIL so
;;; that the cold load will not blow out when first loading Zwei.
(DEFVAR *FILE-TYPE-MODE-ALIST* '())
				    
;;; New faster parser, uses :READ-INPUT-BUFFER, returns the new
;;; attribute list.  Sometimes works for multiple-line plists, depending
;;; on whether the entire -*- stuff fits into the first buffer.  Beware
;;; of making streams do :LINE-INs on files which aren't really ASCII.
;;; :LINE-IN can lose rather badly on such files.  PATHNAME may be NIL
;;; if you don't want any properties put on any pathname.  Support for
;;; the :SYNTAX-PLIST message removed by DLW, 5/14/82, as DLA says it is
;;; only there for to support the ideas of the RMS file system.
;;; :DONT-RESET-STREAM added 9/85, BIM, to support programs that want to know
;;; where the attribute list is in the file.
(DEFUN READ-ATTRIBUTE-LIST (PATHNAME STREAM &KEY DONT-RESET-STREAM &AUX WO PLIST PATH MODE)
  (DECLARE (CL:INLINE LOCATIVEP))		;LOCATIVEP isn't loaded yet when this is called
  (BLOCK PARSING
    (SETQ WO (SEND STREAM ':WHICH-OPERATIONS))
    (WHEN (MEMQ ':READ-INPUT-BUFFER WO)
      ;; This way of reading the property list is sort of a kludge, but it has
      ;; the very important advantage that it won't ever read the whole file like :LINE-IN
      ;; would be prone to do if the file had no carriage returns in it.
      (MULTIPLE-VALUE-BIND (BUFFER START END)
	  (SEND STREAM ':READ-INPUT-BUFFER)	; get first buffer-full from stream
	(CONDITION-CASE ()
	     (WHEN BUFFER			; we have a buffer...
	       (MULTIPLE-VALUE-BIND (PARSED-PLIST PARSE-END COMPLETE-P)
		   (PARSE-ATTRIBUTE-LIST BUFFER START END)

		 ;; decide whether to fall thru to :line-in case, below.
		 ;; we use what we have (don't fall thru) if COMPLETE-P 
		 ;; is non-NIL.  That means parse-attribute-list found
		 ;; both the start and end of a plist.
		 (WHEN COMPLETE-P
		   ;; VC sometimes wants to let us skip the attribute
		   ;; list.  That's easy in the line-in case, below, but
		   ;; gross here.  We must advance to the index returned
		   ;; from parse-attribute-list, then find end of line.
		   (WHEN DONT-RESET-STREAM	; must advance beyond attr line
		     (UNLESS PARSE-END		; p-a-l can return nil
		       (SETQ PARSE-END END))
		     (SEND STREAM ':ADVANCE-INPUT-BUFFER PARSE-END)
		     (LOOP WHILE (NOT (CHAR-EQUAL (SEND STREAM ':TYI)
						  #\RETURN))))
		   (SETQ PLIST PARSED-PLIST)
		   (UNLESS DONT-RESET-STREAM
		     (SEND STREAM ':SET-POINTER 0))
		   (RETURN-FROM PARSING PLIST))))	; return it
	   (ERROR NIL))))			;  otherwise, fall thru to line-in, below

    ;; here is a kludge.  The SI:WITH-STREAM-NEXT-INPUT-BUFFER-HOOK is misdesigned.
    ;; it allows you to count :NEXT-INPUT-BUFFERS.  What it has to do it catch
    ;; the particular event of :NEXT-INPUT-BUFFERing past the first input buffer.
    ;; The first time you read from a stream, there is a :NEXT-INPUT-BUFFER to
    ;; read the first buffer, and then another to get to the second.  However,
    ;; if you :SET-POINTER 0 after getting the first input buffer, then that buffer
    ;; is kept.  Therefore, the second time that you read the attribute list, the D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")first
0    ;; :NEXT-INPUT-BUFFER is in fact fetching the 1second 0buffer.
    ;;
    ;; The TYI/UNTYI here insures that the first input buffer is on hand. At that point,
    ;; and :NEXT-INPUT-BUFFER must be an attempt to get to the second buffer,
    ;; and is intercepted accordingly.
    ;; 
    ;; [later -- jrd] This mechanism is even trickier than it looks.
    ;; The call to SI:WITH-STREAM-NEXT-INPUT-BUFFER-HOOK, below, expands
    ;; into a call to generic function SI:STREAM-WITH-NEXT-INPUT-BUFFER-HOOK,
    ;; whose only method is on SI:UNREWINDABLE-BUFFERED-INPUT-STREAM.  
    ;; Since that's not mixed into epsilon-encapsulating streams, you might
    ;; wonder why this works at all (I did).  Turns out the unclaimed-message
    ;; handler of SI:BASIC-INDIRECT-STREAM-MIXIN is catching it, and re-applying 
    ;; it to the inner stream.  Therefore, the INNER stream runs the hook 
    ;; function, and returns from block look-for-attribute-list.

    (LET ((CH (SEND STREAM :TYI NIL)))		;Read in first buffer
      (WHEN CH (SEND STREAM :UNTYI CH)))
    (LET ((LINE)
	  (EOF))
      (BLOCK LOOK-FOR-ATTRIBUTE-LIST
	(FLET ((NEXT-INPUT-BUFFER-HOOK ()
		 (RETURN-FROM LOOK-FOR-ATTRIBUTE-LIST)))
	  ;; Try to find an attribute list in the first part of the
	  ;; file.  Give up after 300 chars or 10 lines, whichever comes
	  ;; first.  Your mileage may vary.
	  (LOOP WITH N-CHARS-READ = 0
		WITH N-LINES-READ = 0
		WHILE (< N-CHARS-READ 300)
		WHILE (< N-LINES-READ 10)
		DO
	    (IF (SI:STREAM-SUPPORTS-SET-POINTER-0 STREAM)
		(CL:MULTIPLE-VALUE-SETQ (LINE EOF) (SEND STREAM :LINE-IN NIL))
		(SI:WITH-STREAM-NEXT-INPUT-BUFFER-HOOK
		  (STREAM #'NEXT-INPUT-BUFFER-HOOK)
		  (CL:MULTIPLE-VALUE-SETQ (LINE EOF) (SEND STREAM :LINE-IN NIL))))
	    (COND ((STRING-SEARCH "-*-" LINE)
		   (SETQ PLIST (PARSE-ATTRIBUTE-LIST LINE)) 
		   (RETURN NIL))
		  ((OR EOF (STRING-SEARCH-NOT-SET '(#\SPACE #\TAB) LINE))
		   (RETURN NIL)))
	    (INCF N-CHARS-READ (1+ (STRING-LENGTH LINE)))
	    (INCF N-LINES-READ))))
      (UNLESS DONT-RESET-STREAM
	(SEND STREAM :SET-POINTER 0))))
  ;; Various special cases are handled here.
  (CL:CASE (CL:GETF PLIST :MODE)
    ;; Try to guess at a mode if none was supplied.
    ((NIL)
     (WHEN (AND (MEMQ :PATHNAME WO)
		(SETQ PATH (SEND STREAM :PATHNAME))
		(SETQ MODE (CDR (ASSQ (SEND PATH :CANONICAL-TYPE) *FILE-TYPE-MODE-ALIST*))))
       (SETF (CL:GETF PLIST :MODE) MODE)))
    ;;The least we can do to help out TI.
    ((:COMMON-LISP)
     (SETF (CL:GETF PLIST :MODE) :LISP)
     (SETF (CL:GETF PLIST :SYNTAX) :COMMON-LISP)))
  ;; Update the generic pathname property list.
  (WHEN PATHNAME
    (UNLESS (LOCATIVEP PATHNAME)
      (SETQ PATHNAME (SEND PATHNAME :PROPERTY-LIST-LOCATION)))
    (DO ((L PLIST (CDDR L)))
	((NULL L))
      (PUTPROP PATHNAME (SECOND L) (FIRST L))))
  PLIST)

;;; Keep this obsolete name around indefinitely - it's in the LMMAN.
(DEFF FILE-READ-PROPERTY-LIST 'READ-ATTRIBUTE-LIST)
(COMPILER:MAKE-OBSOLETE FILE-READ-PROPERTY-LIST "use FS:READ-ATTRIBUTE-LIST")

;;; This takes a string which probably has a property list in it, and returns the plist.
;;; If it has any trouble parsing, returns whatever plist it could find.
(DEFUN PARSE-ATTRIBUTE-LIST (STRING &OPTIONAL (START 0) (END (ARRAY-ACTIVE-LENGTH STRING))
			     &AUX PLIST (IBASE 10.) (PACKAGE PKG-KEYWORD-PACKAGE))
  (DECLARE (VALUES PLIST END-INDEX COMPLETE-P))
  (LET ((COMPLETE-P NIL)			; T if we get a complete plist
	(ATTRIB-LINE-START-P NIL)		; T if find beginning of non-white line
	(ATTRIB-LINE-END-P NIL)			; T if the line we look in contains an eol
	(ORIGINAL-START START))
    (CONDITION-CASE ()
	 (AND STRING
	      (ARRAYP STRING)

	      (PROGN				; so we don't exit the AND
		;; Skip leading whitespace -- attribute list starts on first non-blank line
		(SETQ START (STRING-SEARCH-NOT-SET '(#\SPACE #\TAB #\RETURN) STRING START END))

		;; complete-p will want to be T if we find a non-blank
		;; line with a return in it.  test for that here.  Set
		;; complete-p in case we don't survive the searches for
		;; -*-, below.

		(SETQ ATTRIB-LINE-START-P START)
		(SETQ ATTRIB-LINE-END-P (AND START (STRING-SEARCH-CHAR #\RETURN STRING
								       START END)))
		(SETQ COMPLETE-P 
		      (OR (> (- END ORIGINAL-START) 300)	; 300 chars is long enough to
								;  say complete
			  (AND ATTRIB-LINE-START-P ATTRIB-LINE-END-P T)))
		START)

	      ;; Narrow down to the stuff between the -*-'s
	      (SETQ START (STRING-SEARCH "-*-" STRING START
					 (OR (STRING-SEARCH-CHAR #\Return STRING START END)
					     END)))

	      (PROGN 
		(SETQ END (STRING-SEARCH "-*-" STRING (INCF START 3) END))

		;; if we got this far, require END to be non-nil, (ie we
		;; found both ends of an attribute list) for complete-p
		(SETQ COMPLETE-P (AND (AND START END)	; -*- delimited
				      T))
		END)

	      ;; Now parse it.
	      (IF (NOT (%STRING-SEARCH-CHAR #/: STRING START END))
		  (SETQ PLIST (LIST ':MODE (READ-FROM-SUBSTRING STRING START END)))
		  (DO ((S START (1+ SEMI-IDX))
		       (COLON-IDX) (SEMI-IDX) (SYM) (ELEMENT NIL NIL) (DONE))
		      (NIL)
		    (OR (SETQ SEMI-IDX (%STRING-SEARCH-CHAR #/; STRING S END))
			(SETQ DONE T SEMI-IDX END))
		    (UNLESS (SETQ COLON-IDX (%STRING-SEARCH-CHAR #/: STRING S SEMI-IDX))
		      ;; No colon, can't get any farther.  If there's anything here, warn.
		      (WHEN (STRING-SEARCH-NOT-SET '(#\Space #\TAB) STRING S SEMI-IDX)
			(FORMAT ERROR-OUTPUT "~&Invalid attribute list format (missing colon): ~S"
				(8B-SUBSTRING STRING S SEMI-IDX)))
		      (RETURN NIL))
		    (OR (SETQ SYM (READ-FROM-SUBSTRING STRING S COLON-IDX))
			(RETURN NIL))
		    (AND (SYMBOLP SYM)
			 (NULL (GET SYM 'KNOWN-FILE-ATTRIBUTE))
			 (FORMAT ERROR-OUTPUT
				 "~&Warning: the symbol ~S is not one of the defined file attributes."
				 SYM))
		    (IF (%STRING-SEARCH-CHAR #/, STRING (SETQ S (1+ COLON-IDX)) SEMI-IDX)
			(DO ((COMMA-IDX) (ELEMENT-DONE))
			    (NIL)
			  (OR (SETQ COMMA-IDX (%STRING-SEARCH-CHAR #/, STRING S SEMI-IDX))
			      (SETQ ELEMENT-DONE T COMMA-IDX SEMI-IDX))
			  (SETQ ELEMENT
				(NCONC ELEMENT
				       (NCONS (READ-FROM-SUBSTRING STRING S COMMA-IDX))))
			  (AND ELEMENT-DONE (RETURN NIL))
			  (SETQ S (1+ COMMA-IDX)))
			(SETQ ELEMENT (READ-FROM-SUBSTRING STRING S SEMI-IDX)))
		    (SETQ PLIST (NCONC PLIST (LIST* SYM ELEMENT NIL)))	;Nicer CDR-CODEs
		    (AND DONE (RETURN NIL)))))
       (READ-ERROR
	 (FORMAT ERROR-OUTPUT "~&The attribute list ~S is not valid."
		 (8B-SUBSTRING STRING START END))))
    (VALUES PLIST END COMPLETE-P)))

(DEFUN READ-FROM-SUBSTRING (STRING &OPTIONAL (START 0) (END (ARRAY-ACTIVE-LENGTH STRING)))
  (WITH-INPUT-FROM-STRING (S STRING START END)
    (READ S)))

(DEFUN 8B-SUBSTRING (8B-ARRAY START END)
  (LET ((STRING (MAKE-ARRAY (- END START) ':TYPE 'ART-STRING)))
    (COPY-ARRAY-PORTION 8B-ARRAY START END STRING 0 (- END START))
    STRING))


;; This horrible violation of modularity is so that we can parse the package specification
;; with respect to the proper package.
(DEFVAR *FILE-ATTRIBUTE-BINDINGS-SYNTAX*)

;; And this horrible violation of modularity makes this really depend on ZWEI
;; in a way that works.
(DEFVAR ZWEI:*MAJOR-MODES-INITIALIZED* NIL
  "Advertises the availability of ZWEI:MAJOR-MODE-FROM-KEYWORD.")

;;;+++ This function is on its way to being obsolete.  The overall plan
;;;+++ is to remove the use of generic pathnames to carry file attributes
;;;+++ from the system.  Programs will get back the keyword attribute list from
;;;+++ fs:read-attribute-list, and pass that instead of a generic pathname.
;;;+++ then, fs:attribute-bindings-from-property-list can produce the 
;;;+++ progv variables. Note that CANONICALIZE-BASE-AND-SYNTAX is delayed until
;;;+++ binding time because it can use the current binding of BASE and READTABLE
;;;+++ for a default.

(DEFUN FILE-ATTRIBUTE-BINDINGS (PATHNAME &KEY ADDITIONAL-ATTRIBUTES)
  (DECLARE (VALUES PROGV-VARS PROGV-VALS))
  (LET ((RELEVANT-PROPERTY-LIST
	  ;; Don't use CL:ETYPECASE here because the CL type system isn't
	  ;; loaded early enough in the cold load
	  (TYPECASE PATHNAME
	    (:NULL NIL)
	    (:INSTANCE (SEND PATHNAME :PROPERTY-LIST))	; we don't modify the plist
	    (:LOCATIVE (LOCATION-CONTENTS PATHNAME))
	    (OTHERWISE
	      (DBG:CHECK-TYPE-1 'PATHNAME PATHNAME
				'(OR NULL SCL:INSTANCE SCL:LOCATIVE) NIL T)))))
    (ATTRIBUTE-BINDINGS-FROM-PROPERTY-LIST
      RELEVANT-PROPERTY-LIST
      :OVERRIDE-PROPERTIES ADDITIONAL-ATTRIBUTES
      :MAJOR-MODE-ADDITIONAL-ATTRIBUTES
      (IF (NULL ZWEI:*MAJOR-MODES-INITIALIZED*)
	  '((:BASE "" "") (:SYNTAX "" ""))
	  (LET ((MAJOR-MODE 
		  (OR
		    (LET ((MODE-PROPERTY (AND RELEVANT-PROPERTY-LIST
					      (CL:GETF RELEVANT-PROPERTY-LIST ':MODE))))
		      (AND MODE-PROPERTY (ZWEI:MAJOR-MODE-FROM-KEYWORD MODE-PROPERTY
								       ':SILENT)))
		    (ZWEI:MAJOR-MODE-FROM-CANONICAL-TYPE
		      (OR
			(TYPECASE PATHNAME
			  (PATHNAME (SEND PATHNAME :CANONICAL-TYPE))
			  (:LOCATIVE (SEND FDEFINE-FILE-PATHNAME :CANONICAL-TYPE)))
			':LISP)))))
	    (SEND MAJOR-MODE :ADDITIONAL-ATTRIBUTES)))
      :CANONICALIZE-BASE-AND-SYNTAX T
      ;; Don't warn for locatives.
      ;; note that the idiot code below will warn for random malformed attributes,
      ;; for now.
      :OBJECT-FOR-WARNING-MESSAGES (IF (TYPEP PATHNAME 'PATHNAME) PATHNAME NIL)
      '%UPDATE-OBJECT-FOR-IMPROVED-BASE-AND-SYNTAX (IF (TYPEP PATHNAME 'PATHNAME)
						       PATHNAME NIL))))

;;;Use this to get "into" the environment specified by the file.  This
;;;takes a property list, possibly in the (:indicator :keyword) format
;;;produced by fs:read-attribute-list, and hands back a variable set and
;;;a a value set, suitable for PROGV.  For convience, it takes a set of
;;;initial properties to use instead.  On request, it will canonicalize
;;;base and syntax in the returned argument but does not `fix' the
;;;property list.   For CANONICALIZE-BASE-AND-SYNTAX to work, it is
;;;required to pass in MAJOR-MODE-ADDITIONAL-ATTRIBUTES, which inform as
;;;to whether the mode defines BASE and SYNTAX as valid properties.

(DEFUN ATTRIBUTE-BINDINGS-FROM-PROPERTY-LIST
       (FILE-PROPERTY-LIST
	&KEY
	CANONICALIZE-BASE-AND-SYNTAX
	MAJOR-MODE-ADDITIONAL-ATTRIBUTES
	OVERRIDE-PROPERTIES
	OBJECT-FOR-WARNING-MESSAGES
	((%UPDATE-OBJECT-FOR-IMPROVED-BASE-AND-SYNTAX
	   %UPDATE-OBJECT-FOR-IMPROVED-BASE-AND-SYNTAX))
	)
  "Returns two values, a list of special variables and a list of values to bind them to."
  (DECLARE (VALUES VARIABLES-LIST VALUES-LIST INDICATOR-LIST))
  (LET ((PROPERTY-LIST OVERRIDE-PROPERTIES))
    (LOOP FOR (IND VAL) ON FILE-PROPERTY-LIST BY #'CDDR
	  WHEN (EQ (CL:GETF PROPERTY-LIST IND 'APPLESAUSE) 'APPLESAUSE)
	    DO (CL:SETF (CL:GETF PROPERTY-LIST IND) VAL))
    (WHEN CANONICALIZE-BASE-AND-SYNTAX
      (MULTIPLE-VALUE-BIND (A-BASE A-SYNTAX)
	  (FS:CANONICALIZE-BASE-AND-SYNTAX 
	    (CL:GETF PROPERTY-LIST ':BASE)
	    (CL:GETF PROPERTY-LIST ':SYNTAX)
	    MAJOR-MODE-ADDITIONAL-ATTRIBUTES
	    ;; No error if bin-loading or no object-with-property-list
	    OBJECT-FOR-WARNING-MESSAGES
	    OBJECT-FOR-WARNING-MESSAGES
	    NIL
	    FILE-PROPERTY-LIST)
	(IF A-BASE
	    (PROGN
	      (CL:SETF (CL:GETF PROPERTY-LIST ':BASE) A-BASE)
	      (WHEN %UPDATE-OBJECT-FOR-IMPROVED-BASE-AND-SYNTAX
		(SEND %UPDATE-OBJECT-FOR-IMPROVED-BASE-AND-SYNTAX
		      :PUTPROP A-BASE ':BASE)))
	    (WHEN %UPDATE-OBJECT-FOR-IMPROVED-BASE-AND-SYNTAX
	      (SEND %UPDATE-OBJECT-FOR-IMPROVED-BASE-AND-SYNTAX :REMPROP ':BASE)))
	(IF A-SYNTAX
	    (PROGN
	      (CL:SETF (CL:GETF PROPERTY-LIST ':SYNTAX) A-SYNTAX)
	      (WHEN %UPDATE-OBJECT-FOR-IMPROVED-BASE-AND-SYNTAX
		(SEND %UPDATE-OBJECT-FOR-IMPROVED-BASE-AND-SYNTAX
		      :PUTPROP A-SYNTAX ':SYNTAX)))
	    (WHEN %UPDATE-OBJECT-FOR-IMPROVED-BASE-AND-SYNTAX
	      (SEND %UPDATE-OBJECT-FOR-IMPROVED-BASE-AND-SYNTAX :REMPROP ':SYNTAX)))))
    (LOOP WITH *FILE-ATTRIBUTE-BINDINGS-SYNTAX* = (CL:GETF PROPERTY-LIST ':SYNTAX)
	  WITH (VAR VAL IND)
	  FOR (INDICATOR VALUE) ON PROPERTY-LIST BY 'CDDR
	  AS TEM = (GET INDICATOR 'FILE-ATTRIBUTE-BINDINGS)
	  WHEN TEM
	    DO (MULTIPLE-VALUE (VAR VAL IND)
		 (FUNCALL TEM OBJECT-FOR-WARNING-MESSAGES INDICATOR VALUE))
	    AND NCONC VAR INTO VARS AND NCONC VAL INTO VALS AND NCONC IND INTO INDS 
	  FINALLY (RETURN (VALUES VARS VALS INDS)))))

(DEFUN VALIDATE-FILE-ATTRIBUTE (INDICATOR VALUE &OPTIONAL ERROR-OBJECT)
  (IF (GET INDICATOR 'KNOWN-FILE-ATTRIBUTE)
      (LET ((BINDING-HANDLER (GET INDICATOR 'FILE-ATTRIBUTE-BINDINGS)))
	(IF BINDING-HANDLER
	    (FUNCALL BINDING-HANDLER ERROR-OBJECT INDICATOR VALUE)
	    (VALUES INDICATOR VALUE INDICATOR)))
      (IF ERROR-OBJECT (FORMAT ERROR-OUTPUT "Invalid file property ~A for ~A."
			       INDICATOR ERROR-OBJECT)
	  NIL)))


;;--- Interim hook intended only for use by Cloe.
(DEFVAR *CLOE-CANONICALIZE-BASE-AND-SYNTAX-HOOK* NIL)

;;;+++ ADDITIONAL-ATTRIBUTES is misnamed.  It really means 
;;;+++ `those attributes defined for the major mode'
(DEFUN CANONICALIZE-BASE-AND-SYNTAX (BSE SYNTAX ADDITIONAL-ATTRIBUTES
				     &OPTIONAL ERROR-P REAL-PATHNAME IGNORED-OLD-MODE
				     ORIGINAL-PLIST)
  (IGNORE IGNORED-OLD-MODE)
  ;; This assures that the named syntax is really a loaded syntax, or forces
  ;; you to create it, specify an alternative, etc. -kmp 21-Sep-89
  (WHEN SYNTAX (SETQ SYNTAX (SI:LISP-SYNTAX-NAME-SYMBOL (SI:FIND-LISP-SYNTAX SYNTAX))))
  ;;--- Replace this with a more general mechanism some year
  (WHEN *CLOE-CANONICALIZE-BASE-AND-SYNTAX-HOOK*
    (MULTIPLE-VALUE-BIND (BSE SYNTAX)
	(FUNCALL *CLOE-CANONICALIZE-BASE-AND-SYNTAX-HOOK*
		 BSE SYNTAX ADDITIONAL-ATTRIBUTES ERROR-P REAL-PATHNAME NIL ORIGINAL-PLIST)
      (WHEN BSE (RETURN-FROM CANONICALIZE-BASE-AND-SYNTAX (VALUES BSE SYNTAX)))))
  (COND
    ;; Base and no Syntax means syntax is Zetalisp
    ((AND BSE (NULL SYNTAX) (ASSQ :SYNTAX ADDITIONAL-ATTRIBUTES))
     (SETQ SYNTAX :ZETALISP))
    ;; Syntax and no Base means base should be IBASE (Zetalisp) 
    ;; or, for more modern syntaxes, current syntax's default base.
    ((AND SYNTAX (NULL BSE) (ASSQ :BASE ADDITIONAL-ATTRIBUTES))
     (SETQ BSE (IF (EQ SYNTAX :ZETALISP)
		   IBASE
		   (SI:LISP-SYNTAX-DEFAULT-BASE (SI:FIND-LISP-SYNTAX SYNTAX))))))
  ;; Now check for neither base nor syntax
  (WHEN (AND (NULL SYNTAX) (NULL BSE)
	     (ASSQ :SYNTAX ADDITIONAL-ATTRIBUTES)
	     (ASSQ :BASE ADDITIONAL-ATTRIBUTES))
    ;;The rule is: is there is no attribute list at all, use the environment.
    ;;This is approximately consistent with CLtL, which implies that the
    ;;global environment will govern CL:COMPILE-FILE.
    ;;If there was an attribute list, then assume that the file is an
    ;;old ZL file, and use ZL defaults, unless the contents of the attribute list
    ;;imply common lisp.
    (COND ((LOOP FOR (INDICATOR NIL) ON ORIGINAL-PLIST BY 'CDDR
		 ALWAYS (OR (EQ INDICATOR :MODE)
			    (NOT (GET INDICATOR 'KNOWN-FILE-ATTRIBUTE))))
	   (SETF BSE CL:*READ-BASE*)
	   (SETF SYNTAX (SI:READTABLE-APPROPRIATE-FILE-SYNTAX CL:*READTABLE*)))
	  ((LET ((PKG (CL:GETF ORIGINAL-PLIST :PACKAGE)))
	     (OR (NOT PKG)
		 (NOT (SETQ PKG (FIND-PACKAGE-FOR-SYNTAX PKG (OR SYNTAX :ZETALISP) NIL)))
		 (OR (EQ PKG SI:PKG-GLOBAL-PACKAGE)
		     (MEMBER SI:PKG-GLOBAL-PACKAGE (SI:PKG-USE-LIST PKG)))))
	   (SETF SYNTAX :ZETALISP))
	  (T
	   (SETF SYNTAX SI:*DEFAULT-LISP-SYNTAX*)))
    (UNLESS BSE
      (SETQ BSE (SI:LISP-SYNTAX-DEFAULT-BASE (SI:FIND-LISP-SYNTAX SYNTAX))))
    (WHEN ERROR-P
      (FORMAT ERROR-OUTPUT
	      "~&~A has neither a Base nor a Syntax attribute;~@
		   ~2Tthe defaults, Base: ~D and Syntax: ~A, will be used."
	      REAL-PATHNAME
	      BSE
	      (LET ((S (SI:LISP-SYNTAX-FROM-KEYWORD SYNTAX)))
		(IF S
		    (SI:LISP-SYNTAX-EXTERNAL-NAME S)
		    SYNTAX)))))
  (VALUES BSE SYNTAX)) 

;;; Keep this obsolete name around indefinitely - it's in the LMMAN.
(DEFF FILE-PROPERTY-BINDINGS 'FILE-ATTRIBUTE-BINDINGS)
(COMPILER:MAKE-OBSOLETE FILE-PROPERTY-BINDINGS "use FS:FILE-ATTRIBUTE-BINDINGS")

(DEFPROP :MODE T KNOWN-FILE-ATTRIBUTE)
(DEFPROP :SYNTAX T KNOWN-FILE-ATTRIBUTE)
(DEFPROP :PACKAGE T KNOWN-FILE-ATTRIBUTE)
(DEFPROP :BASE T KNOWN-FILE-ATTRIBUTE)
(DEFPROP :PATCH-FILE T KNOWN-FILE-ATTRIBUTE)
(DEFPROP :LOWERCASE T KNOWN-FILE-ATTRIBUTE)
(DEFPROP :BACKSPACE T KNOWN-FILE-ATTRIBUTE)
(DEFPROP :TAB-WIDTH T KNOWN-FILE-ATTRIBUTE)
(DEFPROP :DIAGRAM T KNOWN-FILE-ATTRIBUTE)
(DEFPROP :FONTS T KNOWN-FILE-ATTRIBUTE)
(DEFPROP :NOFILL T KNOWN-FILE-ATTRIBUTE)
(DEFPROP :VSP T KNOWN-FILE-ATTRIBUTE)
(DEFPROP :DEFAULT-CHARACTER-STYLE T KNOWN-FILE-ATTRIBUTE)

(DEFUN (:PROPERTY :SYNTAX FS:FILE-ATTRIBUTE-BINDINGS) (FILE IGNORE SYNTAX-KEYWORD)
  (LET ((SYNTAX (SI:FIND-LISP-SYNTAX (OR SYNTAX-KEYWORD :COMMON-LISP) NIL)))
    (COND (SYNTAX
	   (LET ((THE-READTABLE (SI:LISP-SYNTAX-READTABLE SYNTAX))
		 (BINDINGS (SI:LISP-SYNTAX-ADDITIONAL-FILE-ATTRIBUTE-BINDINGS SYNTAX)))
	     (VALUES (CONS 'READTABLE    (MAPCAR #'FIRST BINDINGS))
		     (CONS THE-READTABLE (MAPCAR #'(LAMBDA (B) (EVAL (SECOND B))) BINDINGS))
		     (CONS ':SYNTAX      (MAPCAR #'(LAMBDA (IGNORE) ':SYNTAX) BINDINGS)))))
	  (T
	   (FORMAT ERROR-OUTPUT "~&~A has an undefined -*- Syntax: ~:(~A~) -*-"
		   (OR FILE "This file") SYNTAX-KEYWORD)
	   NIL))))

#|| ;;This same job is now handled as part of the syntax definition for :COMMON-LISP,etc.
    ;; -kmp 6-Sep-89

(DEFUN (:PROPERTY :COMMON-LISP SYNTAX-ATTRIBUTE-HANDLER) ()
  (VALUES (LIST 'READTABLE) (LIST SI:*COMMON-LISP-READTABLE*) (LIST :SYNTAX)))

(DEFUN (:PROPERTY :ZETALISP SYNTAX-ATTRIBUTE-HANDLER) ()
  (VALUES (LIST 'READTABLE) (LIST SI:STANDARD-READTABLE) (LIST :SYNTAX)))

||#

;If the specified package is not found, don't ask whether to create it.  Instead signal
;a condition, since the debugger provides suitable proceed types, and furthermore some
;programs (e.g. the editor) provide a condition handler that does smarter querying.
(DEFUN (:PROPERTY :PACKAGE FILE-ATTRIBUTE-BINDINGS) (IGNORE IGNORE PKG)
  (VALUES (NCONS 'PACKAGE)
	  (NCONS (FIND-PACKAGE-FOR-SYNTAX PKG *FILE-ATTRIBUTE-BINDINGS-SYNTAX*))
	  (NCONS :PACKAGE)))

(DEFVAR *PACKAGE-FOR-SYNTAX-ALIST*
	'(#|| ;;I believe these are not needed any more.
	      ;;Leave the variable until the end of binary file compat constraints
	      ;;so that users can still push onto it if they know about it.
	      ;;Note, though, that pushing onto it won't necessarily 1do0 anything.
	      ;;New code should not try to do that--instead it should set up the Syntax
	      ;;correctly using SYS:DEFINE-LISP-SYNTAX or some such. -kmp 6-Sep-89
	      (:ZETALISP "ZETALISP")
	      (:COMMON-LISP "COMMON-LISP") ||#))

;;; The definition of FS:FIND-PACKAGE-FOR-SYNTAX has moved to 
;;; SYS:SYS;LISP-SYNTAX.LISP.  (That function is now exported from package SYSTEM,
;;; and inherited by package COMPILER.)
;;; -kmp 5-Oct-89

(DEFUN (:PROPERTY :BASE FILE-ATTRIBUTE-BINDINGS) (FILE IGNORE BSE)
  (COND ((AND (TYPEP BSE ':FIXNUM) (> BSE 1) (< BSE 37.))
	 (VALUES (LIST 'BASE 'IBASE) (LIST BSE BSE) (LIST :BASE :IBASE)))
	(T (FORMAT ERROR-OUTPUT "~&~A has an illegal -*- Base:~S -*-" FILE BSE)
	   NIL)))

;;; So that functions can tell if they are being loaded out of, or compiled in, a patch file
(DEFVAR THIS-IS-A-PATCH-FILE NIL)
(DEFUN (:PROPERTY :PATCH-FILE FILE-ATTRIBUTE-BINDINGS) (IGNORE IGNORE VAL)
  (VALUES (NCONS 'THIS-IS-A-PATCH-FILE)
	  (NCONS VAL)
	  (NCONS :PATCH-FILE)))

;;; This returns the attribute list for a file (that is, the -*- line
;;; for a CHARACTER file, and the "qfasl property list" stuff for a
;;; binary file).  "Attribute list" is the new name for all of these things.
(DEFUN PATHNAME-ATTRIBUTE-LIST (PATHNAME)
  (WITH-OPEN-FILE (STREAM PATHNAME ':CHARACTERS ':DEFAULT)
    (IF (SEND STREAM ':CHARACTERS)
	(READ-ATTRIBUTE-LIST NIL STREAM)
	(SI:BINARY-FILE-STREAM-ATTRIBUTE-LIST STREAM))))

;;; Obsolete name.
(DEFF FILE-PROPERTY-LIST 'PATHNAME-ATTRIBUTE-LIST)
(COMPILER:MAKE-OBSOLETE FILE-PROPERTY-LIST "use FS:PATHNAME-ATTRIBUTE-LIST")

;;; This is a variable for holding a set of open streams.
;;; This variable is looked at by the who-line for the file display.
;;; See the :WHO-LINE-INFORMATION method.
(DEFVAR ALL-OPEN-STREAMS ())
(DEFVAR ALL-OPEN-STREAMS-LAST-UPDATED 0)

(DEFUN ADD-OPEN-STREAM (STREAM)
  ;; Since the wholine is going to display this, make sure all necessary
  ;; information is computed beforehand.  This could be done in an init
  ;; method for the stream but what the heck...
  (SEND-IF-HANDLES STREAM :SET-STRING-FOR-WHOLINE
		   (SEND (SEND STREAM :WHO-LINE-INFORMATION) :STRING-FOR-WHOLINE))
  (WITHOUT-INTERRUPTS
    (COND ((NOT (MEMQ STREAM ALL-OPEN-STREAMS))
	   (PUSH STREAM ALL-OPEN-STREAMS)
	   (SETQ ALL-OPEN-STREAMS-LAST-UPDATED (TIME))))))

(DEFUN DELETE-OPEN-STREAM (STREAM)
  (WITHOUT-INTERRUPTS
    (SETQ ALL-OPEN-STREAMS (DELQ STREAM ALL-OPEN-STREAMS))
    (SETQ ALL-OPEN-STREAMS-LAST-UPDATED (TIME))))

(ADD-INITIALIZATION "Flush Open Streams"
		    '(SETQ ALL-OPEN-STREAMS NIL ALL-OPEN-STREAMS-LAST-UPDATED 0)
		    '(SYSTEM))

;;; Find and close all files
(DEFUN CLOSE-ALL-FILES (&KEY QUERY-EACH (VERBOSE T) (MODE :ABORT) (TRY-HARDER NIL))
  (IF TRY-HARDER
      ;; Normally, this isn't the recommended approach since it may ask about
      ;; all kinds of internal (e.g., encapsulated) streams that the user doesn't
      ;; want to think about.  However, sometimes it's necessary.  Also, this will
      ;; unconditionally clear out open slots in some file access paths -- e.g.,
      ;; see method (:CLOSE-ALL-FILES QFILE-ACCESS-PATH). -kmp,jrd 1-Oct-89
      (LOOP FOR HOST IN (WITHOUT-INTERRUPTS	;Copy to assure a consistent view.
			  (COPYLIST *PATHNAME-HOST-LIST*))
	    NCONC (SEND HOST ':CLOSE-ALL-FILES
			:QUERY-EACH QUERY-EACH
			:VERBOSE VERBOSE
			:MODE MODE
			;; In case there are extensions that don't understand
			;; all of these new keywords, allow them to continue
			;; to function.  Is this necessary? -kmp 29-Sep-89
			:ALLOW-OTHER-KEYS T))
      ;; This is the normal thing that should work unless things are in a massively
      ;; inconsistent state.  It uses the normal abstractions and doesn't do anything
      ;; underhanded. -kmp,jrd 1-Oct-89
      (LOOP FOR FILE-STREAM IN (ALL-OPEN-FILES)
	    NCONC
	      (SI:CLOSE-OPEN-FILE FILE-STREAM :MODE MODE :QUERY QUERY-EACH :VERBOSE VERBOSE))))


(DEFUN ALL-OPEN-FILES ()
  (LET ((VISIBLE-STREAMS
	  (SI:ELIMINATE-DUPLICATES 
	    (APPEND ALL-OPEN-STREAMS
		    (LOOP FOR HOST IN (WITHOUT-INTERRUPTS
					(COPYLIST *PATHNAME-HOST-LIST*))
			  APPEND (SEND HOST ':OPEN-STREAMS))))))
    (LOOP FOR STREAM IN VISIBLE-STREAMS
	  WITH INNER-STREAM
	  ;; this assumes that all encapsulating-type streams are built
	  ;; on si:basic-indirect-stream-mixin, which may not be safe...
	  ;; c'est la vie...
	  WHEN (AND (TYPEP STREAM 'SI:BASIC-INDIRECT-STREAM-MIXIN)
		    (SETQ INNER-STREAM (SEND STREAM ':STREAM))
		    (MEMQ INNER-STREAM VISIBLE-STREAMS))
	    DO (SETQ VISIBLE-STREAMS (CL:DELETE INNER-STREAM VISIBLE-STREAMS ':TEST #'EQ))
	    AND COLLECT INNER-STREAM INTO ENCAPSULATED-STREAMS
	  FINALLY (RETURN (VALUES VISIBLE-STREAMS ENCAPSULATED-STREAMS)))))

(DEFVAR SCL:*LOAD-PATHNAME-DEFAULTS*)
(DEFVAR *AUXILIARY-LOADABLE-FILE-TYPES* NIL)	;sage pushes on here.

(DEFPROP DEFINE-AUXILIARY-LOADABLE-FILE-TYPE "Auxiliary loadable file type"
	 SI:DEFINITION-TYPE-NAME)

(DEFMACRO DEFINE-AUXILIARY-LOADABLE-FILE-TYPE (TYPE &KEY LOAD-STREAM-FUNCTION)
  `(DEFINE-AUXILIARY-LOADABLE-FILE-TYPE-1 ,TYPE :LOAD-STREAM-FUNCTION ,LOAD-STREAM-FUNCTION))

(DEFUN DEFINE-AUXILIARY-LOADABLE-FILE-TYPE-1 (TYPE &KEY LOAD-STREAM-FUNCTION)
  (WHEN (SI:RECORD-SOURCE-FILE-NAME TYPE 'DEFINE-AUXILIARY-LOADABLE-FILE-TYPE)
    (LET ((E (CL:ASSOC TYPE *AUXILIARY-LOADABLE-FILE-TYPES*))
	  (NEW-DATA (IF LOAD-STREAM-FUNCTION
			`(:LOAD-STREAM-FUNCTION ,LOAD-STREAM-FUNCTION)
			NIL)))
      (IF E (CL:SETF (CDR E) NEW-DATA)
	  (PUSH (CONS TYPE NEW-DATA) *AUXILIARY-LOADABLE-FILE-TYPES*)))))

(DEFUN SORT-*AUXILIARY-LOADABLE-FILE-TYPES* (ORDERED-CANONICAL-TYPES)
  (SETQ *AUXILIARY-LOADABLE-FILE-TYPES*
	(CL:STABLE-SORT *AUXILIARY-LOADABLE-FILE-TYPES*
			#'(LAMBDA (E1 E2)
			    (LET ((E1P (CL:POSITION (CAR E1) ORDERED-CANONICAL-TYPES))
				  (E2P (CL:POSITION (CAR E2) ORDERED-CANONICAL-TYPES)))
			      (OR (AND E1P E2P (< E1P E2P))
				  (AND E1P (NULL E2P))))))))

(DEFUN LOAD-TYPE-LIST (PATHNAME &OPTIONAL BINARY-TOO? &AUX TYPES)
  (IF (NOT (MEMQ (SEND PATHNAME ':TYPE) '(NIL :UNSPECIFIC)))
      (VALUES (LIST (SEND PATHNAME ':TYPE)) PATHNAME)
    (SETQ TYPES
	  (APPEND (WHEN BINARY-TOO?
		    (SEND PATHNAME ':TYPES-FOR-CANONICAL-TYPE SI:*DEFAULT-BINARY-FILE-TYPE*))
		  (SEND PATHNAME ':TYPES-FOR-CANONICAL-TYPE ':LISP)
		  (LOOP FOR (TYPE . NIL) IN *AUXILIARY-LOADABLE-FILE-TYPES*
			APPENDING (SEND PATHNAME ':TYPES-FOR-CANONICAL-TYPE TYPE))
		  ))
    (WHEN (EQ (SEND PATHNAME ':TYPE) ':UNSPECIFIC)
      (SETQ PATHNAME (SEND PATHNAME ':NEW-TYPE NIL)))
    (LOOP FOR TYPE IN TYPES
	  UNLESS (AND (NULL (SEND PATHNAME :RAW-TYPE))
		      (CONDITION-CASE ()
			  (SEND PATHNAME :NEW-PATHNAME :TYPE TYPE)
			(FS:PATHNAME-ERROR T)
			(:NO-ERROR NIL)))
	    COLLECT TYPE INTO GOOD-TYPES
	    FINALLY (SETQ TYPES GOOD-TYPES))	    
    (VALUES TYPES PATHNAME)))

;Load a file, the appropriate way, into the appropriate package.
;If the type is specified, we use it;  otherwise, we try BIN and then LISP.
;NONEXISTENT-OK-FLAG if NIL means prompt for a new file to load (this is the default)
;		            unless the FS:MULTIPLE-FILE-NOT-FOUND condition is handled
;		     otherwise means just return it if file not found.
;DONT-SET-DEFAULT-P = NIL means update the defaults as well.
(DEFUN LOAD (PATHNAME &OPTIONAL PKG NONEXISTENT-OK-FLAG DONT-SET-DEFAULT-P NO-MSG-P)
  (CATCH-ERROR-RESTART (ERROR "Skip loading ~A" PATHNAME)
    (ERROR-RESTART (ERROR "Retry loading ~A" PATHNAME)
      (SETQ PATHNAME (PARSE-PATHNAME PATHNAME NIL LOAD-PATHNAME-DEFAULTS))
      (WITH-OPEN-STREAM (STREAM (LOAD-OPEN PATHNAME NONEXISTENT-OK-FLAG DONT-SET-DEFAULT-P))
	(IF STREAM
	    (LOAD-STREAM STREAM PKG NO-MSG-P)
	    NONEXISTENT-OK-FLAG)))))

;;; A version of CL:LOAD which works early in the cold-load.
(DEFUN LOAD-COLD (FILENAME &KEY (VERBOSE T) PRINT (IF-DOES-NOT-EXIST :ERROR)
		  PACKAGE DEFAULT-PACKAGE (SET-DEFAULT-PATHNAME T) (REPROMPT NIL))
  PRINT
  (WHEN (EQ IF-DOES-NOT-EXIST :REPROMPT)
    (SETF REPROMPT T)
    (SETF IF-DOES-NOT-EXIST :ERROR))
  (CATCH-ERROR-RESTART (ERROR "Skip loading ~A" FILENAME)
    (ERROR-RESTART (ERROR "Retry loading ~A" FILENAME)
      (WITH-OPEN-STREAM (STREAM (FS:LOAD-OPEN FILENAME NIL (NOT SET-DEFAULT-PATHNAME)
					      IF-DOES-NOT-EXIST REPROMPT))
	(WHEN STREAM
	  (LET ((CL:*PACKAGE*
		  (IF DEFAULT-PACKAGE
		      (SYS:PKG-FIND-PACKAGE DEFAULT-PACKAGE :ERROR SI:*LISP-PACKAGE*)
		      CL:*PACKAGE*)))
	    (FS:LOAD-STREAM STREAM PACKAGE (NOT VERBOSE)))
	  (SEND STREAM :TRUENAME))))))
(WHEN (NOT (FBOUNDP 'CL:LOAD)) (FSET 'CL:LOAD 'LOAD-COLD))

;;; The first part of LOAD
;;; Returns a stream or NIL (if file is nonexistent and that's okay)
1;;; 0NONEXISTENT-OK-FLAG1 is considered obsolete if 0IF-DOES-NOT-EXIST-GIVEN1.
;;; :if-does-not-exit ':reprompt will trigger the old behavior.
0(DEFUN LOAD-OPEN (PATHNAME &OPTIONAL NONEXISTENT-OK-FLAG DONT-SET-DEFAULT-P
		  (IF-DOES-NOT-EXIST :ERROR IF-DOES-NOT-EXIST-GIVEN)
		  REPROMPT-P)
  (CONDITION-CASE-IF (OR NONEXISTENT-OK-FLAG
			 (EQ IF-DOES-NOT-EXIST NIL))
		     ()
       (LET ((STREAM (OPEN-FILE-SEARCH ('LOAD LOAD-PATHNAME-DEFAULTS
					(OR (NOT IF-DOES-NOT-EXIST-GIVEN)
					    (NEQ IF-DOES-NOT-EXIST :ERROR)
					    REPROMPT-P))
				       (LOAD-TYPE-LIST PATHNAME T)
				       :ELEMENT-TYPE :DEFAULT
				       :IF-DOES-NOT-EXIST (OR IF-DOES-NOT-EXIST :ERROR))))
	 (UNLESS DONT-SET-DEFAULT-P
	   (SET-DEFAULT-PATHNAME (SEND STREAM :PATHNAME) LOAD-PATHNAME-DEFAULTS))
	 STREAM)
     (MULTIPLE-FILE-NOT-FOUND NIL)))

;;; The second part of LOAD
(DEFUN LOAD-STREAM (STREAM &OPTIONAL PKG NO-MSG-P)
  (LET ((TYPE (SEND (SEND STREAM :PATHNAME) :CANONICAL-TYPE)))
    (LET* ((AUX-LOAD-INFO (CDR (CL:ASSOC TYPE *AUXILIARY-LOADABLE-FILE-TYPES*)))
	   (LOAD-FUNCTION (CL:GETF AUX-LOAD-INFO ':LOAD-STREAM-FUNCTION)))
      ;; if we have special information, use it.
      ;; If the file was a character file, read it, else try to fasload it.
      (FUNCALL (OR LOAD-FUNCTION
		   (IF (SEND STREAM ':CHARACTERS)
		       #'SI:READFILE-INTERNAL
		       #'SI:LOAD-BINARY-FILE-INTERNAL))
	       STREAM PKG NO-MSG-P))))

;Called if none of the files searched for exists and no one handles
;the MULTIPLE-FILE-NOT-FOUND condition.  Ask for a new pathname and
;proceed.
(DEFUN MULTIPLE-FILE-NOT-FOUND-HANDLER (ERROR)
  (SEND ERROR ':PROCEED ':NEW-PATHNAME))

(DEFUN READFILE (PATHNAME &OPTIONAL PKG NO-MSG-P)
  (DECLARE (VALUES PATHNAME TRUENAME))
  (SETQ PATHNAME (PARSE-PATHNAME PATHNAME NIL LOAD-PATHNAME-DEFAULTS))
  (WITH-OPEN-FILE-SEARCH (STREAM ('READFILE LOAD-PATHNAME-DEFAULTS T)
				 (LOAD-TYPE-LIST PATHNAME))
    (SI:READFILE-INTERNAL STREAM PKG NO-MSG-P)))

(DEFUN DELETE-DIRECTORY (PATHNAME &REST OPTIONS)
  (DECLARE (ARGLIST PATHNAME &KEY (CONFIRM T)))
  (FORCE-USER-TO-LOGIN)
  (SETQ PATHNAME (SEND (MERGE-PATHNAMES PATHNAME
					(SEND (DEFAULT-PATHNAME) :NEW-PATHNAME
					      :TYPE :WILD :VERSION :WILD)
					:WILD)
		       :TRANSLATED-PATHNAME))
  (ERROR-RESTART (ERROR "Retry DELETE-DIRECTORY of ~A" PATHNAME)
    (LEXPR-SEND PATHNAME :DELETE-DIRECTORY OPTIONS)))

(DEFMETHOD (:DELETE-DIRECTORY PATHNAME) (&REST IGNORE)
  (ERROR 'UNKNOWN-OPERATION :OPERATION :DELETE-DIRECTORY))

(DEFMETHOD (:DELETE-DIRECTORY HIERARCHICAL-DIRECTORY-MIXIN) (&REST OPTIONS)
  (LEXPR-FUNCALL #'DELETE-HIERARCHICAL-DIRECTORY SELF
		 :EXPUNGE-P (MEMQ :UNDELETE (SEND HOST :ATTRIBUTES))
		 OPTIONS))

;;; Could be faster if the server did the work.  But this will do for now.
(DEFUN DELETE-HIERARCHICAL-DIRECTORY (DIRECTORY-PATH &KEY (CONFIRM T) (EXPUNGE-P T))
  (LET ((SUBDIR-FILE-ALIST NIL))
    (LABELS ((DO-ONE (DIRECTORY-PATH)
	       (PUSH (LIST* DIRECTORY-PATH
			    (LOOP FOR (PATHNAME . OPTIONS)
				      IN (CDR
					   (DIRECTORY-LIST (SEND DIRECTORY-PATH
								 :NEW-PATHNAME :NAME :WILD
								 :TYPE :WILD :VERSION :WILD)
							   :SORTED))
				  WHEN (CL:GETF OPTIONS :DIRECTORY)
				    DO (DO-ONE (SEND PATHNAME :PATHNAME-AS-DIRECTORY))
				  ELSE COLLECT PATHNAME))
		     SUBDIR-FILE-ALIST)))
      (DO-ONE DIRECTORY-PATH))
    (WHEN CONFIRM
      (WHEN (EQ CONFIRM :EACH)
	(LOOP FOR (PARENT . CHILDREN) IN SUBDIR-FILE-ALIST DO
	  (FORMAT T "~&Files to be deleted in ~A:"
		  (SEND PARENT :NEW-PATHNAME :NAME :WILD :TYPE :WILD :VERSION :WILD))
	  (COND (CHILDREN
		  (TERPRI)
		  (SCL:FORMAT-ITEM-LIST CHILDREN
					:PRESENTATION-TYPE '((CL:PATHNAME) :FORMAT :DIRED)))
		(T
		 (FORMAT T " ~'iNone~")))))
      (UNLESS (MULTIPLE-VALUE-BIND (NFILES NDIRS)
		  (LOOP FOR (NIL . CHILDREN) IN SUBDIR-FILE-ALIST
			COUNT T INTO NDIRS
			SUM (LENGTH CHILDREN) INTO NFILES
			FINALLY (RETURN (VALUES NFILES NDIRS)))
		(IF (> NDIRS 1) (DECF NDIRS) (SETQ NDIRS NIL))
		(UNLESS (PLUSP NFILES) (SETQ NFILES NIL))
		(CL:YES-OR-NO-P "Okay to delete and expunge ~@[~D file~:P from ~]~A~
~@[ and its ~D subdirector~:@P~]? "
				NFILES
				(SEND DIRECTORY-PATH :NEW-PATHNAME
				      :NAME NIL :TYPE NIL :VERSION NIL)
				NDIRS))
	(RETURN-FROM DELETE-HIERARCHICAL-DIRECTORY NIL)))
    (SETQ SUBDIR-FILE-ALIST (NREVERSE SUBDIR-FILE-ALIST))
    (LOOP FOR (PARENT . CHILDREN) IN SUBDIR-FILE-ALIST DO
      (DOLIST (CHILD CHILDREN)
	(DELETEF CHILD))
      (WHEN EXPUNGE-P
	(EXPUNGE-DIRECTORY PARENT))
      (DELETEF (SEND PARENT :DIRECTORY-PATHNAME-AS-FILE)))))
