;;; -*- Mode: LISP; Syntax: Zetalisp; Package: FORMAT; Base: 10 -*-
;;; Function for printing or creating nicely formatted strings.
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; New FORMAT -- 8/14/85 DLA
;;; FORMAT now only supports a control argument which is a string (or symbol).

;;; (FORMAT <stream> <control arg> &REST <args>)
;;; If <stream> is NIL, cons up and return a string.
;;; If <stream> is T, use STANDARD-OUTPUT (saves typing).

(DEFVAR *FORMAT-OUTPUT* NIL "The stream to which directives send output.")
;;(DEFVAR FORMAT-STRING)		 ;The string used for (FORMAT NIL ...)
(DEFVAR *COMMON-LISP-FORMAT* NIL)		;T if we're to interpret things the CL way

(DEFVAR CTL-STRING)		 ;The control string.
(DEFVAR CTL-LENGTH)		 ;STRING-LENGTH of CTL-STRING.
(DEFVAR CTL-INDEX)		 ;Our current index into the control string.  This
				 ;  is used by the conditional command. (NYI)
(DEFVAR ATSIGN-FLAG)		 ;Modifier
(DEFVAR COLON-FLAG)		 ;Modifier
(DEFVAR FORMAT-PARAMS)		 ;Array for pushing parameters
(DEFVAR FORMAT-ARGLIST)		 ;The original arg list, for ~G.
(DEFVAR LOOP-ARGLIST)		 ;Loop arglist, for ~:^.
(DEFVAR FORMAT-CHAR-TABLE)	 ;Table of single-char symbols, for fast interning.
(DEFVAR ROMAN-OLD)

(DEFMACRO WITH-STACK-SUBSTRING ((VAR . SUBSTRING-ARGS) &BODY BODY &ENVIRONMENT ENV)
  (DESTRUCTURING-BIND (STRING FROM &OPTIONAL TO) SUBSTRING-ARGS
    (ONCE-ONLY (STRING FROM TO &ENVIRONMENT ENV)
      (LET ((TO-VAR (GENSYM))
	    (LENGTH-VAR (GENSYM)))
	`(LET* ((,TO-VAR (OR ,TO (ARRAY-ACTIVE-LENGTH ,STRING)))
		(,LENGTH-VAR (- ,TO-VAR ,FROM)))
	   (SYS:WITH-STACK-ARRAY (,VAR ,LENGTH-VAR :TYPE (SYS:ARRAY-TYPE-FIELD ,STRING))
	     (COPY-ARRAY-PORTION ,STRING ,FROM ,TO-VAR ,VAR 0 ,LENGTH-VAR)
	     . ,BODY))))))

(DEFCONST FORMAT-PACKAGE PACKAGE)		;The package I was loaded into

(DEFVAR *FORMAT-CHARACTER-FUNCTIONS* (MAKE-ARRAY #o400 :AREA PERMANENT-STORAGE-AREA))

;; The :FORMAT function spec handler
;; (:FORMAT symbol)
;; symbol has a pname which is the format directive string.

(SYS:DEFINE-FUNCTION-SPEC-HANDLER :FORMAT 
				  (FUNCTION SPEC &OPTIONAL ARG1 ARG2)
  (LET* ((SYMBOL NIL)
	 (VALID (AND (SYMBOLP SYMBOL)
		     (= (LENGTH SPEC) 2)
		     (SYMBOLP (SETQ SYMBOL (CADR SPEC)))
		     (EQ SYMBOL (INTERN-SOFT (GET-PNAME SYMBOL) FORMAT-PACKAGE))
		     (= (STRING-LENGTH (CADR SPEC)) 1))))
    (IF (EQ FUNCTION 'SI:VALIDATE-FUNCTION-SPEC) VALID
	(UNLESS VALID
	  (FERROR "~S is not a valid function spec." SPEC))
	(SELECTQ FUNCTION
	  (SI:FDEFINE (DEFINE-FORMAT-FUNCTION SYMBOL ARG1))
	  (SI:(FDEFINEDP FDEFINITION) (FORMAT-DEFINITION SYMBOL))
	  (SI:FUNDEFINE (UNDEFINE-FORMAT-FUNCTION SYMBOL))
	  (SI:DEFINITION-HAS-LOCATION-P T)
	  (SI:FDEFINITION-LOCATION (FORMAT-DEFINITION-LOCATION SYMBOL))
	  (OTHERWISE (SI:FUNCTION-SPEC-DEFAULT-HANDLER FUNCTION SPEC ARG1 ARG2))))))

(DEFUN DEFINE-FORMAT-FUNCTION (SYMBOL DEFINITION)
  (SETF (AREF *FORMAT-CHARACTER-FUNCTIONS* (* (CHAR-CODE (CHARACTER SYMBOL)) 2))
	DEFINITION))

(DEFUN DEFINE-FORMAT-FUNCTION-TYPE (SYMBOL TYPE)
  (SETF (AREF *FORMAT-CHARACTER-FUNCTIONS* (1+ (* (CHAR-CODE (CHARACTER SYMBOL)) 2)))
	TYPE))

(DEFUN UNDEFINE-FORMAT-FUNCTION (SYMBOL)
  (SETF (AREF *FORMAT-CHARACTER-FUNCTIONS* (* (CHAR-CODE (CHARACTER SYMBOL)) 2))
	NIL))

(DEFUN FORMAT-DEFINITION (SYMBOL)
  (AREF *FORMAT-CHARACTER-FUNCTIONS* (* (CHAR-CODE (CHARACTER SYMBOL)) 2)))

(DEFUN FORMAT-DEFINITION-LOCATION (SYMBOL)
  (ALOC *FORMAT-CHARACTER-FUNCTIONS* (* (CHAR-CODE (CHARACTER SYMBOL)) 2)))

;Little arrays in which to cons up lists of parameters
(DEFRESOURCE FORMAT-PARAMS ()
  :CONSTRUCTOR (MAKE-ARRAY 10. ':TYPE 'ART-Q-LIST
			       ':FILL-POINTER 0)
  :INITIAL-COPIES 10.)


#||
(DEFPROP FORMAT-STRING-STREAM T SI:IO-STREAM-P)

(DEFMACRO EXTEND-FORMAT-STRING (EXTENSION &BODY BODY)
  `(LET* ((OLD-FILL-POINTER (FILL-POINTER FORMAT-STRING))
	  (NEW-FILL-POINTER (+ OLD-FILL-POINTER ,EXTENSION)))
     (WHEN (< (ARRAY-LENGTH FORMAT-STRING) NEW-FILL-POINTER)
       (SETQ FORMAT-STRING (ADJUST-ARRAY-SIZE FORMAT-STRING (* 2 NEW-FILL-POINTER))))
     ,@ BODY
     (SETF (FILL-POINTER FORMAT-STRING) NEW-FILL-POINTER)))

;; (FORMAT NIL ...) or (FORMAT SOME-STRING ...) outputs to this stream, which just puts the
;; characters into the string FORMAT-STRING.

(DEFSELECT (FORMAT-STRING-STREAM FORMAT-STRING-STREAM-DEFAULT-HANDLER)
  (:TYO (CH)
   (ARRAY-PUSH-EXTEND FORMAT-STRING CH))

  (:STRING-OUT (STRING &OPTIONAL (FIRST 0) LAST)
   (OR LAST (SETQ LAST (ARRAY-ACTIVE-LENGTH STRING)))
   (EXTEND-FORMAT-STRING (- LAST FIRST)
     (COPY-ARRAY-PORTION STRING FIRST LAST
			 FORMAT-STRING OLD-FILL-POINTER NEW-FILL-POINTER)))

  (:READ-CURSORPOS (&OPTIONAL (MODE ':CHARACTER))
   (OR (EQ MODE ':CHARACTER)
       (FERROR "String cannot have :PIXEL"))
   (LET ((POS (STRING-REVERSE-SEARCH-CHAR #\CR FORMAT-STRING)))
     (VALUES (- (FILL-POINTER FORMAT-STRING) (IF POS (+ POS 1) 0))
	     0)))

  (:INCREMENT-CURSORPOS (DX DY &OPTIONAL (MODE ':CHARACTER))
   (UNLESS (EQ MODE ':CHARACTER)
     (FERROR "String cannot have :PIXEL"))
   (UNLESS (AND (OR (NULL DY) (ZEROP DY)) (NOT (MINUSP DX)))
     (FERROR "Cannot do this :INCREMENT-CURSORPOS"))
   (EXTEND-FORMAT-STRING DX
     (LOOP FOR I FROM OLD-FILL-POINTER BELOW NEW-FILL-POINTER
	   DO (ASET #\SP FORMAT-STRING I))))

  (:SET-CURSORPOS (X Y &OPTIONAL (MODE ':CHARACTER))
   (OR (EQ MODE ':CHARACTER)
       (FERROR "String cannot have :PIXEL"))
   (LET* ((POS (STRING-REVERSE-SEARCH-SET '(#\RETURN #\LINE #\FORM) FORMAT-STRING))
	  (DELTA (- X (- (FILL-POINTER FORMAT-STRING) (IF POS (+ POS 1) 0)))))
     (UNLESS (AND (OR (NULL Y) (ZEROP Y)) (PLUSP DELTA))
       (FERROR "Cannot do this :SET-CURSORPOS"))
     (EXTEND-FORMAT-STRING DELTA
       (LOOP FOR I FROM OLD-FILL-POINTER BELOW NEW-FILL-POINTER
	     DO (ASET #\SP FORMAT-STRING I)))))

  (:FRESH-LINE ()
   (UNLESS (OR (ZEROP (FILL-POINTER FORMAT-STRING))
	       (CHAR-EQUAL (AREF FORMAT-STRING (1- (FILL-POINTER FORMAT-STRING))) #\CR))
     (ARRAY-PUSH-EXTEND FORMAT-STRING #\CR)
     T)))

(DEFUN FORMAT-STRING-STREAM-DEFAULT-HANDLER (OP &OPTIONAL ARG1 &REST REST)
  (STREAM-DEFAULT-HANDLER 'FORMAT-STRING-STREAM OP ARG1 REST))
||#

(DEFUN FORMAT (STREAM CTL-STRING &REST ARGS)
  "Format arguments according to a control string and print to a stream.  (If the stream
is T, STANDARD-OUTPUT is used; if NIL, a string is returned containing the formatted text.)
The control string is copied to the stream, but ~ indicates special formatting commands:
~D  ~mincol,padchar,commacharD   Print number as a decimal integer.
    ~:D  Print the comma character every three digits.
    ~@D  Always print the sign.   ~:@D  Both.
~O  Analogous to ~D, but prints in octal.
~F  ~F  Print a floating point number.   ~nF  Round it to n digits.
~E  ~E  Print a floating-point number in exponential notation.   ~nE  Round to n digits.
~$  ~w,x,y,z prints a floating-point number with exactly w (default 2) digits to right of
     decimal, at least x (default 1) to left of decimal, right-justified in field y wide
     padded with z.  @ print + sign.  : sign to left of padding.
~R  ~R  Print number as an English cardinal number.
    ~:R  English ordinal number.   ~@R  Roman numeral.   ~:@R  Old Roman numeral.
    ~nR  Print number in radix n.  Thus ~8R = ~O, and ~10R = ~D.
    Extra parameters are as for ~D (~n,mincol,padchar,commacharR).
~A  Ascii output (PRINC).  Good for printing strings.  ~mincol,colinc,minpad,padcharA.
    ~@A  Right-justify the string.   ~:A  Make NIL print as ().  ~:@A  Both.
~S  Analogous to ~A, but uses PRIN1, not PRINC.
~C  Print a character.  Mouse characters print in standard format.
    ~C  Code, preceded by c-, m-, etc. if control bits are present.
    ~:C  Format effectors print as names.  Names of control bits (/"Control-/") precede.
    ~@C  Prints the character in READ format, using #// or #\.
    ~:@C  Like ~:C, but top/front/greek characters are followed by remark, e.g. /" (Top-S)/".
~*  Ignore an argument.   ~n*  Ignore n arguments.   ~:n*  Back up n arguments (default 1).
    ~n@* Go to argument n (default zero: first argument).  Operates relative to ~{...~} lists.
~%  Insert a newline.     ~n%  Insert n newlines.
~X  Insert a space.  (use ~n@T instead, as ~X will eventually mean hexadecimal output).
~~  Insert a tilde.       ~n~  Insert n tildes.
~|  Insert a form.        ~n|  Insert n forms.
    ~:|  Do :CLEAR-SCREEN if the stream supports it, otherwise insert a form.   ~:n|  Similar.
~<cr>  Ignore a CR and following whitespace in the control string.
    ~:<cr> Ignore the CR, retain the whitespace.  ~@<cr> Retain the CR, ignore the whitespace.
~&  Do a :FRESH-LINE.     ~n&  Do a FRESH-LINE, then insert n-1 newlines.
~  Do a :DISPLAY-LOZENGED-STRING if the argument is a string or a symbol.
    Use its name as a character if it is a fixnum.
~^  Terminate processing if no more arguments.  Within ~{...~}, just terminate the loop.
    ~n;  Terminate if n is zero.  ~n,m;  Terminate if n=m.  ~n,m,p;  Terminate if nmp.
    ~:^  When within ~:{...~}, ~^ terminates this iteration.  Use ~:^ to exit the loop.
~T  ~mincol,colincT  Tab to column mincol+p*colinc, for the smallest integer p possible.
    ~mincol,colinc:T  Same, but tabs in TV pixels rather than characters.
    ~n@T  Output n spaces (n defaults to 1).
~Q  Apply next argument to no arguments.  ~a,b,c,...,zQ  Apply next argument to parameters
    a,b,c,...z.  In (Q ...) form, apply argument to unevaled parameters.
~P  Pluralize.  Insert /"s/", unless argument is 1.
    ~:P  Use previous argument, not next one (i.e. do ~:* first).
    ~@P  Insert /"y/" if argument is 1, otherwise insert /"ies/".   ~:@P  Both.
~G  Goto.  ~nG goes to the nth argument (0-origin).  Operates relative to ~{...~} lists.
    Use ~n@* instead, as ~G will eventually be replaced by a floating-point formatter.
~<  ~mincol,colinc,minpad,padchar<str0~;str1~;...~;strn~>  Do formatting for all formatting
    strings strj; then output all strings with padding between them at the ~; points.
    Each padding point must have at least minpad padding characters.  Subject to that,
    the total width must be at least mincol, and must be mincol+p*colinc for some p.
    If str0 is followed by ~:; instead of ~;, then str0 is not normally output, and the
    ~:; is not a padding point.  Instead, after the total width has been determined,
    if the text will not fit into the current line of output, then str0 is output before
    outputting the rest.  (Doesn't work when producing a string.)  An argument n (~:n;)
    means that the text plus n more columns must fit to avoid outputting str0.  A second
    argument m (~n,m:;) provides the line width to use instead of the stream's width.
    ~:<  Also have a padding point at the left.  Hence ~n:<x~> right-justifies x in n columns.
    ~@<  Also have a padding point at the right.   ~:@<  Both.   Hence ~n:@<x~> centers x.
~[  ~[str0~;str1~;...~;strn~]  Cases.  Argument selects one case to do.  If argument is not
    between 0 and n inclusive, then no alternative is performed.  If a parameter is given,
    then use the parameter instead of an argument.  (The only useful one is /"#/".)
    If the last string is preceded by ~:;, it is an /"else/" clause, and is processed if
    no other string is selected.
    One can also tag the cases explicitly by giving arguments to ~;.  In this case the
    first string must be null, and arguments to ~; tag the following string.  The
    argument is matched against the list of parameters for each ~;.  One can get ranges
    of tags by using ~:;.  Pairs of parameters serve as inclusive range limits.
    A ~:; with no parameters is still an /"else/" case.
    Example:  ~[~'+,'-,'*,'////;operator~:'A,'Z,'a,'z;letter~:'0,'9;digit~:;other~]
    will produce /"operator/", /"letter/", /"digit/", or /"other/" as appropriate.
    ~:[iffalse~;iftrue~]  The argument selects the first case if nil, the second if non-nil.
    ~@[str~]  If the argument is non-nil, then it is not swallowed, and str is processed.
    Otherwise, the nil is swallowed and str is ignored.  Thus ~@[~S~] will PRIN1 a
    non-null thing.
~{  ~{str~}  Use str as a format string for each element in the argument.  More generally,
    the argument is a list of things to be used as successive arguments, and str is used
    repeatedly as a format string until the arguments are exhausted (or ~^ is used).
    Within the iteration the commands ~* and ~G move among the iteration arguments,
    not among all the arguments given to FORMAT.
    ~n{str~} repeats the string at most n times.
    Terminating with ~:} forces str to be processed at least once.
    ~:{str}  The argument is a list of lists, and each repetition sees one sublist.
    ~@{str}  All remaining arguments are used as the list.
    ~:@{str}  Each remaining argument is a list.
    If the str within a ~{ is empty, then an argument (which must be a string) is used.
    This argument precedes any that are iterated over as loop arguments.
In place of a numeric parameter, one may use V, which uses an argument to supply the number;
or one may use #, which represents the number of arguments remaining to be processed;
or one may use 'x, which uses the ascii value of x (good for pad characters).
The control string may actually be a list of intermixed strings and sublists.
In that case, the strings are printed literally.  The first atom in a sublist should be
the name of a command, and remaining elements are parameters."
  (SI:CHECK-STRING-ARG CTL-STRING )
  (LET ((RESULT (LET ((*COMMON-LISP-FORMAT* NIL))
		  (LEXPR-FUNCALL #'FORMAT-INTERNAL STREAM CTL-STRING ARGS))))
    (AND (NULL STREAM) RESULT)))

(DEFUN FORMAT-INTERNAL (STREAM CTL-STRING &REST ARGS)
  (FLET ((DO-IT ()
	   (LET ((FORMAT-ARGLIST ARGS)
		 (LOOP-ARGLIST NIL))
	     (CATCH 'FORMAT-/:^-POINT
	       (CATCH 'FORMAT-^-POINT
		 (COND ((STRINGP CTL-STRING)
			(SETF ARGS (FORMAT-CTL-STRING ARGS CTL-STRING)))
		       ((SYMBOLP CTL-STRING)
			(SETF ARGS (FORMAT-CTL-STRING ARGS (GET-PNAME CTL-STRING))))
		       (T (FERROR "~S is not a valid format control string." CTL-STRING)
			  ))))
	     (COPYLIST ARGS))))
    (COND ((NULL STREAM)
	   (LISP:WITH-OUTPUT-TO-STRING (*FORMAT-OUTPUT*)
	     (DO-IT)))
	  ((STRINGP STREAM)
	   (LISP:WITH-OUTPUT-TO-STRING (*FORMAT-OUTPUT* STREAM)
	     (DO-IT)))
	  (T
	   (LET ((*FORMAT-OUTPUT* (IF (EQ STREAM T) STANDARD-OUTPUT STREAM)))
	     (DO-IT))))))

;;; Call this to signal an error in FORMAT processing.  If CTL-STRING is a string, then
;;; CTL-INDEX should point one beyond the place to be indicated in the error message.

;;; Note: when you call format-error, remember that format-error calls format
;;; on its string arg, so please remember that explicit tildes must be quoted
;;; (with another tilde).

(DEFUN FORMAT-ERROR (STRING &REST ARGS)
  (DECLARE (DBG:ERROR-REPORTER))
  (IF (STRINGP CTL-STRING)
      (LET ((START-INDEX (STRING-REVERSE-SEARCH-CHAR #\CR CTL-STRING CTL-INDEX)))
	(SETQ START-INDEX (IF START-INDEX (1+ START-INDEX) 0))
	(FERROR "~1{~:}~%~VT~%~:[~2@T...~;~4@T/"~]~A/"" STRING ARGS
		(+ (- CTL-INDEX START-INDEX) 4)
		(ZEROP START-INDEX) (SUBSTRING CTL-STRING START-INDEX)))
      (FERROR "~1{~:}" STRING ARGS)))

;(DEFUN FORMAT-CTL-LIST (ARGS CTL-LIST &AUX (ATSIGN-FLAG NIL) (COLON-FLAG NIL))
;    (FORMAT-CTL-OP (COND ((GETL (CAR CTL-LIST)
;				'(CTL-ONE-ARG CTL-NO-ARG CTL-MULTI-ARG CTL-REPEAT-CHAR
;				  FORMAT-CTL-ONE-ARG FORMAT-CTL-NO-ARG FORMAT-CTL-MULTI-ARG))
;			  (CAR CTL-LIST))
;			 (T (INTERN-LOCAL-SOFT (CAR CTL-LIST) FORMAT-PACKAGE)))
;		   ARGS (CDR CTL-LIST)))

(DEFUN FORMAT-CTL-STRING (ARGS CTL-STRING &AUX (FORMAT-PARAMS NIL))
  (UNWIND-PROTECT
      (DO ((CTL-INDEX 0)
	   (CTL-LENGTH (ARRAY-ACTIVE-LENGTH CTL-STRING))
	   (STREAM *FORMAT-OUTPUT*)
	   (TEM) (FUNCTION) (TYPE))
	  ((>= CTL-INDEX CTL-LENGTH))
	(SETQ TEM (%STRING-SEARCH-CHAR #/~ CTL-STRING CTL-INDEX CTL-LENGTH))
	(COND ((NEQ TEM CTL-INDEX)		;Put out some literal string
	       (FUNCALL STREAM ':STRING-OUT CTL-STRING CTL-INDEX TEM)
	       (IF (NULL TEM) (RETURN))
	       (SETQ CTL-INDEX TEM)))
	;; (AREF CTL-STRING CTL-INDEX) is a tilde.
	(LET ((ATSIGN-FLAG NIL)
	      (COLON-FLAG NIL))
	  (IF (NULL FORMAT-PARAMS) 
	      (SETQ FORMAT-PARAMS (ALLOCATE-RESOURCE 'FORMAT-PARAMS)))
	  (STORE-ARRAY-LEADER 0 FORMAT-PARAMS 0)
	  (MULTIPLE-VALUE (NIL FUNCTION TYPE ARGS) (FORMAT-PARSE-COMMAND ARGS T))
	  (SETQ ARGS (FORMAT-CTL-OP FUNCTION TYPE ARGS (G-L-P FORMAT-PARAMS)))))
    (WHEN FORMAT-PARAMS (DEALLOCATE-RESOURCE 'FORMAT-PARAMS FORMAT-PARAMS)))
  ARGS)

;;; Expects ATSIGN-FLAG, COLON-FLAG, and FORMAT-PARAMS to be bound.
;;; CTL-INDEX points to a tilde.
;;; Returns character (if not long), function, type, and args
;;; leaving CTL-INDEX after the command.  NIL for the command name
;;; means no command there
;;; If SWALLOW-ARGS is NIL, we are not executing commands, just parsing,
;;; e.g. to find a matching ~}, ~], or ~>.  So don't swallow any args (e.g. for ~V).
(DEFUN FORMAT-PARSE-COMMAND (ARGS SWALLOW-ARGS)
  (DO ((PARAM-FLAG NIL)				;If T, a parameter has been started in PARAM
       (START CTL-INDEX)			;for error message
       (CH)
       (FUNCTION) (TYPE)
       (PARAM NIL)				;PARAM is the parameter currently being constructed
       (PARAM-SIGN NIL))
      ((>= (SETQ CTL-INDEX (1+ CTL-INDEX)) CTL-LENGTH)
       (SETQ CTL-INDEX (1+ START))
       (FORMAT-ERROR "Command fell off end of control string"))
    (SETQ CH (AREF CTL-STRING CTL-INDEX))
    (SETQ CH (CHAR-UPCASE CH))
    (COND ((DIGIT-CHAR-P CH)
	   (SETQ PARAM (+ (* (OR PARAM 0) 10.) (DIGIT-CHAR-P CH))
		 PARAM-FLAG T))
	  ((AND (NOT PARAM) (NOT PARAM-SIGN) (OR (CHAR-EQUAL CH #/+) (CHAR-EQUAL CH #/-)))
	   (SETQ PARAM-SIGN CH
		 PARAM-FLAG T))
	  ((CHAR-EQUAL CH #/@)
	   (SETQ ATSIGN-FLAG T))
	  ((CHAR-EQUAL CH #/:)
	   (SETQ COLON-FLAG T))
	  ((CHAR-EQUAL CH #/V)
	   (COND ((AND (NULL ARGS) SWALLOW-ARGS)
		  (SETQ CTL-INDEX (1+ CTL-INDEX))
		  (FORMAT-ERROR "No argument for V parameter to use")))
	   (SETQ PARAM (POP ARGS) PARAM-FLAG T))
	  ((CHAR-EQUAL CH #/#)
	   (SETQ PARAM (LENGTH ARGS) PARAM-FLAG T))
	  ((CHAR-EQUAL CH #/')
	   (INCF CTL-INDEX)
	   (SETQ PARAM (AREF CTL-STRING CTL-INDEX))
	   (SETQ PARAM-FLAG T))
	  ((CHAR-EQUAL CH #/,)			;comma, begin another parameter
	   (AND PARAM-SIGN (NOT PARAM) (SETQ PARAM 1))
	   (AND (EQL PARAM-SIGN #/-) (SETQ PARAM (- PARAM)))
	   (ARRAY-PUSH FORMAT-PARAMS PARAM)
	   (SETQ PARAM NIL			;omitted arguments made manifest by the
		 PARAM-SIGN NIL			;presence of a comma come through as NIL
		 PARAM-FLAG T))
	  ((CHAR-EQUAL CH #\CR)			;No command, just ignoring a CR
	   (SETQ CTL-INDEX (1+ CTL-INDEX))	;Skip the newline
	   (OR COLON-FLAG			;Unless colon, skip whitespace on the next line
	       (DO ()
		   ((OR (>= CTL-INDEX CTL-LENGTH)
			(NOT (LET ((CHAR (AREF CTL-STRING CTL-INDEX)))
			       (OR (CHAR-EQUAL CHAR #\SP)
				   (CHAR-EQUAL CHAR #\TAB))))))
		 (SETQ CTL-INDEX (1+ CTL-INDEX))))
	   (RETURN (VALUES #\CR #'FORMAT-CRLF :NO-ARG ARGS)))
	  (T					;Must be a command character
	   (SETQ CTL-INDEX (1+ CTL-INDEX))	;Advance past command character
	   (WHEN PARAM-FLAG
	     (AND PARAM-SIGN (NOT PARAM) (SETQ PARAM 1))
	     (AND (EQL PARAM-SIGN #/-) (SETQ PARAM (- PARAM)))
	     (ARRAY-PUSH FORMAT-PARAMS PARAM))
	   (SETQ PARAM-FLAG NIL PARAM NIL PARAM-SIGN NIL)
	   (COND ((CHAR-EQUAL CH #/\)
		  (LET ((I (STRING-SEARCH-CHAR #/\ CTL-STRING (1+ CTL-INDEX))))
		    (WHEN (NULL I)
		      (FORMAT-ERROR "Unmatched \ in control string."))
		    (LET ((COLON (%STRING-SEARCH-CHAR #/: CTL-STRING CTL-INDEX I))
			  (PKG FORMAT-PACKAGE))
		      (WHEN COLON
			(WITH-STACK-SUBSTRING (STR CTL-STRING CTL-INDEX COLON)
			  (SETQ CTL-INDEX (1+ COLON))
			  (SETQ PKG (PKG-FIND-PACKAGE STR ':FIND))
			  (WHEN (NULL PKG)
			    ;; Try to make sure that DEFAULT-CONS-AREA is safe on break
			    (FORMAT-ERROR "Cannot find package."))))
		      (WITH-STACK-SUBSTRING (TEM CTL-STRING CTL-INDEX I)
			(MACROLET ((CANONICALIZE (CHAR)
				     (ONCE-ONLY (CHAR)
				       `(PROGN (SETF (SI:CHAR-STYLE-INDEX ,CHAR) 0)
					       (CHAR-UPCASE ,CHAR)))))
			  (SETQ CTL-INDEX (1+ I))
			  ;; Destructive string upcase and style stripping.
			  (LOOP FOR I BELOW (ARRAY-ACTIVE-LENGTH TEM)
				DO (SETF (AREF TEM I) (CANONICALIZE (AREF TEM I)))))
			(LET ((SYM (INTERN-SOFT TEM PKG)))
			  (WHEN SYM
			    (LET ((FUN (GETL SYM
					     FORMAT:'(CTL-NO-ARG CTL-ONE-ARG CTL-MULTI-ARG))))
			      (WHEN FUN
				(SETQ FUNCTION (CADR FUN)
				      TYPE (CDR (ASSQ (CAR FUN)
						      FORMAT:
						      '((CTL-NO-ARG . :NO-ARG)
							(CTL-ONE-ARG . :ONE-ARG)
							(CTL-MULTI-ARG . :MULTI-ARG))))
				      CH SYM)))))))))
		 (T (LET ((INDEX (* (CHAR-CODE CH) 2))
			  (ARRAY *FORMAT-CHARACTER-FUNCTIONS*))
		      (WHEN (< INDEX (ARRAY-LENGTH ARRAY))
			(SETQ FUNCTION (AREF ARRAY INDEX)
			      TYPE (AREF ARRAY (1+ INDEX)))))))
	   (RETURN (VALUES CH FUNCTION TYPE ARGS))))))

(DEFUN REDEFINE-FORMAT-DIRECTIVE (SYMBOL PROPERTY)
  (LOOP FOR OLD-PROPERTY IN '(CTL-NO-ARG CTL-ONE-ARG CTL-MULTI-ARG)
	WHEN (AND (NEQ OLD-PROPERTY PROPERTY)
		  (GET SYMBOL OLD-PROPERTY))
	  DO (LET ((COMPILER:DEFAULT-WARNING-FUNCTION SYMBOL)
		   (COMPILER:DEFAULT-WARNING-DEFINITION-TYPE 'DEFFORMAT))
	       (CL:WARN "Redefining format directive ~S from ~S to ~S.~@
		         Removing the old definition so it will not conflict with the new one."
			SYMBOL
			(INTERN (SUBSTRING OLD-PROPERTY 4) "")
			(INTERN (SUBSTRING PROPERTY 4) "")))
	     (CL:REMPROP SYMBOL OLD-PROPERTY)))

(DEFMACRO DEFFORMAT (DIRECTIVE (ARG-TYPE) ARGLIST &BODY BODY)
  (CHECK-ARG ARG-TYPE (MEMQ ARG-TYPE '(:NO-ARG :ONE-ARG :MULTI-ARG))
	     "one of :NO-ARG, :ONE-ARG, or :MULTI-ARG")
  `(PROGN 'COMPILE
	  (RECORD-SOURCE-FILE-NAME ',DIRECTIVE 'DEFFORMAT)
	  . ,(IF ( (STRING-LENGTH DIRECTIVE) 1)
		 (LET ((PROPERTY (CDR (ASSQ ARG-TYPE
					    FORMAT:'((:NO-ARG . CTL-NO-ARG)
						     (:ONE-ARG . CTL-ONE-ARG)
						     (:MULTI-ARG . CTL-MULTI-ARG))))))
		   `((REDEFINE-FORMAT-DIRECTIVE ',DIRECTIVE ',PROPERTY)
		     (DEFUN (:PROPERTY ,DIRECTIVE ,PROPERTY) ,ARGLIST
		       (DECLARE (SYS:FUNCTION-PARENT ,DIRECTIVE DEFFORMAT))
		       . ,BODY)))
	       `((DEFINE-FORMAT-FUNCTION-TYPE ',DIRECTIVE ',ARG-TYPE)
		 (DEFUN (:FORMAT ,DIRECTIVE) ,ARGLIST
		   (DECLARE (SYS:FUNCTION-PARENT ,DIRECTIVE DEFFORMAT))
		   . ,BODY)))))

(DEFPROP DEFFORMAT "Format Directive" SI:DEFINITION-TYPE-NAME)

;;; Perform a single formatted output operation on specified args.
;;; ARGS is the list of FORMAT arguments so far; returns the remaining args
;;; not used up by the operation.
(DEFUN FORMAT-CTL-OP (FUNCTION TYPE ARGS PARAMS)
    (COND ((EQ TYPE :NO-ARG)	(FUNCALL FUNCTION PARAMS)		ARGS)
	  ((EQ TYPE :ONE-ARG)	(FUNCALL FUNCTION (CAR ARGS) PARAMS)	(CDR ARGS))
	  ((EQ TYPE :MULTI-ARG)	(FUNCALL FUNCTION ARGS PARAMS))
	  (T (FORMAT-ERROR "Undefined FORMAT command."))))

(DEFUN FORMAT-CRLF (IGNORE)
  (WHEN ATSIGN-FLAG (FUNCALL *FORMAT-OUTPUT* ':TYO #\CR)))

(DEFFORMAT D (:ONE-ARG) (ARG PARAMS)
  (FORMAT-CTL-INTEGER ARG PARAMS 10))

(DEFFORMAT O (:ONE-ARG) (ARG PARAMS)
  (FORMAT-CTL-INTEGER ARG PARAMS 8))

(DEFFORMAT B (:ONE-ARG) (ARG PARAMS)
  (FORMAT-CTL-INTEGER ARG PARAMS 2))

(DEFFORMAT X (:MULTI-ARG) (ARGS PARAMS)
  (COND (*COMMON-LISP-FORMAT*
	 (FORMAT-CTL-INTEGER (FIRST ARGS) PARAMS 16)
	 (REST1 ARGS))
	(T
	 (FORMAT-CTL-REPEAT-CHAR (OR (FIRST PARAMS) 1) (SI:PTTBL-SPACE READTABLE))
	 ARGS)))

(DEFUN FORMAT-CTL-INTEGER (ARG PARAMS &OPTIONAL (RADIX 10))
  (PRINT-INTEGER-FORMAT *FORMAT-OUTPUT* ARG RADIX
			(FIRST PARAMS) (SECOND PARAMS) (THIRD PARAMS)))

(DEFUN DEFAULT-PADCHAR (PADCHAR)
  (IF PADCHAR
      (CHARACTER PADCHAR)
      #\SPACE))

(DEFUN PRINT-INTEGER-FORMAT (*FORMAT-OUTPUT* NUMBER RADIX WIDTH PADCHAR COMMACHAR)
  (LET* ((BASE RADIX)
	 (CL:*PRINT-RADIX* NIL)			;si:print-fixnum respects this
	 (PLUS-P (AND ATSIGN-FLAG (NUMBERP NUMBER) (NOT (MINUSP NUMBER))))
	 (NDIGITS (AND (OR COLON-FLAG WIDTH)
		       (FIXP NUMBER)
		       (LOOP FOR X = (ABS NUMBER) THEN (// X BASE)
			     COUNT T
			     UNTIL (< X BASE)))))
    (SETQ PADCHAR (DEFAULT-PADCHAR PADCHAR))
    (SETQ COMMACHAR (IF (NULL COMMACHAR) #/, (CHARACTER COMMACHAR)))
    (DW:WITH-OUTPUT-AS-PRESENTATION (:STREAM *FORMAT-OUTPUT*
				     :OBJECT NUMBER :TYPE 'SYS:EXPRESSION)
      (WHEN WIDTH
	(FORMAT-CTL-JUSTIFY WIDTH
			    (+ (IF NDIGITS
				   (+ NDIGITS (IF (MINUSP NUMBER) 1 0))
				   (FLATC NUMBER))
			       (IF PLUS-P 1 0)
			       (IF (AND COLON-FLAG NDIGITS)
				   (// (1- NDIGITS) 3)	;Number of commas
				   0))
			    PADCHAR))
      (LET ((NUMBER NUMBER) (NDIGITS NDIGITS) (OP :TYO))
	(WHEN PLUS-P (FUNCALL *FORMAT-OUTPUT* OP #/+))
	(COND ((AND COLON-FLAG NDIGITS)
	       ;; Random hair with commas.
	       (WHEN (MINUSP NUMBER)
		 (FUNCALL *FORMAT-OUTPUT* OP #/-)
		 (SETQ NUMBER (- NUMBER)))
	       (LOOP FOR DIVISOR = (^ BASE (1- NDIGITS)) THEN (// DIVISOR BASE)
		     DO (FUNCALL *FORMAT-OUTPUT* OP (DIGIT-CHAR (// NUMBER DIVISOR) BASE))
		     UNTIL (= DIVISOR 1)
		     DO (SETQ NUMBER (\ NUMBER DIVISOR))
			(WHEN (ZEROP (\ (DECF NDIGITS) 3))
			  (FUNCALL *FORMAT-OUTPUT* OP COMMACHAR))))
	      ((CL:INTEGERP NUMBER) (SI:PRINT-INTEGER NUMBER RADIX *FORMAT-OUTPUT*))
	      ;; This is PRINC rather than PRIN1 so you can have a string instead of a number
	      (T (PRINC NUMBER *FORMAT-OUTPUT*)))))))

(DEFVAR *PRINT-INSIGNIFICANT-DIGITS* NIL)	; remove this when rational printing is done
 
(DEFUN FORMATTABLE-NON-COMPLEX (OBJECT)
  (TYPECASE OBJECT
    (:SINGLE-FLOAT
      ;; not an infinity or a NaN
      ( (LDB SYS:%%SINGLE-EXPONENT (SYS:%FIXNUM OBJECT)) SYS:%SINGLE-EXPONENT-MAX))
    (:DOUBLE-FLOAT
      ;; not an infinity or a NaN
      ( (LDB SYS:%%DOUBLE-EXPONENT (SYS:DOUBLE-HIGH OBJECT)) SYS:%DOUBLE-EXPONENT-MAX))
    (:COMPLEX NIL)
    (:NUMBER T)
    (OTHERWISE NIL)))

(DEFFORMAT F (:ONE-ARG) (ARG PARAMS)
  (LET ((STREAM *FORMAT-OUTPUT*))
    (WHEN (AND (TYPEP ARG :NON-COMPLEX-NUMBER) (NOT (FLOATP ARG)))
      (SETQ ARG (FLOAT ARG)))
    (IF (FORMATTABLE-NON-COMPLEX ARG)
	(DW:WITH-OUTPUT-AS-PRESENTATION (:STREAM STREAM :OBJECT ARG :TYPE 'SYS:EXPRESSION)
	  (IF *COMMON-LISP-FORMAT*
	      (LET ((WIDTH (FIRST PARAMS))
		    (POST-.-DIGITS (SECOND PARAMS))
		    (SCALE-FACTOR (OR (THIRD PARAMS) 0))
		    (OVERFLOW-CHAR (FOURTH PARAMS))
		    (PAD-CHAR (OR (FIFTH PARAMS) (SI:PTTBL-SPACE READTABLE))))
		(SYS:WITH-STACK-ARRAY (STRING 20 :TYPE 'ART-STRING :FILL-POINTER 0)
		  (MULTIPLE-VALUE-BIND (INTEGER BINARY-EXPONENT SIGN)
		      (SI:INTEGER-DECODE-FLOAT ARG)
		    (LET ((PRINT-SIGN (OR (MINUSP SIGN) ATSIGN-FLAG)))
		      (MULTIPLE-VALUE-BIND (IGNORE DECIMAL-EXPONENT N-DIGITS)
			  (IF POST-.-DIGITS
			      (SI:FIXED-WIDTH-DECIMAL-DIGITS INTEGER BINARY-EXPONENT
							     (- (+ SCALE-FACTOR POST-.-DIGITS))
							     T NIL STRING)
			      (IF WIDTH
				  (LET ((DIGITS (MAX (- WIDTH (IF PRINT-SIGN 2 1)) 1)))
				    (IF (< (ABS ARG) 1.0)
					(SI:FIXED-WIDTH-DECIMAL-DIGITS INTEGER BINARY-EXPONENT
								       (- DIGITS) T NIL STRING)
					(SI:FIXED-WIDTH-DECIMAL-DIGITS INTEGER BINARY-EXPONENT
								       DIGITS NIL NIL STRING)))
				  (SI:SHORT-DECIMAL-DIGITS INTEGER BINARY-EXPONENT STRING)))
			(PRINT-F-FORMAT STREAM INTEGER STRING DECIMAL-EXPONENT SIGN
					PRINT-SIGN SCALE-FACTOR WIDTH POST-.-DIGITS N-DIGITS
					OVERFLOW-CHAR PAD-CHAR))))))
	      (SI:PRINT-FLONUM ARG STREAM NIL NIL (FIRST PARAMS) NIL)))
	(PRINT-INTEGER-FORMAT STREAM ARG 10 (FIRST PARAMS) NIL NIL))))

(DEFUN PRINT-F-FORMAT (STREAM INTEGER STRING DECIMAL-EXPONENT SIGN PRINT-SIGN
		       SCALE-FACTOR WIDTH POST-.-DIGITS N-DIGITS OVERFLOW-CHAR
		       PAD-CHAR)
  (DECLARE (IGNORE INTEGER))			;in Rel 8, remove this arg, reshuffle args
  (LET* ((TYO :TYO)
	 (EXPONENT (IF (ZEROP N-DIGITS) 0
		       (+ DECIMAL-EXPONENT SCALE-FACTOR)))
	 (TOTAL-DIGITS (IF (ZEROP N-DIGITS)
			   (OR POST-.-DIGITS 0)
			   (MAX (IF ( EXPONENT 0)
				    (OR POST-.-DIGITS (- N-DIGITS EXPONENT))
				    (IF POST-.-DIGITS
					(+ EXPONENT POST-.-DIGITS)
					(MAX EXPONENT N-DIGITS)))
				1)))
	 (NON-BLANK-WIDTH (+ TOTAL-DIGITS (IF PRINT-SIGN 2 1))))
    (IF (AND OVERFLOW-CHAR WIDTH (> NON-BLANK-WIDTH WIDTH))
	(LOOP REPEAT WIDTH
	      DO (SEND STREAM TYO OVERFLOW-CHAR))
	(LET ((PRINT-LEADING-ZERO (AND ( EXPONENT 0)
				       (OR (NULL WIDTH)
					   (> WIDTH NON-BLANK-WIDTH)))))
	  (WHEN PRINT-LEADING-ZERO (INCF NON-BLANK-WIDTH))
	  (LET ((PRINT-TRAILING-ZERO (AND (NULL POST-.-DIGITS)
					  ( EXPONENT N-DIGITS)
					  (OR (NULL WIDTH)
					      (> WIDTH NON-BLANK-WIDTH)))))
	    (WHEN PRINT-TRAILING-ZERO (INCF NON-BLANK-WIDTH))
	    (WHEN WIDTH
	      (LOOP REPEAT (- WIDTH NON-BLANK-WIDTH)
		    DO (SEND STREAM TYO PAD-CHAR)))
	    (WHEN PRINT-SIGN
	      (SEND STREAM TYO (IF (MINUSP SIGN)
				   (SI:PTTBL-MINUS-SIGN READTABLE)
				   #/+)))
	    (WHEN PRINT-LEADING-ZERO
	      (SEND STREAM TYO #/0))
	    (SI:PRINT-DIGITS-WITH-DECIMAL-POINT
	      STRING N-DIGITS EXPONENT TOTAL-DIGITS STREAM)
	    (WHEN PRINT-TRAILING-ZERO
	      (SEND STREAM TYO #/0)))))))

(DEFFORMAT E (:ONE-ARG) (ARG PARAMS)
  (LET ((STREAM *FORMAT-OUTPUT*))
    (WHEN (AND (NUMBERP ARG) (TYPEP ARG :NON-COMPLEX-NUMBER) (NOT (FLOATP ARG)))
      (SETQ ARG (FLOAT ARG)))
    (IF (FORMATTABLE-NON-COMPLEX ARG)      
	(DW:WITH-OUTPUT-AS-PRESENTATION (:STREAM STREAM :OBJECT ARG :TYPE 'SYS:EXPRESSION)
	  (IF *COMMON-LISP-FORMAT*
	      (LET ((WIDTH (FIRST PARAMS))
		    (POST-.-DIGITS (SECOND PARAMS))
		    (EXPONENT-DIGITS (THIRD PARAMS))
		    (SCALE-FACTOR (OR (FOURTH PARAMS) 1))
		    (OVERFLOW-CHAR (FIFTH PARAMS))
		    (PAD-CHAR (OR (SIXTH PARAMS) (SI:PTTBL-SPACE READTABLE)))
		    (EXPONENT-CHAR (OR (SEVENTH PARAMS)
				       (SI:EXPONENT-MARK-CHARACTER ARG))))
  
		(MULTIPLE-VALUE-BIND (INTEGER BINARY-EXPONENT SIGN)
		    (SI:INTEGER-DECODE-FLOAT ARG)
		  (SYS:WITH-STACK-ARRAY (STRING 20 :TYPE 'ART-STRING :FILL-POINTER 0)
		    (PRINT-E-FORMAT STREAM STRING INTEGER BINARY-EXPONENT SIGN
				    (OR (MINUSP SIGN) ATSIGN-FLAG)
				    WIDTH POST-.-DIGITS EXPONENT-DIGITS SCALE-FACTOR
				    OVERFLOW-CHAR PAD-CHAR EXPONENT-CHAR))))
	      
	      (SI:PRINT-FLONUM ARG STREAM NIL NIL
			       (FIRST PARAMS) T)))
	(PRINT-INTEGER-FORMAT STREAM ARG 10 (FIRST PARAMS) NIL NIL))))

(DEFUN PRINT-E-FORMAT (STREAM STRING INTEGER BINARY-EXPONENT SIGN PRINT-SIGN WIDTH
		       POST-.-DIGITS EXPONENT-DIGITS SCALE-FACTOR OVERFLOW-CHAR
		       PAD-CHAR EXPONENT-CHAR)
  
  (LET ((PRINTED-DIGITS (AND POST-.-DIGITS
			     (+ POST-.-DIGITS
				(IF ( SCALE-FACTOR 0) SCALE-FACTOR 1)))))

    (WHEN PRINTED-DIGITS
      (COND (( PRINTED-DIGITS 0)
	     (SETQ PRINTED-DIGITS 1))
	    ((< PRINTED-DIGITS SCALE-FACTOR)
	     (SETQ PRINTED-DIGITS SCALE-FACTOR))))

    (MULTIPLE-VALUE-BIND (IGNORE DECIMAL-EXPONENT N-DIGITS)
	(IF PRINTED-DIGITS
	    (SI:FIXED-WIDTH-DECIMAL-DIGITS INTEGER BINARY-EXPONENT
					   PRINTED-DIGITS NIL
					   *PRINT-INSIGNIFICANT-DIGITS*
					   STRING)
	    (SI:SHORT-DECIMAL-DIGITS INTEGER BINARY-EXPONENT STRING))

      (LET* ((PRINTED-EXPONENT (IF (ZEROP N-DIGITS) 0
				   (- DECIMAL-EXPONENT SCALE-FACTOR)))
	     (ABS-PRINTED-EXPONENT (ABS PRINTED-EXPONENT))
	     (EXP-SIZE (COND ((< ABS-PRINTED-EXPONENT 10) 1)
			     ((< ABS-PRINTED-EXPONENT 100) 2)
			     (T 3)))
	     (PRINTED-EXPONENT-WIDTH (IF EXPONENT-DIGITS
					 (MAX EXPONENT-DIGITS EXP-SIZE)
					 EXP-SIZE)))

	(WHEN (NULL PRINTED-DIGITS)
	  (WHEN WIDTH
	    (LET ((DIGIT-SPACE (MAX (- WIDTH (IF PRINT-SIGN 4 3)
				       PRINTED-EXPONENT-WIDTH
				       (MAX (- SCALE-FACTOR N-DIGITS) 0)
				       (MAX (- SCALE-FACTOR) 0))
				    SCALE-FACTOR
				    1)))
	      ;; if it won't fit, trim it
	      (WHEN (< DIGIT-SPACE N-DIGITS)
		(SETF (FILL-POINTER STRING) 0)
		(CL:MULTIPLE-VALUE-SETQ (NIL DECIMAL-EXPONENT N-DIGITS)
		  (SI:FIXED-WIDTH-DECIMAL-DIGITS INTEGER BINARY-EXPONENT
						 DIGIT-SPACE NIL
						 *PRINT-INSIGNIFICANT-DIGITS*
						 STRING))
		;; now recompute, in case we rounded
		(SETQ PRINTED-EXPONENT (IF (ZEROP N-DIGITS) 0
					   (- DECIMAL-EXPONENT SCALE-FACTOR)))
		(SETQ ABS-PRINTED-EXPONENT (ABS PRINTED-EXPONENT))
		(SETQ EXP-SIZE (COND ((< ABS-PRINTED-EXPONENT 10) 1)
				     ((< ABS-PRINTED-EXPONENT 100) 2)
				     (T 3)))
		(SETQ PRINTED-EXPONENT-WIDTH (IF EXPONENT-DIGITS
						 (MAX EXPONENT-DIGITS EXP-SIZE)
						 EXP-SIZE)))))
	  ;; leave no trailing zeros
	  (SETQ PRINTED-DIGITS (MAX N-DIGITS 1)))

	(LET* ((TYO :TYO)
	       (TOTAL-DIGITS (IF ( SCALE-FACTOR 0)
				 (- PRINTED-DIGITS SCALE-FACTOR)
				 PRINTED-DIGITS))
	       (NON-BLANK-WIDTH (+ TOTAL-DIGITS
				   (IF PRINT-SIGN 4 3)	;".e+"
				   PRINTED-EXPONENT-WIDTH
				   (IF (NULL POST-.-DIGITS)
				       (MAX (- SCALE-FACTOR PRINTED-DIGITS) 0)
				       0)))
	       (PRINT-LEADING-ZERO (AND ( SCALE-FACTOR 0)
					(OR (NULL WIDTH)
					    (< NON-BLANK-WIDTH WIDTH)))))
	  (WHEN PRINT-LEADING-ZERO
	    (INCF NON-BLANK-WIDTH))

	  (COND ((AND OVERFLOW-CHAR
		      (OR (AND WIDTH (> NON-BLANK-WIDTH WIDTH))
			  (AND EXPONENT-DIGITS (> EXP-SIZE EXPONENT-DIGITS))
			  (AND POST-.-DIGITS (IF ( SCALE-FACTOR 0)
						 ( (- POST-.-DIGITS) SCALE-FACTOR)
						 ( SCALE-FACTOR
						    (+ POST-.-DIGITS 2))))))
		 (LOOP REPEAT (IF (AND WIDTH (> WIDTH 0))
				  WIDTH
				  10)
		       DO (SEND STREAM TYO OVERFLOW-CHAR)))
		(T
		 (WHEN (AND (NULL POST-.-DIGITS)
			    ( SCALE-FACTOR TOTAL-DIGITS)	;zero fraction
			    (OR (NULL WIDTH) (> WIDTH NON-BLANK-WIDTH)))
		   ;; print a trailing zero if it fits
		   (INCF NON-BLANK-WIDTH)
		   (INCF TOTAL-DIGITS))

		 (WHEN WIDTH
		   (LOOP REPEAT (- WIDTH NON-BLANK-WIDTH)
			 DO (SEND STREAM TYO PAD-CHAR)))
		 (SI:PRINT-FLOAT-DIGITS-E-FORMAT STREAM STRING SIGN PRINT-SIGN
						 PRINT-LEADING-ZERO N-DIGITS
						 TOTAL-DIGITS SCALE-FACTOR
						 EXPONENT-CHAR T
						 (- PRINTED-EXPONENT-WIDTH EXP-SIZE)
						 PRINTED-EXPONENT))))))))

(DEFFORMAT G (:MULTI-ARG) (ARGS PARAMS)
  (IF *COMMON-LISP-FORMAT*
      (LET ((STREAM *FORMAT-OUTPUT*)
	    (TYO :TYO)
	    (ARG (FIRST ARGS)))
	(WHEN (AND (NUMBERP ARG) (TYPEP ARG :NON-COMPLEX-NUMBER) (NOT (FLOATP ARG)))
	  (SETQ ARG (FLOAT ARG)))
	(IF (FORMATTABLE-NON-COMPLEX ARG)
	    (DW:WITH-OUTPUT-AS-PRESENTATION (:STREAM STREAM :OBJECT ARG :TYPE 'SYS:EXPRESSION)
	      (LET* ((WIDTH (FIRST PARAMS))
		     (SIGNIFICANT-DIGITS (SECOND PARAMS))
		     (EXPONENT-DIGITS (THIRD PARAMS))
		     (SCALE-FACTOR (OR (FOURTH PARAMS) 1))
		     (OVERFLOW-CHAR (FIFTH PARAMS))
		     (PAD-CHAR (OR (SIXTH PARAMS) (SI:PTTBL-SPACE READTABLE)))
		     (EXPONENT-CHAR (OR (SEVENTH PARAMS)
					(SI:EXPONENT-MARK-CHARACTER ARG))))
		(SYS:WITH-STACK-ARRAY (STRING 20 :TYPE 'ART-STRING :FILL-POINTER 0)
		  (MULTIPLE-VALUE-BIND (INTEGER BINARY-EXPONENT SIGN)
		      (CL:INTEGER-DECODE-FLOAT ARG)
		    (MULTIPLE-VALUE-BIND (IGNORE DECIMAL-EXPONENT N-DIGITS)
			(IF (ZEROP INTEGER)
			    (VALUES NIL 0 0)
			    (IF (NULL SIGNIFICANT-DIGITS)
				(SI:SHORT-DECIMAL-DIGITS INTEGER BINARY-EXPONENT STRING)
				(SI:FIXED-WIDTH-DECIMAL-DIGITS INTEGER BINARY-EXPONENT
							       SIGNIFICANT-DIGITS NIL
							       *PRINT-INSIGNIFICANT-DIGITS*
							       STRING)))
		      (LET* ((F-SIGNIFICANT-DIGITS (OR SIGNIFICANT-DIGITS
						       (MAX N-DIGITS
							    (MIN DECIMAL-EXPONENT 7))))
			     (PRINT-SIGN (OR (MINUSP SIGN) ATSIGN-FLAG))
			     (POST-.-DIGITS (- F-SIGNIFICANT-DIGITS DECIMAL-EXPONENT)))
			
			(IF ( 0 POST-.-DIGITS F-SIGNIFICANT-DIGITS)
			    (LET* ((EXP-FIELD-WIDTH (IF EXPONENT-DIGITS (+ EXPONENT-DIGITS 2)
							4))
				   (F-WIDTH (AND WIDTH (- WIDTH EXP-FIELD-WIDTH))))
			      (UNLESS (OR (> F-SIGNIFICANT-DIGITS 0) (ZEROP INTEGER))
				(FORMAT-ERROR "Significant digits should be greater than zero."))
			      (UNLESS ( EXP-FIELD-WIDTH 2)
				(FORMAT-ERROR "Exponent digits should be greater than zero."))
			      (PRINT-F-FORMAT STREAM INTEGER STRING DECIMAL-EXPONENT SIGN
					      PRINT-SIGN 0 F-WIDTH POST-.-DIGITS N-DIGITS
					      OVERFLOW-CHAR PAD-CHAR)
			      (LOOP REPEAT EXP-FIELD-WIDTH DO
				(SEND STREAM TYO #\SPACE)))
			    (SETF (FILL-POINTER STRING) 0)
			    (PRINT-E-FORMAT STREAM STRING INTEGER BINARY-EXPONENT
					    SIGN PRINT-SIGN
					    WIDTH SIGNIFICANT-DIGITS EXPONENT-DIGITS
					    SCALE-FACTOR
					    OVERFLOW-CHAR PAD-CHAR EXPONENT-CHAR))))))))
	    (PRINT-INTEGER-FORMAT STREAM ARG 10 (FIRST PARAMS) NIL NIL))
	(REST1 ARGS))
      (NTHCDR (OR (FIRST PARAMS) 1) FORMAT-ARGLIST)))

;This does support RDIG being 0.  That used to be complicated.
(DEFFORMAT $ (:ONE-ARG) (ARG PARAMS)
  (LET ((RDIG (OR (FIRST PARAMS) 2))		;This many digits after decimal point
	(LDIG (OR (SECOND PARAMS) 1))		;At least this many to left of decimal
	(FIELD (THIRD PARAMS))			;Right-justify in field this wide
	(PADCHAR (DEFAULT-PADCHAR (FOURTH PARAMS)))	;Padding with this
	(STREAM *FORMAT-OUTPUT*)
	(TYO :TYO))
    (COND ((OR (NOT (FORMATTABLE-NON-COMPLEX ARG)) (> (ABS ARG) 1E30))
	   (FORMAT-CTL-JUSTIFY FIELD (FLATC ARG) PADCHAR)
	   (PRINC ARG STREAM))
	  (T (OR (FLOATP ARG) (SETQ ARG (FLOAT ARG)))
	     (DW:WITH-OUTPUT-AS-PRESENTATION (:STREAM STREAM :OBJECT ARG :TYPE 'SYS:EXPRESSION)
	       (SYS:WITH-STACK-ARRAY (STRING (MAX (- RDIG) 20)
					     :TYPE 'ART-STRING :FILL-POINTER 0)
		 (MULTIPLE-VALUE-BIND (NIL EXPONENT SIGN N-DIGITS)
		     (SI:FIXED-WIDTH-DECIMAL-DIGITS-FROM-FLOAT ARG (- RDIG) T NIL STRING)
		   (LET ((WIDTH (+ (IF (OR ATSIGN-FLAG (MINUSP SIGN)) 2 1)
				   (MAX LDIG EXPONENT)
				   RDIG)))
		     (IF (NOT COLON-FLAG) (FORMAT-CTL-JUSTIFY FIELD WIDTH PADCHAR))
		     (COND ((MINUSP SIGN)
			    (FUNCALL STREAM TYO (SI:PTTBL-MINUS-SIGN READTABLE)))
			   (ATSIGN-FLAG (FUNCALL STREAM TYO #/+)))
		     (IF COLON-FLAG (FORMAT-CTL-JUSTIFY FIELD WIDTH PADCHAR))
		     (LOOP REPEAT (- LDIG (MAX EXPONENT 0))
			   DO (FUNCALL STREAM TYO #/0))
		     (SI:PRINT-DIGITS-WITH-DECIMAL-POINT STRING N-DIGITS EXPONENT
							 (+ (MAX EXPONENT 0) RDIG)
							 STREAM)))))))))

(DEFFORMAT R (:ONE-ARG) (ARG PARAMS)
  (COND ((CAR PARAMS) (FORMAT-CTL-INTEGER ARG (CDR PARAMS) (CAR PARAMS)))
	((AND ATSIGN-FLAG
	      (FIXP ARG)
	      (< ARG 4000.)
	      (> ARG 0))
	 (LET ((ROMAN-OLD COLON-FLAG))
	   (ROMAN-STEP ARG 0)))
	((OR ATSIGN-FLAG
	     (NOT (FIXP ARG)))
	 (LET ((BASE 10.) (CL:*PRINT-RADIX* NIL))
	   (PRIN1 ARG *FORMAT-OUTPUT*)))
	((NOT COLON-FLAG)
	 (ENGLISH-PRINT ARG *FORMAT-OUTPUT*))
	(T (ENGLISH-ORDINAL-PRINT ARG *FORMAT-OUTPUT*))))

(DEFFORMAT A (:ONE-ARG) (ARG PARAMS)
  (FORMAT-CTL-ASCII ARG PARAMS))

(DEFFORMAT S (:ONE-ARG) (ARG PARAMS)
  (FORMAT-CTL-ASCII ARG PARAMS T))

(DEFUN FORMAT-CTL-ASCII (ARG PARAMS &OPTIONAL PRIN1P)
  (FLET ((SIMPLE-ASCII (ARG STREAM)
	   (COND ((AND COLON-FLAG (NULL ARG))
		  (SEND STREAM :STRING-OUT "()"))
		 (PRIN1P
		  (PRIN1 ARG STREAM))
		 ((STRINGP ARG)
		  (SEND STREAM :STRING-OUT ARG))
		 (T
		  (PRINC ARG STREAM)))))
    (WHEN (NOT ATSIGN-FLAG)			;~@5nA right justifies
      (SIMPLE-ASCII ARG *FORMAT-OUTPUT*))
    (WHEN PARAMS
      (DESTRUCTURING-BIND (&OPTIONAL EDGE PERIOD MIN PADCHAR) PARAMS
	(SETF PADCHAR (DEFAULT-PADCHAR PADCHAR))
	(LET ((WIDTH (CLI::FLAT-OPERATION #'SIMPLE-ASCII ARG)))
	  (WHEN (NOT (NULL MIN))
	    (FORMAT-CTL-REPEAT-CHAR MIN PADCHAR)
	    (INCF WIDTH MIN))
	  (WHEN (AND EDGE (> EDGE WIDTH))
	    (FORMAT-CTL-REPEAT-CHAR
	      (IF PERIOD
		  (* PERIOD (CEILING (- EDGE WIDTH) PERIOD))
		  (- EDGE WIDTH))
	      PADCHAR)))))
    (WHEN ATSIGN-FLAG
      (SIMPLE-ASCII ARG *FORMAT-OUTPUT*))))

(DEFFORMAT T (:NO-ARG) (PARAMS &AUX (DEST (OR (FIRST PARAMS) 1))
			       (EXTRA (OR (SECOND PARAMS) 1))
			       (STREAM *FORMAT-OUTPUT*)
			       (OPS (FUNCALL STREAM ':WHICH-OPERATIONS))
			       INCR-OK)
  (COND ((AND ATSIGN-FLAG (NOT COLON-FLAG) (NOT (SECOND PARAMS)))
	 (FORMAT-CTL-REPEAT-CHAR DEST #\SP))
	((OR (SETQ INCR-OK (MEMQ ':INCREMENT-CURSORPOS OPS))
	     (MEMQ ':SET-CURSORPOS OPS))
	 (LET ((FLAVOR (IF COLON-FLAG ':PIXEL ':CHARACTER)))
	   (MULTIPLE-VALUE-BIND (X Y) (FUNCALL STREAM ':READ-CURSORPOS FLAVOR)
	     (LET ((NEW-X (COND (ATSIGN-FLAG	;Next multiple of EXTRA  X+DEST
				 (IF (ZEROP EXTRA) (+ X DEST)
				     (* (// (+ X DEST EXTRA -1) EXTRA) EXTRA)))
				((< X DEST) DEST)
				((ZEROP EXTRA) X)
				;; Next multiple of DEST + k*EXTRA so it is > X
				(T (+ DEST (* (1+ (// (- X DEST) EXTRA)) EXTRA))))))
	       (COND (INCR-OK
		      ;; Use :INCREMENT-CURSORPOS preferentially
		      ;; because it will do a **MORE** if we need one.
		      (FUNCALL STREAM ':INCREMENT-CURSORPOS
			       (- NEW-X X) 0 FLAVOR))
		     (T
		      (FUNCALL STREAM ':SET-CURSORPOS
			       NEW-X Y FLAVOR)))))))
	(ATSIGN-FLAG (FORMAT-CTL-REPEAT-CHAR DEST #\SP))
	(T (FUNCALL STREAM ':STRING-OUT "   "))))

;Colon flag means to spell out control bits, mouse clicks, and format effectors
;Atsign by itself means print readably, using #\ or #/
;Atsign plus colon means spell out and document hard-to-type characters
(DEFFORMAT C (:ONE-ARG) (ARG IGNORE)
  (FORMAT-CTL-CHARACTER ARG))

(DEFUN FORMAT-CTL-CHARACTER (ARG)
  (FORMAT-CHARACTER *FORMAT-OUTPUT* ARG COLON-FLAG (OR COLON-FLAG ATSIGN-FLAG)
		    (AND ATSIGN-FLAG COLON-FLAG) (AND ATSIGN-FLAG (NOT COLON-FLAG))))

(DEFUN FORMAT-CHARACTER-BITS-WIDTH (BITS LONG SHIFT)
  (DECLARE (VALUES LENGTH NEEDS-QUOTING))
  (COND ((ZEROP BITS) (VALUES 0 NIL))
	((NOT LONG)
	 (VALUES (+ (NTH BITS '(0 2 2 4 2 4 4 6 2 4 4 6 4 6 6 8))
		    (IF SHIFT 3 0))
		 'T))
	(T (VALUES (+ (NTH BITS '(0 8 5 13 6 14 11 19 6 14 11 19 12 20 17 25))
		      (IF SHIFT 6 0))
	   'T))))

(DEFUN FORMAT-CHARACTER-BITS (STREAM BITS LONG SHIFT)
  ;; Bits are printed in the order they appear in the lower left corner of the
  ;; keyboard, with the single exception that "control-meta" is preferred over
  ;; "meta-control" by weight of tradition.
  (COND ((ZEROP BITS) NIL)
	((NOT LONG)
	 (SEND STREAM ':STRING-OUT
	       (NTH (LOGAND BITS #o17)
		    '("" "c-" "m-" "c-m-"
		      "s-" "s-c-" "s-m-" "s-m-c-"
		      "h-" "h-c-" "h-m-" "h-m-c-"
		      "h-s-" "h-s-c-" "h-s-m-" "h-s-m-c-")))
	 ;; Shift is abbreviated as sh, to avoid confusion with super
	 (WHEN SHIFT
	   (SEND STREAM ':STRING-OUT "sh-"))
	 'T)
	(T (COND ((= BITS 3)
		  (SEND STREAM ':STRING-OUT "Control-Meta-"))
		 (T
		  (LET ((CH (CODE-CHAR 0 (LOGAND BITS #o17))))
		    (IF (CHAR-BIT CH :HYPER)
			(SEND STREAM ':STRING-OUT "Hyper-"))
		    (IF (CHAR-BIT CH :SUPER)
			(SEND STREAM ':STRING-OUT "Super-"))
		    (IF (CHAR-BIT CH :META)
			(SEND STREAM ':STRING-OUT "Meta-"))
		    (IF (CHAR-BIT CH :CONTROL)
			(SEND STREAM ':STRING-OUT "Control-")))))
	   (WHEN SHIFT
	     (SEND STREAM ':STRING-OUT "Shift-"))
	   'T)))

(DEFUN FORMAT-CHARACTER-STYLE-WIDTH (STYLE LONG FORCE)
  (DECLARE (VALUES LENGTH NEEDS-QUOTING))
  ; This is a hack for now.
  (IF FORCE
      (LET ((STYLE-DESCRIPTOR (SI:UNPARSE-CHARACTER-STYLE STYLE)))
	(LOOP WITH NEEDS-QUOTING = NIL
	      WITH LENGTH = 0
	      FOR FIELD IN STYLE-DESCRIPTOR
	      DO (WHEN (OR FIELD LONG)
						;include the dash
		   (INCF LENGTH (1+ (STRING-LENGTH (STRING FIELD))))
		   (SETQ NEEDS-QUOTING 'T))
	      FINALLY (RETURN (VALUES LENGTH NEEDS-QUOTING))))
      (VALUES 0 NIL)))

(DEFUN FORMAT-CHARACTER-STYLE (STREAM STYLE LONG FORCE)
  (DECLARE (VALUES NEEDS-QUOTING))
  ; This is a hack for now.
  (IF FORCE
      (LET ((STYLE-DESCRIPTOR (SI:UNPARSE-CHARACTER-STYLE STYLE)))
	(LOOP WITH NEEDS-QUOTING = NIL
	      FOR FIELD IN STYLE-DESCRIPTOR
	      DO (WHEN (OR FIELD LONG)
		   (SEND STREAM :STRING-OUT (STRING FIELD))
		   (SEND STREAM :TYO #\-)
		   (SETQ NEEDS-QUOTING 'T))
		 FINALLY (RETURN NEEDS-QUOTING)))
      NIL))


;;; this knows about deep internal details of the reader, so really belongs in 
;;; sys:io;read.lisp.
(DEFSUBST NEEDS-SLASH (CHAR)
  ;; Slashify this character if needed, since it doesn't immediately
  ;; follow a slash.  "If needed" refers to what happens when
  ;; XR-SHARP-SLASH reads what we are now printing.
  (LET* ((READTABLE-FSM (SI:RDTBL-FSM READTABLE))
	 (NUM (CHAR-CODE CHAR))
	 (STATE (AREF READTABLE-FSM
		      (AREF READTABLE-FSM
			    (AREF READTABLE-FSM
				  (SI:RDTBL-STARTING-STATE READTABLE)
				  (SI:RDTBL-SLASH-CODE READTABLE))
			    (SI:RDTBL-CODE READTABLE (CHAR-CODE #/c)))
		      (IF (< NUM SI:RDTBL-ARRAY-SIZE)
			  (SI:RDTBL-CODE READTABLE NUM)
			  (SI:OUT-OF-BOUNDS-RDTBL-CODE READTABLE NUM)))))
    (AND (LISTP STATE)
	 (MEMQ (CAR STATE) '(SI:UNTYI-FUNCTION SI:UNTYI-QUOTE SI:MULTIPLE-ESCAPE)))))

(DEFUN FORMAT-CHARACTER-NAME-WIDTH (CH LONG-NAME READABLE NEEDS-QUOTING)
  (LET* ((CHAR (CODE-CHAR (CHAR-CODE CH)))
	 (CHNAME (AND LONG-NAME (CL:CHAR-NAME CHAR))))
    (IF CHNAME
	(STRING-LENGTH CHNAME)
	(IF (AND READABLE NEEDS-QUOTING (NEEDS-SLASH CHAR)) 2 1))))

(DEFUN FORMAT-CHARACTER-NAME (STREAM CH LONG-NAME READABLE NEEDS-QUOTING)
  (LET* ((CHAR (CODE-CHAR (CHAR-CODE CH)))
	 (CHNAME (AND LONG-NAME (CL:CHAR-NAME CHAR))))
    (COND (CHNAME
	   (SEND STREAM ':STRING-OUT CHNAME))
	  (T
	   (WHEN (AND READABLE NEEDS-QUOTING (NEEDS-SLASH CHAR))
		 (SEND STREAM :TYO (SI:PTTBL-SLASH READTABLE)))
	   (IF NEEDS-QUOTING			; here is where we would test if the stream
						; can retain style information.
	       (SEND STREAM ':TYO CHAR)		; stripped character
	       (SEND STREAM ':TYO CH))))	; keep the style info, (since quoted)
    CHNAME))

(DEFUN FORMAT-CHARACTER-WIDTH (CH LONG-BITS LONG-NAME SYMBOL-HELP READABLE)
  (IGNORE SYMBOL-HELP)
  (IF (MOUSE-CHAR-P CH)
      0
    (SETQ CH (CHARACTER CH))
    (LET* ((BITS (CHAR-BITS CH))
	   (CHAR (CODE-CHAR (CHAR-CODE CH)))
	   (NEEDS-SHIFT (LOWER-CASE-P CHAR)))

      ;; If control bits are present, print them
      (MULTIPLE-VALUE-BIND (LENGTH NEEDS-QUOTING)
	    (FORMAT-CHARACTER-BITS-WIDTH BITS LONG-BITS NEEDS-SHIFT)
	(+
	  LENGTH
	  ;; If printing readably, print #\
	  (IF READABLE 2 0)
	  
	  #||
	  (SETQ NEEDS-QUOTING
		(OR NEEDS-QUOTING
		    (FORMAT-CHARACTER-STYLE-WIDTH STYLE LONG-STYLE)))
	  ||#
	  (FORMAT-CHARACTER-NAME-WIDTH CH LONG-NAME READABLE NEEDS-QUOTING))))))

(DEFUN FORMAT-CHARACTER (STREAM CH LONG-BITS LONG-NAME SYMBOL-HELP READABLE)
  (IF (MOUSE-CHAR-P CH)
      (FORMAT-MOUSE-CHARACTER STREAM CH LONG-BITS LONG-NAME SYMBOL-HELP READABLE)
    (SETQ CH (CHARACTER CH))
    (LET* ((BITS (CHAR-BITS CH))
	   (CHAR (CODE-CHAR (CHAR-CODE CH)))
	   (NEEDS-SHIFT (LOWER-CASE-P CHAR))
	   CHNAME NEEDS-QUOTING)

      ;; If printing readably, print appropriate prefix
      (WHEN READABLE
	(SEND STREAM :TYO #\#)
	(SEND STREAM :TYO (SI:PTTBL-SLASH READTABLE)))

      ;; If control bits are present, print them
      (SETQ NEEDS-QUOTING (FORMAT-CHARACTER-BITS STREAM BITS LONG-BITS NEEDS-SHIFT))

      ; Hack lowercase shift ridiculousness.
      (WHEN (AND NEEDS-QUOTING NEEDS-SHIFT)
	(SETF (CHAR-CODE CH) (CHAR-CODE (CHAR-UPCASE CHAR))))

      ;; Eventually we are going to have to print out style information in the same way we
      ;; print out control bits, i.e. fix-italic-large.  However, if it is a single character,
      ;; and the stream we are printing to can retain font information (streams will have to
      ;; answer this question) then we can print out a stylized character. -- Greenwald
      #||
      (SETQ NEEDS-QUOTING
	    (OR NEEDS-QUOTING
		(FORMAT-CHARACTER-STYLE STREAM STYLE LONG-STYLE)))
      ||#

      ;; Print main part of character as a mouse or keyboard character
      (SETQ CHNAME (FORMAT-CHARACTER-NAME STREAM CH LONG-NAME READABLE NEEDS-QUOTING))

      ;; Print detailed explanation.
      (WHEN (AND SYMBOL-HELP
		 (NOT READABLE)
		 (OR CHNAME
		     (< (CHAR-CODE CHAR) #O040)))
	(FORMAT-PRINT-TOP-CHARACTER CHAR STREAM))
      )))


;;; The same thing all over again for mouse "characters".
(DEFUN FORMAT-MOUSE-CHARACTER (STREAM CH LONG-BITS LONG-NAME IGNORE READABLE)
  (WHEN READABLE
    (SEND STREAM :STRING-OUT "#\"))
  (LET* ((BITS (CHAR-MOUSE-BITS CH))
	 (BUTTON (CHAR-MOUSE-BUTTON CH)))
    ;; If bucky bits are present, print them
    (FORMAT-CHARACTER-BITS STREAM BITS LONG-BITS (BIT-TEST 1_4 BITS))
    
    ;; Print main part of character as a mouse character
    (SEND STREAM :STRING-OUT "Mouse-")
    (IF LONG-NAME
	(SEND STREAM :STRING-OUT (NTH BUTTON '("Left" "Middle" "Right")))
	(SEND STREAM :TYO (NTH BUTTON '(#\L #\M #\R))))))

(DEFUN FORMAT-PRINT-TOP-CHARACTER (CHAR STREAM &OPTIONAL (PARENTHESES T))
  (FLET ((PRINT-IT (CHNAME NAME)
	   (WHEN (AND CHNAME (CHAR CHNAME CHAR))
	     (WHEN PARENTHESES (SEND STREAM ':STRING-OUT " ("))
	     (SEND STREAM ':STRING-OUT NAME)
	     (FORMAT-CHARACTER STREAM CHNAME NIL T NIL NIL)
	     (WHEN PARENTHESES (SEND STREAM ':TYO #/))))))
    (DOTIMES (I 128)
      (COND ((= (CHAR-CODE CHAR) (AREF SI:KBD-NEW-TABLE 2 I))
	     (RETURN (PRINT-IT (CODE-CHAR (AREF SI:KBD-NEW-TABLE 0 I)) "Symbol-")))
	    ((= (CHAR-CODE CHAR) (AREF SI:KBD-NEW-TABLE 3 I))
	     (RETURN (LET ((SH-CODE (AREF SI:KBD-NEW-TABLE 1 I)))
		       (PRINT-IT (CODE-CHAR SH-CODE)
				 (IF (= (AREF SI:KBD-NEW-TABLE 0 I) SH-CODE)
				     ;"shifted" is explicit only for letters
				     "Symbol-shift-"
				     ;for other chars, it is implicit in name
				     "Symbol-")))))))))

(DEFFORMAT P (:MULTI-ARG) (ARGS IGNORE)
    (AND COLON-FLAG (SETQ ARGS (FORMAT-CTL-IGNORE ARGS NIL)))	;crock: COLON-FLAG is set
    (IF ATSIGN-FLAG (IF (EQUAL (CAR ARGS) 1) (FUNCALL *FORMAT-OUTPUT* ':TYO #/y)
			(FUNCALL *FORMAT-OUTPUT* ':STRING-OUT "ies"))
	(OR (EQUAL (CAR ARGS) 1) (FUNCALL *FORMAT-OUTPUT* ':TYO #/s)))
    (CDR ARGS))

(DEFFORMAT * (:MULTI-ARG) (ARGS PARAMS)
  (IF ATSIGN-FLAG
      (NTHCDR (OR (FIRST PARAMS) 0) FORMAT-ARGLIST)
      (FORMAT-CTL-IGNORE ARGS PARAMS)))

(DEFUN FORMAT-CTL-IGNORE (ARGS PARAMS &AUX (COUNT (OR (CAR PARAMS) 1)))
  (COND (COLON-FLAG
	 (DO ((A FORMAT-ARGLIST (CDR A))
	      (B (NTHCDR COUNT FORMAT-ARGLIST) (CDR B)))
	     ((NULL A) (FORMAT-ERROR "Can't back up properly for a ~~:*"))
	   (AND (EQ B ARGS) (RETURN A))))
	(T (NTHCDR COUNT ARGS))))

(DEFFORMAT % (:NO-ARG) (PARAMS)
  (LET ((STREAM *FORMAT-OUTPUT*) (TYO :TYO))
    (DOTIMES (I (OR (CAR PARAMS) 1))
      (DECLARE (IGNORE I))
      (SEND STREAM TYO #\CR))))

(DEFFORMAT & (:NO-ARG) (PARAMS)
  (LET ((N (OR (CAR PARAMS) 1))
	(STREAM *FORMAT-OUTPUT*))
    (WHEN (PLUSP N)
      (FUNCALL STREAM :FRESH-LINE)
      (LOOP REPEAT (1- N) DO
	(FUNCALL STREAM :TYO #\CR)))))

(DEFFORMAT ^ (:MULTI-ARG) (ARGS PARAMS)
  (AND (IF (CAR PARAMS)
	   (IF (CADR PARAMS)
	       (IF (CADDR PARAMS)
		   (AND (NOT (> (CAR PARAMS) (CADR PARAMS)))
			(NOT (> (CADDR PARAMS) (CADR PARAMS))))
		   (= (CAR PARAMS) (CADR PARAMS)))
	       (ZEROP (CAR PARAMS)))
	   (NULL (IF COLON-FLAG LOOP-ARGLIST ARGS)))
       (THROW (IF COLON-FLAG 'FORMAT-/:^-POINT 'FORMAT-^-POINT) NIL))
  ARGS)

(DEFFORMAT ~ (:NO-ARG) (PARAMS)
  (FORMAT-CTL-REPEAT-CHAR (OR (CAR PARAMS) 1) #/~))

(DEFUN FORMAT-CTL-REPEAT-CHAR (COUNT CHAR)
  (LET ((STREAM *FORMAT-OUTPUT*) (TYO :TYO))
    (DOTIMES (I COUNT)
      (DECLARE (IGNORE I))
      (FUNCALL STREAM TYO CHAR))))

(DEFFORMAT /| (:NO-ARG) (PARAMS)
  (IF (AND COLON-FLAG (OPERATION-HANDLED-P *FORMAT-OUTPUT* :CLEAR-WINDOW))
      (SEND *FORMAT-OUTPUT* :CLEAR-WINDOW)
      (FORMAT-CTL-REPEAT-CHAR (OR (CAR PARAMS) 1) #\FORM)))

(DEFFORMAT  (:ONE-ARG) (ARG IGNORE)
  (SETQ ARG
	(IF (NOT (CHARACTERP ARG))
	    (STRING ARG)
	    (LET ((BITS (CHAR-BITS ARG))
		  (CHAR (CODE-CHAR (CHAR-CODE ARG))))
	      (SETQ BITS
		    (NTH BITS '(NIL "c-" "m-" "c-m-"
				    "s-" "s-c-" "s-m-" "s-m-c-"
				    "h-" "h-c-" "h-m-" "h-m-c-"
				    "h-s-" "h-s-c-" "h-s-m-" "h-s-m-c-")))
	      (IF BITS (SEND *FORMAT-OUTPUT* :STRING-OUT BITS))
	      (OR (CL:CHAR-NAME CHAR)
		  (AND (GRAPHIC-CHAR-P CHAR) (STRING CHAR))
		  (FORMAT NIL "~O" (CHAR-CODE CHAR))))))
  (COND ((OPERATION-HANDLED-P *FORMAT-OUTPUT* :DISPLAY-LOZENGED-STRING)
	 (SEND *FORMAT-OUTPUT* :DISPLAY-LOZENGED-STRING ARG))
	(T
	 (SEND *FORMAT-OUTPUT* :TYO #/<)
	 (SEND *FORMAT-OUTPUT* :STRING-OUT ARG)
	 (SEND *FORMAT-OUTPUT* :TYO #/>))))

;; This is really officially obsolete.  In case there are any users out there,
;; such users will be sending output to standard-output (old-style), so we have
;; to bind it.
(DEFFORMAT Q (:ONE-ARG) (ARG PARAMS)
  (LET ((STANDARD-OUTPUT *FORMAT-OUTPUT*))
    (APPLY ARG PARAMS)))

;; In ANSI CL, users can escape with ~/function/.

(DEFVAR *FORMAT-FUNCTION-LOOKUP-IS-SYNTAX-RELATIVE*
	NIL)  ;KMP thinks there is a 51% chance that this is the correct setting.

(DEFFORMAT // (:ONE-ARG) (ARG PARAMS)
  (DECLARE (SPECIAL CTL-STRING CTL-INDEX ATSIGN-FLAG COLON-FLAG *FORMAT-OUTPUT*))
  (LET ((SPEC-BEGIN CTL-INDEX)
	(SPEC-END (STRING-SEARCH-CHAR #\/ CTL-STRING CTL-INDEX)))
    (WHEN (NOT SPEC-END)
      (FORMAT-ERROR "Missing closing // in ~~// directive"))
    (LET* ((SPEC (STRING-UPCASE (SUBSTRING CTL-STRING SPEC-BEGIN SPEC-END)))
	   (PKG-IDX (STRING-SEARCH-CHAR #\: SPEC))
	   (PACKAGE-NAME (IF PKG-IDX (SUBSTRING SPEC 0 PKG-IDX) "CL-USER"))
	   PACKAGE
	   (FUNCTION-NAME
	     (IF (NOT PKG-IDX)
		 SPEC
		 (SUBSTRING SPEC (+ PKG-IDX 
				    (IF (CHAR-EQUAL (AREF SPEC (1+ PKG-IDX)) #\:) 2 1)))))
	   (SYNTAX (IF *FORMAT-FUNCTION-LOOKUP-IS-SYNTAX-RELATIVE*
		       (SI:CURRENT-LISP-SYNTAX)
		       :ANSI-COMMON-LISP)))
      (CONDITION-CASE (E)
	   (SETQ PACKAGE (SYS:FIND-PACKAGE-FOR-SYNTAX PACKAGE-NAME SYNTAX))
	 (SYS:PACKAGE-NOT-FOUND
	   (FORMAT-ERROR "The ~A package ~A does not exist." SYNTAX PACKAGE-NAME)))
      (MULTIPLE-VALUE-BIND (FUN-SYMBOL STATUS)
	  (FUTURE-COMMON-LISP:FIND-SYMBOL FUNCTION-NAME PACKAGE)
	(IF (AND STATUS (FBOUNDP FUN-SYMBOL))
	    (CL:APPLY (CL:SYMBOL-FUNCTION FUN-SYMBOL)
		      *FORMAT-OUTPUT* ARG
		      (IF COLON-FLAG T NIL) (IF ATSIGN-FLAG T NIL)
		      PARAMS)
	    (FORMAT-ERROR "The function ~A is undefined~:[; no such symbol exists~;~]."
			  (FORMAT NIL "~A:~A" PACKAGE FUNCTION-NAME)
			  STATUS))))
    ;; Indicate that we've processed the directive.
    (SETQ CTL-INDEX (1+ SPEC-END))))



;; Several commands have a SIZE long object which they must print
;; in a WIDTH wide field.  If WIDTH is specified and is greater than
;; the SIZE of the thing to be printed, this put out the right
;; number of  CHARs to fill the field.  You can call this before
;; or after printing the thing, to get leading or trailing padding.
(DEFUN FORMAT-CTL-JUSTIFY (WIDTH SIZE &OPTIONAL (CHAR #\SP))
    (AND WIDTH (> WIDTH SIZE) (FORMAT-CTL-REPEAT-CHAR (- WIDTH SIZE) CHAR)))

(DEFUN MAKE-LIST-ARRAY (LIST &AUX ARRAY)
  (SETQ ARRAY (MAKE-ARRAY (LENGTH LIST)))
  (LOOP FOR I FROM 0
	FOR X IN LIST
	DO (ASET X ARRAY I))
  ARRAY)

(DEFCONST ENGLISH-SMALL
	  (MAKE-LIST-ARRAY '("one" "two" "three" "four" "five" "six"
			     "seven" "eight" "nine" "ten" "eleven" "twelve"
			     "thirteen" "fourteen" "fifteen" "sixteen"
			     "seventeen" "eighteen" "nineteen")))

(DEFCONST ENGLISH-ORDINAL-SMALL
	  (MAKE-LIST-ARRAY '("first" "second" "third" "fourth" "fifth"
			     "sixth" "seventh" "eighth" "ninth"
			     "tenth" "eleventh" "twelfth" "thirteenth"
			     "fourteenth" "fifteenth" "sixteenth"
			     "seventeenth" "eighteenth" "nineteenth")))

(DEFCONST ENGLISH-MEDIUM
	  (MAKE-LIST-ARRAY '("twenty" "thirty" "forty" "fifty" "sixty" "seventy"
			     "eighty" "ninety")))

(DEFCONST ENGLISH-ORDINAL-MEDIUM
	  (MAKE-LIST-ARRAY '("twentieth" "thirtieth" "fortieth"
			     "fiftieth" "sixtieth" "seventieth"
			     "eightieth" "ninetieth")))

(DEFCONST ENGLISH-LARGE
	  (MAKE-LIST-ARRAY '("" "thousand" "million" "billion" "trillion"
			     "quadrillion" "quintillion" "sextillion"
			     "septillion" "octillion" "nonillion" "decillion"
			     "undecillion" "duodecillion")))

(DEFCONST ENGLISH-ORDINAL-LARGE
	  (MAKE-LIST-ARRAY '("" "thousandth" "millionth" "billionth"
			     "trillionth" "quadrillionth" "quintillionth"
			     "sextillionth" "septillionth" "octillionth" "nonillionth"
			     "decillionth" "undecillionth" "duodecillionth")))

(DEFCONST ENGLISH-100 "hundred")

(DEFCONST ENGLISH-ORDINAL-100 "hundredth")

;;; Returns T if it printed anything, else NIL.
(DEFUN ENGLISH-PRINT-THOUSAND (N STREAM)
  (LET ((FLAG NIL)
	(N (\ N 100.))
	(H (// N 100.)))
    (COND ((> H 0)
	   (SETQ FLAG T)
	   (FUNCALL STREAM ':STRING-OUT (AREF ENGLISH-SMALL (1- H)))
	   (FUNCALL STREAM ':TYO #\SP)
	   (FUNCALL STREAM ':STRING-OUT ENGLISH-100)
	   (AND (> N 0) (FUNCALL STREAM ':TYO #\SP))))
    (COND ((= N 0))
	  ((< N 20.)
	   (SETQ FLAG T)
	   (FUNCALL STREAM ':STRING-OUT (AREF ENGLISH-SMALL (1- N))))
	  (T
	   (SETQ FLAG T)
	   (FUNCALL STREAM ':STRING-OUT (AREF ENGLISH-MEDIUM (- (// N 10.) 2)))
	   (COND ((ZEROP (SETQ H (\ N 10.))))
		 (T
		  (FUNCALL STREAM ':TYO #/-)
		  (FUNCALL STREAM ':STRING-OUT (AREF ENGLISH-SMALL (1- H)))))))
    FLAG))

;;; Returns T if it printed anything, else NIL.
(DEFUN ENGLISH-PRINT (N &OPTIONAL (STREAM *FORMAT-OUTPUT*) (TRIAD 0))
  (COND ((ZEROP N)
	 (COND ((ZEROP TRIAD)
		(FUNCALL STREAM ':STRING-OUT "zero")
		T)
	       (T NIL)))
	((< N 0)
	 (FUNCALL STREAM ':STRING-OUT "minus")
	 (FUNCALL STREAM ':TYO #\SP)
	 (ENGLISH-PRINT (MINUS N) STREAM)
	 T)
	(T
	 (LET ((FLAG (ENGLISH-PRINT (// N 1000.) STREAM (1+ TRIAD))))
	   (LET ((THIS-TRIPLET (\ N 1000.)))
	     (COND ((NOT (ZEROP THIS-TRIPLET))
		    (IF FLAG (FUNCALL STREAM ':TYO #\SP))
		    (IF (EQ FLAG 'EXPT) (FUNCALL STREAM ':STRING-OUT "plus "))
		    (ENGLISH-PRINT-THOUSAND THIS-TRIPLET STREAM)
		    (COND ((ZEROP TRIAD) T)
			  ((> TRIAD 13.)
			   (FUNCALL STREAM ':STRING-OUT " times ten to the ")
			   (ENGLISH-ORDINAL-PRINT (* 3 TRIAD))
			   (FUNCALL STREAM ':STRING-OUT " power")
			   'EXPT)
			  (T
			   (FUNCALL STREAM ':TYO #\SP)
			   (FUNCALL STREAM ':STRING-OUT (AREF ENGLISH-LARGE TRIAD))
			   T)))
		   (T FLAG)))))))

(DEFUN ENGLISH-ORDINAL-PRINT (N &OPTIONAL (STREAM *FORMAT-OUTPUT*))
       (COND ((ZEROP N)
	      (FUNCALL STREAM ':STRING-OUT "zeroth"))
	     (T (DO ((I (IF (= (\ (// N 10.) 10.) 0) 10. 100.)			    
			    (* I 10.))
		     (TEM))
		    (( (SETQ TEM (\ N I)) 0)
		     (COND ((NOT (ZEROP (- N TEM)))
			    (ENGLISH-PRINT (- N TEM) STREAM)
			    (FUNCALL STREAM ':TYO  #\SP)))
		     (LET ((ENGLISH-SMALL (IF (AND (= (\ TEM 10.) 0)  ( TEM 10.))
					      ENGLISH-SMALL
					      ENGLISH-ORDINAL-SMALL))
			   (ENGLISH-MEDIUM (IF (= (\ TEM 10.) 0)
					       ENGLISH-ORDINAL-MEDIUM
					       ENGLISH-MEDIUM))
			   (ENGLISH-100 ENGLISH-ORDINAL-100)
			   (ENGLISH-LARGE ENGLISH-ORDINAL-LARGE))
		       (ENGLISH-PRINT TEM STREAM)))))))

(DEFUN ROMAN-STEP (X N)
  (LET ((STREAM *FORMAT-OUTPUT*) (TYO :TYO))
    (MACROLET ((ROMAN-CHAR (I X)
			   `(SEND STREAM TYO (NTH (+ ,I (* ,X 2))
						  '(#/I #/V #/X #/L #/C #/D #/M)))))
      (COND ((> X 9.)
	     (ROMAN-STEP (// X 10.) (1+ N))
	     (SETQ X (\ X 10.))))
      (COND ((AND (= X 9) (NOT ROMAN-OLD))
	     (ROMAN-CHAR 0 N)
	     (ROMAN-CHAR 0 (1+ N)))
	    ((= X 5)
	     (ROMAN-CHAR 1 N))
	    ((AND (= X 4) (NOT ROMAN-OLD))
	     (ROMAN-CHAR 0 N)
	     (ROMAN-CHAR 1 N))
	    (T (COND ((> X 5)
		      (ROMAN-CHAR 1 N)
		      (SETQ X (- X 5))))
	       (DO I 0 (1+ I) (>= I X)
		   (ROMAN-CHAR 0 N)))))))

;Funny bases
(DEFUN (:ENGLISH SI:PRINC-FUNCTION) (X STREAM)
    (FORMAT STREAM "~R" (- X)))

(DEFUN (:ROMAN SI:PRINC-FUNCTION) (X STREAM)
   (FORMAT STREAM "~@R" (- X)))

(DEFUN (:ROMAN-OLD SI:PRINC-FUNCTION) (X STREAM)
   (FORMAT STREAM "~:@R" (- X)))

;;; I needed to add  to the following alist, which used to be a compiled-in constant.
(DEFCONST *FORMAT-BALANCED-CLAUSE-DELIMITERS*
	  '((#/[ . #/]) (#/{ . #/}) (#/< . #/>) (#/( . #/)) (#/ . #/) (#/ . #/)))

;;; Parse a set of clauses separated by ~; and terminated by ~closechar.
;;; (If SEMIP is nil, however, then ~; is ignored.)
;;; Returns an array; G-L-P of this array is a list whose length is a multiple of 3.
;;; Every three elements are <string> <bits> <paramarray>, where <string> is a control
;;; string separated by ~;, <bits> encodes the : and @ flags for the ~; or ~closechar
;;; that followed this string (: = 1, @ = 2), and <paramarray> is () or the parameter array
;;; for that ~; or ~closechar.  The arrays and strings are consed in the temporary area.
;;; FORMAT-RECLAIM-CLAUSES should be used to return the arrays and strings.

;;;--- CALLERS NOTE WELL!!! THIS FUNCTION EXPECTS TO BE CALLED INSIDE A
;;;--- SYS:WITH-DATA-STACK!!!  
;;;--- This is not good programming practice, I guess, but it beats the pants off
;;;--- of using FORMAT-TEMPORARY-AREA.
(DEFUN FORMAT-PARSE-CLAUSES (CLOSECHAR SEMIP)
  (DO ((I CTL-INDEX) (J) (TEM) (START (+ 4 (1- CTL-INDEX)))
       (CLAUSES (SYS:MAKE-STACK-ARRAY 30. :TYPE 'ART-Q-LIST
					  :LEADER-LENGTH 2 :FILL-POINTER 0))
       (STACK (SYS:MAKE-STACK-ARRAY 30. :TYPE 'ART-Q-LIST
					:FILL-POINTER 0)))
      (())					;do forever (until explicit return)
    (OR (SETQ J (SETQ CTL-INDEX (%STRING-SEARCH-CHAR #/~ CTL-STRING CTL-INDEX CTL-LENGTH)))
	(FERROR "Missing ~{~*~~~A and ~}~~~A in format string:~%~VT~{~*~VT~}~%~3@T/"~A/"~%"
		(G-L-P STACK) CLOSECHAR START (REVERSE (G-L-P STACK)) CTL-STRING))
    (LET ((ATSIGN-FLAG NIL)
	  (COLON-FLAG NIL)
	  (FORMAT-PARAMS (SYS:MAKE-STACK-ARRAY 10. :TYPE 'ART-Q-LIST :FILL-POINTER 0)))
      (LET ((COMMAND (FORMAT-PARSE-COMMAND NIL NIL)))
	;; Now I points to beginning of clause, J to ~, and CTL-INDEX after command.
	(COND ((NOT (TYPEP COMMAND :CHARACTER))
	       ;; Probably a symbol, such as those used by ~\.  In any
	       ;; case, all of the clauses below are for character
	       ;; hacking.
	       )
	      ((SETQ TEM (CL:ASSOC COMMAND *FORMAT-BALANCED-CLAUSE-DELIMITERS*
				   :TEST #'CHAR-EQUAL))
	       (ARRAY-PUSH-EXTEND STACK (+ 4 (1- CTL-INDEX)))	;for error message only
	       (ARRAY-PUSH-EXTEND STACK (CDR TEM)))
	      ((PLUSP (ARRAY-ACTIVE-LENGTH STACK))
	       (COND ((CHAR-EQUAL COMMAND (AREF STACK (1- (ARRAY-LEADER STACK 0))))
		      (ARRAY-POP STACK)		;pop twice
		      (ARRAY-POP STACK))))
	      ((OR (CHAR-EQUAL COMMAND CLOSECHAR) (AND SEMIP (CHAR-EQUAL COMMAND #/;)))
	       (LET
		 ((STRING (SYS:MAKE-STACK-ARRAY (- J I) :TYPE (SYS:ARRAY-TYPE CTL-STRING))))
		 (COPY-ARRAY-PORTION CTL-STRING I J STRING 0 (- J I))
		 (ARRAY-PUSH-EXTEND CLAUSES STRING))
	       (ARRAY-PUSH-EXTEND CLAUSES (+ (IF COLON-FLAG 1 0) (IF ATSIGN-FLAG 2 0)))
	       (ARRAY-PUSH-EXTEND CLAUSES (IF (PLUSP (ARRAY-ACTIVE-LENGTH FORMAT-PARAMS))
					      (PROG1 FORMAT-PARAMS (SETQ FORMAT-PARAMS NIL))))
	       (SETQ I CTL-INDEX)
	       (COND ((CHAR-EQUAL COMMAND CLOSECHAR)
		      (STORE-ARRAY-LEADER STACK CLAUSES 1)
		      (RETURN CLAUSES)))))))))

(DEFFORMAT /; (:NO-ARG) (IGNORE)
  (FORMAT-ERROR "Stray ~~; in FORMAT control string"))

(DEFFORMAT [ (:MULTI-ARG) (ARGS PARAMS &AUX (ARG (CAR ARGS)))
  (COND (COLON-FLAG
	 (COND (ATSIGN-FLAG
		(SETQ ARG (COND (ARG 1)		;use 2nd clause but don't pop
				(T (POP ARGS) 0))))
	       (T (SETQ ARG (COND (ARG 1) (T 0))) (POP ARGS))))
	(ATSIGN-FLAG (SETQ ARG (COND (ARG 0) (T (POP ARGS) -1))))
	((CAR PARAMS) (SETQ ARG (CAR PARAMS)))
	(T (POP ARGS)))
  (OR (NUMBERP ARG)
      (FORMAT-ERROR "The argument to the FORMAT /"~~[/" command must be a number"))
  (SYS:WITH-DATA-STACK
    (LET* ((START CTL-INDEX)			;for error message only
	   (CLAUSES (FORMAT-PARSE-CLAUSES #/] T))
	   (CLAUSE-LIST (G-L-P CLAUSES))
	   (NUM-CLAUSES (// (LENGTH CLAUSE-LIST) 3.)))
      ;; Verify that the proper number of clauses were specified if we've used
      ;; the colon or atsign modifiers.
      (COND (COLON-FLAG
	     (UNLESS (OR (= NUM-CLAUSES 2)	;only two allowed for ~:[ and ~:@[
			 ;; this conditional should really simply be
			 ;;      (= num-clauses 2)
			 ;; but for now we have to accept an alternative
			 ;; syntax for ~:[ in which only one clause is specified.
			 (AND (= NUM-CLAUSES 1)
			      (NOT ATSIGN-FLAG)))
	       (FORMAT-ERROR
		 "Too ~:[few~;many~] clauses specified for ~:[/"~~:[~;/"~~:@[/"~]"
		 (> NUM-CLAUSES 2)
		 ATSIGN-FLAG)))
	    (ATSIGN-FLAG
	     (WHEN (> NUM-CLAUSES 1)
	       (FORMAT-ERROR "Too many clauses specified for /"~~@[/""))))
      (DO ((L CLAUSE-LIST (CDDDR L))
	   (STATE (AND (PLUSP (ARRAY-ACTIVE-LENGTH CLAUSES))
		       (NOT (ZEROP (STRING-LENGTH (AREF CLAUSES 0))))
		       'SIMPLE)))
	  ((NULL (CDDDR L))
	   (LET ((STRING
		   (COND ((EQ STATE 'HAIRY)
			  (DO ((Z (G-L-P CLAUSES) (CDDDR Z)))
			      ((NULL (CDDDR Z)) NIL)
			    (AND (COND ((NULL (CADDR Z)) T)
				       ((ODDP (CADR Z))
					(DO ((Q (G-L-P (CADDR Z)) (CDDR Q)))
					    ((NULL Q) NIL)
					  (AND (OR (NULL (CAR Q)) (NOT (< ARG (CAR Q))))
					       (OR (NULL (CADR Q)) (NOT (> ARG (CADR Q))))
					       (RETURN T))))
				       (T (MEMQ ARG (G-L-P (CADDR Z)))))
				 (RETURN (CADDDR Z)))))
			 (T (DO ((Z (G-L-P CLAUSES) (CDDDR Z))
				 (A ARG (1- A)))
				((NULL Z) NIL)
			      (AND (ZEROP A) (RETURN (CAR Z)))
			      (AND (ODDP (CADR Z))
				   (NOT (NULL (CDDDR Z)))
				   (RETURN (CADDDR Z))))))))
	     (LET ((NEWARGS (COND (STRING (FORMAT-CTL-STRING ARGS STRING))
				  (T ARGS))))
	       NEWARGS)))
	(COND ((NOT (NULL (CADDR L)))
	       (COND ((EQ STATE 'SIMPLE)
		      (SETQ CTL-INDEX START)
		      (FORMAT-ERROR "Mixture of simple and tagged clauses in ~~[")))
	       (SETQ STATE 'HAIRY))
	      ((NOT (ODDP (CADR L)))
	       (COND ((EQ STATE 'HAIRY)
		      (SETQ CTL-INDEX START)
		      (FORMAT-ERROR "Mixture of simple and tagged clauses in ~~[")))
	       (SETQ STATE 'SIMPLE)))))))

(DEFFORMAT ] (:NO-ARG) (IGNORE)
  (FORMAT-ERROR "Stray ~~] in FORMAT control string"))

(DEFFORMAT { (:MULTI-ARG) (ARGS PARAMS)
  (SYS:WITH-DATA-STACK
    (LET ((LIMIT (OR (FIRST PARAMS) -1))
	  (CLAUSES (FORMAT-PARSE-CLAUSES #/} NIL)))
      (OR (NULL (CDDDR (G-L-P CLAUSES))) (FORMAT-ERROR "Bug in FORMAT's ~{ processor"))
      (LET ((STR (CAR (G-L-P CLAUSES))))
	(AND (ZEROP (STRING-LENGTH STR))
	     (OR (STRINGP (SETQ STR (POP ARGS)))
		 (FORMAT-ERROR "~~{~~} argument not a string")))
	(LET ((LOOP-ARGLIST (IF ATSIGN-FLAG ARGS (CAR ARGS))))
	  (CATCH 'FORMAT-/:^-POINT
	    (CATCH 'FORMAT-^-POINT
	      (DO ((OKAY-TO-EXIT (NOT (ODDP (CADR (G-L-P CLAUSES)))) T))
		  ((OR (AND OKAY-TO-EXIT (NULL LOOP-ARGLIST)) (= LIMIT 0)))
		(COND ((NOT COLON-FLAG)
		       (LET ((FORMAT-ARGLIST LOOP-ARGLIST))
			 (SETQ LOOP-ARGLIST
			       (FORMAT-CTL-STRING LOOP-ARGLIST STR))))
		      (T (LET ((FORMAT-ARGLIST (POP LOOP-ARGLIST)))
			   (CATCH 'FORMAT-^-POINT
			     (FORMAT-CTL-STRING FORMAT-ARGLIST STR)))))
		(SETQ LIMIT (1- LIMIT)))))
	  (IF ATSIGN-FLAG LOOP-ARGLIST (CDR ARGS)))))))

(DEFFORMAT } (:NO-ARG) (IGNORE)
  (FORMAT-ERROR "Stray ~~} in FORMAT control string"))

(DEFFORMAT  (:MULTI-ARG) (ARGS PARAMS)
  (SYS:WITH-DATA-STACK
    (LET ((INDENTATION (OR (FIRST PARAMS)
			   (SEND *FORMAT-OUTPUT* :SEND-IF-HANDLES :READ-CURSORPOS :CHARACTER)
			   0))
	  (CLAUSES (FORMAT-PARSE-CLAUSES #/ NIL)))
      (SI:WITH-INDENTATION (*FORMAT-OUTPUT* INDENTATION)
	(FORMAT-CTL-STRING ARGS (AREF CLAUSES 0))))))

(DEFFORMAT  (:NO-ARG) (IGNORE)
  (FORMAT-ERROR "Stray ~~ in FORMAT control string"))

(DEFFORMAT ? (:MULTI-ARG) (ARGS PARAMS)
  PARAMS
  (COND (ATSIGN-FLAG
	 (FORMAT-CTL-STRING (CDR ARGS) (CAR ARGS)))
	(T
	 (FORMAT-CTL-STRING (CADR ARGS) (CAR ARGS))
	 (CDDR ARGS))))
  
;This is not so hairy as to work with ~T, tabs, crs.  I really don't see how to do that.
;It makes a list of strings, then decides how much spacing to put in,
;then goes back and outputs.
(DEFFORMAT < (:MULTI-ARG) (ARGS PARAMS)
  (SYS:WITH-DATA-STACK
    (LET ((CLAUSES (G-L-P (FORMAT-PARSE-CLAUSES #/> T))))
      (IF (LISP:LOGTEST 1 (NTH (- (LENGTH CLAUSES) 2) CLAUSES))
	  (|FORMAT-<:>| ARGS PARAMS CLAUSES)
	  (FORMAT-<> ARGS PARAMS CLAUSES)))))

(DEFUN FORMAT-<> (ARGS PARAMS CLAUSES)
  (LET* ((STREAM *FORMAT-OUTPUT*)
	 (SENSITIVE (SEND STREAM :OPERATION-HANDLED-P :OUTPUT-AS-PRESENTATION))
	 (MINCOL (OR (FIRST PARAMS) 0))
	 (COLINC (OR (SECOND PARAMS) 1))
	 (MINPAD (OR (THIRD PARAMS) 0))
	 (PADCHAR (DEFAULT-PADCHAR (FOURTH PARAMS)))
	 (W-O (FUNCALL STREAM ':WHICH-OPERATIONS))
	 (NEWLINE NIL)
	 (EXTRA 0)
	 (LINEWIDTH NIL)
	 (STRINGS NIL)
	 (STRING-NCOL 0)
	 (N-PADDING-POINTS -1)
	 (TOTAL-PADDING)
	 (N-PADS)
	 (N-EXTRA-PADS))
    ;; This function is like FORMAT-CTL-STRING except that instead of sending to
    ;; *FORMAT-OUTPUT* it sends to a string and returns that as its second value.
    ;; The returned string is on the data stack.
    (FLET ((FORMAT-CTL-STRING-TO-STRING (ARGS STR)
	     (IF SENSITIVE
		 (LET* ((STRING (DW::MAKE-PRESENTATION-RECORDING-STRING
						;:AREA :STACK	;Nice idea, but not in defstruct.
				  ))
			(VALUE (DW:WITH-OUTPUT-TO-PRESENTATION-RECORDING-STRING
				 (*FORMAT-OUTPUT* STRING)
				 (FORMAT-CTL-STRING ARGS STR))))
		   (VALUES VALUE STRING))
		 (LET* ((STRING (SYS:MAKE-STACK-ARRAY #o200 :TYPE SYS:ART-FAT-STRING
						      :FILL-POINTER 0))
			(VALUE (CL:WITH-OUTPUT-TO-STRING (*FORMAT-OUTPUT* STRING)
				 (FORMAT-CTL-STRING ARGS STR))))
		   (VALUES VALUE STRING))))
	   (WRITE-THE-STRING (STRING STREAM)
	     (IF SENSITIVE
		 (PRINC STRING STREAM)
		 (SEND STREAM :STRING-OUT STRING))))
      (AND COLON-FLAG (SETQ N-PADDING-POINTS (1+ N-PADDING-POINTS)))
      (AND ATSIGN-FLAG (SETQ N-PADDING-POINTS (1+ N-PADDING-POINTS)))
      (CATCH 'FORMAT-^-POINT
	(DO ((SPECS CLAUSES (CDDDR SPECS)) (STR))
	    ((NULL SPECS))
	  (MULTIPLE-VALUE (ARGS STR) (FORMAT-CTL-STRING-TO-STRING ARGS (CAR SPECS)))
	  (SETQ STRING-NCOL (+ (STRING-LENGTH STR) STRING-NCOL))
	  (SETQ N-PADDING-POINTS (1+ N-PADDING-POINTS))
	  (SETQ STRINGS (CONS STR STRINGS))))
      (SETQ STRINGS (NREVERSE STRINGS))
      (COND ((AND CLAUSES (ODDP (CADR CLAUSES)))
	     (SETQ NEWLINE (POP STRINGS))
	     (AND (CADDR CLAUSES)
		  (SETQ EXTRA (OR (CAR (G-L-P (CADDR CLAUSES))) 0)
			LINEWIDTH (CADR (G-L-P (CADDR CLAUSES)))))
	     (SETQ STRING-NCOL (- STRING-NCOL (STRING-LENGTH NEWLINE)))
	     (SETQ N-PADDING-POINTS (1- N-PADDING-POINTS))))
      (AND (ZEROP N-PADDING-POINTS)		;With no options and no ~; right-justify
	   (SETQ COLON-FLAG T N-PADDING-POINTS 1))
      ;; Get the amount of space needed to print the strings and MINPAD padding
      (SETQ TOTAL-PADDING (+ (* N-PADDING-POINTS MINPAD) STRING-NCOL))
      ;; Now bring in the MINCOL and COLINC constraint, i.e. the total width is
      ;; at least MINCOL and exceeds MINCOL by a multiple of COLINC, and
      ;; get the total amount of padding to be divided among the padding points
      (SETQ TOTAL-PADDING (- (+ MINCOL (* COLINC (// (+ (MAX (- TOTAL-PADDING MINCOL) 0)
							(1- COLINC))
						     COLINC)))
			     STRING-NCOL))
      ;; Figure out whether a newline is called for or not.
      (COND ((AND NEWLINE
		  (MEMQ ':READ-CURSORPOS W-O)
		  (> (+ (FUNCALL STREAM ':READ-CURSORPOS ':CHARACTER)
			STRING-NCOL TOTAL-PADDING EXTRA)
		     (OR LINEWIDTH
			 (AND (MEMQ ':SIZE-IN-CHARACTERS W-O)
			      (FUNCALL STREAM ':SIZE-IN-CHARACTERS))
			 95.)))
	     (FUNCALL STREAM ':STRING-OUT NEWLINE)))
      ;; Decide how many pads at each padding point + how many of the leftmost
      ;; padding points need one extra pad.
      (SETQ N-PADS (// TOTAL-PADDING N-PADDING-POINTS)
	    N-EXTRA-PADS (\ TOTAL-PADDING N-PADDING-POINTS))
      (OR (ZEROP N-EXTRA-PADS) (SETQ N-PADS (1+ N-PADS)))
      ;; Output the stuff
      (DO ((STRINGS STRINGS (CDR STRINGS))
	   (PAD-BEFORE-P COLON-FLAG T))
	  ((NULL STRINGS))
	(COND (PAD-BEFORE-P
	       (FORMAT-CTL-REPEAT-CHAR N-PADS PADCHAR)
	       (AND (ZEROP (SETQ N-EXTRA-PADS (1- N-EXTRA-PADS)))
		    (SETQ N-PADS (1- N-PADS)))))
	(WRITE-THE-STRING (CAR STRINGS) STREAM))
      ;; Finally spacing at the right
      (AND ATSIGN-FLAG (FORMAT-CTL-REPEAT-CHAR N-PADS PADCHAR))
      ARGS)))

(DEFUN |FORMAT-<:>| (ARGS PARAMS CLAUSES)
  (WHEN PARAMS
    (ERROR "~~<...~~:> does not accept parameters."))
  (LET ((ARG (IF ATSIGN-FLAG (LISP:SHIFTF ARGS NIL) (POP ARGS)))
	(@> (LISP:LOGTEST 2 (NTH (- (LENGTH CLAUSES) 2) CLAUSES))))
    (MULTIPLE-VALUE-BIND (PREFIX PER-LINE BODY SUFFIX)
	(LISP:ECASE (LENGTH CLAUSES)
	  (3
	    (VALUES (IF COLON-FLAG "(" "")
		    NIL
		    (FIRST CLAUSES)
		    (IF COLON-FLAG ")" "")))
	  (6
	    (WHEN (LISP:LOGTEST 1 (SECOND CLAUSES))
	      (ERROR "~~:; is not supported here."))
	    (VALUES (FIRST CLAUSES)
		    (LISP:LOGTEST 2 (SECOND CLAUSES))
		    (FOURTH CLAUSES)
		    (IF COLON-FLAG ")" "")))
	  (9
	    (WHEN (OR (LISP:LOGTEST 1 (SECOND CLAUSES))
		      (LISP:LOGTEST 3 (FIFTH CLAUSES)))
	      (ERROR "~~@; and ~~:; are not supported here."))
	    (VALUES (FIRST CLAUSES)
		    (LISP:LOGTEST 2 (SECOND CLAUSES))
		    (FOURTH CLAUSES)
		    (SEVENTH CLAUSES))))
      (MACROLET ((DOIT ()
		   `(PROGN
		      BODY @>
		      (ERROR "~~<...~~:> is not supported."))))
	(IF PER-LINE
	    (FUTURE-COMMON-LISP:PPRINT-LOGICAL-BLOCK
	      (*FORMAT-OUTPUT* ARG :PER-LINE-PREFIX PREFIX :SUFFIX SUFFIX)
	      (DOIT))
	    (FUTURE-COMMON-LISP:PPRINT-LOGICAL-BLOCK
	      (*FORMAT-OUTPUT* ARG :PREFIX PREFIX :SUFFIX SUFFIX)
	      (DOIT))))
      ARGS)))

(DEFFORMAT > (:NO-ARG) (IGNORE)
  (FORMAT-ERROR "Stray ~~> in FORMAT control string"))

;; Less messy interface to list-printing stuff -- but it conses
(DEFUN PRINT-LIST (DESTINATION ELEMENT-FORMAT-STRING LIST
		   &OPTIONAL (SEPARATOR-FORMAT-STRING ", ")
			     (START-LINE-FORMAT-STRING "   ")
			     (TILDE-BRACE-OPTIONS ""))
  "Print the elements of list without lapping across line boundaries"
  (LET ((FSTRING (FORMAT NIL "~~~A{~~<~~%~A~~~D:;~A~~>~~^~A~~}"
			 TILDE-BRACE-OPTIONS
			 START-LINE-FORMAT-STRING
			 (STRING-LENGTH SEPARATOR-FORMAT-STRING)
			 ELEMENT-FORMAT-STRING
			 SEPARATOR-FORMAT-STRING)))
    (PROG1 (FORMAT DESTINATION FSTRING LIST)
	   ;; This may be faster than EGC, so leave it in.
	   ;; FSTRING is in WORKING-STORAGE-AREA.
	   (RETURN-ARRAY FSTRING))))

(DEFFORMAT  (:ONE-ARG) (THING IGNORE)
  (LET ((*DOWNCASE-FLAG* ATSIGN-FLAG)
	(*ONCE-ONLY-FLAG* COLON-FLAG)
	(*OLD-STREAM* *FORMAT-OUTPUT*))
    (DECLARE (SPECIAL *DOWNCASE-FLAG* *ONCE-ONLY-FLAG* *OLD-STREAM*))
    (PRINC THING #'UPCASE-STREAM)))

(DEFFORMAT /( (:MULTI-ARG) (ARGS PARAMS)
  PARAMS
  (CL:LOCALLY
    (DECLARE (SPECIAL *DOWNCASE-FLAG* *ONCE-ONLY-FLAG* *OLD-STREAM*))
    (SYS:WITH-DATA-STACK
      (LET ((*DOWNCASE-FLAG* (COND (ATSIGN-FLAG NIL)
				   (COLON-FLAG ':CAPITALIZE-EACH)
				   (T T)))
	    (*ONCE-ONLY-FLAG* (EQ ATSIGN-FLAG (NOT COLON-FLAG)))	;One but not both
	    (CLAUSES (FORMAT-PARSE-CLAUSES #/) NIL))
	    (*OLD-STREAM*
	      ;; If we've already remembered an *old-stream*, use it.
	      (IF (VARIABLE-BOUNDP *OLD-STREAM*)
		  *OLD-STREAM*
		;; Else, use *format-output*
		*FORMAT-OUTPUT*))
	    (*FORMAT-OUTPUT* #'UPCASE-STREAM))
	(DECLARE (SPECIAL *DOWNCASE-FLAG* *ONCE-ONLY-FLAG* *OLD-STREAM*))
	(FORMAT-CTL-STRING ARGS (AREF CLAUSES 0))))))

(DEFFORMAT /) (:NO-ARG) (IGNORE)
  (FORMAT-ERROR "Stray ~~) in FORMAT control string"))

(DEFPROP UPCASE-STREAM T SI:IO-STREAM-P)
(DEFUN UPCASE-STREAM (OP &REST ARGS)
  (DECLARE (SPECIAL *DOWNCASE-FLAG* *ONCE-ONLY-FLAG* *OLD-STREAM*))
  (SELECTQ OP
    (:WHICH-OPERATIONS
     ;; It is important to use :WHICH-OPERATIONS to query the underlying
     ;; stream, not :OPERATION-HANDLED-P, since the default handler for
     ;; :OPERATION-HANDLED-P is implemented by :WHICH-OPERATIONS, and
     ;; hence could recurse
     (IF (MEMBER :GPRINT (SEND *OLD-STREAM* :WHICH-OPERATIONS))
	 '(:TYO :GPRINT)
	 '(:TYO)))
    (:TYO
     (LET ((CHAR (FIRST ARGS)))
       (IF (ALPHANUMERICP CHAR)
	   ;; This character is part of a word (in the sense of CL:STRING-CAPITALIZE)
	   (SETQ CHAR (SELECTQ *DOWNCASE-FLAG*
			((T)
			 (WHEN *ONCE-ONLY-FLAG*
			   (SETQ *ONCE-ONLY-FLAG* NIL
				 *DOWNCASE-FLAG* NIL))
			 (CHAR-DOWNCASE CHAR))
			((NIL)
			 (WHEN *ONCE-ONLY-FLAG*
			   (SETQ *ONCE-ONLY-FLAG* NIL
				 *DOWNCASE-FLAG* T))
			 (CHAR-UPCASE CHAR))
			((:CAPITALIZE-EACH)
			 (IF *ONCE-ONLY-FLAG*
			     (PROG1 (CHAR-UPCASE CHAR)
				    (SETQ *ONCE-ONLY-FLAG* NIL))
			     (CHAR-DOWNCASE CHAR)))))
	   ;; Between words
	   (IF (EQ *DOWNCASE-FLAG* ':CAPITALIZE-EACH)
	       (SETQ *ONCE-ONLY-FLAG* T)))
       (SEND *OLD-STREAM* :TYO CHAR)))
    ((:SIZE-IN-CHARACTERS :INSIDE-SIZE :VISIBLE-CURSORPOS-LIMITS
      :READ-CURSORPOS :SET-CURSORPOS :INCREMENT-CURSORPOS
      :CHAR-WIDTH :LINE-HEIGHT :CHARACTER-WIDTH :STRING-LENGTH
      :OUTPUT-AS-PRESENTATION-1 :GPRINT)
     (LEXPR-SEND *OLD-STREAM* OP ARGS))
    (OTHERWISE
     (STREAM-DEFAULT-HANDLER 'UPCASE-STREAM OP (FIRST ARGS) (REST1 ARGS)))))

(DEFFORMAT W (:ONE-ARG) (ARG PARAMS)
  (WHEN PARAMS
    (ERROR "~~W does not accept parameters."))
  (IF COLON-FLAG
      (IF ATSIGN-FLAG
	  (LISP:WRITE ARG :STREAM *FORMAT-OUTPUT* :PRETTY T :LEVEL NIL :LENGTH NIL)
	  (LISP:WRITE ARG :STREAM *FORMAT-OUTPUT* :PRETTY T))
      (IF ATSIGN-FLAG
	  (LISP:WRITE ARG :STREAM *FORMAT-OUTPUT* :LEVEL NIL :LENGTH NIL)
	  (LISP:WRITE ARG :STREAM *FORMAT-OUTPUT*))))

(DEFFORMAT I (:NO-ARG) (PARAMS)
  (WHEN ATSIGN-FLAG
    (ERROR "~~@I is not supported."))
  (SCL:DESTRUCTURING-BIND (&OPTIONAL (N 0)) PARAMS
    (FUTURE-COMMON-LISP:PPRINT-INDENT (IF COLON-FLAG :CURRENT :BLOCK) N *FORMAT-OUTPUT*)))

(DEFFORMAT _ (:NO-ARG) (PARAMS)
  (WHEN PARAMS
    (ERROR "~~_ does not accept parameters."))
  (FUTURE-COMMON-LISP:PPRINT-NEWLINE (IF COLON-FLAG
					 (IF ATSIGN-FLAG :MANDATORY :FILL)
					 (IF ATSIGN-FLAG :MISER :LINEAR))
				     *FORMAT-OUTPUT*))

;; Compare sage:*face-code-alist*
(DEFCONST *FORMAT-FACE-CODE-ALIST*
	  '((#\I :ITALIC) (#\B :BOLD) (#\P :BOLD-ITALIC) (#\R :ROMAN)))

;;; ~...~ uses its param as a character style.  Use like ~'i.. or ~v..
;;; With colon-flag it binds line height too.
(DEFFORMAT  (:MULTI-ARG) (ARGUMENTS PARAMETERS)
  (COND (ATSIGN-FLAG
	 (FORMAT-ERROR "The format command ~~... does not take an @ flag"))
	(T
	 ;; When (null parameters) just do nothing special, instead of barfing.
	 (MULTIPLE-VALUE-BIND (FACE STYLE)
	     ;; Wouldn't need this circumlocution if with-character-style took a face.
	     (TYPECASE (FIRST PARAMETERS)
	       (:CHARACTER
		 (VALUES (OR (SECOND (ASS #'CL:EQUALP (FIRST PARAMETERS)
					  *FORMAT-FACE-CODE-ALIST*))
			     (FORMAT-ERROR "The face code ~s is unknown"
					   (FIRST PARAMETERS)))
			 NIL))
	       (:SYMBOL (VALUES (FIRST PARAMETERS) NIL))
	       (OTHERWISE			;list or chstyle object
		 (VALUES NIL (FIRST PARAMETERS))))
	   ;; Defer call to format-parse-clauses so above error message (if any)
	   ;; will point to the "right" place in the ctl-string.
	   (SYS:WITH-DATA-STACK			;format-parse-clauses assumes we do this
	     (LET ((CLAUSE (AREF (FORMAT-PARSE-CLAUSES #/ NIL) 0)))
	       ;; Quietly ignoring other clauses ~..~;..~, but there is ample
	       ;; precedent in other format directives above.
	       (IF FACE
		   (SCL:WITH-CHARACTER-FACE (FACE *FORMAT-OUTPUT*
						  :BIND-LINE-HEIGHT COLON-FLAG)
		     (FORMAT-CTL-STRING ARGUMENTS CLAUSE))
		   (SCL:WITH-CHARACTER-STYLE (STYLE *FORMAT-OUTPUT*
						    :BIND-LINE-HEIGHT COLON-FLAG)
		     (FORMAT-CTL-STRING ARGUMENTS CLAUSE)))))))))
	     
(FORMAT:DEFFORMAT FORMAT: (:NO-ARG) (IGNORE)
  (FORMAT:FORMAT-ERROR "Stray ~~ in FORMAT control string"))


(DEFFORMAT HAS-HAVE (:ONE-ARG) (N IGNORE)
  (SEND *FORMAT-OUTPUT* :STRING-OUT (IF (= N 1) "has" "have")))

(DEFFORMAT IS-ARE (:ONE-ARG) (N IGNORE)
  (SEND *FORMAT-OUTPUT* :STRING-OUT (IF (= N 1) "is" "are")))

(DEFFORMAT WAS-WERE (:ONE-ARG) (N IGNORE)
  (SEND *FORMAT-OUTPUT* :STRING-OUT (IF (= N 1) "was" "were")))

(DEFFORMAT THIS-THESE (:ONE-ARG) (N IGNORE)
  (SEND *FORMAT-OUTPUT* :STRING-OUT (IF (= N 1) "this" "these")))

(DEFFORMAT THAT-THOSE (:ONE-ARG) (N IGNORE)
  (SEND *FORMAT-OUTPUT* :STRING-OUT (IF (= N 1) "that" "those")))

(DEFFORMAT IT-THEM (:ONE-ARG) (N IGNORE)
  (SEND *FORMAT-OUTPUT* :STRING-OUT (IF (= N 1) "it" "them")))

(DEFFORMAT IT-THEY (:ONE-ARG) (N IGNORE)
  (SEND *FORMAT-OUTPUT* :STRING-OUT (IF (= N 1) "it" "they")))

(DEFFORMAT ITS-THEIR (:ONE-ARG) (N IGNORE)
  (SEND *FORMAT-OUTPUT* :STRING-OUT (IF (= N 1) "its" "their")))



(DEFMACRO WITH-CASED-STREAM (&BODY FORMS)
  `(CL:LOCALLY (DECLARE (SPECIAL *OLD-STREAM*))
     (LET ((*DOWNCASE-FLAG* (COND (ATSIGN-FLAG NIL)
				  (COLON-FLAG ':CAPITALIZE-EACH)
				  (T T)))
	   (*ONCE-ONLY-FLAG* (EQ ATSIGN-FLAG (NOT COLON-FLAG)))	;One but not both
	   (*OLD-STREAM*
	     ;; If we've already remembered an *old-stream*, use it.
	     (IF (VARIABLE-BOUNDP *OLD-STREAM*)
		 *OLD-STREAM*
		 ;; Else, use *format-output*
		 *FORMAT-OUTPUT*))
	   (*FORMAT-OUTPUT* #'UPCASE-STREAM))
       (DECLARE (SPECIAL *DOWNCASE-FLAG* *ONCE-ONLY-FLAG* *OLD-STREAM*))
       ,@FORMS)))

(FORMAT:DEFFORMAT PLURALIZE (:MULTI-ARG) (ARGS PARAMS)
  (LET ((OFFSET (FIRST PARAMS)))
    (WHEN OFFSET
      (LET ((COLON-FLAG (MINUSP OFFSET))
	    (ATSIGN-FLAG NIL))
	(SETQ ARGS (FORMAT-CTL-IGNORE ARGS (LIST (ABS OFFSET)))))))
  (LET* ((ARG1 (CAR  ARGS))
	 (ARG2 (CADR ARGS))
	 (SINGULAR (EQUAL ARG1 1))
	 X1 X2 X2-P)
    (COND ((OR (STRINGP ARG2) (SYMBOLP ARG2))
	   (SETQ X1 (STRING ARG2)))
	  ((AND (LISTP ARG2)
		(< (LENGTH ARG2) 3)
		(PROGN (SETQ X1 (CAR ARG2) X2 (CADR ARG2))
		       (AND (OR (STRINGP X1) (SYMBOLP X1))
			    (OR (STRINGP X2) (SYMBOLP X2)))))
	   (SETQ X2-P T))
	  (T
	   (FERROR "Bad argument to PLURALIZE format directive: ~S~
		  ~%Expected a singular string or a list of (singular plural)."
		   ARG2)))
    (WITH-CASED-STREAM
      (IF SINGULAR
	  (PRINC X1 *FORMAT-OUTPUT*)
	  (IF X2-P
	      (PRINC X2 *FORMAT-OUTPUT*)
	      (CLI::STRING-PLURALIZE-TO-STREAM X1 *FORMAT-OUTPUT*))))
    (CDDR ARGS)))

#||

(DEFUN TEST-PLURALIZE-FORMAT-OP ()
  (LET ((GOOD "1 man 2 men 1 WIFE 2 WIVES 1 Box 2 Boxes 1 deer 2 deer 1 tooth 2 teeth")
	(TEST (FORMAT NIL "~D ~-\PLURALIZE\ ~D ~-\PLURALIZE\ ~
			   ~D ~-:@\PLURALIZE\ ~D ~-:@\PLURALIZE\ ~
			   ~D ~:\PLURALIZE\ ~D ~:\PLURALIZE\ ~
			   ~D ~-\PLURALIZE\ ~D ~-\PLURALIZE\ ~
			   ~D ~-\PLURALIZE\ ~D ~-\PLURALIZE\"
		      1 "man" 2 "man" 1 "wife" 2 :wife 1 1 'box 2 2 'box
		      1 '("deer" "deer") 2 '("deer" "deer")
		      1 '("tooth"  "teeth") 2 '("tooth" "teeth"))))
    (IF (EQUAL GOOD TEST)
	:WIN
	`(:LOSE :GOOD ,GOOD :BAD ,TEST))))

||#


(FORMAT:DEFFORMAT A-OR-AN (:ONE-ARG) (ARG PARAMS)
  (IGNORE PARAMS)
  ;; Given "EgG"...
  ;;  No modifiers:  "an egg"
  ;;  @  modifier:   "An egg"
  ;;  @: modifiers:  "AN EGG"
  ;;   : modifier:   "An Egg"
  (LET ((THE-STRING (CL:TYPECASE ARG
		      (CL:STRING ARG)
		      (CL:SYMBOL (CL:SYMBOL-NAME ARG))
		      (CL:NUMBER (FORMAT NIL "~D" ARG))
		      (OTHERWISE (FORMAT NIL "~A" ARG)))))
    (LET ((A-OR-AN (CLI::STRING-A-OR-AN THE-STRING NIL NIL)))
      (WITH-CASED-STREAM
	(SEND *FORMAT-OUTPUT* :STRING-OUT (IF (EQ A-OR-AN :AN) "an" "a"))
	(SEND *FORMAT-OUTPUT* :TYO #\Space)
	(FORMAT-CTL-ASCII THE-STRING NIL)))))

#||

(DEFUN TEST-A-OR-AN-FORMAT-OP ()
  (LET ((GOOD (FORMAT NIL "~(   a box~)~%~:(:  a box~)~%~@( @ a box~)~%~:@(:@ a box~)~
	           	~2%~(   an egg~)~%~:(:  an egg~)~%~@( @ an egg~)~%~:@(:@ an egg~)"))
	(TEST (FORMAT NIL "~{   ~\A-OR-AN\~:*~
			   ~%:  ~:\A-OR-AN\~:*~
			   ~% @ ~:@\A-OR-AN\~:*~
			   ~%:@ ~:@\A-OR-AN\~^~2%~}"
		      '(box egg))))
    (IF (EQUAL GOOD TEST) :WIN `(:LOSE :GOOD ,GOOD :BAD ,TEST))))

||#



;;; FORMAT directive ~\QUOTED-STRING\:
;;;  Prints a quoted string.
;;;  The modifiers work as follows:
;;;    Colon says print the quotes only if needed for the current readtable.
;;;    Atsign says use | instead of " for quoting.
;;;    e.g.,
;;;     (FORMAT T "~{~%~\\QUOTED-STRING\\ ~:\\QUOTED-STRING\\ ~
;;; 	           ~@\\QUOTED-STRING\\ ~:@\\QUOTED-STRING\\~}~%"
;;;               '("FOO" "FOO" "FOO" "FOO" "FOO BAR" "FOO BAR" "FOO BAR" "FOO BAR"))
;;;     "FOO" FOO |FOO| FOO
;;;     "FOO BAR" "FOO BAR" |FOO BAR| |FOO BAR|

(FORMAT:DEFFORMAT QUOTED-STRING (:ONE-ARG) (ARG PARAMS)
  (IGNORE PARAMS)
  (LET ((THE-STRING (CL:TYPECASE ARG
		      (CL:STRING ARG)
		      (CL:SYMBOL (CL:SYMBOL-NAME ARG))
		      (OTHERWISE (FORMAT NIL "~A" ARG)))))
    (LET ((QUOTE-CHAR (IF ATSIGN-FLAG #/| #/")))
      (SI:PRINT-PNAME-STRING-1 THE-STRING *FORMAT-OUTPUT* T NIL
			       :OPEN-QUOTE-CHARACTER QUOTE-CHAR
			       :CLOSE-QUOTE-CHARACTER QUOTE-CHAR
			       :FORCE (NOT COLON-FLAG)))))


;; Stupid FORMAT optimizer.

(COMPILER:DEFOPTIMIZER (ZL:FORMAT OPTIMIZE-ZL-FORMAT) (BODY)
  (COMPILER:MATCHP BODY
    (('ZL:FORMAT STREAM STRING . ARGS)
     (OR (OPTIMIZE-FORMAT NIL STREAM STRING ARGS)
	 BODY))
    (* BODY)))

(COMPILER:DEFOPTIMIZER (CL:FORMAT OPTIMIZE-CL-FORMAT) (BODY)
  (COMPILER:MATCHP BODY
    (('CL:FORMAT STREAM STRING . ARGS)
     (OR (OPTIMIZE-FORMAT T STREAM STRING ARGS)
	 BODY))
    (* BODY)))

;; Simple for now (if that's what you call a two-page function).
;; Very careful to preserve all of FORMATs' bugs.
(DEFUN OPTIMIZE-FORMAT (COMMON-LISP STREAM STRING ARGS)
  ;; Canonicalize string
  (WHEN (AND (LISTP STRING)
	     (EQ (CAR STRING) 'QUOTE))
    (LET ((QUOTED (CADR STRING)))
      (COND ((STRINGP QUOTED) (SETQ STRING QUOTED))
	    ((SYMBOLP QUOTED) (SETQ STRING (GET-PNAME QUOTED))))))
  ;; Canonicalize stream
  (WHEN (AND (LISTP STREAM)
	     (EQ (FIRST STREAM) 'QUOTE)
	     (MEMBER (SECOND STREAM) '(T NIL)))
    (SETF STREAM (SECOND STREAM)))
  ;; Simple cases.
  (WHEN (AND (STRINGP STRING)
	     (EQ STREAM T))
    (SELECTOR STRING STRING-EQUAL
      ("~A" (RETURN-FROM OPTIMIZE-FORMAT
	      `(PROGN (PRINC (PROG1 ,@(OR ARGS '(NIL)))) NIL)))
      ("~S" (RETURN-FROM OPTIMIZE-FORMAT
	      `(PROGN (PRIN1 (PROG1 ,@(OR ARGS '(NIL)))) NIL)))
      ("~%" (RETURN-FROM OPTIMIZE-FORMAT
	      `(PROGN (SEND (PROG1 STANDARD-OUTPUT ,@ARGS) :TYO #\CR) NIL)))
      ("~&" (RETURN-FROM OPTIMIZE-FORMAT
	      `(PROGN (SEND (PROG1 STANDARD-OUTPUT ,@ARGS) :FRESH-LINE) NIL)))))
  ;; Remove ~<CR>s, ~@<CR>s, ~%'s, ~~'s.
  (WHEN (STRINGP STRING)
    (MULTIPLE-VALUE-BIND (NEW-STRING FOUND-A-CLAUSE GROKED-A-~)
	(SIMPLIFY-FORMAT-STRING STRING)
      ;; Can't requote ~'s.
      (WHEN (AND NEW-STRING (OR FOUND-A-CLAUSE (NEQ STREAM T)) GROKED-A-~)
	(MULTIPLE-VALUE (NEW-STRING FOUND-A-CLAUSE)
	  (SIMPLIFY-FORMAT-STRING STRING T)))
      (WHEN NEW-STRING (SETF STRING NEW-STRING))
      (IF FOUND-A-CLAUSE
	  (WHEN NEW-STRING
	    `(,(IF COMMON-LISP 'CL:FORMAT 'ZL:FORMAT)
	      ,STREAM ,NEW-STRING ,@ARGS))
	  (COND ((EQ STREAM T)
		 (SELECTOR (STRING-LENGTH STRING) =
		   (0 `(PROGN ,STREAM ,@ARGS NIL))
		   (1 `(PROGN (SEND (PROG1 STANDARD-OUTPUT ,@ARGS) :TYO ,(AREF STRING 0))
			      NIL))
		   (OTHERWISE
		     `(PROGN (SEND (PROG1 STANDARD-OUTPUT ,@ARGS) :STRING-OUT ,STRING) NIL))))
		(NEW-STRING
		 `(,(IF COMMON-LISP 'CL:FORMAT 'ZL:FORMAT)
		   ,STREAM ,STRING ,@ARGS))
		)))))

(DEFUN SIMPLIFY-FORMAT-STRING (STRING &OPTIONAL DONT-HACK-~)
  (when (symbolp string) (setq string (cl:symbol-name string)))
  (when (stringp string)			;when a real string
    (LET* ((LENGTH (STRING-LENGTH STRING))
	   (NEW-STRING (MAKE-ARRAY LENGTH :TYPE (ARRAY-TYPE STRING) :FILL-POINTER 0))
	   (INDEX 0) I NEXT SOMETHING-CHANGED FOUND-A-CLAUSE GROKED-A-~)
      (CL:WITH-OUTPUT-TO-STRING (STRING-STREAM NEW-STRING)
	(LOOP WHILE (< INDEX LENGTH)
	      DO (SETQ I (STRING-SEARCH-CHAR #/~ STRING INDEX LENGTH))
	      UNTIL (NULL I)
	      WHEN (= I (1- LENGTH))
		DO (SETQ FOUND-A-CLAUSE T)
		   (LOOP-FINISH)
	      DO (SETQ NEXT (AREF STRING (1+ I)))
		 (COND ((CHAR-EQUAL NEXT #/%)
			(SETQ SOMETHING-CHANGED T)
			(SEND STRING-STREAM :STRING-OUT STRING INDEX I)
			(SEND STRING-STREAM :TYO #\CR)
			(SETQ INDEX (+ I 2)))
		       ((CHAR-EQUAL NEXT #\CR)
			(SETQ SOMETHING-CHANGED T)
			(SEND STRING-STREAM :STRING-OUT STRING INDEX I)
			(SETQ INDEX (OR (STRING-SEARCH-NOT-SET '(#\SP #\TAB)
							       STRING (+ I 2))
					LENGTH)))
		       ((AND (NOT DONT-HACK-~)
			     (CHAR-EQUAL NEXT #/~))
			(SETQ SOMETHING-CHANGED T)
			(SETQ GROKED-A-~ T)
			(SEND STRING-STREAM :STRING-OUT STRING INDEX (1+ I))
			(SETQ INDEX (+ I 2)))
		       ((AND (CHAR-EQUAL NEXT #/@)
			     (< I (- LENGTH 2))
			     (CHAR-EQUAL (SETQ NEXT (AREF STRING (+ I 2))) #\CR))
			(SETQ SOMETHING-CHANGED T)
			(SEND STRING-STREAM :STRING-OUT STRING INDEX I)
			(SEND STRING-STREAM :TYO #\CR)
			(SETQ INDEX (OR (STRING-SEARCH-NOT-SET '(#\SP #\TAB)
							       STRING (+ I 3))
					LENGTH)))
		       (T (SETQ FOUND-A-CLAUSE T)
			  (SEND STRING-STREAM :STRING-OUT STRING INDEX (+ I 2))
			  (SETQ INDEX (+ I 2)))))
	(SEND STRING-STREAM :STRING-OUT STRING INDEX LENGTH))
      ;; SUBSTRING copies the string, and while doing so removes the fill
      ;; pointer making it a simpler string.
      (VALUES (AND SOMETHING-CHANGED (SUBSTRING NEW-STRING 0)) FOUND-A-CLAUSE GROKED-A-~))))
