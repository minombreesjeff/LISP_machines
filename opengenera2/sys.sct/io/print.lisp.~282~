;;; -*- Mode: LISP; Package: SYSTEM-INTERNALS; Base: 8 -*-
;;; Lisp Machine PRINT.
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; These are the things stored in the print-table (actually a section of the
;;; ARRAY-LEADER of the READTABLE)
;;;	   PTTBL-SPACE			     ;40
;;;	   PTTBL-NEWLINE		     ;215
;;;	   PTTBL-CONS-DOT		     ;" . "
;;;	   PTTBL-MINUS-SIGN		     ;#/-
;;;	   PTTBL-DECIMAL-POINT		     ;#/.
;;;	   PTTBL-SLASH			     ;#//
;;;	   PTTBL-PRINLEVEL		     ;"**"
;;;	   PTTBL-PRINLENGTH		     ;" ...)"
;;;	   PTTBL-OPEN-RANDOM		     ;"#<"
;;;	   PTTBL-CLOSE-RANDOM		     ;">"
;;;	   PTTBL-OPEN-PAREN		     ;#/(
;;;	   PTTBL-CLOSE-PAREN		     ;#/)
;;;	   PTTBL-OPEN-QUOTE-STRING	     ;#/"
;;;	   PTTBL-CLOSE-QUOTE-STRING	     ;#/"
;;;	   PTTBL-OPEN-QUOTE-SYMBOL	     ;#/|
;;;	   PTTBL-CLOSE-QUOTE-SYMBOL	     ;#/|
;;;        PTTBL-PACKAGE-CHAR                ;#/:
;;;	   PTTBL-INTERNAL-PACKAGE-PREFIX     ;"::"
;;;	   PTTBL-UNINTERNED-PREFIX	     ;"#:"
;;;	   PTTBL-RATIO			     ;#/\

;Flag used to prevent recursive error trapping in PRINT-OBJECT
(DEFVAR *PRINT-ERROR*)

;Print an object according to the printer-control variables
;The second argument must be a stream (not t or nil)
;The object is returned
(DEFUN WRITE-INTERNAL (OBJECT STREAM)
  (LET ((*PRINT-ERROR* NIL))
    (COND (*PRINT-PRETTY*
	   (FUNCALL CLI::*PRINT-PRETTY-PRINTER* OBJECT *PRINT-PRETTY* STREAM))
	  (*PRINT-CIRCLE*
	   (GPRINT:PRINT-CIRCLE OBJECT STREAM))
	  (T
	   (SI:PRINT-OBJECT OBJECT 0 *PRINT-ESCAPE* STREAM)))))

(DEFMACRO DEFAULT-WRITE-STREAM (VARIABLE)
  `(COND ((NULL ,VARIABLE)
	  (SETQ ,VARIABLE STANDARD-OUTPUT))
	 ((EQ ,VARIABLE T)
	  (SETQ ,VARIABLE TERMINAL-IO))))

;MAIN ENTRIES
;These are the external entrypoints which are in the usual documentation.  They
;are compatible with MACLISP.

(DEFUN PRINT (OBJECT &OPTIONAL OUTPUT-STREAM)
  (DEFAULT-WRITE-STREAM OUTPUT-STREAM)
  (SEND OUTPUT-STREAM :TYO (PTTBL-NEWLINE READTABLE))
  (LET ((*PRINT-ESCAPE* T))
    (WRITE-INTERNAL OBJECT OUTPUT-STREAM))
  (SEND OUTPUT-STREAM :TYO (PTTBL-SPACE READTABLE))
  OBJECT)

(DEFUN PRIN1 (OBJECT &OPTIONAL OUTPUT-STREAM)
  (DEFAULT-WRITE-STREAM OUTPUT-STREAM)
  (LET ((*PRINT-ESCAPE* T))
    (WRITE-INTERNAL OBJECT OUTPUT-STREAM))
  OBJECT)

(DEFUN PRIN1-THEN-SPACE (OBJECT &OPTIONAL OUTPUT-STREAM)
  (DEFAULT-WRITE-STREAM OUTPUT-STREAM)
  (PRIN1 OBJECT OUTPUT-STREAM)
  (SEND OUTPUT-STREAM :TYO (PTTBL-SPACE READTABLE))
  OBJECT)

(DEFUN PRINC (OBJECT &OPTIONAL OUTPUT-STREAM)
  (DEFAULT-WRITE-STREAM OUTPUT-STREAM)
  (LET ((*PRINT-ESCAPE* NIL))
    (WRITE-INTERNAL OBJECT OUTPUT-STREAM))
  OBJECT)

(DEFUN PPRINT (OBJECT &OPTIONAL OUTPUT-STREAM)
  (DEFAULT-WRITE-STREAM OUTPUT-STREAM)
  (SEND OUTPUT-STREAM :TYO (PTTBL-NEWLINE READTABLE))
  (LET ((*PRINT-PRETTY* (OR *PRINT-PRETTY* T)))
    (WRITE-INTERNAL OBJECT OUTPUT-STREAM))
  (VALUES))

;;; Given the second argument to PRINT (and friends), return
;;; a stream, processing for Maclisp compatibility
(DEFUN DECODE-PRINT-ARG (X)
  (COND ((EQ X NIL) STANDARD-OUTPUT)
	((EQ X T) TERMINAL-IO)
	((CL:STREAMP X) X)
	((AND (LISTP X) (OR (CL:STREAMP (CAR X)) (EQ (CAR X) NIL) (EQ (CAR X) T)))
	 (FERROR "Output to multiple streams ~S not yet supported." X))
	(T X))) ;Unrecognizable, hope funcalling it works.

(DEFUN TERPRI (&OPTIONAL STREAM)
  (FUNCALL (DECODE-PRINT-ARG STREAM) ':TYO (PTTBL-NEWLINE READTABLE))
  T)

(DEFUN TYO (CHAR &OPTIONAL STREAM)
  (FUNCALL (DECODE-PRINT-ARG STREAM) ':TYO CHAR)
  CHAR)

;SUBROUTINES

;A kludge....
(DEFUN PRINT-COMMON-LISP-P ()
  (CHAR= (PTTBL-SLASH READTABLE) #/\))

;; Print the string, with no slashification at all.
;; IGNORE used to be FASTP.  Old versions of PRINTING-RANDOM-OBJECT generated calls to this
;; function with three arguments instead of two.
(DEFSUBST PRINT-RAW-STRING (STRING STREAM &OPTIONAL IGNORE)
  (SEND STREAM :STRING-OUT STRING))

(DEFVAR-RESETTABLE *PRINT-ERROR-SUPPRESS* :INTERACTIVE :INTERACTIVE
  "Defines when printing should suppress errors -- one of T (always), NIL (never)
or :INTERACTIVE (default, only suppress errors on interactive streams).")

;Main routine, to print any Lisp object.
;The WHICH-OPERATIONS argument is provided as an efficiency hack.  It also used
;by streams that have a :PRINT handler, and recursively call PRINT-OBJECT, to
;prevent themselves from being called again (they pass NIL or (:STRING-OUT))
;at level.  To prevent being called again only this once, but not affect calls for
;list elements, use RECURSIVE.
(DEFUN PRINT-OBJECT (EXP I-PRINDEPTH SLASHIFY-P STREAM
		     &OPTIONAL (WHICH-OPERATIONS (FUNCALL STREAM ':WHICH-OPERATIONS))
			       (RECURSIVE NIL))
  (LET ((DBG:*PRINTING-MONITOR-MESSAGE* DBG:*INHIBIT-MONITORING-DURING-PRINT*))
    (BLOCK PRINT
      (CONDITION-BIND
	  ((ERROR #'(LAMBDA (CONDITION)
		      (CONDITION-CASE ()
			   ;; Normal printing method got an error.  If appropriate
			   ;; substitute a default printed representation similar
			   ;; to what PRINT-RANDOM-OBJECT prints.  But if that
			   ;; gets an error (maybe the stream is dead), go back
			   ;; to signalling the original error.
			   ;; Do this on interactive streams, so we can inspect and
			   ;; debug busted objects, but don't do it on non-interactive
			   ;; streams, where we would rather be able to debug the error.
			   (UNLESS *PRINT-ERROR*
			     (WHEN (CL:CASE *PRINT-ERROR-SUPPRESS*
				     (:INTERACTIVE (SEND STREAM :INTERACTIVE))
				     (OTHERWISE *PRINT-ERROR-SUPPRESS*))
			       (UNLESS (TYPEP CONDITION 'PRINT-NOT-READABLE)
				 (LET ((*PRINT-ERROR* T))
				   (PRINTING-RANDOM-OBJECT (EXP STREAM)
				     (PRINT-RAW-STRING "Error printing object " STREAM)
				     (PRINT-RAW-STRING
				       (STRING (OR (ALLOW-RECURSIVE-WIRED-FERROR
						     (IGNORE-ERRORS (TYPEP EXP)))
						   (DATA-TYPE EXP)))
				       STREAM))
				   ;; Make sure the stream is really working
				   (SEND STREAM :FORCE-OUTPUT)
				   (RETURN-FROM PRINT)))))
			 (ERROR
			   ;; Error while printing the substitute p.r., give up
			   (SETQ *PRINT-ERROR* T)
			   NIL)))))
	(UNLESS (AND (NOT RECURSIVE)
		     (MEMQ ':PRINT WHICH-OPERATIONS)	;Allow stream to intercept print operation
		     (FUNCALL STREAM ':PRINT EXP I-PRINDEPTH SLASHIFY-P))
	  (TYPECASE EXP
	    (:FIXNUM
	      (PRINT-FIXNUM-OR-BIGNUM EXP STREAM))
	    (:SYMBOL
	      (PRINT-PNAME-STRING EXP SLASHIFY-P STREAM))
	    (:LIST
	      (IF (AND PRINLEVEL (>= I-PRINDEPTH PRINLEVEL) (NOT PRINT-READABLY))
		  (PRINT-RAW-STRING (PTTBL-PRINLEVEL READTABLE) STREAM)
		(PRINT-LIST EXP I-PRINDEPTH SLASHIFY-P STREAM WHICH-OPERATIONS)))
	    (:ARRAY
	      (IF (LET ((EXP (FOLLOW-STRUCTURE-FORWARDING EXP)))
		    (OR ( (%P-DATA-TYPE EXP) DTP-HEADER-I)
			( (%P-LDB %%HEADER-TYPE-FIELD EXP) %HEADER-TYPE-ARRAY)))
		  (PRINTING-RANDOM-OBJECT (EXP STREAM)
		    (PRINT-RAW-STRING "DTP-ARRAY does not point to array storage" STREAM))
		(LET ((NSS (NAMED-STRUCTURE-P EXP)))
		  (IF NSS
		      (PRINT-STRUCTURE EXP NSS I-PRINDEPTH SLASHIFY-P
				       STREAM WHICH-OPERATIONS)
		    (PRINT-ARRAY-CONTENTS EXP I-PRINDEPTH SLASHIFY-P
					  STREAM NIL WHICH-OPERATIONS)))))
	    (:INSTANCE
	      (IF (AND (NOT (EQL-DISPATCH-INSTANCE-P EXP))
		       (MEMQ ':PRINT-SELF (FUNCALL EXP ':WHICH-OPERATIONS)))
		  (FUNCALL EXP ':PRINT-SELF STREAM I-PRINDEPTH SLASHIFY-P)
		  (PRINTING-RANDOM-OBJECT (EXP STREAM)
		    (SEND STREAM :STRING-OUT (STRING (DATA-TYPE EXP))))))
	    (:FLOAT
	      (PRINT-FLONUM EXP STREAM NIL NIL))
	    #+3600
	    (:EXTENDED-NUMBER
	      (PRINT-EXTENDED-NUMBER EXP STREAM NIL I-PRINDEPTH WHICH-OPERATIONS))
	    #+IMACH
	    (:BIGNUM (PRINT-FIXNUM-OR-BIGNUM EXP STREAM))
	    #+IMACH
	    (:RATIONAL (PRINT-RATIONAL EXP STREAM))
	    #+IMACH
	    (:COMPLEX (PRINT-COMPLEX EXP STREAM))
	    #+IMACH
	    (:DOUBLE-FLOAT (PRINT-FLONUM EXP STREAM))
	    (:CHARACTER
	      (PRINT-CHARACTER EXP STREAM SLASHIFY-P))
	    (:LEXICAL-CLOSURE
	      (PRINT-LEXICAL-CLOSURE EXP STREAM SLASHIFY-P I-PRINDEPTH))
	    (:FUNCALLABLE-INSTANCE
	      (CLOS:PRINT-OBJECT EXP STREAM))
	    (:GENERIC-FUNCTION
	      (LET ((*PRINT-ESCAPE* SLASHIFY-P))
		(IF (CLOS-INTERNALS::GENERIC-FUNCTION-CLOS  EXP)
		    (FUTURE-COMMON-LISP:PRINT-OBJECT EXP STREAM)
		    (SI:PRINT-FUNCTION
		      (GENERIC-FUNCTION-NAME EXP)
		      EXP
		      STREAM))))
	    (:COMPILED-FUNCTION
	      (LET ((*PRINT-ESCAPE* SLASHIFY-P))
		(PRINT-FUNCTION
		  (COMPILED-FUNCTION-NAME-FOR-DEBUGGING EXP)
		  EXP
		  STREAM
		  :TYPE-NAME
		  "Compiled function")))
	    (OTHERWISED,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB") 
0	      (LET ((LAST-DITCH-ATTEMPT (GET (DATA-TYPE EXP) 'PRINT)))
		(COND (LAST-DITCH-ATTEMPT (FUNCALL LAST-DITCH-ATTEMPT EXP I-PRINDEPTH
						   SLASHIFY-P STREAM WHICH-OPERATIONS
						   RECURSIVE))
		      (T (PRINTING-RANDOM-OBJECT (EXP STREAM)
			   (SEND STREAM :STRING-OUT (STRING (DATA-TYPE EXP)))))))))))))
  EXP)

;;; Some control for DW.  This doesn't really make sense as a user
;;; control, nor does the full range of what it does make sense.
(DEFVAR-RESETTABLE *PRINT-SENSITIVE* T T
  "Sensitivity level control.  This provides more control than is needed.
T   = All levels sensitive.
NIL = No levels sensitive.
-N  = Sensitive after N levels.
+N  = Sensitive until N levels.")

(DEFMACRO WITH-SENSITIVITY-FLAG ((OBJECT STREAM) &BODY BODY)
  `(WITH-SENSITIVITY-FLAG-INTERNAL
     (MACROLET ((INVOKE ()
		  `(PROGN ,',@BODY)))
       (IF (NOT (PRINT-SENSITIVE-P))
	   (INVOKE)
	 (DW:WITH-OUTPUT-AS-PRESENTATION (:OBJECT ,OBJECT
					  :TYPE (PRINT-OBJECT-PRESENTATION-TYPE)
					  :STREAM ,STREAM)
	   (INVOKE))))))

(DEFMACRO WITH-SENSITIVITY-FLAG-INTERNAL (&BODY BODY)
  (LET ((OLD-PRINT-SENSITIVE-FLAG (GENSYMBOL "OLD-PRINT-SENSITIVE-FLAG-")))
    `(LET ((,OLD-PRINT-SENSITIVE-FLAG *PRINT-SENSITIVE*))
       (LET-IF (CL:TYPEP ,OLD-PRINT-SENSITIVE-FLAG 'CL:INTEGER)
	       ((*PRINT-SENSITIVE* (CL:ETYPECASE ,OLD-PRINT-SENSITIVE-FLAG
				     ((CL:INTEGER -1 0) T)
				     ((CL:INTEGER 1 1) NIL)
				     ((CL:INTEGER * (1))
				      (1+ ,OLD-PRINT-SENSITIVE-FLAG))
				     ((CL:INTEGER (1))
				      (1- ,OLD-PRINT-SENSITIVE-FLAG)))))
	 (MACROLET ((PRINT-SENSITIVE-P ()
		      `(CL:TYPECASE ,',OLD-PRINT-SENSITIVE-FLAG
			 (CL:(MEMBER T) T)
			 ((OR CL:NULL (CL:INTEGER * 0))
			  NIL)
			 ((CL:INTEGER 1)))))
	   ,@BODY)))))

(DEFUN PRINT-WITH-SENSITIVITY (STREAM EXP I-PRINDEPTH SLASHIFY-P)
  (WITH-SENSITIVITY-FLAG (EXP STREAM)
    (PRINT-OBJECT EXP I-PRINDEPTH SLASHIFY-P STREAM
		  (SEND STREAM :WHICH-OPERATIONS) T))
  T)

(DEFUN GPRINT-WITH-SENSITIVITY (STREAM OBJECT SUGGESTED-FORMAT)
  (WITH-SENSITIVITY-FLAG (OBJECT STREAM)
    (GPRINT:PRINT-OBJECT OBJECT SUGGESTED-FORMAT STREAM T))
  T)


;;; This table is preloaded with the most commonly used presentation types.
;;; We put them all together here in the code to try to minimize the number
;;; of page faults needed to do printing.
;;; 
;;; The contents of this table are reordered in a reordering-task, by a gray code
;;; ordering.  I thought there were performance reasons to use a gray code, but I
;;; was wrong.  But it does leave things in an order that's easy to follow visually,
;;; so we continue to use gray-code ordering.
;;;
;;; It would be a good idea to regenerate this list whenever 1cli::*write-keywords*0 changes.
;;;
;;; This list was generated by doing, in a Dynamic Lisp Listener:
;;; 1(clrhash si:*print-object-presentation-types-table*)
0;;; pointing the mouse at an expression
;;; Doing c-m-Suspend
;;; m-L
;;; c-m-A
;;; Resume
;;; ... and otherwise using the system for a while.
;;; and then going to the editor, with this editor buffer and doing
;;; m-X Evaluate Into Buffer
;;; 1(list-object-presentation-types)
0;;; to get the list for 1*initial-print-object-presentation-types*
0;;; Actually, if you do 1`(defun foo () (,(list-object-presentation-types)))
0;;; it will indent it nicer, and you can edit the result.
1;;; Be sure to do it in this buffer, where the base is 8.
0(DEFVAR *PRINT-OBJECT-PRESENTATION-TYPES-TABLE* NIL)

;;; Weak lock.  We store-conditional into it, and if we get it, we have permission
;;; to store.
(DEFVAR-RESETTABLE *PRINT-OBJECT-PRESENTATION-TYPES-LOCK* NIL NIL)

;;; Get the current list.

(DEFUN LIST-OBJECT-PRESENTATION-TYPES ()
  (DECLARE (VALUES TYPES))			;---someday return data-types, too?
  (SORT-PRINT-OBJECT-PRESENTATION-TYPES
    (GET-PRINT-OBJECT-PRESENTATION-TYPE-TABLE)))

;;; The initial list, to preload the cache and get them all consed together.
(DEFVAR *INITIAL-PRINT-OBJECT-PRESENTATION-TYPES*
  '(((EXPRESSION))
    ((EXPRESSION) :ARRAY NIL :READABLY NIL)
    ((EXPRESSION) :ARRAY NIL :READABLY NIL :STRUCTURE-CONTENTS NIL)
    ((EXPRESSION) :CASE :DOWNCASE :ARRAY NIL :READABLY NIL)
    ((EXPRESSION) :LENGTH 3 :ARRAY NIL :READABLY NIL)
    ((EXPRESSION) :LENGTH 3 :ARRAY NIL :READABLY NIL :STRUCTURE-CONTENTS NIL)
    ((EXPRESSION) :LEVEL 1 :LENGTH 4 :ARRAY NIL :READABLY NIL)
    ((EXPRESSION) :LEVEL 2 :LENGTH 4 :ARRAY NIL :READABLY NIL)
    ((EXPRESSION) :LEVEL 2 :LENGTH 5 :ARRAY NIL :READABLY NIL)
    ((EXPRESSION) :LEVEL 4 :LENGTH 10 :ARRAY NIL :READABLY NIL)
    ((EXPRESSION) :LEVEL 2 :LENGTH 3 :ARRAY NIL :READABLY NIL :STRUCTURE-CONTENTS NIL)
    ((EXPRESSION) :LEVEL 2 :LENGTH 4 :ARRAY NIL :READABLY NIL :STRUCTURE-CONTENTS NIL)
    ((EXPRESSION) :LEVEL 2 :LENGTH 5 :ARRAY NIL :READABLY NIL :STRUCTURE-CONTENTS NIL)
    ((EXPRESSION) :BASE 10)
    ((EXPRESSION) :BASE 10 :ARRAY NIL :READABLY NIL)
    ((EXPRESSION) :BASE 10 :ARRAY NIL :READABLY NIL :STRUCTURE-CONTENTS NIL)
    ((EXPRESSION) :BASE 10 :CASE :DOWNCASE :ARRAY NIL :READABLY NIL)
    ((EXPRESSION) :BASE 10 :LENGTH 3 :ARRAY NIL :READABLY NIL)
    ((EXPRESSION) :BASE 10 :LENGTH 3 :ARRAY NIL :READABLY NIL :STRUCTURE-CONTENTS NIL)
    ((EXPRESSION) :BASE 10 :LEVEL 1 :LENGTH 4 :ARRAY NIL :READABLY NIL)
    ((EXPRESSION) :BASE 10 :LEVEL 2 :LENGTH 4 :ARRAY NIL :READABLY NIL)
    ((EXPRESSION) :BASE 10 :LEVEL 2 :LENGTH 5 :ARRAY NIL :READABLY NIL)
    ((EXPRESSION) :BASE 10 :LEVEL 4 :LENGTH 10 :ARRAY NIL :READABLY NIL)
    ((EXPRESSION) :BASE 10 :LEVEL 2 :LENGTH 3 :ARRAY NIL :READABLY NIL :STRUCTURE-CONTENTS NIL)
    ((EXPRESSION) :BASE 10 :LEVEL 2 :LENGTH 4 :ARRAY NIL :READABLY NIL :STRUCTURE-CONTENTS NIL)
    ((EXPRESSION) :BASE 10 :LEVEL 2 :LENGTH 5 :ARRAY NIL :READABLY NIL :STRUCTURE-CONTENTS NIL)
    ((EXPRESSION) :RADIX T :BASE 10 :LEVEL 3 :LENGTH 3 :READABLY NIL)
    ((EXPRESSION) :RADIX T :LEVEL 3 :LENGTH 3 :READABLY NIL)
    ((EXPRESSION) :ABBREVIATE-QUOTE T :ARRAY NIL :READABLY NIL)
    ((EXPRESSION) :ABBREVIATE-QUOTE T :LEVEL 2 :LENGTH 4 :ARRAY NIL :READABLY NIL)
    ((EXPRESSION) :ABBREVIATE-QUOTE T :LEVEL 2 :LENGTH 3 :ARRAY NIL :READABLY NIL
     :STRING-LENGTH 36 :STRUCTURE-CONTENTS NIL)
    ((EXPRESSION) :ABBREVIATE-QUOTE T :BASE 10 :ARRAY NIL :READABLY NIL)
    ((EXPRESSION) :ABBREVIATE-QUOTE T :BASE 10 :ARRAY NIL :READABLY NIL :STRUCTURE-CONTENTS
     NIL)
    ((EXPRESSION) :ABBREVIATE-QUOTE T :BASE 10 :LEVEL 2 :LENGTH 4 :ARRAY NIL :READABLY NIL)
    ((EXPRESSION) :ABBREVIATE-QUOTE T :BASE 10 :LEVEL 2 :LENGTH 3 :ARRAY NIL :READABLY NIL
     :STRING-LENGTH 36 :STRUCTURE-CONTENTS NIL)
    ((EXPRESSION) :PRETTY T :ABBREVIATE-QUOTE T :ARRAY NIL :READABLY NIL)
    ((EXPRESSION) :PRETTY T :ABBREVIATE-QUOTE T :ARRAY NIL :READABLY NIL :STRUCTURE-CONTENTS
     NIL)
    ((EXPRESSION) :PRETTY T :ABBREVIATE-QUOTE BACKQUOTE :CASE :DOWNCASE :ARRAY NIL :READABLY
     NIL :STRUCTURE-CONTENTS NIL)
    ((EXPRESSION) :PRETTY T :ABBREVIATE-QUOTE T :BASE 10 :ARRAY NIL :READABLY NIL)
    ((EXPRESSION) :PRETTY T :ABBREVIATE-QUOTE T :BASE 10 :ARRAY NIL :READABLY NIL
     :STRUCTURE-CONTENTS NIL)
    ((EXPRESSION) :PRETTY T :ABBREVIATE-QUOTE BACKQUOTE :BASE 10 :ARRAY NIL :READABLY NIL
     :STRUCTURE-CONTENTS NIL)
    ((EXPRESSION) :PRETTY T :ABBREVIATE-QUOTE BACKQUOTE :BASE 10 :CASE :DOWNCASE :ARRAY NIL
     :READABLY NIL :STRUCTURE-CONTENTS NIL)
    ((EXPRESSION) :PRETTY T :ARRAY NIL :READABLY NIL)
    ((EXPRESSION) :PRETTY :DATA :ARRAY NIL :READABLY NIL)
    ((EXPRESSION) :PRETTY T :ARRAY NIL :READABLY NIL :STRUCTURE-CONTENTS NIL)
    ((EXPRESSION) :PRETTY :DATA :ARRAY NIL :READABLY NIL :STRUCTURE-CONTENTS NIL)
    ((EXPRESSION) :PRETTY T :CASE :DOWNCASE :ARRAY NIL :READABLY NIL)
    ((EXPRESSION) :PRETTY T :LENGTH 3 :ARRAY NIL :READABLY NIL)
    ((EXPRESSION) :PRETTY T :LEVEL 2 :LENGTH 4 :ARRAY NIL :READABLY NIL)
    ((EXPRESSION) :PRETTY T :LEVEL 2 :LENGTH 5 :ARRAY NIL :READABLY NIL)
    ((EXPRESSION) :PRETTY T :LEVEL 4 :LENGTH 10 :ARRAY NIL :READABLY NIL)
    ((EXPRESSION) :PRETTY T :LEVEL 1 :LENGTH 4 :ARRAY NIL :READABLY NIL :STRUCTURE-CONTENTS
     NIL)
    ((EXPRESSION) :PRETTY T :LEVEL 2 :LENGTH 4 :ARRAY NIL :READABLY NIL :STRUCTURE-CONTENTS
     NIL)
    ((EXPRESSION) :PRETTY T :BASE 10 :ARRAY NIL :READABLY NIL)
    ((EXPRESSION) :PRETTY :DATA :BASE 10 :ARRAY NIL :READABLY NIL)
    ((EXPRESSION) :PRETTY T :BASE 2 :ARRAY NIL :READABLY NIL :STRUCTURE-CONTENTS NIL)
    ((EXPRESSION) :PRETTY T :BASE 10 :ARRAY NIL :READABLY NIL :STRUCTURE-CONTENTS NIL)
    ((EXPRESSION) :PRETTY :DATA :BASE 10 :ARRAY NIL :READABLY NIL :STRUCTURE-CONTENTS NIL)
    ((EXPRESSION) :PRETTY T :BASE 10 :CASE :DOWNCASE :ARRAY NIL :READABLY NIL)
    ((EXPRESSION) :PRETTY T :BASE 10 :LENGTH 3 :ARRAY NIL :READABLY NIL)
    ((EXPRESSION) :PRETTY T :BASE 10 :LEVEL 2 :LENGTH 4 :ARRAY NIL :READABLY NIL)
    ((EXPRESSION) :PRETTY T :BASE 10 :LEVEL 2 :LENGTH 5 :ARRAY NIL :READABLY NIL)
    ((EXPRESSION) :PRETTY T :BASE 10 :LEVEL 4 :LENGTH 10 :ARRAY NIL :READABLY NIL)
    ((EXPRESSION) :PRETTY T :BASE 10 :LEVEL 1 :LENGTH 4 :ARRAY NIL :READABLY NIL
     :STRUCTURE-CONTENTS NIL)
    ((EXPRESSION) :PRETTY T :BASE 10 :LEVEL 2 :LENGTH 4 :ARRAY NIL :READABLY NIL
     :STRUCTURE-CONTENTS NIL)
    ((EXPRESSION) :PRETTY T :RADIX T :BASE 10 :READABLY NIL)
    ((EXPRESSION) :PRETTY T :RADIX T :BASE 10 :READABLY NIL :STRUCTURE-CONTENTS NIL)
    ((EXPRESSION) :PRETTY T :RADIX T :BASE 10 :LEVEL 3 :LENGTH 3 :READABLY NIL)
    ((EXPRESSION) :PRETTY T :RADIX T :BASE 10 :LEVEL 3 :LENGTH 3 :READABLY NIL
     :STRUCTURE-CONTENTS NIL)
    ((EXPRESSION) :PRETTY :DATA :RADIX T :BASE 10 :LEVEL 3 :LENGTH 3 :READABLY NIL
     :STRUCTURE-CONTENTS NIL)
    ((EXPRESSION) :PRETTY T :RADIX T :READABLY NIL)
    ((EXPRESSION) :PRETTY T :RADIX T :LEVEL 3 :LENGTH 3 :READABLY NIL)
    ((EXPRESSION) :ESCAPE NIL :PRETTY T :ABBREVIATE-QUOTE BACKQUOTE :ARRAY NIL :READABLY NIL
     :STRUCTURE-CONTENTS NIL)
    ((EXPRESSION) :ESCAPE NIL :PRETTY T :ABBREVIATE-QUOTE BACKQUOTE :BASE 10 :ARRAY NIL
     :READABLY NIL :STRUCTURE-CONTENTS NIL)
    ((EXPRESSION) :ESCAPE NIL :PRETTY T :ARRAY NIL :READABLY NIL)
    ((EXPRESSION) :ESCAPE NIL :PRETTY :DATA :ARRAY NIL :READABLY NIL)
    ((EXPRESSION) :ESCAPE NIL :PRETTY T :ARRAY NIL :READABLY NIL :STRUCTURE-CONTENTS NIL)
    ((EXPRESSION) :ESCAPE NIL :PRETTY :DATA :ARRAY NIL :READABLY NIL :STRUCTURE-CONTENTS NIL)
    ((EXPRESSION) :ESCAPE NIL :PRETTY T :LEVEL 2 :LENGTH 4 :ARRAY NIL :READABLY NIL)
    ((EXPRESSION) :ESCAPE NIL :PRETTY T :LEVEL 2 :LENGTH 4 :ARRAY NIL :READABLY NIL
     :STRUCTURE-CONTENTS NIL)
    ((EXPRESSION) :ESCAPE NIL :PRETTY T :BASE 10 :ARRAY NIL :READABLY NIL)
    ((EXPRESSION) :ESCAPE NIL :PRETTY :DATA :BASE 10 :ARRAY NIL :READABLY NIL)
    ((EXPRESSION) :ESCAPE NIL :PRETTY T :BASE 10 :ARRAY NIL :READABLY NIL :STRUCTURE-CONTENTS
     NIL)
    ((EXPRESSION) :ESCAPE NIL :PRETTY :DATA :BASE 10 :ARRAY NIL :READABLY NIL
     :STRUCTURE-CONTENTS NIL)
    ((EXPRESSION) :ESCAPE NIL :PRETTY T :BASE 10 :LEVEL 2 :LENGTH 4 :ARRAY NIL :READABLY NIL)
    ((EXPRESSION) :ESCAPE NIL :PRETTY T :BASE 10 :LEVEL 2 :LENGTH 4 :ARRAY NIL :READABLY NIL
     :STRUCTURE-CONTENTS NIL)
    ((EXPRESSION) :ESCAPE NIL :PRETTY T :BASE 10 :LEVEL 2 :LENGTH 5 :ARRAY NIL :READABLY NIL
     :STRUCTURE-CONTENTS NIL)
    ((EXPRESSION) :ESCAPE NIL :PRETTY :DATA :RADIX T :BASE 10 :LEVEL 3 :LENGTH 3 :READABLY NIL
     :STRUCTURE-CONTENTS NIL)
    ((EXPRESSION) :ESCAPE NIL :ARRAY NIL :READABLY NIL)
    ((EXPRESSION) :ESCAPE NIL :ARRAY NIL :READABLY NIL :STRUCTURE-CONTENTS NIL)
    ((EXPRESSION) :ESCAPE NIL :CASE :DOWNCASE :ARRAY NIL :READABLY NIL)
    ((EXPRESSION) :ESCAPE NIL :LENGTH 3 :ARRAY NIL :READABLY NIL)
    ((EXPRESSION) :ESCAPE NIL :LEVEL 2 :LENGTH 4 :ARRAY NIL :READABLY NIL)
    ((EXPRESSION) :ESCAPE NIL :LEVEL 2 :LENGTH 5 :ARRAY NIL :READABLY NIL)
    ((EXPRESSION) :ESCAPE NIL :LEVEL 4 :LENGTH 10 :ARRAY NIL :READABLY NIL)
    ((EXPRESSION) :ESCAPE NIL :BASE 10 :ARRAY NIL :READABLY NIL)
    ((EXPRESSION) :ESCAPE NIL :BASE 10 :ARRAY NIL :READABLY NIL :STRUCTURE-CONTENTS NIL)
    ((EXPRESSION) :ESCAPE NIL :BASE 10 :CASE :DOWNCASE :ARRAY NIL :READABLY NIL)
    ((EXPRESSION) :ESCAPE NIL :BASE 10 :LENGTH 3 :ARRAY NIL :READABLY NIL)
    ((EXPRESSION) :ESCAPE NIL :BASE 10 :LEVEL 2 :LENGTH 4 :ARRAY NIL :READABLY NIL)
    ((EXPRESSION) :ESCAPE NIL :BASE 10 :LEVEL 2 :LENGTH 5 :ARRAY NIL :READABLY NIL)
    ((EXPRESSION) :ESCAPE NIL :BASE 10 :LEVEL 4 :LENGTH 10 :ARRAY NIL :READABLY NIL)
    ((EXPRESSION) :ESCAPE NIL :RADIX T :BASE 10 :READABLY NIL)
    ((EXPRESSION) :ESCAPE NIL :RADIX T :BASE 10 :LEVEL 3 :LENGTH 3 :READABLY NIL)
    ((EXPRESSION) :ESCAPE NIL :RADIX T :READABLY NIL)
    ((EXPRESSION) :ESCAPE NIL :RADIX T :LEVEL 3 :LENGTH 3 :READABLY NIL)
    ((EXPRESSION) :ESCAPE NIL :ABBREVIATE-QUOTE T :ARRAY NIL :READABLY NIL)
    ((EXPRESSION) :ESCAPE NIL :ABBREVIATE-QUOTE T :BASE 10 :ARRAY NIL :READABLY NIL)
    ((EXPRESSION) :ESCAPE NIL :ABBREVIATE-QUOTE T :BASE 10 :LEVEL 2 :LENGTH 3 :ARRAY NIL
     :READABLY NIL :STRING-LENGTH 36 :STRUCTURE-CONTENTS NIL)))


(DEFUN INITIALIZE-PRINT-OBJECT-PRESENTATION-TYPE-TABLE
       (&OPTIONAL (TYPES *INITIAL-PRINT-OBJECT-PRESENTATION-TYPES*))
  (SETQ *PRINT-OBJECT-PRESENTATION-TYPES-TABLE*
	(CL:MAKE-HASH-TABLE :TEST 'CL:EQUAL :LOCKING NIL :STORE-HASH-CODE T
			    :SIZE 200. :REHASH-AFTER-FULL-GC T))
  (SETQ TYPES (SORT-PRINT-OBJECT-PRESENTATION-TYPES (COPYLIST TYPES)))
  (LOOP WITH EXP = (COPYLIST '(EXPRESSION) PERMANENT-STORAGE-AREA)
	FOR TY IN TYPES
	DO (SETQ TY (COPYLIST TY PERMANENT-STORAGE-AREA))
	   (SETF (CAR TY) EXP)
	   (SETF (GETHASH TY *PRINT-OBJECT-PRESENTATION-TYPES-TABLE*) TY)))

;;; I always wondered how gray codes were computed.  I've long been able to
;;; generate them sequentially, without understanding how.  There is a puzzle
;;; toy involving moving these 8 levers in a gray-code sequence, that I just
;;; whiz through, but I've never been able to explain to anyone how they're
;;; actually generated.
;;; 
;;; So I finally sat down and figured out an algorithm:
;;; 
;;; Each bit (2 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")i0 goes through a cycle of length 1(lsh 4 2i1)0, half on, then half off.
;;; Each bit 2i0's cycle is offset by 1(lsh 1 2i1)0, that is, the first 1 bit starts
;;;   with that number.
;;; Adding 2n0 to the offset yields 22n0 when 2n0 = the offset for that bit.  Thus,
;;;   since the offsets are powers of 2, we can pick up the start of the cycle
;;;   by where we first carry into the offset+1 bit.
;;; We then 1mod0 by the cycle length to get the value for that particular bit.
;;; 
;;; But this isn't how *I* do it.  I just know the pattern to toggling bits,
;;; but I've never been able to explain it.  Oh, well!  --RWK
;;; 
;;; Yow!  A little work at the whiteboard produces a stunning breakthrough.  --SWM&RWK
;;;
;;; PS:  This is used to group similar presentation types together in memory.
;;; It is an interesting problem to sort things so that the most similar are
;;; the closest, but that's far too hard.

#||
(defun show-gray-codes (&optional (limit 32.))
  (cl:fresh-line)
  (dw:formatting-table ()
    (loop for i below limit do
      (dw:formatting-row ()
	(dw:formatting-cell (t :align-x :right)
	  (cl:write i :base 10))
	(dw:formatting-cell (t :align-x :right)
	  (cl:write i :base 2))
	(dw:formatting-cell (t :align-x :right)
	  (cl:write (gray-code i) :base 2))
	(dw:formatting-cell (t :align-x :right)
	  (cl:write (gray-code-old i) :base 2))))))
||#

#||
(DEFUN GRAY-CODE-old (N)
  (LOOP WITH CODE = 0
	FOR I BELOW (CL:INTEGER-LENGTH N)
	FOR M = (MOD (+ N (LSH 1 I)) (LSH 4 I))
	FOR B = (LSH M (- -1 I))
	DO (WHEN (> B 1) (DBG))
	DO #+IGNORE (SETF (LDB (BYTE 1 I) CODE) B)	;Compiles poorly
	   (SETF CODE (LOGIOR CODE (LSH (LOGAND B 1) I)))
	FINALLY (RETURN CODE)))
||#

;; Here is the unbelievably more elegant version of the above.
(DEFUN GRAY-CODE (N)
  (LOGXOR N (LSH N -1)))

(DEFUN SORT-PRINT-OBJECT-PRESENTATION-TYPES (TYPES)
  (LABELS ((KEY-WEIGHT (TYPE)
		       (DECLARE (SYS:DOWNWARD-FUNCTION))
		       (LOOP WITH WEIGHT = 0
			     WITH LENGTH = (LENGTH CLI::*WRITE-KEYWORDS*)
			     FOR (KEY VAL) ON (CDR TYPE) BY 'CDDR
			     DO
			 (IGNORE VAL)
			 (SETF (LDB (BYTE 1 (- (1+ LENGTH)
					       (OR (CL:POSITION KEY CLI::*WRITE-KEYWORDS*
								:KEY #'CAR)
						   (1+ LENGTH))))
				    WEIGHT)
			       1)
			     FINALLY (RETURN WEIGHT)))
	   ;; Only called after we've determined that these have the same keys.
	   (VAL-LESSP (T1 T2)
	     (DECLARE (SYS:DOWNWARD-FUNCTION))
	     (LOOP FOR (K1 V1) ON (CDR T1) BY 'CDDR
		   FOR (K2 V2) ON (CDR T2) BY 'CDDR
		   DO (IGNORE K1 K2)
		   THEREIS (OR (< (%DATA-TYPE V1) (%DATA-TYPE V2))
			       (%POINTER-LESSP V1 V2))
		   NEVER (OR (< (%DATA-TYPE V2) (%DATA-TYPE V1))
			     (%POINTER-LESSP V2 V1))))
	   (KEY-LESSP (T1 T2)
	     (LET ((W1 (GRAY-CODE (KEY-WEIGHT T1)))
		   (W2 (GRAY-CODE (KEY-WEIGHT T2))))
	       (OR (< W1 W2)
		   (AND (= W1 W2)
			(VAL-LESSP T1 T2))))))
      (SORT TYPES #'KEY-LESSP)))

(DEFUN GET-PRINT-OBJECT-PRESENTATION-TYPE-TABLE ()
  (DECLARE (VALUES TYPES DATA-TYPES))
  (LET* ((DATA-TYPES)				;Should be just one, but may have been patched.
	 (TYPES)
	 (EARLIER-FLAGS
	   (CDR (MEMBER :BASE (NREVERSE (MAPCAR #'CAR CLI::*WRITE-KEYWORDS*))))))
    (LABELS ((ADD-OTHER-TYPES (KEY TYPE)
	       (DECLARE (SYS:DOWNWARD-FUNCTION))
	       (IGNORE KEY)
	       (LET* ((FLAG '(FLAG))
		      (PROP-P (EQ FLAG (GETF (CDR TYPE) :STRUCTURE-CONTENTS FLAG))))
		 (WHEN PROP-P
		   ;; We special-case 1:structure-contents0 since I do data-collection with
		   ;; that disabled.  Make sure that people with the default get the same
		   ;; benefits.
		   (CHECK-OTHER-TYPE
		     (LIST* (CAR TYPE)
			    (LOOP FOR (KEY VAL) ON (CDR TYPE) BY 'CDDR
				  UNLESS (EQ KEY :STRUCTURE-CONTENTS)
				    COLLECT KEY
				    AND COLLECT VAL))))
		 ;; Make sure that editing a base 8 buffer gets everything base 10 does.
		 (UNLESS (EQL (GETF (CDR TYPE) :BASE) 8.)
		   (CHECK-OTHER-TYPE
		     (MAKE-8-TYPE TYPE)))))
	     ;; Make a type like this one but with a 1:base0 180 in the right spot.
	     (MAKE-8-TYPE (TYPE)
	       (LIST* (CAR TYPE)
		      (LOOP WITH SO-FAR
			    FOR (KEY VAL . REST) ON (CDR TYPE) BY 'CDDR
			    DO
			(COND ((EQ KEY :BASE))	;Do nothing now, we'll insert later
			      ((MEMQ KEY EARLIER-FLAGS)
			       (SETQ SO-FAR
				     (APPEND SO-FAR
					     (LIST* KEY VAL NIL))))
			      (T (RETURN
				   (APPEND SO-FAR '(:BASE 8.) (LIST* KEY VAL REST)))))
			    FINALLY (RETURN (APPEND SO-FAR '(:BASE 8.))))))
	     (CHECK-OTHER-TYPE (OTHER-TYPE)
	       (OR (GETHASH OTHER-TYPE *PRINT-OBJECT-PRESENTATION-TYPES-TABLE*)
		   ;; Be careful -- this is called with 1default-cons-area0 bound to a
		   ;; temporary area!
		   (LET ((OTHER-TYPE (COPYLIST OTHER-TYPE PERMANENT-STORAGE-AREA)))
		     (SETF (GETHASH OTHER-TYPE *PRINT-OBJECT-PRESENTATION-TYPES-TABLE*)
			   OTHER-TYPE))))
	     (COLLECT-TYPES (KEY VAL)
	       (DECLARE (SYS:DOWNWARD-FUNCTION))
	       (IGNORE KEY)
	       (CL:PUSHNEW (CAR VAL) DATA-TYPES :TEST #'EQ)
	       (PUSH VAL TYPES)))
      (MAPHASH #'ADD-OTHER-TYPES SI:*PRINT-OBJECT-PRESENTATION-TYPES-TABLE*)
      (MAPHASH #'COLLECT-TYPES SI:*PRINT-OBJECT-PRESENTATION-TYPES-TABLE*)
      (VALUES TYPES DATA-TYPES))))

(DEFMACRO WITH-PRINT-OBJECT-PRESENTATION-TYPE-LIST
	  ((LIST TABLE) &BODY BODY)
  ;; Build up a stack list of keywords and values for variables in the
  ;; table that don't have their default values.  Compile-time value of the
  ;; variable TABLE is open-coded into the resulting code.
  ;; Don't make any variable bindings in BODY!
  `(LET ((,LIST 0))
     ,@(LOOP FOR (KEYWORD VARIABLE NIL DEFAULT-VALUE) IN (SYMEVAL TABLE)
	     APPEND `((UNLESS (EQL ,VARIABLE ',DEFAULT-VALUE)
			(%PUSH ',KEYWORD)
			(%PUSH ,VARIABLE)
			(INCF ,LIST))))
     (SETQ ,LIST (AND (PLUSP ,LIST) (SYS:%FINISH-STACK-LIST (+ ,LIST ,LIST -1))))
     ,@BODY))

(DEFVAR *PRINT-OBJECT-PRESENTATION-TYPE-CACHE-CACHE* NIL)

(DEFUN PRINT-OBJECT-PRESENTATION-TYPE ()
  (LET ((OK-TO-STORE NIL)
	(CANONICAL-COPY)
	(TEST-TYPE))
    (UNWIND-PROTECT
	;; Introduce no new variables after this point!
	(WITH-PRINT-OBJECT-PRESENTATION-TYPE-LIST (EXCEPTIONS CLI::*WRITE-KEYWORDS*)
	  (%PUSH '(EXPRESSION))
	  (%PUSH EXCEPTIONS)
	  (SETQ TEST-TYPE (%FINISH-STACK-LIST* 1))
	  ;; A one-level cache before going to the table.
	  ;; It is not interlocked, since it doesn't matter who stores into it.
	  (IF (EQUAL TEST-TYPE *PRINT-OBJECT-PRESENTATION-TYPE-CACHE-CACHE*)
	      *PRINT-OBJECT-PRESENTATION-TYPE-CACHE-CACHE*
	    (SETQ OK-TO-STORE
		  (STORE-CONDITIONAL (LOCF *PRINT-OBJECT-PRESENTATION-TYPES-LOCK*)
				     NIL CURRENT-PROCESS))
	    (WHEN *PRINT-OBJECT-PRESENTATION-TYPES-TABLE*
	      (SETQ CANONICAL-COPY (GETHASH TEST-TYPE
					    *PRINT-OBJECT-PRESENTATION-TYPES-TABLE*)))
	    (IF CANONICAL-COPY
		(SETF *PRINT-OBJECT-PRESENTATION-TYPE-CACHE-CACHE* CANONICAL-COPY)
	      (SETF CANONICAL-COPY
		    (COPYLIST TEST-TYPE PERMANENT-STORAGE-AREA))
	      (WHEN OK-TO-STORE
		(SETF *PRINT-OBJECT-PRESENTATION-TYPE-CACHE-CACHE* CANONICAL-COPY)
		(WHEN *PRINT-OBJECT-PRESENTATION-TYPES-TABLE*
		  (SETF (GETHASH CANONICAL-COPY *PRINT-OBJECT-PRESENTATION-TYPES-TABLE*)
			CANONICAL-COPY))))
	    CANONICAL-COPY))
      (WHEN OK-TO-STORE
	(SETQ *PRINT-OBJECT-PRESENTATION-TYPES-LOCK* NIL)))))


(DEFUN PRINT-WITH-QUOTE-ABBREVIATED (EXP STREAM CONTINUE-FUN REALLY-PRINT-LIST-FUN)
  (DECLARE (DOWNWARD-FUNARG CONTINUE-FUN REALLY-PRINT-LIST-FUN))
  (MACROLET ((CONTINUE (EXP) `(FUNCALL CONTINUE-FUN ,EXP))
	     (REALLY-PRINT-LIST () `(FUNCALL REALLY-PRINT-LIST-FUN))
	     (MAYBE-PRINT-OBJECT ((CHAR &KEY EXACTLY-TWO MACRO-FUN MACRO-#-FUN)
				  &BODY BODY)
	       (WHEN (OR MACRO-FUN MACRO-#-FUN)
		 (SETQ BODY
		       `((LET ((,CHAR (CAR (RASSOC ,(OR MACRO-FUN MACRO-#-FUN)
						   (,(IF MACRO-FUN
							 'RDTBL-MACRO-ALIST
						       'RDTBL-#-MACRO-ALIST)
						    READTABLE)))))
			   (IF (NOT ,CHAR)
			       (REALLY-PRINT-LIST)
			     ,@BODY)))))
	       (WHEN EXACTLY-TWO
		 (SETQ BODY
		       `((IF (OR (ATOM (CDR EXP))
				 (NOT (NULL (CDDR EXP))))
			     (CONTINUE (SECOND EXP))
			   ,@BODY))))
	       `(PROGN ,@BODY)))
    (LABELS ((CONTINUE-BACKQUOTE (STRING)
	       (IF (NEQ SCL:*PRINT-ABBREVIATE-QUOTE* 'BACKQUOTE)
		   (REALLY-PRINT-LIST)
		 (SEND STREAM :STRING-OUT STRING)
		 (CONTINUE (CDR EXP)))))
      (SELECTQ (CAR EXP)
	(QUOTE
	 (MAYBE-PRINT-OBJECT (CHAR :EXACTLY-TWO T :MACRO-FUN 'XR-QUOTE-MACRO)
			     (SEND STREAM :TYO CHAR)
			     (CONTINUE (SECOND EXP))))
	(FUNCTION
	 (MAYBE-PRINT-OBJECT (CHAR :EXACTLY-TWO T :MACRO-#-FUN '|XR-#'-MACRO|)
			     (SEND STREAM :TYO #\#)
			     (SEND STREAM :TYO CHAR)
			     (CONTINUE (SECOND EXP))))
	((XR-BQ-CONS XR-BQ-LIST XR-BQ-LIST* XR-BQ-APPEND XR-BQ-NCONC)
	 (MAYBE-PRINT-OBJECT (CHAR :MACRO-FUN 'XR-BACKQUOTE-MACRO)
			     (LET ((NEW-EXPRESSION (GPRINT::UNBACKQUOTIFY EXP))
				   (SCL:*PRINT-ABBREVIATE-QUOTE* 'BACKQUOTE))
			       (SEND STREAM :TYO #\`)
			       (CONTINUE NEW-EXPRESSION))))
	(GPRINT::COMMA (CONTINUE-BACKQUOTE ","))
	(GPRINT::COMMA-ATSIGN (CONTINUE-BACKQUOTE ",@"))
	(GPRINT::COMMA-DOT (CONTINUE-BACKQUOTE ",."))
	(GPRINT::DOT-COMMA (CONTINUE-BACKQUOTE ".,"))
	(OTHERWISE (REALLY-PRINT-LIST))))))

;Print a list, hacking prinlength and prinlevel.
(DEFUN PRINT-LIST (EXP I-PRINDEPTH SLASHIFY-P STREAM WHICH-OPERATIONS)
  (LABELS ((REALLY-PRINT-LIST ()
	     (FUNCALL STREAM ':TYO (PTTBL-OPEN-PAREN READTABLE))
	     (DO ((I-PRINLENGTH 1 (1+ I-PRINLENGTH))
		  (FIRST T NIL))
		 ((ATOM EXP)
		  (COND ((NOT (NULL EXP))
			 (PRINT-RAW-STRING (PTTBL-CONS-DOT READTABLE) STREAM)
			 (PRINT-OBJECT EXP (1+ I-PRINDEPTH) SLASHIFY-P STREAM WHICH-OPERATIONS)))
		  (FUNCALL STREAM ':TYO (PTTBL-CLOSE-PAREN READTABLE)))
	       (OR FIRST (FUNCALL STREAM ':TYO (PTTBL-SPACE READTABLE)))
	       (PRINT-OBJECT (CAR EXP) (1+ I-PRINDEPTH) SLASHIFY-P STREAM WHICH-OPERATIONS)
	       (SETQ EXP (CDR EXP))
	       (WHEN (AND PRINLENGTH
			  (>= I-PRINLENGTH PRINLENGTH)	;One frob gets printed before test.
			  (NOT PRINT-READABLY)
			  (NOT (ATOM EXP)))	;Don't do it uselessly
		 (RETURN (PRINT-RAW-STRING (PTTBL-PRINLENGTH READTABLE) STREAM))))))
    (IF (OR (NOT SCL:*PRINT-ABBREVIATE-QUOTE*)
	    (ATOM EXP)			;Just in case.
	    (NOT (SYMBOLP (CAR EXP))))
	(REALLY-PRINT-LIST)
      (LABELS ((CONTINUE (NEW-EXP)
		 (PRINT-OBJECT NEW-EXP I-PRINDEPTH SLASHIFY-P STREAM WHICH-OPERATIONS)))
	(PRINT-WITH-QUOTE-ABBREVIATED EXP STREAM #'CONTINUE #'REALLY-PRINT-LIST)))))

(DEFUN PRINT-STRUCTURE (EXP NSS I-PRINDEPTH SLASHIFY-P STREAM WHICH-OPERATIONS)
  (IF (AND PRINLEVEL ( I-PRINDEPTH PRINLEVEL) (NOT PRINT-READABLY))
      (PRINT-RAW-STRING (PTTBL-PRINLEVEL READTABLE) STREAM)
      (IF (AND (GET NSS 'NAMED-STRUCTURE-INVOKE)
	       (MEMQ :PRINT-SELF (NAMED-STRUCTURE-INVOKE EXP :WHICH-OPERATIONS)))
	  (NAMED-STRUCTURE-INVOKE EXP :PRINT-SELF STREAM I-PRINDEPTH SLASHIFY-P)
	  (IF (AND (NAMED-STRUCTURE-P EXP)
		   (PRINT-COMMON-LISP-P)
		   (OR PRINT-READABLY SCL:*PRINT-STRUCTURE-CONTENTS*))

	      (PROGN
		(PRINT-RAW-STRING "#S" STREAM)
		(PRINT-LIST (LIST* NSS (SI:GET-STRUCTURE-INIT-LIST EXP))
			    I-PRINDEPTH SLASHIFY-P STREAM WHICH-OPERATIONS))

	      (PRINTING-RANDOM-OBJECT (EXP STREAM)
		(PRINT-RAW-STRING (GET-PNAME NSS) STREAM))))))


(DEFUN PRINT-CL-STRUCTURE (OBJECT STREAM DEPTH)
  (MULTIPLE-VALUE-BIND (INIT-LIST STRUCTURE-NAME)
      (SI:GET-STRUCTURE-INIT-LIST OBJECT)
    (UNLESS STRUCTURE-NAME
      (FERROR "~S is not a Common Lisp structure." OBJECT))
    (PRINT-RAW-STRING "#S" STREAM)
    (PRINT-LIST (LIST* STRUCTURE-NAME INIT-LIST)
		DEPTH T STREAM (SEND STREAM :WHICH-OPERATIONS))))

;; this next suffers from the fact that the description won't be there until after 
;; the defstruct is compiled. So its utility is limited. This really needs to be
;; a defstruct feature.

(DEFMACRO CL-STRUCTURE-PRINTER (STRUCTURE-NAME OBJECT STREAM DEPTH)
  (LET* ((DESCRIPTION (GET STRUCTURE-NAME 'DEFSTRUCT-DESCRIPTION))
	 (SLOT-LIST (LOOP FOR (SLOT . PLIST)
			      IN (DEFSTRUCT-DESCRIPTION-SLOT-ALIST DESCRIPTION)
			  COLLECT (INTERN (GET-PNAME SLOT) PKG-KEYWORD-PACKAGE)
			  COLLECT `(,(DEFSTRUCT-SLOT-DESCRIPTION-REF-MACRO-NAME PLIST)
				    ,OBJECT))))
    (IF DESCRIPTION
	`(PROGN
	   (PRINT-RAW-STRING "#S" ,STREAM)
	   (PRINT-LIST
	     (LIST ',STRUCTURE-NAME ,@SLOT-LIST)
	     ,DEPTH T ,STREAM (SEND ,STREAM :WHICH-OPERATIONS)))
	`(PRINT-CL-STRUCTURE ,OBJECT ,STREAM ,DEPTH))))

;Print a fixnum, possibly with negation, decimal point, etc.

(DEFUN PRINT-FIXNUM-OR-BIGNUM (INTEGER STREAM &AUX TEM)
  (COND ((AND (FIXP BASE)
	      ( 2 BASE 36.))
	 (WHEN (OR PRINT-READABLY (NOT (MAYBE-PRINT-ABBREVIATED-INTEGER INTEGER BASE STREAM)))
	   (PRINT-INTEGER-IN-RADIX-FORM INTEGER STREAM)))
	((AND (SYMBOLP BASE)
	      (SETQ TEM (GET BASE 'PRINC-FUNCTION)))
	 (IF (MINUSP INTEGER)
	     (SEND STREAM :TYO (PTTBL-MINUS-SIGN READTABLE))
	     (SETQ INTEGER (MINUS INTEGER)))
	 (FUNCALL TEM INTEGER STREAM))
	(T
	 (FERROR "A BASE of ~S is meaningless" BASE)))
  INTEGER)

(DEFUN PRINT-INTEGER-IN-RADIX-FORM (INTEGER STREAM)
  (WHEN (AND PRINRADIX (FIXP BASE))
    (PRINT-RADIX-SPECIFIER STREAM))
  (WHEN (MINUSP INTEGER)
    (SEND STREAM :TYO (PTTBL-MINUS-SIGN READTABLE)))
  (PRINT-INTEGER-DIGITS INTEGER BASE STREAM)
  (WHEN (AND (EQL BASE 10.) PRINRADIX)
    (SEND STREAM :TYO (PTTBL-DECIMAL-POINT READTABLE))))

;; Needed for compatibility with 7.1
(DEFUN PRINT-FIXNUM (X STREAM)
  (PRINT-INTEGER-IN-RADIX-FORM X STREAM))

;Print a (possibly-signed) integer.
(DEFUN PRINT-INTEGER (INTEGER RADIX STREAM)
  (WHEN (MINUSP INTEGER)
    (SEND STREAM :TYO (PTTBL-MINUS-SIGN READTABLE)))
  (PRINT-INTEGER-DIGITS INTEGER RADIX STREAM))

;;; Print the digits, without sign or radix specifier
(DEFUN PRINT-INTEGER-DIGITS (INTEGER RADIX STREAM)
  (CL:ETYPECASE INTEGER
    (CL:FIXNUM (PRINT-FIXNUM-1 INTEGER RADIX STREAM))
    (CL:BIGNUM (PRINT-BIGNUM-DIGITS INTEGER RADIX STREAM))))

;Print the digits of the fixnum, without sign.
(DEFUN PRINT-FIXNUM-1 (FIXNUM RADIX STREAM)
  (MULTIPLE-VALUE-BIND (DIGITS LAST-DIGIT)
      (TRUNCATE FIXNUM RADIX)
    (UNLESS (ZEROP DIGITS)
      (PRINT-FIXNUM-1 DIGITS RADIX STREAM))
    (FUNCALL STREAM :TYO (DIGIT-CHAR (ABS LAST-DIGIT) RADIX))))

(DEFUN PRINT-RADIX-SPECIFIER (STREAM &OPTIONAL EVEN-IF-TEN)
  (COND ((EQL BASE 2) (SEND STREAM :STRING-OUT "#b"))
	((EQL BASE 8.) (SEND STREAM :STRING-OUT "#o"))
	((EQL BASE 16.) (SEND STREAM :STRING-OUT "#x"))
	((OR EVEN-IF-TEN (NOT (= BASE 10.)))
	 (SEND STREAM :TYO #/#)
	 (PRINT-INTEGER BASE 10. STREAM)
	 (SEND STREAM :TYO #/r))))

;;; Print character objects using #\ syntax when slashified, as self when princ'ed
(DEFUN PRINT-CHARACTER (CHAR STREAM SLASHIFY-P)
  (IF SLASHIFY-P 
      (FORMAT:FORMAT-CHARACTER STREAM CHAR NIL (FORMATTING-CHAR-P CHAR) NIL ':COMMON-LISP)
      (FUNCALL STREAM ':TYO CHAR)))

(DEFUN PRINT-FUNCTION (NAME FUNCTION STREAM &KEY (TYPE-NAME (CL:TYPE-OF FUNCTION)))
  (LET* ((ENCAPSULATIONP
	   (AND (CL:CONSP NAME)
		(CL:CONSP (CDR NAME))
		(CL:CONSP (SECOND NAME))
		(EQ (FIRST (SECOND NAME)) 'ENCAPSULATED-DEFINITION)))
	 (ENCAPSULATED-THING
	   (WHEN ENCAPSULATIONP
	     (PROG1
	       (FDEFINITION (SECOND (SECOND NAME)))
	       (SETQ NAME (FIRST NAME))
	       (SETQ TYPE-NAME "Encapsulation"))))
	 (DEFINEDP (AND NAME
			(VALIDATE-FUNCTION-SPEC NAME)
			(FDEFINEDP NAME)))
	 (DEF (AND DEFINEDP (FDEFINITION NAME)))
	 (ENCAPSULATEDP (AND DEF (SI:FUNCTION-ENCAPSULATED-P DEF)))
	 (MACROP (AND DEF (EQ (MACRO-FUNCTION DEF) FUNCTION)))
	 (SPECIALP (AND DEF (EQ (SPECIAL-FORM-P DEF) FUNCTION)))
	 (CURRENTP (AND DEFINEDP
			(OR (IF ENCAPSULATIONP
				(EQ DEF FUNCTION)
				(EQ (FDEFINITION (UNENCAPSULATE-FUNCTION-SPEC NAME))
				    FUNCTION))
			    SPECIALP
			    MACROP))))
    (FLET ((PRINT-NAME (NAME)
	     (DW::WITH-OUTPUT-AS-PRESENTATION (:STREAM STREAM
					       :OBJECT NAME
					       :TYPE 'FUNCTION-SPEC)
	       (PRIN1 NAME STREAM))))
      (IF (OR (NULL CURRENTP)
	      *PRINT-ESCAPE*
	      SCL:*PRINT-READABLY*)
	  (PRINTING-RANDOM-OBJECT (FUNCTION STREAM)
	    (PRINC TYPE-NAME STREAM)
	    (SEND STREAM :TYO #\SPACE)
	    (COND (NAME
		   (PRINT-NAME NAME)
		   (COND (CURRENTP
			  (COND (ENCAPSULATIONP
				 (SEND STREAM :STRING-OUT " of ")
				 (PRINC ENCAPSULATED-THING STREAM))
				(ENCAPSULATEDP
				 (SEND STREAM :STRING-OUT " (Encapsulated)"))
				(MACROP
				 (SEND STREAM :STRING-OUT " Macroexpander"))
				(SPECIALP
				 (SEND STREAM :STRING-OUT " Special form"))))
			 (T
			  (SEND STREAM :STRING-OUT " (Not the current definition)"))))
		  (T
		   (SEND STREAM :STRING-OUT "unnamed"))))
	  (PRINT-NAME NAME)))))

;; MLY's more informative version
(DEFUN PRINT-LEXICAL-CLOSURE (EXP STREAM SLASHIFY-P &OPTIONAL (DEPTH 0))
  (LET* ((FUNCTION (UNDIGEST (LEXICAL-CLOSURE-FUNCTION EXP)))
	 (PRINTER (CDR (SI:DEBUGGING-INFO-USER-ENTRY FUNCTION 'CLOS:PRINT-OBJECT)))
	 (*PRINT-ESCAPE* SLASHIFY-P)
	 (LISP:*PRINT-LEVEL* (IF LISP:*PRINT-LEVEL*
				 (MIN LISP:*PRINT-LEVEL* 1)
				 1))
	 (LISP:*PRINT-LENGTH* (IF LISP:*PRINT-LENGTH*
				  (MIN LISP:*PRINT-LENGTH* 4)
				  4)))
    (WHEN (AND PRINTER (CL:APPLY (FIRST PRINTER) EXP STREAM (CL:REST PRINTER)))
      (RETURN-FROM PRINT-LEXICAL-CLOSURE))
    (PRINTING-RANDOM-OBJECT (EXP STREAM)
      (LET ((SG (LET ((REGION (%REGION-NUMBER EXP)))
		  (WHEN (AND REGION (LDB-TEST %%REGION-STACK (REGION-BITS REGION)))
		    (MULTIPLE-VALUE-BIND (NIL NIL NIL NIL SG)
			(DECODE-STACK-ADDRESS EXP)
		      SG)))))
	(PRINT-RAW-STRING (IF (NULL SG) "LEXICAL-CLOSURE " "STACK-LEXICAL-CLOSURE ")
			  STREAM)
	(PRINT-OBJECT (FUNCTION-NAME FUNCTION) DEPTH SLASHIFY-P STREAM)
	(COND ((NULL SG))
	      ((EQ SG %CURRENT-STACK-GROUP))
	      (T (FORMAT STREAM ", stack ~A" (SG-NAME SG))))))))

;;; *PRINT-BIT-VECTOR-LENGTH* can be T as well as NIL or a number.  If it is
;;; non-null, then bit vectors are printed even when *PRINT-ARRAY* is nil.
;;; T means print them always, no matter how long.

(DEFUN PRINT-ARRAY-CONTENTS (ARRAY I-PRINDEPTH SLASHIFY-P STREAM IGNORE WHICH-OPERATIONS)
  (COND ((STRINGP ARRAY)
	 (IF (LET ((LENGTH (ARRAY-ACTIVE-LENGTH ARRAY)))
	       (AND ( LENGTH (ARRAY-LENGTH ARRAY))
		    (OR PRINT-READABLY
			(NULL *PRINT-STRING-LENGTH*)
			( LENGTH *PRINT-STRING-LENGTH*))))
	     (PRINT-QUOTED-STRING ARRAY SLASHIFY-P STREAM)
	     (PRINT-ARBITRARY-ARRAY ARRAY STREAM)))
	((CL:BIT-VECTOR-P ARRAY)
	 ;; in CL, *PRINT-ARRAY* has control.  SCL extends with *P-B-V-L*
	 ;; if that is non-null, they are printed.
	 (LET ((LENGTH (ARRAY-ACTIVE-LENGTH ARRAY)))
	   (IF (AND ( LENGTH (ARRAY-LENGTH ARRAY))
		    (OR PRINT-READABLY
			(CL:CASE *PRINT-BIT-VECTOR-LENGTH*
			  ((T) T)
			  ((NIL) CL:*PRINT-ARRAY*)
			  (OTHERWISE ( LENGTH *PRINT-BIT-VECTOR-LENGTH*)))))
	       (PROGN (PRINT-RAW-STRING "#*" STREAM)
		      (DOTIMES (I LENGTH)
			(SEND STREAM :TYO (IF (ZEROP (AREF ARRAY I)) #/0 #/1))))
	       (PRINT-ARBITRARY-ARRAY ARRAY STREAM))))
	((AND (NOT PRINT-READABLY)
	      (OR (NULL CL:*PRINT-ARRAY*)
		  (AND *PRINT-ARRAY-LENGTH*
		       (> (ARRAY-ACTIVE-LENGTH ARRAY) *PRINT-ARRAY-LENGTH*))))
	 (PRINT-ARBITRARY-ARRAY ARRAY STREAM))
	((AND PRINLEVEL ( I-PRINDEPTH PRINLEVEL) (NOT PRINT-READABLY))
	 (PRINT-RAW-STRING (PTTBL-PRINLEVEL READTABLE) STREAM))
	(T
	 (LET ((RANK (ARRAY-#-DIMS ARRAY))
	       (ELEMENT-TYPE (CL:ARRAY-ELEMENT-TYPE ARRAY)))
	   (IF (AND PRINT-READABLY
		    (NOT (EQ ELEMENT-TYPE T)))
	       (COND ((= RANK 1)
		      (PRINT-RAW-STRING "#S" STREAM)
		      (PRINT-OBJECT `(CL:VECTOR :ELEMENT-TYPE ,ELEMENT-TYPE
						:CONTENTS ,(CL:MAKE-ARRAY (CL:LENGTH ARRAY) :INITIAL-CONTENTS ARRAY))
				    I-PRINDEPTH SLASHIFY-P STREAM WHICH-OPERATIONS))
		     (T
		      (PRINT-RAW-STRING "#S" STREAM)
		      (LET ((DIMENSIONS (CL:ARRAY-DIMENSIONS ARRAY)))
			(PRINT-OBJECT `(CL:ARRAY :ELEMENT-TYPE ,ELEMENT-TYPE
						 :DIMENSIONS ,DIMENSIONS
						 :CONTENTS ,(CL:MAKE-ARRAY DIMENSIONS :INITIAL-CONTENTS ARRAY))
				      I-PRINDEPTH SLASHIFY-P STREAM WHICH-OPERATIONS))))
	       (COND ((= RANK 1)
		      ;; It is a vector.
		      ;; It's neither a bit-vector nor a string, so print it as a general vector.
		      (PRINT-RAW-STRING "#(" STREAM)
		      (LOOP FOR I FROM 0 BELOW (ARRAY-ACTIVE-LENGTH ARRAY)
			    FOR FIRST = T THEN NIL DO
			(WHEN (AND PRINLENGTH ( I PRINLENGTH) (NOT PRINT-READABLY))
			  (PRINT-RAW-STRING (PTTBL-PRINLENGTH READTABLE) STREAM)
			  (RETURN))
			(UNLESS FIRST
			  (SEND STREAM :TYO #\SPACE))
			(PRINT-OBJECT (AREF ARRAY I) (1+ I-PRINDEPTH)
				      SLASHIFY-P STREAM WHICH-OPERATIONS)
			    FINALLY (SEND STREAM :TYO #/))))
		     (T
		      ;; It's not a vector, use #nA syntax.
		      (SEND STREAM :TYO #/#)
		      (PRINT-INTEGER RANK 10. STREAM)
		      (SEND STREAM :TYO #/A)
		      (PRINT-ARRAY-CONTENTS-INTERNAL ARRAY (MAKE-ARRAY RANK) 0 RANK I-PRINDEPTH
						     SLASHIFY-P STREAM WHICH-OPERATIONS))))))))

;; MLY's new informative version.
(DEFUN PRINT-ARBITRARY-ARRAY (ARRAY STREAM)
  (PRINTING-RANDOM-OBJECT (ARRAY STREAM)
    (LET ((PRINT-TYPE (AREF #.(LET ((ARRAY (MAKE-ARRAY (LSH 1 (BYTE-SIZE ARRAY-TYPE-FIELD)))))
				(SETF (AREF ARRAY ART-Q) T)
				(SETF (AREF ARRAY ART-BOOLEAN) 'SCL:BOOLEAN)
				(SETF (AREF ARRAY ART-FAT-STRING) 'CL:CHARACTER)
				(SETF (AREF ARRAY ART-STRING) 'CL:STRING-CHAR)
				(SETF (AREF ARRAY ART-FIXNUM) 'CL:FIXNUM)
				(SETF (AREF ARRAY ART-16B) '(CL:UNSIGNED-BYTE 16.))
				(SETF (AREF ARRAY ART-8B) '(CL:UNSIGNED-BYTE 8))
				(SETF (AREF ARRAY ART-4B) '(CL:UNSIGNED-BYTE 4))
				(SETF (AREF ARRAY ART-2B) '(CL:UNSIGNED-BYTE 2))
				(SETF (AREF ARRAY ART-1B) 'CL:BIT)
				ARRAY)
			    (ARRAY-TYPE-FIELD ARRAY))))
      (FLET ((STRING-OUT (STRING STREAM)
	       (IF (EQ *PRINCASE* :UPCASE)
		   (PRINT-RAW-STRING STRING STREAM)
		   (PRINT-CASED-STRING STRING STREAM NIL))))
	(COND ((NULL PRINT-TYPE)
	       (STRING-OUT (LISP:SYMBOL-NAME (ARRAY-TYPES (ARRAY-TYPE-FIELD ARRAY)))
			   STREAM))
	      ((EQ PRINT-TYPE T)
	       (STRING-OUT "ARRAY" STREAM))
	      (T (STRING-OUT "ARRAY " STREAM)
		 (LET ((BASE 10.))
		   (PRIN1 PRINT-TYPE STREAM))))))
    (LET ((RANK (LISP:ARRAY-RANK ARRAY))
	  (SIZE (LISP:ARRAY-TOTAL-SIZE ARRAY)))
      (COND ((= RANK 0)
	     (PRINT-RAW-STRING " 0-dimensional" STREAM))
	    ((= RANK 1)
	     (LISP:WRITE-CHAR #\Space STREAM)
	     (PRINT-FIXNUM-1 SIZE 10. STREAM))
	    (T
	     (DOTIMES (I RANK)
	       (LISP:WRITE-CHAR (IF (ZEROP I) #\Space #\x) STREAM)
	       (PRINT-FIXNUM-1 (LISP:ARRAY-DIMENSION ARRAY I) 10. STREAM))))
      (LET ((DISPLACED (ARRAY-DISPLACED-P ARRAY))
	    (LEADER (ARRAY-HAS-LEADER-P ARRAY))
	    (FORWARDED (NOT (EQ ARRAY (FOLLOW-STRUCTURE-FORWARDING ARRAY))))
	    (SG (LET ((REGION (%REGION-NUMBER ARRAY)))
		  (WHEN (AND REGION (LDB-TEST %%REGION-STACK (REGION-BITS REGION)))
		    (MULTIPLE-VALUE-BIND (NIL NIL NIL NIL SG)
			(DECODE-STACK-ADDRESS ARRAY)
		      SG))))
	    (FIRST T))
	(FLET ((NEXT ()
		 (PRINT-RAW-STRING (IF FIRST " " ", ") STREAM)
		 (SETQ FIRST NIL)))
	  (WHEN (AND (NOT DISPLACED) (NOT LEADER))
	    (NEXT)
	    (PRINT-RAW-STRING "simple" STREAM))
	  (WHEN DISPLACED
	    (NEXT)
	    (IF (NOT (ARRAY-INDIRECT-P ARRAY))
		;; if array-indirect-p then is displaced to another array,
		;;  rather than to a random memory location.
		(PRINT-RAW-STRING "displaced" STREAM)
		(PROGN
		  (WHEN (NOT (ZEROP (ARRAY-DISCONTIGUOUS-BIT ARRAY)))
		    (PRINT-RAW-STRING "conformally-" STREAM))
		  ;(when (not (zerop (array-index-offset array)))
		  ;  (print-raw-string "offset-" stream))
		  (PRINT-RAW-STRING "indirect" STREAM))))
	  (WHEN LEADER
	    (NEXT)
	    (LET ((LENGTH (ARRAY-LEADER-LENGTH ARRAY)))
	      (IF (AND (EQL RANK 1)
		       (EQL LENGTH 1)
		       (LISP:TYPEP (FILL-POINTER ARRAY) 'LISP:FIXNUM))
		  (PROGN
		    (PRINT-RAW-STRING "fill-pointer" STREAM)
		    (UNLESS (EQL (FILL-POINTER ARRAY) SIZE)
		      (LISP:WRITE-CHAR #\Space STREAM)
		      (PRINT-FIXNUM-1 (FILL-POINTER ARRAY) 10. STREAM)))
		  (PROGN
		    (PRINT-RAW-STRING "leader-length " STREAM)
		    (PRINT-FIXNUM-1 LENGTH 10. STREAM)))))
	  (WHEN FORWARDED
	    (NEXT)
	    (PRINT-RAW-STRING "forwarded" STREAM))
	  (WHEN SG
	    (NEXT)
	    (IF (EQ SG %CURRENT-STACK-GROUP)
		(PRINT-RAW-STRING "stack-allocated" STREAM)
		(FORMAT STREAM "allocated on stack ~A" (SG-NAME SG))))
	  #+IGNORE
	  ;;--- Test this before patching.  Make sure it works for streams which don't
	  ;;--- support :DISPLAY-LOSENGED-STRING.
	  (WHEN (STRINGP ARRAY)
	    (LET ((LENGTH (STRING-LENGTH ARRAY)))
	      (WHEN (AND (NUMBERP SCL:*PRINT-STRING-LENGTH*)
			 (> LENGTH SCL:*PRINT-STRING-LENGTH* 12))
		(LISP:WRITE-CHAR #\Space STREAM)
		(DW::WITH-CHARACTER-SIZE (:SMALLER STREAM)
		  ;;>> abbreviating-output has some bugs, so we use this instead
		  (FLET ((OUT (C)
			   (COND ((CHAR-EQUAL C #\Newline)
				  (SEND STREAM :DISPLAY-LOZENGED-STRING "Return"))
				 ((CHAR-EQUAL C #\Tab)
				  (SEND STREAM :DISPLAY-LOZENGED-STRING "Tab"))
				 (T (LISP:WRITE-CHAR C STREAM)))))
		    (DOTIMES (I 5)
		      (OUT (LISP:CHAR ARRAY I)))
		    (SI:PRINT-RAW-STRING "..." STREAM)
		    (DOTIMES (I 5)
		      (OUT (LISP:CHAR ARRAY (- LENGTH 5 (- I))))))))))
	  )))))

(DEFUN PRINT-ARRAY-CONTENTS-INTERNAL (ARRAY INDEX-ARRAY AXIS RANK I-PRINDEPTH
				      SLASHIFY-P STREAM WHICH-OPERATIONS)
  (IF (ZEROP RANK)
      (PROGN (SEND STREAM :TYO (PTTBL-SPACE READTABLE))
	     (PRINT-OBJECT (AREF ARRAY) I-PRINDEPTH SLASHIFY-P STREAM WHICH-OPERATIONS))
      (LET ((BOTTOM-P (= (1+ AXIS) RANK))
	    (DIMENSION (ARRAY-DIMENSION-N (1+ AXIS) ARRAY))
	    (ARRAY-TYPE (ARRAY-TYPE ARRAY)))
	(COND ((AND PRINLEVEL ( I-PRINDEPTH PRINLEVEL) (NOT PRINT-READABLY))
	       (PRINT-RAW-STRING (PTTBL-PRINLEVEL READTABLE) STREAM))
	      ((AND BOTTOM-P
		    (OR (NULL PRINLENGTH) ( DIMENSION PRINLENGTH) PRINT-READABLY)
		    (OR (MEMQ ARRAY-TYPE '(ART-1B ART-STRING ART-FAT-STRING))))
	       ;; Use abbreviated syntax for the innermost sequences in the array
	       (COND ((EQ ARRAY-TYPE 'ART-1B)
		      (PRINT-RAW-STRING "#*" STREAM)
		      (DOTIMES (I DIMENSION)
			(ASET I INDEX-ARRAY AXIS)
			(SEND STREAM :TYO (IF (ZEROP (GENERAL-AREF ARRAY INDEX-ARRAY RANK))
					      #/0 #/1))))
		     (T
		      (WHEN SLASHIFY-P
			(FUNCALL STREAM :TYO (PTTBL-OPEN-QUOTE-STRING READTABLE)))
		      (DOTIMES (I DIMENSION)
			(ASET I INDEX-ARRAY AXIS)
			(LET* ((CHAR (GENERAL-AREF ARRAY INDEX-ARRAY RANK))
			       (CODE (CHAR-CODE CHAR)))
			  (AND SLASHIFY-P
			       (GRAPHIC-CHAR-P CHAR)
			       (BIT-TEST 16 (RDTBL-BITS READTABLE CODE))
			       (FUNCALL STREAM :TYO (PTTBL-SLASH READTABLE)))
			  (FUNCALL STREAM :TYO CHAR)))
		      (WHEN SLASHIFY-P
			(FUNCALL STREAM :TYO (PTTBL-CLOSE-QUOTE-STRING READTABLE)))
		      )))
	      (T
	       (SEND STREAM :TYO (PTTBL-OPEN-PAREN READTABLE))
	       (LOOP FOR FIRST = T THEN NIL
		     FOR I FROM 0 BELOW DIMENSION DO
		 (ASET I INDEX-ARRAY AXIS)
		 (WHEN (AND PRINLENGTH ( I PRINLENGTH) (NOT PRINT-READABLY))
		   (PRINT-RAW-STRING (PTTBL-PRINLENGTH READTABLE) STREAM)
		   (RETURN (VALUES)))
		 (UNLESS FIRST (SEND STREAM :TYO (PTTBL-SPACE READTABLE)))
		 (IF BOTTOM-P
		     (PRINT-OBJECT (GENERAL-AREF ARRAY INDEX-ARRAY RANK)
				   (1+ I-PRINDEPTH) SLASHIFY-P STREAM WHICH-OPERATIONS)
		     (PRINT-ARRAY-CONTENTS-INTERNAL
		       ARRAY INDEX-ARRAY (1+ AXIS) RANK
		       (1+ I-PRINDEPTH) SLASHIFY-P STREAM WHICH-OPERATIONS))
		     FINALLY (SEND STREAM :TYO (PTTBL-CLOSE-PAREN READTABLE))))))))

;If non-NIL, Common Lisp strings printed with the Zetalisp readtable and
;Zetalisp strings printed with the Common Lisp readtable are prefixed with #"
;to distinguish them as the wrong kind of strings.
(DEFVAR *FLAG-WRONG-TYPE-STRINGS* T)

;Called by pathnames when asked to print themselves with the CL readtable in effect
(DEFUN PRINT-PATHNAME (PATHNAME STREAM)
  (SEND STREAM :STRING-OUT "#P")
  (LET ((*FLAG-WRONG-TYPE-STRINGS* NIL))
    (PRIN1 (SEND PATHNAME :STRING-FOR-READABLE-PRINTING) STREAM)))


;; Printing flonums. 
;; The third argument used to be FASTP.

(DEFUN PRINT-FLONUM (FLOAT STREAM &OPTIONAL IGNORE IGNORE MAX-DIGITS FORCE-E-FORMAT)
  (CHECK-ARG-TYPE FLOAT :FLOAT)
  (MULTIPLE-VALUE-BIND (INTEGER EXPONENT SIGN)
      (INTEGER-DECODE-FLOAT FLOAT)
    (SELECTQ EXPONENT
      (:INFINITY
       (SEND STREAM ':TYO (IF (MINUSP SIGN) (PTTBL-MINUS-SIGN READTABLE) #/+))
       (SEND STREAM ':TYO #/1)
       (SEND STREAM ':TYO (EXPONENT-MARK-CHARACTER FLOAT))
       (SEND STREAM ':TYO #/))
      (:NAN
       (PRINTING-RANDOM-OBJECT (FLOAT STREAM :NO-POINTER)
	 (SEND STREAM ':TYO (IF (MINUSP SIGN) (PTTBL-MINUS-SIGN READTABLE) #/+))
	 (SEND STREAM ':STRING-OUT (TYPECASE FLOAT
				     (:DOUBLE-FLOAT "DOUBLE-NAN ")
				     (OTHERWISE "NAN ")))
	 (PRINT-INTEGER INTEGER 8. STREAM)))
      (OTHERWISE
       (IF SCL:*PRINT-EXACT-FLOAT-VALUE*
	   (PRINT-EXACT-FLOAT FLOAT STREAM)
	   (WITH-STACK-ARRAY (STRING 20. :ELEMENT-TYPE 'SCL:STRING-CHAR :FILL-POINTER 0)
	     (MULTIPLE-VALUE-BIND (STRING DECIMAL-EXPONENT N-DIGITS)
		 (IF MAX-DIGITS
		     (FIXED-WIDTH-DECIMAL-DIGITS INTEGER EXPONENT MAX-DIGITS NIL NIL STRING)
		     (SHORT-DECIMAL-DIGITS INTEGER EXPONENT STRING))
	       (WHEN (ZEROP INTEGER) (SETQ DECIMAL-EXPONENT 0))	     
	       (COND ((OR FORCE-E-FORMAT ( DECIMAL-EXPONENT -3) (> DECIMAL-EXPONENT 7))
		      (PRINT-FLOAT-DIGITS-E-FORMAT STREAM STRING SIGN (MINUSP SIGN)
						   NIL N-DIGITS (MAX N-DIGITS 2) 1
						   (EXPONENT-MARK-CHARACTER FLOAT)
						   NIL NIL
						   (- DECIMAL-EXPONENT 1)))
		     (T
		      (PRINT-FLOAT-DIGITS STRING DECIMAL-EXPONENT SIGN
					  N-DIGITS (MAX N-DIGITS (+ DECIMAL-EXPONENT 1))
					  STREAM)
		      (MULTIPLE-VALUE-BIND (MARK DEFAULT-P)
			  (EXPONENT-MARK-CHARACTER FLOAT)
			(UNLESS DEFAULT-P
			  (SEND STREAM ':TYO MARK)
			  (SEND STREAM ':TYO #/0))))))))))))

(DEFUN EXPONENT-MARK-CHARACTER (X)
  (DECLARE (VALUES CHAR DEFAULT-P))
  (LET ((TYPE (TYPECASE X
		(:DOUBLE-FLOAT 'CL:DOUBLE-FLOAT)
		(OTHERWISE 'CL:SINGLE-FLOAT))))
    (IF (EQ TYPE CL:*READ-DEFAULT-FLOAT-FORMAT*)
	(VALUES #/e T)
      (SELECTQ TYPE
	(CL:SINGLE-FLOAT #/f)
	(CL:DOUBLE-FLOAT #/d)))))

(defun print-exact-float (float &optional (stream standard-output))
  (multiple-value-bind (ignore ignore sign)
      (decode-float float)
    (when (minusp sign)
      (send stream :tyo (pttbl-minus-sign readtable)))
    (multiple-value-bind (integer fraction)
	(truncate float)
      (multiple-value-bind (numerator exponent)
	  (integer-decode-float fraction)
	;; print integer part
	(print-integer-digits integer 10. stream)
	(send stream :tyo (pttbl-decimal-point readtable))
	;; print fraction digits
	(setq numerator (* numerator 10.))
	(setq exponent (- exponent))
;	(loop do (multiple-value (digit numerator)
;				 (floor numerator denominator))
;		 (send stream :tyo (digit-char digit))
;		 (setq numerator (* numerator 10.))
;	      until (zerop numerator))
	(loop do (send stream :tyo (digit-char (ldb (byte 4 exponent) numerator)))
		 (setq numerator (* (dpb 0 (byte 4 exponent) numerator) 5))
		 (decf exponent)
	      until (zerop numerator))
	(multiple-value-bind (mark default-p)
	    (exponent-mark-character float)
	  (unless default-p
	    (send stream ':tyo mark)
	    (send stream ':tyo #/0)))))))


(DEFUN MAYBE-PRINT-ABBREVIATED-INTEGER (INTEGER RADIX STREAM)
  ;; return T if we printed anything
  (LET ((MAX-DIGITS SCL:*PRINT-INTEGER-LENGTH*)
	(TWO-DIGITS (CL:EXPT RADIX 2)))
    (WHEN (AND (FIXP MAX-DIGITS) ( MAX-DIGITS 2)
	       ;; we know that two-digits fits in a fixnum, so negating it won't cons
	       (NOT (< (- TWO-DIGITS) INTEGER TWO-DIGITS)))
      (LET ((EST-DIGITS (MULTIPLE-VALUE-BIND (FRACTION EXPONENT)
			    (DECODE-FLOAT-OF-FLOAT INTEGER)
			  (ROUND (+ (CL:LOG FRACTION) (* EXPONENT (CL:LOG 2)))
				 (CL:LOG RADIX)))))
	(WHEN ( EST-DIGITS MAX-DIGITS)
	  (MULTIPLE-VALUE-BIND (PART-DIGITS EXTRA-DIGIT)
	      (FLOOR MAX-DIGITS 2)
	    (LET* ((HIGH-PART (ABS (// INTEGER
				       (CL:EXPT RADIX (- EST-DIGITS
							 (+ PART-DIGITS EXTRA-DIGIT))))))
		   (HIGH-MAX (CL:EXPT RADIX (+ PART-DIGITS EXTRA-DIGIT))))
	      (UNLESS (< HIGH-PART HIGH-MAX)
		(SETQ HIGH-PART (// HIGH-PART RADIX))
		(INCF EST-DIGITS))
	      (WHEN (> EST-DIGITS MAX-DIGITS)
		(LET* ((LOW-PART (ABS (\ INTEGER (IF (ZEROP EXTRA-DIGIT)
						     HIGH-MAX
						     (// HIGH-MAX RADIX)))))
		       (LOW-PART-DIGITS (LOOP FOR X = LOW-PART THEN (// X RADIX)
					      COUNT T
					      UNTIL (< X RADIX))))
		  (SEND STREAM :STRING-OUT "#<INTEGER (")
		  (PRINT-INTEGER EST-DIGITS 10. STREAM)
		  (SEND STREAM :STRING-OUT " digits) ")
		  (WHEN PRINRADIX
		    (PRINT-RADIX-SPECIFIER STREAM T))
		  (WHEN (MINUSP INTEGER)
		    (SEND STREAM :TYO (PTTBL-MINUS-SIGN READTABLE)))
		  (PRINT-INTEGER-DIGITS HIGH-PART RADIX STREAM)
		  (SEND STREAM :STRING-OUT "...")
		  (LOOP REPEAT (- PART-DIGITS LOW-PART-DIGITS)
			DO (SEND STREAM :TYO #\0))
		  (PRINT-INTEGER-DIGITS LOW-PART RADIX STREAM)
		  (SEND STREAM :STRING-OUT ">")
		  T)))))))))

;;; Print the digits of a bignum
(DEFUN PRINT-BIGNUM-DIGITS (BIGNUM RADIX STREAM)
  (LET* ((DIGITS-PER-Q (IF (EQL RADIX 10.)
			   9.			;gratuitous optimization
			   ;; number of bits in a positive fixnum
			   ;; divided by the maximum number of bits in a digit
			   (1- (CEILING 31. (HAULONG (1- RADIX))))))
	 (MAX-RADIX (^ RADIX DIGITS-PER-Q))
	 (NUM (BIGNUM-TO-ARRAY BIGNUM MAX-RADIX))
	 (LENGTH (ARRAY-LENGTH NUM)))
    (DO ((INDEX (1- LENGTH) (1- INDEX))
	 (NDIGITS -1 DIGITS-PER-Q))
	((MINUSP INDEX))
      (PRINT-BIGNUM-PIECE (AREF NUM INDEX) RADIX STREAM NDIGITS))
    (RETURN-ARRAY NUM)))

(DEFUN PRINT-BIGNUM-PIECE (PIECE RADIX STREAM NDIGITS)
  (MULTIPLE-VALUE-BIND (DIGITS LAST-DIGIT)
      (TRUNCATE PIECE RADIX)
    (UNLESS (AND (ZEROP DIGITS) ( NDIGITS 1))
      (PRINT-BIGNUM-PIECE DIGITS RADIX STREAM (1- NDIGITS)))
    (FUNCALL STREAM ':TYO (DIGIT-CHAR LAST-DIGIT RADIX))))


;The next two pages are support for some of the string (pname) printers that follow.

(DEFSUBST FAST-ARRAY-PUSH-EXTEND (ARRAY DATA)
  "Fast version of ARRAY-PUSH-EXTEND that makes a number of assumptions for speed:
 - Array has fill pointer and is adjustable.
 - Interrupts are off (or don't matter).
 - If array needs to grow, it should grow by 25% of its size.
 - Array is not ART-Q-LIST
 - Return value doesn't matter."
  (LET* ((OLD-LENGTH (ARRAY-LEADER ARRAY 0))
	 (NEW-LENGTH (1+ OLD-LENGTH)))
    (COMPILER:%ERROR-UNLESS ( NEW-LENGTH (ARRAY-LENGTH ARRAY))
      (ADJUST-ARRAY-SIZE ARRAY (+ NEW-LENGTH (// OLD-LENGTH 4) 1)))
    (ASET DATA ARRAY OLD-LENGTH)
    (STORE-ARRAY-LEADER NEW-LENGTH ARRAY 0)))

;The rest of this implements the WITH-BUFFERED-IO-STRING-STREAM abstraction.

(DEFVAR *BUFFERED-IO-STRING-STREAMS* (MAKE-ARRAY 10 :FILL-POINTER 0))

(DEFVAR *BUFFERED-IO-STRING-STREAM-STRING-DEFAULT-SIZE* 32.)

(DEFSUBST ALLOCATE-BUFFERED-IO-STRING-STREAM-STRING (N)
  (LET ((STRING (WITHOUT-INTERRUPTS
		  (UNLESS (ZEROP (FILL-POINTER *BUFFERED-IO-STRING-STREAMS*))
		    (CL:VECTOR-POP *BUFFERED-IO-STRING-STREAMS*)))))
    (IF STRING
	(IF (< (CL:ARRAY-DIMENSION STRING 0) N)
	    (CL:ADJUST-ARRAY STRING N :FILL-POINTER 0)
	    (PROGN (SETF (FILL-POINTER STRING) 0) STRING))
	(CL:MAKE-ARRAY N :ADJUSTABLE T :FILL-POINTER 0 :ELEMENT-TYPE 'CHARACTER))))

(DEFSUBST DEALLOCATE-BUFFERED-IO-STRING-STREAM-STRING (STRING)
  (CL:VECTOR-PUSH STRING *BUFFERED-IO-STRING-STREAMS*))

(DEFMACRO WITH-BUFFERED-IO-STRING-STREAM
	  ((STREAM &KEY (SIZE *BUFFERED-IO-STRING-STREAM-STRING-DEFAULT-SIZE*)
		   	(FAST-WRITE-CHAR NIL)
			(SLOW-WRITE-CHAR-P T))
	   &BODY FORMS)
  (LET ((STRING-VAR (FUTURE-COMMON-LISP:GENSYM "STRING")))
    `(LET (,STRING-VAR)
       (UNWIND-PROTECT (MULTIPLE-VALUE-PROG1
			 (PROGN (SETQ ,STRING-VAR
				      (ALLOCATE-BUFFERED-IO-STRING-STREAM-STRING ,SIZE))
				(LET ((,STRING-VAR ,STRING-VAR))
				  (DECLARE (SYS:ARRAY-REGISTER ,STRING-VAR))
				  ,(LET ((FORM `(PROGN ,@FORMS)))
				     (WHEN FAST-WRITE-CHAR
				       (SETQ FORM
					     `(FLET ((,FAST-WRITE-CHAR (CHAR)
						      (FAST-ARRAY-PUSH-EXTEND ,STRING-VAR
									      CHAR)))
						(DECLARE (CL:INLINE ,FAST-WRITE-CHAR))
						,FORM)))
				     (WHEN SLOW-WRITE-CHAR-P
				       (SETQ FORM
					     `(WITH-OUTPUT-TO-STRING (,STREAM ,STRING-VAR)
						,FORM)))
				     FORM)))
			 (SEND ,STREAM :STRING-OUT ,STRING-VAR))
	 (IF ,STRING-VAR (DEALLOCATE-BUFFERED-IO-STRING-STREAM-STRING ,STRING-VAR))))))


;More support for pname printers

(DEFVAR *PRINT-PREFER-QUOTES* T
  "Controls, for example, whether the symbol whose name is `a'
prints preceded by a slash or surrounded by vertical bars.")

(DEFSUBST CHAR-CODE-UPCASE (CHAR-CODE)
  (IF (< CHAR-CODE 128.)  ;Certainly the ASCII range is safe.
      			  ;There might be a more abstract test, though.
      (IF ( (CHAR-CODE #\a) CHAR-CODE (CHAR-CODE #\z))
	  (LOGXOR #o40 CHAR-CODE)
	  CHAR-CODE)
      ;; This probably hardly ever happens, so don't inline.
      (CHAR-CODE (CHAR-UPCASE (CODE-CHAR CHAR-CODE)))))

(DEFSUBST CHAR-CODE-DOWNCASE (CHAR-CODE)
  (IF (< CHAR-CODE 128.)  ;Certainly the ASCII range is safe.
      			  ;There might be a more abstract test, though.
      (IF ( (CHAR-CODE #\A) CHAR-CODE (CHAR-CODE #\Z))
	  (LOGXOR #o40 CHAR-CODE)
	  CHAR-CODE)
      ;; This probably hardly ever happens, so don't inline.
      (CHAR-CODE (CHAR-DOWNCASE (CODE-CHAR CHAR-CODE)))))

(DEFSUBST STRING-UNAFFECTED-BY-CASE-SHIFT-P (STRING CASE LENGTH)
  ;; If the CASE argument is :UPCASE, 
  ;;    return true only for strings that will not be affected by upcasing
  ;; If the CASE argument is :DOWNCASE,
  ;;    return true only for strings that will not be affected by downcasing
  ;; Otherwise return false.
  (CL:CASE CASE
    (:UPCASE
      (LET ((STRING STRING))
	(DECLARE (SYS:ARRAY-REGISTER STRING))
	(CL:DOTIMES (I LENGTH T)
	  (LET* ((CHAR (AREF STRING I))
		 (CHAR-CODE (CHAR-CODE CHAR))
		 (UPCODE (CHAR-CODE-UPCASE CHAR-CODE)))
	    (UNLESS (= UPCODE CHAR-CODE)
	      (RETURN NIL))))))
    (:DOWNCASE
      (LET ((STRING STRING))
	(DECLARE (SYS:ARRAY-REGISTER STRING))
	(CL:DOTIMES (I LENGTH T)
	  (LET* ((CHAR (AREF STRING I))
		 (CHAR-CODE (CHAR-CODE CHAR))
		 (DOWNCODE (CHAR-CODE-DOWNCASE CHAR-CODE)))
	    (UNLESS (= DOWNCODE CHAR-CODE)
	      (RETURN NIL))))))
    (OTHERWISE NIL)))




;The following functions print out strings, in three different ways.

;This was factored out of PRINT-PNAME-STRING-1
;Various :UPCASE special cases have been removed because they no longer worked
;when READTABLE-CASE was factored in.  I left them in the source, commented out,
;just for temporary historical reasons.  The commented-out parts can be removed
;once this is seen to be stable. -kmp 4-Oct-92
(DEFSUBST PRINT-PNAME-STRING-2 (STRING STREAM EMPTY-OK FORCE
				OPEN-QUOTE-CHARACTER CLOSE-QUOTE-CHARACTER SLASH-CHARACTER)
  (WITH-FAST-READTABLE-ACCESS (READTABLE)
    (LET ((LEN (ARRAY-ACTIVE-LENGTH STRING))
	  FSMWINS
	  (MUST// NIL)
	  (SOME-NOT-// NIL)
	  (SLASH-COUNT 0)
	  (RDTBL-LIMIT (RDTBL-LIMIT READTABLE)))
      (SETQ FSMWINS
	    (AND (PLUSP LEN)
		 (DO ((I 0 (1+ I))
		      (STATE (RDTBL-STARTING-STATE READTABLE))
		      (FSM (RDTBL-FSM READTABLE)))
		     ((= I LEN)
		      ;; We're done with our simulated read attempt.
		      ;; Now determine whether the thing we parsed is a symbol.
		      (COND ((NOT (NUMBERP STATE))
			     (DO ((L (RDTBL-MAKE-SYMBOL READTABLE) (CDR L)))
				 ((NULL L))
			       (WHEN (AND (EQ (CAR STATE) (CAAR L))
					  (EQ (CDR STATE) (CDAR L)))
				 (RETURN T))))
			    ((NOT (NUMBERP
				    (SETQ STATE
					  (AREF FSM STATE (RDTBL-BREAK-CODE READTABLE)))))
			     ;; Would breaking here reach one of the states that
			     ;; untyi's one character then makes a symbol from the rest?
			     (DO ((L (RDTBL-MAKE-SYMBOL-BUT-LAST READTABLE)
				     (CDR L))
				  (UNCONDITIONAL T NIL))
				 ((NULL L) NIL)
			       (AND (EQ (CAR STATE) (CAAR L))
				    (EQ (CDR STATE) (CDAR L))
				    (RETURN
				      (OR UNCONDITIONAL
					  (NOT (LET ((IBASE BASE))
						 (TOKEN-IS-EXTENDED-INTEGER STRING))))))))
			    (T NIL)))
		   (LET* ((CHAR (AREF STRING I))
			  (CHAR-CODE (CHAR-CODE CHAR))
			  (TRANSLATED-CHAR-P
			    (AND (< CHAR-CODE RDTBL-LIMIT)
				 (FAST-TRANSLATED-CHAR-CODE-P CHAR-CODE))))
		     (MACROLET ((PREFER-QUOTES ()
				  `(PROGN
				     (UNLESS MUST//
				       ;; Skip this if we've already determined
				       ;; that we must slash.
				       (DO ((I (1+ I) (1+ I)))
					   ((= I LEN))
					 (LET ((N (CHAR-CODE (AREF STRING I))))
					   (COND ((AND (< N RDTBL-LIMIT)	
						       (FAST-ALWAYS-SLASHIFY-CODE-P N))
						  (SETQ MUST// T)
						  (RETURN NIL))))))
				     (RETURN NIL))))
		       (COND ((OR (NOT (NUMBERP STATE))	;FSM ran out
				  ;; TRANSLATED-CHAR-P.
				  ;; There used to be a special case here which doesn't work
				  ;; with READTABLE-CASE.  We make up the speed elsewhere.
				  )
			      (PREFER-QUOTES))
			     ;; If translation, doesn't mean FSM loses,
			     ;; just means we need to be careful and use /'s
			     ;; when printing.
			     (TRANSLATED-CHAR-P
			      ;;translated char? then fsm doesn't lose,
			      ;;but we must //
			      (WHEN (OR *PRINT-PREFER-QUOTES* (> (INCF SLASH-COUNT) 1))
				(PREFER-QUOTES))
			      (SETQ MUST// T))
			     (T
			      (SETQ SOME-NOT-// T))))
		     (SETQ STATE
			   (AREF FSM
				 STATE
				 (COND ((NOT (< CHAR-CODE RDTBL-LIMIT))
					(FAST-RDTBL-CODE (CHAR-CODE #/A)))
				       ((FAST-ALWAYS-SLASHIFY-CODE-P CHAR-CODE)
					(SETQ MUST// T)	;YES: set flag.
					(RDTBL-SLASH-CODE READTABLE))
				       (T
					(FAST-RDTBL-CODE CHAR-CODE)))))))))
      (WHEN (AND (ZEROP LEN) EMPTY-OK)
	;; ``Damnable package names.''
	;; What the previous overly-cryptic comment seems to mean is:
	;;  The null symbol name prints, but the null package name doesn't print.
	;;  That is, ``foo:||'' rather than `foo:'
	;;       but ``:foo''   rather than ``||:foo''.
	;;  This same subroutine is called for both, so the EMPTY-OK argument
	;;  controls which to see.  If EMPTY-OK is T, nothing is displayed.
	;;  Otherwise, || is displayed.  -kmp 16-Sep-92
	(SETQ FSMWINS T))
      (COND ((AND FSMWINS (NOT MUST//)
		  (STRING-UNAFFECTED-BY-CASE-SHIFT-P STRING *PRINCASE* LEN))
	     (PRINT-RAW-STRING STRING STREAM))
	    ((AND #||(NEQ *PRINCASE* ':UPCASE)||# SOME-NOT-// FSMWINS)
	     (PRINT-CASED-STRING STRING STREAM MUST//))
	    (T
	      (LET ((INHIBIT-QUOTES (AND FSMWINS (NOT FORCE))))
		(COND (MUST//
			(WITH-BUFFERED-IO-STRING-STREAM (STREAM :SIZE (* 2 LEN)
								:FAST-WRITE-CHAR CHAR-OUT
								:SLOW-WRITE-CHAR-P NIL)
			  (LET ((STRING STRING))
			    (DECLARE (SYS:ARRAY-REGISTER STRING))
			    (UNLESS INHIBIT-QUOTES
			      (CHAR-OUT OPEN-QUOTE-CHARACTER))
			    (DOTIMES (I LEN)
			      (LET* ((CHAR (AREF STRING I)) (CHAR-CODE (CHAR-CODE CHAR)))
				(WHEN (AND (< CHAR-CODE RDTBL-LIMIT)
					   (FAST-ALWAYS-SLASHIFY-CODE-P CHAR-CODE))
				  (CHAR-OUT SLASH-CHARACTER))
				(CHAR-OUT CHAR)))
			    (UNLESS INHIBIT-QUOTES
			      (CHAR-OUT CLOSE-QUOTE-CHARACTER)))))
		      (T
			(UNLESS INHIBIT-QUOTES
			  (SEND STREAM :TYO OPEN-QUOTE-CHARACTER))
			(PRINT-RAW-STRING STRING STREAM)
			(UNLESS INHIBIT-QUOTES
			  (SEND STREAM :TYO CLOSE-QUOTE-CHARACTER))))))))))

;Print out a symbol's print-name.  If slashification is on,, try slashify it
;so that if read in the right thing will happen.
(DEFSUBST PRINT-PNAME-STRING-1 (STRING STREAM SLASHIFY-P EMPTY-OK
				&KEY
				 (FORCE NIL)
				 (OPEN-QUOTE-CHARACTER (PTTBL-OPEN-QUOTE-SYMBOL READTABLE))
				 (CLOSE-QUOTE-CHARACTER (PTTBL-CLOSE-QUOTE-SYMBOL READTABLE))
				 (SLASH-CHARACTER (PTTBL-SLASH READTABLE)))
  (IF (NOT SLASHIFY-P)
      (IF (EQ *PRINCASE* ':UPCASE)
	  (PRINT-RAW-STRING STRING STREAM)
	  (PRINT-CASED-STRING STRING STREAM NIL))
      (PRINT-PNAME-STRING-2 STRING STREAM EMPTY-OK FORCE
			    OPEN-QUOTE-CHARACTER CLOSE-QUOTE-CHARACTER SLASH-CHARACTER)))

(DEFUN PRINT-PNAME-STRING (SYMBOL SLASHIFY-P STREAM)
    ;; Print a prefix, if any is required
    (WHEN (AND SLASHIFY-P (SYMBOLP SYMBOL))
      (COND ((SYMBOL-PACKAGE SYMBOL)
	     (LET ((XP-STREAM STREAM))
	       (PKG-SYMBOL-PREFIX #'(LAMBDA (NAME IGNORE FLAG)
				      (PRINT-PNAME-STRING NAME T XP-STREAM)
				      (COND ((EQ FLAG ':SYNTAX)
					     (DOTIMES (I 3)
					       (DECLARE (IGNORE I))
					       (FUNCALL XP-STREAM ':TYO
						   (PTTBL-PACKAGE-CHAR READTABLE))))
					    (FLAG
					      (FUNCALL XP-STREAM ':STRING-OUT
						       (PTTBL-INTERNAL-PACKAGE-PREFIX
							 READTABLE)))
					    (T
					      (FUNCALL XP-STREAM ':TYO
						       (PTTBL-PACKAGE-CHAR READTABLE)))))
				  SYMBOL)))
	    (*PRINT-GENSYM*
	     (FUNCALL STREAM ':STRING-OUT (PTTBL-UNINTERNED-PREFIX READTABLE)))))
    ;; Now print the pname itself
    (PRINT-PNAME-STRING-1 (IF (SYMBOLP SYMBOL) (GET-PNAME SYMBOL) SYMBOL)
			  STREAM
			  SLASHIFY-P
			  (NOT (SYMBOLP SYMBOL))))

(DEFUN PRINT-CASED-STRING (STRING STREAM SLASH)
  (WITH-FAST-READTABLE-ACCESS (READTABLE)
    (WITH-BUFFERED-IO-STRING-STREAM (STREAM :SIZE (+ (* 2 (STRING-LENGTH STRING)) 2)
					    :FAST-WRITE-CHAR CHAR-OUT
					    :SLOW-WRITE-CHAR-P NIL)
      (FLET ((MAYBE-CHAR-DOWNCASE (CHAR CHAR-CODE)
	       (LET ((NEW-CHAR (CHAR-DOWNCASE CHAR)))
		 (IF (= CHAR-CODE (FAST-RDTBL-TRANS (CHAR-CODE NEW-CHAR)))
		     NEW-CHAR CHAR)))
	     (MAYBE-CHAR-UPCASE (CHAR CHAR-CODE)
	       (LET ((NEW-CHAR (CHAR-UPCASE CHAR)))
		 (IF (= CHAR-CODE (FAST-RDTBL-TRANS (CHAR-CODE NEW-CHAR)))
		     NEW-CHAR CHAR))))
	(DECLARE (CL:INLINE MAYBE-CHAR-DOWNCASE MAYBE-CHAR-UPCASE))
	(LET ((RDTBL-LIMIT (RDTBL-LIMIT READTABLE)))
	  (MACROLET ((HANDLE-UP-OR-DOWNCASE (CASE)
		       `(DOTIMES (I (ARRAY-ACTIVE-LENGTH STRING))
			  (LET ((STRING STRING))
			    (DECLARE (SYS:ARRAY-REGISTER STRING))
			    (LET* ((CHAR (AREF STRING I)) (CHAR-CODE (CHAR-CODE CHAR)))
			      (COND ((AND SLASH
					  (< CHAR-CODE RDTBL-LIMIT)
					  ;; need to check this, rather than just
					  ;; UPPER/LOWER-CASE-P so that we don't
					  ;; unnecessarily slashify characters outside
					  ;; of the standard-character-set.
					  (OR (FAST-TRANSLATED-CHAR-CODE-P CHAR-CODE)
					      (FAST-ALWAYS-SLASHIFY-CODE-P CHAR-CODE)))
				     (CHAR-OUT (PTTBL-SLASH READTABLE))
				     (CHAR-OUT CHAR))
				    (T
				     (CHAR-OUT (,(CL:CASE CASE
						   (:DOWNCASE 'MAYBE-CHAR-DOWNCASE)
						   (:UPCASE   'MAYBE-CHAR-UPCASE))
						CHAR CHAR-CODE)))))))))
	    (SELECTQ *PRINCASE*
	      (:DOWNCASE (HANDLE-UP-OR-DOWNCASE :DOWNCASE))
	      (:UPCASE (HANDLE-UP-OR-DOWNCASE :UPCASE))
	      (:CAPITALIZE
		;; STATE = T  means we just saw alphanumeric
		;; STATE = NIL means we just saw otherwise.
		(LET ((STATE NIL))
		  (DOTIMES (I (ARRAY-ACTIVE-LENGTH STRING))
		    (LET ((STRING STRING))
		      (DECLARE (SYS:ARRAY-REGISTER STRING))
		      (LET* ((CHAR (AREF STRING I)) (CHAR-CODE (CHAR-CODE CHAR)))
			(COND ((AND SLASH
				    (< CHAR-CODE RDTBL-LIMIT)
				    (FAST-ALWAYS-SLASHIFY-CODE-P CHAR-CODE))
			       (CHAR-OUT (PTTBL-SLASH READTABLE))
			       (CHAR-OUT CHAR)
			       (SETQ STATE NIL))
			      ((AND (< CHAR-CODE RDTBL-LIMIT)
				    (FAST-TRANSLATED-CHAR-CODE-P CHAR-CODE))
			       (WHEN SLASH
				 (CHAR-OUT (PTTBL-SLASH READTABLE)))
			       (CHAR-OUT CHAR)
			       (SETQ STATE T))
			      (STATE
			       (COND ((ALPHANUMERICP CHAR)
				      (CHAR-OUT (MAYBE-CHAR-DOWNCASE CHAR CHAR-CODE)))
				     (T
				      (CHAR-OUT CHAR)
				      (SETQ STATE NIL))))
			      (T
			       (COND ((ALPHANUMERICP CHAR)
				      (CHAR-OUT (MAYBE-CHAR-UPCASE CHAR CHAR-CODE))
				      (SETQ STATE T))
				     (T
				      (CHAR-OUT CHAR))))))))))
;;;           (:UPCASE
;;;	        (FERROR "~S should not be called when ~S is :UPCASE."
;;;                     'PRINT-CASED-STRING '*PRINCASE*))
	      (OTHERWISE
		(FERROR "~S is not a valid value of ~S." *PRINCASE* '*PRINCASE*)))))))))



#|| ;Just for QA.  To compile this

() ;Magic

(defvar *readtable-case-printing-correct-answer*
	"
READTABLE-CASE *PRINT-CASE*  Symbol-name  Output
--------------------------------------------------
:UPCASE        :UPCASE       ZEBRA        ZEBRA
:UPCASE        :UPCASE       Zebra        |Zebra|
:UPCASE        :UPCASE       zebra        |zebra|
:UPCASE        :DOWNCASE     ZEBRA        zebra
:UPCASE        :DOWNCASE     Zebra        |Zebra|
:UPCASE        :DOWNCASE     zebra        |zebra|
:UPCASE        :CAPITALIZE   ZEBRA        Zebra
:UPCASE        :CAPITALIZE   Zebra        |Zebra|
:UPCASE        :CAPITALIZE   zebra        |zebra|
:DOWNCASE      :UPCASE       ZEBRA        |ZEBRA|
:DOWNCASE      :UPCASE       Zebra        |Zebra|
:DOWNCASE      :UPCASE       zebra        ZEBRA
:DOWNCASE      :DOWNCASE     ZEBRA        |ZEBRA|
:DOWNCASE      :DOWNCASE     Zebra        |Zebra|
:DOWNCASE      :DOWNCASE     zebra        zebra
:DOWNCASE      :CAPITALIZE   ZEBRA        |ZEBRA|
:DOWNCASE      :CAPITALIZE   Zebra        |Zebra|
:DOWNCASE      :CAPITALIZE   zebra        Zebra
:PRESERVE      :UPCASE       ZEBRA        ZEBRA
:PRESERVE      :UPCASE       Zebra        Zebra
:PRESERVE      :UPCASE       zebra        zebra
:PRESERVE      :DOWNCASE     ZEBRA        ZEBRA
:PRESERVE      :DOWNCASE     Zebra        Zebra
:PRESERVE      :DOWNCASE     zebra        zebra
:PRESERVE      :CAPITALIZE   ZEBRA        ZEBRA
:PRESERVE      :CAPITALIZE   Zebra        Zebra
:PRESERVE      :CAPITALIZE   zebra        zebra"
  "Table of correct answers from X3J13/92-102, pages 22-6..22-7,
plus some others.")

(defun test-readtable-case (&key (verbose t)
			    (printer #'prin1)
			    ((:prefer-quotes *print-prefer-quotes*) *print-prefer-quotes*))
  (readtable-test-compare
    (with-output-to-string (cl:*standard-output*)
      (test-readtable-case-printing :printer printer))
    :verbose verbose))

(defun test-readtable-case-printing (&key (printer #'prin1))
  (let ((cl:*readtable* (cl:copy-readtable nil))
	(cl:*print-case* CL:*print-case*)
	(cl:*package* (symbol-package 'ZEBRA)))
    (format t "~%READTABLE-CASE *PRINT-CASE*  Symbol-name  Output~
               ~%--------------------------------------------------~
               ~%")
    (dolist (readtable-case '(:upcase :downcase :preserve #||:invert||#))
      (setf (future-common-lisp:readtable-case cl:*readtable*) readtable-case)
      (dolist (print-case '(:upcase :downcase :capitalize))
	(dolist (symbol '(|ZEBRA| |Zebra| |zebra|))
	  (setq cl:*print-case* print-case)
	  (format t "~&:~A~15T:~A~29T~A~42T~A"
		  (string-upcase readtable-case)
		  (string-upcase print-case)
		  (cl:symbol-name symbol)
		  (with-output-to-string (str)
		    (funcall printer symbol str))))))))

(defun readtable-test-compare (test-string &key (verbose t))
  (declare (values same correct))
  (with-input-from-string (str1 *readtable-case-printing-correct-answer*)
    (with-input-from-string (str2 test-string)
      (do ((l1 (cl:read-line str1 nil nil)
	       (cl:read-line str1 nil nil))
	   (l2 (cl:read-line str2 nil nil)
	       (cl:read-line str2 nil nil))
	   (correct t)
	   (same t))
	  ((or (null l1) (null l2))
	   (when (or l1 l2)
	     (when verbose (format t "~&Output of unequal length. This shouldn't happen.~%"))
	     (setq same nil correct nil))
	   (when verbose (format t "~&Test ~:[failed~;succeeded~]~:[~;, but came close~]."
				 same (and (not same) correct)))
	   (values same correct))
	(cond ((cl:equal l1 l2)
	       (when verbose (format t "~&  ~A~%" l2)))
	      (t
	       (setq same nil)
	       (when verbose
		 (let* ((value-gotten (scl:substring l2 42))
			(value-expected (scl:substring l1 29
						       (scl:string-search-set '(#\Tab #\Space)
									      l1
									      :start 29)))
			(equivalent
			  (with-input-from-string (s l1)
			    (let ((cl:*readtable* (copy-readtable)))
			      (setf (future-common-lisp:readtable-case cl:*readtable*)
				    (read s))
			      (let ((cl:*print-case* (read s)))
				(cl:string= value-expected
					    (read-from-string value-gotten)))))))
		   (setq correct (and correct equivalent))
		   (format t "~& ~A ~55T;Expected ~A~:[~; (equivalent)~]"
			   l2 (scl:substring l1 42) equivalent)))))))))

(defun benchmark-readtable-case (&key
				 (printer #'prin1)
				 (repeat-inner 25.)
				 (repeat-outer 100.)
				 (without-interrupts nil)
				 (print-cases '(:upcase :downcase :capitalize))
				 (readtable-cases
				   '(:upcase :downcase :preserve
					     #||:invert||#))
				 (symbols-to-print
				   '(|ZEBRA| |Zebra| |zebra|
				     |ZEBRA-STRIPES| |Zebra-Stripes| |Zebra-stripes|
				     |zebra-stripes| |Zebra Stripes| |Zebra\|Stripes|
				     |ZEBRA\|STRIPES|))
				 stream-setup
				 window
				 &aux
				 (print-cases+ (append print-cases '(:any)))
				 (readtable-cases+ (append readtable-cases '(:any))))
  (labels ((print-label (item stream)
	     (format stream "~:[total~;~S~]" (neq item :any) item))
	   (print-value (item stream)
	     (let ((total (apply #'+ item)) (n (length item)))
	       (format stream "~3$ (~D/~D/~D)"
		       (quotient (float total) n repeat-inner)
		       total n repeat-inner)))
	   (analyze (buckets)
	     (flet ((do-cells (function stream)
		      (dolist (readtable-case readtable-cases+)
			(formatting-cell (stream) (funcall function readtable-case stream)))))
	       (format t "~2&~D iteration~:P over ~D symbol~:P, ~
			     with all ~R combinations of ~
			     *PRINT-CASE* and READTABLE-CASE.~
			  ~%~D call~:P to the printer were made at each step.~
			  ~%Interrupts were ~:[enabled~;disabled~] during benchmark.~
			  ~%Time is given in internal time units (~D unit~:P = 1 second).~%"
		       repeat-outer (length symbols-to-print)
		       (* (length readtable-cases) (length print-cases))
		       repeat-inner without-interrupts
		       cl:internal-time-units-per-second)
	       (formatting-table ()
		 (formatting-row ()
		   (formatting-cell () (format t " *P-C* \\ R-C "))
		   (do-cells #'print-label cl:*standard-output*))
		 (dolist (print-case print-cases+)
		   (formatting-row ()
		     (formatting-cell () (print-label print-case cl:*standard-output*))
		     (do-cells #'(lambda (readtable-case stream)
				   (print-value (gethash (list readtable-case print-case)
							 buckets)
						stream))
			       cl:*standard-output*)))))
	     buckets)
	   (run-benchmark (buckets)
	     (let ((cl:*readtable* (cl:copy-readtable nil))
		   (cl:*print-case* CL:*print-case*)
		   (cl:*package* (symbol-package (car symbols-to-print)))
		   (scrap-string (cl:make-array 100 :element-type 'character :fill-pointer 0)))
	       (dotimes (i repeat-outer)
		 (dolist (readtable-case readtable-cases)
		   (setf (future-common-lisp:readtable-case cl:*readtable*) readtable-case)
		   (dolist (print-case print-cases)
		     (dolist (symbol symbols-to-print)
		       (setq cl:*print-case* print-case)
		       (setf (fill-pointer scrap-string) 0)
		       (funcall (or stream-setup
				    (if window
					#'(lambda (fn) (funcall fn window)))
				    #'(lambda (fn)
					(declare (sys:downward-function))
					(cl:with-output-to-string
					  (str scrap-string)
					  (funcall fn str))))
				#'(lambda (str)
				    (declare (sys:downward-function))
				    (let (then now)
				      (setq then (cl:get-internal-run-time))
				      (dotimes (n repeat-inner)
					(funcall printer symbol str))
				      (setq now (cl:get-internal-run-time))
				      (let ((duration (- now then)))
					(cl:push duration
						 (gethash (list readtable-case print-case)
							  buckets))
					(cl:push duration
						 (gethash (list :any :any) buckets))
					(cl:push duration
						 (gethash (list readtable-case :any) buckets))
					(cl:push duration
						 (gethash (list :any print-case)
							  buckets)))))))))))
	     buckets))
    (let ((buckets (cl:make-hash-table :test 'cl:equal)))
      (analyze (if without-interrupts
		   (without-interrupts (run-benchmark buckets))
		   (run-benchmark buckets))))))

||#



(DEFSUBST SLASHIFY-WITHIN-STRING-P (CHAR)
  (LET ((CODE (CHAR-CODE CHAR)))
    (AND (< CODE RDTBL-ARRAY-SIZE)
	 (BIT-TEST #o16 (RDTBL-BITS READTABLE CODE)))))

;Print a string, and if slashification is on, slashify it appropriately.
(DEFUN PRINT-QUOTED-STRING (STRING SLASHIFY-P STREAM)
  (WHEN (NOT SLASHIFY-P)
    (RETURN-FROM PRINT-QUOTED-STRING (PRINT-RAW-STRING STRING STREAM)))
  (SEND STREAM :TYO (PTTBL-OPEN-QUOTE-STRING READTABLE))
  (LET* ((STRING STRING)
	 (LENGTH (ARRAY-ACTIVE-LENGTH STRING)))
    (DECLARE (SYS:ARRAY-REGISTER STRING))
    (LOOP WITH OPEN = (PTTBL-OPEN-PAREN READTABLE)
	  AND SLASH = (PTTBL-SLASH READTABLE)
	  WITH BACK-INDEX = 0
	  FOR I FROM 0 BELOW LENGTH
	  AS PREV-CHAR = CHAR
	  AS CHAR = (AREF STRING I)
	  DO (COND ((OR (SLASHIFY-WITHIN-STRING-P CHAR)
			(AND (EQL PREV-CHAR #\CR) (EQL CHAR OPEN)))
		    (WHEN (> I BACK-INDEX)
		      (SEND STREAM :STRING-OUT STRING BACK-INDEX I))
		    (SEND STREAM :TYO SLASH)
		    (SEND STREAM :TYO CHAR)
		    (SETQ BACK-INDEX (1+ I)))
		   ((> (- I BACK-INDEX) 200) ;; reasonable size chunks
		    (SEND STREAM :STRING-OUT STRING BACK-INDEX I)
		    (SETQ BACK-INDEX I)))
	  FINALLY
	    (WHEN (> I BACK-INDEX)
	      (SEND STREAM :STRING-OUT STRING BACK-INDEX I))))
  (SEND STREAM :TYO (PTTBL-CLOSE-QUOTE-STRING READTABLE))
  NIL)

(DEFUN PRINT-NOT-READABLE (OBJECT)
  (SIGNAL 'PRINT-NOT-READABLE :OBJECT OBJECT))

(DEFPROP DTP-ODD-PC PRINT-PC PRINT)
(DEFPROP DTP-EVEN-PC PRINT-PC PRINT)

(DEFUN PRINT-PC (PC IGNORE SLASHIFY-P STREAM IGNORE IGNORE)
  (FLET ((PRINT-PC-INTERNAL (OFFSET FUNCTION STREAM)
	   ;; Be readable in the cold load.
	   (PRINC "PC " STREAM)
	   (LET ((BASE 8)) (PRINC OFFSET STREAM))
	   (PRINC " in " STREAM)
	   (PRINC FUNCTION STREAM)))
    (MULTIPLE-VALUE-BIND (FUNCTION OFFSET)
	(DECODE-PC PC)
      (IF SLASHIFY-P
	  (PRINTING-RANDOM-OBJECT (PC STREAM)
	    (PRINT-PC-INTERNAL OFFSET FUNCTION STREAM))
	  (PRINT-PC-INTERNAL OFFSET FUNCTION STREAM)))))

(DEFPROP DTP-LOCATIVE PRINT-LOCATIVE PRINT)

(DEFUN PRINT-LOCATIVE (LOCATIVE PRINDEPTH SLASHIFY-P STREAM WHICH-OPERATIONS RECURSIVE)
  (PRINTING-RANDOM-OBJECT (LOCATIVE STREAM)
    (SEND STREAM :STRING-OUT "LOCATIVE")
    (CONDITION-CASE (SPEC TYPE)
	 (COMPILER:DISASSEMBLE-DECODE-LOCATIVE LOCATIVE)
       (ERROR (SEND STREAM :STRING-OUT " (error decoding locative)"))
       (:NO-ERROR
	 (CL:CASE TYPE
	   (:VARIABLE
	    (SEND STREAM :STRING-OUT " to ")
	    (PRINT-OBJECT SPEC PRINDEPTH SLASHIFY-P STREAM WHICH-OPERATIONS RECURSIVE))
	   (:FUNCTION
	    (SEND STREAM :STRING-OUT " to #'")
	    (DW::WITH-OUTPUT-AS-PRESENTATION (:STREAM STREAM :OBJECT SPEC :TYPE 'FUNCTION-SPEC)
	      (PRINT-OBJECT SPEC PRINDEPTH SLASHIFY-P STREAM WHICH-OPERATIONS RECURSIVE))))))))
