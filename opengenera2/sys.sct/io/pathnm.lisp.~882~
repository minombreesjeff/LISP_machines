;;; -*- Mode: Lisp; Syntax: Zetalisp; Base: 8; Package: FILE-SYSTEM -*-

;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; Advertised function interfaces:
;;; PARSE-PATHNAME THING &OPTIONAL WITH-RESPECT-TO (DEFAULTS *DEFAULT-PATHNAME-DEFAULTS*)
;;;  Parses a string (or whatever) into a pathname.
;;; DEFAULT-PATHNAME &OPTIONAL DEFAULTS HOST DEFAULT-TYPE DEFAULT-VERSION
;;;  Returns the default for the given HOST from DEFAULTS.
;;; SET-DEFAULT-PATHNAME PATHNAME &OPTIONAL DEFAULTS
;;;  Sets the default for either the host of the pathname or the NIL default.
;;; MAKE-PATHNAME-DEFAULTS
;;;  Returns an alist that you can pass to the functions below that take a set of defaults.
;;;  Most things that take a set of defaults will also take a single pathname.
;;; MERGE-PATHNAMES PATHNAME &OPTIONAL DEFAULTS DEFAULT-VERSION
;;;  Fill in slots in PATHNAME from program defaults.  This is what most
;;;  programs interface to.
;;; MERGE-PATHNAMES-AND-SET-DEFAULTS PATHNAME &OPTIONAL DEFAULTS DEFAULT-VERSION
;;;  Does parse, merge, and updating of defaults.
;;; DESCRIBE-PATHNAME PATHNAME
;;;  Describes all files that look like pathname.  Also useful when you cannot remember what
;;;  directory a file is in.
;;; PATHNAME-PLIST PATHNAME

;;; Advertised messages on pathnames:
;;; :GET INDICATOR
;;; :PUTPROP PROP INDICATOR
;;; :REMPROP INDICATOR
;;; :HOST :DEVICE, :DIRECTORY, :NAME, :TYPE, :VERSION
;;; :RAW-DEVICE, :RAW-DIRECTORY, :RAW-NAME, :RAW-TYPE
;;; :NEW-DEVICE, :NEW-DIRECTORY, :NEW-NAME, :NEW-TYPE, :NEW-VERSION
;;; :NEW-PATHNAME &REST OPTIONS
;;; :DEFAULT-NAMESTRING STRING
;;; :GENERIC-PATHNAME
;;; :STRING-FOR-HOST, :STRING-FOR-PRINTING, :STRING-FOR-EDITOR
;;; :STRING-FOR-DIRED
;;; :INIT-FILE PROGRAM-NAME CANONICAL-TYPE
;;; :CANONICAL-TYPE  -> canonical-type original-type
;;; :NEW-CANONICAL-TYPE canonical-type &optional original-type
;;; :TYPES-FOR-CANONICAL-TYPE

;;; Advertised special variables:
;;; *KNOWN-TYPES* - list of types unimportant for the sake of generic pathnames.
;;; *ITS-UNINTERESTING-TYPES* - types that do not deserve the FN2 slot.

;;; Other system types (pathname syntaxes) must implement at least the following messages:
;;; They can then be mixed with CHAOS-PATHNAME for use with the QFILE chaosnet file
;;; job protocol.
;;;  :STRING-FOR-HOST - returns a string that can be sent to the file computer that
;;;  specifying the file in question.
;;;  :PARSE-NAMESTRING - takes a string and returns multiple values for various components
;;;  present in the string.
;;; See ITS-PATHNAME-MIXIN and/or TOPS20-PATHNAME-MIXIN for additional details.

;;; To add another protocol, implement the messages of CHAOS-PATHNAME for generic file
;;; manipulation.  That flavor is defined in QFILE.

;;; Interaction with host objects:
;;; The HOST instance variable of a pathname is a host object, as
;;; outlined in AI: LISPM2; HOST >.
;;; *PATHNAME-HOST-LIST* is the set of all pathname hosts.  Some of
;;; these are actual hosts on the local network, such as MIT-AI, and
;;; others are logical hosts, such as SYS.  When parsing a string into a
;;; pathname, the specified host (the part of the string before the
;;; colon) is sent in the :PATHNAME-HOST-NAMEP message to each host in
;;; this list.  When that returns T, that host is used.
;;; The host is sent a :PATHNAME-FLAVOR message to determine the flavor of the
;;; pathname to instantiate.  (If the reply to :PATHNAME-FLAVOR returns multiple
;;; values, the second is an addition for the INIT-PLIST to use when instantiating.)
;;; Normally, when printing the host portion of a pathname, the host is
;;; sent a :NAME-AS-FILE-COMPUTER message.

;; The pathname hash table, pathnames, and cached strings are stored here to improve locality.
;; Individual :STRING-FOR-mumble methods can save a string copy by explicitly
;; consing the string in PATHNAME-AREA, but this is not necessary.
(DEFVAR PATHNAME-AREA (MAKE-AREA ':NAME 'PATHNAME-AREA
				 ':GC ':STATIC))

(DEFGENERIC PATHNAME-READABLE-P (PATHNAME)
  "T if this pathname is interned and readable, NIL otherwise")

;;; This is a separate flavor so there can be dummy pathnames which just print and store
;;; properties.
(DEFFLAVOR EMPTY-PATHNAME () (FLAVOR:PROPERTY-LIST-MIXIN))

(DEFMETHOD (PATHNAME-READABLE-P EMPTY-PATHNAME) () NIL)

;;; PRINC of a pathname is just like PRINC of the :STRING-FOR-PRINTING
(DEFMETHOD (:PRINT-SELF EMPTY-PATHNAME) (STREAM IGNORE SLASHIFY-P &AUX TEM)
  (LET ((SCL:*PRINT-STRING-LENGTH* NIL))
    (IF (PATHNAME-READABLE-P SELF)
	(COND ((NOT SLASHIFY-P)
	       (SEND STREAM ':STRING-OUT (SEND SELF ':STRING-FOR-PRINTING)))
	      ((SETQ TEM (GET (LOCF (SI:RDTBL-PLIST READTABLE)) ':PATHNAME-PRINTER))
	       (FUNCALL TEM SELF STREAM))
	      (T
	       (SI:PRINTING-RANDOM-OBJECT (SELF STREAM :TYPEP :NO-POINTER)
		 (PRIN1 (SEND SELF ':STRING-FOR-READABLE-PRINTING) STREAM))))
      (SYS:PRINTING-RANDOM-OBJECT (SELF STREAM :TYPEP)
	(FORMAT STREAM (SEND SELF :STRING-FOR-PRINTING))))))

(DEFMETHOD (:PLIST EMPTY-PATHNAME) ()
  FLAVOR:PROPERTY-LIST)

(DEFMETHOD (:STRING-FOR-READABLE-PRINTING EMPTY-PATHNAME :DEFAULT) ()
  (SEND SELF :STRING-FOR-PRINTING))

;;; This is for use by things like the editor which have structures that store file-like
;;; properties on non-pathname objects.
(DEFFLAVOR DUMMY-PATHNAME (NAME) (EMPTY-PATHNAME)
  (:WRITABLE-INSTANCE-VARIABLES)
  (:INITABLE-INSTANCE-VARIABLES))

(DEFMETHOD (:STRING-FOR-PRINTING DUMMY-PATHNAME) ()
  NAME)

(DEFMETHOD (:STRING-FOR-EDITOR DUMMY-PATHNAME) ()
  NAME)

(DEFMETHOD (:STRING-FOR-DIRED DUMMY-PATHNAME) ()
  NAME)

(DEFUN MAKE-DUMMY-PATHNAME (NAME &OPTIONAL PLIST)
  (MAKE-INSTANCE 'DUMMY-PATHNAME ':NAME NAME ':PROPERTY-LIST PLIST))

;;; The guts of this flavor are defined in PATHST, but we can't
;;; compile this file without it.

(DEFFLAVOR CASE-MIXIN () ())

(DEFFLAVOR FUTURE-COMMON-LISP:PATHNAME () ())

;;; This is the actual base flavor
(DEFFLAVOR PATHNAME
	(HOST
	 (DEVICE NIL)
	 (DIRECTORY NIL)
	 (NAME NIL)
	 (TYPE NIL)
	 (VERSION NIL)
	 (VC-BRANCH NIL)			;for Version Control
	 (VC-VERSION NIL)			;for Version Control
	 (FLAVOR:PROPERTY-LIST NIL)		;Where files properties are stored
	 (STRING-FOR-PRINTING NIL)
	 (VC-STRING-FOR-PRINTING NIL)
	 )
	(CASE-MIXIN EMPTY-PATHNAME FUTURE-COMMON-LISP:PATHNAME)
; These now just send the messages. (See below)
; (:OUTSIDE-ACCESSIBLE-INSTANCE-VARIABLES HOST DEVICE DIRECTORY NAME TYPE VERSION
;					 FLAVOR:PROPERTY-LIST)
  (:GETTABLE-INSTANCE-VARIABLES HOST VERSION VC-BRANCH VC-VERSION FLAVOR:PROPERTY-LIST)
  (:INITABLE-INSTANCE-VARIABLES HOST DEVICE DIRECTORY NAME TYPE VERSION
				VC-BRANCH VC-VERSION
				FLAVOR:PROPERTY-LIST
				STRING-FOR-PRINTING)
  (:READABLE-INSTANCE-VARIABLES VC-BRANCH VC-VERSION)
  (:INIT-KEYWORDS :OTHER-COMPONENTS)
  (:REQUIRED-METHODS :PARSE-NAMESTRING)
  (:METHOD-COMBINATION :DECACHE-HOST-NAME (:PROGN :MOST-SPECIFIC-LAST)
		       :DECACHE-CACHED-STRINGS (:PROGN :MOST-SPECIFIC-LAST)
                       :BEFORE-FULL-GC (:PROGN :MOST-SPECIFIC-LAST))
  (:DEFAULT-INIT-PLIST :AREA PATHNAME-AREA)	;Store them here
  :ABSTRACT-FLAVOR) 

(DEFMETHOD (PATHNAME-READABLE-P PATHNAME) () T)

(DEFSUBST PATHNAME-HOST (P)		(SEND P ':HOST))
(DEFSUBST PATHNAME-DEVICE (P)		(SEND P ':DEVICE))
(DEFSUBST PATHNAME-DIRECTORY (P)	(SEND P ':DIRECTORY))
(DEFSUBST PATHNAME-NAME (P)		(SEND P ':NAME))
(DEFSUBST PATHNAME-TYPE (P)		(SEND P ':TYPE))
(DEFSUBST PATHNAME-VERSION (P)		(SEND P ':VERSION))
(DEFSUBST PATHNAME-PROPERTY-LIST (P)    (SEND P ':PROPERTY-LIST))
#||
(DEFPROP PATHNAME-PROPERTY-LIST
	 ((PATHNAME-PROPERTY-LIST PATHNAME) . (SEND PATHNAME ':PROPERTY-LIST-LOCATION))
	 LOCF)
||#

;And these are for the people who were fucked over by the changing of the above
(DEFSUBST PATHNAME-HOST-INSTANCE-VARIABLE (P) (SYMEVAL-IN-INSTANCE P 'HOST))
(DEFSUBST PATHNAME-DEVICE-INSTANCE-VARIABLE (P) (SYMEVAL-IN-INSTANCE P 'DEVICE))
(DEFSUBST PATHNAME-DIRECTORY-INSTANCE-VARIABLE (P) (SYMEVAL-IN-INSTANCE P 'DIRECTORY))
(DEFSUBST PATHNAME-NAME-INSTANCE-VARIABLE (P) (SYMEVAL-IN-INSTANCE P 'NAME))
(DEFSUBST PATHNAME-TYPE-INSTANCE-VARIABLE (P) (SYMEVAL-IN-INSTANCE P 'TYPE))
(DEFSUBST PATHNAME-VERSION-INSTANCE-VARIABLE (P) (SYMEVAL-IN-INSTANCE P 'VERSION))

(DEFMETHOD (MAKE-INSTANCE PATHNAME) (&REST IGNORE)
  (OR (VARIABLE-BOUNDP HOST)
      (FERROR "Host must be specified when initializing a pathname"))) 

;; used globally.
(CL:DEFPARAMETER *VC-PATHNAME-DELIMITER* #\)

;; Set to NIL when we save a world with VC pathnames removed
(CL:DEFPARAMETER *VC-PATHNAME-PARSING-ENABLED* T)

(DEFVAR-RESETTABLE *VC-PATHNAME-STRING-APPEND-IN-PROGRESS* NIL NIL)

;;; Caching of strings
(DEFMACRO-IN-FLAVOR (CACHE-IN-VARIABLE PATHNAME) (VARIABLE-OR-VARIABLE-AND-AREA
						   &BODY BODY)
  (LET ((AREA 'PATHNAME-AREA)
	(VARIABLE))
    (IF (LISTP VARIABLE-OR-VARIABLE-AND-AREA)
	(DESTRUCTURING-BIND (VAR &KEY (X-AREA 'PATHNAME-AREA)) VARIABLE-OR-VARIABLE-AND-AREA
	  (SETQ AREA X-AREA VARIABLE VAR))
	(SETQ VARIABLE VARIABLE-OR-VARIABLE-AND-AREA))
    `(OR ,VARIABLE
	 (SETQ ,VARIABLE (SI:COPY-INTO-AREA-IF-NOT-THERE (PROGN ,@BODY) ,AREA))))) 

;;--- :UNSPECIFIC in VC branches and versions means precisely what NIL means
;;--- elsewhere in pathnames (and vice-versa).  Namely, NIL in a VC slot means
;;--- that the pathname is D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")not0 a VC pathname (and those NILs are not later
;;--- superseded during merging), and :UNSPECIFIC in a VC slot 1is0 later merged.
;; Note that printing VC pathnames always works, even if parsing them is
;; disabled, in case a VC pathname crept into the world somehow.
(DEFUN-IN-FLAVOR (VC-STRING-FOR-PRINTING PATHNAME) ()
  (STRING-APPEND *VC-PATHNAME-DELIMITER*
		 (COND ((EQ VC-BRANCH ':WILD) "*")
		       ((EQ VC-BRANCH ':UNSPECIFIC) "")
		       ((NOT (NULL VC-BRANCH)) VC-BRANCH)
		       (T ""))
		 (IF VC-VERSION *VERSION-DELIMITER* "")	
		 (COND ((EQ VC-VERSION ':OLDEST) "oldest") 
		       ((EQ VC-VERSION ':NEWEST) "newest")
		       ((EQ VC-VERSION ':PARENT) "parent")
		       ((EQ VC-VERSION ':UNSPECIFIC) "")
		       ((EQ VC-VERSION ':WILD) "*")
		       ((NUMBERP VC-VERSION)
			(FORMAT NIL "~D" VC-VERSION))
		       (T ""))))

(DEFMETHOD (PATHNAME-VC-P PATHNAME) () (VC-P))

(DEFMACRO-IN-FLAVOR (WITH-VC-INFO-APPENDED PATHNAME) (&BODY BODY)
  `(LET ((NORMAL-STRING
	   (LET ((*VC-PATHNAME-STRING-APPEND-IN-PROGRESS* T))
	     ,@BODY)))
     (IF (AND (VC-P) (NOT *VC-PATHNAME-STRING-APPEND-IN-PROGRESS*))   
	 (STRING-APPEND NORMAL-STRING (VC-STRING-FOR-PRINTING))
	 NORMAL-STRING)))

(DEFSUBST-IN-FLAVOR (VC-P PATHNAME) ()
  (OR VC-BRANCH VC-VERSION))

(DEFWHOPPER-SUBST (:STRING-FOR-PRINTING PATHNAME) ()
  (IF *VC-PATHNAME-STRING-APPEND-IN-PROGRESS*
      (OR STRING-FOR-PRINTING
	  (SETQ STRING-FOR-PRINTING (CONTINUE-WHOPPER)))
      (OR VC-STRING-FOR-PRINTING
	  (SETQ VC-STRING-FOR-PRINTING
		(WITH-VC-INFO-APPENDED (CONTINUE-WHOPPER))))))

(DEFMETHOD (:DECACHE-HOST-NAME PATHNAME) ()
  (SEND SELF ':DECACHE-CACHED-STRINGS))

(DEFMETHOD (:DECACHE-CACHED-STRINGS PATHNAME) ()
  (SETQ STRING-FOR-PRINTING NIL
	VC-STRING-FOR-PRINTING NIL))

(DEFMETHOD (:BEFORE-FULL-GC PATHNAME) (GC-FUNCTION)
  (SEND SELF ':DECACHE-CACHED-STRINGS)
  (FUNCALL GC-FUNCTION (LOCF DEVICE))
  (FUNCALL GC-FUNCTION (LOCF DIRECTORY))
  (FUNCALL GC-FUNCTION (LOCF NAME))
  (FUNCALL GC-FUNCTION (LOCF TYPE))
  (FUNCALL GC-FUNCTION (LOCF VC-BRANCH))
  (FUNCALL GC-FUNCTION (LOCF VC-VERSION))) 

(DEFMETHOD (:STRING-FOR-DIRED PATHNAME) ()
  (SEND SELF ':STRING-FOR-PRINTING))

(DEFMETHOD (:STRING-FOR-MINI PATHNAME) ()
  (SEND SELF ':STRING-FOR-PRINTING))

(DEFMETHOD (:STRING-FOR-DIRECTORY PATHNAME) ()
  (SEND SELF ':STRING-FOR-PRINTING))

(DEFMETHOD (:STRING-FOR-WHOLINE PATHNAME) ()
  (SEND (IF (EQ VERSION :NEWEST) (SEND SELF :NEW-VERSION NIL) SELF) ':STRING-FOR-PRINTING))

(DEFWHOPPER-SUBST (:STRING-FOR-READABLE-PRINTING PATHNAME) ()
  (WITH-VC-INFO-APPENDED (CONTINUE-WHOPPER)))

(DEFWHOPPER-SUBST (:STRING-FOR-DIRED PATHNAME) ()
  (WITH-VC-INFO-APPENDED (CONTINUE-WHOPPER)))

(DEFWHOPPER-SUBST (:STRING-FOR-MINI PATHNAME) ()
  (WITH-VC-INFO-APPENDED (CONTINUE-WHOPPER)))

(DEFWHOPPER-SUBST (:STRING-FOR-DIRECTORY PATHNAME) ()
  (WITH-VC-INFO-APPENDED (CONTINUE-WHOPPER)))

(DEFWHOPPER-SUBST (:STRING-FOR-WHOLINE PATHNAME) ()
  (WITH-VC-INFO-APPENDED (CONTINUE-WHOPPER)))

(DEFWHOPPER-SUBST (:STRING-FOR-EDITOR PATHNAME) ()
  (WITH-VC-INFO-APPENDED (CONTINUE-WHOPPER)))

;;Most pathnames specify files which can be read with the usual stream
;;I/O functions.  DBFS-PATHNAMEs are one exception.  See sys:statice;file;dbfs-pathnames.
(defmethod (pathname-sequentially-accessible-p pathname) () t)


;;; This is a pathname that corresponds to a real (as opposed to logical) host
(DEFFLAVOR HOST-PATHNAME
	((STRING-FOR-EDITOR NIL)
	 (STRING-FOR-DIRED NIL)
	 (STRING-FOR-DIRECTORY NIL)
	 )
	(PATHNAME)
  :INITABLE-INSTANCE-VARIABLES)

(DEFWHOPPER-SUBST (:STRING-FOR-EDITOR HOST-PATHNAME) ()
  (CACHE-IN-VARIABLE (STRING-FOR-EDITOR :AREA 'ZWEI:*ZMACS-BUFFER-AREA*)
	(CONTINUE-WHOPPER)))

(DEFWHOPPER-SUBST (:STRING-FOR-DIRED HOST-PATHNAME) ()
  (CACHE-IN-VARIABLE STRING-FOR-DIRED (CONTINUE-WHOPPER)))

(DEFWHOPPER-SUBST (:STRING-FOR-DIRECTORY HOST-PATHNAME) ()
  (CACHE-IN-VARIABLE STRING-FOR-DIRECTORY (CONTINUE-WHOPPER)))

(DEFMETHOD (:DECACHE-CACHED-STRINGS HOST-PATHNAME) ()
  (SETQ STRING-FOR-EDITOR NIL
	STRING-FOR-DIRED NIL
	STRING-FOR-DIRECTORY NIL))

;;; This is a pathname connected by some remote medium.  It might even be a local file
;;; system if that interfaces through a :STRING-FOR-HOST.
(DEFFLAVOR REMOTE-PATHNAME
	((STRING-FOR-HOST NIL)			;Caches
	 )
	(HOST-PATHNAME)
  (:REQUIRED-METHODS :STRING-FOR-HOST)
  :INITABLE-INSTANCE-VARIABLES)

(DEFMETHOD (:STRING-FOR-PRINTING REMOTE-PATHNAME) ()
  (STRING-APPEND (SEND HOST ':NAME-AS-FILE-COMPUTER) ":"
		 (SEND SELF ':STRING-FOR-HOST)))

(DEFMETHOD (:STRING-FOR-EDITOR REMOTE-PATHNAME) ()
  (STRING-APPEND (SEND SELF ':STRING-FOR-HOST) #\SP
		 (SEND HOST ':NAME-AS-FILE-COMPUTER) #/:))

(DEFWHOPPER-SUBST (:STRING-FOR-HOST REMOTE-PATHNAME) (&OPTIONAL DIRECTION)
  ;; The remote host should never see any VC stuff...
  (CACHE-IN-VARIABLE STRING-FOR-HOST
		     (IF DIRECTION
			 (CONTINUE-WHOPPER DIRECTION)
			 (CONTINUE-WHOPPER))))

(DEFMETHOD (:DECACHE-CACHED-STRINGS REMOTE-PATHNAME) ()
  (SETQ STRING-FOR-HOST NIL))

(DEFMETHOD (:STRING-FOR-MINI REMOTE-PATHNAME) ()
  (SEND SELF ':STRING-FOR-HOST))

(DEFMETHOD (:STRING-FOR-DIRECTORY REMOTE-PATHNAME) ()
  (SEND SELF ':STRING-FOR-HOST))

(DEFMETHOD (:NEW-DEVICE PATHNAME) (NEW-DEVICE)
  (SEND SELF ':NEW-PATHNAME ':DEVICE NEW-DEVICE))

(DEFMETHOD (:NEW-RAW-DEVICE PATHNAME) (NEW-DEVICE)
  (SEND SELF ':NEW-PATHNAME ':RAW-DEVICE NEW-DEVICE))

(DEFMETHOD (:NEW-DIRECTORY PATHNAME) (NEW-DIRECTORY)
  (SEND SELF ':NEW-PATHNAME ':DIRECTORY NEW-DIRECTORY))

(DEFMETHOD (:NEW-RAW-DIRECTORY PATHNAME) (NEW-DIRECTORY)
  (SEND SELF ':NEW-PATHNAME ':RAW-DIRECTORY NEW-DIRECTORY))

(DEFMETHOD (:NEW-NAME PATHNAME) (NEW-NAME)
  (SEND SELF ':NEW-PATHNAME ':NAME NEW-NAME))

(DEFMETHOD (:NEW-RAW-NAME PATHNAME) (NEW-NAME)
  (SEND SELF ':NEW-PATHNAME ':RAW-NAME NEW-NAME))

(DEFMETHOD (:NEW-TYPE PATHNAME) (NEW-TYPE)
  (SEND SELF ':NEW-PATHNAME ':TYPE NEW-TYPE))

(DEFMETHOD (:NEW-RAW-TYPE PATHNAME) (NEW-TYPE)
  (SEND SELF ':NEW-PATHNAME ':RAW-TYPE NEW-TYPE))

(DEFMETHOD (:NEW-VERSION PATHNAME) (NEW-VERSION)
  (SEND SELF ':NEW-PATHNAME ':VERSION NEW-VERSION))

(DEFMETHOD (:NEW-VC-BRANCH PATHNAME) (NEW-BRANCH)
  (SEND SELF :NEW-PATHNAME ':VC-BRANCH NEW-BRANCH))

(DEFMETHOD (:NEW-VC-VERSION PATHNAME) (NEW-VERSION)
  (SEND SELF :NEW-PATHNAME ':VC-VERSION NEW-VERSION))


(DEFMETHOD (:PRIMARY-DEVICE PATHNAME) ()
  ':UNSPECIFIC)

;;; These exist for the sake of ITS
(DEFMETHOD (:NEW-TYPE-AND-VERSION PATHNAME) (NEW-TYPE NEW-VERSION)
  (SEND SELF ':NEW-PATHNAME ':TYPE NEW-TYPE ':VERSION NEW-VERSION))

(COMPILER:MAKE-MESSAGE-OBSOLETE :NEW-TYPE-AND-VERSION
  "Not all uses of :NEW-TYPE-AND-VERSION//:TYPE-AND-VERSION
can be handled by the same procedures for encoding type and
version in filesystems without version numbers.

In simple cases where special kludgery to get around lack
of version numbers is not required, use
:NEW-PATHNAME :TYPE <type> :VERSION <version> instead.

In more difficult cases, use the extended logical-pathname
translation feature, which is capable of a variety of encodings
of type and version, depending on the exact requirements.

See the file SYS: IO; LOGPATH.LISP for details on predefined
translation methods, and details on how to define your own.")

(DEFMETHOD (:TYPE-AND-VERSION PATHNAME) ()
  (VALUES TYPE VERSION))

(COMPILER:MAKE-MESSAGE-OBSOLETE :TYPE-AND-VERSION
  "Not all uses of :NEW-TYPE-AND-VERSION//:TYPE-AND-VERSION
can be handled by the same procedures for encoding type and
version in filesystems without version numbers.

Use the extended logical-pathname translation feature,
which is capable of a variety of encodings of type and
version, depending on the exact requirements.  Use
:BACK-TRANSLATED-PATHNAME'ing with the physical pathname,
to get a logical pathname with the desired type and
version decoded.

See the file SYS: IO; LOGPATH.LISP for details on
predefined translation methods, and details on how
to define your own.")

(DEFMETHOD (:PATCH-FILE-NAME PATHNAME)
	   (SYSTEM-NAME SAME-DIRECTORY-P PATOM &OPTIONAL MAJOR-VERSION MINOR-VERSION)
  (FORMAT NIL "~:[~A~*~;~*~A~]~@[-~D~]~@[-~D~]"
	  (EQ SAME-DIRECTORY-P :EXPLICIT) SYSTEM-NAME PATOM MAJOR-VERSION MINOR-VERSION))

(DEFMETHOD (:PATCH-FILE-PATHNAME PATHNAME)
	   (SYSTEM-NAME SAME-DIRECTORY-P PATOM PATCH-TYPE
			&OPTIONAL MAJOR-VERSION MINOR-VERSION FILE-TYPE)
  (SELECTQ PATCH-TYPE
    (:SYSTEM-DIRECTORY
     (SEND SELF :NEW-PATHNAME
	   :NAME (SEND SELF :PATCH-FILE-NAME SYSTEM-NAME SAME-DIRECTORY-P PATOM)
	   :CANONICAL-TYPE :PATCH-SYSTEM-DIRECTORY
	   :VERSION :NEWEST))
    (:COMPONENT-DIRECTORY
     (SEND SELF :NEW-PATHNAME
	   :NAME (SEND SELF :PATCH-FILE-NAME
		       SYSTEM-NAME SAME-DIRECTORY-P PATOM MAJOR-VERSION)
	   :CANONICAL-TYPE :PATCH-COMPONENT-DIRECTORY
	   :VERSION :NEWEST))
    (:PATCH-DIRECTORY
     (SEND SELF :NEW-PATHNAME
	   :NAME (SEND SELF :PATCH-FILE-NAME
		       SYSTEM-NAME SAME-DIRECTORY-P PATOM MAJOR-VERSION)
	   :CANONICAL-TYPE :PATCH-PATCH-DIRECTORY
	   :VERSION :NEWEST))
    (:VC-SOURCE-CHANGE-JOURNAL
     (SEND SELF :NEW-PATHNAME
	   :NAME (SEND SELF :PATCH-FILE-NAME
		       SYSTEM-NAME SAME-DIRECTORY-P PATOM MAJOR-VERSION)
	   :CANONICAL-TYPE :VC-SOURCE-CHANGE-JOURNAL
	   :VERSION :NEWEST))
    (:PATCH-FILE
     (SEND SELF :NEW-PATHNAME
	   :NAME (SEND SELF :PATCH-FILE-NAME
		       SYSTEM-NAME SAME-DIRECTORY-P PATOM MAJOR-VERSION MINOR-VERSION)
	   :CANONICAL-TYPE FILE-TYPE
	   :VERSION :NEWEST))))

#||
(DEFMETHOD (:OLD-PATCH-FILE-PATHNAME PATHNAME)
	   (SYSTEM-NAME SAME-DIRECTORY-P PATOM PATCH-TYPE
			&OPTIONAL MAJOR-VERSION MINOR-VERSION FILE-TYPE)
  (SELECTQ PATCH-TYPE
    (:SYSTEM-DIRECTORY
     (SEND SELF ':NEW-PATHNAME
	   ':NAME (IF SAME-DIRECTORY-P PATOM (STRING SYSTEM-NAME))
	   ':CANONICAL-TYPE ':PATCH-SYSTEM-DIRECTORY
	   ':VERSION ':NEWEST))
    (:VERSION-DIRECTORY				;--- :PATCH-DIRECTORY in SCT
     (SEND SELF ':NEW-PATHNAME
	   ':NAME (FORMAT NIL "~:[~A~*~;~*~A~]-~D"
			  SAME-DIRECTORY-P SYSTEM-NAME PATOM MAJOR-VERSION)
	   ':CANONICAL-TYPE ':PATCH-VERSION-DIRECTORY	;--- :PATCH-PATCH-DIRECTORY in SCT
	   ':VERSION ':NEWEST))
    (:PATCH-FILE
     (SEND SELF ':NEW-PATHNAME
	   ':NAME (FORMAT NIL "~:[~A~*~;~*~A~]-~D-~D"
			  SAME-DIRECTORY-P SYSTEM-NAME PATOM MAJOR-VERSION MINOR-VERSION)
	   ':CANONICAL-TYPE FILE-TYPE
	   ':VERSION ':NEWEST))))
||#

(DEFMETHOD (:INIT-FILE PATHNAME) (PROGRAM-NAME CANONICAL-TYPE)
  (SEND SELF ':NEW-PATHNAME ':NAME (STRING-APPEND PROGRAM-NAME "-INIT")
			    ':CANONICAL-TYPE CANONICAL-TYPE
			    ':VERSION ':NEWEST
			    ':VC-BRANCH NIL
			    ':VC-VERSION NIL
			    )) 

;;; Default is for users to have their own directories on the primary device.
;;; This code is duplicated in (LMFS-PATHNAME :HOMEDIR).
;;; The caller must guarentee that (SEND HOST ':HOST-USER-ID) will return the right
;;; value.
(DEFMETHOD (:HOMEDIR PATHNAME) ()
  ;; Assume top-level-directory on primary device
  (MAKE-PATHNAME ':HOST HOST ':DEVICE (SEND SELF ':PRIMARY-DEVICE)
		 ':DIRECTORY (LIST (SEND HOST ':HOST-USER-ID))))

;; Make a guess for the home directory if we don't have it.  Don't ask the host.
(DEFMETHOD (:QUIET-HOMEDIR PATHNAME) ()
  (MAKE-PATHNAME ':HOST HOST
		 ':DEVICE (SEND SELF ':PRIMARY-DEVICE)
		 ':DIRECTORY (LIST (OR (SEND HOST ':HOST-USER-ID) "FOO"))))

;;; These are the defaults you get if you don't get anything else.
(DEFVAR *DEFAULT-PATHNAME-DEFAULTS*)

;;; This is a user variable, it says whether defaults are maintained on a per-host basis, or
;;; one default for all hosts.
(DEFVAR *DEFAULTS-ARE-PER-HOST* NIL)

;;; Canonical types for which the type in the generic pathname is NIL rather than coming
;;; from the pathname.
;;; :TEXT and other known types are not in this list so that you can have two editor buffers,
;;; one on the .LISP and one on the .TEXT without their mode lines interfering.
(DEFVAR *KNOWN-TYPES* '(:LISP :QBIN :BIN :IBIN :VBIN NIL :UNSPECIFIC)) 

;;; Should this leave the VC branch? Not yet, because the whole mechanism for 
;;; source file recording isn't really prepared to deal with two different
;;; version from two different branches.
(DEFMETHOD (:GENERIC-PATHNAME PATHNAME) ()
  ;; Don't do any excess work if we already have a generic pathname
  (IF (AND (NULL TYPE) (NULL VERSION) (NULL VC-BRANCH) (NULL VC-VERSION))
      SELF
    (SEND SELF :NEW-PATHNAME
	       :RAW-TYPE (IF (MEMBER (SEND SELF ':CANONICAL-TYPE) *KNOWN-TYPES*) NIL TYPE)
	       :VERSION NIL
	       :VC-BRANCH NIL
	       :VC-VERSION NIL)))

;;; Definitions for the pathname hashing protocol with hosts.

;; This is used during FULL-GC
(DEFVAR *INHIBIT-PATHNAME-CREATION* NIL)

(DEFUN PATHNAME-HASH-TABLE-GET-PATHNAME-INTERNAL
       (HOST HASH-TABLE DEV DIR NAM TYP VRS OTHERS VC-BRANCH VC-VERSION KEY)
  (DECLARE (VALUES PATHNAME OLD-P))
  ;; Have to remove style because the case-sensitive pathnames don't
  ;; ignore style information.
  (SETQ KEY (STRING-THIN-PATHNAME-COMPONENT KEY))
  ;; If VC is not enabled, then we have to kludge the version
  (WHEN (AND (NOT *VC-PATHNAME-PARSING-ENABLED*)
	     (OR VC-BRANCH VC-VERSION))
    (SETQ VRS (FLAT-VERSION-FROM-VC-VERSION-AND-VERSION VC-VERSION VRS))
    (SETQ VC-BRANCH NIL
	  VC-VERSION NIL))
  (LET ((PATHNAME (CLI::FAST-TABLE-GET HASH-TABLE KEY)))
    (IF PATHNAME				;no such thing as a pathname of NIL,
						;so we don't need the second argument.
	(VALUES PATHNAME T)
      (WHEN *INHIBIT-PATHNAME-CREATION*
	(ERROR "Attempt to create a pathname during pathname GC"))
      (MACROLET ((BLESS (&REST ITEMS)
		   `(SETQ
		      ,@(LOOP FOR ITEM IN ITEMS
			      APPEND `(,ITEM (STRING-THIN-PATHNAME-COMPONENT ,ITEM))))))
	(BLESS DEV DIR NAM TYP VRS VC-BRANCH VC-VERSION OTHERS))
      (SETQ PATHNAME (NETI:PATHNAME-HOST-MAKE-PATHNAME HOST DEV DIR NAM TYP VRS OTHERS 
			   VC-BRANCH VC-VERSION))
      (SEND PATHNAME ':VALIDATE)
      ;; Now get a key which is a permanent object (not stack consed) and which
      ;; may not be EQUAL to the other key if there were component validation errors.
      (LET ((NEW-KEY (SEND PATHNAME ':HASH-KEY)))
	;; Since the two keys come from methods on different flavors, check that the
	;; host and pathname flavors were defined consistently.
	(OR (= (LENGTH NEW-KEY) (LENGTH KEY))
	    (FERROR "The host flavor and the pathname flavor have inconsistent hash keys"))
	;; We don't worry about the fact we may have CONSed a pathname that we'll
	;; discard if someone else got in here first.  We do it this way so we cannot
	;; hold the lock while erroring for pathname reasons
	;; We depend on the hash table to provide the process locking.
	(BLOCK INTERN
	  (SCL:MODIFY-HASH
	    HASH-TABLE NEW-KEY
	    #'(LAMBDA (KEY OLD-PATHNAME EXISTS-P)
		(DECLARE (SYS:DOWNWARD-FUNCTION))
		(IGNORE KEY)
		(IF EXISTS-P
		    (RETURN-FROM INTERN (VALUES OLD-PATHNAME T))
		    ;; just return the new pathname to be stashed into the table.
		    PATHNAME)))
	  (VALUES PATHNAME NIL))))))


;;; Defined here because its used in this file.  Could be in PATHS.
;;; Method on a host.
(DEFGENERIC NETI:PATHNAME-HOST-GET-PATHNAME
	    (PATHNAME-HOST DEV DIR NAM TYP VRS OTHERS VC-BRANCH VC-VERSION))

;;;
;;; Macrology to define the pathname and host methods in a single form,
;;; so as to avoid any possibility of inconsistency.

(DEFPROP DEFINE-PATHNAME-KEY-METHODS "Pathname key methods" SI:DEFINITION-TYPE-NAME)

(DEFPROP DEFINE-PATHNAME-KEY-METHODS DEFINE-PATHNAME-KEY-METHODS
	 ZWEI:DEFINITION-FUNCTION-SPEC-TYPE)

;;; --- move this to the editor?
(DEFUN (:PROPERTY DEFINE-PATHNAME-KEY-METHODS ZWEI:DEFINITION-FUNCTION-SPEC-FINDER) (BP)
  (AND (SETQ BP (ZWEI:FORWARD-OVER ZWEI:*WHITESPACE-CHARS* BP))
       (ZWEI:FORWARD-LIST BP 1 NIL -1 T)))

;;; This macro can be used to define both the PATHNAME-HOST-GET-PATHNAME of
;;; a pathname host and the :HASH-KEY method of the corresponding pathname,
;;; so long as you don't want to use the :OTHER-COMPONENTS feature.
;;; In that case, there is no well-defined correspondence between 
;;; the contents of :OTHER-COMPONENTS and the pathname's instance variables.
;;; For now, if you want that, you have to write your own methods.
;;;
;;; --- furthermore, there is a risk that a non-VC pathname will hash
;;; --- the same as a VC pathname if the first two elements of the other component
;;; --- list are the same as some vc info, and the length of the keys is not
;;; --- compared.
(DEFMACRO DEFINE-PATHNAME-KEY-METHODS
	  ((HOST-FLAVOR PATHNAME-FLAVOR) &BODY KEY-ELEMENT-FORMS)
  (FLET ((.HOST-DO-IT ()
	   `(PATHNAME-HASH-TABLE-GET-PATHNAME-INTERNAL
		SELF
		(SEND SELF :PATHNAME-HASH-TABLE)
		.DEVICE
		.DIRECTORY
		.NAME
		.TYPE
		.VERSION
		.OTHERS
		.VC-BRANCH
		.VC-VERSION
		.KEY)))
    (LIST					;nested backquote is too painful.
      `PROGN
      `(RECORD-SOURCE-FILE-NAME ',HOST-FLAVOR 'DEFINE-PATHNAME-KEY-METHODS)
      `(DEFMETHOD (NETI:PATHNAME-HOST-GET-PATHNAME ,HOST-FLAVOR)
		    (.DEVICE .DIRECTORY .NAME .TYPE .VERSION .OTHERS .VC-BRANCH .VC-VERSION)
	   (DECLARE (SYS:FUNCTION-PARENT ,HOST-FLAVOR DEFINE-PATHNAME-KEY-METHODS))
	   (MACROLET ((GP-DEVICE () '.DEVICE)
		      (GP-DIRECTORY () '.DIRECTORY)
		      (GP-NAME () '.NAME)
		      (GP-TYPE () '.TYPE)
		      (GP-VERSION () '(IF (AND (NOT *VC-PATHNAME-PARSING-ENABLED*)
					       (OR .VC-BRANCH .VC-VERSION))
					  (FLAT-VERSION-FROM-VC-VERSION-AND-VERSION
					    .VC-VERSION .VERSION)
					  .VERSION))
		      (GP-OTHERS () '.OTHERS)
		      (GP-HOST () 'SELF))
	     (IF (AND *VC-PATHNAME-PARSING-ENABLED*
		      (OR .VC-BRANCH .VC-VERSION))
		 (WITH-STACK-LIST (.KEY ,@KEY-ELEMENT-FORMS .VC-BRANCH .VC-VERSION)
		   ,(.HOST-DO-IT))
		 (WITH-STACK-LIST (.KEY ,@KEY-ELEMENT-FORMS)
		   ,(.HOST-DO-IT)))))
	`(DEFMETHOD (:HASH-KEY ,PATHNAME-FLAVOR) ()
	   (DECLARE (SYS:FUNCTION-PARENT ,HOST-FLAVOR DEFINE-PATHNAME-KEY-METHODS))
	   (MACROLET ((GP-DEVICE () 'DEVICE)
		      (GP-DIRECTORY () 'DIRECTORY)
		      (GP-NAME () 'NAME)
		      (GP-TYPE () 'TYPE)
		      (GP-VERSION () '(IF (AND (NOT *VC-PATHNAME-PARSING-ENABLED*)
					       (OR VC-BRANCH VC-VERSION))
					  (FLAT-VERSION-FROM-VC-VERSION-AND-VERSION
					    VC-VERSION VERSION)
					  VERSION))
		      (GP-HOST () `(PATHNAME-HOST SELF)))
	     (IF (AND *VC-PATHNAME-PARSING-ENABLED*
		      (OR VC-BRANCH VC-VERSION))
		 (LIST-IN-AREA PATHNAME-AREA ,@KEY-ELEMENT-FORMS VC-BRANCH VC-VERSION)
		 (LIST-IN-AREA PATHNAME-AREA ,@KEY-ELEMENT-FORMS))))
	`(DEFMETHOD (WITH-HASH-KEY-INTERNAL ,PATHNAME-FLAVOR) (CONTINUATION)
	   (DECLARE (SYS:DOWNWARD-FUNARG CONTINUATION)
		    (SYS:FUNCTION-PARENT ,HOST-FLAVOR DEFINE-PATHNAME-KEY-METHODS))
	   (MACROLET ((GP-DEVICE () 'DEVICE)
		      (GP-DIRECTORY () 'DIRECTORY)
		      (GP-NAME () 'NAME)
		      (GP-TYPE () 'TYPE)
		      (GP-VERSION () '(IF (AND (NOT *VC-PATHNAME-PARSING-ENABLED*)
					       (OR VC-BRANCH VC-VERSION))
					  (FLAT-VERSION-FROM-VC-VERSION-AND-VERSION
					    VC-VERSION VERSION)
					  VERSION))
		      (GP-HOST () `(PATHNAME-HOST SELF)))
	     (IF (AND *VC-PATHNAME-PARSING-ENABLED*
		      (OR VC-BRANCH VC-VERSION))
		 (WITH-STACK-LIST (.KEY. ,@KEY-ELEMENT-FORMS VC-BRANCH VC-VERSION)
		   (FUNCALL CONTINUATION SELF .KEY.))
		 (WITH-STACK-LIST (.KEY. ,@KEY-ELEMENT-FORMS)
		   (FUNCALL CONTINUATION SELF .KEY.)))))))) 

(DEFMACRO WITH-PATHNAME-HASH-KEY ((PATHNAME KEY) &BODY BODY)
  `(WITH-HASH-KEY-INTERNAL
     PATHNAME
     #'(LAMBDA (,PATHNAME ,KEY)
	 ,@BODY)))


(DEFVAR *CANONICAL-TYPES-ALIST* NIL
  "Alist of system types to canonical-type definitions.")

(DEFVAR *DEFAULT-CANONICAL-TYPES* NIL
  "Alist of canonical types to types when none are defined per-system")

;;; for obvious reasons, this cannot be used with abandon.
;;; mostly useful when you have typo'ed.
(DEFUN UNDEFINE-CANONICAL-TYPE (CANONICAL-TYPE)
  (LET ((SYSTEMS-TO-DELETE NIL))
    (LOOP FOR SYSTEM-ENTRY IN *CANONICAL-TYPES-ALIST*
	  DO (CL:SETF (CDR SYSTEM-ENTRY)
		      (CL:DELETE CANONICAL-TYPE (CDR SYSTEM-ENTRY)
				 :KEY #'FIRST))
	     (WHEN (NULL (CDR SYSTEM-ENTRY))
	       (PUSH SYSTEM-ENTRY SYSTEMS-TO-DELETE)))
    (WHEN SYSTEMS-TO-DELETE
      (SETQ *CANONICAL-TYPES-ALIST*
	    (CL:SET-DIFFERENCE *CANONICAL-TYPES-ALIST* SYSTEMS-TO-DELETE))))
  (SETQ *DEFAULT-CANONICAL-TYPES* (CL:DELETE CANONICAL-TYPE *DEFAULT-CANONICAL-TYPES*
					     :KEY #'FIRST)))

(DEFUN LOOKUP-CANONICAL-TYPE (SYSTEM-TYPE ORIGINAL-TYPE)
  (DECLARE (VALUES CANONICAL-TYPE ORIGINAL-TYPE))
  (LOOP WITH ENTRIES = (CDR (ASSQ SYSTEM-TYPE *CANONICAL-TYPES-ALIST*))
	FOR (CANONICAL-TYPE . TYPES) IN ENTRIES
	WHEN (MEM #'STRING= ORIGINAL-TYPE TYPES)
	  DO (IF (STRING= ORIGINAL-TYPE (FIRST TYPES))
		 (RETURN (VALUES CANONICAL-TYPE NIL))
	       (RETURN (VALUES CANONICAL-TYPE ORIGINAL-TYPE)))
	FINALLY
	(RETURN (DO ((L *DEFAULT-CANONICAL-TYPES* (CDR L)))
		    ((NULL L) (VALUES ORIGINAL-TYPE ORIGINAL-TYPE))
		  (WHEN (MEM #'STRING= ORIGINAL-TYPE (CDAR L))
		    (IF (STRING= ORIGINAL-TYPE (CADAR L)) ;preferred?
			(RETURN (VALUES (CAAR L) NIL))
		      (RETURN (VALUES (CAAR L) ORIGINAL-TYPE))))))))

(DEFPROP DEFINE-CANONICAL-TYPE "Canonical type" SI:DEFINITION-TYPE-NAME)
(DEFMACRO DEFINE-CANONICAL-TYPE (CANONICAL-TYPE DEFAULT &BODY SPECS)
  `(DEFINE-CANONICAL-TYPE-1 ',CANONICAL-TYPE ',DEFAULT ',SPECS))

(DEFUN CHECK-CANONICAL-TYPE-1 (CANONICAL-TYPE DEFAULT)
  (LOOP FOR (EXISTING-CANONICAL-TYPE . STRINGS) IN *DEFAULT-CANONICAL-TYPES*
	UNLESS (EQ CANONICAL-TYPE EXISTING-CANONICAL-TYPE)
	  WHEN (MEMBER DEFAULT STRINGS)
	    DO (FERROR "~A is already defined as the default for cannonical type ~S,~@
			 cannot redefine it as the default for canonical type ~S."
			DEFAULT EXISTING-CANONICAL-TYPE CANONICAL-TYPE)))

(DEFUN CHECK-CANONICAL-TYPE-2 (CANONICAL-TYPE SYSTEM-TYPE TYPES)
  (CHECK-ARG SYSTEM-TYPE (MEMQ SYSTEM-TYPE NETI:ALL-SYSTEM-TYPES) "a system type")
  (LOOP FOR TYPE IN TYPES
	FOR EXISTING-CANONICAL-TYPE = (LOOKUP-CANONICAL-TYPE SYSTEM-TYPE TYPE)
	UNLESS (OR (STRINGP TYPE) (EQ TYPE :UNSPECIFIC))	;ITS kludge
	  DO (FERROR "~S is not a string, it cannot be a file type." TYPE)
	UNLESS (EQ CANONICAL-TYPE EXISTING-CANONICAL-TYPE)	;Redefinition
	  UNLESS (OR (STRINGP EXISTING-CANONICAL-TYPE)		;New definition
		     (AND (EQ TYPE :UNSPECIFIC)			;Oddball case, not a string
			  (EQ EXISTING-CANONICAL-TYPE :UNSPECIFIC)))
	    DO (FERROR "~A is already defined as the ~A canonical type ~S.~@
			 You may not redefine it as the ~S canonical type."
			TYPE SYSTEM-TYPE EXISTING-CANONICAL-TYPE
			CANONICAL-TYPE)))

(DEFUN DEFINE-CANONICAL-TYPE-1 (CANONICAL-TYPE DEFAULT SPECS
				&AUX (DEFAULT-CONS-AREA PATHNAME-AREA))
  (CHECK-ARG CANONICAL-TYPE KEYWORDP "a keyword")
  (CHECK-ARG-TYPE DEFAULT :STRING)
  (RECORD-SOURCE-FILE-NAME CANONICAL-TYPE 'DEFINE-CANONICAL-TYPE)
  (CHECK-CANONICAL-TYPE-1 CANONICAL-TYPE DEFAULT)
  (LOOP FOR (SYSTEM-TYPES . TYPES) IN SPECS
	WHEN (NOT (LISTP SYSTEM-TYPES))
	  DO (SETQ SYSTEM-TYPES (LIST SYSTEM-TYPES))
     DO (LOOP FOR SYSTEM-TYPE IN SYSTEM-TYPES
	      FOR BUCKET = (ASSQ SYSTEM-TYPE *CANONICAL-TYPES-ALIST*)
	      DO (CHECK-CANONICAL-TYPE-2 CANONICAL-TYPE SYSTEM-TYPE TYPES)
	      UNLESS BUCKET
	        DO (SETQ BUCKET (NCONS SYSTEM-TYPE))
		   (PUSH BUCKET *CANONICAL-TYPES-ALIST*)
	      DO (LET ((TYPE-BUCKET (ASSQ CANONICAL-TYPE (CDR BUCKET))))
		   (UNLESS TYPE-BUCKET
		     (SETQ TYPE-BUCKET (NCONS CANONICAL-TYPE))
		     (NCONC BUCKET (NCONS TYPE-BUCKET)))
		   (SETF (CDR TYPE-BUCKET) (COPYLIST TYPES)))))
  (IF (NOT (LISTP DEFAULT))
      (SETQ DEFAULT (LIST DEFAULT)))
  (LET ((BUCKET (ASSQ CANONICAL-TYPE *DEFAULT-CANONICAL-TYPES*)))
    (UNLESS BUCKET
      (SETQ BUCKET (NCONS CANONICAL-TYPE))
      (SETF *DEFAULT-CANONICAL-TYPES* (NCONC *DEFAULT-CANONICAL-TYPES* (NCONS BUCKET))))
    (SETF (CDR BUCKET) DEFAULT)))



;;; The central definition of what types have what meaning on what systems.
;;; Be sure to give types in upper-case, as they are compared between systems
;;; in case-dependent manner.
;;; Note theory behind UNIX42 system type: it should generally prefer the same
;;; as LMFS, but support anything that vanilla UNIX supports.

;;; The central definition of what types have what meaning on what systems.
;;; Be sure to give types in upper-case, as they are compared between systems
;;; in case-dependent manner.
;;; Note theory behind UNIX42 system type: it should generally prefer the same
;;; as LMFS, but support anything that vanilla UNIX supports.

(DEFINE-CANONICAL-TYPE :LISP "LISP"
  ((:TENEX :TOPS-20) "LISP" "LSP")
  (:ITS :UNSPECIFIC)				;A crock, maybe wrong.  --RWK
  (:UNIX "L" "LISP")
  (:UNIX42 "LISP" "L")
  ((:VMS4 :VMS4.4) "LISP" "LSP")
  ((:VMS :MSDOS :OS//2) "LSP"))

(DEFINE-CANONICAL-TYPE :TEXT "TEXT"
  ((:TENEX :TOPS-20) "TEXT" "TXT")
  (:UNIX "TX" "TEXT" "TXT")
  (:UNIX42 "TEXT" "TX" "TXT")
  ((:VMS4 :VMS4.4) "TEXT" "TXT")
  ((:VMS :MSDOS :OS//2) "TXT"))

(DEFINE-CANONICAL-TYPE :MIDAS "MIDAS"
  ((:TENEX :TOPS-20) "MID" "MIDAS")
  (:UNIX "MD")
  ((:UNIX42 :VMS4 :VMS4.4) "MIDAS" "MD")
  ((:VMS :FEP :MSDOS :OS//2) "MID"))

(DEFINE-CANONICAL-TYPE :QBIN "QBIN"
  (:UNIX "QB" "QBIN")
  (:UNIX42 "QBIN" "QB")
  (:VMS4 "QBN" "QBIN")
  (:VMS4.4 "QBIN" "QBN")
  ((:VMS :MSDOS :OS//2) "QBN"))

(DEFPROP :QBIN 16. :BINARY-FILE-BYTE-SIZE)

(DEFINE-CANONICAL-TYPE :BIN "BIN"
  (:UNIX "BN" "BIN")
  (:UNIX42 "BIN" "BN"))

(DEFPROP :BIN 16. :BINARY-FILE-BYTE-SIZE)

(DEFINE-CANONICAL-TYPE :IBIN "IBIN"
  (:UNIX "IB" "IBIN")
  (:UNIX42 "IBIN" "IB")
  ((:VMS4 :VMS4.4) "IBIN")
  ((:VMS :MSDOS :OS//2) "IBN"))

(DEFPROP :IBIN 16. :BINARY-FILE-BYTE-SIZE)

(DEFINE-CANONICAL-TYPE :VBIN "VBIN"
  (:UNIX "VB" "VBIN")
  (:UNIX42 "VBIN" "VB")
  ((:VMS4 :VMS4.4) "VBIN")
  ((:VMS :MSDOS :OS//2) "VBN"))

(DEFPROP :VBIN 16. :BINARY-FILE-BYTE-SIZE)

(DEFINE-CANONICAL-TYPE :PRESS "PRESS"
  (:UNIX "PR" "PRESS")
  (:UNIX42 "PR" "PRESS")
  (:FEP "PRES")
  ((:VMS4 :VMS4.4) "PRESS" "PRS")
  ((:VMS :MSDOS) "PRS"))

(DEFPROP :PRESS 8. :BINARY-FILE-BYTE-SIZE)

(DEFINE-CANONICAL-TYPE :LGP "LGP"
  (:UNIX "LG" "LGP")
  (:UNIX42 "LGP" "LG"))

(DEFPROP :LGP 8. :BINARY-FILE-BYTE-SIZE)

(FS:DEFINE-CANONICAL-TYPE :LGP2-METRICS "LGP2-METRICS"
  ((:UNIX :VMS) "L2M"))

(DEFPROP :LGP2-METRICS 8. :BINARY-FILE-BYTE-SIZE)

;; The system directory for all versions of a system
(DEFINE-CANONICAL-TYPE :PATCH-SYSTEM-DIRECTORY "SYSTEM-DIR"
  (:UNIX "SD")
  (:UNIX42 "SYSTEM-DIR" "SD")
  (:VMS4 "SPD" "SYSTEM-DIR")
  (:VMS4.4 "SYSTEM-DIR" "SPD")
  ((:VMS :FEP :MSDOS :OS//2) "SPD")
  (:ITS "(SDIR)"))

;; The per-version components of a system
(DEFINE-CANONICAL-TYPE :PATCH-COMPONENT-DIRECTORY "COMPONENT-DIR"
  (:UNIX "CD")
  (:UNIX42 "COMPONENT-DIR" "CD")
  (:VMS4 "CPD" "COMPONENT-DIR")
  (:VMS4.4 "COMPONENT-DIR" "CPD")
  ((:VMS :FEP :MSDOS :OS//2) "CPD")
  (:ITS "(CDIR)"))

;; The patch directory for a version of a system
(DEFINE-CANONICAL-TYPE :PATCH-PATCH-DIRECTORY "PATCH-DIR"
  (:UNIX "PD")
  (:UNIX42 "PATCH-DIR" "PD")
  (:VMS4 "PPD" "PATCH-DIR")
  (:VMS4.4 "PATCH-DIR" "PPD")
  ((:VMS :FEP :MSDOS :OS//2) "PPD")
  (:ITS "(PDIR)"))

(DEFINE-CANONICAL-TYPE :VC-SOURCE-CHANGE-JOURNAL "SC-JOURNAL"
  (:UNIX "SCJ")
  (:UNIX42 "SC-JOURNAL")
  (:VMS4 "SCJ" "SC-JOURNAL")
  (:VMS4.4 "SC-JOURNAL" "SCJ")
  ((:VMS :FEP :MSDOS :OS//2) "SCJ")
  (:ITS "(SCJ)"))

(DEFINE-CANONICAL-TYPE :BABYL "BABYL"
  (:UNIX "BB" "BABYL")
  (:UNIX42 "BABYL" "BB")
  ((:VMS4 :VMS4.4) "BABYL" "BAB")
  ((:VMS :FEP :MSDOS :OS//2) "BAB"))

(DEFINE-CANONICAL-TYPE :XMAIL "XMAIL"
  (:UNIX "XM" "XMAIL")
  (:UNIX42 "XMAIL" "XM")
  ((:VMS4 :VMS4.4) "XMAIL" "XML")
  ((:VMS :FEP :MSDOS :OS//2) "XML"))

(DEFINE-CANONICAL-TYPE :MAIL "MAIL"
  (:UNIX "MA" "MAIL")
  (:UNIX42 "MAIL" "MA")
  (:VMS4 "MAI" "MAIL")
  (:VMS4.4 "MAIL" "MAI")
  ((:VMS :MSDOS :OS//2) "MAI"))

(DEFINE-CANONICAL-TYPE :RMAIL "RMAIL"
  (:UNIX "RM")
  (:UNIX42 "RMAIL" "RM")
  ((:VMS4 :VMS4.4) "RMAIL" "RML")
  ((:VMS :FEP :MSDOS :OS//2) "RML"))

(DEFINE-CANONICAL-TYPE :ZMAIL-TEMP "_ZMAIL"
  (:UNIX "_Z" "_ZMAIL")
  (:UNIX42 "_ZMAIL" "_Z")
  ((:VMS4 :VMS4.4) "_ZMAIL" "ZMT")
  ((:VMS :FEP :MSDOS :OS//2) "ZMT"))

(DEFINE-CANONICAL-TYPE :GMSGS "GMSGS"
  (:UNIX "G" "GMSGS")
  (:UNIX42 "GMSGS" "G")
  ((:VMS4 :VMS4.4) "GMSGS" "GM")
  ((:VMS :FEP :MSDOS :OS//2) "GM"))

(DEFINE-CANONICAL-TYPE :GMSGS-TEMP "_GMSGS"
  (:UNIX "_G" "_GMSGS")
  (:UNIX42 "_GMSGS" "_G")
  ((:VMS4 :VMS4.4) "_GMSGS" "GMT")
  ((:VMS :FEP :MSDOS :OS//2) "GMT"))

(DEFINE-CANONICAL-TYPE :KBIN "KBIN"
  (:VMS "KBN")
  ((:VMS4 :VMS4.4) "KBIN" "KBN")
  (:UNIX42 "KBIN" "KB")
  (:UNIX "KB" "KBIN"))
(DEFPROP :KBIN 16. :BINARY-FILE-BYTE-SIZE)

(DEFINE-CANONICAL-TYPE :UNBIN "UNBIN"
  (:UNIX "UB" "UNBIN")
  (:UNIX42 "UNBIN" "UB")
  ((:VMS4 :VMS4.4) "UNBIN" "UNB")
  ((:VMS :FEP :MSDOS :OS//2) "UNB"))

(DEFINE-CANONICAL-TYPE :OUTPUT "OUTPUT"
  (:UNIX "OT" "OUTPUT")
  (:UNIX42 "OUTPUT" "OT")
  (:VMS4 "OUT" "OUTPUT")
  (:VMS4.4 "OUTPUT" "OUT")
  ((:VMS :FEP :MSDOS :OS//2) "OUT"))

(DEFINE-CANONICAL-TYPE :ULOAD "ULOAD"
  (:UNIX "UL" "ULOAD")
  (:UNIX42 "ULOAD" "UL")
  ((:VMS4 :VMS4.4) "ULOAD" "ULD")
  ((:VMS :FEP :MSDOS :OS//2) "ULD"))

(DEFINE-CANONICAL-TYPE :MCR "MCR"
  (:UNIX "MC" "MCR")
  (:UNIX42 "MCR" "MC"))

(DEFINE-CANONICAL-TYPE :SYM "SYM"
  (:UNIX "SM" "SYM")
  (:UNIX42 "SYM" "SM"))

(DEFINE-CANONICAL-TYPE :TBL "TBL"
  (:UNIX "TB" "TBL")
  (:UNIX42 "TBL" "TB"))

(DEFINE-CANONICAL-TYPE :MICROCODE "MIC")
(DEFPROP :MICROCODE 8 :BINARY-FILE-BYTE-SIZE)
(DEFINE-CANONICAL-TYPE :ERROR-TABLE "ERR")

(DEFINE-CANONICAL-TYPE :FEP-COMMAND "FEP-COMMAND"
  (:FEP "BOOT"))

(DEFINE-CANONICAL-TYPE :FEP-LOAD "FLOD"
  ((:VMS4 :VMS4.4) "FLOD" "FLD")
  (:VMS  "FLD"))
(DEFPROP :FEP-LOAD 8 :BINARY-FILE-BYTE-SIZE)

(PROGN

(DEFINE-CANONICAL-TYPE :SYNC-PROGRAM "SYNC"
  (:UNIX "SN" "SYNC")
  (:UNIX42 "SYNC" "SN")
  ((:VMS4 :VMS4.4) "SYNC" "SYN")
  ((:VMS :MSDOS :OS//2) "SYN"))  
(DEFPROP :SYNC-PROGRAM 8 :BINARY-FILE-BYTE-SIZE)

)

(DEFINE-CANONICAL-TYPE :CWARNS "CWARNS"
  (:UNIX "CW" "CWARNS")
  (:UNIX42 "CWARNS" "CW")
  ((:VMS4 :VMS4.4) "CWARNS" "CWN")
  ((:VMS :FEP :MSDOS :OS//2) "CWN"))

(DEFINE-CANONICAL-TYPE :SYSTEM "SYSTEM"
  (:UNIX "SY" "SYSTEM")
  (:UNIX42 "SYSTEM" "SY")
  ((:VMS4 :VMS4.4) "SYSTEM" "SYD")
  ((:VMS :FEP :MSDOS :OS//2) "SYD"))

(DEFINE-CANONICAL-TYPE :FONT-WIDTHS "WIDTHS"
  ((:VMS4 :VMS4.4) "WIDTHS" "WID")
  ((:VMS :FEP :MSDOS :OS//2) "WID")
  (:UNIX "WD" "WIDTHS")
  (:UNIX42 "WIDTHS" "WD"))

(DEFPROP :FONT-WIDTHS 16. :BINARY-FILE-BYTE-SIZE)

(DEFINE-CANONICAL-TYPE :BFD "BFD")		;used by sys: io1; bfd

(DEFPROP :BFD 16. :BINARY-FILE-BYTE-SIZE)
  
(DEFINE-CANONICAL-TYPE :KST "KST"
  (:UNIX "KT" "KST")
  (:UNIX42 "KST" "KT"))

(DEFPROP :KST 9. :BINARY-FILE-BYTE-SIZE)

(DEFINE-CANONICAL-TYPE :AC "AC")  ;used by sys: io1; fntcnv

(DEFPROP :AC 16. :BINARY-FILE-BYTE-SIZE)

(DEFINE-CANONICAL-TYPE :AL "AL")  ;used by sys: io1; fntcnv

(DEFPROP :AL 16. :BINARY-FILE-BYTE-SIZE)

(DEFINE-CANONICAL-TYPE :KS "KS")  ;used by sys: io1; fntcnv

(DEFPROP :KS 16. :BINARY-FILE-BYTE-SIZE)

(DEFINE-CANONICAL-TYPE :AST "AST"  ;used by sys: io1; fntcnv
  (:UNIX "AT" "AST")
  (:UNIX42 "AST" "AT"))

;For SUDS
(DEFINE-CANONICAL-TYPE :PLT "PLT"
  (:UNIX "PL" "PLT")
  (:UNIX42 "PLT" "PL"))

;Hardcopy wants to read these 36-bit files as 9-bit bytes
(DEFPROP :PLT 9. :BINARY-FILE-BYTE-SIZE)

;For SUDS
(DEFINE-CANONICAL-TYPE :DRW "DRW")

;12-bit bytes are the most efficient way to store 36-bit words
(DEFPROP :DRW 12. :BINARY-FILE-BYTE-SIZE)

;For SUDS
(DEFINE-CANONICAL-TYPE :WD "WD")

;12-bit bytes are the most efficient way to store 36-bit words
(DEFPROP :WD 12. :BINARY-FILE-BYTE-SIZE)

;For SUDS
(DEFINE-CANONICAL-TYPE :DIP "DIP")

;12-bit bytes are the most efficient way to store 36-bit words
(DEFPROP :DIP 12. :BINARY-FILE-BYTE-SIZE)

;For SUDS
(DEFINE-CANONICAL-TYPE :SAV "SAV")

;12-bit bytes are the most efficient way to store 36-bit words
(DEFPROP :SAV 12. :BINARY-FILE-BYTE-SIZE)

(DEFINE-CANONICAL-TYPE :MAP "MAP")  ;used by sys: lmfs; backup-aux

(DEFINE-CANONICAL-TYPE :CONSOLIDATED-MAP "CON-MAP"  ;used by sys: lmfs; backup-aux
  ((:VMS4 :VMS4.4) "CON-MAP" "CON")
  ((:VMS :FEP :MSDOS :OS//2) "CON")
  (:UNIX "CM")
  (:UNIX42 "CON-MAP" "CM"))

(DEFINE-CANONICAL-TYPE :TAGS "TAGS"		;used by sys: zwei; sectio
  (:UNIX "TG" "TAGS")
  (:UNIX42 "TAGS" "TG")
  ((:VMS4 :VMS4.4) "TAGS" "TAG")
  ((:VMS :FEP :MSDOS :OS//2) "TAG"))

(DEFINE-CANONICAL-TYPE :PALX-BIN "PALX_BIN"
  (:TOPS-20 "PBIN")
  (:TENEX "PBIN")
  (:UNIX "PB" "PBIN")
  (:UNIX42 "PALX_BIN" "PBIN" "PB")
  ((:VMS4 :VMS4.4) "PALX-BIN" "PXB")
  ((:VMS :FEP :MSDOS :OS//2) "PXB"))

(DEFPROP :PALX-BIN 8. :BINARY-FILE-BYTE-SIZE)

(DEFINE-CANONICAL-TYPE :XGP "XGP"
  (:UNIX "XG" "XGP")
  (:UNIX42 "XGP" "XG"))

(DEFINE-CANONICAL-TYPE :LIL "LIL"
  (:UNIX "LL" "LIL")
  (:UNIX42 "LIL" "LL"))

(DEFINE-CANONICAL-TYPE :FORTRAN "FOR"
  (:LISPM "FORTRAN" "FOR" "FTN")
  ((:VMS4 :VMS4.4) "FOR" "FORTRAN" "FTN")
  (:UNIX "F")
  (:UNIX42 "F" "FOR" "FTN" "FORTRAN"))		; Prefer F since its so common on UNIX.

(FS:DEFINE-CANONICAL-TYPE :PASCAL "PASCAL"
  (:LISPM "PASCAL" "PAS")
  (:VMS4 "PAS" "PASCAL")
  (:VMS4.4 "PASCAL" "PAS")
  ((:VMS :MSDOS :OS//2) "PAS")
  (:UNIX "P"))

(FS:DEFINE-CANONICAL-TYPE :C "C"
  ((:LISPM :UNIX :UNIX42 :VMS :VMS4 :MSDOS :OS//2) "C"))

(FS:DEFINE-CANONICAL-TYPE :C-INCLUDE "H"
  ((:LISPM :UNIX :UNIX42 :VMS :VMS4 :MSDOS :OS//2) "H"))

(DEFINE-CANONICAL-TYPE :SAGE-RECORD "SAR")	;Sage database record files

(DEFINE-CANONICAL-TYPE :SAGE-BINARY "SAB")	;Sage parsed database files and indexes

(DEFPROP :SAGE-BINARY 8. :BINARY-FILE-BYTE-SIZE)

(DEFINE-CANONICAL-TYPE :MSS "MSS"		;for Scribe files, needed by editor
  ((:UNIX :UNIX42) "MSS" "MS"))

(DEFINE-CANONICAL-TYPE :LOGICAL-PATHNAME-DIRECTORY-TRANSLATIONS "TRANSLATIONS"
  ((:VMS4 :VMS4.4) "TRANSLATIONS" "LDT")
  ((:VMS :FEP :MSDOS :OS//2) "LDT")
  (:UNIX "LD" "LOGDIR")
  (:UNIX42 "TRANSLATIONS" "LOGDIR" "LD")
  (:ITS "LOGDIR"))

(DEFINE-CANONICAL-TYPE :NULL-TYPE ""		;ILCP distribution needs this.
  ((:UNIX :UNIX42) :UNSPECIFIC "")
  (:LOGICAL "" "NULL-TYPE"))

(DEFINE-CANONICAL-TYPE :COLD-LOAD "LOAD"
  ((:VMS4 :VMS4.4) "LOAD" "LOD")
  ((:VMS :MSDOS :OS//2) "LOD"))

(DEFPROP :COLD-LOAD 8. :BINARY-FILE-BYTE-SIZE)

(DEFINE-CANONICAL-TYPE :I-COLD-LOAD "ILOD"
  ((:VMS4 :VMS4.4) "ILOD" "ILD")
  ((:VMS :MSDOS :OS//2) "ILD"))

(DEFPROP :I-COLD-LOAD 8. :BINARY-FILE-BYTE-SIZE)

(DEFINE-CANONICAL-TYPE :V-COLD-LOAD "VLOD"
  ((:VMS4 :VMS4.4) "VLOD" "VLD")
  ((:VMS :MSDOS :OS//2) "VLD"))

(DEFPROP :V-COLD-LOAD 8. :BINARY-FILE-BYTE-SIZE)

(DEFINE-CANONICAL-TYPE :FEP "FEP"
  )

(DEFPROP :FEP 8. :BINARY-FILE-BYTE-SIZE)

(DEFINE-CANONICAL-TYPE :FILES "FILES"
  ((:VMS4 :VMS4.4) "FILES" "FLS")
  ((:VMS :FEP :MSDOS :OS//2) "FLS")
  (:UNIX "FL")
  (:UNIX42 "FILES" "FL"))

(DEFINE-CANONICAL-TYPE :PXL "PXL"		;TEX PXL font files.
  ((:UNIX :UNIX42) "PXL" "PX"))

(DEFPROP :PXL 8. :BINARY-FILE-BYTE-SIZE)

(DEFINE-CANONICAL-TYPE :IMAGE "IMAGE"
  (:FEP "IMG")
  ((:VMS4 :VMS4.4) "IMAGE" "IMG")
  (:VMS "IMG")
  (:UNIX "IM" "IMAGE")
  (:UNIX42 "IMAGE" "IM"))

(DEFINE-CANONICAL-TYPE :DUMP "DUMP"
  ((:VMS4 :VMS4.4) "DUMP" "IDM")
  (:VMS "IDM")
  (:UNIX "DM" "DUMP")
  (:UNIX42 "DUMP" "DM"))

(DEFINE-CANONICAL-TYPE :IMAGE-ICON "ICON"
  ((:VMS4 :VMS4.4) "ICON" "ICN")
  (:VMS "ICN")
  (:UNIX "IC" "ICON")
  (:UNIX42 "ICON" "IC"))

(DEFPROP :IMAGE-ICON 16. :BINARY-FILE-BYTE-SIZE)

(DEFPROP :DUMP 16. :BINARY-FILE-BYTE-SIZE)

(DEFINE-CANONICAL-TYPE :MACINTOSH-RESOURCE "RSRC")

(DEFPROP :MACINTOSH-RESOURCE 8 :BINARY-FILE-BYTE-SIZE)

(DEFINE-CANONICAL-TYPE :SCT "SCT")

(DEFPROP :SCT T :UNIX-NEWEST-VERSION-SHOULD-BE-EXPLICIT)
(DEFPROP :|sct| T :UNIX-NEWEST-VERSION-SHOULD-BE-EXPLICIT)



(DEFMETHOD (:CANONICAL-TYPE PATHNAME) ()
  (DECLARE (VALUES CANONICAL-TYPE ORIGINAL-TYPE))
  (LET ((CTYPE (SEND SELF :TYPE)))
    (AND CTYPE				;special case null type for speed
	 (LOOKUP-CANONICAL-TYPE (SEND HOST :SYSTEM-TYPE) CTYPE))))

(DEFMETHOD (:NEW-CANONICAL-TYPE PATHNAME)
	   (CANONICAL-TYPE &OPTIONAL (ORIGINAL-TYPE NIL ORIGINAL-TYPE-P))
  (LET ((NEW-TYPE (SEND SELF ':TYPE-FOR-NEW-CANONICAL-TYPE
			CANONICAL-TYPE ORIGINAL-TYPE ORIGINAL-TYPE-P)))
    (SEND SELF ':NEW-PATHNAME ':RAW-TYPE NEW-TYPE)))

;;; This converts a canonical type symbol or string to the raw type to use.

(DEFMETHOD (:TYPE-FOR-NEW-CANONICAL-TYPE PATHNAME)
	   (CANONICAL-TYPE ORIGINAL-TYPE ORIGINAL-TYPE-P)
  (IF (AND (NULL ORIGINAL-TYPE-P) (EQ CANONICAL-TYPE (SEND SELF ':CANONICAL-TYPE)))
      (SEND SELF ':RAW-TYPE)
    (LOOP WHEN (OR (STRINGP CANONICAL-TYPE)
		   (EQ CANONICAL-TYPE ':UNSPECIFIC)	;These are not caught here
		   (EQ CANONICAL-TYPE ':WILD)		;for the sake of :NEW-DEFAULT-PATHNAME
		   (SEND SELF ':VALID-TYPE-P CANONICAL-TYPE))
	    RETURN (SEND SELF ':UNCASE-TYPE CANONICAL-TYPE)
	  WHEN (AND (SYMBOLP CANONICAL-TYPE)
		    (LET ((TYPES (SEND SELF ':TYPES-FOR-CANONICAL-TYPE CANONICAL-TYPE)))
		      (IF (AND ORIGINAL-TYPE
			       (MEM #'STRING= ORIGINAL-TYPE TYPES))
			  ORIGINAL-TYPE
			(SETQ ORIGINAL-TYPE (FIRST TYPES)))))	;Default type
	    RETURN (SEND SELF ':UNCASE-TYPE ORIGINAL-TYPE)
	DO (SIGNAL-PROCEED-CASE ((NEW-VALUE) 'INVALID-PATHNAME-COMPONENT
				 ':PATHNAME SELF
				 ':COMPONENT ':CANONICAL-TYPE
				 ':COMPONENT-VALUE CANONICAL-TYPE
				 ':COMPONENT-DESCRIPTION "canonical type")
	     (:NEW-COMPONENT (SETQ CANONICAL-TYPE NEW-VALUE))))))

(DEFMETHOD (:TYPES-FOR-CANONICAL-TYPE PATHNAME) (CANONICAL-TYPE)
  (IF (NOT (SYMBOLP CANONICAL-TYPE))
      (LIST CANONICAL-TYPE)
    (LOOP WITH OUR-SYSTEM-TYPE = (SEND HOST ':SYSTEM-TYPE)
	  WITH ENTRIES = (CDR (ASSQ OUR-SYSTEM-TYPE *CANONICAL-TYPES-ALIST*))
	  FOR (ENTRY-CANONICAL-TYPE . TYPES) IN ENTRIES
	  WHEN (EQ ENTRY-CANONICAL-TYPE CANONICAL-TYPE)
	    RETURN TYPES
	  FINALLY (RETURN (CDR (ASSQ CANONICAL-TYPE *DEFAULT-CANONICAL-TYPES*))))))

;;; Create a pathname, specifying components in external syntax form.
;;; Similar to sending a :NEW-PATHNAME message to an existing pathname,
;;; except that there is no pre-existing pathname, and only the host
;;; is defaulted, coming only from the (specified or default) defaults.

;;; N.B. Don't gratuituously rearrange these & keywords.  This is the only order that
;;; generates correct code in the A machine compiler.
(DEFUN MAKE-PATHNAME (&REST OPTIONS
		      &KEY (DEFAULTS *DEFAULT-PATHNAME-DEFAULTS*) HOST &ALLOW-OTHER-KEYS)
  (LET ((PATHNAME (IF HOST
		      (SEND (GET-PATHNAME-HOST HOST) ':SAMPLE-PATHNAME)
		    (DEFAULT-PATHNAME DEFAULTS NIL NIL NIL T))))
    (SETQ PATHNAME (SEND PATHNAME :NEW-DEFAULT-PATHNAME :DEVICE NIL :DIRECTORY NIL
			 :NAME NIL :TYPE NIL :VERSION NIL))
    (LEXPR-SEND PATHNAME ':NEW-PATHNAME OPTIONS)))


;;; Make sure that a :NEW-PATHNAME which specifies a new host
;;; is processed by the flavor of pathname for that host.
(DEFWHOPPER-SUBST (:NEW-PATHNAME PATHNAME) (&REST OPTIONS &KEY ((:HOST NEW-HOST))
						  &ALLOW-OTHER-KEYS)
  (LET ((NEW-PATHNAME-HOST NIL))
     (IF (AND NEW-HOST
	      (PROGN (SETQ NEW-PATHNAME-HOST (GET-PATHNAME-HOST NEW-HOST))
		     (NOT (NETI:NS-EQ HOST NEW-PATHNAME-HOST))))
	 (LET ((NEW-PATHNAME (SEND SELF :NEW-DEFAULT-PATHNAME :HOST NEW-HOST)))
	     (LEXPR-SEND NEW-PATHNAME ':NEW-PATHNAME OPTIONS))
	 (LEXPR-CONTINUE-WHOPPER OPTIONS))))


;;; This is the fundamental way of altering some of the components of a pathname.
;;; Specify an alternating list of components and values.
;;; Components allowed are :HOST, :DEVICE, :DIRECTORY, :NAME, :TYPE and :VERSION;
;;; All the :NEW-x operations call this one (by default),
;;; and all the :PARSE-x operations (except :PARSE-NAMESTRING)
;;; are called only by MAKE-PATHNAME-1, which is called only from here.

(DEFMETHOD (:NEW-PATHNAME PATHNAME) (&REST OPTIONS)
  (LEXPR-FUNCALL #'MAKE-PATHNAME-1
		 SELF
		 ':DEFAULT-HOST HOST
		 ':DEFAULT-DEVICE DEVICE
		 ':DEFAULT-DIRECTORY DIRECTORY
		 ':DEFAULT-NAME NAME
		 ':DEFAULT-TYPE TYPE
		 ':DEFAULT-VERSION VERSION
		 ':DEFAULT-VC-BRANCH VC-BRANCH
		 ':DEFAULT-VC-VERSION VC-VERSION
		 OPTIONS)) 

(EVAL-WHEN (EVAL GLOBAL:LOAD COMPILE)
(DEFPROP :DEVICE :PARSE-DEVICE-SPEC PARSE-XXX-SPEC)
(DEFPROP :DIRECTORY :PARSE-DIRECTORY-SPEC PARSE-XXX-SPEC)
(DEFPROP :NAME :PARSE-NAME-SPEC PARSE-XXX-SPEC)
(DEFPROP :TYPE :PARSE-NAME-SPEC PARSE-XXX-SPEC)

(DEFPROP :DEVICE :VALID-DEVICE VALIDATED-COMPONENT)
(DEFPROP :DIRECTORY :VALID-DIRECTORY VALIDATED-COMPONENT)
(DEFPROP :NAME :VALID-NAME VALIDATED-COMPONENT)
(DEFPROP :TYPE :VALID-TYPE VALIDATED-COMPONENT)
(DEFPROP :VERSION :VALID-VERSION VALIDATED-COMPONENT)

(DEFPROP :DEVICE :UNCASE-DEVICE REVERSE-CASE)
(DEFPROP :DIRECTORY :UNCASE-DIRECTORY REVERSE-CASE)
(DEFPROP :NAME :UNCASE-NAME REVERSE-CASE)
(DEFPROP :TYPE :UNCASE-TYPE REVERSE-CASE)

(DEFPROP :DEVICE :RAW-DEVICE RAW-CASE)
(DEFPROP :DIRECTORY :RAW-DIRECTORY RAW-CASE)
(DEFPROP :NAME :RAW-NAME RAW-CASE)
(DEFPROP :TYPE :RAW-TYPE RAW-CASE)

(DEFPROP :DEVICE :CASE-DEVICE INTERCHANGE-CASE)
(DEFPROP :DIRECTORY :CASE-DIRECTORY INTERCHANGE-CASE)
(DEFPROP :NAME :CASE-NAME INTERCHANGE-CASE)
(DEFPROP :TYPE :CASE-TYPE INTERCHANGE-CASE)

(DEFPROP :DEVICE :VALID-DEVICE-P VALIDATE-COMPONENT)
(DEFPROP :DIRECTORY :VALID-DIRECTORY-P VALIDATE-COMPONENT)
(DEFPROP :NAME :VALID-NAME-P VALIDATE-COMPONENT)
(DEFPROP :TYPE :VALID-TYPE-P VALIDATE-COMPONENT)
(DEFPROP :VERSION :VALID-VERSION-P VALIDATE-COMPONENT)
)

(DEFMACRO UNCASE-PATHNAME-COMPONENT (PLIST INDICATOR)
  `(LET ((COMPONENT (GET ,PLIST ',(GET INDICATOR 'RAW-CASE))))
     (OR COMPONENT
	 (AND (SETQ COMPONENT (GET PLIST ',INDICATOR))
	      (SEND SELF ',(GET INDICATOR 'REVERSE-CASE) COMPONENT)))))

(DEFMACRO UNCASE-PATHNAME-COMPONENT-VALIDATED (PLIST INDICATOR)
  `(SEND SELF ',(GET INDICATOR 'VALIDATED-COMPONENT)
	      (UNCASE-PATHNAME-COMPONENT ,PLIST ,INDICATOR)))


(DEFUN MAKE-PATHNAME-1 (ACTOR &REST OPTIONS
			&AUX RAW-DEVICE RAW-DIRECTORY RAW-NAME RAW-TYPE
			NEW-DEVICE NEW-DIRECTORY NEW-NAME NEW-TYPE NEW-VERSION
			OTHER-COMPONENTS
			DEFAULT-DEVICE DEFAULT-DIRECTORY DEFAULT-NAME DEFAULT-TYPE
			DEFAULT-VERSION DEFAULTS NEW-HOST
			NEW-DEVICE-P NEW-DIRECTORY-P NEW-NAME-P NEW-TYPE-P NEW-VERSION-P
			OTHER-COMPONENTS-P
			CANONICAL-TYPE CANONICAL-TYPE-P ORIGINAL-TYPE ORIGINAL-TYPE-P
			DEFAULT-VC-BRANCH NEW-VC-BRANCH NEW-VC-BRANCH-P
			DEFAULT-VC-VERSION NEW-VC-VERSION NEW-VC-VERSION-P
			)
  (SETQ DEFAULTS (OR (GET (LOCF OPTIONS) ':DEFAULTS) *DEFAULT-PATHNAME-DEFAULTS*)
	NEW-HOST (OR (GET (LOCF OPTIONS) ':HOST)
		     (GET (LOCF OPTIONS) ':DEFAULT-HOST)
		     (PATHNAME-HOST (DEFAULT-PATHNAME DEFAULTS NIL NIL NIL T))))
  (SETQ NEW-HOST (GET-PATHNAME-HOST NEW-HOST))
  (UNLESS (EQ (SEND ACTOR :HOST) NEW-HOST)
    (SETQ ACTOR (SEND NEW-HOST ':SAMPLE-PATHNAME)))
  (LOOP FOR (KEY VAL) ON OPTIONS BY 'CDDR
	DO (SELECTQ KEY
	     (:DEFAULT-HOST)
	     (:DEFAULT-DEVICE (UNLESS DEFAULT-DEVICE (SETQ DEFAULT-DEVICE VAL)))
	     (:DEFAULT-DIRECTORY (UNLESS DEFAULT-DIRECTORY (SETQ DEFAULT-DIRECTORY VAL)))
	     (:DEFAULT-NAME (UNLESS DEFAULT-NAME (SETQ DEFAULT-NAME VAL)))
	     (:DEFAULT-TYPE (UNLESS DEFAULT-TYPE (SETQ DEFAULT-TYPE VAL)))
	     (:DEFAULT-VERSION (LET ((VERS (IF (AND (TYPEP ACTOR 'LOGICAL-PATHNAME)
						    (EQ VAL :UNSPECIFIC))
					       :NEWEST VAL)))
				 ;; If we are trying to make a logical pathname with
				 ;; a version of :UNSPECIFIC (e.g., if it points to
				 ;; a Unix host), just make it be :NEWEST
				 ;; +++ This is a kludge, and must not remain as a permanent
				 ;; +++ feature beyond Release 7.0.  The right thing is for
				 ;; +++ Unix pathnames to use 1:newest0 instead of 1:unspecific
0				 ;; +++ for the version.  --RWK
				 (UNLESS DEFAULT-VERSION (SETQ DEFAULT-VERSION VERS))))
	     (:DEFAULT-VC-BRANCH (UNLESS DEFAULT-VC-BRANCH (SETQ DEFAULT-VC-BRANCH VAL)))
	     (:DEFAULT-VC-VERSION (UNLESS DEFAULT-VC-VERSION (SETQ DEFAULT-VC-VERSION VAL)))
	     (:RAW-DEVICE
	      (UNLESS NEW-DEVICE-P
		(SETQ RAW-DEVICE VAL)
		(SETQ NEW-DEVICE-P T)))
	     (:DEVICE
	      (UNLESS NEW-DEVICE-P
		(SETQ NEW-DEVICE VAL)
		(SETQ NEW-DEVICE-P T)))
	     (:RAW-DIRECTORY
	      (UNLESS NEW-DIRECTORY-P
		(SETQ RAW-DIRECTORY VAL)
		(SETQ NEW-DIRECTORY-P T)))
	     (:DIRECTORY
	      (UNLESS NEW-DIRECTORY-P
		(SETQ NEW-DIRECTORY VAL)
		(SETQ NEW-DIRECTORY-P T)))
	     (:RAW-NAME 
	      (UNLESS NEW-NAME-P
		(SETQ RAW-NAME VAL)
		(SETQ NEW-NAME-P T)))
	     (:NAME
	      (UNLESS NEW-NAME-P
		(SETQ NEW-NAME VAL)
		(SETQ NEW-NAME-P T)))
	     (:RAW-TYPE 
	      (UNLESS NEW-TYPE-P
		(SETQ RAW-TYPE VAL)
		(SETQ NEW-TYPE-P T)))
	     (:TYPE
	      (IF (AND VAL (SYMBOLP VAL))
		  (UNLESS CANONICAL-TYPE-P
		    (SETQ CANONICAL-TYPE VAL)
		    (SETQ CANONICAL-TYPE-P ':TYPE))
		(UNLESS NEW-TYPE-P
		  (SETQ NEW-TYPE VAL)
		  (SETQ NEW-TYPE-P T))))
	     (:VERSION
	      (UNLESS NEW-VERSION-P
		(LET ((VERS (IF (AND (TYPEP ACTOR 'LOGICAL-PATHNAME)
				     (EQ VAL :UNSPECIFIC))
				:NEWEST VAL)))
		  ;; See the comment above...
		  (SETQ NEW-VERSION VERS)
		  (SETQ NEW-VERSION-P T))))
	     (:VC-BRANCH
	      (UNLESS NEW-VC-BRANCH-P
		(SETQ NEW-VC-BRANCH-P T NEW-VC-BRANCH VAL)))
	     (:VC-VERSION
	      (UNLESS NEW-VC-VERSION-P
		(SETQ NEW-VC-VERSION-P T NEW-VC-VERSION VAL)))
	     (:OTHER-COMPONENTS
	      (UNLESS OTHER-COMPONENTS-P
		(SETQ OTHER-COMPONENTS VAL)
		(SETQ OTHER-COMPONENTS-P VAL)))
	     (:DEFAULTS)
	     (:HOST)
	     (:CANONICAL-TYPE
	      (UNLESS (EQ CANONICAL-TYPE-P T)
		(SETQ CANONICAL-TYPE VAL)
		(SETQ CANONICAL-TYPE-P T)))
	     (:ORIGINAL-TYPE
	      (UNLESS ORIGINAL-TYPE-P
		(SETQ ORIGINAL-TYPE VAL)
		(SETQ ORIGINAL-TYPE-P T)))
	     (OTHERWISE (FERROR "~S is not a recognized option" KEY))))
  ;; The new fields are parsed only once to save time, consing, and possible errors
  ;; due to incompatible fields in different types of pathnames.
  (MACROLET ((MAKE-UNCASED-COMPONENT
	       (RAW-COMPONENT ACTOR KEY COMPONENT DEFAULT NEW-P)
	       `(PROGN (UNLESS ,RAW-COMPONENT
			 (WHEN ,COMPONENT
			   (SETQ ,RAW-COMPONENT
				 (SEND ,ACTOR ',(GET KEY 'REVERSE-CASE) ,COMPONENT))))
		       ;; This is the wrong thing.
		       ;; There has to be a new idea of NAME-FOR-HOST, etc.
		       (COMMENT
			 (WHEN ,RAW-COMPONENT
			   (SETQ ,RAW-COMPONENT
				 (SEND ,ACTOR ',(GET KEY 'PARSE-XXX-SPEC) ,RAW-COMPONENT))))
		       (UNLESS ,NEW-P
			 (SETQ ,RAW-COMPONENT ,DEFAULT)))))
    (MAKE-UNCASED-COMPONENT RAW-DEVICE ACTOR :DEVICE NEW-DEVICE
			    DEFAULT-DEVICE NEW-DEVICE-P)
    (MAKE-UNCASED-COMPONENT RAW-DIRECTORY ACTOR :DIRECTORY NEW-DIRECTORY
			    DEFAULT-DIRECTORY NEW-DIRECTORY-P)
    (MAKE-UNCASED-COMPONENT RAW-NAME ACTOR :NAME NEW-NAME
			    DEFAULT-NAME NEW-NAME-P)
    (MAKE-UNCASED-COMPONENT RAW-TYPE ACTOR :TYPE NEW-TYPE
			    DEFAULT-TYPE NEW-TYPE-P))
  (UNLESS NEW-VERSION-P (SETQ NEW-VERSION DEFAULT-VERSION))
  (UNLESS NEW-VC-BRANCH-P (SETQ NEW-VC-BRANCH DEFAULT-VC-BRANCH))
  (UNLESS NEW-VC-VERSION-P (SETQ NEW-VC-VERSION DEFAULT-VC-VERSION))
  (IF (AND CANONICAL-TYPE-P
	   (NOT NEW-TYPE-P))
      (SETQ RAW-TYPE
	    (SEND ACTOR ':TYPE-FOR-NEW-CANONICAL-TYPE
		  CANONICAL-TYPE ORIGINAL-TYPE ORIGINAL-TYPE-P)))
  (NETI:PATHNAME-HOST-GET-PATHNAME
    NEW-HOST
    RAW-DEVICE
    RAW-DIRECTORY
    RAW-NAME
    RAW-TYPE
    NEW-VERSION
    OTHER-COMPONENTS
    NEW-VC-BRANCH
    NEW-VC-VERSION
    )) 

;;; Default is to leave the string alone
(DEFMETHOD (:PARSE-COMPONENT-SPEC PATHNAME) (SPEC)
  SPEC)

(DEFMETHOD (:PARSE-DEVICE-SPEC PATHNAME) (SPEC)
  (SEND SELF :PARSE-COMPONENT-SPEC SPEC))

(DEFMETHOD (:PARSE-DIRECTORY-SPEC PATHNAME) (SPEC)
  (COND ((EQ SPEC ':ROOT) ':ROOT)
	((NULL SPEC) NIL)
	((LISTP SPEC)
	 (LOOP FOR S IN SPEC
	       COLLECT (SEND SELF :PARSE-COMPONENT-SPEC S)))
	(T (LIST (SEND SELF :PARSE-COMPONENT-SPEC SPEC)))))

(DEFMETHOD (:PARSE-NAME-SPEC PATHNAME) (SPEC)
  (SEND SELF ':PARSE-COMPONENT-SPEC
	(IF (LISTP SPEC) (CAR SPEC) SPEC)))

(DEFMETHOD (:TRANSLATABLE-P PATHNAME) () T)

(DEFMETHOD (:TRANSLATED-PATHNAME PATHNAME) () SELF)

(DEFMETHOD (:BACK-TRANSLATED-PATHNAME PATHNAME) (PATHNAME) PATHNAME)

;;; This is used to parse a string which may not have the host in it
;;; If you use this for anything other than parsing a string produced by
;;; a filesystem (i.e. a filename you *KNOW* must be legal because a filesystem
;;; gave it to you, directly or not), supply the second argument NIL.
(DEFMETHOD (:PARSE-TRUENAME PATHNAME) (STRING &OPTIONAL (FROM-FILESYSTEM T))
  (LET ((*INHIBIT-VALIDITY-CHECKING* FROM-FILESYSTEM))
    (MERGE-PATHNAMES (PARSE-PATHNAME STRING HOST) SELF)))

(DEFUN PATHNAME-LESSP (PATHNAME-1 PATHNAME-2)
  (SEND PATHNAME-1 ':SORT-LESSP PATHNAME-2))

(DEFSUBST PATHNAME-COMPONENT-COMPARE (X Y)
  (COND ((EQ X Y) 0)
	((EQUAL X Y) 0)
	((SYMBOLP X)
	 (IF (SYMBOLP Y)
	     (PATHNAME-KEYWORD-COMPARE X Y)
	     -1))
	((SYMBOLP Y) 1)
	((STRINGP X)
	 (IF (STRINGP Y)
	     (%STRING-COMPARE X 0 Y 0 NIL)
	     -1))
	((STRINGP Y) 1)
	((NUMBERP X)
	 (IF (NUMBERP Y)
	     (- X Y)
	     -1))
	((NUMBERP Y) 1)
	(T (IF (ALPHALESSP X Y)
	       -1
	       1))))

(DEFMETHOD (:SORT-LESSP PATHNAME) (OTHER-PATHNAME &AUX TEM)
  (MULTIPLE-VALUE-BIND
       (OTHER-HOST OTHER-DEVICE OTHER-DIRECTORY OTHER-NAME OTHER-TYPE OTHER-VERSION
	OTHER-VC-BRANCH OTHER-VC-VERSION)
      (SEND OTHER-PATHNAME :ALL-COMPONENTS)
    (AND (ZEROP (SETQ TEM (PATHNAME-COMPONENT-COMPARE HOST OTHER-HOST)))
       (ZEROP (SETQ TEM (PATHNAME-COMPONENT-COMPARE DEVICE OTHER-DEVICE)))
       (ZEROP (SETQ TEM (PATHNAME-COMPONENT-COMPARE DIRECTORY OTHER-DIRECTORY)))
       (ZEROP (SETQ TEM (PATHNAME-COMPONENT-COMPARE NAME OTHER-NAME)))
       (ZEROP (SETQ TEM (PATHNAME-COMPONENT-COMPARE TYPE OTHER-TYPE)))
       (ZEROP (SETQ TEM (PATHNAME-COMPONENT-COMPARE VC-BRANCH OTHER-VC-BRANCH)))
       (ZEROP (SETQ TEM (PATHNAME-COMPONENT-COMPARE VC-VERSION OTHER-VC-VERSION)))
       (SETQ TEM (PATHNAME-COMPONENT-COMPARE VERSION OTHER-VERSION)))
    (MINUSP TEM)))




;;; Get all the pathname components at once, to make the sort predicate faster.
(DEFMETHOD (:ALL-COMPONENTS PATHNAME) () (VALUES HOST DEVICE DIRECTORY NAME TYPE VERSION
						 VC-BRANCH VC-VERSION))

(DEFUN PATHNAME-KEYWORD-COMPARE (X Y)
  (COND ((EQ X ':NEWEST)
	 (COND ((EQ Y ':NEWEST) 0)
	       (T 1)))
	((EQ Y ':NEWEST)
	 (COND ((EQ X ':NEWEST) 0)
	       (T -1)))
	(T (STRING-COMPARE X Y))))

(DEFMETHOD (:FASD-FORM PATHNAME) ()
  `(MAKE-FASLOAD-PATHNAME ',(SEND HOST ':NAME-AS-FILE-COMPUTER)
			  ',(SEND SELF ':DEVICE) ',(SEND SELF ':DIRECTORY)
			  ',(SEND SELF ':NAME) ',(SEND SELF ':TYPE)
			  ',(SEND SELF ':VERSION)
			  NIL
			  ,@(WHEN (VC-P)
			      `(
				',(SEND SELF :VC-BRANCH)
				',(SEND SELF :VC-VERSION)
				)))) 

;;; The cold-load generator has special knowledge of this function.
;;; Don't change it without checking there.
(DEFUN MAKE-FASLOAD-PATHNAME (HOST DEVICE DIRECTORY NAME TYPE VERSION
			      &OPTIONAL COMPILER-VERSION
			      VC-BRANCH VC-VERSION)
  (WHEN (AND (STRINGP NAME)			;Old-style GENERIC?
	     (EQ TYPE ':UNSPECIFIC)
	     (EQ VERSION ':UNSPECIFIC))
    (SETQ TYPE NIL VERSION NIL))		;Substitute new
  (LET ((PATH-HOST (GET-PATHNAME-HOST HOST T)))
    (IF PATH-HOST
	;; If we found the host, then we hope that this is a local pathname and treat it
	;; accordingly.  We could be stricter and insist that it be logical, but this might
	;; break some user applications which don't bother with logical pathnames.
	;; Nothing in the system should ever dump physical pathnames into a BIN file.
	(LET ((PATH (SEND (SEND PATH-HOST :SAMPLE-PATHNAME) :NEW-DEFAULT-PATHNAME
			  :DEVICE DEVICE :DIRECTORY DIRECTORY
			  :NAME NAME :TYPE TYPE :VERSION VERSION
			  :VC-BRANCH VC-BRANCH
			  :VC-VERSION VC-VERSION
			  )))
	  ;; Compiler-version identifies the world that compiled this file, in a way
	  ;; different from its system major version number.  Normally this argument is not
	  ;; supplied in the call to MAKE-FASLOAD-PATHNAME that is dumped out in a BIN file,
	  ;; but when a specially-patched compilation environment is constructed, it can be
	  ;; patched to put a keyword here for later identification.
	  (WHEN COMPILER-VERSION
	    (SEND PATH :PUTPROP COMPILER-VERSION :FASLOAD-COMPILER-VERSION))
	  PATH)
	;; We didn't recognize the host.  There's not much we can do except to hope that
	;; the human user can figure this one out.
	(FORMAT NIL "LOADed physical pathname ~A: ~A; ~A.~A.~A~A.~A"
		HOST DIRECTORY NAME TYPE VERSION VC-BRANCH VC-VERSION)))) 

;; Generate a default filename.  Most just merge in the name, etc.
(DEFMETHOD (:NEW-DEFAULT-PATHNAME PATHNAME) (&REST OPTIONS)
  (LET* ((PLIST (LOCF OPTIONS))
	 (DEVNAME (UNCASE-PATHNAME-COMPONENT-VALIDATED PLIST :DEVICE))
	 (DIRNAME (UNCASE-PATHNAME-COMPONENT-VALIDATED PLIST :DIRECTORY))
	 (FILENAME (UNCASE-PATHNAME-COMPONENT-VALIDATED PLIST :NAME))
	 (FILETYPE (UNCASE-PATHNAME-COMPONENT-VALIDATED PLIST :TYPE))
	 (FILEVERSION (SEND SELF ':VALID-VERSION (GET PLIST ':VERSION)))
	 (VC-BRANCH (SEND SELF :VALID-VC-BRANCH (CL:GETF OPTIONS ':VC-BRANCH)))
	 (VC-VERSION (SEND SELF :VALID-VC-VERSION (CL:GETF OPTIONS ':VC-VERSION)))
	 (CANONICAL-TYPE (GETL PLIST '(:CANONICAL-TYPE)))
	 (NARGS (1+ (LENGTH OPTIONS))))
    ;; If we got canonical type instead, carefully convert it to a raw type
    ;; acceptable to this pathname.  This should only have to substitute
    ;; in the case of :UNSPECIFIC, but we have to do the casing anyway.
    (WHEN (OR (AND (NOT (GETL PLIST '(:TYPE :RAW-TYPE)))
		   CANONICAL-TYPE)
	      (AND (SETQ CANONICAL-TYPE (GETL PLIST '(:TYPE)))
		   (SYMBOLP (SECOND CANONICAL-TYPE))))
      (SETQ FILETYPE (SEND SELF ':TYPE-FOR-NEW-CANONICAL-TYPE
			   (OR (GET PLIST ':CANONICAL-TYPE)
			       (GET PLIST ':TYPE))
			   (GET PLIST ':ORIGINAL-TYPE)
			   (GETL PLIST '(:ORIGINAL-TYPE))))
      (SETQ FILETYPE (SEND SELF ':VALID-TYPE FILETYPE)))
    (MULTIPLE-VALUE-BIND (DEVNAME DIRNAME FILENAME FILETYPE FILEVERSION)
	(SEND SELF :VALID-COMPONENTS-ALL DEVNAME DIRNAME FILENAME FILETYPE FILEVERSION)
      (LET ((DEVPROP (GETL PLIST '(:DEVICE :RAW-DEVICE)))
	    (DIRPROP (GETL PLIST '(:DIRECTORY :RAW-DIRECTORY)))
	    (NAMPROP (GETL PLIST '(:NAME :RAW-NAME)))
	    (TYPPROP (GETL PLIST '(:TYPE :RAW-TYPE :CANONICAL-TYPE)))
	    (VRSPROP (GETL PLIST '(:VERSION)))
	    (VC-BRANCH-PROP (NEQ 'APPLESAUCE (CL:GETF OPTIONS ':VC-BRANCH 'APPLESAUCE)))
	    (VC-VERSION-PROP (NEQ 'APPLESAUCE (CL:GETF OPTIONS ':VC-VERSION 'APPLESAUCE))))
	(WHEN DEVPROP (INCF NARGS 2))
	(WHEN DIRPROP (INCF NARGS 2))
	(WHEN NAMPROP (INCF NARGS 2))
	(WHEN TYPPROP (INCF NARGS 2))
	(WHEN VRSPROP (INCF NARGS 2))
	(WHEN VC-BRANCH-PROP (INCF NARGS 2))
	(WHEN VC-VERSION-PROP (INCF NARGS 2))
	(%START-FUNCTION-CALL SELF RETURN NARGS NIL)
	(%PUSH ':NEW-PATHNAME)
	(WHEN DEVPROP
	  (%PUSH ':RAW-DEVICE) (%PUSH DEVNAME))
	(WHEN DIRPROP
	  (%PUSH ':RAW-DIRECTORY) (%PUSH DIRNAME))
	(WHEN NAMPROP
	  (%PUSH ':RAW-NAME) (%PUSH FILENAME))
	(WHEN TYPPROP
	  (%PUSH ':RAW-TYPE) (%PUSH FILETYPE))
	(WHEN VRSPROP
	  (%PUSH ':VERSION) (%PUSH FILEVERSION))
	(WHEN VC-BRANCH-PROP
	  (%PUSH ':VC-BRANCH) (%PUSH VC-BRANCH))
	(WHEN VC-VERSION-PROP
	  (%PUSH ':VC-VERSION) (%PUSH VC-VERSION))
	(DO () ((NULL OPTIONS))
	  (%PUSH (POP OPTIONS)))
	(%FINISH-FUNCTION-CALL SELF RETURN NARGS NIL))))) 


;;; Make sure that a :NEW-DEFAULT-PATHNAME which specifies a new host
;;; is processed by the flavor of pathname for that host.
;;; 
;;; This preserves case when both hosts are the same type.
;;; it dosen't preserve case when they are different types
;;; but agree on case handling.  That could be added.
;;;
(DEFWHOPPER-SUBST (:NEW-DEFAULT-PATHNAME PATHNAME) (&REST OPTIONS &KEY ((:HOST NEW-HOST))
							  &ALLOW-OTHER-KEYS)
  (LET ((NEW-PATHNAME-HOST NIL))
    (IF (AND NEW-HOST
	     (PROGN (SETQ NEW-PATHNAME-HOST (GET-PATHNAME-HOST NEW-HOST))
		    (NOT (NETI:NS-EQ HOST NEW-PATHNAME-HOST))))
	(MULTIPLE-VALUE-BIND (CANONICAL-TYPE ORIGINAL-TYPE)
	    (SEND SELF :CANONICAL-TYPE)
	  (LET* ((SAMPLE (SEND NEW-PATHNAME-HOST :SAMPLE-PATHNAME))
		 (SAME-SYSTEM-TYPE-P
		   (EQL (SEND NEW-PATHNAME-HOST :SYSTEM-TYPE)
			(SEND HOST :SYSTEM-TYPE)))
		 (NEW-PATHNAME (SEND SAMPLE :NEW-DEFAULT-PATHNAME
				     :DEVICE (SEND SELF :DEVICE)
				     (IF SAME-SYSTEM-TYPE-P :RAW-DIRECTORY :DIRECTORY)
				     (IF SAME-SYSTEM-TYPE-P (SEND SELF :RAW-DIRECTORY)
					 (SEND SELF :DIRECTORY))
				     (IF SAME-SYSTEM-TYPE-P :RAW-NAME :NAME)
				     (IF SAME-SYSTEM-TYPE-P (SEND SELF :RAW-NAME)
					 (SEND SELF :NAME))
				     (IF SAME-SYSTEM-TYPE-P :RAW-TYPE :TYPE)
				     (IF SAME-SYSTEM-TYPE-P (SEND SELF :RAW-TYPE)
					 CANONICAL-TYPE)
				     :ORIGINAL-TYPE ORIGINAL-TYPE
				     :VERSION VERSION
				     :VC-BRANCH VC-BRANCH
				     :VC-VERSION VC-VERSION
				     )))
	    (LEXPR-SEND NEW-PATHNAME ':NEW-DEFAULT-PATHNAME OPTIONS)))
	(LEXPR-CONTINUE-WHOPPER OPTIONS)))) 

;;; These take, and return, RAW components.

(DEFMETHOD (:VALID-COMPONENTS-ALL PATHNAME) (DEVNAME DIRNAME NAM TYP VRS)
  (DECLARE (VALUES DEVICE DIRECTORY NAME TYPE VERSION))
  (VALUES DEVNAME DIRNAME NAM TYP VRS))

(DEFMETHOD (:VALID-DEVICE PATHNAME) (DEVNAME)
  (IF (SEND SELF ':VALID-DEVICE-P DEVNAME)
      DEVNAME
    (SEND (QUIET-USER-HOMEDIR HOST) :RAW-DEVICE)))

(DEFMETHOD (:VALID-DEVICE-P PATHNAME) (DEVNAME)
  (MEMQ DEVNAME '(NIL :UNSPECIFIC)))

(DEFMETHOD (:VALID-DIRECTORY PATHNAME) (DIRNAME)
  (IF (SEND SELF ':VALID-DIRECTORY-P DIRNAME)
      DIRNAME
    (IF (OR (NLISTP DIRNAME)
	    ( (LENGTH DIRNAME) 1))
	(SEND SELF :DEFAULT-DIRECTORY)
      (SEND SELF ':VALID-DIRECTORY (LAST DIRNAME)))))

(DEFMETHOD (:VALID-DIRECTORY-P PATHNAME) (DIRNAME)
  (TYPECASE DIRNAME
    (:LIST (AND (NULL (CDR DIRNAME))
		(OR (EQ (FIRST DIRNAME) :WILD)
		    (AND (STRINGP (FIRST DIRNAME))
			 (> (STRING-LENGTH (FIRST DIRNAME)) 0)))))
    (:NULL T)))

(DEFVAR *DEFAULT-DIRECTORY-RECURSION-FLAG* NIL)

;;; Any pathname where this isn't a legal directory name must
;;; supply its own method.  Fortunately, we don't support RSX yet, but
;;; let's not make it impossible.
(DEFMETHOD (:DEFAULT-DEFAULT-DIRECTORY PATHNAME) ()
  '("FOO"))

(DEFMETHOD (:DEFAULT-DIRECTORY PATHNAME) ()
  (IF *DEFAULT-DIRECTORY-RECURSION-FLAG*
      (SEND SELF :DEFAULT-DEFAULT-DIRECTORY)
    (LET ((*DEFAULT-DIRECTORY-RECURSION-FLAG* T))
      (SEND (QUIET-USER-HOMEDIR HOST) ':DIRECTORY))))


(DEFMETHOD (:VALID-NAME PATHNAME) (NAM)
  (IF (SEND SELF ':VALID-NAME-P NAM)
      NAM
    (SEND SELF :UNCASE-NAME "FOO")))

(DEFMETHOD (:VALID-NAME-P PATHNAME) (NAM)
  (OR (AND (STRINGP NAM)
	   (> (STRING-LENGTH NAM) 0))
      (MEMQ NAM '(NIL :WILD))))

(DEFMETHOD (:VALID-TYPE PATHNAME) (TYP)
  (IF (SEND SELF ':VALID-TYPE-P TYP)
      TYP
    (IF (EQ TYP ':UNSPECIFIC)
	(IF (SEND SELF ':VALID-TYPE-P "") ""
	  (SEND (SEND SELF ':NEW-CANONICAL-TYPE ':LISP) ':RAW-TYPE))
      (SEND (SEND SELF ':NEW-CANONICAL-TYPE ':LISP) ':RAW-TYPE))))

(DEFMETHOD (:VALID-TYPE-P PATHNAME) (TYP)
  (OR (STRINGP TYP) (MEMQ TYP '(NIL :WILD))))

(DEFMETHOD (:VALID-VERSION-P PATHNAME) (VRS)
  (OR (AND (FIXNUMP VRS) (> VRS 0))
      (MEMQ VRS '(NIL :WILD :NEWEST :OLDEST))))

(DEFMETHOD (:VALID-VERSION PATHNAME) (VRS)
  (IF (SEND SELF ':VALID-VERSION-P VRS) VRS ':NEWEST))

(DEFMETHOD (:VALID-VC-BRANCH PATHNAME) (BR)
  (IF (SEND SELF :VALID-VC-BRANCH-P BR) BR NIL))

;;--- See comment on VC-STRING-FOR-PRINTING about how :UNSPECIFIC is treated
(DEFMETHOD (:VALID-VC-BRANCH-P PATHNAME) (BR)
  (OR (NULL BR)
      (EQ BR ':WILD)
      (EQ BR ':UNSPECIFIC)
      (AND (STRINGP BR)
	   (NOT (WITH-STACK-LIST (DELIMS *VC-PATHNAME-DELIMITER*
					 (CL:CHAR *VERSION-DELIMITER* 0))
		  (STRING-SEARCH-SET DELIMS BR))))))

(DEFMETHOD (:VALID-VC-VERSION PATHNAME) (VR)
  (IF (SEND SELF :VALID-VC-VERSION-P VR) VR NIL))

;;--- See comment on VC-STRING-FOR-PRINTING about how :UNSPECIFIC is treated
(DEFMETHOD (:VALID-VC-VERSION-P PATHNAME) (VR)
  (OR (NULL VR)
      (AND (NUMBERP VR) (NOT (MINUSP VR)))
      (EQ VR ':PARENT)
      (EQ VR ':WILD)
      (EQ VR ':NEWEST)
      (EQ VR ':OLDEST)
      (EQ VR ':UNSPECIFIC)))


(DEFUN STRING-THIN-PATHNAME-COMPONENT (OBJECT)
  (IF *INHIBIT-VALIDITY-CHECKING*
      OBJECT
    (TYPECASE OBJECT
      (:STRING
	;; Don't remove bits, but do complain about them, since they
	;; should never get here in the first place
	(STRING-THIN OBJECT :ERROR-IF :BITS))
      (:LIST
	(LET* ((OLD-CAR (CAR OBJECT))
	       (OLD-CDR (CDR OBJECT))
	       (NEW-CAR (STRING-THIN-PATHNAME-COMPONENT OLD-CAR))
	       (NEW-CDR (STRING-THIN-PATHNAME-COMPONENT OLD-CDR)))
	  (IF (AND (EQL OLD-CAR NEW-CAR) (EQL OLD-CDR NEW-CDR))
	      OBJECT
	    (CONS NEW-CAR NEW-CDR))))
      (OTHERWISE OBJECT))))

;;; Efficiency hack.  Avoid consing more keys than we need, by using the one
;;; already created to intern this pathname when it was created.  For setting
;;; up other hash-tables.

(DEFMETHOD (:FIND-HASH-KEY PATHNAME) ()
  ;; Because we can't get the key without consing it in the pathname area
  ;; (clearly bogus, but not worth fixing right now), just always cons it.
  ;; Our only caller only does this once, so we can get away with this.
  ;; The right thing is to define a with-pathname-hash-key-internal method
  ;; that conses it on the stack.
  (SEND SELF :HASH-KEY))

;; Returns a valid component, copied into PATHNAME-AREA.  TEST-ARG is a component,
;; in raw (uncased) form.
(DEFMETHOD (:VALIDATE-COMPONENT PATHNAME)
	   (TEST-ARG TEST-ARG-LOC VALID-MSG TEST-MSG CASE-MSG UNCASE-MSG COMPONENT
		     PRETTY-NAME)
  ;; Fix it before we try to print any error messages....
  (LOOP AS (OK FAILURE-TEXT) = (MULTIPLE-VALUE-LIST (SEND SELF TEST-MSG TEST-ARG))
	UNTIL OK
     DO (RPLACA TEST-ARG-LOC (SEND (SEND HOST ':SAMPLE-PATHNAME) VALID-MSG))
	(SEND SELF ':VALIDATE)			;Be sure to be entirely legal before we print
	(SETQ STRING-FOR-PRINTING NIL)
	(SETQ VC-STRING-FOR-PRINTING NIL)
	(SIGNAL-PROCEED-CASE ((NEW-VALUE) 'INVALID-PATHNAME-COMPONENT
			      ':PATHNAME SELF
			      ':COMPONENT COMPONENT
			      ':COMPONENT-VALUE TEST-ARG
			      ':COMPONENT-DESCRIPTION PRETTY-NAME
			      ':ADDITIONAL-TEXT FAILURE-TEXT)
	  (:NEW-COMPONENT ;; Fix up the case by canonicalizing and converting back.
	   (SETQ STRING-FOR-PRINTING NIL)
	   (SETQ VC-STRING-FOR-PRINTING NIL)
	   (SEND SELF ':DECACHE-CACHED-STRINGS) 
	   (IF (NULL CASE-MSG)
	       (SETQ TEST-ARG NEW-VALUE)
	     (SETQ TEST-ARG (SEND SELF UNCASE-MSG (SEND SELF CASE-MSG NEW-VALUE))))))
     FINALLY (RETURN (COPY-INTO-PATHNAME-AREA TEST-ARG))))

(DEFVAR-STANDARD *INHIBIT-VALIDITY-CHECKING* NIL NIL NIL NIL
		 "Don't check validity of pathnames, assume what the parser gave us is real.
Bind this to T when the pathname comes from the filesystem.")

(DEFMETHOD (:VALIDATE PATHNAME) ()
  (UNLESS *INHIBIT-VALIDITY-CHECKING*
    ;; The order of these checks is deliberate: it causes components to be asked about
    ;; in left-to-right order.  See :VALIDATE-COMPONENT.
    (SETQ VC-VERSION (SEND SELF :VALIDATE-COMPONENT VC-VERSION (LOCF VC-VERSION)
			   ':VC-VERSION ':VALID-VC-VERSION-P NIL NIL ':VC-VERSION
			   "VC branch version component"))
    (SETQ VC-BRANCH (SEND SELF :VALIDATE-COMPONENT VC-BRANCH (LOCF VC-BRANCH)
			  ':VC-BRANCH ':VALID-VC-BRANCH-P NIL NIL ':VC-BRANCH
			  "VC branch name component"))
    (SETQ VERSION (SEND SELF ':VALIDATE-COMPONENT VERSION (LOCF VERSION) ':VERSION
			':VALID-VERSION-P NIL NIL ':VERSION "version component"))
    (SETQ TYPE (SEND SELF ':VALIDATE-COMPONENT TYPE (LOCF TYPE) ':RAW-TYPE
		     ':VALID-TYPE-P ':CASE-TYPE ':UNCASE-TYPE ':TYPE "type component"))
    (SETQ NAME (SEND SELF ':VALIDATE-COMPONENT NAME (LOCF NAME) ':RAW-NAME
		     ':VALID-NAME-P ':CASE-NAME ':UNCASE-NAME ':NAME "name component"))
    (SETQ DIRECTORY (SEND SELF ':VALIDATE-COMPONENT DIRECTORY (LOCF DIRECTORY) ':RAW-DIRECTORY
			  ':VALID-DIRECTORY-P ':CASE-DIRECTORY ':UNCASE-DIRECTORY
			  ':DIRECTORY "directory component"))
    (SETQ DEVICE (SEND SELF ':VALIDATE-COMPONENT DEVICE (LOCF DEVICE) ':RAW-DEVICE
		       ':VALID-DEVICE-P ':CASE-DEVICE ':UNCASE-DEVICE
		       ':DEVICE "device component")))) 

(DEFUN COPY-INTO-PATHNAME-AREA (OBJ)
  (SI:COPY-INTO-AREA-IF-NOT-THERE OBJ PATHNAME-AREA))

;;;--- This duplicates code in version control proper, but that's ok for now.
(DEFUN PARSE-PATHNAME-VC-INFO (THING START END)
  (DECLARE (VALUES BRANCH-NAME BRANCH-VERSION))
  (LET ((DOTX (SCL:STRING-SEARCH-CHAR (CL:CHAR *VERSION-DELIMITER* 0)
				      THING :START START :END END))
	(BRANCH)
	(VERSION))
    (IF (= START END)
	;;--- See comment on VC-STRING-FOR-PRINTING about how :UNSPECIFIC is treated
	(VALUES :UNSPECIFIC :UNSPECIFIC)
      (IF DOTX
	  (PROGN
	    (WHEN (> DOTX START)
	      (SETQ BRANCH (SUBSTRING THING START DOTX))
	      (SETQ BRANCH
		    (COND ((STRING-EQUAL BRANCH "") ':UNSPECIFIC)
			  ((STRING-EQUAL BRANCH "*") ':WILD)
			  (T BRANCH))))
	    (SETQ VERSION (SUBSTRING THING (1+ DOTX) END))
	    (SETQ VERSION
		  (COND ((STRING-EQUAL VERSION "NEWEST") ':NEWEST)
			((STRING-EQUAL VERSION "OLDEST") ':OLDEST)
			((STRING-EQUAL VERSION "PARENT") ':PARENT)
			((STRING-EQUAL VERSION "*") ':WILD)
			((STRING-EQUAL VERSION "") ':UNSPECIFIC)
			((PARSE-NUMBER VERSION 0 NIL 10. T))
			(T VERSION))))
	(SETQ BRANCH
	      (COND ((STRING-EQUAL BRANCH "*") ':WILD)
		    (T (SUBSTRING THING START END)))
	      VERSION NIL))
      ;; Let :VALID-VC-VERSION cause complaint.
      (VALUES BRANCH VERSION))))

;;; Turn anything into a pathname
;;; WITH-RESPECT-TO is the host to parse this on.  DEFAULTS is a set of defaults.
(DEFUN PARSE-PATHNAME (THING &OPTIONAL WITH-RESPECT-TO-HOST
		       (DEFAULTS *DEFAULT-PATHNAME-DEFAULTS*))
  (AND WITH-RESPECT-TO-HOST
       (SETQ WITH-RESPECT-TO-HOST (GET-PATHNAME-HOST WITH-RESPECT-TO-HOST)))
  (ARGUMENT-TYPECASE THING
    (PATHNAME THING)
    (:STRING
      (SETF THING (STRING-THIN THING :ERROR-IF :BITS))
      (LET (HOST-SPECIFIED START END VC-START VC-END VC-BRANCH VC-VERSION)
	(IF WITH-RESPECT-TO-HOST
	    (SETQ HOST-SPECIFIED NIL START 0 END (STRING-LENGTH THING))
	    (MULTIPLE-VALUE (HOST-SPECIFIED START END)
	      (PARSE-PATHNAME-FIND-COLON THING)))
	;; Version Control information can by anyplace after the :.
	;; We parse this even if VC pathnames are not enabled, so that the
	;; proper VC version kludging takes place.
	(LET ((VC-DELIMITER-INDEX
		(SCL:STRING-SEARCH-CHAR *VC-PATHNAME-DELIMITER* THING
					:START START :END END :FROM-END T)))
	  ;; If there was one, the last one is definitive, since VC info
	  ;; cannot contain the delimiter, even doubled.  But we have to
	  ;; check for doubling that would include it in the host information.
	  (WHEN (AND VC-DELIMITER-INDEX
		     (OR (= VC-DELIMITER-INDEX START)	;can't be doubled if its first
			 (NOT (CHAR-EQUAL (CL:CHAR THING (1- VC-DELIMITER-INDEX))
					  *VC-PATHNAME-DELIMITER*))))
	    (SETQ VC-START (1+ VC-DELIMITER-INDEX)
		  VC-END END
		  END VC-DELIMITER-INDEX)
	    (CL:MULTIPLE-VALUE-SETQ (VC-BRANCH VC-VERSION)
	      (PARSE-PATHNAME-VC-INFO THING VC-START VC-END))))
	(LET ((HOST (OR HOST-SPECIFIED WITH-RESPECT-TO-HOST
			(PATHNAME-HOST (DEFAULT-PATHNAME DEFAULTS NIL NIL NIL T)))))
	  (MULTIPLE-VALUE-BIND (DEVICE DIRECTORY NAME TYPE VERSION OTHER-COMPONENTS)
	      (SEND (SEND HOST ':SAMPLE-PATHNAME) ':PARSE-NAMESTRING
		    (NOT (NULL HOST-SPECIFIED)) THING START END)
	    (WHEN (AND (NULL VERSION) (OR VC-BRANCH VC-VERSION))
	      (SETF VERSION :NEWEST))
	    (NETI:PATHNAME-HOST-GET-PATHNAME HOST
	      DEVICE
	      DIRECTORY
	      NAME
	      TYPE
	      VERSION
	      OTHER-COMPONENTS
	      VC-BRANCH
	      VC-VERSION)))))))
			  
(DEFUN PARSE-PATHNAME-FIND-COLON (STRING)
  (DECLARE (VALUES HOST-SPECIFIED START END))
  (LET ((END (STRING-LENGTH STRING))
	(START (OR (STRING-SEARCH-NOT-SET '(#\SP #\TAB #\RETURN) STRING) 0))
	(COLONX (STRING-SEARCH-CHAR #/: STRING)))
    (IF COLONX
	(LET ((HOST-END (STRING-REVERSE-SEARCH-NOT-SET '(#\SP #\TAB #\RETURN)
						       STRING COLONX)))
	  (IF HOST-END
	      (VALUES (GET-PATHNAME-HOST (SUBSTRING STRING START  (1+ HOST-END)))
		      (1+ COLONX) END)
	      (VALUES NIL (1+ COLONX) END)))
	(VALUES NIL START END))))


;;;--- Note that merge-pathnames is circumventing this, because sometimes it
;;;--- it wants this to mean "including non-NIL VC fields."
(DEFMETHOD (:FULLY-MERGED-P PATHNAME) ()
  (AND DEVICE DIRECTORY
       (NOT (AND (LISTP DIRECTORY)
		 (OR (EQ (FIRST DIRECTORY) :RELATIVE)
		     (MEMQ NIL DIRECTORY))))
       NAME TYPE VERSION
       ;; No VC or both VC is OK; :UNSPECIFIC is not fully merged
       ;;--- See comment on VC-STRING-FOR-PRINTING about how :UNSPECIFIC is treated
       (OR (AND VC-BRANCH (OR (AND (SYMBOLP VC-BRANCH)
				   (NEQ VC-BRANCH :UNSPECIFIC))
			      (STRINGP VC-BRANCH))
		VC-VERSION (OR (AND (SYMBOLP VC-VERSION)
				    (NEQ VC-VERSION :UNSPECIFIC))
			       (NUMBERP VC-VERSION)))
	   (NOT (OR VC-BRANCH VC-VERSION)))))


;;; Fill in slots in PATHNAME from program defaults.  This is what most
;;; programs interface to 

(DEFUN MERGE-PATHNAMES (PATHNAME &OPTIONAL
			(DEFAULTS *DEFAULT-PATHNAME-DEFAULTS*)
			(DEFAULT-VERSION ':NEWEST)
			(DEFAULT-VC-VERSION ':NEWEST))
  (CHECK-ARG DEFAULTS (OR (AND (TYPEP DEFAULTS :LIST)
			       (MEMQ DEFAULTS *ALL-DEFAULTS-ALISTS*))
			  (TYPEP DEFAULTS :STRING)
			  (TYPEP DEFAULTS :SYMBOL)
			  (TYPEP DEFAULTS 'PATHNAME))
	     "a string, symbol, pathname, or defaults-alist")
  (SETQ PATHNAME (PARSE-PATHNAME PATHNAME NIL DEFAULTS))
  (TYPECASE DEFAULTS
    ((:LIST :NULL) (SETQ DEFAULTS (DEFAULT-PATHNAME DEFAULTS (SEND PATHNAME :HOST))))
    ((:STRING :SYMBOL PATHNAME) (SETQ DEFAULTS (PARSE-PATHNAME DEFAULTS))))
  (WHEN (AND (SEND PATHNAME :FULLY-MERGED-P)
	     (OR (PATHNAME-VC-P PATHNAME)
		 (NOT (PATHNAME-VC-P DEFAULTS))))
    (RETURN-FROM MERGE-PATHNAMES PATHNAME))
  (SEND PATHNAME :MERGE-PATHNAMES DEFAULTS DEFAULT-VERSION DEFAULT-VC-VERSION))

(DEFWHOPPER (:MERGE-PATHNAMES PATHNAME)
	    (DEFAULT &OPTIONAL (DEFAULT-VERSION :NEWEST) (DEFAULT-VC-VERSION :NEWEST))
  (CONTINUE-WHOPPER (SEND DEFAULT :NEW-DEFAULT-PATHNAME :HOST HOST)
		    DEFAULT-VERSION DEFAULT-VC-VERSION))

(DEFMETHOD (:MERGE-PATHNAMES PATHNAME) (DEFAULT
					 &OPTIONAL (DEFAULT-VERSION :NEWEST)
						   (DEFAULT-VC-VERSION :NEWEST))
  ;; Merge the device, directory, name, and type
  ;; The raw versions are used for efficiency, since the default has already been
  ;; coerced to be on the same host.  This also causes the right case to be transfered
  ;; for LMFS.
  (LET ((DDIR (SEND DEFAULT ':RAW-DIRECTORY))
	(NEW-DEVICE NIL)
	(NEW-DIRECTORY NIL)
	(NEW-NAME NIL)
	(NEW-TYPE NIL)
	(NEW-VERSION NIL)
	(NEW-VC-BRANCH NIL)
	(NEW-VC-VERSION NIL)
	(FORCE-NEW-VC-BRANCH NIL)		;used to force a NIL result
	(FORCE-NEW-VC-VERSION NIL))		;ditto.
    (SETQ NEW-DIRECTORY (COND ((NULL DIRECTORY) DDIR)
			      ((AND (LISTP DIRECTORY) (EQ (CAR DIRECTORY) ':RELATIVE))
			       (MERGE-RELATIVE-DIRECTORY DIRECTORY DDIR T))
			      ((AND (LISTP DIRECTORY) (MEMQ NIL DIRECTORY))
			       (MERGE-DIRECTORIES DIRECTORY DDIR T))))
    (UNLESS DEVICE
      (SETQ NEW-DEVICE (SEND DEFAULT ':RAW-DEVICE)))
    (UNLESS NAME
      (SETQ NEW-NAME (SEND DEFAULT ':RAW-NAME)))
    ;; Merge the type
    (UNLESS TYPE
      (SETQ NEW-TYPE (SEND DEFAULT ':RAW-TYPE)))
    ;; Merge the version as follows: if the version isn't supplied then get it
    ;; from DEFAULT-VERSION if name or type exists, otherwise from DEFAULT pathname.
    (UNLESS VERSION
      (SETQ NEW-VERSION
	    (IF (AND (OR NAME TYPE)
		     (NEQ DEFAULT-VERSION ':DEFAULT))
		DEFAULT-VERSION
		(SEND DEFAULT :VERSION))))
    ;; First, use ordinary defaulting to pick up VC information from the default.
    ;; Only merge in VC info if the user actually typed a lozenge!
    ;;--- See comment on VC-STRING-FOR-PRINTING about how :UNSPECIFIC is treated
    (WHEN (EQ VC-BRANCH :UNSPECIFIC)
      (SETQ NEW-VC-BRANCH (SEND DEFAULT :VC-BRANCH)))
    (WHEN (EQ VC-VERSION :UNSPECIFIC)
      (SETQ NEW-VC-VERSION
	    (IF (AND NEW-VC-BRANCH
		     (OR (AND (SYMBOLP NEW-VC-BRANCH)
			      (NEQ NEW-VC-BRANCH :UNSPECIFIC))
			 (STRINGP NEW-VC-BRANCH)))
		DEFAULT-VC-VERSION
	      (SEND DEFAULT :VC-VERSION))))
    ;; Then, if our VC fields are either of them :UNSPECIFIC, replace with NIL
    (WHEN (EQ NEW-VC-BRANCH :UNSPECIFIC)
      (SETQ NEW-VC-BRANCH NIL
	    FORCE-NEW-VC-BRANCH T))
    (WHEN (EQ NEW-VC-VERSION :UNSPECIFIC)
      (SETQ NEW-VC-VERSION NIL
	    FORCE-NEW-VC-VERSION T))
    ;; Now the matrix that bashes some type and vc info
    (COND ((AND VERSION
		(NEQ VERSION ':WILD)		;a wild version dosen't disallow VC info.
		(NOT (VC-P)))
	   ;; If no explicit VC information, and explicit flat version info,
	   ;; leave NIL for VC info.
	   (SETQ NEW-VC-BRANCH NIL
		 NEW-VC-VERSION NIL))
	  ((AND (VC-P) (NOT VERSION))
	     ;; the converse applies
	   (SETQ NEW-VERSION ':NEWEST)))	;---default-version?
    ;; if the name or type changed, and the vc branch was unspecified,
    ;; use the supplied default version.  It will usually be newest, anyway.
    (WHEN (AND (OR NAME TYPE)
	       (OR VC-BRANCH NEW-VC-BRANCH)	;don't invent a vc version
						;to go with a lack of a vc branch.
	       (NOT VC-VERSION)
	       (SEND DEFAULT :VC-VERSION)
	       (NEQ DEFAULT-VERSION ':DEFAULT))
      (SETQ NEW-VC-VERSION DEFAULT-VERSION))

    (LET ((NARGS 1))
      (AND NEW-DEVICE (INCF NARGS 2))
      (AND NEW-DIRECTORY (INCF NARGS 2))
      (AND NEW-NAME (INCF NARGS 2))
      (AND NEW-TYPE (INCF NARGS 2))
      (AND NEW-VERSION (INCF NARGS 2))
      (WHEN (OR NEW-VC-BRANCH FORCE-NEW-VC-BRANCH) (INCF NARGS 2))
      (WHEN (OR NEW-VC-VERSION FORCE-NEW-VC-VERSION) (INCF NARGS 2))

      (%START-FUNCTION-CALL SELF RETURN NARGS NIL)
      (%PUSH ':NEW-PATHNAME)
      (WHEN NEW-DEVICE
	(%PUSH ':RAW-DEVICE)
	(%PUSH NEW-DEVICE))
      (WHEN NEW-DIRECTORY
	(%PUSH ':RAW-DIRECTORY)
	(%PUSH NEW-DIRECTORY))
      (WHEN NEW-NAME
	(%PUSH ':RAW-NAME)
	(%PUSH NEW-NAME))
      (WHEN NEW-TYPE
	(%PUSH ':RAW-TYPE)
	(%PUSH NEW-TYPE))
      (WHEN NEW-VERSION
	(%PUSH ':VERSION)
	(%PUSH NEW-VERSION))
      (WHEN (OR NEW-VC-BRANCH FORCE-NEW-VC-BRANCH)
	(%PUSH ':VC-BRANCH)
	(%PUSH NEW-VC-BRANCH))
      (WHEN (OR NEW-VC-VERSION FORCE-NEW-VC-VERSION)
	(%PUSH ':VC-VERSION)
	(%PUSH NEW-VC-VERSION))
      (%FINISH-FUNCTION-CALL SELF RETURN NARGS NIL)))) 

;;; Obsolete version.  Keep it around for a while.
(DEFUN MERGE-PATHNAME-DEFAULTS (PATHNAME &OPTIONAL (DEFAULTS *DEFAULT-PATHNAME-DEFAULTS*)
						   (DEFAULT-TYPE ':LISP)
						   (DEFAULT-VERSION ':NEWEST)
					 &AUX HOST DEFAULT NEW-DEVICE NEW-DIRECTORY
					 NEW-NAME NEW-TYPE NEW-VERSION)
  (SETQ PATHNAME (PARSE-PATHNAME PATHNAME NIL DEFAULTS))
  ;; Host always comes from pathname
  (SETQ HOST (PATHNAME-HOST PATHNAME))
  ;; Get default for this host
  (SETQ DEFAULT (DEFAULT-PATHNAME DEFAULTS HOST))
  ;; Merge the device, directory, and name
  (LET ((PDIR (PATHNAME-DIRECTORY PATHNAME))
	(DDIR (PATHNAME-DIRECTORY DEFAULT)))
    (SETQ NEW-DIRECTORY (COND ((NULL PDIR) DDIR)
			      ((AND (LISTP PDIR) (EQ (CAR PDIR) ':RELATIVE))
			       (MERGE-RELATIVE-DIRECTORY PDIR DDIR))
			      ((AND (LISTP PDIR) (MEMQ NIL PDIR))
			       (MERGE-DIRECTORIES PDIR DDIR)))))
  (OR (PATHNAME-DEVICE PATHNAME)
      (SETQ NEW-DEVICE (PATHNAME-DEVICE DEFAULT)))
  (OR (PATHNAME-NAME PATHNAME)
      (SETQ NEW-NAME (PATHNAME-NAME DEFAULT)))
  ;; Merge the type and version if the name was NIL before the above merge,
  ;; or if the user says to always do so.
  (COND ((NULL (PATHNAME-NAME PATHNAME))
	 (OR (PATHNAME-TYPE PATHNAME)
	     (SETQ NEW-TYPE (PATHNAME-TYPE DEFAULT)))
	 (OR (PATHNAME-VERSION PATHNAME)
	     (SETQ NEW-VERSION (PATHNAME-VERSION DEFAULT)))))
  (OR (PATHNAME-TYPE PATHNAME) NEW-TYPE
      (SETQ NEW-TYPE DEFAULT-TYPE))
  (OR (PATHNAME-VERSION PATHNAME) NEW-VERSION
      (SETQ NEW-VERSION (IF (EQ DEFAULT-VERSION ':DEFAULT)
			    (PATHNAME-VERSION DEFAULT)
			  DEFAULT-VERSION)))
  ;; Whatever the new fields are, give them to the pathname.
  ;; I think this is the only way to do this without consing.
  (LET ((NARGS 1))
    (AND NEW-DEVICE (INCF NARGS 2))
    (AND NEW-DIRECTORY (INCF NARGS 2))
    (AND NEW-NAME (INCF NARGS 2))
    (AND NEW-TYPE (INCF NARGS 2))
    (AND NEW-VERSION (INCF NARGS 2))
    (%START-FUNCTION-CALL PATHNAME RETURN NARGS NIL)
    (%PUSH ':NEW-PATHNAME)
    (COND (NEW-DEVICE
	   (%PUSH ':DEVICE)
	   (%PUSH NEW-DEVICE)))
    (COND (NEW-DIRECTORY
	   (%PUSH ':DIRECTORY)
	   (%PUSH NEW-DIRECTORY)))
    (COND (NEW-NAME
	   (%PUSH ':NAME)
	   (%PUSH NEW-NAME)))
    (COND (NEW-TYPE
	   (%PUSH ':CANONICAL-TYPE)
	   (%PUSH NEW-TYPE)))
    (COND (NEW-VERSION
	   (%PUSH ':VERSION)
	   (%PUSH NEW-VERSION)))
    (%FINISH-FUNCTION-CALL PATHNAME RETURN NARGS NIL)))

;;; A relative directory is one whose CAR is :RELATIVE and whose CDR is a a list of
;;; strings and special symbols.  The symbol :UP means step up in the hierarchy.
;;; Strings are just added onto the end of the default.
;;; E.g. (:relative "foo") ("usr" "lispm") => ("usr" "lispm" "foo")
;;;	 (:relative :up "bar") ("usr" "lispm" "foo") => ("usr" "lispm" "bar")
;;;      (:relative :up "bar") ("foo") => ("bar")
;;;      (:relative :up) ("foo") => :root

(DEFUN MERGE-RELATIVE-DIRECTORY (RELATIVE DEFAULT &OPTIONAL NULL-COMPONENTS-OK)
  (IF (NEQ (FIRST RELATIVE) :RELATIVE)
      (MERGE-DIRECTORIES RELATIVE DEFAULT)
    (LOOP FOR DIRECTORY = (COND ((OR (NULL DEFAULT) (EQ DEFAULT ':ROOT)) NIL)
				((ATOM DEFAULT) (NCONS DEFAULT))
				(T (REVERSE DEFAULT)))
			THEN (CDR DIRECTORY)
	  FOR DIR = (FIRST DIRECTORY)
	  FOR RDIR ON (CDR RELATIVE)
	  FOR REL IN (CDR RELATIVE)
	  WHILE (EQ REL :UP)
	  WHEN (NULL DIRECTORY)
	    DO (PARSE-PATHNAME-ERROR "There is no superior to the root.")
	  COLLECT DIR INTO NEW-DEFAULT
	  FINALLY
	    (WHEN (MEMQ NIL DIRECTORY)
	      (UNLESS NULL-COMPONENTS-OK
		(FERROR "Null directory component in ~S." DEFAULT)))
	    (RETURN (OR (NRECONC DIRECTORY
				 (MERGE-DIRECTORIES RDIR (NREVERSE NEW-DEFAULT)
						    NULL-COMPONENTS-OK))
			:ROOT)))))

(DEFUN MERGE-DIRECTORIES (DIRECTORY DEFAULT &OPTIONAL NULL-COMPONENTS-OK)
  (IF (NOT (MEMQ NIL DIRECTORY)) DIRECTORY
    (LOOP FOR DIR IN DIRECTORY
	  FOR DEFDIR = DEFAULT THEN (CDR DEFDIR)
	  FOR DEF = (FIRST DEFDIR)
	  FOR NDIR = (OR DIR DEF)
	  UNLESS (OR NDIR NULL-COMPONENTS-OK)
	    DO (PARSE-PATHNAME-ERROR "Null directory component in ~S~@
				      did not have a default in ~S." DIRECTORY DEFAULT)
	  COLLECT NDIR)))

;;; Another handy user interface, fills in from defaults and updates them.  Useful when
;;; not prompting.
(DEFUN MERGE-PATHNAMES-AND-SET-DEFAULTS (PATHNAME
					&OPTIONAL (DEFAULTS *DEFAULT-PATHNAME-DEFAULTS*)
						  (DEFAULT-VERSION ':NEWEST))
  (SETQ PATHNAME (MERGE-PATHNAMES PATHNAME DEFAULTS DEFAULT-VERSION))
  (AND (LISTP DEFAULTS) (SET-DEFAULT-PATHNAME PATHNAME DEFAULTS))
  PATHNAME)

;;; Obsolete version.  Keep it around for a while.
(DEFUN MERGE-AND-SET-PATHNAME-DEFAULTS (PATHNAME
					&OPTIONAL (DEFAULTS *DEFAULT-PATHNAME-DEFAULTS*)
						  (DEFAULT-TYPE "X")
						  (DEFAULT-VERSION ':NEWEST))
  (SETQ PATHNAME (MERGE-PATHNAME-DEFAULTS PATHNAME DEFAULTS DEFAULT-TYPE DEFAULT-VERSION))
  (AND (LISTP DEFAULTS) (SET-DEFAULT-PATHNAME PATHNAME DEFAULTS))
  PATHNAME)

(DEFMETHOD (:DEFAULT-NAMESTRING PATHNAME) (NAMESTRING &OPTIONAL (DEFAULT-VERSION ':NEWEST))
  (MERGE-PATHNAMES NAMESTRING SELF DEFAULT-VERSION))

;;; The default is not to have completion at all
(DEFMETHOD (:COMPLETE-STRING PATHNAME) (STRING IGNORE)
  ;; Values returned are string, success-p, string-has-host-p
  (VALUES STRING NIL NIL))

(DEFMETHOD (:HOST-DELIMITER PATHNAME :DEFAULT) () #/:)

(DEFUN DEFAULT-PATHNAME-MULTIPLE-FILE-PLISTS (FILES &KEY (CHARACTERS T CHARACTERS-P)
					      (ELEMENT-TYPE ':DEFAULT ELEMENT-TYPE-P))
  (WHEN (AND CHARACTERS-P ELEMENT-TYPE-P)
    (ERROR "DEFAULT-PATHNAME-MULTIPLE-FILE-PLISTS can't take both ~
             :CHARACTERS and :ELEMENT-TYPE"))
  ;; --screw -- no :ELEMENT-TYPE way to say "any byte size"
  (WHEN (AND CHARACTERS-P (NOT ELEMENT-TYPE-P)
	     (SETQ ELEMENT-TYPE (IF CHARACTERS 'CL:CHARACTER ':DEFAULT))))
  (LOOP FOR FILE IN FILES
	AS STREAM = (OPEN FILE ':DIRECTION NIL ':ERROR NIL ':ELEMENT-TYPE ELEMENT-TYPE)
	COLLECT (CONS FILE (AND (NOT (ERRORP STREAM))
				(LET* ((LIST (SEND STREAM ':PLIST))
				       (PLIST (LOCF LIST)))
				  (OR (GET PLIST ':TRUENAME)
				      (PUTPROP PLIST (SEND STREAM ':TRUENAME) ':TRUENAME))
				  LIST)))))

;;; Split off the gut of this method into a defun-method so local file system can call it
;;; conditionally.
(DEFMETHOD (:MULTIPLE-FILE-PLISTS PATHNAME) (FILES OPTIONS)
  (DECLARE (ARGLIST (FILES &KEY (CHARACTERS T CHARACTERS-P)
			   (ELEMENT-TYPE ':DEFAULT ELEMENT-TYPE-P))))
  (CL:APPLY #'DEFAULT-PATHNAME-MULTIPLE-FILE-PLISTS FILES OPTIONS))

(DEFMETHOD (:UNDELETE PATHNAME) ()
  (CHANGE-FILE-PROPERTIES SELF T ':DELETED NIL))

(DEFUN DESCRIBE-PATHNAME (PATHNAME)
  (IF (TYPEP PATHNAME 'PATHNAME)
      (DESCRIBE-PATHNAME-1 PATHNAME)
    (SETQ PATHNAME (PARSE-PATHNAME PATHNAME))
    (LET* ((HOST (PATHNAME-HOST-INSTANCE-VARIABLE PATHNAME))
	   (DEVICE (PATHNAME-DEVICE-INSTANCE-VARIABLE PATHNAME))
	   (DIRECTORY (PATHNAME-DIRECTORY-INSTANCE-VARIABLE PATHNAME))
	   (NAME (PATHNAME-NAME-INSTANCE-VARIABLE PATHNAME))
	   (TYPE (PATHNAME-TYPE-INSTANCE-VARIABLE PATHNAME))
	   (VERSION (PATHNAME-VERSION-INSTANCE-VARIABLE PATHNAME))
	   (HASH-TABLE (SEND HOST ':PATHNAME-HASH-TABLE NIL)))
      (WHEN HASH-TABLE
	(MAPHASH
	  #'(LAMBDA (IGNORE VAL)
	      (AND (OR (NULL DEVICE)
		       (EQUAL DEVICE (PATHNAME-DEVICE-INSTANCE-VARIABLE VAL)))
		   (OR (NULL DIRECTORY)
		       (EQUAL DIRECTORY (PATHNAME-DIRECTORY-INSTANCE-VARIABLE VAL)))
		   (OR (NULL NAME)
		       (EQUAL NAME (PATHNAME-NAME-INSTANCE-VARIABLE VAL)))
		   (OR (NULL TYPE)
		       (EQUAL TYPE (PATHNAME-TYPE-INSTANCE-VARIABLE VAL)))
		   (OR (NULL VERSION)
		       (EQUAL VERSION (PATHNAME-VERSION-INSTANCE-VARIABLE VAL)))
		   (DESCRIBE-PATHNAME-1 VAL)))
	  HASH-TABLE)))))

(DEFUN DESCRIBE-PATHNAME-1 (PATHNAME)
  (LET* ((PLIST (PATHNAME-PROPERTY-LIST PATHNAME))
	 (G-PLIST (PATHNAME-PROPERTY-LIST (SEND PATHNAME :GENERIC-PATHNAME)))
	 (LOADED-IDS (AND G-PLIST (GET (LOCF G-PLIST) ':FILE-ID-PACKAGE-ALIST))))
    (WHEN (OR PLIST G-PLIST)
      (WHEN LOADED-IDS
	(DO ((LOADED-IDS LOADED-IDS (CDR LOADED-IDS))
	     (FIRST-P T NIL)
	     (INFO) (TRUENAME) (CREATION-DATE))
	    ((NULL LOADED-IDS))
	  (SETQ INFO (CADAR LOADED-IDS)
		TRUENAME (CAR INFO)
		CREATION-DATE (CDR INFO))
	  (FORMAT T "~&The version ~:[~*~;of ~A ~]in package ~A ~:[is ~A, and ~;~*~]~
		       was created ~\TIME\~%"
	    FIRST-P PATHNAME (CAAR LOADED-IDS) (EQ PATHNAME TRUENAME) TRUENAME
	    CREATION-DATE)))
      (DO ((PLIST PLIST (CDDR PLIST))
	   (FLAG NIL)
	   (*PRINT-PRETTY* (AND *PRINT-PRETTY* ':DATA))	;Don't grind lists starting with DEFUN
	   (IND) (PROP))
	  ((NULL PLIST))
	(SETQ IND (CAR PLIST)
	      PROP (CADR PLIST))
	(COND ((NEQ IND ':FILE-ID-PACKAGE-ALIST)
	       (COND ((NULL FLAG)
		      (FORMAT T "~&~A has the following ~:[other ~]properties:~%"
			PATHNAME (NULL LOADED-IDS))
		      (SETQ FLAG T)))
	       (FORMAT T "~&~7@T~S:~27T~S~%" IND PROP)))))))

(DEFUN PATHNAME-PLIST (PATHNAME)
  (PATHNAME-PROPERTY-LIST (MERGE-PATHNAMES PATHNAME)))

(DEFUN INIT-FILE-PATHNAME (PROGRAM-NAME
			   &OPTIONAL (CANONICAL-TYPE NIL) (HOST USER-LOGIN-MACHINE))
  (SEND (USER-HOMEDIR HOST) ':INIT-FILE (STRING PROGRAM-NAME) CANONICAL-TYPE))

(DEFMETHOD (:TRUENAME PATHNAME) (&OPTIONAL (ERROR-P T))
  (CONDITION-CASE-IF ERROR-P ()
      (SEND (OPEN SELF ':DIRECTION :PROBE :IF-DOES-NOT-EXIST :ERROR) ':TRUENAME)
    (FILE-OPERATION-FAILURE NIL)))

;;; This isn't implemented as a separate file subprotocol, just use the directory
;;; This has bugs on the ITS file server, where non-existent file returns an
;;; empty list for the directory, and non-existent directory comes back as an
;;; asynchronous mark rather than a command error and hence is not subject to ERROR-P.
;;; Maybe someone will fix these someday.
;;; 11/18/82- Sys 221 - We can at least recognize and generate file-not-found for
;;; all servers.  Directory-not-found will still signal.
(DEFMETHOD (:PROPERTIES PATHNAME) ()
  (LET ((DIR (SEND SELF ':DIRECTORY-LIST '(:DELETED))))
    (COND ((NULL (CDR DIR))
	   (ERROR 'FILE-NOT-FOUND-FOR-PROPERTIES ':PATHNAME SELF))
	  (T (VALUES (CADR DIR) (GET (CAR DIR)  ':SETTABLE-PROPERTIES))))))

(DEFVAR *MISC-FS-TABLE* (CL:MAKE-HASH-TABLE :TEST #'STRING-EQUAL :SIZE 2))

(DEFMACRO DEFINE-SECONDARY-FILE-SYSTEM ((NAME) (HOST SUFFIX) &BODY BODY)
  (SETF NAME (CL:INTERN (STRING NAME) (CL:FIND-PACKAGE "KEYWORD")))
  (LET ((GENSYM (FINTERN "MAKE-~A-FILE-HOST" NAME)))
    `(PROGN
       (DEFUN ,GENSYM (,HOST ,SUFFIX)
	 (DECLARE (SYS:FUNCTION-PARENT ,NAME DEFINE-SECONDARY-FILE-SYSTEM))
	 ,@BODY)
       (DEFINE-SECONDARY-FILE-SYSTEM-1 ',NAME ',GENSYM))))

(DEFUN DEFINE-SECONDARY-FILE-SYSTEM-1 (NAME GENSYM)
  (WHEN (RECORD-SOURCE-FILE-NAME NAME 'DEFINE-SECONDARY-FILE-SYSTEM)
    (CL:SETF (CL:GETHASH (CL:SYMBOL-NAME NAME) *MISC-FS-TABLE*) (SYS:FDEFINITION GENSYM))))

;;; Only mung these without-interrupts, because it can be changed.
;;; Can't use a lock because it is munged in the scheduler.
(DEFVAR *PATHNAME-HOST-LIST* NIL)		;Physical hosts
(DEFVAR *LOGICAL-PATHNAME-HOST-LIST* NIL)	;Logical hosts

(DEFUN GET-PATHNAME-HOST (HOST-NAME &OPTIONAL NO-ERROR-P NO-AUTO-ADD-P)
  (OR (GET-PATHNAME-HOST-I HOST-NAME (LOCF *LOGICAL-PATHNAME-HOST-LIST*))
      (GET-PATHNAME-HOST-I HOST-NAME (LOCF *PATHNAME-HOST-LIST*))
      (AND (NOT NO-AUTO-ADD-P)
	   (LET ((HOST (CL:TYPECASE HOST-NAME
			 (NET:BASIC-HOST HOST-NAME)
			 (CL:STRING (PARSE-PATHNAME-HOST HOST-NAME)))))
	     (AND HOST
		  (PROGN
		    (SEND HOST :MAYBE-DECACHE-NAME-AS-FILE-COMPUTER)
		    (WITHOUT-INTERRUPTS
		      (SI:PUSH* HOST *PATHNAME-HOST-LIST*))
		    HOST))))
      (GET-LOGICAL-PATHNAME-HOST HOST-NAME NO-ERROR-P)))

(DEFUN PARSE-PATHNAME-HOST (HOST-NAME)
  ;; Handle LOCAL:
  (WHEN (STRING-EQUAL HOST-NAME "local")
    (RETURN-FROM PARSE-PATHNAME-HOST NET:*LOCAL-HOST*))
  ;; Handle FEPn: and HOST: (along with host|FEPn: and host|HOST:)
  (LET* ((BAR-IDX (STRING-REVERSE-SEARCH-CHAR #/| HOST-NAME))
	 (LENGTH (CL:LENGTH HOST-NAME))
	 (SUFFIX-IDX (1+ (OR (STRING-REVERSE-SEARCH-NOT-SET "0123456789" HOST-NAME)
			     (1- LENGTH)))))
    (MULTIPLE-VALUE-BIND (PARENT CHILD)
	(IF (NOT (NULL BAR-IDX))
	    (VALUES (SUBSTRING HOST-NAME 0 BAR-IDX)
		    (SUBSTRING HOST-NAME (1+ BAR-IDX) SUFFIX-IDX))
	    (VALUES "local"
		    (SUBSTRING HOST-NAME 0 SUFFIX-IDX)))
      (LET ((MAKER (CL:GETHASH CHILD *MISC-FS-TABLE*)))
	(WHEN (NOT (NULL MAKER))
	  (LET ((PARENT (IF (STRING-EQUAL PARENT "local")
			    NET:*LOCAL-HOST*
			    (NET:PARSE-HOST PARENT T))))
	    (WHEN (NOT (NULL PARENT))
	      (LET ((HOST (FUNCALL MAKER PARENT
				   (AND (< SUFFIX-IDX LENGTH)
					(CL:PARSE-INTEGER HOST-NAME :START SUFFIX-IDX)))))
		(WHEN (NOT (NULL HOST))
		  (RETURN-FROM PARSE-PATHNAME-HOST HOST)))))))))
  ;; Handle the normal case for hosts.
  (LET ((HOST (NET:PARSE-HOST HOST-NAME T)))
    (WHEN HOST
      (RETURN-FROM PARSE-PATHNAME-HOST HOST)))
  ;; Handle the normal case for file systems.
  (LET ((OBJ (CONDITION-CASE ()
		  (NETI:FIND-OBJECT-NAMED :FILE-SYSTEM HOST-NAME)
		(NETI:OBJECT-NOT-FOUND NIL))))
    (WHEN OBJ
      (RETURN-FROM PARSE-PATHNAME-HOST OBJ)))
  NIL)

(DEFUN GET-LOGICAL-PATHNAME-HOST (HOST-NAME &OPTIONAL NO-ERROR-P)
  (LOOP DOING
    (CATCH-ERROR-RESTART (SYS:ERROR "Try to load logical host ~A" HOST-NAME)
      (RETURN
	(COND ((GET-PATHNAME-HOST-I HOST-NAME (LOCF *LOGICAL-PATHNAME-HOST-LIST*)))
	      (NO-ERROR-P NIL)
	      (T (ERROR 'UNKNOWN-PATHNAME-HOST ':NAME HOST-NAME)))))
    (MAKE-LOGICAL-PATHNAME-HOST HOST-NAME)))

(DEFUN GET-PATHNAME-HOST-I (HOST-NAME LIST)
  (WITHOUT-INTERRUPTS
    (DO ((HOSTP (TYPEP HOST-NAME 'NET:BASIC-HOST))
	 (L (CDR LIST) (CDR L))
	 (L1 LIST L))
	((NULL L) NIL)
      (AND (IF HOSTP
	       (EQ (CAR L) HOST-NAME)
	       (SEND (CAR L) ':PATHNAME-HOST-NAMEP HOST-NAME))
	   (RETURN
	     (PROG1 (CAR L)
		    (COND ((NEQ L1 LIST)
			   (RPLACD L1 (CDR L))
			   (RPLACD LIST
				   (RPLACD L (CDR LIST)))))))))))

;;; Returns an alist that you can pass to the functions below that take a set of defaults.
(DEFVAR *ALL-DEFAULTS-ALISTS* NIL
  "All defaults alists are remembered here, for resetting when the site changes")

(DEFUN MAKE-PATHNAME-DEFAULTS ()
  (LET ((ALIST (NCONS (NCONS NIL))))
    (WITHOUT-INTERRUPTS
      (PUSH ALIST *ALL-DEFAULTS-ALISTS*))
    ALIST))

(DEFUN PATHNAME-DEFAULTS-P (DEFAULTS)
  (MEMQ DEFAULTS *ALL-DEFAULTS-ALISTS*))

(DEFUN RESET-ALL-PATHNAME-DEFAULTS ()
  (LOOP FOR ALIST IN *ALL-DEFAULTS-ALISTS*
	DO (SETF (CAR ALIST) (NCONS NIL))
	   (SETF (CDR ALIST) NIL))
  (SETQ CL:*DEFAULT-PATHNAME-DEFAULTS*
	(DEFAULT-PATHNAME)))

(ADD-INITIALIZATION "Reset pathname defaults" 
		    '(RESET-ALL-PATHNAME-DEFAULTS)
		    '(:BEFORE-COLD))

(SI:DEFINE-GC-OPTIMIZATION RESET-ALL-PATHNAME-DEFAULTS :LAYERED-IDS-RELEASE
  (:DOCUMENTATION "Reset pathname defaults")
  (:ORDER (:BEFORE GC-PATHNAMES))		;This conses pathnames
  (:BEFORE-FLIP (IGNORE)
    (RESET-ALL-PATHNAME-DEFAULTS)))

(DEFUN COPY-PATHNAME-DEFAULTS (DEFAULTS)
  (CHECK-ARG DEFAULTS PATHNAME-DEFAULTS-P "a pathname defaults alist")
  (LET ((NEW (COPYALIST DEFAULTS)))
    (WITHOUT-INTERRUPTS
      (PUSH NEW *ALL-DEFAULTS-ALISTS*))))

;;; Returns the default for the given host from defaults.
;;; SAMPLE-P means this function is being called from inside the parsing function and
;;; cannot do any parsing itself, but must just return something to accept messages.
;;; DEFAULTS can also be an atom, which is used as a default.
(DEFUN DEFAULT-PATHNAME (&OPTIONAL DEFAULTS HOST DEFAULT-TYPE DEFAULT-VERSION SAMPLE-P
			 &AUX PATHNAME DEFAULT-HOST)
  ;; Default the arguments if unsupplied or NIL
  (AND HOST (SETQ HOST (GET-PATHNAME-HOST HOST)))
  (OR DEFAULTS (SETQ DEFAULTS *DEFAULT-PATHNAME-DEFAULTS*))
  ;; Get PATHNAME and DEFAULT-HOST
  (IF (AND DEFAULTS (NLISTP DEFAULTS))
      ;; DEFAULTS is not a defaults a-list, so it must be a pathname
      (SETQ PATHNAME (PARSE-PATHNAME DEFAULTS)
	    DEFAULT-HOST (PATHNAME-HOST PATHNAME))
      ;; Get the relevant entry from the defaults alist
      (LET ((ELEM (COND ((NOT *DEFAULTS-ARE-PER-HOST*) (ASSQ NIL DEFAULTS))
			(HOST (ASSQ HOST DEFAULTS))
			(T (DOLIST (DEFAULT DEFAULTS)	;Last host mentioned
			     (AND (CDR DEFAULT) (RETURN DEFAULT)))))))
	(IF SAMPLE-P
	    ;; If SAMPLE-P, all we want to know is what host to use
	    (SETQ DEFAULT-HOST (OR HOST		;We were told
				   (CAR ELEM)	;Third case of COND above
				   (AND (CDR ELEM) (PATHNAME-HOST (CDR ELEM)))	;First of COND
				   USER-LOGIN-MACHINE))	;If all else fails, this is always set
	    ;; If not SAMPLE-P, we need to get the pathname from ELEM
	    (UNLESS (OR HOST (CDR ELEM))
	      (IF (OR (NOT (VARIABLE-BOUNDP USER-LOGIN-MACHINE))
		      (NOT USER-LOGIN-MACHINE))
		  ;; Cold load environment.
		  (SETQ ELEM (NCONS NET:*LOCAL-HOST*))
		  ;; No defaults recorded yet, use the login machine as the host
		  (FORCE-USER-TO-LOGIN)
		  (SETQ ELEM (OR (ASSQ USER-LOGIN-MACHINE DEFAULTS)
				 (NCONS USER-LOGIN-MACHINE)))))
	    ;; If no default recorded yet for this host, make one up
	    (SETQ PATHNAME (OR (CDR ELEM)
			       (SEND (QUIET-USER-HOMEDIR (OR HOST (CAR ELEM)
							     NET:*LOCAL-HOST*))
				     :NEW-DEFAULT-PATHNAME
				     :NAME "FOO" :CANONICAL-TYPE :LISP :VERSION :NEWEST)))
	    (SETQ DEFAULT-HOST (PATHNAME-HOST PATHNAME))
	    ;; Check for this specific case here, as it would otherwise cause
	    ;; infinite recursion.
	    (UNLESS (SEND PATHNAME :FULLY-MERGED-P)
	      (FERROR "DEFAULT-PATHNAME received a defaults alist, ~S,~@
		     with an incompletly-merged pathname, ~S."
		      DEFAULTS PATHNAME)))))
  (COND (SAMPLE-P (SETQ PATHNAME (SEND DEFAULT-HOST ':SAMPLE-PATHNAME)))
	;; If default-type or default-version was given, or the host has changed,
	;; merge those in.
	((OR (AND HOST (NEQ HOST DEFAULT-HOST)) DEFAULT-TYPE DEFAULT-VERSION)
	 (OR HOST (SETQ HOST DEFAULT-HOST))
	 (LET ((ACTOR (SEND HOST ':SAMPLE-PATHNAME))
	       CANONICAL-TYPE
	       (ORIGINAL-TYPE NIL))
	   (COND ((EQ (SEND HOST ':SYSTEM-TYPE)
		      (SEND DEFAULT-HOST ':SYSTEM-TYPE))
		  ;; Same host type.  Be extra careful about preserving case, for the
		  ;; sake of LMFS.
		  (SETQ PATHNAME
			(SEND ACTOR ':NEW-DEFAULT-PATHNAME
			      ':RAW-DEVICE  (IF (EQ HOST DEFAULT-HOST)
						(SEND PATHNAME ':DEVICE)
						(SEND ACTOR ':PRIMARY-DEVICE))
			      ':RAW-DIRECTORY (SEND PATHNAME ':RAW-DIRECTORY)
			      ':RAW-NAME (SEND PATHNAME ':RAW-NAME)
			      (IF DEFAULT-TYPE ':TYPE ':RAW-TYPE)
			      (OR DEFAULT-TYPE (SEND PATHNAME ':RAW-TYPE))
			      ':VERSION (OR DEFAULT-VERSION (SEND PATHNAME ':VERSION))
			      ':VC-BRANCH (SEND PATHNAME :VC-BRANCH)
			      ':VC-VERSION (AND (SEND PATHNAME :VC-BRANCH)
						(OR DEFAULT-VERSION
						    (SEND PATHNAME :VC-VERSION)))
			      )))
		 (T (IF DEFAULT-TYPE
			(SETQ CANONICAL-TYPE DEFAULT-TYPE)
			(MULTIPLE-VALUE (CANONICAL-TYPE ORIGINAL-TYPE)
			  (SEND PATHNAME ':CANONICAL-TYPE)))
		    (SETQ PATHNAME
			  (SEND ACTOR ':NEW-DEFAULT-PATHNAME
				':HOST HOST
				':DEVICE (IF (EQ HOST DEFAULT-HOST) (SEND PATHNAME ':DEVICE)
					     (SEND ACTOR ':PRIMARY-DEVICE))
				':DIRECTORY (SEND PATHNAME ':DIRECTORY)
				':NAME (SEND PATHNAME ':NAME)
				':CANONICAL-TYPE CANONICAL-TYPE
				':ORIGINAL-TYPE ORIGINAL-TYPE
				':VERSION (OR DEFAULT-VERSION
					      (PATHNAME-VERSION PATHNAME))
				':VC-BRANCH (SEND PATHNAME :VC-BRANCH)
				':VC-VERSION (AND (SEND PATHNAME :VC-BRANCH)
						(OR DEFAULT-VERSION
						    (SEND PATHNAME :VC-VERSION))))))))))
  ;; This shouldn't recurse infinitely, unless *DEFAULT-PATHNAME-DEFAULTS* is messed up.
  ;; When MERGE-PATHNAMES calls us again, that's where PATHNAME will come from.
  (UNLESS (SEND PATHNAME :FULLY-MERGED-P)	;Make one last try to merge.
    (SETQ PATHNAME (MERGE-PATHNAMES PATHNAME))
    ;; Try again harder, if we don't have a fully-merged directory.
    (LET ((RAW-DIR (SEND PATHNAME :RAW-DIRECTORY)))
      (WHEN (AND (LISTP RAW-DIR) (MEMQ NIL RAW-DIR))
	(SETQ PATHNAME (SEND PATHNAME :NEW-PATHNAME :RAW-DIRECTORY (REMQ NIL RAW-DIR))))))
  (UNLESS (SEND PATHNAME :FULLY-MERGED-P)
    (FERROR "DEFAULT-PATHNAME tried to return ~A, which is an incomplete default."
	    PATHNAME))
  PATHNAME) 

;;; Sets the default for a defaults alist (default *DEFAULT-PATHNAME-DEFAULTS*)
(DEFUN SET-DEFAULT-PATHNAME (PATHNAME &OPTIONAL (DEFAULTS *DEFAULT-PATHNAME-DEFAULTS*)
			     &AUX ELEM)
  (CATCH-ERROR-RESTART (ERROR "Skip setting default to ~A,~@
			       and perhaps try to use it."
			       PATHNAME)
    (CHECK-ARG DEFAULTS PATHNAME-DEFAULTS-P "pathname defaults alist")
    (SETQ PATHNAME (MERGE-PATHNAMES (PARSE-PATHNAME PATHNAME NIL DEFAULTS)
				    (DEFAULT-PATHNAME DEFAULTS)))
    (UNLESS (SEND PATHNAME :FULLY-MERGED-P)
      (FERROR "Attempt to set a default to ~A, which is not fully-merged." PATHNAME))
    (OR (SETQ ELEM (ASSQ (PATHNAME-HOST PATHNAME) DEFAULTS))
	(PROGN (SETQ ELEM (NCONS (PATHNAME-HOST PATHNAME)))	;put new elem in list so PULL
	       (NCONC DEFAULTS (NCONS ELEM))))	            ;can work entirely by side-effect
    (SETF (CDR ELEM) PATHNAME)
    (SETQ DEFAULTS (PULL ELEM DEFAULTS))	;This is the default host
    (AND (NOT *DEFAULTS-ARE-PER-HOST*)
	 (SETQ ELEM (ASSQ NIL DEFAULTS))
	 (SETF (CDR ELEM) PATHNAME))
    (WHEN (EQ DEFAULTS *DEFAULT-PATHNAME-DEFAULTS*)
      ;; set it for Common Lisp too.
      (SETQ CL:*DEFAULT-PATHNAME-DEFAULTS* PATHNAME)))
  PATHNAME)

;;; Move ITEM to the front of LIST destructively
;;; If item is not in LIST, a list is returned whose CAR is ITEM and whose CDR is the
;;; unmodified original list.
(DEFUN PULL (ITEM LIST)
  (IF (MEMQ ITEM LIST)
      (DO ((LS LIST (CDR LS))
	   (IT ITEM))
	  (NIL)
	(SETF (CAR LS) (PROG1 IT (SETQ IT (CAR LS))))
	(AND (EQ ITEM IT) (RETURN LIST)))
      (CONS ITEM LIST)))

;;; This is a less strong version of DEFAULT-PATHNAME.  It takes a
;;; defaults-alist, pathname, string, or NIL, like DEFAULT-PATHNAME,
;;; but it does not fill in unspecified components if given a pathname or string.
(DEFUN COERCE-PATHNAME-DEFAULTS (THING)
  (TYPECASE THING
    ((:NULL :LIST)
     (DEFAULT-PATHNAME THING))
    (OTHERWISE (PARSE-PATHNAME THING))))

(DEFMETHOD (:SYSTEM-TYPE PATHNAME) ()
  (SEND HOST :SYSTEM-TYPE))

(DEFMETHOD (:HEURISTIC-PARSE-MAYBE-HOSTED-PATHNAME PATHNAME) (STRING)
  (SEND SELF ':PARSE-TRUENAME STRING NIL))

(DEFMETHOD (:HEURISTIC-PRINT-MAYBE-HOSTED-PATHNAME PATHNAME) (PATHNAME)
  (IF (EQ HOST (SEND PATHNAME ':HOST))
      (SEND PATHNAME ':STRING-FOR-HOST)
      (FERROR "The pathname ~A is not on the host ~A.  This pathname cannot be written~@
		in a format readable by host ~A." PATHNAME HOST HOST)))

(DEFUN HEURISTIC-PARSE-MAYBE-HOSTED-PATHNAME (STRING DEFAULTS)
  (LET ((DEFAULT-PATHNAME (DEFAULT-PATHNAME DEFAULTS NIL NIL NIL T)))
    (MERGE-PATHNAMES
      (SEND DEFAULT-PATHNAME ':HEURISTIC-PARSE-MAYBE-HOSTED-PATHNAME STRING)
      DEFAULTS)))

(DEFUN HEURISTIC-PRINT-MAYBE-HOSTED-PATHNAME (PATHNAME DEFAULTS)
  (SEND (DEFAULT-PATHNAME DEFAULTS NIL NIL NIL T)
	':HEURISTIC-PRINT-MAYBE-HOSTED-PATHNAME PATHNAME))

(DEFFLAVOR HIERARCHICAL-DIRECTORY-NO-PATCH-MIXIN () ()
  (:REQUIRED-FLAVORS PATHNAME))

(DEFFLAVOR HIERARCHICAL-DIRECTORY-MIXIN () (HIERARCHICAL-DIRECTORY-NO-PATCH-MIXIN)
  (:REQUIRED-FLAVORS PATHNAME))

(DEFMETHOD (:VALID-DIRECTORY-P HIERARCHICAL-DIRECTORY-NO-PATCH-MIXIN) (DIRNAME)
  (TYPECASE DIRNAME
    (:SYMBOL (MEMQ DIRNAME '(NIL :WILD :ROOT)))
    (:LIST (AND (OR (NEQ (CAR DIRNAME) :WILD-INFERIORS)
		    (NOT (SEND SELF :ROOT-ALWAYS-EXPLICIT-P)))
		(SEND SELF ':VALID-SUBDIRECTORY-P DIRNAME 0)))))

(DEFMETHOD (:VALID-SUBDIRECTORY-P HIERARCHICAL-DIRECTORY-NO-PATCH-MIXIN) (DIRNAME-LIST LEVEL)
  (LOOP FOR DIRNAME IN DIRNAME-LIST
	FOR I FROM LEVEL
	FOR FIRST-P = T THEN NIL
	DO (SELECTQ DIRNAME
	     ((:RELATIVE)
	      (IF FIRST-P
		  (UNLESS (SEND SELF :ROOT-ALWAYS-EXPLICIT-P)
		    (SETQ I -1))
		  (RETURN NIL)))
	     ((:UP :WILD-INFERIORS)
	      (DECF I)))
	WHEN (< I -1)
	  DO (SETQ I -1)
	UNLESS (< I 0)
	  ALWAYS (SEND SELF ':VALID-DIRECTORY-COMPONENT-P DIRNAME I)))

;;; Can we talk about the root without it being an additional level of directory?
(DEFMETHOD (:ROOT-ALWAYS-EXPLICIT-P HIERARCHICAL-DIRECTORY-NO-PATCH-MIXIN :DEFAULT) ()
  NIL)

(DEFMETHOD (:VALID-DIRECTORY-COMPONENT-P HIERARCHICAL-DIRECTORY-NO-PATCH-MIXIN)
	   (DIRNAME IGNORE)
  (OR (STRINGP DIRNAME) (MEMQ DIRNAME '(:WILD NIL))))

;;; By default, a directory is stored as a file in the superior directory whose name gives
;;; the name of the component at this level.
(DEFMETHOD (:PATHNAME-AS-DIRECTORY HIERARCHICAL-DIRECTORY-NO-PATCH-MIXIN) ()
  (SEND SELF :NEW-PATHNAME
	:RAW-DIRECTORY (COND ((EQ DIRECTORY :ROOT) (LIST NAME))
			     ((LISTP DIRECTORY) (APPEND DIRECTORY (LIST NAME)))
			     (T (FERROR "Cannot get pathname as directory.")))
	:RAW-NAME NIL
	:RAW-TYPE NIL
	:VERSION NIL))

;;; For composing hierarchical directories.
;;; New level is RAW.
(DEFMETHOD (:DOWN-DIRECTORY-LEVEL HIERARCHICAL-DIRECTORY-NO-PATCH-MIXIN) (NEW-LEVEL)
  (SEND SELF ':NEW-RAW-DIRECTORY
	(COND ((EQ DIRECTORY ':ROOT) (LIST NEW-LEVEL))
	      ((STRINGP DIRECTORY) (LIST DIRECTORY NEW-LEVEL))
	      ((ATOM DIRECTORY) (FERROR
				  "Directory not suitable for going down a level: ~A" SELF))
	      (T (APPEND DIRECTORY (LIST NEW-LEVEL))))))

;;; For decomposing hierarchical directories.
(DEFMETHOD (:UP-DIRECTORY-LEVEL HIERARCHICAL-DIRECTORY-NO-PATCH-MIXIN) ()
  (COND ((EQ DIRECTORY ':ROOT)
	 (FERROR "Cannot go up a level from the root directory: ~A" SELF))
	((ATOM DIRECTORY)
	 (FERROR "Directory not suitable for going up a level: ~A" SELF))
	(T (VALUES
	     (SEND SELF ':NEW-RAW-DIRECTORY
		   (OR (BUTLAST DIRECTORY) ':ROOT))
	     (CAR (LAST DIRECTORY))))))

(DEFMETHOD (:PATCH-FILE-DIRECTORY HIERARCHICAL-DIRECTORY-MIXIN)
	   (SYSTEM-NAME SAME-DIRECTORY-P PATOM MAJOR-VERSION)
  (SEND (SEND SELF :NEW-PATHNAME
	      :NAME (SEND SELF :PATCH-FILE-NAME
			  SYSTEM-NAME SAME-DIRECTORY-P PATOM MAJOR-VERSION))
	:PATHNAME-AS-DIRECTORY))

(DEFMETHOD (:PATCH-FILE-PATHNAME HIERARCHICAL-DIRECTORY-MIXIN)
	   (SYSTEM-NAME SAME-DIRECTORY-P PATOM PATCH-TYPE
			&OPTIONAL MAJOR-VERSION MINOR-VERSION FILE-TYPE)
  (SELECTQ PATCH-TYPE
    (:SYSTEM-DIRECTORY
     (SEND SELF ':NEW-PATHNAME
	   ':NAME (SEND SELF :PATCH-FILE-NAME SYSTEM-NAME SAME-DIRECTORY-P PATOM)
	   ':CANONICAL-TYPE ':PATCH-SYSTEM-DIRECTORY
	   ':VERSION ':NEWEST))
    (OTHERWISE
     (LET ((NEW-DIR (SEND SELF :PATCH-FILE-DIRECTORY
			  SYSTEM-NAME SAME-DIRECTORY-P PATOM MAJOR-VERSION)))
	       (SELECTQ PATCH-TYPE
		 (:COMPONENT-DIRECTORY
		  (SEND NEW-DIR :NEW-PATHNAME
			:NAME (SEND SELF :PATCH-FILE-NAME
				    SYSTEM-NAME SAME-DIRECTORY-P PATOM MAJOR-VERSION)
			:CANONICAL-TYPE :PATCH-COMPONENT-DIRECTORY
			:VERSION :NEWEST))
		 (:PATCH-DIRECTORY
		  (SEND NEW-DIR :NEW-PATHNAME
			:NAME (SEND SELF :PATCH-FILE-NAME
				    SYSTEM-NAME SAME-DIRECTORY-P PATOM MAJOR-VERSION)
			:CANONICAL-TYPE :PATCH-PATCH-DIRECTORY
			:VERSION :NEWEST))
		 (:PATCH-FILE
		  (SEND NEW-DIR ':NEW-PATHNAME
			':NAME (SEND SELF :PATCH-FILE-NAME SYSTEM-NAME SAME-DIRECTORY-P PATOM
				     MAJOR-VERSION MINOR-VERSION)
			':CANONICAL-TYPE FILE-TYPE
			':VERSION ':NEWEST)))))))


#||               The code in here supported ancient patch file locations.
		  it is left in the source for documentation only.

;;; The following is to provide compatibility between systems built in releases 5.0 and 5.1.
;;; It remembers whether a given version of a system uses the old or new patch file pathnames.

(DEFVAR *PATCH-DIRECTORY-CACHE* (MAKE-EQUAL-HASH-TABLE))

(ADD-INITIALIZATION "Clear patch directory cache"
		    '(SEND *PATCH-DIRECTORY-CACHE* :CLEAR-HASH)
		    '(:FULL-GC))

(ADD-INITIALIZATION "Clear patch directory cache"
		    '(SEND *PATCH-DIRECTORY-CACHE* :CLEAR-HASH)
		    '(:BEFORE-COLD))

(DEFUN PATCH-FILE-WITH-TYPE (PATHNAME TYPE)
  (condition-case ()
       (LET ((PHYSICAL
	       (IF (AND TYPE (SYMBOLP TYPE)
			(NOT (MEMQ TYPE '(:UNSPECIFIC :WILD))))
		   (FIND-FILE-WITH-TYPE (SEND PATHNAME :NEW-TYPE NIL) TYPE)
		   (UNLESS (SEND PATHNAME :WILD-P)
		     (PROBEF PATHNAME)))))
	 (WHEN PHYSICAL
	   (SEND PATHNAME :NEW-PATHNAME :RAW-TYPE (SEND PHYSICAL :RAW-TYPE))))
     (directory-not-found nil)))

;;; TRY-CONTINUATION and TRY-OLD are continuation functions that
;;; yield a pathname to try, with the new and old syntax, respectively.
;;; TRY-CONTINUATION takes an optional argument of a value for SAME-DIRECTORY-P.

(DEFUN HIERARCHICAL-DIRECTORY-PATCH-FILE-SEARCH (TRY-CONTINUATION TRY-OLD FILE-TYPE)
  (DECLARE (SYS:DOWNWARD-FUNARG TRY-CONTINUATION TRY-OLD))
  (LET ((PATHNAME (FUNCALL TRY-CONTINUATION)))
    (LABELS ((PROBE-PATCH-FILE (&KEY TRY-PATHNAME SUCCESS-TYPE FAILURE-TYPE (ERROR-P T))
	       (DECLARE (SYS:DOWNWARD-FUNCTION))
	       (CONDITION-CASE-IF (NOT ERROR-P) ()
		    (CONDITION-CASE ()
			 (IF (NOT (IF (SEND TRY-PATHNAME :WILD-P)
				      (CDR (DIRECTORY-LIST PATHNAME))
				    (SETQ TRY-PATHNAME
					  (PATCH-FILE-WITH-TYPE TRY-PATHNAME FILE-TYPE))))
			     FAILURE-TYPE
			   (SETQ PATHNAME TRY-PATHNAME)
			   SUCCESS-TYPE)
		       ((FILE-LOOKUP-ERROR WRONG-KIND-OF-FILE)
			NIL))
		  (ERROR NIL))))
      (LET ((NEW-TYPE
	      (OR (PROBE-PATCH-FILE :TRY-PATHNAME PATHNAME
				    :SUCCESS-TYPE :NEW)
		  (PROBE-PATCH-FILE
		    :TRY-PATHNAME (FUNCALL TRY-CONTINUATION :EXPLICIT)
		    :SUCCESS-TYPE :NEW-BUT-WITH-PATOM
		    :ERROR-P NIL)
		  (PROBE-PATCH-FILE
		    :TRY-PATHNAME (FUNCALL TRY-OLD)
		    :SUCCESS-TYPE :OLD
			   :FAILURE-TYPE :NEW
			   :ERROR-P NIL))))
	(VALUES PATHNAME NEW-TYPE)))))


(DEFWHOPPER (:PATCH-FILE-PATHNAME HIERARCHICAL-DIRECTORY-MIXIN)
	    (SYSTEM-NAME SAME-DIRECTORY-P PATOM PATCH-TYPE
			 &OPTIONAL MAJOR-VERSION MINOR-VERSION FILE-TYPE)
  (LET ((DIRECTORY-PATH (SEND SELF :NEW-PATHNAME :NAME NIL :TYPE NIL :VERSION NIL)))
    (WITH-STACK-LIST (KEY DIRECTORY-PATH SYSTEM-NAME MAJOR-VERSION)
      (FLET ((PROBE (PATHNAME)
	       (OR (PATCH-FILE-WITH-TYPE PATHNAME FILE-TYPE) PATHNAME)))
	(SELECTQ (SEND *PATCH-DIRECTORY-CACHE* :GET-HASH KEY)
	  (:NEW (PROBE (CONTINUE-WHOPPER SYSTEM-NAME SAME-DIRECTORY-P PATOM PATCH-TYPE
					 MAJOR-VERSION MINOR-VERSION FILE-TYPE)))
	  (:NEW-BUT-WITH-PATOM
	   (PROBE (CONTINUE-WHOPPER SYSTEM-NAME :EXPLICIT PATOM PATCH-TYPE
				    MAJOR-VERSION MINOR-VERSION FILE-TYPE)))
	  (:OLD (SEND SELF :OLD-PATCH-FILE-PATHNAME SYSTEM-NAME SAME-DIRECTORY-P PATOM
		      PATCH-TYPE MAJOR-VERSION MINOR-VERSION FILE-TYPE))
	  ((NIL)
	   ;; We didn't have it cached.  We look it up.
	   ;; First we get continuations to compute the possible pathnames.
	   (FLET ((TRY-CONTINUATION (&OPTIONAL (NEW-SAME-DIRECTORY-P SAME-DIRECTORY-P))
		    (DECLARE (SYS:DOWNWARD-FUNCTION))
		    (CONTINUE-WHOPPER SYSTEM-NAME NEW-SAME-DIRECTORY-P
				      PATOM PATCH-TYPE
				      MAJOR-VERSION MINOR-VERSION
				      FILE-TYPE))
		  (TRY-OLD ()
		    (DECLARE (SYS:DOWNWARD-FUNCTION))
		    (SEND SELF :OLD-PATCH-FILE-PATHNAME
			  SYSTEM-NAME SAME-DIRECTORY-P
			  PATOM PATCH-TYPE
			  MAJOR-VERSION MINOR-VERSION
			  FILE-TYPE)))
	     (MULTIPLE-VALUE-BIND (PATHNAME NEW-TYPE)
		 (HIERARCHICAL-DIRECTORY-PATCH-FILE-SEARCH #'TRY-CONTINUATION #'TRY-OLD
							   FILE-TYPE)
	       (WHEN NEW-TYPE
		 (SEND *PATCH-DIRECTORY-CACHE* :PUT-HASH (COPYLIST KEY)
		       NEW-TYPE))
	       PATHNAME))))))))

||#

(DEFFLAVOR MEANINGFUL-ROOT-MIXIN () ()
  (:REQUIRED-FLAVORS PATHNAME)
  (:REQUIRED-METHODS :DIRECTORY-PATHNAME-AS-FILE)
  (:METHOD-COMBINATION :VALID-DIRECTORY-COMPONENT-P :DAEMON-WITH-OR)
  (:DOCUMENTATION :MIXIN "For use with file systems where the root directory is treated
as an ordinary directory."))

(DEFMETHOD (:VALID-DIRECTORY-COMPONENT-P MEANINGFUL-ROOT-MIXIN :OR) (DIRNAME IGNORE)
  (MEMQ DIRNAME '(:RELATIVE :UP)))


;; Error System interface

(DEFFLAVOR PATHNAME-ERROR () (ERROR))

(DEFFLAVOR PARSE-PATHNAME-ERROR () (FERROR PATHNAME-ERROR))

(DEFPROP PARSE-PATHNAME-ERROR T :ERROR-REPORTER)
(DEFUN PARSE-PATHNAME-ERROR (FORMAT-STRING &REST FORMAT-ARGS)
  (ERROR 'PARSE-PATHNAME-ERROR
	 ':FORMAT-STRING FORMAT-STRING
	 ':FORMAT-ARGS (COPYLIST FORMAT-ARGS)))

;; Note: COMPONENT is in raw (uncased) form.
(DEFFLAVOR INVALID-PATHNAME-COMPONENT
	(PATHNAME COMPONENT COMPONENT-VALUE COMPONENT-DESCRIPTION (ADDITIONAL-TEXT NIL))
	(PATHNAME-ERROR)
  :GETTABLE-INSTANCE-VARIABLES
  :INITABLE-INSTANCE-VARIABLES)

(DEFMETHOD (:REPORT INVALID-PATHNAME-COMPONENT) (STREAM)
  (LET* ((BASE 10.) (CL:*PRINT-RADIX* NIL)
	 (HOST (SEND PATHNAME :HOST))
	 (SYSTEM-TYPE (SEND HOST :SYSTEM-TYPE)))
    (FORMAT STREAM "~S is an invalid ~A for ~A (~A ~A host)~@[,~% because it is ~A~]."
	    COMPONENT-VALUE COMPONENT-DESCRIPTION HOST
	    (IF (MEMQ SYSTEM-TYPE '(:ITS :IFS :ALTO)) "an" "a")
	    SYSTEM-TYPE ADDITIONAL-TEXT)))

;; One argument: a new component, in raw (uncased) form.
(DEFMETHOD (:PROCEED INVALID-PATHNAME-COMPONENT :NEW-COMPONENT)
	   ;; No, this prompt and read shouldn't be :STRING; you may want to give
	   ;; a list or symbol.
	   ;; [Actually, it should be parsed again, by the right piece of the parser. --RWK]
	   (&OPTIONAL (COMP (PROMPT-AND-READ ':EXPRESSION
					     "Form to use as the ~A instead: "
					     COMPONENT-DESCRIPTION)))
  (VALUES ':NEW-COMPONENT COMP))

(DEFMETHOD (:DOCUMENT-PROCEED-TYPE INVALID-PATHNAME-COMPONENT :NEW-COMPONENT) (STREAM)
  (FORMAT STREAM "Supply a new ~A" COMPONENT-DESCRIPTION))

(DEFFLAVOR UNKNOWN-PATHNAME-HOST (NAME) (PATHNAME-ERROR)
  :INITABLE-INSTANCE-VARIABLES
  :GETTABLE-INSTANCE-VARIABLES)

(DEFMETHOD (:REPORT UNKNOWN-PATHNAME-HOST) (STREAM)
  (FORMAT STREAM "~S is not a known file server host." NAME))

(COMPILE-FLAVOR-METHODS PARSE-PATHNAME-ERROR INVALID-PATHNAME-COMPONENT	UNKNOWN-PATHNAME-HOST)

;; Pathname system initialization

(DEFUN PATHNAME-INITIALIZE ()
  (SETQ *DEFAULT-PATHNAME-DEFAULTS* (MAKE-PATHNAME-DEFAULTS))
  (SETQ LOAD-PATHNAME-DEFAULTS (MAKE-PATHNAME-DEFAULTS))
  ;; The following belongs here, but at the moment PATHNAME-INITIALIZE gets called
  ;; before we even know what our local host is!
  #+IGNORE
  (SETQ CL:*DEFAULT-PATHNAME-DEFAULTS* (DEFAULT-PATHNAME))
  )

(ADD-INITIALIZATION "PATHNAME-INITIALIZE" '(PATHNAME-INITIALIZE) '(:ONCE))

;;; Flush all hosts except for logical and their related physical off the list of
;;; pathname hosts.  Then flush all non-pathname hosts off of defaults alists.
(DEFUN SITE-PATHNAME-PURGE ()
  (LOOP WITH ALL-HOSTS = (LOOP FOR HOST IN *LOGICAL-PATHNAME-HOST-LIST*
			       APPEND (SEND HOST ':ALL-HOSTS))
	FOR ALIST IN *ALL-DEFAULTS-ALISTS*
	DO (LOOP FOR BUCKET IN ALIST
		 FOR (HOST . PATHNAME) = BUCKET
		 DO (UNLESS HOST
		      (SETQ HOST (AND PATHNAME (SEND PATHNAME ':HOST))))
		 WHEN (OR (MEMQ HOST *LOGICAL-PATHNAME-HOST-LIST*)
			  (MEMQ HOST ALL-HOSTS))
		 COLLECT BUCKET INTO NEW-ALIST
		 FINALLY
		 (UNLESS (ASSQ NIL NEW-ALIST)
		   (SETQ NEW-ALIST (NCONC NEW-ALIST (NCONS (CONS NIL (CDAR NEW-ALIST))))))
		 (SETF (CAR ALIST) (CAR NEW-ALIST))
		 (SETF (CDR ALIST) (CDR NEW-ALIST)))

	   FINALLY
	     (CONDITION-CASE (.ERROR.)
		 (SETQ CL:*DEFAULT-PATHNAME-DEFAULTS*	;   FS:*DEFAULT-PATHNAME-DEFAULTS*
		       (IF (AND (VARIABLE-BOUNDP CL:*DEFAULT-PATHNAME-DEFAULTS*)
				CL:*DEFAULT-PATHNAME-DEFAULTS*
				(MEMQ (SEND CL:*DEFAULT-PATHNAME-DEFAULTS* :HOST) ALL-HOSTS))
			   CL:*DEFAULT-PATHNAME-DEFAULTS*
			 (DEFAULT-PATHNAME)))
	       (ERROR (FORMAT ERROR-OUTPUT "Error resetting CL:*DEFAULT-PATHNAME-DEFAULTS*:~@
					    ~~A~~@
					    It will be set to ~A."
			      .ERROR.
			      (SETQ CL:*DEFAULT-PATHNAME-DEFAULTS* (FS:DEFAULT-PATHNAME)))))))


(ADD-INITIALIZATION "Purge pathnames" '(SITE-PATHNAME-PURGE) '(:SITE :NORMAL))

(SI:DEFINE-GC-OPTIMIZATION SITE-PATHNAME-PURGE :LAYERED-SYSTEM-RELEASE
  (:DOCUMENTATION "Remove site-specific pathnames")
  (:BEFORE-FLIP (IGNORE)
    (SITE-PATHNAME-PURGE)))
