 ;;;-*- Mode:LISP; Package:FS; Lowercase:T; base:8; lowercase:yes -*-

;;;
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
;;;

;;;
;;; Global flags and variables 
;;; Look also for the generic file server things in SERVER-UTIL.LISP.
;;;

(defconst *nfile-server-version* 2)		;can be any SEXP
;;; 6/18/85 10:00:02 BSG
;;; Version 2 modifies the token list data stream protocol to use :EOF instead
;;; of top level close-parens.  This is coincidental with the change from :NEW-FILE to :NFILE.


(defconst *nfile-transmitted-error-properties*
	  '(:pathname :new-pathname :operation :directory-pathname))

(defvar *trace-server-enabled* nil)		;trace the file server
(defvar *server-traces* nil)			;by queuing inputs here.
(defvar *nfile-server-dont-answer-logins* nil)	;if non-NIL, reject connections with this msg
(defvar *nfile-server-notification* nil)	;if non-NIL, notify all server with this msg

(defvar *server-command-table* nil)		;Hash table for looking up commands.
(defconst *server-command-table-default-size* 50.)
(defvar *server-property-index-table* nil)	;default value.

;;;
;;; Things bound per server instance
;;;

(defvar *data-channels* nil)			;all non-direct data channel objects
(defvar *direct-channels* nil)			;all direct ones
(defvar *server-is-logged-in*)			;flag that says USER logged in.
(defvar *command-name* nil)			;command keyword of current command
(defvar *tid*)					;transaction ID of current commandn
(defvar *control-stream*)			;connection control stream
(defvar *nfile-server-responded* nil)		;flag that says this command was respdd to
(defvar *nfile-server-local-host*)		;the default host (file system) for requests
(defvar *property-index-table* nil)		;bound per server to not screw up
(defvar *nfile-server-user-version* nil)

;;;
;;; Error flavor definitions, built on stuff in SERVER-UTIL.
;;;

(defflavor file-server-synchronization ()
	   (condition)
  )

(defmethod (dbg:report file-server-synchronization) (stream)
  (format stream "The NEW-FILE Server has signalled a synchronization condition. ~@
		  This is normally an internal condition only.  There is a malfunction ~@
		  if this error appears visibly."))

(defmethod (dbg:proceed file-server-synchronization :proceed) () t)

(defflavor server-no-file-system () (server-error fs:no-file-system))
(defflavor server-not-logged-in () (server-error fs:not-logged-in))
(defflavor server-host-not-available () (server-error fs:host-not-available))
(defflavor server-login-problems () (server-error fs:login-problems))
(defflavor server-invalid-password () (server-error fs:invalid-password))
(Defflavor server-unknown-user () (server-error fs:unknown-user))

(compile-flavor-methods
  file-server-synchronization
  server-no-file-system
  server-not-logged-in
  server-host-not-available
  server-login-problems
  server-invalid-password
  server-unknown-user)

;;;
;;; Structure definitions for data process/channel communication objects
;;; (value of "handle" server-command arguments)
;;;

(defstruct (nfile-server-data-channel :named (:conc-name data-channel-) )
  handle					;File handle, a string
  iotype					;'fs:input or fs:output or fs:direct
  data-proc					;data channel process
  data-stream					;utility file-copying xface to net stream
  sibling					;brother or sister nfile-server-data-channel
  (cell nil)					;command/communication, NIL = idle
  (opening nil)					;open stream, or 'fs:directory
  arg						;random junk communication
  binp						;opening is binary
  dinfo						;dafile count
  server-instance				;server object
  tid						;tid, needed for :DIRECTORY response
  user-id					;we are proxy for this user-id
  user						;we are proxy for this user
  access-cell					;magic kludge for LMFS access right propgtn
  mark-id)					;info to be sent/sought for DC mark.

(defstruct (nfile-server-direct-data-channel :named (:conc-name direct-data-channel-)
					     (:include nfile-server-data-channel))
  output-channel)				;involved output channel

(defselect ((:property nfile-server-data-channel named-structure-invoke))
  (:print-self (ob stream ignore slashp)
    (if slashp
	(printing-random-object (ob stream)
	  (format stream "Data-channel ~A" ob))
	(format stream "~A" (data-channel-handle ob)))))

(defselect ((:property nfile-server-direct-data-channel named-structure-invoke))
  (:print-self (ob stream ignore slashp)
   (if slashp
       (printing-random-object (ob stream)
	 (format stream "Direct-data-channel ~A" ob))
       (format stream "~A" (data-channel-handle ob)))))


;; Borrow from LMFS dumper...
(defmacro do-value-list ((variable . values) &body body)
  (let ((gs (gensym)))
    `(with-stack-list (,gs . ,values)
       (dolist (,variable ,gs)
	 . ,body))))

(defmacro one-but-not-both-nor-neither (v1 v2 command)
  `(progn
     (if (and ,v1 ,v2)
	 (server-protocol-violation
	   ,(format nil "Both ~A and ~A given for ~S?" v1 v2 command)))
     (if (not (or ,v1 ,v2))
	 (server-protocol-violation
	   ,(format nil "Neither ~A nor ~A given for ~S?" v1 v2 command))))) 

(net:define-server :nfile (:medium :byte-stream-with-mark
			   :who-line t
			   :trusted-p t
			   :reject-unless-trusted nil
			   :no-host-in-process-name t	D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");Since we compute it on our own.
0			   :stream (control-stream :token-list t :accept-p nil)
			   :flavor nfile-server-instance))


(defflavor nfile-server-instance
	   ((control-stream nil)
	    (server-user-id server-login-id)
	    (server-user (or (net:find-object-named :user server-login-id nil)
			     (net:find-object-named :user "LISP-MACHINE" nil)))
	    (local-host net:*local-host*)
	    (access-groups nil)
	    (data-channels nil)
	    (direct-channels nil)
	    (property-index-table *server-property-index-table*)
	    (logged-in nil)
	    (user-version 0))
  (neti:byte-stream-server)
  (:gettable-instance-variables control-stream property-index-table))

(defmethod (:user-id nfile-server-instance) ()
  server-user-id)

(defmethod (:server-top-level nfile-server-instance) ()
  (setq control-stream (send self :stream))
  (let ((*server-instance* self)
	(*control-stream* control-stream)
	(user-id server-user-id)
	(si:*user* server-user)
	(*nfile-server-local-host* local-host)
	(lmfs:*access-groups* access-groups)
	(*access-cell* (locf access-groups))
	(*data-channels* data-channels)
	(*direct-channels* direct-channels)
	(*property-index-table* property-index-table)
	(*server-is-logged-in* logged-in)
	(*nfile-server-user-version* user-version))
    (declare (special lmfs:*access-groups* lmfs:*access-permissive* lmfs:*require-login*))
    (si:link-variables (locf *control-stream*) (locf control-stream)
		       (locf user-id) (locf server-user-id)
		       (locf si:*user*) (locf server-user)
		       (locf *nfile-server-local-host*) (locf local-host)
		       (locf lmfs:*access-groups*) *access-cell*
		       (locf *data-channels*) (locf data-channels)
		       (locf *direct-channels*) (locf direct-channels)
		       (locf *property-index-table*) (locf property-index-table)
		       (locf *server-is-logged-in*) (locf logged-in)
		       (locf *nfile-server-user-version*) (locf user-version))
    (let-if (not (send self :trusted-p))
	    ((lmfs:*access-permissive* nil)
	     (lmfs:*require-login* t))
      (nfile-server control-stream))))

(eval-when (compile load eval)
  (defun def-file-server-command-preprocess-descriptors (arglist)
    (if (memq '&aux arglist)
	(loop for x in arglist until (eq x '&aux) collect x)
	arglist)) 
  
  (defun def-file-server-command-process-arglist (arglist)
    (loop with auxpassed = nil
	  for item in arglist
	  if (eq item '&aux) do (setq auxpassed t)	;DO collect the &aux, though.
	  ;; Linearize keys here and now.
	  unless (or (eq item '&key)		;forget that they're keys...
		     (and item (listp item) (eq (third item) 'ignore)))
	  collect (if (and (not (atom item)) (not auxpassed))
		      (car item)		;when data type given, collect only name.
		      item)))			;collect &aux vbls with initializations.
  )

(defmacro def-file-server-command (name arglist &body body)
  `(local-declare ((sys:function-parent ,name def-file-server-command))
     (defun (:property ,name file-server-command)
	    ,(def-file-server-command-process-arglist arglist)
       . ,body)
     (def-file-server-command-1
       ',name
       ',(def-file-server-command-preprocess-descriptors arglist))))


(defun def-file-server-command-1 (name info)
  (if (null *server-command-table*)
      (store-conditional (variable-location *server-command-table*)
			 nil
			 (cl:make-hash-table :test #'cl:equal
					     :size *server-command-table-default-size*)))
  (putprop name info 'nfile-command-info)
  (record-source-file-name name 'def-file-server-command)
  (send *server-command-table* ':put-hash (get-pname name) (cons name info)))

(defun server-parse-request (request)
  (let (tid command-info data)
    (unless request
      (nfile-server-error 'server-protocol-violation "Null request sent!?"))
    (unless (and (listp request) (cdr request) (listp (cdr request)))
      (server-protocol-violation "Request missing transaction ID?"))
    (setq tid (cadr request))
    (unless (and (stringp tid) (plusp (string-length tid)))
      (server-protocol-violation "Illegal transaction ID: ~S" tid))
    (setq *tid* tid)
    (let ((cname (car request)))
      (cond ;;older versions of protocol
	    ((stringp cname)
	     (setq command-info (send *server-command-table* ':get-hash cname))
	     (setq *command-name* (pop command-info)))
	    ((keywordp cname)
	     (setq command-info (get cname 'nfile-command-info))
	     (setq *command-name* cname))
	    (t (server-protocol-violation "Illegal command name: ~S" cname)))
      (unless command-info
	(error 'server-unknown-operation ':operation cname)))

    (setq data (cddr request))
    (prog1
      (loop with stopflag
	    for (item . rest-of-pattern) on command-info
	    with these-are-optional = nil
	    until stopflag
	    nconc
	    (selectq item
	      (&optional
	       (setq these-are-optional t)
	       nil)
	      (&key (prog1 (server-parse-keyword-args rest-of-pattern data)
			   (setq data nil stopflag t)))
	      (t (when (null data)
		   (if these-are-optional (loop-finish))
		   (server-protocol-violation
		     "Required arguments to the ~S command are missing." *command-name*))
		 ;; Don't PASS ignore's, but do waste time parsing them.
		 (let ((value (server-parse-request-datum item nil (pop data))))
		   (and (not (and item (listp item) (eq (third item) 'ignore)))
			(list value))))))
      (if data
	  (server-protocol-violation "Too many arguments were given to the ~S command."
				     *command-name*)))))

(defun server-parse-keyword-args (keywords data &aux len)
  (setq len (length data))
  (if (oddp len)
      (server-protocol-violation "Odd number of keywords and values to ~A." *command-name*))
  ;; Convert keywords to linear value args.
  (loop with kwds-found-bits = 0
	for descriptor in keywords
	as name = (if (atom descriptor) descriptor (car descriptor))
	as data-type = (if (atom descriptor) descriptor (cadr descriptor))
	as value = (loop for (keyword datum) on data by 'cddr
			 as bit first 1 then (ash bit 1)
			 when (string-equal name keyword)
			 return (progn
				  (setq kwds-found-bits (logior bit kwds-found-bits))
				  (server-parse-request-datum name data-type datum)))
	unless (and (listp descriptor) (eq (third descriptor) 'ignore))
	collect value
	finally (unless (= kwds-found-bits (1- (ash 1 (// len 2))))
		  (let* ((bad-name-index (loop for i upfrom 0
					       unless (ldb-test (byte 1 i) kwds-found-bits)
					       return (* 2 i)))
			 (bad-name (nth bad-name-index data)))
		    ;;If it occurs anywhere else, the reason that it wasn't used
		    ;; is that it is DUPLICATED!
		    (loop for (kwd) on data by 'cddr
			  as index upfrom 0 by 2
			  if (and ( index bad-name-index)
				  (string-equal kwd bad-name))
			  do (server-protocol-violation
			       ;; Watch out for the colon below, it makes pseudo-keywords.
			       "Duplicate keyword :~A to ~A." bad-name *command-name*))
		    (server-protocol-violation
		      "Unknown keyword to ~A: :~A" *command-name* bad-name)))))

(defun server-parse-request-datum (pattern data-type datum &aux null-ok)
  (when (and (listp pattern) (eq (cadr pattern) ':optional))
    (setq null-ok t pattern (car pattern)))
  
  (when (null data-type)
    (cond ((listp pattern)
	   (setq data-type (cadr pattern))
	   
	   (when (eq data-type ':list )
	     (unless (or (null datum)		;common lisp needed
			 (listp datum))
	       (server-protocol-violation
		 "A list of values for argument ~S was expected, but not given."
		 (car pattern)))
	     (return-from server-parse-request-datum
	       (loop for x in datum
		     collect (server-parse-request-datum nil (third pattern) x))))
	   
	   (setq pattern (car pattern)))
	  (t (setq data-type pattern))))
  
  (when (eq data-type 'property-pairs)
    (unless (or (null datum)			;common lisp needed
		(listp datum))
      (server-protocol-violation
	"Keyword//value pairs for argument ~S were expected, but not given - ~S"
	pattern datum))
    (or (zerop (mod (length datum) 2))
	(server-protocol-violation
	  "Odd number of items to keyword//value pair argument ~S" pattern))
    (return-from server-parse-request-datum
      (server-parse-request-property-pairs pattern datum)))
  
  (when (and datum (listp datum) (neq data-type ':sexp))
    (server-protocol-violation "A list of values for argument ~S was given, but not expected."
			       pattern))
  
  (if (and (stringp datum) null-ok (zerop (string-length datum)))
      (setq datum nil))
  
  (when (null datum)
    (return-from server-parse-request-datum nil))
  
  (if (and (not (memq data-type '(:integer :sexp)))
	   (numberp datum))
      (server-protocol-violation
	"A number was given for the argument ~S.  A number is not wanted for this argument."
	pattern))
  
  (selectq data-type
    (:sexp datum)				;YESSIR.
    (:integer
     (or (numberp datum)
	 (server-protocol-violation
	   "A number was expected for the argument ~S, but ~S was given."
	   pattern datum))
     datum)
    (:string (or datum ""))
    (:keyword (or (keywordp datum)
		  (server-protocol-violation
		    "A keyword was expected for argument ~S, but ~S was sent." pattern datum))
	      datum)
    (:boolean (selectq datum
		((t nil) datum)
		(t (server-protocol-violation
		     "The values T or NIL are allowed for the argument ~S, not ~S."
		     pattern datum))))
    (:boolkey
     (selectq datum
       ((t nil) datum)
       (t (if (keywordp datum)
	      datum
	      (server-protocol-violation
		"The values T or NIL or a keyword are allowed for the argument ~S, ~
                     not ~S."
		pattern datum)))))
    (pathname
     ;;In QFILE, this merges, "for CFTP".  Here, if it does that,
     ;;it breaks null-type :complete-string.
     (fs:parse-pathname datum *nfile-server-local-host*))
    (input-handle (look-up-file-handle datum 'input))
    (output-handle (look-up-file-handle datum 'output))
    (non-direct-handle (look-up-file-handle datum 'non-direct))
    (direct-handle (look-up-file-handle datum 'direct))
    (handle
     (or (look-up-file-handle datum 'non-direct nil)
	 (look-up-file-handle datum 'direct ':error)))
    (new-non-direct-handle
     (loop for channel in *data-channels*
	   when (string-equal datum (data-channel-handle channel))
	     do (server-protocol-violation "File handle already defined: ~A" channel))
     (make-nfile-server-data-channel handle datum))
    (t (if (keywordp data-type)
	   (ferror "Unknown data-type for ~S:  ~S" pattern data-type))
       datum)))


(defun server-parse-request-property-pairs (pattern datum)
  (loop for (indicator value) on datum by 'cddr
	unless (keywordp indicator)
	do (server-protocol-violation "Invalid indicator name in argument ~S: ~S"
				      pattern indicator)
	collect indicator
	collect (loop for (cvinfo . props-of-this-type) in *nfile-directory-properties*
		      when (memq indicator props-of-this-type)
		      return (funcall (fifth cvinfo) value)
		      finally (return value))))

		
(defun (nfile-server-error compiler:style-checker) (form &aux flavor-form)
  (cond ((null (cdr form))
	 (compiler:warn '(:bad-style t) "NFILE-SERVER-ERROR being called with no flavor"))
	((atom (setq flavor-form (cadr form))))
	((eq (car flavor-form) 'quote)
	 (flavor:check-flavor-name (cadr flavor-form) "NFILE-SERVER-ERROR flavor"))))

(defprop nfile-server-error t :error-reporter)
(defun nfile-server-error (cond &rest format-args)
  (error cond ':report-string (lexpr-funcall #'format nil format-args))) 

(defprop server-protocol-violation t :error-reporter)
(defun server-protocol-violation (&rest args)
  (lexpr-funcall #'nfile-server-error 'server-protocol-violation args))

(defun trace-nfile-server (&optional (onoff t))
  (setq *trace-server-enabled* onoff))
		
(defun report-nfile-server-error (err info)
  (report-file-server-error "NFile"
			    (and *server-instance* (send *server-instance* :foreign-host))
			    err
			    info))

(defun look-up-file-handle (name type &optional (not-found-action ':error))
  (loop for channel in (selectq type
			 ((non-direct input output) *data-channels*)
			 (direct *direct-channels*))
	when (string-equal (data-channel-handle channel) name)
	return (cond ((eq type 'non-direct) channel)
		     ((eq type (data-channel-iotype channel)) channel)
		     (t (server-protocol-violation
			  "File handle ~A is not a ~A handle, which was required."
			  channel type)))
	finally (selectq not-found-action
		  (:create
		   (let ((chan nil))
		     (selectq type
		       (direct
			(push (setq chan
				    (make-nfile-server-direct-data-channel
				      handle name iotype type))
			    *direct-channels*))
		       ((input output)
			(push (setq chan
				    (make-nfile-server-data-channel handle name iotype type))
			      *direct-channels*))
		       (t (ferror "Not legal to ask for create of ~S handle." type)))
		     (return chan)))
		  (nil (return nil))
		  (t (server-protocol-violation
		       "No file handle named ~A has been established." name)))))
						 
(defun handle-get-opening (handle)
  (let ((opening (data-channel-opening handle)))
    (if (null opening)
	(server-protocol-violation "I see no stream open on this handle: ~A" handle))
    (if (symbolp opening)
	(server-protocol-violation "Attempt to use channel with active directory list: ~A"
				   handle))
    opening))



(defun nfile-server (control-stream)
  (when *nfile-server-dont-answer-logins*
    (send control-stream ':reject *nfile-server-dont-answer-logins*)
    (return-from nfile-server nil))
  
  (send control-stream ':accept)
  
  (setf (si:process-name current-process)
	(string-append "NFILE Control ("
		       (send (send control-stream ':foreign-host) ':short-name) ")"))
  
  (login-file-server-machine-if-necessary #'report-nfile-server-error)
  
  (maybe-init-server-property-index-table)
  
  (unwind-protect
      (condition-case-if (not neti:*server-debug-flag*)
			 (err)
	   (catch 'server-connection-disappear
	     ;; If there's a message, send it off right away.
	     (if *nfile-server-notification*
		 (send *server-instance* ':file-server-notification
		       *nfile-server-notification*))
	     (if (and *server-shutdown-message*
		      *server-shutdown-time*
		      (> *server-shutdown-time* (time:get-universal-time)))
		 (send *server-instance* ':file-server-notification
		       (format nil "Server shutdown in ~A - ~A"
			       (time:seconds-to-interval-string
				 (- *server-shutdown-time* (time:get-universal-time)))
			       *server-shutdown-message*)))
	     (nfile-server-command-loop control-stream))
	 ;; Major trap for vanished control connection...
	 ((connection-closed connection-closed-locally connection-lost
			     network-stream-closed bad-connection-state
			     host-stopped-responding))
	 ;;De mortuis nil nisi bonum...
	 (error (report-nfile-server-error err "Server Top Level")))
    ;;UNWIND-PROTECT cleanups
    (cleanup-nfile-server-instance control-stream)))

(defun nfile-server-command-loop (control-stream)
  (let (request *tid* *command-name* *nfile-server-responded* args)
    (error-restart-loop ((error) "File server command level")
      (setq *tid* nil *command-name* nil *nfile-server-responded* nil)
      (catch 'nfile-server-error
	(condition-case-if
	  (not neti:*server-debug-flag*)
	  (err)
	     (condition-bind ((error #'file-server-error-filter))
	      (setq request (nfile-server-read-command control-stream))
	      (if *trace-server-enabled*
		  (without-interrupts (push request *server-traces*)))
	      (setq args (server-parse-request request))
	      (when *nfile-server-dont-answer-logins*
		;; Yes, you can go away, but don't come back!
		(unless (memq *command-name*
			      '(:close :undata-connection :resynchronize-data-connection))
		  (nfile-server-error 'server-host-not-available "~A"
				      *nfile-server-dont-answer-logins*)))
	      ;; Do the actual work..
	      (nfile-server-dispatch *command-name* args))
	  ((file-error pathname-error server-error)
	   (nfile-server-error-response err))
	  ((connection-closed connection-closed-locally connection-lost
	    bad-connection-state network-stream-closed host-stopped-responding) 
	   ;;don't complain...
	   (throw 'server-connection-disappear nil))
	  (error
	    (report-nfile-server-error
	      err (if *command-name*
		      (format nil
			      "Processing ~A, host ~A TID ~A"
			      *command-name*
			      (send *server-instance* :foreign-host)
			      *tid*)
		      (format nil "Reading command from host ~A"
			      (send *server-instance* :foreign-host))))
	    
	    ;;Neither of these should happen, but if they do, we're in for a lot
	    ;;of repeated trouble, so we must blow the connection away.
	    (when (or (typep err 'neti:token-io-unsafe)
		      (typep err 'neti:token-stream-data-error))
	      (send *control-stream*
		    :close-with-reason "Token data stream synchronization error." t)
	      (throw 'server-connection-disappear nil))

	    (condition-case (errr)
		(nfile-server-error 'server-bug "Bug at file server:~%~A" err)
	      (server-bug (nfile-server-error-response errr))))
	  (:no-error
	   (unless *nfile-server-responded*	;unless we already spoke,
	     (nfile-server-response))))))))	;default boring response

(defun nfile-server-read-command (control-stream)
  (loop do
	(condition-case ()
	    (return (send control-stream ':read-token-list))
	  (neti:mark-seen
	    (loop do
		  (condition-case ()
		      ;;Read through for ANOTHER mark and datum, for we cannot clear
		      ;;the now-marked/unsafe input stream without reading another mark.
		      ;;For this, he sent another mark and message.  Although this is
		      ;;robust, it is slightly unclean, but probably less unclean
		      ;;than diddling the stream to make it safe artificially.
		      ;;Feed back the datum after the mark, with a mark before it.
		      (let ((what-i-read (send control-stream ':read-token-list t)))
			;; Check for having gotten out of sync.  We should have
			;; already read through the DUMMY.
			(unless (equal what-i-read "USER-RESYNC-DUMMY")
			  (return
			    (send control-stream ':send-token-list what-i-read t))))
		    (neti:mark-seen)))))))

(defun nfile-server-dispatch (cmd args)
  (cond ((memq cmd '(:login :resynchronize :data-connection :undata-connection))
	 (apply (get cmd 'file-server-command) args))
	((not *server-is-logged-in*)
	 (server-error 'server-not-logged-in
		       "Login is required for the ~S operation." *command-name*))
	(t  (let ((host (send *control-stream* ':foreign-host)))
	      (when (and
		      (not (memq cmd '(:close :filepos :complete :resynchronize
					      :resynchronize-data-connection)))
		      (nfile-log-transaction-for-host-p host))
		(log-untrusted-transaction "NFILE" host cmd args)))
	    (apply (get cmd 'file-server-command) args))))

;; This so you can log other hosts if you want.
;;;****This needs more work if it is to fulfill its intended generality.
(defun nfile-log-transaction-for-host-p (host)
  (if (eq host (send *server-instance* :foreign-host))
      (not (send *server-instance* :trusted-p))
      t))

(defun cleanup-nfile-server-instance (control-stream)
  (neti:logout-server :nfile (send *server-instance* :foreign-host))
  (when control-stream
    (condition-case (err)
	(send control-stream ':close-with-reason
	      (or *nfile-server-dont-answer-logins*
		  "NFILE server termination") t)
      (error (report-nfile-server-error err "Server Top Level close"))))
  ;;Get the Data Connections to cool it, and kill 'em.
  (dolist (handle *data-channels*)		;don't truck with direct openings.
    (condition-case (err)
	(and
	  (cleanup-nfile-data-connection handle)
	  (cleanup-nfile-data-connection (data-channel-sibling handle))
	  ;;Don't remove unless everybody took their hands off.
	  (send (send (data-channel-data-stream handle) ':raw-stream)
		':close-with-reason "Server termination" t))
      (error (report-nfile-server-error err "Server toplevel close data connections"))))
  ;;Only then close what openings there are.
  (do-value-list (list *data-channels* *direct-channels*)
    (dolist (channel list)
      (let ((opening (data-channel-opening channel)))
	(when (and opening (not (symbolp opening)))
	  (condition-case (err)
	      (send opening ':close ':abort)
	    (error (report-nfile-server-error
		     err "Server finish closing remaining openings"))))))))


(defun cleanup-nfile-data-connection (channel)
  (let ((sibling (data-channel-sibling channel)))
    (condition-case (err)
	(unless (or (eq (data-channel-cell channel) ':conn-aborted)
		    (eq (data-channel-cell sibling) ':conn-aborted))
	  (catch 'server-connection-disappear
	    (data-process-command channel 'undata "Cleanup DataProc" 240.)	;4 seconds
	    (setf (data-channel-cell sibling) ':conn-aborted)
	    (when (data-channel-data-proc sibling)
	      (process:process-wakeup (data-channel-data-proc sibling)))
	    (if (eq (data-channel-cell channel) ':conn-aborted)
		(progn
		  (setf (data-channel-cell channel) nil)
		  (when (data-channel-data-proc channel)
		    (process:process-wakeup (data-channel-data-proc channel)))
		  nil)
		(if (data-channel-cell channel)
		    (ferror "Data process failed to relinquish data connection - state is ~S."
			    (data-channel-cell channel))))))
      (error (report-nfile-server-error err "Data connection cleanup") nil)
      (:no-error t))))

(defun maybe-init-server-property-index-table ()
  (when (null *server-property-index-table*)
    ;; No race issue, only one possible answer
    (setq *server-property-index-table*
	  (copylist				;for locality
	    (loop for (nil . props) in fs:*known-directory-properties*
		  append props)))))


(defun nfile-server-response (&rest results)
  (if *nfile-server-responded*
      (ferror "Attempt to reply twice to ~S ~A" *command-name* *tid*))
  (send *control-stream* ':send-token-list
	(list* *command-name*
	       *tid*
	       (and results
		    (encode-object-to-token-list results t))))
  (setq *nfile-server-responded* t))

(defun prestidigitate-instance-vars-out-of-error (error &aux val)
  (loop for keyword in *nfile-transmitted-error-properties*
	when (and (send error ':operation-handled-p keyword)
		  (setq val (send error keyword)))
	nconc (list keyword val)))

(defun nfile-server-error-response (error)
  (if *nfile-server-responded*
      (ferror "Attempt to reply twice to ~S ~A" *command-name* *tid*))

  (nfile-server-send-error *control-stream* nil error nil ':error *tid*)
  (setq *nfile-server-responded* t)
  (throw 'nfile-server-error nil))

(defun nfile-server-send-error (stream mark-p error restartable-p message-type tid)
  (let ((instance-vars
	  ;; For the whole list, NIL is (), but at next level, NIL
	  (append
	    (and restartable-p '(:RESTARTABLE T))
	    (loop for x in (prestidigitate-instance-vars-out-of-error error)
		  collect (encode-object-to-token-list x t)))))
    (with-stack-list (message
		       message-type
		       tid
		       (server-three-letter-code error) 
		       instance-vars
		       (with-output-to-string (stream)
			 (if (send error ':operation-handled-p ':report-without-pathname)
			     (send error ':report-without-pathname stream)
			     (send error ':report stream))))
      (log-server-error-event error "NFILE" (send *server-instance* :foreign-host)
			      "~S" message)
      (send stream ':send-token-list message mark-p))))

(def-file-server-command :login (user (password :optional)
				      &key (file-system :sexp) (user-version :sexp))
  user-version
  (if (or (null user) (zerop (string-length user)))
      (server-protocol-violation "Null user name not permitted"))
  ;; 

  (let* ((user (user-name-from-login-name user))
	 (user-object (net:find-object-named :user user nil))
	 (hd (nfile-server-home-directory user))) ;compute first, in case blows out.
    (nfile-server-set-file-system file-system user password)
    (when user-version
      (setq *nfile-server-user-version* user-version))
    (setq *server-is-logged-in*
	  (progn
	    (when user-object
	      (setq si:*user* user-object))
	    (setq user-id user)))
    (nfile-server-response
      ':name user
      ':homedir-pathname hd
      ':server-version *nfile-server-version*
      ':property-index-table *property-index-table*)))


;;; NFILE-SERVER-SET-FILE-SYSTEM is responsible for establishing a login to 
;;; a particular file system.  
;;;
;;; data of NIL is the local LMFS
;;; data of (:FEP number) is FEP<number>:
;;; data of (:HOST) is the embedded LispM's host's file system
;;; data of (:ISO9660 number) is CDROM<number>: (i.e., the ISO9660 file system
;;;   on the CD-ROM in the drive at SCSI unit <number>)
;;; Nothing else is supported.
;;;
;;; The user and password arguments are used to log the user into the particular
;;; file system.  At this time, all logging in is done against the local LMFS.
;;; FEP file systems check access (if at all) by borrowing facilities of LMFS.
;;; Machines with FEP-FS and no local LMFS cannot be secured.
;;;

(defun nfile-server-set-file-system (data user password)
  (declare (special lmfs:*require-login*))
  (cond ((null net:*system-secured*))		;ignore the password and user
	(password
	 (neti:login-server :nfile (send *server-instance* :foreign-host)
			    user password))
	(lmfs:*require-login*			;if you turn this on without
						;there being a LMFS, you lose.
	 (server-error 'server-invalid-password "Login with password is required.")))
  (cond ((null data))				;local LMFS
	((eq (first data) ':host)
	 (setq *nfile-server-local-host* (add-emb-file-host)))
	((and (eq (car data) ':fep)
	      (numberp (cadr data)))
	 (if (si:disk-unit-mounted-p (cadr data))
	     (setq *nfile-server-local-host* (fs:add-fep-file-host (cadr data)))
	     (server-error 'server-no-file-system "Disk unit ~D is not mounted." (cadr data))))
	((and (eq (car data) :iso9660)
	      (fixp (cadr data)))
	 (setq *nfile-server-local-host*
	       (fs:get-pathname-host (format nil "CDROM~D" (cadr data)))))
	(t (server-error 'server-no-file-system "Cannot access file system ~S." data))))

(def-file-server-command :home-directory (user)
  (nfile-server-response
    (nfile-server-home-directory user)))

(defun nfile-server-home-directory (user)
  (fs:make-pathname ':host si:local-host ':device ':unspecific
		    ':directory
		    (list user)
		    ':name nil ':type nil ':version nil))


;;; Opening files. 

(def-file-server-command :open
			 ((handle :optional) pathname (direction :keyword) (binary-p :boolkey)
			  &key

			  (temporary :boolean ignore) (raw :boolean ignore)
			  (super-image :boolean)
			  (file-type :string) (creator-signature :string)

			  (deleted :boolean) (preserve-dates :boolean)
			  (direct-file-id :string) (estimated-length :integer)
			  (byte-size :integer)
			  (if-exists :keyword) (if-does-not-exist :keyword)
			  &aux opening)
  
  

  (if (and (eq direction ':io)
	   (not direct-file-id))
      (server-protocol-violation "A direct file handle is required for bidirectional open."))

  (unless (eq (null handle)
	      (or (not (null direct-file-id))
		  (not (null (memq direction '(:probe :probe-link :probe-directory))))))
    (server-protocol-violation "Inconsistency of file handle vs. open mode"))
	 
  (cond (direct-file-id
	 (if handle (server-protocol-violation
		      "A handle was supplied for a DIRECT OPEN.  One shouldn't have been."))
	 (setq handle (look-up-file-handle direct-file-id 'direct ':create))
	 (if (data-channel-opening handle)
	     (server-protocol-violation
	       "Direct file handle ~A is still (or already?) in use." handle)))
	
	((null handle))				;probe
	
	(t
	 ;; Keywords versus local package.
	 (unless (string-equal direction (data-channel-iotype handle))
	   (server-protocol-violation
	     "File handle ~A is of the wrong gender for ~A." handle direction))
	 (if (data-channel-opening handle)
	     (server-protocol-violation
	       "File handle ~A is still (or already?) in use." handle))))

  (setq pathname (nfile-server-check-access
		   pathname
		   (selectq direction
		     ((:input :probe-directory :probe-link :probe) #/R)
		     (:output #/C) (otherwise #/M))))
  ;; for the NIL cases of these, the USER side wants to get an error back
  ;; and translate it to NIL over there. Over here, we need to take the error
  ;; condition irregardless.
  (when (and (memq direction '(:io :input :probe :probe-directory :probe-link))
	     (null if-does-not-exist))
    (setq if-does-not-exist ':error))
  (when (null if-exists)
    (setq if-exists ':error))
  (let ((nargs 9))
    (if deleted (incf nargs 2))
    (if preserve-dates (incf nargs 2))
    (if direct-file-id (incf nargs 2))
    (if estimated-length (incf nargs 2))
    (if if-exists (incf nargs 2))
    (if if-does-not-exist (incf nargs 2))
    (if super-image (incf nargs 2))
    (if file-type (incf nargs 2))
    (if creator-signature (incf nargs 2))

    ;;; Calling the instance directly wouldn't be such a bad idea, either.
    (setq
      opening				;compiler bug 10/31/85 13:37:54
      (block nil
	(%start-function-call #'open t nargs nil)
	(%push pathname)
	(%push ':direction)           (%push direction)
	(%push ':characters)	  (%push (if (eq binary-p ':default) binary-p (not binary-p)))
	(%push ':byte-size)	          (%push byte-size)
	(when deleted                 (%push ':deleted)        (%push t))
	(when preserve-dates          (%push ':preserve-dates) (%push t))
	(when direct-file-id          (%push ':direct)         (%push t))
	(when estimated-length        (%push ':estimated-length) (%push estimated-length))
	(when if-exists               (%push ':if-exists)      (%push if-exists))
	(when if-does-not-exist       (%push ':if-does-not-exist) (%push if-does-not-exist))
	(when super-image	      (%push ':super-image) (%push super-image))
	(when file-type               (%push ':file-type) (%push file-type))
	(when creator-signature       (%push ':creator-signature) (%push creator-signature))
	(%push '%return-binary-stream-for-character-file) (%push t)
	(%finish-function-call #'open t nargs nil))))
  
  (cond ((memq direction '(:probe :probe-directory :probe-link))
	 (close opening))
	(t
	 (setf (data-channel-opening handle) opening)	;needed for cleanup, too
	 ;; --- data-channel-binp is something of a joke in the current scheme of things.
	 ;; it reflects the state of the stream we got by calling open up there.
	 ;; in effect, binp NIL just means `byte size is definitely 8, you don't
	 ;; have to check the property'  This is pretty awful, but it works, and there
	 ;; is no point to housecleaning this kludge when we are only going to have
	 ;; to recast it later when we really sort out characters issues.
	 (setf (data-channel-binp handle) (not (send opening ':characters)))
	 (setf (data-channel-tid handle) *tid*)
	 (unless direct-file-id
	   (set-channel-exception handle nil)
	   (when (eq (data-channel-cell handle) ':conn-aborted)
	     (throw 'server-connection-disappear nil))
	   (setf (data-channel-cell handle) (if (eq direction ':input) 'read 'write))
	   (when (data-channel-data-proc handle)
	     (process:process-wakeup (data-channel-data-proc handle))))))
  (nfile-server-open-close-finish-response opening t))


;;; Data connection stuff.

(defun null-content (x) (null (cdr x)))

(def-file-server-command :data-connection ((input-handle new-non-direct-handle)
					   (output-handle new-non-direct-handle))
  (multiple-value-bind (raw-data-stream identifier)
      (condition-case (err)
	   (send *control-stream* ':start-open-auxiliary-stream
		 nil				;active-p
		 ':application-id "NFD"
		 ':stream-options '(:token-list t))
	 (sys:network-error (server-error
			      'server-network-error
			      "Attempt to listen for data connection ~A//~A failed: ~@
				   ~A" input-handle output-handle err)))
    (let ((data-stream (make-instance 'neti:token-list-bidirectional-data-stream
				      :raw-stream raw-data-stream
				      :data-protocol-version
;;;+++Compatibility kludge with old user ends.
				      (or *nfile-server-user-version* 2)))
	  (hostname (send (send *server-instance* :foreign-host) ':short-name)))
      (alter-nfile-server-data-channel
	input-handle iotype 'input data-stream data-stream server-instance *server-instance*)
      (alter-nfile-server-data-channel
	output-handle iotype 'output
	data-stream data-stream server-instance *server-instance*)
      (setf (data-channel-user-id input-handle) user-id)
      (setf (data-channel-user    input-handle) si:*user*)
      ;;moved up from below
      (setf (data-channel-access-cell input-handle) *access-cell*)
      (setf (data-channel-data-proc input-handle)
	    (neti:process-run-function-in-secure-environment
	      #'(lambda ()
		  (nfile-server-data-top-level input-handle))
	      :name
	      (string-append "NFILE In  " (data-channel-handle input-handle)
			     " (" hostname ")")))
      (setf (data-channel-user-id output-handle) user-id)
      (setf (data-channel-user    output-handle) si:*user*)
      ;;moved up from below
      (setf (data-channel-access-cell output-handle) *access-cell*)
      (setf (data-channel-data-proc output-handle)
	    (neti:process-run-function-in-secure-environment
	      #'(lambda ()
		  (nfile-server-data-top-level output-handle))
	      :name
	      (string-append "NFILE Out " (data-channel-handle output-handle)
			     " (" hostname ")")))
      (setf (data-channel-sibling input-handle) output-handle)
      (setf (data-channel-sibling output-handle) input-handle)
      (push input-handle *data-channels*)
      (push output-handle *data-channels*)
      (nfile-server-response identifier))))

(def-file-server-command :undata-connection (input-handle output-handle)
  (unless (eq (data-channel-sibling input-handle) output-handle)
    (server-protocol-violation
      "Handles ~A and ~A are not for the same connection, won't UNDATA either."
      input-handle output-handle))
  (do-value-list (handle input-handle output-handle)
    (data-process-command handle 'undata))
  (do-value-list (handle input-handle output-handle)
    ;; We can't predict which side will be told to undata, so make sure
    ;; that all sides get removed from alldatas.
    (setq *data-channels* (delq handle *data-channels*))
    (send (send (data-channel-data-stream handle) ':raw-stream)
	  ':close-with-reason "Undata" t)))

(defun nfile-server-data-top-level (handle)
  (let ((*server-instance* (data-channel-server-instance handle))
	(lmfs:*access-groups* nil))
    (declare (special *server-instance*
		      lmfs:*access-groups* lmfs:*access-permissive* lmfs:*require-login*))
    (si:link-variables (locf lmfs:*access-groups*) (data-channel-access-cell handle))
    (let-if (not (send *server-instance* :trusted-p))
	    ((lmfs:*access-permissive* nil)
	     (lmfs:*require-login* t))
      (let* ((stream (data-channel-data-stream handle))
	     (user-id (data-channel-user-id handle))
	     (si:*user* (data-channel-user handle))
	     (raw-stream (send stream ':raw-stream)))
	(condition-case (err)
	     (condition-bind ((error #'file-server-error-filter))
	       (if (eq (data-channel-iotype handle) 'output)
		   (send raw-stream ':complete-connection)
		   ;; Don't wait more than 5 minutes for a connection to complete
		   (process:with-process-block-timeout ((* 5 60.) timer)
		     (process:process-block-and-poll-wait-function
		       "Data stream connection"
		       .5
		       #'(lambda () (or (not (null (send raw-stream ':connected-p)))
					(not (process:timer-pending-p timer)))))))
	       (nfile-data-process-command-loop handle stream raw-stream))
	   ((connection-closed network-stream-closed bad-connection-state
			       connection-closed-locally connection-lost
			       host-stopped-responding host-not-responding)
	    (setf (data-channel-cell handle) ':conn-aborted)
	    (when (data-channel-data-proc handle)
	      (process:process-wakeup (data-channel-data-proc handle))))
	   (error (setf (data-channel-cell handle) ':conn-aborted)
		  (ignore-errors (send raw-stream ':close-with-reason
				       "Error encountered by data process" t))
		  (report-nfile-server-error err "Data connection top level")))
	;; Bye now....
	(setf (data-channel-data-proc handle) nil)
	(when (data-channel-data-proc handle)
	  (process:process-wakeup (data-channel-data-proc handle)))))))

(defun nfile-data-process-command-loop (handle stream raw-stream)
  (do () (())
    top
    (process:process-block-and-poll-wait-function
      "Data Conn Cmd"
      .5
      #'(lambda () (not (null (or (data-channel-cell handle)
				  (not (send raw-stream ':connected-p)))))))
    (unless (send raw-stream ':connected-p)
      (setf (data-channel-cell handle) ':conn-aborted)
      (when (data-channel-data-proc handle)
	(process:process-wakeup (data-channel-data-proc handle)))
      (return ':conn-aborted))
    (let ((opening (data-channel-opening handle))
	  cmd)
      (condition-case ()
	  (catch 'async-abort
	    ;; Unspring the beartrap in case we got here without trapping
	    ;; any bears this time.
	    (set-channel-exception handle nil)
	    (selectq (setq cmd (data-channel-cell handle))
	      ((undata :conn-aborted)		;Gute Nacht, O Wesen.
	       (setf (data-channel-cell handle) nil)
	       (when (data-channel-data-proc handle)
		 (process:process-wakeup (data-channel-data-proc handle)))
	       (return nil))
	      
	      (hands-off)
	      
	      ((wsync fpwsync)
	       (send stream ':discard-current-output-buffer)
	       (send raw-stream ':send-token-list
		     (list "RESYNCHRONIZE" (data-channel-mark-id handle)) t)
	       (send raw-stream ':force-output)
	       (when (eq cmd 'fpwsync)		;rol' de ball..
		 (%store-conditional (locf (data-channel-cell handle)) 'fpwsync 'read)
		 (when (data-channel-data-proc handle)
		   (process:process-wakeup (data-channel-data-proc handle)))
		 (go top)))			;and actually do what we tell ourselves!
	      (rsync
	       (read-data-stream-for-resync-message
		 stream (data-channel-mark-id handle))
	       (%store-conditional (locf (data-channel-cell handle)) 'rsync nil)
	       (when (data-channel-data-proc handle)
		   (process:process-wakeup (data-channel-data-proc handle)))
	       (let ((*control-stream* (send *server-instance* :control-stream))
		     (*tid* (data-channel-tid handle))
		     (*nfile-server-responded* nil)
		     (*command-name* ':resynchronize-data-channel))
		 (nfile-server-response))
	       (go top))
	      (directory
	       (nfile-server-data-process-directory handle)
	       ;; This is really dispatching control state...
	       (%store-conditional (locf (data-channel-cell handle)) 'directory nil)
	       (go top)
	       )
	      (write
	       (if (null opening) (ferror "File Server Data Top Level - no opening"))
	       (nfile-server-write-loop handle stream))
	      ((read read-with-count)
	       (if (null opening) (ferror "File Server Data Top Level - No opening."))
	       (nfile-server-read-loop handle stream cmd))
	      (weof
	       (send stream ':eof))		;Thas' what weof stands for..
	      (t (ferror "Bogus communication cell value: ~S"
			 (data-channel-cell handle))))
	    (setf (data-channel-cell handle) nil))
	(file-server-synchronization)))))

;; WRITE files, READ the network
(defun nfile-server-write-loop (handle stream
				  &aux
				  (binp (data-channel-binp handle))
				  (opening (data-channel-opening handle)))
  (send stream ':clear-eof)
  ;; This delightful condition is signalled when an output resync happens, and we
  ;; get wind of it before the control connection does.
  (condition-case ()
      (condition-bind ((fs:file-error #'(lambda (error &rest ignore)
					  (nfile-server-async-error error handle))))
	(if (and binp (> (send opening ':byte-size) 8))
	    (stream-copy-8-to-16 stream opening)
	    (stream-copy-until-eof stream opening))
	(send opening ':force-output))	;for good luck
    (neti:mark-seen)))

;; READ files, WRITE the network.
(defun nfile-server-read-loop (handle stream cmd
				  &aux
				  (binp (data-channel-binp handle))
				  (opening (data-channel-opening handle))
				  )
  (condition-bind ((fs:file-error #'(lambda (error &rest ignore)
				      (nfile-server-async-error error handle))))
    (if (and binp (> (send opening ':byte-size) 8))
	(stream-copy-16-to-8 opening stream)
	(stream-copy-until-eof opening stream))
    (cond ((eq cmd 'read-with-count)
	   (setf (data-channel-opening handle) nil)
	   (send stream ':force-output))
	  (t (send stream ':eof)))))

(defun nfile-server-async-error (error handle)
  (let ((data-stream (data-channel-data-stream handle))
	(celloc (locf (data-channel-cell handle)))
	(cmd (data-channel-cell handle)))
    (when (memq cmd '(read write))
      (%store-conditional celloc cmd 'async-mark))
    
    ;; Send an async error on the appropriate channel to advertise our woes.
    (let ((stream
	    (selectq (data-channel-iotype handle)
	      (input
	       (send data-stream ':force-output)
	       (send data-stream ':raw-stream))
	      (output (send *server-instance* :control-stream)))))
      (nfile-server-send-error
	stream nil error
	(not (null (dbg:proceed-type-p error ':retry-file-error)))
	':async-error (data-channel-handle handle)))
    
    ;; Now wait for the control connection to fix us.
    (process-wait "Async Marked" #'(lambda () (neq (data-channel-cell handle) 'async-mark)))

    (selectq (data-channel-cell handle)
      (continue    (setf (data-channel-cell handle) cmd)
		   (dbg:proceed error ':retry-file-error))
      (async-abort ;; channel gonna go unsafe, no need to flush data now..
       (setf (data-channel-cell handle) nil)
       (throw 'async-abort nil))
      ((undata					;"CFTP" user program closing conn
	 :conn-aborted hands-off)		;jsut get back to main loop
		   (throw 'async-abort nil))
      (otherwise  (ferror "Cell in odd state in async recover - ~S"
			  (data-channel-cell handle))))))

(defun data-process-command (handle &optional flag (whostate "Data Channel Process")
			     timeout mark-id)
  (if (eq (data-channel-cell handle) ':conn-aborted)
      (throw 'server-connection-disappear nil))

  ;; Potential for gubbishing this field, but why should it be using it, anyway?
  (when mark-id
    (setf (data-channel-mark-id handle) mark-id))

  (when flag					;have to goose the data process
    (process::with-no-other-processes
      (setf (data-channel-cell handle) flag)
      (set-channel-exception handle 'file-server-synchronization))
    (when (data-channel-data-proc handle)
      (process:process-wakeup (data-channel-data-proc handle))))

  ;; NIL timeout means no timeout.  But ':return means don't even wait.
  (unless (eq timeout ':return)
    (process:with-process-block-timeout
      ((if timeout (// timeout 60.0) (* 5. 60. 60.)) timer)
      (process:process-block-and-poll-wait-function
	whostate
	.5
	#'(lambda ()
	    (or (not (null (memq (data-channel-cell handle) '(nil :conn-aborted))))
		(not (process:timer-pending-p timer)))))))
  
  (if (eq (data-channel-cell handle) ':conn-aborted)
      (throw 'server-connection-disappear nil)))

(defun set-channel-exception (channel condition)
  (let ((raw-stream (send (data-channel-data-stream channel) ':raw-stream)))
    (when raw-stream				;this goes null
      ;; when undataing the other half of a data connection..
      (send raw-stream
	    (selectq (data-channel-iotype channel)
	      ;; The NET STREAM, not the file!
	      (input ':set-output-exception)
	      (output ':set-input-exception))
	    condition))))

(def-file-server-command :continue (non-direct-handle)
  (handle-get-opening non-direct-handle)		;verify active handle
  (unless (eq (data-channel-cell non-direct-handle) 'async-mark)
    (ferror "Channel ~A not in async marked state." non-direct-handle))
  (%store-conditional (locf (data-channel-cell non-direct-handle)) 'async-mark 'continue))

(def-file-server-command :resynchronize-data-channel (handle (user-identifier :optional))
  (if (eq (data-channel-cell handle) 'async-mark)
      (data-process-command handle 'async-abort))	;get it back to main loop.

  (selectq (data-channel-iotype handle)
    (input
     (if user-identifier
	 (server-protocol-violation
	   ":resynchronize-data-channel - IDENTIFIER given in INPUT case."))
     (setq user-identifier (file-gensym "SDCRSY"))
     (nfile-server-response user-identifier)
     (data-process-command handle 'wsync "Write Sync Mark" ':return user-identifier))
    (output
     (unless user-identifier
       (server-protocol-violation
	 ":resynchronize-data-channel - IDENTIFIER omitted in output case."))
     (setf (data-channel-tid handle) *tid*)
     (setq *nfile-server-responded* t)		;let dataproc answer
     (data-process-command handle 'rsync "Read Synchronization Mark"
			   ':return user-identifier)))
  ;; Then respond.
  (when (and (data-channel-opening handle)
	     (not (symbolp (data-channel-opening handle))))
    (ignore-errors
      (close (data-channel-opening handle) ':abort))
    (setf (data-channel-opening handle) nil)))

(def-file-server-command :close (handle (abort-p :boolean))
  (nfile-server-finish-close t handle abort-p))

(def-file-server-command :finish (handle)
  (nfile-server-finish-close nil handle nil))

(defun nfile-server-finish-close (close-p handle abort-p)
  (let* ((direction (data-channel-iotype handle))
	 (opening (data-channel-opening handle))
	 (direct (eq direction 'direct))
	 ddata)
    (when direct
      (setq ddata handle handle (direct-data-channel-output-channel handle))
      (when handle
	(setq direction 'output)))

    (when handle
      (when (and (eq direction 'output) (not abort-p))
	(process-wait "Write Finish or Abort"
		      #'(lambda ()
			  (memq (data-channel-cell handle)
				'(nil :conn-aborted async-mark)))))

      ;; Normally data-process-command makes this check, but
      ;; we're not using him in the above non-deterministic wait.
      (when (eq (data-channel-cell handle) ':conn-aborted)
	(throw 'server-connection-disappear nil))

      (when (eq (data-channel-cell handle) 'async-mark)
	(if abort-p
	    (data-process-command handle 'async-abort)
	    (error 'server-channel-error-pending
		   ':pathname (send opening ':pathname)
		   ':operation (if close-p ':close ':finish))))
      
      (if (data-channel-cell handle)	;if it finished by itself, no problem
	  ;; Otherwise, get it out, unconditionally.
	  (data-process-command handle 'hands-off "Channel Abort")))

    (cond ((eq opening 'directory)
	   (nfile-server-response))
	  (t
	   
	   (if close-p
	       (send opening ':close (and abort-p ':abort))
	       (send opening ':finish))
				       
	   ;; The channel is our data base for cleanup-time closings.
	   (if (and handle close-p)
	       (setf (data-channel-opening handle) nil))

	   (nfile-server-open-close-finish-response opening nil)))

    (when (and direct close-p)
      (setf (data-channel-opening ddata) nil)	;doesn't make much difference, see next line
      (setq *direct-channels* (delq ddata *direct-channels*)))

    (when (and handle (not close-p))
      (setf (data-channel-cell handle) 'write))))


(defun nfile-server-open-close-finish-response (opening open-magic-props &aux val)
  (let* ((file-element-type (%file-stream-file-element-type opening))
	 (characters (cl:subtypep file-element-type 'cl:character))
	 (byte-size (or (and characters 8.)
			(and (scl:equal-typep file-element-type 'cl:fixnum)
			     32.)
			(and (listp file-element-type)
			     ;; ugh. Dismember a common lisp type by hand.
			     (eq (first file-element-type) 'cl:unsigned-byte)
			     (numberp (second file-element-type))
			     (second file-element-type))
			16.)))    

    (nfile-server-response
      (send opening ':truename)
      (not characters)
      `(
	,@(and (send opening ':author) 
	       `(:author ,(send opening ':author)))
	:creation-date ,(send opening ':creation-date)
	,@(and (setq val (send opening ':send-if-handles ':length))
	       `(:length ,val))
	,@(and open-magic-props
	       (setq val (send opening ':send-if-handles ':read-pointer))
	       `(:pointer-base ,val))
	:byte-size ,byte-size))))

;;; Random commands.

(def-file-server-command :filepos (handle (position :integer) (resync-uid :optional))
  (let* ((direction (data-channel-iotype handle))
	 (opening (handle-get-opening handle)))
    (when (eq direction 'direct)
      (setq handle (direct-data-channel-output-channel handle))
      (when handle
	(setq direction 'output)
	(data-process-command handle nil "Filepos Syn Mark")))	;Wait for it to finish.
    (when handle
      (if (eq (data-channel-cell handle) 'read-with-count)
	  (server-protocol-violation "FILEPOS illegal with counted READ still in progress."))
      (data-process-command handle 'hands-off "Filepos Sync"))

    (unwind-protect
      (progn
	(send opening ':set-pointer position)
	(nfile-server-response)			;special response, needed NOW.
	(when (and handle (eq direction 'input))
	  ;; Although EOF is the obvious possiblity here, we can't really know if
	  ;; data process sent the EOF or not, so use resync mechanism.
	  (data-process-command
	    (prog1 handle (setq handle nil))	;don't let unwind-handler go off...
	    'fpwsync "Filepos Write Sync Mark" ':return resync-uid)))
      ;;If set-pointer fails, restart the data connection anyway, to avoid
      ;;an ill-defined stopped state.  In the normal input-channel case, the
      ;;data connection (cmd FPWSYNC) must do this, so we don't block if the user aborts
      ;;before reading what we want to send....
      (when handle
	(setf (data-channel-cell handle) (if (eq direction 'input) 'read 'write))))))

(def-file-server-command :delete ((handle :optional) (pathname :optional))
  (one-but-not-both-nor-neither handle pathname :delete)
  (send (if pathname
	    (nfile-server-check-access pathname #/M)
	    (handle-get-opening handle))
	':delete))

(def-file-server-command :directory (input-handle pathname
						  (control-kwds :list :keyword)
						  (properties :list :keyword))
  (nfile-server-directory-properties input-handle pathname control-kwds properties
				     ':directory))

(def-file-server-command :multiple-file-plists
			 (input-handle (pathlist :list pathname) (characters :boolkey)
				       (properties :list :keyword))
  (nfile-server-directory-properties input-handle pathlist (list characters)
				     properties ':multiple-file-plists))


(defun nfile-server-directory-properties (input-handle pathname control-kwds attributes
					  command-name)
  (if (data-channel-opening input-handle)
      (server-protocol-violation
	"DIRECTORY//MULTIPLE-FILE-PLISTS: Handle ~A still (already?) in use." input-handle))

  (setf (data-channel-arg input-handle)
	(list
	  command-name
	  ;; Server access vs. multiple-file-plists is a bitch.
	  (if (eq command-name ':multiple-file-plists)
	      pathname				;really a pathlist
	      (nfile-server-check-access pathname #/L))
	  control-kwds
	  attributes
	  (send *server-instance* :property-index-table)))

  (setf (data-channel-tid input-handle) *tid*)
  (setf (data-channel-opening input-handle) 'directory)	;make close work
  (set-channel-exception input-handle nil)
  (setf (data-channel-cell input-handle) 'directory)
  (setq *nfile-server-responded* t))		;let dataproc answer

(defun nfile-server-data-process-directory (handle)
  (destructuring-bind (*command-name* actor control-kwds properties prop-table)
		      (data-channel-arg handle)
    ;; Setup pseudo-control-process environment.
    (let ((*control-stream* (send *server-instance* :control-stream))
	  (*tid* (data-channel-tid handle))
	  (*nfile-server-responded* nil)
	  (stream (data-channel-data-stream handle))
	  dirlist)
      (catch 'nfile-server-error
	(unwind-protect
	  (progn
	    (condition-case (error)
		(setq dirlist
		      (selectq *command-name*
			(:directory
			 (lexpr-funcall #'fs:directory-list actor
					(remove :noerror control-kwds))) ;let user side return the error object
			(:multiple-file-plists
			 (nfile-server-multiple-file-plists actor control-kwds properties))))
	      (fs:file-error
		(nfile-server-error-response error)))	;will bomb out.
	    
	    (nfile-server-response)
	    
	    (when (eq *command-name* :directory)
	      (when (null (caar dirlist))
		(setf (cdar dirlist) (copylist (cdar dirlist)))))

	    (nfile-server-process-directory-lists dirlist prop-table)
	    
	    properties				;someday pass in for selective list..
	    
	    (send (send stream ':raw-stream) ':send-token-list dirlist))
	  ;; No EOF needed.
	  (setf (data-channel-opening handle) nil))))))

(defun nfile-server-process-directory-lists (dirlist prop-table)
  (loop for node in dirlist
	when node				;mfplists returns null conses..
	do (unless (stringp (car node))		;we may have already done this one...
	     (rplaca node (and (car node) (send (car node) ':string-for-host))))
	   (rplacd node (nfile-convert-property-list-to-tokens (cdr node))))
  (loop for node in dirlist
	do (loop for ptr on (cdr node) by 'cddr
		 for (ind) = ptr
		 as index = (find-position-in-list ind prop-table)
		 when index do (rplaca ptr index))))

(defun nfile-server-multiple-file-plists (pathnames control attributes)
  (setq attributes (si:eliminate-duplicates attributes))
  ;; Also selects clause below with no attributes...
  (cond ((loop for att in attributes always (memq att '(:creation-date :length)))
	 ;; "Today's" Lispm operation will do...
	 (loop with nresult = (fs:multiple-file-plists pathnames
						       ':characters (car control))
	       ;; Contract is to return in the order given.
	       for pathname in pathnames
	       as element = (or (assq pathname nresult)
				(ferror "Multiple file plists didn't return info for ~S"
					pathname))
	       collect (and (cdr element)
			    (rplaca element
				    (or (get element ':truename)
					(ferror "Multiple file plists didn't return ~
					            truename for ~S" pathname))))
		 into plists
	       finally (return (progn (loop for pl in plists do (si:nremprop pl :truename))
				       plists))))
	
	;; *****I don't know the contract of "LENGTH" vs binary files here.
	(t (loop for pathname in pathnames
		 as plist = (condition-case ()
				(fs:file-properties pathname)
			      (fs:file-error nil))
		 collect
		 (and plist
		      `(,(car plist)
			,@ (loop for (ind val) on (cdr plist) by 'cddr	;i used to
				 when (memq ind attributes)	;               tv:doplist
				 nconc `(,ind ,val))
			,@ (if (memq ':characters attributes)
			       `(:characters ,(not (get plist ':binary))))))))))

(def-file-server-command :properties ((handle :optional) pathname
				      (control-kwds :list :keyword)
				      (properties :list :keyword))
  
  properties
  control-kwds

  (one-but-not-both-nor-neither handle pathname :PROPERTIES)

  (multiple-value-bind
    (proplist changeables)
      (send (if handle
		(handle-get-opening handle)
		(nfile-server-check-access pathname #/L))
	    ':properties)
    (with-stack-list (result-list proplist)
      (nfile-server-process-directory-lists result-list *property-index-table*))
    (nfile-server-response proplist changeables)))


	      
(def-file-server-command :change-properties
			 ((handle :optional) (pathname :optional) property-pairs)
  (one-but-not-both-nor-neither handle pathname :change-properties)
  (let ((actor (or pathname (handle-get-opening handle))))
    (nfile-server-check-access (or pathname (send actor :truename)) #/M)
    (lexpr-send actor :change-properties t property-pairs)))

(def-file-server-command :rename ((handle :optional) (pathname :optional)
				  (to-pathname pathname))
  
  (one-but-not-both-nor-neither handle pathname :rename)
  
  (if (null (send to-pathname ':version))
      (setq to-pathname (send to-pathname ':new-version ':newest)))

  (multiple-value-bind (from to)
      (cond (pathname
	     (or (send pathname ':version)
		 (setq pathname (send pathname':new-version ':newest)))
	     
	     (send (nfile-server-check-access pathname #/M)
		   ':rename
		   (nfile-server-check-access to-pathname #/C)))
	    (t					;rename while open
	     (let ((opening (handle-get-opening handle)))
	       (nfile-server-check-access (send opening ':truename) #/M)
	       (send opening ':rename (nfile-server-check-access to-pathname #/C)))))
    
    (if (and (not (null from))
	     (not (null to)))
	(nfile-server-response from to))))		;otherwise, normal response will do.
	       
(def-file-server-command :expunge (pathname)
  (nfile-server-response
    (send (nfile-server-check-access pathname #/M) ':expunge)))

(def-file-server-command :create-directory (pathname property-pairs)
  property-pairs				;Being worked on ***********
  (nfile-server-response
    (send (nfile-server-check-access pathname #/M) ':create-directory)))

(def-file-server-command :create-link (pathname (target pathname) property-pairs)
  property-pairs
  (unless (send *server-instance* :trusted-p)
    (error 'server-access-error
	   :pathname pathname
	   ':report-string "Link creation not allowed from unprivileged host."))
  (nfile-server-response
    (send pathname ':create-link target)))

(def-file-server-command :complete
			 (string pathname &key
				 (direction :keyword) (new-ok :boolean) (deleted :boolean))
  (unless (send *server-instance* :trusted-p)
    (error 'server-access-error
	   :pathname pathname
	   ':report-string "Completion not allowed from unprivileged host."))
  (multiple-value-bind (result success)
        (send pathname ':complete-string string 
	  (list*
	    (if (eq direction ':output) ':write ':read)
	    (if new-ok ':new-ok ':old)
	    (if deleted '(:deleted))))
    (nfile-server-response result success)))


(def-file-server-command :read (direct-handle input-handle (count :integer)
					      &key (filepos :integer))
    (unless (plusp count)
      (server-protocol-violation "Non-positive count in counted READ."))
    (when filepos
      (unless ( filepos 0)
	(server-protocol-violation "Negative file position in counted READ.")))

    (let ((opening (handle-get-opening direct-handle)))
      (send opening ':read-bytes count filepos)
      (setf (data-channel-opening input-handle) opening)
      (setf (data-channel-binp input-handle) (data-channel-binp direct-handle))
      (setf (data-channel-tid input-handle) (data-channel-tid direct-handle))
      (setf (data-channel-dinfo input-handle) count)
      (setf (data-channel-cell input-handle) 'read-with-count)))

(def-file-server-command :abort (input-handle)
  (if (eq (data-channel-cell input-handle) 'async-mark)
      (data-process-command input-handle 'async-abort))
  (if (data-channel-cell input-handle)	;if it finished by itself, no problem
      ;; Otherwise, get it out, unconditionally.
      (data-process-command input-handle 'hands-off "Channel Direct Read Abort"))
  (setf (data-channel-opening input-handle) nil))

(def-file-server-command :direct-output (direct-handle (output-handle :optional))
    (cond (output-handle				;Binding
	   (setf (data-channel-opening output-handle) (data-channel-opening direct-handle))
	   (setf (data-channel-binp output-handle) (data-channel-binp direct-handle))
	   (setf (data-channel-tid output-handle) (data-channel-tid direct-handle))
	   (setf (direct-data-channel-output-channel direct-handle) output-handle)
	   (setf (data-channel-cell output-handle) 'write))
	  (t					;Unbinding
	   (setq output-handle
		 (or (direct-data-channel-output-channel direct-handle)
		     (server-protocol-violation "No output handle in ~A" direct-handle)))
	   (if (eq (data-channel-cell output-handle) 'async-mark)
	       (data-process-command output-handle 'async-abort))
	   (data-process-command output-handle nil "Write Finish")
	   (send (data-channel-opening output-handle) ':force-output)
	   (setf (direct-data-channel-output-channel direct-handle) nil) 
	   (setf (data-channel-opening output-handle) nil))))


(compiler:function-defined 'lmfs:add-capability-raw)
(compiler:function-defined 'lmfs:check-and-err-password)
(compiler:function-defined 'lmfs:remove-capability-raw)

;;;--- correct error if not logged in.
(def-file-server-command :enable-capabilities ((capability :string) &optional password)
  ;;Don't send messages to the local access path, for they prompt for the password.
  (lmfs:add-capability-raw (lmfs:check-and-err-password *server-is-logged-in*
							capability password))
  (nfile-server-response `(,capability "T")))

(def-file-server-command :disable-capabilities ((capability :string))
  ;;Don't send messages to the local access path, for they prompt for the password.
  (lmfs:remove-capability-raw capability)
  (nfile-server-response `(,capability nil)))	;nil will be received as ().


(defmethod (:file-server-notification nfile-server-instance) (message)
  (condition-case ()
      (progn
	;; We should never be in a state where token output is unsafe.  Unless, of course,
	;; somebody aborts this, or the connection has already been aborted. Doesn't seem like
	;; server-initiated resync should be necessary just-in-case somebody aborts *this*
	;; function.  With the new server system, we'll allocate a cell, and effectively queue
	;; it, solving the problem, most of the time.  Just in case, we'll catch the error.
	(send control-stream ':send-token-list `(:notification "" ,message))
	(send control-stream ':force-output))
    ((sys:bad-connection-state neti:token-io-unsafe))))

(defmethod (:file-server-shutdown nfile-server-instance) (&optional
							   (reason "File Server Shutdown"))
  (condition-case ()
      (send (send self ':stream) ':close-with-reason reason t)
    (sys:bad-connection-state)))

(defmethod (:peek nfile-server-instance) ()
  (list '()
	(tv:scroll-maintain-list
	  #'(lambda () 
	      ;; used to look like this
	      ;;	(let ((l (list local-host)))
	      ;;        (and
	      ;;          (neq local-host net:local-host)
	      ;;          (rplaca l local-host)))
	      ;; blech!
	      (if (neq local-host net:*local-host*)
		  (list local-host)
		  nil))
	  #'(lambda (host)
	      (let ((info (send-if-handles host ':peek-server-info)))
		(when info
		  (tv:scroll-parse-item
		    (string-append "    " (cl:apply #'format nil info)))))))
	(tv:scroll-parse-item
	  "    User: "
	  `(:function ,#'(lambda () server-user-id) nil 15.))	    
	(tv:scroll-maintain-list
	  #'(lambda () data-channels)
	  #'nfile-peek-data-channel)
	(tv:scroll-maintain-list
	  #'(lambda () direct-channels)
	  #'(lambda (channel)
	      (list '()
		    (tv:scroll-parse-item
		      "      "
		      "Direct File Handle  "
		      (data-channel-handle channel)
		      `(:function ,#'(lambda ()
				       (let ((ochan
					       (direct-data-channel-output-channel channel)))
					 (if ochan
					     (string-append
					       ", Output Handle "
					       (data-channel-handle ochan))
					     "")))))
		    (let ((op (data-channel-opening channel)))
		      (if op (send op ':peek-file-system 8)
			  (tv:scroll-parse-item
			    "No opening; type S for more up-to-date info."))))))))

(defun nfile-server-dbg (&optional host)
  (if host (setq host (net:parse-host host)))
  (loop for server in net:*active-servers*
	thereis (send server :send-if-handles :nfile-debug host))		    
  'nfile-server-dbg)

(defmethod (:nfile-debug nfile-server-instance) (&optional host)
  (if (if host
	  (eq host (send self :foreign-host))
	  (fquery nil "~A in ~S on ~A (~A)? "
		(send self :foreign-host)
		(send neti:process :whostate)
		control-stream
		(if (send control-stream ':connected-p)
		    "Connected" "Disconnected")))
      (cond ((fquery nil "Dbg the control process? ")
	     (dbg neti:process)
	     t)
	    (t (loop for chan in data-channels
		     as proc = (data-channel-data-proc chan)
		     when  (fquery nil "~A, state ~A, process in ~S. Dbg? "
				   chan
				   (or (data-channel-cell chan) "Idle")
				   (send proc ':whostate))
		       return (progn (dbg proc) t))))))


(defun nfile-peek-data-channel (handle)
  (list ()
	(tv:scroll-parse-item 
	  "      "
	  `(:mouse
	    (nil :kbd (send :process-menu ,(data-channel-data-proc handle))
		 :documentation
		 "Menu of useful things to do to this process.")
	    :function
	    ,#'(lambda () (let ((p (data-channel-data-proc handle)))
			    (if p (process-name p) "No process"))))
	  " ("
	  `(:function ,#'(lambda ()
			   (let ((p (data-channel-data-proc handle)))
			     (if p (tv:peek-process-whostate p) "vanished"))))
	  "), sibling "
	  (data-channel-handle (data-channel-sibling handle))
	  " cmd: "
	  `(:mouse
	    (nil :funcall-with-self
		 ,#'(lambda (peek) (send peek :process-run-fs-menu
					 ':nfile-server-channel-peek handle))
		 :documentation
		 "Menu of useful things to do to this channel.")
	    :function ,#'(lambda () (or (data-channel-cell handle) "(Idle)"))))
	(tv:scroll-maintain-list
	  #'(lambda () (list (data-channel-opening handle)))
	  #'(lambda (opening)
	      (cond ((null opening) nil)
		    ((eq opening 'directory)
		     (tv:scroll-parse-item "     In DIRECTORY state."))
		    (t (send opening ':peek-file-system 8)))))))


#| not yet converted for NFILE, no exact equivalent....

    (list '(:pre-process-function nfile-data-server-preprocess)
		     (and (neq (data-channel-iotype data) 'direct)
			  (tv:scroll-parse-item
			    ':leader (list nil nil nil nil nil nil)
			    "      Data Connection: "
			    `(:mouse-item
			      (nil :kbd (send :server-connection-menu
					      ,chaos:*local-chaosnet*	;sigh
					      ,conn tv:item)
				   :documentation
				   "Menu of useful things to do to data connection")
			      :string ,(format nil "~S" conn))))
		     nil
		     (nfile-peek-data-process-half data)
		     (and sibdata (nfile-peek-data-process-half sibdata)))

(defun nfile-data-server-preprocess (list-item)
  (let ((line-item (second list-item)))
    (if line-item				;Directs don't have it
	(let* ((wanted (array-leader line-item (+ 4 tv:scroll-item-leader-offset)))
	       (got (array-leader line-item (+ 5 tv:scroll-item-leader-offset))))
	  (cond ((null wanted)
		 (store-array-leader nil line-item (+ 5 tv:scroll-item-leader-offset))
		 (setf (third list-item) nil))
		((eq wanted got))
		(t
		 (setf (third list-item) (chaos:peek-chaos-conn wanted))
		 (store-array-leader wanted line-item
				     (+ 5 tv:scroll-item-leader-offset))))))))
  |#

(defun nfile-server-check-access (path required)
  (if (send *server-instance* :trusted-p)
      path
      (file-server-check-access path required)))


(compile-flavor-methods nfile-server-instance)

;;; For REORDER-MEMORY
(defun nfile-symbols ()
  (cl:delete-duplicates
    (append
      ;; Keywords used as arguments to OPEN
      '(:input :output :io :probe :probe-link :probe-directory
	:default :error :create
	:new-version :rename :rename-and-delete :overwrite :append :supersede)
      (loop for (nil . keywords) in fs:*known-directory-properties*
	    append keywords)
      (loop for x being the hash-elements of *server-command-table*
	    collect (car x)
	    append (loop for (parameter) in (cdr (memq '&key (cdr x)))
			 collect (intern (string parameter) pkg-keyword-package))))))
