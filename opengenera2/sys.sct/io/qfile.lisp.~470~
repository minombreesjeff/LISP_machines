;;; -*- Mode: LISP; Package: FILE-SYSTEM; Base: 8 -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; Some remaining crocks:
;;; Why not just get an error in DATA-CONNECTION rather than having to know number foreign
;;; host supports?

(DEFCONST %FILE-CHARACTER-OPCODE CHAOS:DAT-OP)
(DEFCONST %FILE-BINARY-OPCODE (LOGIOR CHAOS:DAT-OP 100))
(DEFCONST %FILE-COMMAND-OPCODE CHAOS:DAT-OP)
(DEFCONST %FILE-SYNCHRONOUS-MARK-OPCODE (1+ CHAOS:DAT-OP))
(DEFCONST %FILE-ASYNCHRONOUS-MARK-OPCODE (+ CHAOS:DAT-OP 2))
(DEFCONST %FILE-NOTIFICATION-OPCODE (+ CHAOS:DAT-OP 3))
(DEFCONST %FILE-EOF-OPCODE CHAOS:EOF-OP)

(DEFVAR *FILE-DATA-WINDOW-SIZE* 15)

;;; A file server host.  In the HOST slot of a pathname.
(DEFFLAVOR QFILE-ACCESS-PATH
	((HOST-UNITS NIL))			;List of active HOST-UNIT's
	(FONT-ENCAPSULATING-ACCESS-PATH-MIXIN
	 DIRECTORY-STREAM-FILE-ACCESS-PATH-MIXIN USER-FILE-ACCESS-PATH)
  (:REQUIRED-METHODS :MAX-DATA-CONNECTIONS :HSNAME-INFORMATION)
  (:GETTABLE-INSTANCE-VARIABLES HOST-UNITS))

(DEFINE-FILE-PROTOCOL :QFILE (:CHAOS)
  (:DESIRABILITY .75)
  (:ACCESS-PATH-FLAVOR (HOST)
   (SELECTQ (SEND HOST ':SYSTEM-TYPE)
     (:ITS 'ITS-QFILE-ACCESS-PATH)
     (:TOPS-20 'TOPS20-QFILE-ACCESS-PATH)
     (:TENEX 'TENEX-QFILE-ACCESS-PATH)
     (:LISPM 'LMFS-QFILE-ACCESS-PATH)
     (OTHERWISE 'NORMAL-QFILE-ACCESS-PATH))))

;;; One HOST-UNIT is associated with each control connection
(DEFFLAVOR HOST-UNIT
	(ACCESS-PATH				;QFILE-ACCESS-PATH
	 (CONTROL-CONNECTION NIL)		;Control connection for this host
	 (CONTROL-CONNECTION-TOUCHED (TIME))	;Last time the control connection was used.
	 (DATA-CONNECTIONS NIL)			;List of DATA-CONNECTION's
	 MAX-DATA-CONNECTIONS			;Maximum number of data connections
	 (LOCK (PROCESS:MAKE-LOCK "Host Unit Lock" :RECURSIVE T))	;Lock to insure no timing screws
	 SERVICE-ACCESS-PATH			;How to make connection (not used currently)
	 )
	()
  :ORDERED-INSTANCE-VARIABLES
  :READABLE-INSTANCE-VARIABLES
  (:WRITABLE-INSTANCE-VARIABLES CONTROL-CONNECTION DATA-CONNECTIONS)
  (:INITABLE-INSTANCE-VARIABLES ACCESS-PATH SERVICE-ACCESS-PATH))

;;; A DATA-CONNECTION is associated with each data connection.
;;; The two directions in the connection itself are used independently.
(DEFSTRUCT (DATA-CONNECTION :LIST*
			    (:CONC-NAME DATA-)
			    (:CONSTRUCTOR MAKE-DATA-CONNECTION
					  (CONNECTION INPUT-HANDLE OUTPUT-HANDLE)))
  CONNECTION					;The chaos connection
  (TOUCHED (TIME))				;Last time used in either direction
  INPUT-HANDLE
  OUTPUT-HANDLE
  (STREAM-LIST (LIST ':INPUT NIL ':OUTPUT NIL))
  )

(DEFSUBST DATA-HANDLE (DATA-CONNECTION DIRECTION)
  (SELECTQ DIRECTION
    (:INPUT (DATA-INPUT-HANDLE DATA-CONNECTION))
    (:OUTPUT (DATA-OUTPUT-HANDLE DATA-CONNECTION))))

(DEFSUBST DATA-STREAM (DATA-CONNECTION DIRECTION)
  (CADR (MEMQ DIRECTION (DATA-STREAM-LIST DATA-CONNECTION))))

(DEFMETHOD (MAKE-INSTANCE HOST-UNIT) (&REST IGNORE)
  (SETQ MAX-DATA-CONNECTIONS (SEND ACCESS-PATH ':MAX-DATA-CONNECTIONS)))

;;; Lock a host unit around BODY
(DEFMACRO LOCK-HOST-UNIT ((HOST-UNIT) &BODY BODY)
  `(PROCESS:WITH-LOCK ((HOST-UNIT-LOCK ,HOST-UNIT))
     ,@BODY))

(DEFMETHOD (MAKE-INSTANCE QFILE-ACCESS-PATH) (&REST IGNORE)
  (SEND SELF :GET-HOST-UNIT))

;;; Sent when booting, forget all active connections, reset all HOST-UNIT's.
(DEFMETHOD (:RESET QFILE-ACCESS-PATH) ()
  (DOLIST (UNIT HOST-UNITS)
    (FUNCALL UNIT ':RESET))
  (UNREGISTER-FOR-FILE-CONNECTION-SCAVENGER SELF))

(DEFMETHOD (:RESET HOST-UNIT) (&OPTIONAL DONT-UNLOCK-LOCK-P)
  (COND (CONTROL-CONNECTION
	 (CHAOS:REMOVE-CONN CONTROL-CONNECTION)
	 (SETQ CONTROL-CONNECTION NIL)))
  (DO ((DATA-CONNS DATA-CONNECTIONS (CDR DATA-CONNS))
       (DATA-CONN))
      ((NULL DATA-CONNS)
       (SETQ DATA-CONNECTIONS NIL))
    (SETQ DATA-CONN (CAR DATA-CONNS))
    (DO ((LIST (DATA-STREAM-LIST DATA-CONN) (CDDR LIST))
	 (STREAM))
	((NULL LIST))
      (AND (NOT (SYMBOLP (SETQ STREAM (CADR LIST))))
	   (FUNCALL STREAM ':SET-STATUS ':CLOSED)))
    (CHAOS:REMOVE-CONN (DATA-CONNECTION DATA-CONN)))
  (UNLESS DONT-UNLOCK-LOCK-P
    (PROCESS:RESET-LOCK LOCK)))

;;; This also frees up any slots marked as open
(DEFMETHOD (:CLOSE-ALL-FILES QFILE-ACCESS-PATH) (&KEY (VERBOSE T)
						      (QUERY-EACH NIL)
						      (MODE :ABORT)
						 &AUX THINGS-CLOSED)
  (DOLIST (UNIT HOST-UNITS) 
    (DOLIST (DATA-CONN (HOST-UNIT-DATA-CONNECTIONS UNIT))
      (DO ((LIST (DATA-STREAM-LIST DATA-CONN) (CDDR LIST)))
	  ((NULL LIST))
	(LET ((STREAM (CADR LIST)))
	  (COND ((NULL STREAM))
		((EQ STREAM T)
		 (SETF (CADR LIST) NIL))
		(T
		 (SETQ THINGS-CLOSED
		       (NCONC (SI:CLOSE-OPEN-FILE STREAM
						  :MODE MODE
						  :QUERY QUERY-EACH
						  :VERBOSE VERBOSE)
			      THINGS-CLOSED))))))))
  THINGS-CLOSED)

(DEFMETHOD (:OPEN-STREAMS QFILE-ACCESS-PATH) (&AUX STREAMS)
  (DOLIST (UNIT HOST-UNITS) 
    (DOLIST (DATA-CONN (HOST-UNIT-DATA-CONNECTIONS UNIT))
      (DO LIST (DATA-STREAM-LIST DATA-CONN) (CDDR LIST) (NULL LIST)
	(LET ((STREAM (CADR LIST)))
	  (OR (SYMBOLP STREAM)
	      (PUSH STREAM STREAMS))))))
  STREAMS)


;;; Number is the protocol version number
(DEFCONST *FILE-CONTACT-NAME* "FILE 1")
(DEFCONST *FILE-CONTROL-WINDOW-SIZE* 5)

;; Verify that connection is still open
(DEFMETHOD (:TEST-CONTROL-CONNECTION HOST-UNIT) ()
  (AND CONTROL-CONNECTION
       (EQ (CHAOS:STATE CONTROL-CONNECTION) 'CHAOS:OPEN-STATE)
       (LOOP FOR DATA-CONN IN DATA-CONNECTIONS
	     ALWAYS (EQ (CHAOS:STATE (DATA-CONNECTION DATA-CONN))
			'CHAOS:OPEN-STATE))))

;;; Check that connection hasn't gone away, making a new one if necessary
(DEFMETHOD (:VALIDATE-CONTROL-CONNECTION HOST-UNIT) (&OPTIONAL NO-ERROR-P)
  (LOCK-HOST-UNIT (SELF)
    (SETQ CONTROL-CONNECTION-TOUCHED (TIME))
    (COND ((SEND SELF ':TEST-CONTROL-CONNECTION)
	   T)
	  (T
	   (SEND SELF ':RESET T)	;Arg of T means don't unlock lock
	   (DO (CONN) (NIL)
	     (CONDITION-CASE-IF NO-ERROR-P ()
		 (SETQ CONN
		       (CHAOS:CONNECT (SEND ACCESS-PATH ':HOST)
				      *FILE-CONTACT-NAME* *FILE-CONTROL-WINDOW-SIZE*))
	       (CONNECTION-ERROR
		(RETURN NIL))
	       (:NO-ERROR
		(SETF (CHAOS:INTERRUPT-FUNCTION CONN) (LET-CLOSED ((HOST-UNIT SELF))
							'HOST-CHAOS-INTERRUPT-FUNCTION))
		(SETQ CONTROL-CONNECTION CONN)
		(FS:REGISTER-FOR-FILE-CONNECTION-SCAVENGER
		  ACCESS-PATH #'(LAMBDA () (SEND ACCESS-PATH :SCAVENGE)))
		(SEND ACCESS-PATH ':LOGIN-UNIT SELF T)
		(RETURN T))))))))

;;; Transaction management
(DEFSTRUCT (FILE-TRANSACTION-ID :LIST :CONC-NAME
				(:CONSTRUCTOR MAKE-FILE-TRANSACTION-ID-INTERNAL
					      (ID SIMPLE-P)))
  ID
  SIMPLE-P
  (PKT NIL))

(DEFUN FILE-MAKE-TRANSACTION-ID (&OPTIONAL (SIMPLE-P NIL) &AUX ID)
  (WITHOUT-INTERRUPTS
    (SETQ ID (FILE-GENSYM "T"))
    (PUSH (MAKE-FILE-TRANSACTION-ID-INTERNAL ID SIMPLE-P) *FILE-PENDING-TRANSACTIONS*))
  ID)

;;; only called by the next two functions
(DEFUN ABORT-PENDING-FILE-TRANSACTION-ID (ID &AUX PKT)
  (WITHOUT-INTERRUPTS
    (SETQ PKT (FILE-TRANSACTION-ID-PKT ID))
    ;; if there is a packet, then the transaction was actually
    ;; completed while we were trying to abort.  Else, mark the
    ;; transaction as aborted so the interrupt function doesn't think
    ;; there was a protocol violation.
    (COND (PKT (SETQ *FILE-PENDING-TRANSACTIONS*
		     (DELQ ID *FILE-PENDING-TRANSACTIONS*))
	       (CHAOS:RETURN-PKT PKT))
	  (T (SETF (FILE-TRANSACTION-ID-PKT ID) :ABORTED)))))

(DEFUN ABORT-PENDING-FILE-TRANSACTION (TID &AUX ID)
  (WITHOUT-INTERRUPTS
    (WHEN (SETQ ID (ASSOC TID *FILE-PENDING-TRANSACTIONS*))
      (ABORT-PENDING-FILE-TRANSACTION-ID ID))))

;;; Wait for a transaction to complete.  Should not be called if the transaction is simple.
(DEFUN FILE-WAIT-FOR-TRANSACTION (TID &OPTIONAL CONN (WHOSTATE "File Transaction") &AUX ID)
  (WITHOUT-INTERRUPTS				;this actually works!
    (UNWIND-PROTECT				;abort the ID on error or abort
      (IF (NULL (SETQ ID (ASSOC TID *FILE-PENDING-TRANSACTIONS*)))
	  (FERROR "Transaction ID ~A not found on pending list" TID)
	  (PROCESS-WAIT WHOSTATE #'(LAMBDA (ID CONN)
				     (OR (FILE-TRANSACTION-ID-PKT ID)
					 (NEQ (CHAOS:STATE CONN) 'CHAOS:OPEN-STATE)))
			ID CONN)
	  (COND ((NEQ (CHAOS:STATE CONN) 'CHAOS:OPEN-STATE)
		 (CHAOS:BAD-CHAOS-CONNECTION-STATE CONN "complete a FILE transaction on"))
		(T (PROG1 (FILE-TRANSACTION-ID-PKT ID)
			  (SETQ *FILE-PENDING-TRANSACTIONS*
				(DELQ ID *FILE-PENDING-TRANSACTIONS*))
			  (SETQ ID NIL)))))	;don't abort the ID
      (WHEN ID (ABORT-PENDING-FILE-TRANSACTION-ID ID)))))

(DEFUN HOST-CHAOS-INTERRUPT-FUNCTION (REASON CONN &REST IGNORE)
  (DECLARE (SPECIAL HOST-UNIT))
  (SELECTQ REASON
    (:INPUT
     (LOOP WHILE (EQ (CHAOS:STATE CONN) 'CHAOS:OPEN-STATE)
	   AS PKT = (CHAOS:GET-NEXT-PKT CONN T)
	   UNTIL (NULL PKT)
	   WITH STRING WITH TEM DO
       (SETQ STRING (CHAOS:PKT-STRING PKT))
       (SELECT (CHAOS:PKT-OPCODE PKT)
	 (%FILE-ASYNCHRONOUS-MARK-OPCODE
	  (SETQ STRING (SUBSTRING STRING
				  (1+ (STRING-SEARCH-CHAR #\SP (CHAOS:PKT-STRING PKT)))))
	  (DO ((DATA-CONNS (HOST-UNIT-DATA-CONNECTIONS HOST-UNIT) (CDR DATA-CONNS))
	       (HANDLE-LEN (OR (STRING-SEARCH-CHAR #\SP STRING)
			       (STRING-LENGTH STRING)))
	       (STREAM))
	      ((NULL DATA-CONNS)
	       (PROCESS-RUN-FUNCTION "FILE Protocol Violation"
		 #'(LAMBDA (PKT CONN)
		     (UNWIND-PROTECT
		       (FERROR "FILE protocol violation at interrupt level, ~
				asynchronous mark for non-open output channel.~@
				Host: ~A  Packet: ~S"
			       (SEND (CHAOS:FOREIGN-HOST-OBJECT CONN) ':SHORT-NAME)
			       (CHAOS:PKT-STRING PKT))
		       (CHAOS:RETURN-PKT PKT)))
		 PKT CONN))
	    (COND ((AND (STRING-EQUAL STRING (DATA-HANDLE (CAR DATA-CONNS) ':OUTPUT) 0 0
				      HANDLE-LEN)
			(SETQ STREAM (DATA-STREAM (CAR DATA-CONNS) ':OUTPUT)))
		   (FUNCALL STREAM ':ASYNC-MARK PKT)
		   (RETURN NIL)))))
	 (%FILE-COMMAND-OPCODE
	  (SETQ STRING (SUBSTRING STRING 0 (STRING-SEARCH-CHAR #\SP STRING)))
	  (SETQ TEM (ASSOC STRING *FILE-PENDING-TRANSACTIONS*))
	  (RETURN-ARRAY (PROG1 STRING (SETQ STRING NIL)))	;Don't cons
	  (COND ((NULL TEM)
		 (PROCESS-RUN-FUNCTION
		   "FILE Protocol Violation"
		   #'(LAMBDA (PKT CONN)
		       (UNWIND-PROTECT
			 (FERROR "FILE protocol violation at interrupt level from host ~A, ~
				  unknown transaction id in ~S"
				 (SEND (CHAOS:FOREIGN-HOST-OBJECT CONN) ':SHORT-NAME)
				 (CHAOS:PKT-STRING PKT))
			 (CHAOS:RETURN-PKT PKT)))
		   PKT CONN))
		((FILE-TRANSACTION-ID-SIMPLE-P TEM)
		 ;;If simple transaction, make sure no error
		 (LET ((STRING (NSUBSTRING (CHAOS:PKT-STRING PKT)
					   (1+ (STRING-SEARCH-CHAR #\SP
								   (CHAOS:PKT-STRING PKT)))))
		       (FROM))
		   (SETQ FROM (1+ (STRING-SEARCH-SET '(#\SP #\CR) STRING)))
		   ;; If simple transaction fails, barf in another process
		   (OR (NOT (STRING-EQUAL "ERROR" STRING 0 FROM 5
					  (STRING-SEARCH-SET '(#\SP #\CR) STRING FROM)))
		       (PROCESS-RUN-FUNCTION "FILE Simple Transaction Failed"
					     #'FILE-ERROR (STRING-APPEND STRING))))
		 (CHAOS:RETURN-PKT PKT)
		 (SETQ *FILE-PENDING-TRANSACTIONS* (DELQ TEM *FILE-PENDING-TRANSACTIONS*)))
		((NULL (FILE-TRANSACTION-ID-PKT TEM))
		 (SETF (FILE-TRANSACTION-ID-PKT TEM) PKT))
		((EQ (FILE-TRANSACTION-ID-PKT TEM) ':ABORTED)
		 ;; somebody decided to abort this transaction; throw
		 ;; packet away and don't complain
		 (CHAOS:RETURN-PKT PKT)
		 (SETQ *FILE-PENDING-TRANSACTIONS* (DELQ TEM *FILE-PENDING-TRANSACTIONS*)))
		(T
		 (PROCESS-RUN-FUNCTION "QFILE implementation error"
		   #'(LAMBDA (PKT CONN ID)	;let user inspect variables if desired
		       PKT CONN ID
		       (UNWIND-PROTECT
			 (FERROR "QFILE implementation error at interrupt level: ~
				  packet slot for transaction id was not NIL or :ABORTED")
			 (CHAOS:RETURN-PKT PKT)))
		   PKT CONN (PROG1 TEM (SETQ *FILE-PENDING-TRANSACTIONS*
					     (DELQ TEM *FILE-PENDING-TRANSACTIONS*)))))))
	 (%FILE-NOTIFICATION-OPCODE
	  (TV:NOTIFY NIL "File server ~A: ~A"
			 (SEND (HOST-UNIT-ACCESS-PATH HOST-UNIT) ':HOST) STRING)
	  (CHAOS:RETURN-PKT PKT))
	 (OTHERWISE (CHAOS:RETURN-PKT PKT)))))))

(DEFMETHOD (:NEW-HOST-UNIT QFILE-ACCESS-PATH) (&AUX UNIT)
  (SETQ UNIT (MAKE-INSTANCE 'HOST-UNIT ':SERVICE-ACCESS-PATH SERVICE-ACCESS-PATH
				       ':ACCESS-PATH SELF))
  (WITHOUT-INTERRUPTS
    (SETQ HOST-UNITS (NCONC HOST-UNITS (NCONS UNIT))))
  (SEND UNIT ':VALIDATE-CONTROL-CONNECTION)
  UNIT)

;;; Return a valid host unit.  If no units, make one.  If any unit is still open, use it.
;;; Errors if fails to connect.
(DEFMETHOD (:GET-HOST-UNIT QFILE-ACCESS-PATH) ()
  (COND ((NULL HOST-UNITS)
	 (SEND SELF ':NEW-HOST-UNIT))
	((LOOP FOR UNIT IN HOST-UNITS
	       WHEN (FUNCALL UNIT ':VALIDATE-CONTROL-CONNECTION T)
	       RETURN UNIT))
	(T
	 (LET ((UNIT (CAR HOST-UNITS)))
	   (FUNCALL UNIT ':VALIDATE-CONTROL-CONNECTION)
	   UNIT))))

;;; Get a DATA-CONNECTION for use in DIRECTION.
;;; Make two passes over existing units, first trying open ones.
(DEFMETHOD (:GET-DATA-CONNECTION QFILE-ACCESS-PATH) (DIRECTION)
  (DO-NAMED TOP ((ERROR-P NIL T)) (NIL)
    (DO ((UNITS HOST-UNITS (CDR UNITS))
	 (UNIT) (DATA-CONN))
	((NULL UNITS))
      (SETQ UNIT (CAR UNITS))
      (AND (FUNCALL UNIT ':VALIDATE-CONTROL-CONNECTION (NOT ERROR-P))
	   (SETQ DATA-CONN (FUNCALL UNIT ':GET-DATA-CONNECTION DIRECTION))
	   (RETURN-FROM TOP (VALUES DATA-CONN UNIT))))
    (AND ERROR-P
	 (LET* ((UNIT (SEND SELF ':NEW-HOST-UNIT))
		(DATA-CONN (FUNCALL UNIT ':GET-DATA-CONNECTION DIRECTION)))
	   (OR DATA-CONN (FERROR "New unit failed to allocate data connection"))
	   (RETURN-FROM TOP (VALUES DATA-CONN UNIT))))))

;;; Get a data connection for this unit.  Makes a new one if there is room in within the
;;; maximum number.  We are assumed to have recently been checked for validity.
(DEFMETHOD (:GET-DATA-CONNECTION HOST-UNIT) (DIRECTION)
  (LOCK-HOST-UNIT (SELF)
    (DO ((DATA-CONNS DATA-CONNECTIONS (CDR DATA-CONNS))
	 (DATA-CONN))
	(NIL)
      (SETQ DATA-CONN (COND (DATA-CONNS (CAR DATA-CONNS))
			    ((= (LENGTH DATA-CONNECTIONS) MAX-DATA-CONNECTIONS)
			     (RETURN NIL))
			    (T (SEND SELF ':NEW-DATA-CONNECTION))))
      (COND ((EQ DIRECTION ':BIDIRECTIONAL)	;He wants BOTH halves..
	     (WHEN (AND (NULL (DATA-STREAM DATA-CONN ':INPUT))
			(NULL (DATA-STREAM DATA-CONN ':OUTPUT)))
	       (SETF (DATA-STREAM DATA-CONN ':INPUT) T)	;Reserve....
	       (SETF (DATA-STREAM DATA-CONN ':OUTPUT) T)
	       (RETURN DATA-CONN)))
	    ((NULL (DATA-STREAM DATA-CONN DIRECTION))
	     (SETF (DATA-STREAM DATA-CONN DIRECTION) T)	;Mark as allocated
	     (RETURN DATA-CONN))))))

;;; Mark a data-connection [half] as having seen a failing OPEN or DIRECTORY-LIST.
;;; This allows OPEN and DIRECTORY-LIST to free it, without closing it.
;;;
(DEFMETHOD (:MARK-FAILING-DATA-CONNECTION HOST-UNIT) (HANDLE)
  (LOCK-HOST-UNIT (SELF)			;protect the loop down the list
    (LOOP FOR DATA-CONN IN DATA-CONNECTIONS
	  IF (EQUAL (DATA-INPUT-HANDLE DATA-CONN ) HANDLE)
	  RETURN (SETF (DATA-STREAM DATA-CONN ':INPUT) ':FAILED)     ;this need not be atomic
	  IF (EQUAL (DATA-OUTPUT-HANDLE DATA-CONN) HANDLE)
	  RETURN (SETF (DATA-STREAM DATA-CONN ':OUTPUT) ':FAILED)))) ;or even under a lock...

;;; Allocate a new data connection
(DEFMETHOD (:NEW-DATA-CONNECTION HOST-UNIT) ()
  (LET ((INPUT-HANDLE (FILE-GENSYM "I"))
	(OUTPUT-HANDLE (FILE-GENSYM "O"))
	(PKT (CHAOS:GET-PKT))
	(TID (FILE-MAKE-TRANSACTION-ID))
	(DATA-CONN NIL)
	(CONNECTION NIL)
	SUCCESS)
    (CHAOS:SET-PKT-STRING PKT TID "  DATA-CONNECTION " INPUT-HANDLE " " OUTPUT-HANDLE)
    (UNWIND-PROTECT
      (PROGN (SETQ CONNECTION
		   (CHAOS:LISTEN OUTPUT-HANDLE *FILE-DATA-WINDOW-SIZE* NIL))
	     (CHAOS:SEND-PKT CONTROL-CONNECTION PKT)
	     (COND ((SETQ SUCCESS (CHAOS:WAIT CONNECTION 'CHAOS:LISTENING-STATE
					      (* 60. 30.) "Data Conn Listen"))
		    ;; Connection was established, pick up command acknowledgement
		    (CHAOS:ACCEPT CONNECTION)
		    (SETQ PKT (FILE-WAIT-FOR-TRANSACTION (PROG1 TID (SETQ TID NIL))
							 CONTROL-CONNECTION "New Data Conn")))
		   ;; Connection failed, but maybe we got a command acknowledgement
		   ((SETQ PKT
			  (FILE-TRANSACTION-ID-PKT (ASSOC TID *FILE-PENDING-TRANSACTIONS*))))
		   (T
		    ;; No response at all from server -- give reasonable error
		    (ERROR 'CHAOS:CHAOS-HOST-NOT-RESPONDING-DURING-CONNECTION
			   ':CONNECTION CONNECTION
			   ':FOREIGN-HOST (SEND ACCESS-PATH ':HOST)
			   ':CONTACT-NAME OUTPUT-HANDLE)))
	     ;; Handle command acknowledgement
	     (UNWIND-PROTECT
	       (LET ((STRING (CHAOS:PKT-STRING PKT)))
		 (SETQ STRING (NSUBSTRING STRING (1+ (STRING-SEARCH-CHAR #\SP STRING))))
		 (COND ((AND SUCCESS (FILE-CHECK-COMMAND "DATA-CONNECTION" STRING T))
			(SETQ DATA-CONN (MAKE-DATA-CONNECTION CONNECTION
							      INPUT-HANDLE OUTPUT-HANDLE))
			(PUSH DATA-CONN DATA-CONNECTIONS))
		       (T (FILE-ERROR STRING))))	;not proceedable
	       (UNLESS TID (CHAOS:RETURN-PKT PKT))))
      (WHEN TID (ABORT-PENDING-FILE-TRANSACTION TID))
      (IF (AND CONNECTION (NOT DATA-CONN))	;if the connection exists, but not
						;incorporated into a data
						;connection, then we lost
						;somewhere along the way and
						;should flush the connection.   
	  (CHAOS:REMOVE-CONN CONNECTION)))
    DATA-CONN))

;;; Called when done with a DATA-CONNECTION for DIRECTION.
(DEFMETHOD (:FREE-DATA-CONNECTION HOST-UNIT) (DATA-CONNECTION DIRECTION)
  (SETF (DATA-TOUCHED DATA-CONNECTION) (TIME))
  (COND ((EQ DIRECTION ':BIDIRECTIONAL)
	 (SETF (DATA-STREAM DATA-CONNECTION ':INPUT) NIL)
	 (SETF (DATA-STREAM DATA-CONNECTION ':OUTPUT) NIL))
	(T
	 (SETF (DATA-STREAM DATA-CONNECTION DIRECTION) NIL))))

(DEFMETHOD (:SCAVENGE QFILE-ACCESS-PATH) ()
  (LET ((HOST-ACTIVE-P NIL)
	(TIMEOUT (SEND SELF ':SEND-IF-HANDLES ':CONTROL-CONNECTION-LIFETIME)))
    (LOOP FOR HOST-UNIT IN HOST-UNITS
	  WHEN (SEND HOST-UNIT ':SCAVENGE TIMEOUT)
	  DO (SETQ HOST-ACTIVE-P T))
    HOST-ACTIVE-P))

(DEFMETHOD (:SCAVENGE HOST-UNIT) (TIMEOUT)
  (LOCK-HOST-UNIT (SELF)
    (LET ((TIME (TIME))
	  (HOST-ACTIVE-P NIL))
      (WHEN (AND CONTROL-CONNECTION
		 (EQ (CHAOS:STATE CONTROL-CONNECTION) 'CHAOS:OPEN-STATE))
	(LOOP WITH KILL-CONTROL-CONNECTION = CONTROL-CONNECTION
	      WITH N = (LENGTH DATA-CONNECTIONS)
	      WITH WINNERS
	      FOR DATA-CONNECTION IN DATA-CONNECTIONS
	      AS L = (IF (= N 1) *FILE-DATA-LIFE* *FILE-ADDITIONAL-DATA-LIFE*)
	      WHEN (AND (NULL (DATA-STREAM DATA-CONNECTION ':INPUT))
			(NULL (DATA-STREAM DATA-CONNECTION ':OUTPUT))
			(> (TIME-DIFFERENCE TIME (DATA-TOUCHED DATA-CONNECTION))
			   L))
		DO (DECF N) AND COLLECT DATA-CONNECTION INTO LOSERS
	      ELSE DO (SETQ WINNERS (SETQ HOST-ACTIVE-P T))
	      FINALLY
		(OR (AND KILL-CONTROL-CONNECTION TIMEOUT
			 (> (TIME-DIFFERENCE TIME CONTROL-CONNECTION-TOUCHED)
			    TIMEOUT)
			 (NOT WINNERS))
		    (SETQ KILL-CONTROL-CONNECTION NIL HOST-ACTIVE-P T))
		(WHEN (OR LOSERS KILL-CONTROL-CONNECTION)
		  (KILL-FILE-CONNECTIONS SELF LOSERS KILL-CONTROL-CONNECTION))))
      HOST-ACTIVE-P)))

;; This needs to run in a real process because is has to PROCESS-WAIT.
(DEFUN KILL-FILE-CONNECTIONS (HOST-UNIT DATA-CONNS CONTROL-CONN)
  (LOOP FOR DATA-CONN IN DATA-CONNS
	AS CONN = (DATA-CONNECTION DATA-CONN)
	DO ;; I don't know why this gets an error sometimes, but it seems better
	   ;; to ignore the error instead of bombing with the file system locked.
	   ;; --HIC
    (IGNORE-ERRORS
      (CHAOS:RETURN-PKT
	(FUNCALL HOST-UNIT ':COMMAND NIL (DATA-HANDLE DATA-CONN ':INPUT) NIL
		 "Kill Data Conn" "UNDATA-CONNECTION")))
    (IGNORE-ERRORS				;Don't bomb out in the background process
						;let the error be found somewhere else.
						;Probably the host just went down anyway.
      (CHAOS:CLOSE-CONN CONN "Done" T))
    (SETF (HOST-UNIT-DATA-CONNECTIONS HOST-UNIT)
	  (DELQ DATA-CONN (HOST-UNIT-DATA-CONNECTIONS HOST-UNIT))))
  (COND (CONTROL-CONN
	 (IGNORE-ERRORS
	   (CHAOS:CLOSE-CONN CONTROL-CONN "KILL-FILE-CONNECTIONS" T))
	 (SETF (HOST-UNIT-CONTROL-CONNECTION HOST-UNIT) NIL))))

;; Implicit arguments to :COMMAND
(DEFVAR *COMMAND-PATHNAME* NIL)
(DEFVAR *COMMAND-ERROR-ARGUMENTS* NIL)

;;; *DONT-HACK-LOGIN* prevents infinite recursion when logging in.
;;; If it were not there, the :COMMAND "LOGIN" done by LOGIN-HOST-UNIT
;;; would recursively try to LOGIN-HOST-UNIT when initially trying "".
;;; Its semantics are "Don't handle CORRECTABLE-LOGIN-PROBLEMS, because I'm
;;; going to handle them at an outer level".

;;; Send a command over the control connection.
;;; MARK-P means writing or reading (expecting) a synchronous mark.
;;; STREAM-OR-HANDLE is a stream whose file handle should be used, or the handle itself.
;;;  If STREAM-OR-HANDLE is a list of :CREATE and a handle, we go through special pain
;;;   to let the caller know the status of the data connection.
;;;  if MARK-P, this had better really be a stream.
;;; SIMPLE-P means do not wait for a response, get an asynchronous error if any.
;;; Caller must return the PKT.
(DEFMETHOD (:COMMAND HOST-UNIT) (MARK-P STREAM-OR-HANDLE SIMPLE-P WHOSTATE
					&REST COMMANDS
					&AUX HANDLE STREAM PKT SUCCESS STRING TRANSACTION-ID
					     CREATE-P)
  (DECLARE (VALUES PKT STRING))
  (WHEN (LISTP STREAM-OR-HANDLE)
    (SETQ CREATE-P (EQ (FIRST STREAM-OR-HANDLE) ':CREATE)
	  STREAM-OR-HANDLE (SECOND STREAM-OR-HANDLE)))
  (COND ((STRINGP STREAM-OR-HANDLE)
	 (SETQ HANDLE STREAM-OR-HANDLE))
	(STREAM-OR-HANDLE
	 (SETQ STREAM STREAM-OR-HANDLE
	       HANDLE (FUNCALL STREAM ':FILE-HANDLE))
	 (IF (EQ MARK-P T)			;= we are to figure out which direction
	     (SETQ MARK-P (FUNCALL STREAM ':DIRECTION)))))
  ;; Keep trying the command while correctible-login-problems occur
  (LOOP DO
	(SETQ TRANSACTION-ID (FILE-MAKE-TRANSACTION-ID SIMPLE-P)
	      PKT (CHAOS:GET-PKT))
	;; Make up a packet containing the command to be sent over
	(LEXPR-FUNCALL #'CHAOS:SET-PKT-STRING
		       PKT TRANSACTION-ID " " (OR HANDLE "") " " COMMANDS)
	(CHAOS:SEND-PKT CONTROL-CONNECTION PKT %FILE-COMMAND-OPCODE)
	;; Note that we send a sync-mark even when the command errs.  The protocol should
	;; note this. (This only happens with close, set-byte-size and set-position (if it
	;; ever really works on writing, which it currently doesn't))
	(AND (EQ MARK-P ':OUTPUT)
	     (FUNCALL STREAM ':WRITE-SYNCHRONOUS-MARK))
	;; Get the portion of the response after the transaction ID.
	(COND (SIMPLE-P
	       (AND (EQ MARK-P ':INPUT)
		    (FUNCALL STREAM ':READ-UNTIL-SYNCHRONOUS-MARK))
	       (RETURN (VALUES NIL ""))))	; Return from loop and function
	(SETQ PKT (FILE-WAIT-FOR-TRANSACTION TRANSACTION-ID CONTROL-CONNECTION WHOSTATE)
	      STRING (NSUBSTRING (CHAOS:PKT-STRING PKT)
				 (1+ (STRING-SEARCH-CHAR #\SP (CHAOS:PKT-STRING PKT))))
	      SUCCESS (LET ((FROM (IF HANDLE (FILE-CHECK-HANDLE HANDLE STRING)
				      (1+ (STRING-SEARCH-SET '(#\SP #\CR) STRING)))))
			(NOT (STRING-EQUAL "ERROR" STRING 0 FROM 5
					   (STRING-SEARCH-SET '(#\SP #\CR) STRING FROM)))))
	(COND (SUCCESS
	       (AND (EQ MARK-P ':INPUT)
		    (FUNCALL STREAM ':READ-UNTIL-SYNCHRONOUS-MARK))
	       (RETURN (VALUES PKT STRING))))
	;;Operation has failed: we have to free the data connection, although
	;;only the caller knows which one.  Let him know that it's ok to do so.
	(WHEN CREATE-P
	  ;;Mark the handle such that the unwind-protect handlers below us
	  ;;know that this handle need be freed, but not closed.  Let others
	  ;;know that the handle isn't available until the unwp's clean up.
	  (SEND SELF ':MARK-FAILING-DATA-CONNECTION HANDLE))
	;; If we encounter a correctable login error while not doing a LOGIN
	;; we try login-host-unit, and then retry the command.
	;; If login host unit didn't work but returned anyway, then the retry
	;; should fail on a different type of error.
	(CONDITION-CASE-IF (NOT *DONT-HACK-LOGIN*)
			   (CONDITION)
	    (UNWIND-PROTECT
	      (LEXPR-FUNCALL #'FILE-ERROR STRING *COMMAND-PATHNAME* *COMMAND-ERROR-ARGUMENTS*)
	      (CHAOS:RETURN-PKT PKT))
	  (CORRECTABLE-LOGIN-PROBLEMS
	    (SEND ACCESS-PATH ':LOGIN-UNIT SELF T CONDITION)))))

;;; Ensure response over control connection is for correct file-handle.  If not, bomb out
;;; right here as the protocol has been violated.  If returning, return the string-index
;;; of the first non-file-handle byte.
(DEFUN FILE-CHECK-HANDLE (HANDLE STRING)
  (LET ((HANDLE-END (STRING-SEARCH-SET '(#\SP #\CR) STRING)))
    (AND (NULL HANDLE-END)
	 (FERROR "Response over control connection was incorrectly formatted"))
    (OR (STRING-EQUAL STRING HANDLE 0 0 HANDLE-END)
	(FERROR "Response over control connection was for wrong file handle"))
    (1+ HANDLE-END)))

(DEFUN FILE-CHECK-COMMAND (COMMAND RETURNED-STRING &OPTIONAL (Y-OR-N-P NIL)
                                                   &AUX START END)
  (SETQ START (1+ (STRING-SEARCH-CHAR #\SP RETURNED-STRING)))
  (SETQ END (OR (STRING-SEARCH-SET '(#\SP #\CR) RETURNED-STRING START)
                (STRING-LENGTH RETURNED-STRING)))
  (COND ((STRING-EQUAL RETURNED-STRING COMMAND START 0 END)
	 (1+ END)) ;Index of character after the delimiting space
        (Y-OR-N-P NIL)
        (T (ERROR 'QFILE-PROTOCOL-VIOLATION
	     ':FORMAT-STRING "Incorrect command name ~S in acknowledge from file computer"
	     ':FORMAT-ARGS (LIST (NSUBSTRING RETURNED-STRING START END))))))

(DEFPROP FILE-STRING-FOR-HOST T :ERROR-REPORTER)
(DEFUN FILE-STRING-FOR-HOST (PATHNAME)
  (LET ((STRING (SEND PATHNAME ':STRING-FOR-HOST)))
    (WHEN (STRING-SEARCH-CHAR #\CR STRING)
      (FERROR "FILE protocol cannot handle pathname containing newline: ~S" STRING))
    STRING))

(DEFMETHOD (FILE-ACCESS-PATH-LOGIN QFILE-ACCESS-PATH) (LOGIN-P &KEY FORCE-PASSWORD)
  (DOLIST (UNIT HOST-UNITS)
    (SEND SELF :LOGIN-UNIT UNIT LOGIN-P FORCE-PASSWORD)))

(DEFMETHOD (:LOGIN-UNIT QFILE-ACCESS-PATH) (UNIT LOGIN-P &OPTIONAL CONDITION)
  (LOGIN-HOST-UNIT UNIT LOGIN-P CONDITION))

(DEFUN LOGIN-HOST-UNIT (UNIT LOGIN-P &OPTIONAL CONDITION)
  (LET ((ACCESS-PATH (HOST-UNIT-ACCESS-PATH UNIT))
	(CONN (HOST-UNIT-CONTROL-CONNECTION UNIT)))
    (COND ((OR (NULL CONN)
	       (NEQ (CHAOS:STATE CONN) 'CHAOS:OPEN-STATE))
	   ;; No control connection - don't do anything, return NIL.
	   NIL)
	  ((NOT LOGIN-P)
	   ;; Log out this file connection.
	   (SETF (HOST-UNIT-CONTROL-CONNECTION UNIT) NIL)
	   (CHAOS:CLOSE-CONN CONN "Logging out" T)
	   (DOLIST (DATA-CONN (HOST-UNIT-DATA-CONNECTIONS UNIT))
	     (DO ((LIST (DATA-STREAM-LIST DATA-CONN) (CDDR LIST))
		  (STREAM))
		 ((NULL LIST))
	       (AND (NOT (SYMBOLP (SETQ STREAM (CADR LIST))))
		    (FUNCALL STREAM ':SET-STATUS ':CLOSED)))
	     (CHAOS:CLOSE-CONN (DATA-CONNECTION DATA-CONN) "Logging out" T))
	   (SETF (HOST-UNIT-DATA-CONNECTIONS UNIT) NIL)
	   T)
	  (T
	   ;; Really log in this file connection.
	   ;; If the connection was newly created, or isn't logged in yet, and
	   ;; we know a login name to use for this host, quietly try it.
	   ;; Otherwise, or if that fails, loop asking the user for a name and password
	   ;; until we get one that works.  If we abort out while the connection isn't
	   ;; logged in yet, close the connection so it doesn't hang around forever
	   ;; without being logged in.
	   (LET* ((NEW-USER-ID NIL)
		  (PASSWORD NIL)
		  (LOGGED-IN (AND CONDITION (NOT (TYPEP CONDITION 'NOT-LOGGED-IN))))
		  IDX HSNAME-PATHNAME REAL-USER-ID PERSONAL-NAME GROUP-AFFILIATION)
	     (UNWIND-PROTECT
	       (LOOP DO
		 (MULTIPLE-VALUE (NEW-USER-ID PASSWORD)
		   (GET-USER-ID-AND-PASSWORD ACCESS-PATH NEW-USER-ID PASSWORD CONDITION))
		 (CONDITION-CASE (CONDITION2)
		     (MULTIPLE-VALUE-BIND (PKT STR)
			 (LET ((*DONT-HACK-LOGIN* T))
			   (SEND UNIT ':COMMAND NIL NIL NIL "Login"
				 "LOGIN " (OR NEW-USER-ID "") " " (OR PASSWORD "") " "))
		       ;; File server successfully logged in
		       (SETQ LOGGED-IN T)
		       (OR (AND (SETQ IDX (STRING-SEARCH-CHAR #\SP STR))
				(SETQ IDX (STRING-SEARCH-CHAR #\SP STR (1+ IDX)))
				(SETQ IDX (STRING-SEARCH-CHAR #\SP STR (1+ IDX))))
			   (FERROR "Incorrect format in LOGIN response from ~A" ACCESS-PATH))
		       ;; Get data about the user from server
		       (MULTIPLE-VALUE (HSNAME-PATHNAME PERSONAL-NAME GROUP-AFFILIATION
					REAL-USER-ID)
			 (SEND ACCESS-PATH ':HSNAME-INFORMATION UNIT STR IDX))
		       (SEND SI:*USER* ':PROPERTIES-FROM-FILE-SERVER (SEND ACCESS-PATH ':HOST)
			     REAL-USER-ID PERSONAL-NAME GROUP-AFFILIATION)
		       (WHEN REAL-USER-ID
			 ;; The host gets to canonicalize user id's; for example,
			 ;; Unix usually converts to lower case.
			 (SEND ACCESS-PATH ':SET-HOST-USER-ID REAL-USER-ID))
		       ;; Reset cached information about the user
		       (NETI:COMPUTE-FINGER-STRING T)
		       (SEND ACCESS-PATH ':SET-HOMEDIR-PATHNAME HSNAME-PATHNAME)
		       ;; Some semblance of security...
		       (UNLESS (OR *REMEMBER-PASSWORDS*
				   (NULL PASSWORD))
			 (COPY-ARRAY-CONTENTS "" PASSWORD))
		       (CHAOS:RETURN-PKT PKT)
		       (RETURN T))
		   (CORRECTABLE-LOGIN-PROBLEMS
		     (SETQ CONDITION CONDITION2))))
	       ;; Aborted without logging in, so logout the file server
	       (IF (NOT LOGGED-IN)
		   (LOGIN-HOST-UNIT UNIT NIL))))))))

;;; Functions to be called by pathname interface.
;;; Commands without associated streams.
(DEFUN DELETE-CHAOS (ACCESS-PATH *COMMAND-PATHNAME* &AUX HOST-UNIT)
  (SETQ HOST-UNIT (FUNCALL ACCESS-PATH ':GET-HOST-UNIT))
  (LET ((*COMMAND-ERROR-ARGUMENTS* '(:OPERATION :DELETE)))
    (CHAOS:RETURN-PKT
      (FUNCALL HOST-UNIT ':COMMAND NIL NIL NIL "Delete"
	       "DELETE" #\CR (FILE-STRING-FOR-HOST *COMMAND-PATHNAME*) #\CR))
    T))

(DEFUN RENAME-CHAOS (ACCESS-PATH *COMMAND-PATHNAME* NEW-PATHNAME)
  (WITH-STACK-LIST (*COMMAND-ERROR-ARGUMENTS*
		     ':OPERATION ':RENAME
		     ':NEW-PATHNAME NEW-PATHNAME)
    (LET (PKT STRING IDX FROM-PATHNAME TO-PATHNAME)
      (UNWIND-PROTECT
	(PROGN
	  (MULTIPLE-VALUE (PKT STRING)
	    (SEND (SEND ACCESS-PATH ':GET-HOST-UNIT)
		  :COMMAND NIL NIL NIL "Rename"
		  "RENAME" #\CR (FILE-STRING-FOR-HOST *COMMAND-PATHNAME*) #\CR
		  (FILE-STRING-FOR-HOST NEW-PATHNAME) #\CR))
	  (AND (SETQ IDX (STRING-SEARCH-CHAR #\CR STRING))
	       (SETQ TO-PATHNAME
		     (SEND *COMMAND-PATHNAME* :PARSE-TRUENAME
			   (NSUBSTRING STRING (SETQ IDX (1+ IDX))
				       (SETQ IDX (STRING-SEARCH-CHAR #\CR STRING IDX)))))
	       IDX
	       (SETQ FROM-PATHNAME
		     (SEND *COMMAND-PATHNAME* :PARSE-TRUENAME
			   (NSUBSTRING STRING (SETQ IDX (1+ IDX))
				       (STRING-SEARCH-CHAR #\CR STRING IDX)))))
	  (VALUES FROM-PATHNAME TO-PATHNAME))
	(AND PKT (CHAOS:RETURN-PKT PKT))))))

;; After logging in a host unit, we hack the capabilities
;; to the last state requested.
(DEFMETHOD (:LOGIN-UNIT QFILE-ACCESS-PATH :AFTER) (UNIT LOGIN-P &OPTIONAL IGNORE)
  (IF LOGIN-P
      (PROGN (LOOP FOR CAP IN (SEND HOST ':GET ':ENABLED-CAPABILITIES)
		   DO (SEND UNIT ':PROCESS-UNIT-CAPABILITY
			    CAP "Enable" ':ENABLE-CAPABILITIES))
	     (LOOP FOR CAP IN (SEND HOST ':GET ':DISABLED-CAPABILITIES)
		   DO (SEND UNIT ':PROCESS-UNIT-CAPABILITY
			    CAP "Disable" ':DISABLE-CAPABILITIES)))))

;; Enable one capability on one host unit
;; Return the A-list of capability names (strings) and on/off values
(DEFMETHOD (:PROCESS-UNIT-CAPABILITY HOST-UNIT) (CAPABILITY WHOSTATE COMMAND)
  (LOOP DO
	(CONDITION-CASE ()
	    (LET ((PASSWORD (AND (EQ COMMAND ':ENABLE-CAPABILITIES)
				 (SEND ACCESS-PATH ':PASSWORD-FOR-CAPABILITY CAPABILITY))))
	      (RETURN
		(LOCK-HOST-UNIT (SELF)
		  (IF (SEND SELF ':VALIDATE-CONTROL-CONNECTION)
		      (WITH-STACK-LIST (*COMMAND-ERROR-ARGUMENTS* ':OPERATION COMMAND)
			(MULTIPLE-VALUE-BIND (PKT STRING)
			    (IF PASSWORD
				(SEND SELF ':COMMAND
				      NIL NIL NIL WHOSTATE (STRING COMMAND) " "
				      CAPABILITY
				      #\CR
				      PASSWORD)
				(SEND SELF ':COMMAND
				      NIL NIL NIL WHOSTATE (STRING COMMAND) " "
				      CAPABILITY)) 
			  (LOOP WITH I = (STRING-SEARCH-CHAR #\SP STRING)
				WITH PACKAGE = SI:PKG-USER-PACKAGE
				WHILE (SETQ I (STRING-SEARCH-CHAR #\SP STRING (1+ I)))
				COLLECT (CONS (SUBSTRING STRING (1+ I)
							 (SETQ I (STRING-SEARCH-CHAR
								   #\SP STRING (1+ I))))
					      (READ-FROM-STRING STRING NIL (1+ I)))
				FINALLY (CHAOS:RETURN-PKT PKT))))))))
	  (INVALID-CAPABILITY-PASSWORD))))

(DEFMETHOD (:PASSWORD-FOR-CAPABILITY QFILE-ACCESS-PATH :DEFAULT) (IGNORE) NIL)

(DEFMETHOD (:STREAM-PROPERTIES HOST-UNIT) (PATHNAME HANDLE)
  (SEND ACCESS-PATH ':PROPERTIES PATHNAME HANDLE))

(DEFMETHOD (:PROCESS-CAPABILITIES QFILE-ACCESS-PATH)
	   (CAPABILITIES ENABLE-P &AUX WHOSTATE COMMAND ADD-KEY REMOVE-KEY RESULT-ALIST)
  (IF ENABLE-P
      (SETQ WHOSTATE "Enable"
	    COMMAND ':ENABLE-CAPABILITIES
	    ADD-KEY ':ENABLED-CAPABILITIES
	    REMOVE-KEY ':DISABLED-CAPABILITIES)
    (SETQ WHOSTATE "Disable"
	  COMMAND ':DISABLE-CAPABILITIES
	  ADD-KEY ':DISABLED-CAPABILITIES
	  REMOVE-KEY ':ENABLED-CAPABILITIES))
  (LOOP FOR CAP IN CAPABILITIES
	WITH BAD-CAPS = NIL
     DO (CONDITION-CASE (.ERROR.)
	    (LOOP FOR HOST-UNIT IN (SEND SELF ':HOST-UNITS)
		  DO (SETQ RESULT-ALIST
			   (SEND HOST-UNIT ':PROCESS-UNIT-CAPABILITY CAP WHOSTATE COMMAND)))
	  ((UNIMPLEMENTED-OPTION UNKNOWN-OPERATION UNHANDLED-CAPABILITY)
	   (PUSH (CONS CAP .ERROR.) BAD-CAPS))
	  (:NO-ERROR (SEND HOST ':RECORD-CAPABILITY CAP ADD-KEY REMOVE-KEY)))
     FINALLY
     (IF BAD-CAPS
	 (LET* ((CONDITION (MAKE-CONDITION 'UNHANDLED-CAPABILITIES ':ERRORS BAD-CAPS
					   ':HOST SELF ':OPERATION WHOSTATE))
		(RESULT (SIGNAL CONDITION)))
	   (OR RESULT
	       (FORMAT QUERY-IO "~A" CONDITION))))
     (RETURN RESULT-ALIST)))

(DEFMETHOD (:ENABLE-CAPABILITIES QFILE-ACCESS-PATH) (&REST CAPABILITIES)
  (SEND SELF ':PROCESS-CAPABILITIES CAPABILITIES T))

(DEFMETHOD (:DISABLE-CAPABILITIES QFILE-ACCESS-PATH) (&REST CAPABILITIES)
  (SEND SELF ':PROCESS-CAPABILITIES CAPABILITIES NIL))

(DEFMETHOD (:DEFAULT-ENABLE-CAPABILITIES QFILE-ACCESS-PATH) ()
  '("ALL"))

(DEFUN COMPLETE-CHAOS (ACCESS-PATH PATHNAME STRING OPTIONS
		       &AUX HOST-UNIT PKT FILE-STRING SUCCESS
			    DELETED-P WRITE-P NEW-OK STRING-ORIGIN)
  (DOLIST (KEY OPTIONS)
    (SELECTQ KEY
      (:DELETED
       (SETQ DELETED-P T))
      ((:READ :IN)
       (SETQ WRITE-P NIL))
      ((:PRINT :OUT :WRITE)
       (SETQ WRITE-P T))
      (:OLD
       (SETQ NEW-OK NIL))
      (:NEW-OK
       (SETQ NEW-OK T))
      (OTHERWISE
       (FERROR "~S is not a recognized option" KEY))))
  (SETQ HOST-UNIT (FUNCALL ACCESS-PATH ':GET-HOST-UNIT))
  (CONDITION-CASE ()
      (MULTIPLE-VALUE (PKT FILE-STRING)
	(FUNCALL HOST-UNIT ':COMMAND NIL NIL NIL "Complete"
		 "COMPLETE"
		 (IF DELETED-P	" DELETED" "")
		 (IF WRITE-P	" WRITE" "")
		 (IF NEW-OK	" NEW-OK" "")
		 #\CR (FILE-STRING-FOR-HOST PATHNAME)
		 #\CR STRING #\CR))
    (FILE-OPERATION-FAILURE STRING)		;No success.
    (:NO-ERROR
     (OR (SETQ STRING-ORIGIN (STRING-SEARCH-CHAR #\CR FILE-STRING))
	 (FERROR "Illegally formatted string ~S" FILE-STRING))
     (SETQ SUCCESS (SUBSTRING FILE-STRING (FILE-CHECK-COMMAND "COMPLETE" FILE-STRING)
			      STRING-ORIGIN))
     (SETQ SUCCESS (SELECTOR SUCCESS STRING-EQUAL
		     ("T" T)
		     ("NIL" NIL)
		     (OTHERWISE (INTERN SUCCESS ""))))
     (SETQ STRING (SUBSTRING FILE-STRING
			     (SETQ STRING-ORIGIN (1+ STRING-ORIGIN))
			     (STRING-SEARCH-CHAR #\CR FILE-STRING STRING-ORIGIN)))
     (CHAOS:RETURN-PKT PKT)
     (VALUES STRING SUCCESS))))

(DEFUN CHANGE-PROPERTIES-CHAOS (ACCESS-PATH *COMMAND-PATHNAME* PROPERTIES
				&AUX STRING HOST-UNIT)
  (SETQ HOST-UNIT (FUNCALL ACCESS-PATH ':GET-HOST-UNIT))
  (SETQ STRING (CHANGE-PROPERTIES-STRING PROPERTIES *COMMAND-PATHNAME*))
  (LET ((*COMMAND-ERROR-ARGUMENTS* '(:OPERATION :CHANGE-PROPERTIES)))
    (CHAOS:RETURN-PKT
      (FUNCALL HOST-UNIT ':COMMAND NIL NIL NIL "Change Properties" STRING))
    T))

(DEFUN CHANGE-PROPERTIES-STRING (PROPERTIES &OPTIONAL PATHNAME)
  (SCL:WITH-STANDARD-IO-ENVIRONMENT
    (WITH-OUTPUT-TO-STRING (STREAM)
      (FORMAT STREAM "CHANGE-PROPERTIES~%")
      (WHEN PATHNAME (FORMAT STREAM "~A~%" (FILE-STRING-FOR-HOST PATHNAME)))
      (LOOP FOR (IND PROP) ON PROPERTIES BY 'CDDR
	    DO (FORMAT STREAM "~A " IND)
	       (FUNCALL (DO ((L *KNOWN-DIRECTORY-PROPERTIES* (CDR L)))
			    ((NULL L) 'PRINC)
			  (AND (MEMQ IND (CDAR L))
			       (RETURN (CADAAR L))))
			PROP STREAM)
	       (FUNCALL STREAM ':TYO #\CR)))))

(DEFUN EXPUNGE-CHAOS (ACCESS-PATH *COMMAND-PATHNAME* OPTIONS &AUX HOST-UNIT PKT FILE-STRING)
  (DO ((O OPTIONS (CDDR O)))
      ((NULL O))
    (OR (EQ (CAR O) ':ERROR)
	(FERROR "~S is not a recognized option" (CAR O))))
  (SETQ HOST-UNIT (FUNCALL ACCESS-PATH ':GET-HOST-UNIT))
  (LET ((*COMMAND-ERROR-ARGUMENTS* '(:OPERATION :EXPUNGE)))
    (MULTIPLE-VALUE (PKT FILE-STRING)
      (FUNCALL HOST-UNIT ':COMMAND NIL NIL NIL "Expunge"
	       "EXPUNGE" #\CR (FILE-STRING-FOR-HOST *COMMAND-PATHNAME*) #\CR))
    (PROG1 (LET ((START (FILE-CHECK-COMMAND "EXPUNGE" FILE-STRING)))
	     (PARSE-NUMBER FILE-STRING START))
	   (CHAOS:RETURN-PKT PKT))))

(DEFUN CREATE-DIRECTORY-CHAOS (ACCESS-PATH PATHNAME OPTIONS &AUX HOST-UNIT)
  (AND OPTIONS (FERROR "~S is not a recognized option" (CAR OPTIONS)))
  (SETQ HOST-UNIT (FUNCALL ACCESS-PATH ':GET-HOST-UNIT))
  (LET ((*COMMAND-ERROR-ARGUMENTS* '(:OPERATION :CREATE-DIRECTORY))
	(*COMMAND-PATHNAME* (SEND PATHNAME ':NEW-PATHNAME ':NAME NIL ':TYPE NIL
				  ':VERSION NIL)))
    (CHAOS:RETURN-PKT
      (FUNCALL HOST-UNIT ':COMMAND NIL NIL NIL "Create Directory"
	       "CREATE-DIRECTORY" #\CR (FILE-STRING-FOR-HOST *COMMAND-PATHNAME*) #\CR))))

(DEFUN CREATE-LINK-CHAOS (ACCESS-PATH *COMMAND-PATHNAME* LINKTO-PATH OPTIONS
			  &AUX HOST-UNIT)
  (AND OPTIONS (FERROR "~S is not a recognized option" (CAR OPTIONS)))
  (SETQ HOST-UNIT (FUNCALL ACCESS-PATH ':GET-HOST-UNIT))
  (WITH-STACK-LIST (*COMMAND-ERROR-ARGUMENTS*
		     ':OPERATION ':CREATE-LINK
		     ':NEW-PATHNAME LINKTO-PATH)

    ;; This is a QFILE-protocol-specific restriction, not a systemic one.
    (UNLESS (EQ (SEND *COMMAND-PATHNAME* ':HOST)
		(SEND LINKTO-PATH ':HOST))
      (ERROR 'LINK-ACROSS-HOSTS ':PATHNAME *COMMAND-PATHNAME*))

    (CHAOS:RETURN-PKT
       (FUNCALL HOST-UNIT ':COMMAND NIL NIL NIL "Create Link"
	       "CREATE-LINK" #\CR (FILE-STRING-FOR-HOST *COMMAND-PATHNAME*) #\CR
	       (FILE-STRING-FOR-HOST LINKTO-PATH))))
  T)

;;; Stream generating versions

(DEFUN OPEN-CHAOS (ACCESS-PATH REAL-PATHNAME *COMMAND-PATHNAME* OPTIONS
		   &AUX (MODE ':READ) (TYPE ':CHARACTER)
		   (DELETED-P NIL) (RAW-P NIL) (SUPER-IMAGE-P NIL)
		   BYTE-SIZE (PRESERVE-DATES-P NIL) (INHIBIT-LINKS-P NIL) (SUBMIT-P NIL)
		   (PROBE-DIRECTORY-P NIL) (DIRECT-P NIL) (ESTIMATED-LENGTH NIL)
		   ;; The value NIL has already been condition-case'd by OPEN.
		   (IF-EXISTS NIL) (IF-NOT-EXISTS NIL) (IF-LOCKED NIL)
		   FILE-HANDLE HOST-UNIT DATA-CONN PKT SUCCESS STRING DIRECTION
		   CHARACTERS 
		   FAKE-CHARACTERS)
  (LOOP FOR (KEY VAL) ON OPTIONS BY 'CDDR
	DO (SELECTQ KEY
	     (:DIRECTION
	      (SETQ MODE (SELECTQ VAL
			   (:INPUT ':READ)
			   (:OUTPUT ':WRITE)
			   (:PROBE ':PROBE)
			   (:PROBE-LINK
			    (SETQ INHIBIT-LINKS-P T)
			    ':PROBE)
			   (:PROBE-DIRECTORY
			    (SETQ PROBE-DIRECTORY-P T)
			    ':PROBE)
			   (:IO ':BIDIRECTIONAL)
			   (OTHERWISE (FERROR "~S is an invalid direction" VAL)))))
	     (:RAW (SETQ RAW-P VAL))
	     (:SUPER-IMAGE (SETQ SUPER-IMAGE-P VAL))
	     (:PRESERVE-DATES (SETQ PRESERVE-DATES-P VAL))
	     (:ESTIMATED-LENGTH (SETQ ESTIMATED-LENGTH VAL))
	     (:DELETED (SETQ DELETED-P VAL))
	     (:SUBMIT (SETQ SUBMIT-P VAL))
	     ((:IGNORE :ERROR))			;:ERROR is handled by OPEN
	     (:IF-EXISTS
	      (IF (MEMQ VAL '(:ERROR :NEW-VERSION :RENAME :RENAME-AND-DELETE
			      :OVERWRITE :TRUNCATE :APPEND :SUPERSEDE NIL))
		  (SETQ IF-EXISTS (OR VAL ':ERROR))	;NIL handled by OPEN
		  (FERROR "Unknown IF-EXISTS keyword: ~S" VAL)))
	     (:IF-DOES-NOT-EXIST
	      (IF (MEMQ VAL '(:ERROR :CREATE NIL))
		  (SETQ IF-NOT-EXISTS (OR VAL ':ERROR))
		  (FERROR "Unknown IF-DOES-NOT-EXIST keyword: ~S" VAL)))
	     (:IF-LOCKED
	      (IF (MEMQ VAL '(:ERROR :SHARE NIL))
		  (SETQ IF-LOCKED VAL)
		  (FERROR "Unknown IF-LOCKED keyword: ~S" VAL)))
	     (:DIRECT (SETQ DIRECT-P VAL)
		      (SETQ FILE-HANDLE (FILE-GENSYM "D")))
	     (:ELEMENT-TYPE
	      (CHECK-STREAM-ELEMENT-TYPE VAL :PROTOCOL "QFILE")
	      (SETQ CHARACTERS (IF (EQ VAL ':DEFAULT)
				   :DEFAULT
				   (CL:SUBTYPEP VAL 'CL:CHARACTER)))
	      (SETQ BYTE-SIZE (BYTE-SIZE-FROM-ELEMENT-TYPE VAL))
	      (COND ((EQ CHARACTERS :DEFAULT)
		     (SETQ TYPE :DEFAULT))
		    ((EQ CHARACTERS T)
		     (SETQ TYPE :CHARACTER))
		    (T (SETQ TYPE :BINARY))))
	     (:FAKE-CHARACTERS (SETQ FAKE-CHARACTERS VAL))
	     (OTHERWISE (FERROR "~S is not a known OPEN option" KEY))))
  (IF (EQ IF-NOT-EXISTS
	  (SELECTQ MODE
	    (:READ ':ERROR)
	    (:PROBE ':ERROR)			;the manual says NIL here
	    ((:WRITE :BIDIRECTIONAL)
	     (IF (MEMQ IF-EXISTS '(:OVERWRITE :APPEND))
		 ':ERROR
		 ':CREATE))))
      (SETQ IF-NOT-EXISTS NIL))
  (when (or
	  (memq mode '(:read :probe))		;IF-EXISTS not defined in this case.
	  (and (MEMQ MODE '(:WRITE :BIDIRECTIONAL))
	       (EQ IF-EXISTS
		   ;; NB: The memq here is a kludge to make UNIX (and
		   ;; PC) QFILE work in spite of the following protocol
		   ;; violation:  default for :IF-EXISTS is
		   ;; :NEW-VERSION, IFF the pathname's version is
		   ;; :NEWEST.  If you don't transmit the version, the
		   ;; server is supposed to assume the default.
		   ;; Instead, UNIX (and the PC) cheat and use
		   ;; :OVERWRITE.  However, if you send them an explicit
		   ;; :IF-EXISTS :NEW-VERSION, they get huffy and return
		   ;; an error indication. Since UNIX pathnames always have a 
		   ;; version is :UNSPECIFIC, this code would always send an explicit
		   ;; :NEW-VERSION across, because its not the default.
		   ;; So the MEMQ below treats :UNSPECIFIC the same as :NEWEST.		   
		   (IF (MEMQ (SEND REAL-PATHNAME ':VERSION) '(:NEWEST :UNSPECIFIC))
		       ':NEW-VERSION
		       ':ERROR))))
    (SETQ IF-EXISTS NIL))


  (AND (EQ BYTE-SIZE NIL)
       (SETQ BYTE-SIZE ':DEFAULT))
  (SETQ DIRECTION (SELECTQ MODE
		    (:READ ':INPUT)
		    (:WRITE ':OUTPUT)))
  (IF (AND (EQ MODE ':BIDIRECTIONAL)
	   (NOT DIRECT-P))
      (FERROR "Bidirectional openings only supported for :DIRECT."))
  (IF (OR DIRECT-P (EQ MODE ':PROBE))
      ;;PROBE mode implies no need for data connection
      (SETQ HOST-UNIT (FUNCALL ACCESS-PATH ':GET-HOST-UNIT))
      (MULTIPLE-VALUE (DATA-CONN HOST-UNIT)
	(FUNCALL ACCESS-PATH ':GET-DATA-CONNECTION DIRECTION)))
  (UNWIND-PROTECT
    (LET ((*COMMAND-ERROR-ARGUMENTS* `(:OPERATION :OPEN :MODE ,MODE)))
      (MULTIPLE-VALUE (PKT STRING)
	(FUNCALL HOST-UNIT ':COMMAND NIL
		 (IF DIRECT-P
		     `(:PASS ,FILE-HANDLE)
		      (SELECTQ MODE
			(:PROBE NIL)
			(:READ `(:CREATE ,(DATA-INPUT-HANDLE DATA-CONN)))
			(:WRITE `(:CREATE ,(DATA-OUTPUT-HANDLE DATA-CONN)))
			(:BIDIRECTIONAL NIL)))
		 NIL
		 (IF (EQ MODE ':PROBE) "Probe" "Open")
		 "OPEN " MODE " " TYPE
		 (IF (NEQ BYTE-SIZE ':DEFAULT) (FORMAT NIL " BYTE-SIZE ~D" BYTE-SIZE) "")
		 (IF DELETED-P		" DELETED" "")
		 (IF RAW-P		" RAW" "")
		 (IF SUPER-IMAGE-P	" SUPER" "")
		 (IF PRESERVE-DATES-P	" PRESERVE-DATES" "")
		 (IF INHIBIT-LINKS-P 	" INHIBIT-LINKS" "")
		 (IF PROBE-DIRECTORY-P  " PROBE-DIRECTORY" "")
		 (IF SUBMIT-P		" SUBMIT" "")
		 (IF ESTIMATED-LENGTH (FORMAT NIL " ESTIMATED-LENGTH ~D" ESTIMATED-LENGTH) "")
		 (IF DIRECT-P		" DIRECT" "")
		 (IF IF-EXISTS		" IF-EXISTS " "")
		 (IF IF-EXISTS		IF-EXISTS "")
		 (IF IF-NOT-EXISTS	" IF-DOES-NOT-EXIST " "")
		 (IF IF-NOT-EXISTS	IF-NOT-EXISTS "")
		 (IF IF-LOCKED		" IF-LOCKED " "")
		 (IF IF-LOCKED		IF-LOCKED "")
		 #\CR (FILE-STRING-FOR-HOST REAL-PATHNAME) #\CR))
      (SETQ SUCCESS T))
    (OR SUCCESS
	DIRECT-P
	(EQ MODE ':PROBE)
	;;Free the data connection if and only if we know that the command failed.
	;;Unless we know for sure that the command failed, we do not know for sure
	;;if the server has put this data connection into active use or not.
	;;Serious remodularization of QFILE is called for to do it right.
	;;For Release 4, we will just drop the data connection onto the floor
	;;if there is any ambiguity.
	(SELECTQ (DATA-STREAM DATA-CONN DIRECTION)
	  (:FAILED (SEND HOST-UNIT ':FREE-DATA-CONNECTION DATA-CONN DIRECTION))
	  ((T) (SETF (DATA-STREAM DATA-CONN DIRECTION) ':UNCLEAR)))))
  (LET* ((PROPERTIES (READ-FILE-PROPERTY-LIST-STRING STRING "OPEN" *COMMAND-PATHNAME*))
	 (PLIST (LOCF PROPERTIES)))
    (CHAOS:RETURN-PKT PKT)
    (WHEN (EQ TYPE ':DEFAULT)
      (SETQ TYPE (IF (GET PLIST ':CHARACTERS)
		     ':CHARACTER ':BINARY)))
    (IF (EQ TYPE :CHARACTER)
	(SI:NREMPROP PLIST ':BYTE-SIZE)
	(if (eq byte-size :default)
	    (setq byte-size (get plist :byte-size))
	    (PUTPROP PLIST BYTE-SIZE :BYTE-SIZE)))
    (let ((stream
	    (MAKE-INSTANCE (SELECTQ MODE
			     (:PROBE 'FILE-PROBE-STREAM)
			     (:READ (IF DIRECT-P
					(SELECTQ TYPE
					  (:CHARACTER 'FILE-INPUT-DIRECT-CHARACTER-STREAM)
					  (:BINARY 'FILE-INPUT-DIRECT-BINARY-STREAM))
					(SELECTQ TYPE
					  (:CHARACTER 'FILE-INPUT-CHARACTER-STREAM)
					  (:BINARY 'FILE-INPUT-BINARY-STREAM))))
			     (:WRITE (IF DIRECT-P
					 (SELECTQ TYPE
					   (:CHARACTER 'FILE-OUTPUT-DIRECT-CHARACTER-STREAM)
					   (:BINARY 'FILE-OUTPUT-DIRECT-BINARY-STREAM))
					 (SELECTQ TYPE
					   (:CHARACTER 'FILE-OUTPUT-CHARACTER-STREAM)
					   (:BINARY 'FILE-OUTPUT-BINARY-STREAM))) )
			     (:BIDIRECTIONAL
			      (SELECTQ TYPE
				(:CHARACTER 'FILE-BIDIRECTIONAL-DIRECT-CHARACTER-STREAM)
				(:BINARY 'FILE-BIDIRECTIONAL-DIRECT-BINARY-STREAM))))
			   'fs:%file-stream-file-element-type
			   (element-type-from-old-fs-info (EQ TYPE :CHARACTER)
							  (GET PLIST ':BYTE-SIZE))
			   ':FILE-ACCESS-PATH ACCESS-PATH
			   ':HOST-UNIT HOST-UNIT
			   ':FILE-HANDLE FILE-HANDLE	;Only for DIRECT
			   ':DATA-CONNECTION DATA-CONN
			   ':PROPERTY-LIST PROPERTIES
			   ':PATHNAME *COMMAND-PATHNAME*)))
      ;; --- Why does this bother to make a char stream and then re-encapsulate
      ;; --- instead of just using a binary stream? No translations on user side,
      ;; --- right?
      (when (and fake-characters (eq type :character))
	(selectq mode
	  (:read (setq stream (make-instance 'si:character-to-8bit-input-stream
					      :stream stream)))
	  (:write (setq stream (make-instance 'si:8bit-to-buffered-character-output-stream
					       :stream stream)))
	  (:bidirectional
	   (setq stream
		 (make-instance 'si:buffered-character-to-8bit-stream :stream stream)))))
      (VALUES stream (EQ TYPE :BINARY)))))


;;; Pathname is only used as a source of a host with respect to which to parse
(DEFUN READ-FILE-PROPERTY-LIST-STRING (STRING OPERATION PATHNAME
				       &AUX PATHNAME-ORIGIN PROPERTY-LIST)
  (OR (SETQ PATHNAME-ORIGIN (STRING-SEARCH-CHAR #\CR STRING))
      (ERROR 'QFILE-PROTOCOL-VIOLATION
	     ':FORMAT-STRING "Illegally formatted string ~S"
	     ':FORMAT-ARGS (LIST STRING)))
  (DO ((I (FILE-CHECK-COMMAND OPERATION STRING)
	  (OR II (STRING-SEARCH-CHAR #\SP STRING (1+ I))))
       (II NIL)
       (PROP '((:CREATION-DATE) (:CREATION-TIME)
	       (:LENGTH . T) (:QFASLP . T) (:CHARACTERS . T)
	       (:AUTHOR . T) (:BYTE-SIZE . T) (:POINTER-BASE . T))
	     (CDR PROP))
       (IBASE 10.) (PACKAGE SI:PKG-USER-PACKAGE)
       (READTABLE SI:STANDARD-READTABLE)
       (TYPE) (DATE-START))
      ((OR (NULL I) ( I PATHNAME-ORIGIN) (NULL PROP)))
    (SETQ II NIL)
    (SETQ TYPE (CAAR PROP))
    (SELECTQ TYPE
      (:CREATION-DATE (SETQ DATE-START I))
      (:LENGTH (SETQ PROPERTY-LIST
		     (LIST* ':CREATION-DATE
			    (IF (NOT (VARIABLE-BOUNDP #'TIME:PARSE-UNIVERSAL-TIME))
				;;When bootstrapping, dates are recorded as strings.
				(SUBSTRING STRING DATE-START I)
				(PARSE-DIRECTORY-DATE-PROPERTY STRING DATE-START I))
			    PROPERTY-LIST))))
    (WHEN (CDAR PROP)
      (SETQ PROPERTY-LIST
	    (LIST* TYPE
		   (MULTIPLE-VALUE (NIL II)
		     (READ-FROM-STRING STRING NIL I))
		   PROPERTY-LIST))))
  (LIST* ':TRUENAME
	 (FUNCALL PATHNAME ':PARSE-TRUENAME
		  (SUBSTRING STRING (SETQ PATHNAME-ORIGIN (1+ PATHNAME-ORIGIN))
			     (STRING-SEARCH-CHAR #\CR STRING PATHNAME-ORIGIN)))
	 PROPERTY-LIST))


(DEFUN MULTIPLE-PLISTS-CHAOS (ACCESS-PATH PATHNAMES OPTIONS
			      &AUX FILE-LIST CONNECTION (TYPE ':CHARACTER))
  (LOOP FOR (IND OPT) ON OPTIONS BY 'CDDR
	DO (SELECTQ IND
	     (:CHARACTERS 
	      (SETQ TYPE (SELECTQ OPT
			   ((T) ':CHARACTER)
			   ((NIL) ':BINARY)
			   (:DEFAULT ':DEFAULT)
			   (OTHERWISE
			    (FERROR "~S is an invalid :CHARACTERS specification" OPT)))))
	     (OTHERWISE (FERROR "~S is not a known MULTIPLE-FILE-PLISTS option" IND))))
  (SETQ CONNECTION (HOST-UNIT-CONTROL-CONNECTION (FUNCALL ACCESS-PATH ':GET-HOST-UNIT)))
  (SETQ FILE-LIST (LOOP FOR PATHNAME IN PATHNAMES
			COLLECT (LIST PATHNAME NIL)))
  (LET ((FILES-TO-DO (COPYLIST FILE-LIST))	;not copytree!
	(OUTSTANDING-TRANSACTIONS NIL)
	(OUTSTANDING-COUNT 0))
    (UNWIND-PROTECT			;remove outstanding transactions on abonormal exit
      (PROG ()
	 QUEUE-SOME-TRANSACTIONS
	    (WHEN (OR (NULL FILES-TO-DO)	;nothing to transact
		      ( OUTSTANDING-COUNT 10.)	;too many queued already
		      (NOT (CHAOS:MAY-TRANSMIT CONNECTION)))	;can't queue anything
	      (GO WAIT-FOR-TRANSACTION))
	    (LET ((FILE-TO-DO (POP FILES-TO-DO))
		  (PKT (CHAOS:GET-PKT))
		  (TRANSACTION-ID (FILE-MAKE-TRANSACTION-ID NIL)))
	      (SETF (SECOND FILE-TO-DO) TRANSACTION-ID)
	      (SETQ OUTSTANDING-TRANSACTIONS (NCONC OUTSTANDING-TRANSACTIONS
						    (NCONS FILE-TO-DO)))
	      (INCF OUTSTANDING-COUNT)
	      (CHAOS:SET-PKT-STRING PKT TRANSACTION-ID
				    "  OPEN PROBE " TYPE #\CR
				    (FILE-STRING-FOR-HOST (FIRST FILE-TO-DO)) #\CR)
	      (CHAOS:SEND-PKT CONNECTION PKT %FILE-COMMAND-OPCODE))
	    (GO QUEUE-SOME-TRANSACTIONS)
	 WAIT-FOR-TRANSACTION
	    (WHEN (NULL OUTSTANDING-TRANSACTIONS)
	      (GO FINISHED))
	    (LET* ((OUTSTANDING (POP OUTSTANDING-TRANSACTIONS))
		   (TRANSACTION-ID (SECOND OUTSTANDING))
		   (PKT (FILE-WAIT-FOR-TRANSACTION TRANSACTION-ID CONNECTION "Probe"))
		   (PKT-STRING (CHAOS:PKT-STRING PKT))
		   (STRING (NSUBSTRING PKT-STRING (1+ (STRING-SEARCH-CHAR #\SP PKT-STRING))))
		   (FROM (1+ (STRING-SEARCH-SET '(#\SP #\CR) STRING)))
		   (SUCCESS (NOT (STRING-EQUAL "ERROR" STRING 0 FROM 5
					       (STRING-SEARCH-SET '(#\SP #\CR)
								  STRING FROM))))
		   (PROPERTY-LIST (AND SUCCESS (READ-FILE-PROPERTY-LIST-STRING
						 STRING "OPEN" (FIRST OUTSTANDING)))))
		(DECF OUTSTANDING-COUNT)
		(CHAOS:RETURN-PKT PKT)
		(SETF (CDR OUTSTANDING) PROPERTY-LIST))
	    (GO QUEUE-SOME-TRANSACTIONS)
	 FINISHED)
      ;; unwind protect clause
      (LOOP FOR (NIL TID) IN OUTSTANDING-TRANSACTIONS
	    DO (ABORT-PENDING-FILE-TRANSACTION TID))))
  FILE-LIST)

(DEFUN DIRECTORY-CHAOS (ACCESS-PATH *COMMAND-PATHNAME* OPTIONS
			&AUX (DELETED-P NIL) (FAST-P NIL) (DIRS-ONLY-P NIL)
			(NO-EXTRA-INFO NIL) DATA-CONN HOST-UNIT PKT SUCCESS STRING)
  (DO ((L OPTIONS (CDR L)))
      ((NULL L))
    (SELECTQ (CAR L)
      (:FAST (SETQ FAST-P T))
      (:NO-EXTRA-INFO (SETQ NO-EXTRA-INFO T))
      ;; This is for the :ALL-DIRECTORIES message
      (:DIRECTORIES-ONLY (SETQ DIRS-ONLY-P T))
      ;; This is for TOPS-20
      (:DELETED (SETQ DELETED-P T))
      (:NOERROR)
      (OTHERWISE (FERROR "~S is not a known DIRECTORY option" (CAR L)))))
  (MULTIPLE-VALUE (DATA-CONN HOST-UNIT)
    (FUNCALL ACCESS-PATH ':GET-DATA-CONNECTION ':INPUT))
  (UNWIND-PROTECT
    (LET ((*COMMAND-ERROR-ARGUMENTS* '(:OPERATION :DIRECTORY-LIST)))
      (MULTIPLE-VALUE (PKT STRING)
	(FUNCALL HOST-UNIT ':COMMAND NIL
		 `(:CREATE ,(DATA-INPUT-HANDLE DATA-CONN))
		 NIL "Directory"
		 "DIRECTORY"
		 (IF DELETED-P		" DELETED" "")
		 (IF FAST-P		" FAST" "")
		 (IF DIRS-ONLY-P	" DIRECTORIES-ONLY" "")
		 (IF NO-EXTRA-INFO	" NO-EXTRA-INFO" "")
		 #\CR (FILE-STRING-FOR-HOST *COMMAND-PATHNAME*) #\CR))
      (SETQ SUCCESS T))
    (OR SUCCESS
	(SELECTQ (DATA-STREAM DATA-CONN ':INPUT)
	  (:FAILED (SEND HOST-UNIT ':FREE-DATA-CONNECTION DATA-CONN ':INPUT))
	  ((T) (SETF (DATA-STREAM DATA-CONN ':INPUT) ':UNCLEAR)))))
  (FILE-CHECK-COMMAND "DIRECTORY" STRING)
  (CHAOS:RETURN-PKT PKT)
  (MAKE-INSTANCE 'FILE-DIRECTORY-STREAM
		 ':FILE-ACCESS-PATH ACCESS-PATH
		 ':HOST-UNIT HOST-UNIT
		 ':DATA-CONNECTION DATA-CONN
		 ':PATHNAME *COMMAND-PATHNAME*))

(DEFUN PROPERTIES-CHAOS (ACCESS-PATH *COMMAND-PATHNAME* STREAM-HANDLE
			&AUX DATA-CONN HOST-UNIT PKT SUCCESS STRING)
  (MULTIPLE-VALUE (DATA-CONN HOST-UNIT)
    (FUNCALL ACCESS-PATH ':GET-DATA-CONNECTION ':INPUT))
  (UNWIND-PROTECT
    (LET ((*COMMAND-ERROR-ARGUMENTS* '(:OPERATION :PROPERTIES)))
      (MULTIPLE-VALUE (PKT STRING)
	(IF STREAM-HANDLE
	    (FUNCALL HOST-UNIT ':COMMAND NIL
		     `(:CREATE ,(DATA-INPUT-HANDLE DATA-CONN))
		     NIL "Properties"
		     "PROPERTIES"
		     " "
		     STREAM-HANDLE)
	    (FUNCALL HOST-UNIT ':COMMAND NIL
		     `(:CREATE ,(DATA-INPUT-HANDLE DATA-CONN))
		     NIL "Properties"
		     "PROPERTIES"
		     #\CR (FILE-STRING-FOR-HOST *COMMAND-PATHNAME*) #\CR)))
      (SETQ SUCCESS T))
    (OR SUCCESS
	(SELECTQ (DATA-STREAM DATA-CONN ':INPUT)
	  (:FAILED (SEND HOST-UNIT ':FREE-DATA-CONNECTION DATA-CONN ':INPUT))
	  ((T) (SETF (DATA-STREAM DATA-CONN ':INPUT) ':UNCLEAR)))))
  (FILE-CHECK-COMMAND "PROPERTIES" STRING)
  (CHAOS:RETURN-PKT PKT)
  (MAKE-INSTANCE 'FILE-DIRECTORY-STREAM
		 ':FILE-ACCESS-PATH ACCESS-PATH
		 ':HOST-UNIT HOST-UNIT
		 ':DATA-CONNECTION DATA-CONN
		 ':PATHNAME *COMMAND-PATHNAME*))

(COMPILE-FLAVOR-METHODS HOST-UNIT)

(DEFFLAVOR FILE-STREAM-MIXIN
	(HOST-UNIT
	 STATUS)
	(%FILE-STREAM-STORED-FILE-ELEMENT-TYPE-MIXIN
	 FLAVOR:PROPERTY-LIST-MIXIN SI:FILE-STREAM-MIXIN)
  (:INITABLE-INSTANCE-VARIABLES HOST-UNIT)
  (:INIT-KEYWORDS :FILE-HANDLE))

(DEFMETHOD (:QFASLP FILE-STREAM-MIXIN) ()
  (CL:GETF FLAVOR:PROPERTY-LIST ':QFASLP))

(DEFMETHOD (:TRUENAME FILE-STREAM-MIXIN) ()
  (CL:GETF FLAVOR:PROPERTY-LIST ':TRUENAME))

(DEFMETHOD (:LENGTH FILE-STREAM-MIXIN) ()
  (CL:GETF FLAVOR:PROPERTY-LIST ':LENGTH))

;;; Flavors that really have an open connection
;;; STATUS is one of
;;;  :OPEN - a file is currently open on this channel
;;;  :CLOSED - no file is open, but the channel exists
;;;  :EOF - a file is open, but is at its end (no more data available).
;;;  :SYNC-MARKED - a mark that was requested has been received
;;;  :ASYNC-MARKED - an asynchronous (error) mark has been received
(DEFFLAVOR FILE-DATA-STREAM-MIXIN
	((STATUS ':OPEN)
	 DATA-CONNECTION
	 FILE-HANDLE
	 CHAOS:CONNECTION)
	(FILE-STREAM-MIXIN SI:FILE-DATA-STREAM-MIXIN)
  (:SETTABLE-INSTANCE-VARIABLES STATUS)
  (:GETTABLE-INSTANCE-VARIABLES FILE-HANDLE)
  (:INITABLE-INSTANCE-VARIABLES DATA-CONNECTION))

(DEFFLAVOR FILE-INPUT-STREAM-MIXIN
	(CHAOS:INPUT-PACKET)
	(FILE-DATA-STREAM-MIXIN 
	 SI:AREG-CACHING-BUFFERED-INPUT-STREAM-MIXIN
	 SI:INPUT-FILE-STREAM-MIXIN))

(DEFFLAVOR FILE-OUTPUT-STREAM-MIXIN
	()
	(FILE-DATA-STREAM-MIXIN
	 SI:AREG-CACHING-BUFFERED-OUTPUT-STREAM-MIXIN
	 SI:OUTPUT-FILE-STREAM-MIXIN)
  (:REQUIRED-METHODS :SEND-PKT-BUFFER))

(DEFMETHOD (MAKE-INSTANCE FILE-DATA-STREAM-MIXIN) (&REST IGNORE)
  (SEND SELF ':BIND-INITIAL-FILE-HANDLE))

(DEFMETHOD (:BIND-INITIAL-FILE-HANDLE FILE-DATA-STREAM-MIXIN) ()
  (SEND SELF ':BIND-DATA-CONNECTION))

(DEFMETHOD (:BIND-DATA-CONNECTION FILE-DATA-STREAM-MIXIN) ()
  (LET ((DIRECTION (FUNCALL-SELF ':DIRECTION)))
    (SETF (DATA-STREAM DATA-CONNECTION DIRECTION) SELF)
    (SETQ FILE-HANDLE (DATA-HANDLE DATA-CONNECTION DIRECTION)
	  CHAOS:CONNECTION (DATA-CONNECTION DATA-CONNECTION))))

(DEFMETHOD (MAKE-INSTANCE FILE-OUTPUT-STREAM-MIXIN) (&REST IGNORE)
  (LET ((POINTER-BASE (SEND SELF ':GET ':POINTER-BASE)))
    (IF (AND POINTER-BASE
	     (PLUSP POINTER-BASE))
	(SEND SELF ':SET-OUTPUT-POINTER-BASE POINTER-BASE))))

;;; Stream version of host unit :COMMAND, supplies file handle itself.
;;; MARK-P is T or NIL or :INPUT or :OUTPUT.
(DEFMETHOD (:COMMAND FILE-DATA-STREAM-MIXIN) (MARK-P WHOSTATE COM &REST STRINGS
						     &AUX PKT STRING)
  (DECLARE (VALUES STRING SUCCESS))
  (MULTIPLE-VALUE (PKT STRING)
    (LEXPR-FUNCALL HOST-UNIT ':COMMAND MARK-P SELF NIL WHOSTATE COM STRINGS))
  (PROG1 (STRING-APPEND STRING)
	 (CHAOS:RETURN-PKT PKT)))

(DEFMETHOD (:CLOSE FILE-DATA-STREAM-MIXIN) (&OPTIONAL ABORTP)
  (LOOP DOING
    ;; When sending the close command discovers that the control connection
    ;; has gone away, the Debugger Resume command will come back here instead
    ;; of querying the user about attempting to throw through an unwind-protect.
    (CATCH-ERROR-RESTART-IF (OR ABORTP (EQ (SEND SELF :DIRECTION) :INPUT))
			    ((ERROR) "Close ~A in abort mode."
				     (SEND SELF :PATHNAME))
      (RETURN
	(COND ((EQ STATUS ':CLOSED) NIL)
	      ((NEQ (CHAOS:STATE (HOST-UNIT-CONTROL-CONNECTION HOST-UNIT)) 'CHAOS:OPEN-STATE)
	       (SETQ STATUS ':CLOSED)
	       T)
	      (T
	       (FUNCALL-SELF ':REAL-CLOSE ABORTP)))))
    (SETQ ABORTP T)))

(DEFMETHOD (:INPUT-SYNC-MARK-NEEDED-P FILE-INPUT-STREAM-MIXIN) ()
  (AND DATA-CONNECTION
       (EQ (DATA-STREAM DATA-CONNECTION ':INPUT) SELF)
       ':INPUT))


(DEFMETHOD (:REAL-CLOSE FILE-INPUT-STREAM-MIXIN) (ABORT-P)
  (LET ((*COMMAND-PATHNAME* (SEND SELF ':PATHNAME)))
    (WITH-STACK-LIST (*COMMAND-ERROR-ARGUMENTS*
		       ':OPERATION ':CLOSE
		       ':STREAM SELF)
      (UNWIND-PROTECT
	(PROGN (IF (NEQ STATUS ':EOF)
		   (SEND SELF ':COMMAND (SEND SELF ':INPUT-SYNC-MARK-NEEDED-P)
			 "Close" "CLOSE")
		   (CHAOS:RETURN-PKT
		     (SEND HOST-UNIT ':COMMAND
			   (SEND SELF ':INPUT-SYNC-MARK-NEEDED-P)
			   SELF NIL "Close" "CLOSE")))
	       (IF DATA-CONNECTION		;.. for DIRECT may not have data connection...
		   (SEND HOST-UNIT ':FREE-DATA-CONNECTION DATA-CONNECTION ':INPUT))
	       (SETQ STATUS ':CLOSED))
	(UNLESS (OR ABORT-P (EQ STATUS ':CLOSED))
	  (SEND SELF ':CLOSE ':ABORT))))))

(DEFUN-IN-FLAVOR (FILE-PROCESS-ASYNC-MARK FILE-DATA-STREAM-MIXIN) (PKT)
    (LET ((STRING (NSUBSTRING (CHAOS:PKT-STRING PKT)
			      (1+ (STRING-SEARCH-CHAR #\SP (CHAOS:PKT-STRING PKT))))))
      (FILE-SIGNAL STRING (SEND SELF ':PATHNAME) ':STREAM SELF))
    ;; If user says to continue, attempt to do so.
    (FUNCALL-SELF ':CONTINUE))

(DEFUN-IN-FLAVOR (FILE-PROCESS-OUTPUT-ASYNC-MARK FILE-OUTPUT-STREAM-MIXIN) ()
  (LET ((PKT (CAR (REMPROP (LOCF FLAVOR:PROPERTY-LIST) 'ASYNC-MARK-PKT))))
    (OR PKT (FERROR "Output stream ~S in ASYNC-MARKED state, but no async mark pkt" SELF))
    (UNWIND-PROTECT
      (FILE-PROCESS-ASYNC-MARK PKT)
      (CHAOS:RETURN-PKT PKT))))

(DEFMETHOD (:SEND-OUTPUT-BUFFER FILE-OUTPUT-STREAM-MIXIN) (&REST ARGS)
  (LOOP DOING
    (SELECTQ STATUS
      ((:OPEN :EOF)
       (PROCESS-WAIT "File Net Out"
		     #'(LAMBDA (STAT CONNECTION)
			 (OR (EQ (CAR STAT)':ASYNC-MARKED)
			     (CHAOS:MAY-TRANSMIT CONNECTION)
			     (NEQ (CHAOS:STATE CONNECTION) 'CHAOS:OPEN-STATE)))
		     (LOCF STATUS) CHAOS:CONNECTION)
       (AND (NEQ (CHAOS:STATE CHAOS:CONNECTION) 'CHAOS:OPEN-STATE)
	    (CHAOS:BAD-CHAOS-CONNECTION-STATE CHAOS:CONNECTION "transmit on"))
       (AND (NEQ STATUS ':ASYNC-MARKED)
	    (RETURN (LEXPR-FUNCALL-SELF ':SEND-PKT-BUFFER ARGS))))
      (:ASYNC-MARKED
       (FILE-PROCESS-OUTPUT-ASYNC-MARK))
      (OTHERWISE
       (FERROR "Attempt to write to ~S, which is in illegal state ~S" SELF STATUS)))))

;;; Sent from inside the interrupt function, change our status and remember error message.
(DEFMETHOD (:ASYNC-MARK FILE-OUTPUT-STREAM-MIXIN) (PKT)
  ;; without-interrupts in case status is already :async-marked, we
  ;; remove the old packet, get descheduled, and the other process tries
  ;; to process the (now) non-existent packet
  (WITHOUT-INTERRUPTS
    ;; return old pkt if there was one (Unix happens to send many, Many,
    ;; MANY packets when it runs out of file system space.)
    (LET ((PKT (CAR (REMPROP (LOCF FLAVOR:PROPERTY-LIST) 'ASYNC-MARK-PKT))))
      (WHEN PKT (CHAOS:RETURN-PKT PKT)))
    (SETF (CL:GETF FLAVOR:PROPERTY-LIST 'ASYNC-MARK-PKT) PKT)
    (SETQ STATUS ':ASYNC-MARKED)))

(DEFUN-IN-FLAVOR (FILE-NEXT-READ-PKT FILE-INPUT-STREAM-MIXIN) (NO-HANG-P FOR-SYNC-MARK-P)
  (SELECTQ (IF FOR-SYNC-MARK-P ':EOF STATUS)
    ((:OPEN :EOF)
     (LET ((PKT (CHAOS:GET-NEXT-PKT CHAOS:CONNECTION NO-HANG-P)))
       (COND (PKT
	      (SELECT (CHAOS:PKT-OPCODE PKT)
		;; Received some sort of data, return it
		((%FILE-BINARY-OPCODE %FILE-CHARACTER-OPCODE)
		 PKT)

		;; No data, but a synchronous mark
		(%FILE-SYNCHRONOUS-MARK-OPCODE
		 (SETQ STATUS ':SYNC-MARKED)
		 (CHAOS:RETURN-PKT PKT)
		 NIL)

		;; Received an asynchronous mark, meaning some sort of error condition
		(%FILE-ASYNCHRONOUS-MARK-OPCODE
		 (SETQ STATUS ':ASYNC-MARKED)
		 (OR FOR-SYNC-MARK-P (FILE-PROCESS-ASYNC-MARK PKT))
		 (CHAOS:RETURN-PKT PKT)
		 NIL)

		;; EOF received, change channel state and return
		(%FILE-EOF-OPCODE
		 (SETQ STATUS ':EOF)
		 (CHAOS:RETURN-PKT PKT)
		 NIL)

		;; Connection closed or broken with message
		((CHAOS:CLS-OP CHAOS:LOS-OP)
		 (ERROR (IF (= (CHAOS:PKT-OPCODE PKT) CHAOS:CLS-OP)
			    'CHAOS:CHAOS-CONNECTION-CLOSED
			    'CHAOS:CHAOS-CONNECTION-LOST)
			':CONNECTION CHAOS:CONNECTION ':REASON (CHAOS:PKT-STRING PKT)))

		;; Not a recognized opcode, huh?
		(OTHERWISE
		 (ERROR 'CHAOS:UNKNOWN-PKT-OPCODE ':PKT PKT
			':CONNECTION CHAOS:CONNECTION)))))))
    (:CLOSED
     (FERROR "Attempt to read from ~S, which is closed" SELF))
    ((:ASYNC-MARKED :SYNC-MARKED)
     (FERROR "Attempt to read from ~S, which is in a marked state" SELF))
    (OTHERWISE
     (FERROR "Attempt to read from ~S, which is in illegal state ~S" SELF STATUS))))

(DEFMETHOD (:READ-UNTIL-SYNCHRONOUS-MARK FILE-INPUT-STREAM-MIXIN) ()
  (LOOP UNTIL (EQ STATUS ':SYNC-MARKED)
	AS PKT = (FILE-NEXT-READ-PKT NIL T)
	WHEN PKT DO (CHAOS:RETURN-PKT PKT)
	FINALLY (SETQ STATUS ':OPEN)))

(DEFMETHOD (:GET-NEXT-INPUT-PKT FILE-INPUT-STREAM-MIXIN) (&OPTIONAL NO-HANG-P)
  (LOOP WHEN (EQ STATUS ':EOF) RETURN NIL
	THEREIS (SETQ CHAOS:INPUT-PACKET (FILE-NEXT-READ-PKT NO-HANG-P NIL))))

(DEFMETHOD (:WRITE-SYNCHRONOUS-MARK FILE-OUTPUT-STREAM-MIXIN) ()
  (LET-GLOBALLY ((STATUS ':EOF))		;In case :ASYNC-MARK now
    (FUNCALL-SELF ':FORCE-OUTPUT))		;Send any partial buffer
  (CHAOS:SEND-PKT CHAOS:CONNECTION (CHAOS:GET-PKT) %FILE-SYNCHRONOUS-MARK-OPCODE))

(DEFMETHOD (:FINISH FILE-OUTPUT-STREAM-MIXIN) ()
  (SETQ FLAVOR:PROPERTY-LIST
	(NCONC (READ-FILE-PROPERTY-LIST-STRING
		 (SEND SELF ':COMMAND
		       (AND DATA-CONNECTION
			    (SELECTQ (SEND SELF ':DIRECTION)
			      (:BIDIRECTIONAL ':OUTPUT)
			      (T (SEND SELF ':DIRECTION))))
		       "Finish" "FINISH")
		 "FINISH" SI:PATHNAME)
	       FLAVOR:PROPERTY-LIST))
  T)



(DEFMETHOD (:OUTPUT-SYNC-MARK-NEEDED-P FILE-OUTPUT-STREAM-MIXIN) ()
  (AND DATA-CONNECTION
       (EQ (DATA-STREAM DATA-CONNECTION ':OUTPUT) SELF)
       ':OUTPUT))


(DEFMETHOD (:REAL-CLOSE FILE-OUTPUT-STREAM-MIXIN) (ABORT-P &AUX STRING)
  (LET ((FREE-DATA-CONNECTION (NOT (NULL DATA-CONNECTION)))
	(MARK-P (SEND SELF ':OUTPUT-SYNC-MARK-NEEDED-P)))
    ;; Unwind-protect here would be WRONG.  If you don't finish
    ;; CLEANLY, you have no right to free the data connection or
    ;; for that matter, call it :CLOSED.
    ;; Closing an open output channel.  Finish sending the data.
    (AND (EQ STATUS ':OPEN) MARK-P (SEND SELF ':EOF))
    ;; If aborting out of a file-writing operation before normal :CLOSE,
    ;; delete the incomplete file.  Don't worry if it gets an error.
    (SETQ STATUS ':CLOSE-IN-PROGRESS)
    (UNWIND-PROTECT
      (LET ((*COMMAND-PATHNAME* (SEND SELF ':PATHNAME)))
	(WITH-STACK-LIST (*COMMAND-ERROR-ARGUMENTS* ':STREAM SELF)
	  (WHEN ABORT-P
	    (SEND SELF ':COMMAND NIL "Delete" "DELETE"))
	  (SETQ STRING (SEND SELF ':COMMAND MARK-P "Close" "CLOSE")))
	(SETQ FLAVOR:PROPERTY-LIST
	      (NCONC (READ-FILE-PROPERTY-LIST-STRING STRING "CLOSE" SI:PATHNAME)
		     FLAVOR:PROPERTY-LIST))
	(WHEN FREE-DATA-CONNECTION
	  (SEND HOST-UNIT ':FREE-DATA-CONNECTION DATA-CONNECTION
		(SEND SELF ':DIRECTION)))
	(SETQ STATUS ':CLOSED))
      ;; If you unwind the thing, force it closed.
      (UNLESS (OR ABORT-P (EQ STATUS ':CLOSED))
	(SEND SELF ':CLOSE ':ABORT)))))

(DEFMETHOD (:DELETE FILE-DATA-STREAM-MIXIN) (&OPTIONAL (ERROR-P T))
  ;;; DON'T use the QFILE "DELETE <stream>" command... That has to be reserved
  ;;; for signalling aborting close to the server, since QFILE has no other way
  ;;; to convey that, and multiplexing that in that way would cause the foreign
  ;;; file system not to know which action to take in general.
  (SEND SELF ':CHANGE-PROPERTIES ERROR-P :DELETED T)
  T)

(DEFMETHOD (:RENAME FILE-DATA-STREAM-MIXIN) (NEW-NAME &OPTIONAL (ERROR-P T))
  (SELECTQ STATUS
    ((:OPEN :EOF :SYNC-MARKED :ASYNC-MARKED)
     (LET ((*COMMAND-PATHNAME* (SEND SELF ':PATHNAME)))
       (WITH-STACK-LIST (*COMMAND-ERROR-ARGUMENTS* ':STREAM SELF
						   ':OPERATION ':RENAME
						   ':NEW-PATHNAME NEW-NAME)
	 (CONDITION-CASE-IF (NOT ERROR-P) (.ERROR.)
	     (FUNCALL-SELF ':COMMAND NIL "Rename" "RENAME" #\CR
			   (FILE-STRING-FOR-HOST NEW-NAME))
	   (FILE-OPERATION-FAILURE .ERROR.)
	   (:NO-ERROR (SETQ SI:PATHNAME NEW-NAME)
		      (WHEN TV:WHO-LINE-FILE-STATE-SHEET
			(SEND TV:WHO-LINE-FILE-STATE-SHEET ':CLOBBERED))
		      NIL)))))
    (OTHERWISE (FERROR "~S in illegal state for rename" SELF))))

(DEFMETHOD (:PROPERTIES FILE-DATA-STREAM-MIXIN) ()
  (SELECTQ STATUS
    ((:OPEN :EOF :SYNC-MARKED :ASYNC-MARKED)
     (SEND HOST-UNIT ':STREAM-PROPERTIES (SEND SELF ':PATHNAME) FILE-HANDLE))
    (OTHERWISE (FERROR "~S in illegal state for file properties" SELF))))

(DEFMETHOD (:CHANGE-PROPERTIES FILE-DATA-STREAM-MIXIN)
	   (ERROR-P &REST PROPERTIES)
  (SELECTQ STATUS
    ((:OPEN :EOF :SYNC-MARKED :ASYNC-MARKED)
     (LET ((*COMMAND-PATHNAME* (SEND SELF ':PATHNAME)))
       (WITH-STACK-LIST (*COMMAND-ERROR-ARGUMENTS*
			  ':STREAM SELF
			  ':OPERATION ':CHANGE-PROPERTIES)
	 (CONDITION-CASE-IF (NOT ERROR-P) (.ERROR.)
	     (FUNCALL-SELF ':COMMAND NIL "Change Properties"
			   (CHANGE-PROPERTIES-STRING PROPERTIES))
	   (FILE-OPERATION-FAILURE .ERROR.)))))
    (OTHERWISE (FERROR "~S in illegal state for change properties" SELF))))

(DEFMETHOD (:CONTINUE FILE-DATA-STREAM-MIXIN) (&AUX SUCCESS)
  (COND ((EQ STATUS ':ASYNC-MARKED)
	 (SETF STATUS ':OPEN)
	 (UNWIND-PROTECT
	   (PROGN (FUNCALL-SELF ':COMMAND NIL "Continue" "CONTINUE")
		  (SETQ SUCCESS T))
	   (OR SUCCESS (SETQ STATUS ':ASYNC-MARKED))))))

(DEFMETHOD (:SET-BUFFER-POINTER FILE-DATA-STREAM-MIXIN) (NEW-POINTER)
  (SELECTQ STATUS
    ((:OPEN :EOF)
     (AND (EQ STATUS ':EOF) (SETQ STATUS ':OPEN))
     (FUNCALL-SELF ':COMMAND
		   (COND ((NULL DATA-CONNECTION) NIL)	;No mark
			 ((EQ (SEND SELF ':DIRECTION) ':BIDIRECTIONAL) ':OUTPUT)
			 (T T))			;Let :COMMAND figure it out
		   "File Position" "FILEPOS " (FORMAT NIL "~D" NEW-POINTER))
     NEW-POINTER)
    (OTHERWISE
     (FERROR ":SET-POINTER attempted on ~S which is in state ~S" SELF STATUS))))

(DEFMETHOD (:FILE-FINISH FILE-OUTPUT-STREAM-MIXIN) ()
  (DO () ((CHAOS:CONN-FINISHED-P CHAOS:CONNECTION))
    (PROCESS-WAIT "File Finish"
		  #'(LAMBDA (CONN STAT)
		      (OR (CHAOS:CONN-FINISHED-P CONN)
			  (EQ (CAR STAT) ':ASYNC-MARKED)))
		  CHAOS:CONNECTION (LOCF STATUS))
    (AND (EQ STATUS ':ASYNC-MARKED) (FILE-PROCESS-OUTPUT-ASYNC-MARK))))

(DEFMETHOD (:EOF FILE-OUTPUT-STREAM-MIXIN) ()
  (FUNCALL-SELF ':FORCE-OUTPUT)
  (CHAOS:SEND-PKT CHAOS:CONNECTION (CHAOS:GET-PKT) CHAOS:EOF-OP)
  (SETQ STATUS ':EOF)
  (FUNCALL-SELF ':FILE-FINISH))

(DEFFLAVOR FILE-CHARACTER-STREAM-MIXIN () (FILE-DATA-STREAM-MIXIN))

(DEFFLAVOR FILE-BINARY-STREAM-MIXIN () (FILE-DATA-STREAM-MIXIN))

(DEFMETHOD (:SET-BYTE-SIZE FILE-BINARY-STREAM-MIXIN) (NEW-BYTE-SIZE)
  (CHECK-ARG NEW-BYTE-SIZE (AND (FIXP NEW-BYTE-SIZE)
				(> NEW-BYTE-SIZE 0) ( NEW-BYTE-SIZE 16.))
	     "A positive number less than or equal to 16.")
  (FUNCALL-SELF ':COMMAND T "Set Byte Size" "SET-BYTE-SIZE "
		(FORMAT NIL "~D ~D" NEW-BYTE-SIZE (FUNCALL-SELF ':READ-POINTER)))
  NEW-BYTE-SIZE)



(DEFFLAVOR FILE-DIRECT-STREAM-MIXIN
	()
	()
  (:METHOD-COMBINATION :DIRECT-DATA-CONNECTION-IN-USE-P :OR)
  (:REQUIRED-FLAVORS FILE-STREAM-MIXIN FILE-DATA-STREAM-MIXIN))


(DEFMETHOD (MAKE-INSTANCE FILE-DIRECT-STREAM-MIXIN) (&KEY ((:FILE-HANDLE THE-FILE-HANDLE))
						     &ALLOW-OTHER-KEYS)
  (SEND SELF :PUTPROP T ':DIRECT)
  (SETQ FILE-HANDLE
	(OR THE-FILE-HANDLE
	    (FERROR "No direct access file handle."))))

(DEFMETHOD (:BIND-INITIAL-FILE-HANDLE FILE-DIRECT-STREAM-MIXIN) ())

(DEFMETHOD (:CHECK-FREE-DATA-CONNECTION FILE-DIRECT-STREAM-MIXIN) ()
  (IF DATA-CONNECTION
      (UNLESS (SEND SELF ':DIRECT-DATA-CONNECTION-IN-USE-P)
	(SEND HOST-UNIT ':FREE-DATA-CONNECTION DATA-CONNECTION (SEND SELF ':DIRECTION))
	(SETQ DATA-CONNECTION NIL))))

(DEFMETHOD (:DIRECT-ENSURE-DATA-CONNECTION FILE-DIRECT-STREAM-MIXIN) ()
  (WHEN (NULL DATA-CONNECTION)
    (LET ((DIRECTION (SEND SELF ':DIRECTION)))
      (SETQ DATA-CONNECTION
	    (SEND HOST-UNIT
		  ':GET-DATA-CONNECTION DIRECTION))	;Works for :BIDIRECTIONAL
      (COND ((EQ DIRECTION ':BIDIRECTIONAL)
	     (SETF (DATA-STREAM DATA-CONNECTION ':OUTPUT) SELF)
	     (SETF (DATA-STREAM DATA-CONNECTION ':INPUT) SELF))
	    (T (SETF (DATA-STREAM DATA-CONNECTION DIRECTION) SELF)))
      (SETQ CHAOS:CONNECTION (DATA-CONNECTION DATA-CONNECTION)))))

(DEFFLAVOR FILE-DIRECT-INPUT-STREAM-MIXIN
	((INPUT-FILE-HANDLE NIL))
	(FILE-DIRECT-STREAM-MIXIN)
  (:REQUIRED-FLAVORS FILE-STREAM-MIXIN FILE-DATA-STREAM-MIXIN
   SI:INPUT-POINTER-REMEMBERING-MIXIN))


(DEFMETHOD (:INPUT-SYNC-MARK-NEEDED-P FILE-DIRECT-INPUT-STREAM-MIXIN) ()
  (AND INPUT-FILE-HANDLE ':INPUT))


(DEFMETHOD (:READ-BYTES FILE-DIRECT-INPUT-STREAM-MIXIN) (NBYTES &OPTIONAL FILEPOS)
  (SELECTQ STATUS
    ((:OPEN :EOF :SYNC-MARKED :ASYNC-MARKED)
     (IF (EQ STATUS ':EOF)
	 (SETQ STATUS ':OPEN))
     (SEND SELF ':DIRECT-ENSURE-DATA-CONNECTION)
     (SETQ INPUT-FILE-HANDLE (DATA-HANDLE DATA-CONNECTION ':INPUT))
     (LET ((*COMMAND-PATHNAME* (SEND SELF ':PATHNAME)))
       (WITH-STACK-LIST (*COMMAND-ERROR-ARGUMENTS* ':STREAM SELF ':OPERATION ':READ-BYTES)
	 (SEND SELF ':COMMAND NIL "Read Bytes" "READ"
	       (FORMAT NIL " ~D " NBYTES) INPUT-FILE-HANDLE
	       (IF FILEPOS
		   (FORMAT NIL " ~D" FILEPOS)
		   ""))))
     (IF FILEPOS (SETQ SI:INPUT-POINTER-BASE FILEPOS)))
    (OTHERWISE (FERROR "~S in illegal state ~S for READ-BYTES" STATUS SELF))))

(DEFMETHOD (:READ-LAST-BYTE FILE-DIRECT-INPUT-STREAM-MIXIN) ()
  (WHEN INPUT-FILE-HANDLE
    (SETQ INPUT-FILE-HANDLE NIL)
    (SEND SELF ':CHECK-FREE-DATA-CONNECTION)))

(DEFMETHOD (:DIRECT-DATA-CONNECTION-IN-USE-P FILE-DIRECT-INPUT-STREAM-MIXIN) ()
  INPUT-FILE-HANDLE)

(DEFMETHOD (:ABORT-DIRECT-READ FILE-DIRECT-INPUT-STREAM-MIXIN) ()
  (LET ((*COMMAND-PATHNAME* (SEND SELF ':PATHNAME)))
    (WITH-STACK-LIST (*COMMAND-ERROR-ARGUMENTS* ':STREAM SELF
						':OPERATION ':READ-ABORT)
      (SEND SELF ':COMMAND ':INPUT "Read Abort" "ABORT" " " INPUT-FILE-HANDLE)))
  (SETQ INPUT-FILE-HANDLE NIL))

(DEFFLAVOR FILE-DIRECT-OUTPUT-STREAM-MIXIN
	((OUTPUT-FILE-HANDLE NIL))
	(FILE-DIRECT-STREAM-MIXIN)
  (:REQUIRED-FLAVORS FILE-STREAM-MIXIN FILE-DATA-STREAM-MIXIN
   SI:OUTPUT-POINTER-REMEMBERING-MIXIN))

(DEFMETHOD (:OUTPUT-SYNC-MARK-NEEDED-P FILE-DIRECT-OUTPUT-STREAM-MIXIN) ()
  (AND OUTPUT-FILE-HANDLE ':OUTPUT))

(DEFMETHOD (:DIRECT-DATA-CONNECTION-IN-USE-P FILE-DIRECT-OUTPUT-STREAM-MIXIN) ()
  OUTPUT-FILE-HANDLE)

(DEFMETHOD (:NEW-OUTPUT-BUFFER FILE-DIRECT-OUTPUT-STREAM-MIXIN :BEFORE) ()
  (SEND SELF ':DIRECT-OUTPUT))

(DEFMETHOD (:SET-BUFFER-POINTER FILE-DIRECT-OUTPUT-STREAM-MIXIN :AFTER) (IGNORE)
  (IF (EQ STATUS ':SYNC-MARKED)
      (SETQ STATUS ':OPEN)))

(DEFMETHOD (:GET-OLD-DATA FILE-DIRECT-OUTPUT-STREAM-MIXIN) (IGNORE OFFSET)
  (IF (= OFFSET (IF (SEND SELF ':CHARACTERS) 2 1))
      NIL
      (FERROR ":GET-OLD-DATA invoked for ~S" SELF)))

(DEFMETHOD (:SET-POINTER FILE-DIRECT-OUTPUT-STREAM-MIXIN :BEFORE) (IGNORE)
  (SEND SELF ':SEND-CURRENT-OUTPUT-BUFFER NIL))	;Never let POINTER-REMEMBERer optimize.

(DEFMETHOD (:DIRECT-OUTPUT FILE-DIRECT-OUTPUT-STREAM-MIXIN) ()
  (WHEN (NULL OUTPUT-FILE-HANDLE)
    (SELECTQ STATUS
      ((:OPEN :EOF :SYNC-MARKED :ASYNC-MARKED)
       (IF (EQ STATUS ':EOF)
	   (SETQ STATUS ':OPEN))
       (SEND SELF ':DIRECT-ENSURE-DATA-CONNECTION)
       (SETQ OUTPUT-FILE-HANDLE (DATA-HANDLE DATA-CONNECTION ':OUTPUT))
       (LET ((*COMMAND-PATHNAME* (SEND SELF ':PATHNAME)))
	 (WITH-STACK-LIST (*COMMAND-ERROR-ARGUMENTS* ':STREAM SELF
						     ':OPERATION ':DIRECT-OUTPUT)
	   (SEND SELF ':COMMAND NIL "Direct Output" "DIRECT-OUTPUT" " " OUTPUT-FILE-HANDLE))))
      (OTHERWISE (FERROR "~S in illegal state READ-BYTES" SELF)))))

(DEFMETHOD (:UNDIRECT-OUTPUT FILE-DIRECT-OUTPUT-STREAM-MIXIN) ()
  (SEND SELF ':SEND-CURRENT-OUTPUT-BUFFER NIL)	;Just to make sure
  (WHEN OUTPUT-FILE-HANDLE
    (SETQ OUTPUT-FILE-HANDLE NIL)
    (LET ((*COMMAND-PATHNAME* (SEND SELF ':PATHNAME)))
      (WITH-STACK-LIST (*COMMAND-ERROR-ARGUMENTS* ':STREAM SELF
						  ':OPERATION ':DIRECT-OUTPUT)
	(SEND SELF ':COMMAND ':OUTPUT "Direct Output" "DIRECT-OUTPUT")))     ;mark wait, too.
    (IF (EQ STATUS ':SYNC-MARKED)
	(SETQ STATUS ':OPEN))
    (SEND SELF ':CHECK-FREE-DATA-CONNECTION)))

(DEFWHOPPER (:EOF FILE-DIRECT-OUTPUT-STREAM-MIXIN) ()
  (IF OUTPUT-FILE-HANDLE			;Punt if no data connection
      (CONTINUE-WHOPPER)))

(DEFFLAVOR FILE-DIRECT-BIDIRECTIONAL-STREAM-MIXIN
	()
	()
  (:REQUIRED-FLAVORS
   FILE-DIRECT-INPUT-STREAM-MIXIN FILE-DIRECT-OUTPUT-STREAM-MIXIN
   SI:BUFFERED-INPUT-STREAM SI:BUFFERED-OUTPUT-STREAM
   SI:INPUT-POINTER-REMEMBERING-MIXIN SI:OUTPUT-POINTER-REMEMBERING-MIXIN
   FILE-DATA-STREAM-MIXIN))

(DEFMETHOD (:NEXT-INPUT-BUFFER FILE-DIRECT-BIDIRECTIONAL-STREAM-MIXIN :BEFORE) (&REST IGNORE)
  (IF OUTPUT-FILE-HANDLE
      (SEND SELF ':UNDIRECT-OUTPUT)))

(DEFMETHOD (:READ-BYTES FILE-DIRECT-BIDIRECTIONAL-STREAM-MIXIN :BEFORE) (&REST IGNORE)
  (IF OUTPUT-FILE-HANDLE
      (SEND SELF ':UNDIRECT-OUTPUT)))

(DEFMETHOD (:SET-POINTER FILE-DIRECT-BIDIRECTIONAL-STREAM-MIXIN) (POINTER)
  (WHEN INPUT-FILE-HANDLE
    (SEND SELF ':ABORT-DIRECT-READ))
  (SEND SELF ':DISCARD-CURRENT-INPUT-BUFFER)
  (SETQ SI:INPUT-POINTER-BASE POINTER)
  (SEND SELF ':CHECK-FREE-DATA-CONNECTION))
;;;Hairy bidirectional stream mixin daemon will actually set the pointer

(DEFMETHOD (:REAL-CLOSE FILE-DIRECT-INPUT-STREAM-MIXIN :BEFORE) (IGNORE)
  (IF INPUT-FILE-HANDLE (SEND SELF ':ABORT-DIRECT-READ)))

(DEFFLAVOR FILE-INPUT-CHARACTER-STREAM-MIXIN ()
	   (FILE-INPUT-STREAM-MIXIN FILE-CHARACTER-STREAM-MIXIN))

(DEFFLAVOR FILE-INPUT-BINARY-STREAM-MIXIN ()
	   (FILE-INPUT-STREAM-MIXIN FILE-BINARY-STREAM-MIXIN))

(DEFFLAVOR FILE-OUTPUT-CHARACTER-STREAM-MIXIN ()
	   (FILE-OUTPUT-STREAM-MIXIN FILE-CHARACTER-STREAM-MIXIN)
  (:REQUIRED-FLAVORS CHAOS:CHARACTER-OUTPUT-STREAM-MIXIN))

(DEFFLAVOR FILE-OUTPUT-BINARY-STREAM-MIXIN ()
	   (FILE-OUTPUT-STREAM-MIXIN FILE-BINARY-STREAM-MIXIN)
  (:REQUIRED-FLAVORS CHAOS:BINARY-OUTPUT-STREAM-MIXIN))

(DEFMETHOD (:SEND-PKT-BUFFER FILE-OUTPUT-CHARACTER-STREAM-MIXIN) (ARRAY LIMIT END-OF-RECORD)
  (IGNORE ARRAY END-OF-RECORD)
  (CHAOS:SEND-CHARACTER-PKT LIMIT))

(DEFMETHOD (:SEND-PKT-BUFFER FILE-OUTPUT-BINARY-STREAM-MIXIN) (ARRAY LIMIT END-OF-RECORD)
  (IGNORE ARRAY END-OF-RECORD)
  (CHAOS:SEND-BINARY-PKT LIMIT))

(DEFFLAVOR FILE-INPUT-CHARACTER-STREAM
	()
	(FILE-INPUT-CHARACTER-STREAM-MIXIN SI:INPUT-FILE-STREAM-MIXIN
	 CHAOS:CHARACTER-INPUT-STREAM-MIXIN SI:BUFFERED-INPUT-CHARACTER-STREAM
	 SI:INPUT-POINTER-REMEMBERING-MIXIN))

(DEFFLAVOR FILE-OUTPUT-CHARACTER-STREAM
	()
	(FILE-OUTPUT-CHARACTER-STREAM-MIXIN SI:OUTPUT-FILE-STREAM-MIXIN
	 SI:OUTPUT-POINTER-REMEMBERING-MIXIN
	 CHAOS:CHARACTER-OUTPUT-STREAM-MIXIN SI:BUFFERED-OUTPUT-CHARACTER-STREAM))

(DEFFLAVOR FILE-INPUT-BINARY-STREAM
	()
	(FILE-INPUT-BINARY-STREAM-MIXIN SI:INPUT-FILE-STREAM-MIXIN
	 SI:INPUT-POINTER-REMEMBERING-MIXIN
	 CHAOS:BINARY-INPUT-STREAM-MIXIN SI:BUFFERED-INPUT-BINARY-STREAM
	 SI:UNSIGNED-BYTE-8-WITH-CHARACTER-INPUT-MIXIN))

(DEFFLAVOR FILE-OUTPUT-BINARY-STREAM
	()
	(FILE-OUTPUT-BINARY-STREAM-MIXIN SI:OUTPUT-FILE-STREAM-MIXIN
	 SI:OUTPUT-POINTER-REMEMBERING-MIXIN
	 CHAOS:BINARY-OUTPUT-STREAM-MIXIN SI:BUFFERED-OUTPUT-BINARY-STREAM
	 SI:UNSIGNED-BYTE-8-WITH-CHARACTER-OUTPUT-MIXIN))

(DEFFLAVOR FILE-OUTPUT-DIRECT-CHARACTER-STREAM
	()
	(FILE-DIRECT-OUTPUT-STREAM-MIXIN
	 SI:DIRECT-ACCESS-BUFFERED-OUTPUT-STREAM-MIXIN
	 FILE-OUTPUT-CHARACTER-STREAM-MIXIN SI:OUTPUT-FILE-STREAM-MIXIN
	 SI:OUTPUT-POINTER-REMEMBERING-MIXIN
	 CHAOS:CHARACTER-OUTPUT-STREAM-MIXIN SI:BUFFERED-OUTPUT-CHARACTER-STREAM))

(DEFFLAVOR FILE-INPUT-DIRECT-CHARACTER-STREAM
	()
	(FILE-DIRECT-INPUT-STREAM-MIXIN SI:DIRECT-ACCESS-BUFFERED-INPUT-STREAM-MIXIN
	 FILE-INPUT-CHARACTER-STREAM-MIXIN SI:INPUT-FILE-STREAM-MIXIN
	 CHAOS:CHARACTER-INPUT-STREAM-MIXIN SI:BUFFERED-INPUT-CHARACTER-STREAM
	 SI:INPUT-POINTER-REMEMBERING-MIXIN))

(DEFFLAVOR FILE-OUTPUT-DIRECT-BINARY-STREAM
	()
	(FILE-DIRECT-OUTPUT-STREAM-MIXIN
	 SI:DIRECT-ACCESS-BUFFERED-OUTPUT-STREAM-MIXIN
	 FILE-OUTPUT-BINARY-STREAM-MIXIN SI:OUTPUT-FILE-STREAM-MIXIN
	 SI:OUTPUT-POINTER-REMEMBERING-MIXIN
	 CHAOS:BINARY-OUTPUT-STREAM-MIXIN SI:BUFFERED-OUTPUT-BINARY-STREAM
	 SI:UNSIGNED-BYTE-8-WITH-CHARACTER-OUTPUT-MIXIN))

(DEFFLAVOR FILE-INPUT-DIRECT-BINARY-STREAM
	()
	(FILE-DIRECT-INPUT-STREAM-MIXIN
	 SI:DIRECT-ACCESS-BUFFERED-INPUT-STREAM-MIXIN
	 FILE-INPUT-BINARY-STREAM-MIXIN SI:INPUT-FILE-STREAM-MIXIN
	 SI:INPUT-POINTER-REMEMBERING-MIXIN
	 CHAOS:BINARY-INPUT-STREAM-MIXIN SI:BUFFERED-INPUT-BINARY-STREAM
	 SI:UNSIGNED-BYTE-8-WITH-CHARACTER-INPUT-MIXIN))

(DEFFLAVOR FILE-BIDIRECTIONAL-DIRECT-CHARACTER-STREAM ()
	   (FILE-DIRECT-BIDIRECTIONAL-STREAM-MIXIN
	    FILE-DIRECT-INPUT-STREAM-MIXIN
	    FILE-DIRECT-OUTPUT-STREAM-MIXIN 
	    SI:BIDIRECTIONAL-POINTER-REMEMBERING-MIXIN 
	    SI:DIRECT-ACCESS-BUFFERED-INPUT-STREAM-MIXIN
	    SI:DIRECT-ACCESS-BUFFERED-OUTPUT-STREAM-MIXIN
	    FILE-OUTPUT-CHARACTER-STREAM-MIXIN	;get :real-close from him
	    FILE-INPUT-CHARACTER-STREAM-MIXIN 
	    CHAOS:CHARACTER-STREAM
	    SI:BIDIRECTIONAL-STREAM
	    SI:INPUT-POINTER-REMEMBERING-MIXIN
	    SI:OUTPUT-POINTER-REMEMBERING-MIXIN))

(DEFFLAVOR FILE-BIDIRECTIONAL-DIRECT-BINARY-STREAM ()
	   (FILE-DIRECT-BIDIRECTIONAL-STREAM-MIXIN
	    FILE-DIRECT-INPUT-STREAM-MIXIN
	    FILE-DIRECT-OUTPUT-STREAM-MIXIN 
	    SI:BIDIRECTIONAL-POINTER-REMEMBERING-MIXIN 
	    SI:DIRECT-ACCESS-BUFFERED-INPUT-STREAM-MIXIN
	    SI:DIRECT-ACCESS-BUFFERED-OUTPUT-STREAM-MIXIN
	    FILE-OUTPUT-BINARY-STREAM-MIXIN 
	    FILE-INPUT-BINARY-STREAM-MIXIN 
	    CHAOS:BINARY-STREAM
	    SI:BIDIRECTIONAL-STREAM
	    SI:INPUT-POINTER-REMEMBERING-MIXIN
	    SI:OUTPUT-POINTER-REMEMBERING-MIXIN
	    SI:UNSIGNED-BYTE-8-WITH-CHARACTER-IO-MIXIN))

(DEFFLAVOR FILE-PROBE-STREAM
	((STATUS ':CLOSED))
	(FILE-STREAM-MIXIN SI:STREAM)
  (:GETTABLE-INSTANCE-VARIABLES STATUS)
  (:INIT-KEYWORDS :FILE-ACCESS-PATH :DATA-CONNECTION))

(DEFFLAVOR FILE-DIRECTORY-STREAM () (FILE-INPUT-CHARACTER-STREAM))

(COMPILE-FLAVOR-METHODS FILE-INPUT-CHARACTER-STREAM FILE-INPUT-BINARY-STREAM
			FILE-OUTPUT-CHARACTER-STREAM FILE-OUTPUT-BINARY-STREAM
			FILE-PROBE-STREAM FILE-DIRECTORY-STREAM
			FILE-INPUT-DIRECT-CHARACTER-STREAM
			FILE-OUTPUT-DIRECT-CHARACTER-STREAM
			FILE-INPUT-DIRECT-BINARY-STREAM
			FILE-OUTPUT-DIRECT-BINARY-STREAM
			FILE-BIDIRECTIONAL-DIRECT-CHARACTER-STREAM
			FILE-BIDIRECTIONAL-DIRECT-BINARY-STREAM)

(DEFMETHOD (FILE-ACCESS-PATH-OPEN QFILE-ACCESS-PATH) (REAL-PATHNAME PATHNAME &REST OPTIONS)
  (OPEN-CHAOS SELF REAL-PATHNAME PATHNAME OPTIONS))

(DEFMETHOD (:RENAME QFILE-ACCESS-PATH) (OLD-PATHNAME NEW-PATHNAME)
  (RENAME-CHAOS SELF OLD-PATHNAME NEW-PATHNAME))

(DEFMETHOD (:DELETE QFILE-ACCESS-PATH) (PATHNAME)
  (DELETE-CHAOS SELF PATHNAME))

(DEFMETHOD (:COMPLETE-STRING QFILE-ACCESS-PATH) (DEFAULT STRING OPTIONS)
  (COMPLETE-CHAOS SELF DEFAULT STRING OPTIONS))

(DEFMETHOD (:CHANGE-PROPERTIES QFILE-ACCESS-PATH) (PATHNAME &REST PROPERTIES)
  (CHANGE-PROPERTIES-CHAOS SELF PATHNAME PROPERTIES))

(DEFMETHOD (:DIRECTORY-STREAM QFILE-ACCESS-PATH) (PATHNAME OPTIONS)
  (DIRECTORY-CHAOS SELF PATHNAME OPTIONS))

(DEFMETHOD (:PROPERTIES-STREAM QFILE-ACCESS-PATH) (PATHNAME HANDLE)
  (PROPERTIES-CHAOS SELF PATHNAME HANDLE))

;;; Perhaps this would be a reasonable default for the way all hosts should work?
(DEFMETHOD (:ALL-DIRECTORIES QFILE-ACCESS-PATH) (PATHNAME OPTIONS)
  (LET ((DIRS (FUNCALL PATHNAME ':DIRECTORY-LIST (CONS ':DIRECTORIES-ONLY OPTIONS))))
    (IF (STRINGP DIRS) DIRS
	(SETQ DIRS (CDR DIRS))
	(DOLIST (X DIRS)
	  (RPLACA X (FUNCALL (CAR X) ':NEW-PATHNAME ':NAME NIL ':TYPE NIL
			     ':VERSION NIL)))
	DIRS)))

(DEFMETHOD (:MULTIPLE-FILE-PLISTS QFILE-ACCESS-PATH) (FILES OPTIONS)
  (MULTIPLE-PLISTS-CHAOS SELF FILES OPTIONS))

(DEFMETHOD (:EXPUNGE QFILE-ACCESS-PATH) (PATHNAME &REST OPTIONS)
  (EXPUNGE-CHAOS SELF PATHNAME OPTIONS))

(DEFMETHOD (:CREATE-DIRECTORY QFILE-ACCESS-PATH) (PATHNAME &REST OPTIONS)
  (CREATE-DIRECTORY-CHAOS SELF PATHNAME OPTIONS))

(DEFMETHOD (:CREATE-LINK QFILE-ACCESS-PATH) (LINKFROM-PATH LINKTO-PATH &REST OPTIONS)
  (CREATE-LINK-CHAOS SELF LINKFROM-PATH LINKTO-PATH OPTIONS))

(DEFMETHOD (:UPDATE-HOMEDIR QFILE-ACCESS-PATH) (IGNORE)
  (SEND SELF ':GET-HOST-UNIT))			;This will make sure someone is logged in

;;; Operating system particular host flavors


(DEFFLAVOR ITS-QFILE-ACCESS-PATH () (NO-PASSWORD-ACCESS-PATH-MIXIN QFILE-ACCESS-PATH))

(DEFMETHOD (:MAX-DATA-CONNECTIONS ITS-QFILE-ACCESS-PATH) () 3)

;;; Given the response to the LOGIN command, as passed as the STR argument
;;; in the :HSNAME-INFORMATION method, return the (canonicalized) user-id
;;; that was returned by the host.
(DEFUN PARSE-CANONICAL-UNAME (STR)
  (LET ((I (1+ (STRING-SEARCH-CHAR #\SP STR (1+ (STRING-SEARCH-CHAR #\SP STR))))))
    (SUBSTRING STR I (STRING-SEARCH-CHAR #\SP STR I))))

(DEFMETHOD (:HSNAME-INFORMATION ITS-QFILE-ACCESS-PATH) (UNIT STR IDX)
  UNIT
  (LET* ((HSNAME (SUBSTRING STR (SETQ IDX (1+ IDX))
			    (SETQ IDX (STRING-SEARCH-CHAR #\CR STR IDX))))
	 (HSNAME-PATHNAME (MAKE-PATHNAME ':HOST HOST ':DEVICE "DSK" ':DIRECTORY HSNAME))
	 (PERSONAL-NAME (SUBSTRING STR (SETQ IDX (1+ IDX))
				   (SETQ IDX (STRING-SEARCH-CHAR #\CR STR IDX))))
	 (GROUP-AFFILIATION (SUBSTRING STR (1+ IDX))))
    (VALUES HSNAME-PATHNAME PERSONAL-NAME GROUP-AFFILIATION (PARSE-CANONICAL-UNAME STR))))


(DEFFLAVOR NORMAL-QFILE-ACCESS-PATH () (QFILE-ACCESS-PATH))

(DEFMETHOD (:HSNAME-INFORMATION NORMAL-QFILE-ACCESS-PATH) (UNIT STR IDX)
  UNIT
  (LET* ((HSNAME (SUBSTRING STR (SETQ IDX (1+ IDX))
			    (SETQ IDX (STRING-SEARCH-CHAR #\CR STR IDX))))
	 (HSNAME-PATHNAME (SEND SELF ':HSNAME-PATHNAME HSNAME))
	 (PERSONAL-NAME (SUBSTRING STR (SETQ IDX (1+ IDX))
				   (SETQ IDX (STRING-SEARCH-CHAR #\CR STR IDX))))
	 (GROUP-AFFILIATION (SUBSTRING STR (1+ IDX))))
    (VALUES HSNAME-PATHNAME PERSONAL-NAME GROUP-AFFILIATION (PARSE-CANONICAL-UNAME STR))))

(DEFMETHOD (:HSNAME-PATHNAME NORMAL-QFILE-ACCESS-PATH) (STRING)
  (PARSE-PATHNAME STRING HOST))

(DEFMETHOD (:MAX-DATA-CONNECTIONS NORMAL-QFILE-ACCESS-PATH) () 8)


(DEFFLAVOR TOPS20-QFILE-ACCESS-PATH ()
	   (ALLOW-ANONYMOUS-LOGINS-ACCESS-PATH-MIXIN NORMAL-QFILE-ACCESS-PATH))

(DEFFLAVOR TENEX-QFILE-ACCESS-PATH () (TOPS20-QFILE-ACCESS-PATH))

(DEFMETHOD (:HSNAME-PATHNAME TENEX-QFILE-ACCESS-PATH) (STRING)
  (MAKE-PATHNAME ':HOST HOST ':DEVICE "DSK" ':DIRECTORY STRING))


(DEFFLAVOR LMFS-QFILE-ACCESS-PATH () (LMFS-ACCESS-PATH-MIXIN NORMAL-QFILE-ACCESS-PATH))

(DEFMETHOD (:MAX-DATA-CONNECTIONS LMFS-QFILE-ACCESS-PATH) () 69.)

(DEFMETHOD (:HSNAME-INFORMATION LMFS-QFILE-ACCESS-PATH) (IGNORE STR IDX)
  (LET ((PATHNAME
	  (IF (NULL IDX)
	      (MAKE-PATHNAME ':HOST HOST ':DEVICE ':UNSPECIFIC
			     ':DIRECTORY (STRING-APPEND *PATH-DELIMITER* USER-ID)
			     ':NAME NIL ':TYPE NIL ':VERSION NIL)
	      (PARSE-PATHNAME
		(SUBSTRING STR
			   (SETQ IDX (1+ (STRING-SEARCH-CHAR #\CR STR IDX)))
			   (STRING-SEARCH-CHAR #\CR STR IDX))
		HOST))))
    (VALUES PATHNAME		;User's home directory
	    NIL			;Personal name (don't know)
	    NIL			;Group affiliation (don't know)
	    (PARSE-CANONICAL-UNAME STR))))

(DEFMETHOD (:PASSWORD-FOR-CAPABILITY LMFS-QFILE-ACCESS-PATH) (CAPABILITY)
  (FORMAT QUERY-IO "~&Password for ~a capability on host ~a: " CAPABILITY HOST)
  (STRING-UPCASE (STRING-TRIM '(#\SP #\TAB) (READLINE-NO-ECHO QUERY-IO))))


(FLAVOR:NOTICE-RUN-TIME-METHOD '(FLAVOR:METHOD :PEEK-FILE-SYSTEM QFILE-ACCESS-PATH))

(COMPILE-FLAVOR-METHODS NORMAL-QFILE-ACCESS-PATH ITS-QFILE-ACCESS-PATH
			TOPS20-QFILE-ACCESS-PATH TENEX-QFILE-ACCESS-PATH
			LMFS-QFILE-ACCESS-PATH)

;;; Initializations

(DEFUN QFILE-INIT ()
  (WITHOUT-INTERRUPTS
    (DO ((L *FILE-PENDING-TRANSACTIONS* (CDR L))
	 (PKT))
	((NULL L)
	 (SETQ *FILE-PENDING-TRANSACTIONS* NIL))
      (AND (SETQ PKT (FILE-TRANSACTION-ID-PKT (CAR L)))
	   (NOT (EQ PKT ':ABORTED))
	   (CHAOS:RETURN-PKT PKT)))))


(ADD-INITIALIZATION "QFILE-INIT" '(QFILE-INIT) '(SYSTEM))
