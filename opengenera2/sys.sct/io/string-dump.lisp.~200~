D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");;; -*- Syntax: Common-Lisp; Base: 10; Mode: LISP; Package: SYSTEM-INTERNALS; Lowercase: Yes; Fonts: CPTFONT,CPTFONTI,CPTFONTCB -*-

(2 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB");;; Streams for writing fonted files.
0;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>


#||
(with-string-dumping-stream (*character-stream* kbin-context :stream stream)
  ;; Dynamic extent, *CHARACTER-STREAM* can be lexical or dynamic.
 )

(with-string-loading-stream (*character-stream* stream)
 )
||#

;;; 2The formats:

0;;; 1Escaped text streams:
0;;;
;;; Initially, every character is read as is, with style 0, character set 0, and bits 0.
;;; However, there is a magic sequence which denotes the start of escape-hood.  This
;;; sequence is followed by a version number for the format, to make any future extentions
;;; easier.
;;;
;;; This is very similar to the format used to indicate font shifts of old.
;;; The escape character (normally  (Epsilon)) is used to indicate a font shift.
;;; Characters in the file are interpreted as being the subindex field, and the
;;; rest of the character is obtained from a current default chosen by the font
;;; shift characters.
;;;
;;; Each combination of bits, character-set, character-set-offset, and style
;;; (i.e. everything that differs that's not in the 8-bit byte stored in a simple
;;; string), we call a 1character type0.
;;;
;;; The two character sequence ( denotes the start of a "character type definition":
;;; (<nnn> <bits> (<char-set> <offset>) (<family> <face> <size>) <default-font>)
;;;
;;; <nnn> is the "character-type" number, as a non-negative decimal integer.
;;;
;;; <bits> is the contents of the bits field of the characters, as a decimal integer.
;;;
;;; <character-set> is the name of a character-set, normally 2nil0 for the standard
;;; character set, but possibly a keyword such as 2:japanese0.  This plus the <offset>
;;; below are used to determine the 1char-set0 field of the character.
;;;
;;; <offset> is the offset within the character-set.  It is used in conjunction with
;;; the <character-set> above.
;;;
;;; <family>, <face>, and <size> are the three standard components of a character
;;; style.  This forms a standard style spec to be parsed; if this is extended in
;;; the future, it will be reflected here.
;;;
;;; <default-font> is a font to use to display this if we don't understand the
;;; style and character-set.  This is particularly useful for Rel-6, which otherwise
;;; wouldn't understand 1any0 of this.
;;;
;;; 0 - 9 select a specific character type, for types 0-9.  These must have been
;;; previously defined before, except that type 0 is always (0 nil 0 nil nil nil).
;;; Types 10 and above are denoted as (nn).  (Actually, this syntax is also legal
;;; but unused for 0-9.
;;;
;;;  is how you encode an actual epsilon in the file.
;;;
;;; For compatability with other systems, (LMITI) * means go back to the previous
;;; level.
;;;
;;; For forward compatability from Release 6.2, accept -frobs after #/9.
;;;
;;; For compatability
;;;
;;; If we have more than 256 character types, it is permissable to re-define them.
;;; An LRU scheme might be appropriate, but is not required, and probably would not
;;; be implemented.
;;;
;;; If a file is going to be edited by both Release 6.2 and 7.0 worlds,
;;; there are two possibilities:
;;;
;;;   A.  2No font Attribute0.
;;;     1. 2Advantages
0;;;        Font shifts will appear as literal text in 6.2, and can be left alone.
;;;        They can even be edited, carefully.
;;;     2. 2Disadvantages
0;;;        Font shifts will appear in unexpected places.  If in code, the code will be
;;;        unreadable.
;;;   B.  2With Font Attribute0.
;;;     1. 2Advantages
0;;;        Font shifts do not interfere with Release 6.0 usage of the file.
;;;     2. 2Disadvantages
0;;;        Release 6 cannot add new fonts, but can make use of the ones Rel-7 has used.
;;;
;;; Release 7 tries to find out what font the file should appear in in Rel 6
;;; ("back-back-translation"), and that info is provided to Rel-6 under 2#+release-6
0;;; after the type index.
;;;
;;; Also, the definitions in the file Y:>rwk>lispm>string-rel6-compat are suggested
;;; for Release 6.2.  I am assuming that this patch should wait until we actually
;;; ship Rel 7, in case we change things.  It isn't needed until sites have both
;;; Rel 6 and Rel 7.  It may be better to ship it earlier, but I think 6.1 is too early.
;;; Hence, 6.2, whether there is a 6.2 sent out separately, or not.
;;;

(defflavor basic-dumping-stream ((transition-table)
				 (escape-quote nil)
				 (last-char #\Return)
				 stream)
	   ()
  :gettable-instance-variables
  (:initable-instance-variables escape-quote))

(defmethod (make-instance basic-dumping-stream :after) (&rest ignore)
  (send self :reset-state))

(defmethod (:reset-state basic-dumping-stream :default) (&optional (reset-mappings t))
  (ignore reset-mappings))

(defmethod (:reset-state basic-dumping-stream :after) (&optional (reset-mappings t))
  (ignore reset-mappings)
  (when transition-table
    (setf (fill-pointer transition-table) 0))
  (setq last-char #\Return))

(defmethod (:line-out basic-dumping-stream) (string &optional (start-index 0) end)
  (send self :string-out string start-index end)
  (send self :write-char #\return))

(defmethod (:fresh-line basic-dumping-stream) ()
  (unless (char-equal last-char #\Return)
    (send self :tyo #\Return)
    t))

(defun %string-search-char= (char string start end)
  (let ((str string))
    (declare (compiler:array-register str))
    (do ((i start (1+ i)))
	(( i end) nil)
      (when (char= (aref str i) char)
	(return i)))))

(defmethod (:set-up-transition-table basic-dumping-stream) (string
							    &optional (start-index 0)
								      final-index
								      initial-style+set)
  (unless final-index
    (setq final-index (string-length string)))
  (unless transition-table
    (setq transition-table (allocate-resource 'string-transition-table)))
  (if ( start-index final-index)
      (cl:setf (fill-pointer transition-table) 0)
    (let ((transition-tbl transition-table)
	  (string string))
      (declare (sys:array-register transition-tbl string))
      (loop with escape-flag = (when escape-quote (char-subindex escape-quote))
	    with first-char = (aref string start-index)
	    with transition-index = 0
	    with transition-index-limit = (array-length transition-tbl)
	    for i from start-index below final-index
	    for old-return-p = nil then return-p
	    for char = (aref string i)
1	    ;; When doing escape coding, return in style 0 is always output without
	    ;; any style escapes or quoting.  When we find it here, we leave 2old-style+set
1	    ;; unchanged and don't increment 2transitions1.
0	    for return-p = (and escape-flag (char= char #\Return))
	    for old-style+set = (or initial-style+set
				    (char-ldb-internal %%char-all-but-subindex first-char))
			      then (if old-return-p old-style+set style+set)
	    for style+set = (char-ldb-internal %%char-all-but-subindex char)
1		;;   If we have a character not of the same type, or, if we are using escape
		;; codes, has the same subindex as either the escape character or the return
		;; character, we have a transition.  
		;;   If we are using escapes, we don't escape return unless it has non-zero
		;; type.
0	    when (and (not return-p)
		      (or ( style+set old-style+set)
			  (and escape-flag
			       (or (= (char-subindex char) escape-flag)
				   (and (= (char-subindex char) (char-subindex #\Return))
					( (char-type char) 0))))))
	      sum 1 into transitions
	      and do (when ( transition-index transition-index-limit)
		       (let ((old-transition-tbl transition-tbl)
			     (new-transition-tbl
			       (allocate-resource 'string-transition-table
						  (ceiling (* transition-index-limit 5/3)))))
			 (copy-array-contents old-transition-tbl new-transition-tbl)
			 (setq transition-tbl new-transition-tbl
			       transition-index-limit (array-length transition-tbl)
			       transition-table new-transition-tbl)
			 (deallocate-resource 'string-transition-table old-transition-tbl)))
		     (setf (aref transition-tbl transition-index) i)
		     (incf transition-index)
	    finally
	      (setf (fill-pointer transition-tbl) transitions)))))

1;;; Dump a fat string, or a string determined to have escape characters needing
;;; quoting.
0(defmethod (:string-out-fat basic-dumping-stream) (string start-index final-index)
  (let ((string string))
    (declare (sys:array-register))		1;The setup checks the type
0    (let ((length (- final-index start-index)))
      (if (zerop length)
	  1;;*** Not really right, but for now, since the loop below needs length  1
0	  (send self :dump-simple-string string 0 0)
	(send self :set-up-transition-table string start-index final-index
						   (send self :default-char-type))
	(send self :dump-hairy-string string start-index final-index)))))

#+IGNORE
(defmethod (:dump-hairy-string basic-dumping-stream :default) (string start-index final-index)
  (let ((ratio (cl:/ (fill-pointer transition-table) (float (- final-index start-index)))))
    (cond ((< ratio .5)
	   (send self :dump-string-with-updates
		 string start-index final-index))
	  (t (send self :dump-string-general-codes
		   string start-index final-index)))))

#+IGNORE
(defmethod (:dump-simple-string-opcode basic-dumping-stream :default) ()
  dump-string-simple-opcode)

(defmethod (:dump-simple-string basic-dumping-stream) (string start-index final-index)
  (send self :dump-simple-string-opcode)
  (send self :dump-string-internal string start-index final-index))

;;;
;;; --------
;;; <
;;;

#||
(defmethod (:dump-string-with-updates-opcode basic-dumping-stream :default) ()
  dump-string-update-opcode)

(defmethod (:dump-string-with-updates basic-dumping-stream) (string start-index final-index)
  (send self :dump-string-with-updates-opcode)
  (send self :tyo transitions)
  ... )
||#

(defmethod (:close basic-dumping-stream :after) (&rest ignore)
  (when transition-table
    (let ((tran-tab transition-table))
      (setq transition-table nil)
      (deallocate-resource 'string-transition-table tran-tab))))

#+IGNORE
(defmethod (:dump-symbol basic-dumping-stream :default) (symbol)
  (let* ((pkg (pkg-prefix-name symbol))
	 (pkg-len (string-length pkg))
	 (pname (string symbol))
	 (pname-len (string-length pname)))
    (send stream :tyo pkg-len)
    (send self :dump-string-internal pkg 0 pkg-len)
    (send stream :tyo pname-len)
    (send self :dump-string-internal pkg 0 pname-len)))


1;;; This 2send-if-handles1 test needs to be moved out of the loop somehow.
;;; It seems to take a fair bit of the time.

0(defmethod (:get-output-buffer-1 basic-dumping-stream :default) ()
  (send-if-handles self :get-output-buffer))

(cl:defparameter *dump-string-internal-max-binary-chunk-size* 4096)

(defmethod (:dump-string-internal basic-dumping-stream) (string start-index final-index)
  (multiple-value-bind (buffer buf-start buf-end)
      (send self :get-output-buffer-1)
    (let ((string string))
      (declare (sys:array-register string))
      (if buffer
	  (loop with length = (- final-index start-index)
		with length-to-go = length
		for start = start-index then (+ start buf-length)
		for buf-length = (- buf-end buf-start)
		for length-this-time = (min buf-length length-to-go)
		do (multiple-value-bind (outstring ibuf-start ibuf-end nbuf-end)
		       (send self :prepare-8bit-buffer buffer buf-start length-this-time)
		     (let ((outstring outstring))	1;Compiler 0vs1 2multiple-value-bind
0		       (declare (sys:array-register outstring))
		       ;; ** This could, perhaps, be made faster by hacking a word at a time
		       ;; ** instead of a byte at a time.  Need a dispatch by string width.
		       (loop for bi from ibuf-start below ibuf-end
			     for si from start
			     do (setf (aref outstring bi) (char-subindex (aref string si)))))
		     (send self :advance-output-buffer nbuf-end)
		     (decf length-to-go length-this-time))
		until (zerop length-to-go)
		do (multiple-value (buffer buf-start buf-end)
		     (send self :get-output-buffer)))
	(let* ((amount-to-dump (- final-index start-index))
	       (binary-chunk-size (min amount-to-dump
				       *dump-string-internal-max-binary-chunk-size*)))
	  (sys:with-stack-array (binary-chunk binary-chunk-size :type art-8b)
	    (declare (sys:array-register binary-chunk))
	    (loop for amount-left-to-dump = amount-to-dump
					  then (- amount-left-to-dump amount-this-time)
		  until (zerop amount-left-to-dump)
		  for string-start = start-index then (+ string-start amount-this-time)
		  as amount-this-time = (min amount-left-to-dump binary-chunk-size)
		  do (loop for binary-chunk-index from 0 below amount-this-time
			   for string-index from string-start
			   do (setf (aref binary-chunk binary-chunk-index)
				    (char-subindex (aref string string-index))))
		     (send stream :string-out binary-chunk 0 amount-this-time))))))))

1;;; Mix this in when dumping a series of strings serially with escape codes,
;;; as into a VMS file.

0(defflavor continuous-dumping-context-mixin ((default-char-type 0))
	   ())

(defmethod (:default-char-type continuous-dumping-context-mixin) ()
  default-char-type)

(defmethod (:remember-char-type continuous-dumping-context-mixin)
	   (new-default)
  (setq default-char-type new-default))

(defmethod (:reset-state continuous-dumping-context-mixin :after) (&optional (reset-mappings t)
									     )
  (ignore reset-mappings)
  (send self :remember-char-type 0))

1;;; Default is to not keep context between strings, so each string
;;; starts out in the default set of style, char-set, and bits.

0(defmethod (:default-char-type basic-dumping-stream :default) ()
  0)

(defmethod (:remember-char-type basic-dumping-stream :default)
	   (new-default)
  (ignore new-default)
  nil)

(defflavor escape-dumping-stream-mixin
	((dumping-fat nil)			;T if we're doing escapes.
	 (transparent-tyo nil)			;T if we should output characters as they come
	 (password-stream nil)
	 (fonts-checking-stream nil)
	 (char-type-index 0)
	 (type&mcstype-index (cl:make-hash-table :test #'eq :rehash-threshold 20.))
						;accelerator to avoid merging
						;(char-style char) with merged-current-style
						;for each character.
	 (style&bits&setchar-spec (cl:make-hash-table :test #'eq :rehash-threshold 20.))
						;real information -- lists everything
						;we know how to do.
	 (current-or-default-style-changed nil)
	 default-character-style
	 current-character-style
	 merged-current-style
	 initial-options)
	(continuous-dumping-context-mixin basic-dumping-stream character-stream)
  (:gettable-instance-variables default-character-style current-character-style)
  (:initable-instance-variables dumping-fat)
  (:init-keywords :default-character-style :check-for-fonts-line)
  (:default-init-plist :escape-quote #\
		       :default-character-style (parse-character-style nil)))

(defmethod (make-instance escape-dumping-stream-mixin) (&key default-character-style
							     check-for-fonts-line
							&allow-other-keys)
  (cl:setf initial-options nil
	   (cl:getf initial-options :escape-quote) escape-quote
	   (cl:getf initial-options :dumping-fat) dumping-fat
	   (cl:getf initial-options :default-character-style) default-character-style
	   (cl:getf initial-options :check-for-fonts-line) check-for-fonts-line))

#||
(defun view-raw-file (&optional (pathname (accept 'cl:pathname)))
  (with-open-file (s pathname :direction :input :element-type 'cl:string-char)
    (stream-copy-until-eof s standard-output)))
||#

(defmethod (:set-default-character-style escape-dumping-stream-mixin) (new-style)
  (unless (eq new-style default-character-style)
    (setq default-character-style new-style)
    (setq current-or-default-style-changed t)
    (setq merged-current-style (merge-character-styles
				 current-character-style default-character-style))))

;;;--- Eric Daly: You can just take these out of here when you get to this spot.
;;;--- Note that I broke people passing :default-style as an init-keyword.

(defmethod (:default-style escape-dumping-stream-mixin) ()
  default-character-style)

(defmethod (:set-default-style escape-dumping-stream-mixin) (n-d-s)
  (send self :set-default-character-style n-d-s))

(defsubst-in-flavor (lookup-char-type-index-1 escape-dumping-stream-mixin) (char-type)
  (let ((hash (cl:gethash merged-current-style type&mcstype-index)))
    (dolist (spec hash)
      (if (= (car spec) char-type)
	  (return (cdr spec))))))

(defun-in-flavor (store-char-type-index-1 escape-dumping-stream-mixin)
		    (char-type a-merged-current-style a-char-type-index)
  (let ((hash (cl:gethash a-merged-current-style type&mcstype-index)))
    (cl:push (cons char-type a-char-type-index) hash :localize t)
    (cl:setf
      (cl:gethash a-merged-current-style type&mcstype-index) hash)))

(defsubst-in-flavor (lookup-char-type-index-2 escape-dumping-stream-mixin)
		    (style bits-and-set)
  (let ((hash (cl:gethash style style&bits&setchar-spec)))
    (dolist (spec hash)
      (if (= (car spec) bits-and-set)
	  (return (cdr spec))))))

(defun-in-flavor (store-char-type-index-2 escape-dumping-stream-mixin)
		    (style bits-and-set a-spec)
  (let ((hash (cl:gethash style style&bits&setchar-spec)))
    (cl:push (cons bits-and-set a-spec) hash :localize t)
    (cl:setf (cl:gethash style style&bits&setchar-spec) hash)))

(defsubst-in-flavor (state-ok-p escape-dumping-stream-mixin) (char)
  (or (char= char #\Return)
      (and (= (char-type char) (send self :default-char-type))
	   (not current-or-default-style-changed))))

(defmethod (:with-character-style escape-dumping-stream-mixin)
	   (style continuation arg bind-line-height)
  (ignore bind-line-height)
  (let ((different nil)
	(old-mcs merged-current-style))
    (unwind-protect
	(letf ((current-character-style style))
	  (setq merged-current-style (merge-character-styles
				       current-character-style default-character-style))
	  (setq different (neq merged-current-style old-mcs))
	  (setq current-or-default-style-changed different)
	  (funcall continuation arg))
      (setq merged-current-style (merge-character-styles
				   current-character-style default-character-style))
      (setq current-or-default-style-changed different))))

(defun compute-character-type-info (char &optional force-style)
  (declare (values bits char-set offset family face size extended))
  (multiple-value-bind (char-set index)
      (char-char-set-and-index char)
    (let ((style (or force-style (char-style char))))
      (values (char-bits char)
	      (send char-set :name)
	      (cl:/ (- index (char-subindex char)) 256)
	      (cs-family style)
	      (cs-face style)
	      (cs-size style)
	      (cs-extended-attributes style)))))

(defun char-type-spec-from-char (char index style-default &optional force-style)
  (multiple-value-bind (bits char-set offset family face size extended)
      (compute-character-type-info char force-style)
    (make-char-type-spec-frob char index bits char-set offset family face size extended
			      style-default)))

(defun make-char-type-spec-frob (char char-type-index bits char-set offset family face size
				 extended default)
  #---ignore (ignore extended)
  (let* ((font (or (lookup-font char
				*b&w-screen*
				(merge-character-styles
				  default
				  *file-absolute-default-character-style*)
				nil t)
		   'fonts:cptfont))
	 (name (if (typep font 'font)
		   (font-name font)
		   font)))
    (make-char-type-spec type char-type-index
			 bits bits
			 char-set (make-char-type-spec-char-set name char-set
								offset offset)
			 style (make-char-type-spec-style family family
							  face face
							  size size
							  #+IGNORE #+IGNORE
							  attributes extended)
			 default-font (string name))))

;;; the FIX.ROMAN.NORMAL here is just to confuse you.  NIL.NIL.NIL would have the same
;;; effect, which is to default the search for CPTFONT from that X, which is in NIL.NIL.NIL.
(defvar *default-type-0-spec* (char-type-spec-from-char #\X 0 '(:fix :roman :normal)))

(defmethod (:reset-state escape-dumping-stream-mixin :after) (&optional (reset-mappings t))
  (setq escape-quote (cl:getf initial-options :escape-quote)
	dumping-fat (cl:getf initial-options :dumping-fat)
	transparent-tyo nil
	password-stream nil
	char-type-index 0
	current-or-default-style-changed nil
	default-character-style (cl:getf initial-options :default-character-style)
	current-character-style (parse-character-style nil)
	merged-current-style (merge-character-styles current-character-style
						     default-character-style))
  (when reset-mappings
    (setq type&mcstype-index (clrhash type&mcstype-index)
	  style&bits&setchar-spec (clrhash style&bits&setchar-spec))
    (store-char-type-index-2 (parse-character-style nil) (char-type #\X) *default-type-0-spec*)
    )
  (if (cl:getf initial-options :check-for-fonts-line)
      (setq fonts-checking-stream (make-instance 'fonts-checking-stream
				    :continuation (lambda (fat-p)
						    (unless dumping-fat
						      (when fat-p
							(send self :start-dumping-fat)))
						    (setq fonts-checking-stream nil))))
      (setq fonts-checking-stream nil)))

;;; Force a transition back to type zero.
(defmethod (:back-to-type-zero escape-dumping-stream-mixin) ()
  (unless (zerop default-char-type)
    (send self :escape-char-type #\X)))

(defmethod (:start-dumping-fat escape-dumping-stream-mixin) ()
  (letf ((transparent-tyo t))
    (loop for i below (string-length *fat-password*)
	  do (send self :tyo (aref *fat-password* i)))
    (send self :write-byte *escape-format-version*)
    (loop for i below (string-length *fat-password-message*)
	  do (send self :tyo (aref *fat-password-message* i)))
    (setq dumping-fat t)))

(defmethod (:start-dumping-thin escape-dumping-stream-mixin) ()
  (when dumping-fat
    (letf ((transparent-tyo t))
      (send self :tyo #\)
      (send self :tyo fat-unpassword-character)
      (setq dumping-fat nil))))

;;; This method makes absolutely no assumptions about the state of the stream
;;; and is therefore usuable for :if-exists :append
(defmethod (:reset-character-style-state escape-dumping-stream-mixin) ()
  (send self :start-dumping-fat)	1;this suffices to reset the state on reading0	
  (send self :start-dumping-thin))     1 ;This returns us to thin state, and also
0					1;resets our internal idea that we have
0					1;outstanding dumping state.

0(defmethod (:start-password-stream escape-dumping-stream-mixin) ()
  (setq password-stream
	(make-instance 'password-checking-stream
		       :stream self
		       :thin-continuation #'(lambda ()
					      1;; Thin, output the epsilon
0					      (setq password-stream nil)
					      (letf ((transparent-tyo t))
						(send self :tyo #\)))
		       :fat-continuation #'(lambda ()
					     1;; Fat.
0					     (setq password-stream nil)
					     (send self :start-dumping-fat)
					     (letf ((transparent-tyo t))
					       (send self :tyo #\))))))

(defmethod (:tyo escape-dumping-stream-mixin) (char)
  (if transparent-tyo
      1;; We are outputing part of an escape sequence
0      (send stream :tyo (char-subindex char))
    ;; Normal character output      
    (when fonts-checking-stream		;Watch for Fonts: lines indicating fatness.
      (send fonts-checking-stream :tyo char))
    (if password-stream
	(send password-stream :tyo char)
	(block tyo-done
	  (setq last-char char)
	  (unless (state-ok-p char)
	    (send self :escape-char-type char))
	  (let ((subindex (char-subindex char))
		(escape-subindex (char-subindex escape-quote)))
	    1;; If we have an epsilon or something that looks like an epsilon or return
0	    1;; quote it.
0	    (when (and (not dumping-fat)
		       (= subindex escape-subindex))
	      (send self :start-password-stream)
	      (send password-stream :tyo #\)
	      (return-from tyo-done nil))
	    (when (and dumping-fat
		       (or (= subindex escape-subindex)
			   (and (= subindex (char-subindex #\return))
				( (char-type char) 0))))
	      (unless dumping-fat
		(send self :start-dumping-fat))
	      (send stream :tyo escape-subindex))
	    (send stream :tyo subindex))))))

(defmethod (:string-out escape-dumping-stream-mixin)
	   (string &optional (start-index 0) final-index)
  (when fonts-checking-stream
    (send fonts-checking-stream :string-out string start-index final-index))
  (if password-stream
      (send password-stream :string-out string start-index final-index)
    (let ((string string))
      (declare (sys:array-register))		;The setup checks the type
      (setq final-index (or final-index (string-length string)))
      (unless ( start-index final-index)
	(setq last-char (aref string (1- final-index))))
      (select (array-type-field string)
	(art-string
	 (if (or (not escape-quote)
		 (not (%string-search-char= escape-quote string start-index final-index)))
	     ;; Easy case
	     (progn
	       (unless (or transparent-tyo
			   ( start-index final-index)
			   (state-ok-p #\X))	;its thin, right? check against M-C-S
		 (send self :escape-char-type #\X))
	     (send self :dump-simple-string string start-index final-index))
	   (send self :string-out-fat string start-index final-index)))
	(art-fat-string
	 (send self :string-out-fat string start-index final-index))
	(otherwise (ferror "~S is not a string." string))))))

(defmethod (:can-accept-diagrams-as-lines escape-dumping-stream-mixin) () t)

(defwhopper (:line-out escape-dumping-stream-mixin) (line &rest args)
  (if (and (not (stringp line))
	   (instancep line))
      (multiple-value-bind (encoded-line escape-p)
	  (send line :string-for-file)
	(if (not escape-p)
	    (continue-whopper encoded-line)
	  (unless dumping-fat
	    (send self :start-dumping-fat))
	  (send stream :tyo (char-subindex escape-quote))
	  (send self :write-byte (char-subindex #\#))
	  (loop for char being the array-elements of encoded-line do
	    (send self :write-byte (char-subindex char)))
	  (send self :write-byte (char-subindex #\return))))
      (lexpr-continue-whopper line args)))

;;; a method, because ZMAIL has to shadow it.
(defmethod (eds-define-character-type escape-dumping-stream-mixin) (char bits-and-set style)
  (let* ((char-type (char-type char))
	 (index (cl:incf char-type-index))
	 (spec (char-type-spec-from-char
		 char index default-character-style style)))
    (store-char-type-index-2 style bits-and-set spec)
    (unless dumping-fat			1;Probably redundant
0      (send self :start-dumping-fat))
    (letf ((transparent-tyo t))
      (send self :tyo escape-quote)
      (scl:with-standard-io-environment (prin1 spec self))
      (setq default-char-type char-type))
    index))

;;; The user of this undertakes to transmit the default-character-style
;;; supplied here out of band, somehow, but invisible to release 6.  The
;;; actual characters remain in their actual styles, and the  mappings
;;; describe the actual styles of the characters, as modified by
;;; WITH-CHARACTER-STYLE and SET-DEFAULT-CHARACTER-STYLE operations.
;;; Thus,  this method does not merge the character's style with the
;;; supplied default character style.
;;; 
;;; However, since the default is invisible to release 6, the
;;; default-character-style must participate in calculating the
;;; backtranslated font, (by passing it to char-type-spec-from-char).

(defmethod (eds-predefine-character-type escape-dumping-stream-mixin)
	   (character default-style)
  (let ((style (char-style character))
	(bits-and-set (%logdpb 0 %%char-type-style (char-type character)))
	(new-spec nil))
    (unless (lookup-char-type-index-2 style bits-and-set)
      (store-char-type-index-2
	style bits-and-set
	(setq new-spec
	      (char-type-spec-from-char
		character (cl:incf char-type-index) default-style style))))
    new-spec))

(defmethod (eds-character-type-specs escape-dumping-stream-mixin) ()
  (cl:sort 
    (loop for bits-and-set-spec-list being the hash-elements of style&bits&setchar-spec 
	  nconc
	    (loop for (bits-and-set . spec) in bits-and-set-spec-list
		  do
	      (ignore bits-and-set)
		  collect spec))
    #'<
    :key #'(lambda (s) (char-type-spec-type s))))

(defmethod (:escape-char-type escape-dumping-stream-mixin) (char)
  (when transparent-tyo
    (ferror "Using escape codes while writing an escape code."))
  (let* ((defined-type nil)
	 (char-type (char-type char))
	 (index (lookup-char-type-index-1 char-type)))
    (unless index
      (let ((bits-and-set (%logdpb 0 %%char-type-style char-type))	; zero the style
	    (true-style (merge-character-styles (char-style char)
						merged-current-style)))
	(setq index (char-type-spec-type (lookup-char-type-index-2 true-style bits-and-set)))
	(unless index
	  (setq index (eds-define-character-type self char bits-and-set true-style)
		defined-type t))
	(store-char-type-index-1 char-type merged-current-style index)))
    (letf ((transparent-tyo t))
      (unless dumping-fat			1;Probably redundant
0	(send self :start-dumping-fat))
      (unless defined-type			1;the definition switches the state
0	(send self :tyo escape-quote)
	(if ( index 9.)
	    (send self :tyo (digit-char index))
	    (send self :tyo #\()
	    (scl:with-standard-io-environment (prin1 index self))
	    (send self :tyo #\))))1)
0    (setq default-char-type char-type)
    (setq current-or-default-style-changed nil)))

;;; Here for ZMACS Rel-6 compatability kludge (to order the character types by the Font:
;;; attribute).

(defmethod (:clear-character-types escape-dumping-stream-mixin) ()
  (cl:clrhash type&mcstype-index)
  (cl:clrhash style&bits&setchar-spec))

;;; Here for ZMACS Rel-6 compatability kludge (to order the character types by the Font:
;;; attribute).

(defmethod (:preset-character-type escape-dumping-stream-mixin)
	   (&key index (bits 0) character-set (offset 0) (style *null-style*)
		 (default-font
		   (or (get-font *b&w-screen* character-set
				 (merge-character-styles style '(:fix :roman :normal)) t)
		       fonts:cptfont)))
  (setq char-type-index (max index char-type-index))
  (let ((char #\) ))
    (cl:setf (char-char-set-index char)
	     (send (lookup-character-set character-set) :decode-offset offset)
	     (char-bits char) bits)
    (store-char-type-index-2
      style					; it pays no attention to the character
      (char-type char)				; trim off code
      (si:make-char-type-spec type index
			      bits bits
			      char-set (make-char-type-spec-char-set
					 name (cl:etypecase character-set
						(basic-character-set
						  (send character-set :name))
						((or string symbol) character-set))
					 offset offset)
			      style (si:unparse-character-style style)
			      default-font (cl:etypecase default-font
					     (font (string (font-name default-font)))
					     (symbol (string default-font))
					     (string default-font))))))

;;; Here for ZMACS Rel-6 compatability kludge (to order the character types by the Font:
;;; attribute).

(defmethod (:write-all-character-types escape-dumping-stream-mixin) ()
  (unless (or (= (cl:hash-table-count style&bits&setchar-spec) 0)
	      (and (= (cl:hash-table-count style&bits&setchar-spec) 1)
		   (lookup-char-type-index-2 (parse-character-style nil) (char-type #\x))))
    (send self :start-dumping-fat)
    (letf ((transparent-tyo t))
      (let ((specs
	      (loop for bits-and-set-spec-list being the hash-elements of style&bits&setchar-spec 
		    append
		      (loop for (bits-and-set . spec) in bits-and-set-spec-list
			    do
			(ignore bits-and-set)
			    collect spec))))
	(cl:sort specs #'< :key #'(lambda (s) (char-type-spec-type s)))
	(loop for spec in specs
	      do
	  (send self :tyo escape-quote)
	  (scl:with-standard-io-environment (prin1 spec self))
	  (cl:setf default-char-type (char-type-spec-type spec)))))))

(defmethod (:dump-simple-string escape-dumping-stream-mixin) (string start-index final-index)
  (unless (= start-index final-index)
    (send self :dump-string-internal string start-index final-index)))

(defmethod (:quote-next escape-dumping-stream-mixin) ()
  (letf ((transparent-tyo t))
    (unless dumping-fat
      (send self :start-dumping-fat))
    (send self :tyo escape-quote)))

1;;; Dump string, with escape codes whenever style, character-set, character-set offset,
;;; or bits change.
0(defmethod (:dump-hairy-string escape-dumping-stream-mixin) (string start-index final-index)
  (let ((string string)
	(transition-tbl transition-table))
    (declare (sys:array-register string transition-tbl))
    1;; start by dealing with any with-character-style-produced foolishness.
0    (loop with font-escape-code = (char-subindex escape-quote)
	  with transition-count = (fill-pointer transition-table)
	  for i = start-index then next-style-loc
	  for transition from 0 to transition-count
	  for next-style-loc = (if (< transition transition-count)
				   (aref transition-tbl transition)
				 final-index)
	  for char = (aref string i)
	  for old-char-type = (send self :default-char-type)
			    then (if must-change-type char-type old-char-type)
	  for char-type = (char-type char)
	  for char-subindex = (char-subindex char)
	  for must-change-type = (and (not transparent-tyo)
				      (or current-or-default-style-changed
					  ( old-char-type char-type))
				      (char char #\Return)) 
	  when must-change-type
	    do (send self :escape-char-type char)
	  do (cond ((and (not dumping-fat)
			 (= char-subindex font-escape-code)
			 (not (= i next-style-loc)))
		    1;; We may have to quote a password sequence here.  Start checking.
0		    (send self :start-password-stream)
		    1;; The password stream will take care of sending any extra back to us.
0		    (send password-stream :string-out string i next-style-loc)
		    1;; The above line may cause the stream to remove itself.
0		    (when password-stream
		      (send password-stream :finish)))
		   1;; If we're writing something that looks like an escape sequence or return,
0		   1;; quote it
0		   (t (when (and dumping-fat
				 (or (= char-subindex font-escape-code)
				     (and (= char-subindex (char-subindex #\return))
					  ( char-type 0))))
			1;; If the size of this interval is 0, handle this escape the next time
0			1;; around.0  1This can happen if we have  at the beginning of the line.
0			(unless (= i next-style-loc)
			  (send self :quote-next)))
		      (send self :dump-string-internal string i next-style-loc))1)
0	  finally
	    (when must-change-type
	      (send self :remember-char-type char-type)))))



;;; Mixin for filling in an array, rather than doing output to a file.
(defflavor array-filling-stream-mixin (array start-index end-index) ()
  (:required-flavors basic-dumping-stream)
  (:initable-instance-variables array start-index end-index))

(defmethod (:get-output-buffer array-filling-stream-mixin) ()
  (values array start-index end-index))

;;; for speed, shadow the method with the send-if-handles.
(defmethod (:get-output-buffer-1 array-filling-stream-mixin) ()
  (send self :get-output-buffer))

(defmethod (:advance-output-buffer array-filling-stream-mixin) (&optional new-end)
  (setq start-index (or new-end end-index)))

(defflavor 8-bit-dumping-mixin
	((indirect-16b-array (make-array 10000 :type 'art-8b
					 :displaced-index-offset 9999
					 :displaced-to "")))
	()
  (:required-flavors basic-dumping-stream))

(defmethod (:prepare-8bit-buffer 8-bit-dumping-mixin) (buffer buf-start length)
  (values buffer buf-start (+ buf-start length) (+ buf-start length)))

;;; *** This doesn't really work.  The offset is in terms of 16-bit units.
;;; Needs to do this without a buffer.  Presumably by copying, or something,
;;; if not on a 16-bit boundary?
(defmethod (:prepare-16bit-buffer 8-bit-dumping-mixin) (buffer buf-start length)
  (change-indirect-array indirect-16b-array 'art-16b length
			 buffer buf-start)
  (values indirect-16b-array 0 (* length 2) (+ buf-start (* length 2))))


(defflavor indirect-escape-output-stream ()
	   (escape-dumping-stream-mixin
	    continuous-dumping-context-mixin
	    8-bit-dumping-mixin
	    indirect-output-stream-mixin
	    basic-dumping-stream))

;;; for speed, shadow the method with the send-if-handles.
(defmethod (:get-output-buffer-1 indirect-escape-output-stream) ()
  nil)

(defflavor password-checking-stream ((index 0) stream
				     (thin-continuation nil)	1;What to do if still thin.
0				     (fat-continuation nil))	1;What to do if now fat.
0	   (output-stream character-stream)
  (:initable-instance-variables stream thin-continuation fat-continuation))

(defmethod (:tyo password-checking-stream) (char)
  (if (not index)
      1;; Done checking, pass on the rest.
0      (send stream :tyo char)
    (if (char= char (aref *fat-password* index))
	(when ( (cl:incf index) (string-length *fat-password*))
	  (when fat-continuation
	    (funcall fat-continuation)
	    (setq fat-continuation nil))
	  (send self :finish)
	  (send stream :start-dumping-thin))
      (send self :finish)
      (send stream :tyo char)))1)

0(defmethod (:finish password-checking-stream) ()
  1;; The continuation is responsible for outputing the epsilon
0  (when index
    (funcall thin-continuation)
    (send stream :string-out *fat-password* 1 index)
    (setq index nil)))				1;Any more chars go direct to the stream.


0(defflavor fonts-checking-stream ((state :start)	;:start = no attributes seen
						;:attributes = looking for Fonts:
						;:skip-attribute = This attribute isn't Fonts:
						;:done = ignore further input
				  (index 0)	;Position in token
				  (continuation))	;What to do when done.  ARG = fat-p
	   (output-stream character-stream)
  (:initable-instance-variables continuation))


(defmethod (:tyo fonts-checking-stream) (char)
  (macrolet ((new-state (state-name)
	       `(cl:setf index 0
			 state ,state-name))
	     (terminate (fat-p)
	       `(progn (funcall continuation ,fat-p)
		       (new-state :done))))
    (cl:ecase state
      (:start
	(if (char-equal char #\Return)
	    (terminate nil)
	    (if (not (char-equal char (aref "-*-" index)))
		(cl:setf index 0)
	      (incf index)
	      (when ( index 3)
		(new-state :attributes)))))
      (:attributes
	(unless (and (zerop index) (cl:find char #(#\Return #\Space #\Tab)))
	  (if (not (char-equal char (aref "Fonts:" index)))
	      (new-state :skip-attribute)
	    (incf index)
	    (when ( index 6)
	      (terminate t)))))
      (:skip-attribute
	(if (char-equal char #\;)
	    (new-state :attributes)
	  (if (not (char-equal char (aref "-*-" index)))
	      (cl:setf index 0)
	    (incf index)
	    (when ( index 3)
	      (terminate nil)))))
      (:done))))

(compile-flavor-methods indirect-escape-output-stream password-checking-stream
			fonts-checking-stream)


#||

;;; Flavor to use to dump to 8-bit streams

(defflavor 8-bit-stream-dumping-stream ()
	(8-bit-dumping-mixin stream-dumping-stream-mixin basic-dumping-stream)
  :gettable-instance-variables)


(defflavor character-stream-dumping-stream-mixin () (stream-dumping-stream-mixin))

(defmethod (:write-char character-stream-dumping-stream-mixin) (char)
  (send stream :tyo (int-char (char-subindex char))))

(defflavor indirect-escape-character-stream ()
	   (continuous-dumping-context-mixin
	    char-stream-dumping-mixin
	    escape-dumping-stream-mixin))

(defflavor 16-bit-dumping-mixin
	((indirect-8b-array (make-array 10000 :type 'art-8b
					:displaced-index-offset 9999
					:displaced-to "")))
	()
  (:required-flavors basic-dumping-stream))

(defmethod (:prepare-8bit-buffer 16-bit-dumping-mixin) (buffer buf-start length)
  (change-indirect-array indirect-8b-array 'art-8b length
			 buffer buf-start)
  (values indirect-8b-array 0 (ceiling length 2) (+ buf-start (ceiling length 2))))

(defmethod (:prepare-16bit-buffer 16-bit-dumping-mixin) (buffer buf-start length)
  (values buffer buf-start (+ buf-start length) (+ buf-start length)))


(defflavor char-stream-dumping-mixin
	((indirect-8b-array (make-array 10000 :type 'art-8b
					:displaced-index-offset 9999
					:displaced-to "")))
	()
  (:required-flavors basic-dumping-stream))

(defmethod (:prepare-8bit-buffer char-stream-dumping-mixin) (buffer buf-start length)
  (change-indirect-array indirect-8b-array 'art-8b length
			 buffer buf-start)
  (values indirect-8b-array 0 length (+ buf-start length)))
;;; Flavor to use to dump to 16-bit streams
(defflavor 16-bit-stream-dumping-stream ()
	(16-bit-dumping-mixin stream-dumping-stream-mixin basic-dumping-stream)
  :gettable-instance-variables)

;;; Flavor to use to fill 8-bit arrays
(defflavor 8-bit-array-filling-stream ()
	   (8-bit-dumping-mixin array-filling-stream-mixin basic-dumping-stream))

;;; Flavor to use to fill 16-bit arrays
(defflavor 16-bit-array-filling-stream ()
	   (16-bit-dumping-mixin array-filling-stream-mixin basic-dumping-stream))

;;; Flavor to use to fill 32-bit arrays
(defflavor 32-bit-array-filling-stream ()
	   (16-bit-dumping-mixin 8-bit-dumping-mixin array-filling-stream-mixin
	    basic-dumping-stream))

(defmethod (:prepare-16bit-buffer 32-bit-array-filling-stream) (buffer buf-start length)
  (change-indirect-array indirect-16b-array 'art-16b length
			 buffer buf-start)
  (values indirect-16b-array 0 length (+ buf-start length)))

;;; Character-and-binary-stream

(defflavor character-and-binary-stream ()
	   (continuous-dumping-context-mixin 8-bit-stream-dumping-stream))

||#

2;;; Simple Strings in Binary Files

1;;; stack-allocated indirect-array buffers.
0;;; 2(with-indirect-array (1buffer2 1array-type0 1indirect-to2 1start2 1end2)
0;;;2    . 1body2)
0;;; Allocates a temporary buffer 1buffer0 indirected to 1indirect-to0 from 1start0 to 1end0.
;;; 1Buffer0 will have array-type of 1array-type0.  1Buffer0 will have dynamic extent;
;;; that is, it will be deallocated on exit from the macro.


;;; 1Buffer0 will display as:
;;; #<INDIRECT-ARRAY 1array-type0 1%pointer0 1indirect-to0 1start0 1end0>
;;; 1Array-type0, 1indirect-to0, 1start0, and 1end0 are as above; the 1%pointer0 is the
;;; %pointer of 1buffer0.

;;; 2Warning:
0;;; If the elements of 1buffer0 are larger than 1indirect-to0, it is the caller's
;;; responsibility to pad 1indirect-to0.

(defstruct (indirect-array
	     :named
	     (:make-array (:displaced-to "Uninitialized"
			   :displaced-index-offset 512.
			   :type 'art-8b))))

(defselect ((indirect-array named-structure-invoke))
  (:print-self (object stream &rest ignore) 
   (let ((array-type (array-type object))
	 (offset (array-index-offset object)))
     (format stream "#<INDIRECT-ARRAY ~A ~O  ~S (~D~D)>"
	     array-type (%pointer object)
	     (array-indirect-pointer object)
	     offset (+ offset (array-length object))))))

(defmacro with-indirect-array
	  ((buffer buffer-array-type indirect-to &optional (start 0) end) &body body)
  `(with-indirect-array-internal
     #'(lambda (,buffer) ,@body) ,buffer-array-type ,indirect-to ,start ,end))

(defun with-indirect-array-internal
       (continuation array-type-name indirect-to &optional (start 0) end)
  (declare (sys:downward-funarg continuation))
  (let ((array-type array-type-name))
    (if (symbolp array-type)
	(setq array-type (symeval array-type))
      (setq array-type-name (nth array-type *array-type-codes*)))
    (let* ((bits-per-element (cdr (assq array-type-name array-bits-per-element)))
	   (to-array-type-name (array-type indirect-to))
	   (to-bits-per-element (cdr (assq to-array-type-name array-bits-per-element))))
      (check-arg array-type-name (not (null bits-per-element))
		 "a type name for a numeric array")
      (check-arg indirect-to (not (null to-bits-per-element))
		 "a numeric array")
      (unless end
	(setq end (array-length indirect-to)))
      (let ((size (- end start))
	    (ratio (cl:/ bits-per-element to-bits-per-element)))
	(setq size (floor size ratio))
	(with-stack-array (indirect-array size
			    :type array-type
			    :displaced-to indirect-to
			    :displaced-index-offset start
			    :named-structure-symbol 'indirect-array
			    :fill-pointer size)
	 (funcall continuation indirect-array))))))


;;; 2read-simple-string-from-binary-stream0 reads a string from a stream.
;;; The assumption is that you know how many characters you are going to
;;; read from the file.  Hence, this does not mess with EOF values, but rather
;;; signals an error if you encounter EOF while inputting a stream.

(defun read-simple-string-from-binary-stream (stream string &optional (start 0) end)
  (cl:check-type string (cl:array cl:string-char))
  (unless end
    (setq end (array-length string)))
  (let ((stream-element-type (send stream :element-type)))
    (cond ((cl:subtypep '(cl:unsigned-byte 16.) stream-element-type)
	   ;; Stream holds at least 16 bits per byte, 
	   (let* ((oddp (oddp end)))
	     (if (not oddp)
		 (with-indirect-array (buffer art-16b string start end)
		   (send stream :string-in "EOF while reading string" buffer))
	       (with-indirect-array (buffer art-16b string start (1- end))
		 (send stream :string-in "EOF while reading string" buffer))
	       (setf (aref string (1- end))
		     (int-char (ldb (byte 8 0) (send stream :tyi
						     "EOF while reading string")))))))
	  ((cl:subtypep '(cl:unsigned-byte 8) stream-element-type)
	   (with-indirect-array (buffer art-8b string start end)
	     (send stream :string-in "EOF while reading string" buffer)))
	  (t (ferror "Unknown stream element type for reading strings:  ~S"
		     stream-element-type)))
    (when (array-has-leader-p string)
      (setf (fill-pointer string) end))
    end))

;;; Write a simple string to a binary stream.

(defun write-simple-string-to-binary-stream (stream string &optional (start 0) end)
  (cl:check-type string (cl:array cl:string-char))
  (let ((stream-element-type (send stream :element-type)))
    (cond ((cl:subtypep '(cl:unsigned-byte 16.) stream-element-type)
	   (unless end
	     (setq end (array-active-length string)))
	   (let ((oddp (oddp end)))
	     (when oddp
	       (decf end))
	     (with-indirect-array (buffer art-16b string start end)
	       (send stream :string-out buffer))
	     (when oddp
	       (send stream :tyo (char-int (aref string end))))))
	  ((cl:subtypep '(cl:unsigned-byte 8) stream-element-type)
	   (with-indirect-array (buffer art-8b string start end)
	     (send stream :string-out buffer)))
	  (t (ferror "Unknown stream element type for storing strings: ~S"
		     stream-element-type)))))

1;;; "Easy-to-use" resource of epsilon encoding streams.

0(defflavor epsilon-encoding-output-stream
	((buffered-stream (make-instance '8bit-to-buffered-character-output-stream
					 :stream nil))
	 (unbuffered-stream (make-instance '8bit-to-unbuffered-character-output-stream
					   :stream nil)))
	(indirect-escape-output-stream)
  )

(defmethod (make-instance epsilon-encoding-output-stream :after) (&rest ignore)
  (when stream
    1;; If the caller supplied an initial stream, we must be certain to invoke 2:set-stream
1    ;; on the stream to insure that all proper setup takes place while being careful to0 1not
    ;; lose the caller's original option settings.
0    (let ((initial-stream stream))
      (setf stream nil)
      (lexpr-send self :set-stream initial-stream initial-options))))

(defmethod (:set-stream epsilon-encoding-output-stream)
	     (new-stream &key (reset-mappings t)
			      ((:escape-quote new-escape-quote) #\)
			      ((:dumping-fat new-dumping-fat))
			      ((:default-character-style new-dcs) (parse-character-style nil))
			      check-for-fonts-line)
1  ;; Put the new setttable options where the 2:reset-state 1message will find them later.
0  (cl:setf (cl:getf initial-options :escape-quote) new-escape-quote
	   (cl:getf initial-options :dumping-fat) new-dumping-fat
	   (cl:getf initial-options :default-character-style) new-dcs
	   (cl:getf initial-options :check-for-fonts-line) check-for-fonts-line)
  1;; Setup the new stream.
0  (cl:setf (indirect-stream-stream buffered-stream) nil
	   (indirect-stream-stream unbuffered-stream) nil)
  (multiple-value-bind (actual-new-stream)
      (cond ((null new-stream) nil)
1	    ;; The following tests are kludges! --
	    ;;    The stream protocol should provide generic functions to determine whether
	    ;;    a stream is buffered/unbuffered.  Without them, we
	    ;;    must rely on checking for specific flavors or for support of the specific
0	    1;;    methods used by the 28bit-to-buffered-character-output-stream1 flavor.
0	    ((cl:subtypep (cl:stream-element-type new-stream) '(cl:unsigned-byte 8))
	     new-stream)
	    ((cl:typep new-stream 'binary-stream)
	     (error "~S is a binary stream but is not 8-bit wide." new-stream))
	    ((and (operation-handled-p new-stream :get-output-buffer)
		  (operation-handled-p new-stream :advance-output-buffer))
	     (setf (indirect-stream-stream buffered-stream) new-stream)
	     buffered-stream)
	    (t
	     (setf (indirect-stream-stream unbuffered-stream) new-stream)
	     unbuffered-stream))
    1;; Use the I.V. accessor instead of directly setting the I.V. to guarentee that
    ;; all appropriate side effects for setting the stream take place.
0    (setf (indirect-stream-stream self) actual-new-stream))
  1;; Now get back to our initial state.
0  (send self :reset-state reset-mappings))

(defmethod (:reset-state epsilon-encoding-output-stream :after) (&optional (reset-mappings t))
  (ignore reset-mappings)
  (send buffered-stream :clear-output)
  (send unbuffered-stream :clear-output))

(compile-flavor-methods epsilon-encoding-output-stream)

(defresource epsilon-encoding-output-stream (stream
					     &key (flavor 'epsilon-encoding-output-stream)
						  (escape-quote #\)
						  dumping-fat
						  (default-character-style
						    (parse-character-style nil))
						  check-for-fonts-line)
  :constructor (make-instance flavor :stream nil
				     :escape-quote escape-quote
				     :dumping-fat dumping-fat
				     :default-character-style default-character-style
				     :check-for-fonts-line check-for-fonts-line)
  :matcher (eq (cl:type-of object) flavor)
  :initializer (send object :set-stream stream :escape-quote escape-quote
					       :dumping-fat dumping-fat
					       :default-character-style default-character-style
					       :check-for-fonts-line check-for-fonts-line)
  :deinitializer (progn
		   (send object :set-stream nil)
		   (send object :reset-state)))




;;; ****************************************************************

;;; The following sections are a reimplementation of epsilon-encoding
;;; output streams.  This implementation uses a buffered encapsulating
;;; stream, and a string-char inner stream.

;;;
;;; This stuff is incompatible with the existing epsilon-encapsulating
;;; output stuff in one important repspect:  It does *not* attempt to
;;; write rel-6 formatted files.  That means that it doesn *not* check
;;; for a fonts: attribute in the outgoing data; it always writes the
;;; standard rel-7 format epsilon password etc (at least for files that
;;; contain styled data...)

;;;
;;; Dumping styled chars happens as follows:
;;; if see a styled char, and it's bits are different from current dumping bits,
;;; lookup bits in bits-to-index table.  If failed, its a new style:  Merge style
;;; with default style; lookup result in style-to-spec table.  If not there, compute
;;; spec from style.  Make entries in bits-to-index, style-to-spec as apropriate.
;;;

(defflavor buffered-epsilon-encapsulating-output-mixin
	(state					; current state, :thin, :unstyled, :styled
	 style-to-spec-table			; #<character-style foo.bar.baz> ->
						;   '((0 0 0 nil 0) ...)
	 bits-to-index-table			; <bits> -> fixnum index
	 next-index				; starts at 0 and increments
	 (default-style nil)			; style representing bits 0
	 original-default-style			; copy of above; ref point for with-char-style
	 current-bits				; current char-bits.
	 current-offset				; current offset in current char-set
	 escape-quote				; char (or code) of the escape char

	 ;; leftover stuff from last :send-output-buffer
	 leftover-buffer			; this'll be a fat-string
	 leftover-buffer-size			; how big it is
	 leftover-buffer-length			; nbytes in it now
	 )
	(indirect-stream-mixin)
  (:initable-instance-variables default-style escape-quote)
  (:required-flavors basic-buffered-output-stream))


(defmethod (make-instance buffered-epsilon-encapsulating-output-mixin :after) (&rest ignore)
  (setq state ':thin
	style-to-spec-table (cl:make-hash-table ':test 'cl:equal ':rehash-threshold 20)
	bits-to-index-table (cl:make-hash-table ':test 'eq ':rehash-threshold 20)
	current-bits 0
	current-offset 0
	leftover-buffer nil
	leftover-buffer-size 0
	leftover-buffer-length 0)
  (unless default-style
    (setq default-style (parse-character-style '(nil nil nil))))
  (setq original-default-style default-style)
  (multiple-value-bind (char-set char-index)
      (char-char-set-and-index #\x)
    (let* ((offset (- (char-code #\x) char-index))	; 0...
	   (set-offset-and-style (list char-set offset default-style)))
      (setf (gethash set-offset-and-style style-to-spec-table)
	    (char-type-spec-from-char #\x 0 default-style))
      (setf (gethash 0 bits-to-index-table) (list 0 set-offset-and-style))))
  (setf next-index 1)				; we just defined index 0
  )

(defvar *buffered-epsilon-output-buffer-size* 4096.
  "Size of output buffer used by buffered-epsilon output streams")

(defmethod (:new-output-buffer buffered-epsilon-encapsulating-output-mixin) ()
  (values (allocate-resource 'fat-string-buffer *buffered-epsilon-output-buffer-size*)
	  0 *buffered-epsilon-output-buffer-size*))

;;;
;;; put us in 'fat' mode
;;;
(defmethod (enter-epsilon-mode buffered-epsilon-encapsulating-output-mixin) ()
  (when (eq state ':thin)
    (send stream ':string-out *fat-password*)
    (send stream ':tyo (code-char 2))		; format version
    (send stream ':string-out *fat-password-message*)
    (setq state ':unstyled)))


;;;
;;; send the fat-unpassword sequence, set back to :thin mode.  Leave state?
;;;
(defmethod (revert-to-thin-mode buffered-epsilon-encapsulating-output-mixin) ()
  (when (neq state ':thin)
    (send stream ':tyo escape-quote)
    (send stream ':tyo fat-unpassword-character)
    (setq state ':thin)))


;;; this is really obsolete, I think; leftover from when Zmacs wanted to
;;; be able to write rel-6 formatted files?
(defmethod (:clear-character-types buffered-epsilon-encapsulating-output-mixin) ()
  (cl:clrhash bits-to-index-table)
  (cl:clrhash style-to-spec-table)
  (setf next-index 0))

;;; Another obsolete one used by Zmacs.
(defmethod (:preset-character-type buffered-epsilon-encapsulating-output-mixin)
	   (&key index (bits 0) character-set (offset 0) (style *null-style*)
		 (default-font
		   (or (get-font *b&w-screen* character-set
				 (merge-character-styles style '(:fix :roman :normal)) t))
		   fonts:cptfont))
  (ignore default-font)
  (setf next-index (max next-index (1+ index)))
  (let ((char #\x))
    (cl:setf (char-char-set-index char) (send (lookup-character-set character-set)
					      :decode-offset offset)
	     (char-bits char) bits
	     (char-style-index char) (style-index style t))
    (let* ((char-bits (char-type char))
	   (spec (char-type-spec-from-char char index style))
	   (set-offset-and-style
	     (multiple-value-bind (char-set char-index)
		 (char-char-set-and-index char)
	       (list char-set (- (char-code char) char-index) style))))
      (cl:setf (gethash set-offset-and-style style-to-spec-table) spec
	       (gethash char-bits bits-to-index-table)
			(list index set-offset-and-style)))))
  

;;; Another obsolete one, used by Zmacs
(defmethod (:write-all-character-types buffered-epsilon-encapsulating-output-mixin) ()
  (cond ((= (cl:hash-table-count style-to-spec-table) 0)
	 (multiple-value-bind (char-set char-index)
	     (char-char-set-and-index #\x)
	   (let* ((offset (- (char-code #\x) char-index))	; 0...
		  (set-offset-and-style (list char-set offset default-style)))
	     (setf (gethash set-offset-and-style style-to-spec-table)
		   (char-type-spec-from-char #\x 0 default-style))
	     (setf (gethash 0 bits-to-index-table) (list 0 set-offset-and-style))))
	 (setf next-index 1))
	((and (= (cl:hash-table-count style-to-spec-table) 1)
	      (gethash (char-type #\x) bits-to-index-table)))
	(t
	 (enter-epsilon-mode self)
	 (let ((specs nil))
	   (maphash #'(lambda (ignore spec) (push spec specs)) style-to-spec-table)
	   (cl:sort specs #'< :key #'char-type-spec-type)
	   (dolist (spec specs)
	     (send stream ':tyo escape-quote)
	     (scl:with-standard-io-environment (prin1 spec stream))
	     (maphash #'(lambda (char-bits index-and-style)
			  (when (= (first index-and-style)
				   (char-type-spec-type spec))
			    (setf current-bits char-bits)))
		      bits-to-index-table)))))
  nil)

;;;
;;; Used by Mr. file-access-path-open-whopper to force an unpassword
;;; sequence when opening a file in append mode
;;;
(defmethod (:reset-character-style-state buffered-epsilon-encapsulating-output-mixin) ()
  (enter-epsilon-mode self)			; in case extant file not in eps mode
  (revert-to-thin-mode self))			; force an unpassword

;;;
;;; handed some char-bits, do suitable machinations to set our style
;;; state to match.
;;;
(defmethod (switch-to-style buffered-epsilon-encapsulating-output-mixin) (char char-bits)
  (block switch-to-style
    (when (= char-bits current-bits) 
      (return-from switch-to-style :unchanged))
    (enter-epsilon-mode self)			; just in case
    (let (index style spec)
      (setq index (first (gethash char-bits bits-to-index-table)))
      (when index
	;; the easy case; we've already got an index for this particular
	;; configuration of char-bits
	(send stream ':tyo escape-quote)
	(if (> index 9)
	    (progn 
	      (send stream ':tyo #\()
	      (scl:with-standard-io-environment (prin1 index stream))
	      (send stream ':tyo #\)))
	    (send stream ':tyo (code-char (+ index (char-code #\0)))))
	(setq current-bits char-bits)
	;; find the spec that matches this index, so we can set current-offset
	(let ((matching-key (second (gethash char-bits bits-to-index-table))))
	  (unless matching-key
	    (error "Internal error: No matching char spec for type ~D" index))
	  (setq current-offset (second matching-key)))
	(return-from switch-to-style :predefined))
      
      ;; bits not already defined, see if merging with default style buys
      ;; us a style that is defined.
      (setq style (merge-character-styles (char-style char) default-style))

      ;; Oops! this is busted.  need to take into account char-set and offset too...
      ;; (setq spec (gethash style style-to-spec-table))

      (multiple-value-bind (char-set char-index)
	  (char-char-set-and-index char)
	(setq current-offset (- (char-code char) char-index))
	(let ((set-offset-and-style (list char-set current-offset style)))
	  (setq spec (gethash set-offset-and-style style-to-spec-table))
	  ;; if we bought a spec, use the index from it
	  (if spec
	      (progn
		(setq index (char-type-spec-type spec))
		(send stream ':tyo escape-quote) 
		(if (> index 9)
		    (progn 
		      (send stream ':tyo #\()
		      (scl:with-standard-io-environment (prin1 index stream))
		      (send stream ':tyo #\)))
		    (send stream ':tyo (code-char (+ index (char-code #\0))))))
	      ;; no spec matching this one?  ok, construct the spec, and stuff it in
	      ;; the hash table.
	      (progn
		(setq index next-index)
		(incf next-index)
		(setq spec (char-type-spec-from-char char index style))
		(setf (gethash set-offset-and-style style-to-spec-table) spec)
		;; write the spec into the stream
		(send stream ':tyo escape-quote)
		(scl:with-standard-io-environment (prin1 spec stream))))
	  ;; put this bits->index translation back for next time
	  (setf (gethash char-bits bits-to-index-table)
		(list index set-offset-and-style))
	  ;; remember what style we're in now
	  (setq current-bits char-bits)
	  ;; done!  ready to write out the char.
	  :new-style
	  )))))

;;;
;;; collect the ugly string comparison against fat-password in one place
;;;
(defun string-matches-fat-password-p (string start end &optional (offset 0))
  (declare (values t-nil-or-partial))
  (let* ((remaining-password-length (- (string-length *fat-password*) offset))
	 (limit (min remaining-password-length (- end start)))
	 (match (zerop (string-compare string *fat-password* 
				       start offset (+ start limit) (+ offset limit)))))
    (if match
	(if (< limit remaining-password-length)
	    ':partial
	    t)
	nil)))

(defmethod (send-quoted-fat-password buffered-epsilon-encapsulating-output-mixin) ()
  (enter-epsilon-mode self)
  (send stream ':string-out *fat-password*)
  (setf leftover-buffer-length 0)		; no more leftovers
  (revert-to-thin-mode self))

;;;
;;; send this (sub)string to inner stream, with suitable encoding.  this
;;; function checks for epsilons in the data (so they can be quoted if
;;; necessary) and deals with checking for style shifts.
;;;
(defmethod (really-send-buffer buffered-epsilon-encapsulating-output-mixin) 
	   (buffer start end check-for-password)
  (let ((buffer buffer)				; boy, do I hate this compiler bug...
	(need-new-buffer-p nil)			; this flag tells us when we need
						;  to refresh inner-buf etc.
						;  we wouldn't need it if the compiler 
						;  worked right...
	)
    (declare (sys:array-register buffer))
    (multiple-value-bind (inner-buf inner-start inner-end)
	(send stream ':get-output-buffer)
      (let ((inner-buf inner-buf))
	(declare (sys:array-register inner-buf))
	(loop until (>= start end)		; while there's more data to process
	      with inner-index			; index into inner buf
	      with escape-quote-subindex = (char-subindex escape-quote)
	      with return-subindex = (char-subindex #\Return)
	      do
	  (when need-new-buffer-p
	    (cl:multiple-value-setq (inner-buf inner-start inner-end) 
	      (send stream ':get-output-buffer))
	    (setq need-new-buffer-p nil))
	  (setq inner-index inner-start)
	  (multiple-value-bind (char char-bits must-quote-p)
	      (loop named copying-segment
		    until (>= start end)
		    for this-char = (aref buffer start)
		    for subindex = (char-subindex this-char)
		    do (cond ((= subindex escape-quote-subindex)
			      ;; Anything that looks like an escape quote may need to be quoted
			      (return (values this-char nil t)))
			     ((= subindex return-subindex)
			      ;; Unquoted Return is a real Return.  A character in the current
			      ;; character set whose subindex is Return must be quoted.
			      (if (zerop (char-type this-char))
				  (setf (aref inner-buf inner-index) #\Return)
				  (return (values this-char nil t))))
			     ((let ((bits (char-ldb-internal %%char-all-but-subindex this-char)))
				;; Style or character set changed.
				(when ( bits current-bits)
				  (return (values this-char bits nil)))))
			     (t
			      ;; Current style and character set -- Stick it into the buffer.
			      (setf (aref inner-buf inner-index)
				    (code-char (- (char-int this-char) current-offset)))))
		       ;; Only get here if we've put another character into the buffer.
		       (incf inner-index)
		       (when (>= inner-index inner-end)
			 ;; exhausted inner buffer.  flush this one and get a fresh one
			 (send stream ':advance-output-buffer)
			 (cl:multiple-value-setq (inner-buf inner-start inner-end) 
			   (send stream ':get-output-buffer))
			 (setq inner-index inner-start))
		       (incf start)
		    finally			; end of buffer
		      (return (values nil nil nil)))
	    ;; advance output buffer index if necessary
	    (when (> inner-index inner-start)
	      (send stream ':advance-output-buffer inner-index)
	      (setq inner-start inner-index))
	    ;; Decide what to do based on why we stopped.
	    (cond (must-quote-p
		   ;; A character that needs quoting --
		   ;;    If it's an , decide on what to do based on our current state.
		   (if (char= char escape-quote)
		       (cl:case state 
			 (:thin
			   ;; see if it's a fat-password
			   (let ((match (and check-for-password
					     (string-matches-fat-password-p 
					       buffer start end))))
			     (cond
			       ((eq match ':partial)
				;; drat.  partial match.  set leftover buffer to this 
				;; segment, and return
				(unless leftover-buffer
				  (setq leftover-buffer
					(allocate-resource 'fat-string-buffer
							   (string-length *fat-password*)))
				  (setq leftover-buffer-size (string-length *fat-password*)))
				(copy-array-portion buffer start end 
						    leftover-buffer 0 (- end start))
				(setq leftover-buffer-length (- end start))
;				(dbg:when-mode-lock 
;				  (format t "~&stashing leftover segment ~S"
;					  (substring leftover-buffer 0 leftover-buffer-length))
;				  )
				(return))
			       ((null match)
				;; not fat-password.  just write out the escape and keep going.
				(send stream ':tyo escape-quote)
				(incf start)
				(setq need-new-buffer-p t))
			       (t
				;; it is the fat-password.  go to fat mode, write it out, and 
				;; revert to thin mode
				(enter-epsilon-mode self)
				(let ((end-of-password
					(+ start (string-length *fat-password*))))
				  (really-send-buffer self buffer      
						      start
						      end-of-password
						      nil)
				  ;; skip the part we just wrote
				  (setq start end-of-password))
				(revert-to-thin-mode self)
				(setq need-new-buffer-p t)))))
			 ((:unstyled :styled)
			  ;; send an extra escape, to escape the escape in the user's data.
			  (send stream ':tyo escape-quote)	; the quote
			  (send stream ':tyo escape-quote)	; the quoted quote
			  (incf start)		; skip the quote we just wrote
			  (setq need-new-buffer-p t)))
		       ;; Any other character that must be quoted.
		       (let ((bits (char-type char)))
			 (when (eq state :thin)
			   (enter-epsilon-mode self))
			 (when ( bits current-bits)
			   (switch-to-style self char bits))
			 (send stream ':tyo escape-quote)
			 (send stream ':tyo (code-char (char-subindex char)))
			 (incf start)
			 (setq need-new-buffer-p t))))
		  (char-bits
		   ;; font shift
		   (switch-to-style self char char-bits)
		   ;; (unless (= char-bits current-bits) (cl:error" ??"))
		   ;; (decf start)			; back up index, so as to process this char again
		   (setq need-new-buffer-p t)))
	    )))					; end of outer loop
      )))



(defmethod (:with-character-style buffered-epsilon-encapsulating-output-mixin)
	   (style continuation arg  bind-line-height)
  (ignore bind-line-height)
  (let ((saved-default-style default-style)
	(new-default-style (merge-character-styles style default-style)))
    (if (eq new-default-style default-style)
	;; no-op, just run the continuation
	(funcall continuation arg)
	;; change to that style, and set it as the default within this scope
	(unwind-protect				
	    (progn
	      (send self ':force-output)	; send what we've got
	      (setq default-style new-default-style)
	      (funcall continuation arg))
	  (progn
	    ;; now put it all back
	    (send self ':force-output)		; force out styled stuff
	    (setq default-style saved-default-style))))))

(defmethod (:send-output-buffer buffered-epsilon-encapsulating-output-mixin) 
	   (buffer end &optional ignore)
  (block send-output-buffer			; so we can return out of it
    (let ((start 0)
	  (buffer buffer))
      (declare (sys:array-register buffer))

      (flet ((stylify-buffer (buf start end)
	       (let ((buf buf))
		 (declare (sys:array-register buf))
		 (loop for i from start below end
		       for char = (aref buf i)
		       for merged-char = (make-character char :style
							 (merge-character-styles (char-style char)
										 default-style))
		       do (setf (aref buf i) merged-char)))))
	(when (eq state ':thin)
	  ;; if there's a leftover buffer, check to see if it and the new
	  ;; buffer contain an epsilon-password that'll need escaping
	  (when (plusp leftover-buffer-length)
	    (let ((this-buffer-continues-password
		    (string-matches-fat-password-p buffer 0 end leftover-buffer-length)))
	      (cond ((eq this-buffer-continues-password ':partial)
		     ;; what!?!  another piece of the password that's still incomplete???
		     ;; good grief.  tack it on.
;		   (dbg:when-mode-lock
;		     (format t "~&adding new segment ~S" (substring buffer 0 end)))
		     (copy-array-portion buffer 0 end
					 leftover-buffer leftover-buffer-length 
					 (+ end leftover-buffer-length))
		     (incf leftover-buffer-length end)
		     (return-from send-output-buffer))
		    ((null this-buffer-continues-password)
		     ;; false alarm, this wasn't really the fat password.
		     ;; fall thru to case below that'll send what we have.
		     )
		    (t
		     ;; it is the fat-password, in two parts.  go to fat
		     ;; mode, and send it.
		     (enter-epsilon-mode self)
		     (really-send-buffer self leftover-buffer 0 leftover-buffer-length nil)
		     (setq start (- (string-length *fat-password*) leftover-buffer-length))
;		   (dbg:when-mode-lock 
;		     (format t "~&flushing segments ~S and ~S"
;			     (substring leftover-buffer 0 leftover-buffer-length)
;			     (substring buffer 0 start)))
		     (really-send-buffer self buffer 0 start nil)
		     (revert-to-thin-mode self)
		     (setq leftover-buffer-length 0))))))

	;; if there's still a leftover buffer for whatever reason, just send it.
	(when (plusp leftover-buffer-length)
	  (when (neq default-style original-default-style)
	    ;; blech.  we're inside a with-character-style.  must go thru
	    ;; data merging style against current default
	    (stylify-buffer leftover-buffer 0 leftover-buffer-length))
	  (really-send-buffer self leftover-buffer 0 leftover-buffer-length nil)
	  (setq leftover-buffer-length 0))

	;; now send the rest.  really-send-buffer will set up leftover buffer
	;; as needed if it sees a partial fat-password.
	(when (neq default-style original-default-style)
	  ;; blech.  we're inside a with-character-style.  must go thru
	  ;; data merging style against current default
	  (stylify-buffer buffer start end))
	(really-send-buffer self buffer start end t)))
    (deallocate-resource 'fat-string-buffer buffer)))



(defmethod (:discard-output-buffer buffered-epsilon-encapsulating-output-mixin) (buffer)
  (deallocate-resource 'fat-string-buffer buffer))

;;; ****************************************************************

;;; read/set pointer etc

;;; ****************************************************************

;;; read/set pointer etc

(defmethod (:read-pointer buffered-epsilon-encapsulating-output-mixin) ()
  ;; (send self ':force-output)			; get everything sync'ed up
  (+ (send stream ':read-pointer)
     (or (and stream-output-buffer stream-output-index)
	 0)))

(defmethod (:set-pointer buffered-epsilon-encapsulating-output-mixin) (p)
  (unless (zerop p)
    (error ":SET-POINTER is only supported for pointer value 0"))
  (revert-to-thin-mode self)
  (send stream ':set-pointer 0))

;;; ****************************************************************

;;; Diagramology

(defmethod (:can-accept-diagrams-as-lines buffered-epsilon-encapsulating-output-mixin) () t)

;;; stolen from escape-dumping-stream-mixin
(defwhopper (:line-out buffered-epsilon-encapsulating-output-mixin) (line &rest args)
  (if (and (not (stringp line))
	   (instancep line))
      (multiple-value-bind (encoded-line escape-p)
	  (send line :string-for-file)
	(if (not escape-p)
	    (continue-whopper encoded-line)
	    (progn
	      ;; get back in sync
	      (send self ':send-current-output-buffer nil)
	      (when (eq state ':thin)
		(enter-epsilon-mode self))
	      (send stream :tyo escape-quote)
	      (send stream :tyo #\#)
	      (send stream ':line-out encoded-line))))
      (lexpr-continue-whopper line args)))

;;; ****************************************************************

;;; an instantiable flavor

(defflavor string-char-epsilon-output-mixin
	()
	()
  (:required-flavors buffered-epsilon-encapsulating-output-mixin)
  (:default-init-plist :escape-quote #\))

(defflavor string-char-epsilon-output-stream
	()
	(buffered-smart-fresh-line-mixin
	 line-output-stream-mixin
	 string-char-epsilon-output-mixin 
	 buffered-epsilon-encapsulating-output-mixin
	 character-stream
	 buffered-output-stream
	 future-common-lisp:file-stream))

(compile-flavor-methods string-char-epsilon-output-stream)
