;;; -*- Base: 10; Mode: LISP; Package: NSAGE; Syntax: Common-lisp; -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; Establish real protocols, including all the flavors (structure, node, diagram)
;;; for each directive and all the methods on those flavors.
;;; Write real defgenerics and comment them.
;;;
;;; "Outline mode"
;;;
;;; Drive line indentation off environment type and parameters.
;;;
;;; Representation of tables.  Alignment prototype exists, do we need an envr to
;;; set the bounds for re-alignment?  Electric table mode?
;;;
;;;================================================================
;;; Other editor stuff
;;;
;;; Visible whitespace mode (tabs, spaces, paragraph breaks, item breaks).
;;;
;;;============================================================

;;; generate the right kind of Zwei node structure for each Sage structure

(defmethod D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")(zwei:markup-structure-editor-node sage-directive-inferiors-mixin)
0	   (the-superior)
  (let ((node (zwei:get-markup-structure-editor-node self the-superior)))
    (setf (zwei:node-inferiors node)
	  (loop for inferior in (directive-inferiors self)
		for n = (zwei:markup-structure-editor-node inferior node)
		when n
		  collect it))
    node))

(defvar 1*zwei-nodes-for-record-table*0 (make-hash-table))

;;; We keep track of all the editor nodes for each record.
(defun 1add-node-for-record0 (record new-node)
  (unless (loop for node in (gethash record *zwei-nodes-for-record-table*)
		when (eq (send node :superior) (send new-node :superior))
		  do (return t))
    (push new-node (gethash record *zwei-nodes-for-record-table*))))

;;; Useful for debugging and patches
(defun 1refill-node-table0 ()
  (clrhash *zwei-nodes-for-record-table*)
  (tv:dolist-noting-progress (buffer zwei:*zmacs-buffer-list* "Updating recordnode registry")
    (when (typep buffer 'zwei:markup-buffer)
      (dolist (node (zwei:node-inferiors buffer))
	(when (typep node 'zwei:record-structure-node)
	  (let ((record (zwei:markup-structure-node-markup-structure node)))
	    (add-node-for-record record node)))))))

(defun 1remove-node-for-record0 (record-node)
  (let ((record (zwei:markup-structure-node-markup-structure record-node)))
    (modify-hash *zwei-nodes-for-record-table*
		 record
		 #'(lambda (record nodes found-p)
		     (ignore record)
		     (when found-p
		       (remove record-node nodes))))))

;;; ---Why use this instead of find-home-node-for-record??
(defun 1markup-structure-node-for-record0 (record &optional in-buffer)
  (let ((nodes (gethash record *zwei-nodes-for-record-table*)))
    (if in-buffer
	(flet ((ultimate-node-superior (original-node)
		 (loop for node = original-node
		       then (zwei:node-superior node)
		       when (null (zwei:node-superior node))
			 return node)))
	  (find-if (lambda (node)
		     (eq (ultimate-node-superior node)
			 in-buffer))
		   nodes))
	(first nodes))))

;;; Finds the record node that is the top-level record-node in the record's
;;; file.  --- should this ensure-record-in-editor first?
;;; This function figures out which of the possibly many zwei nodes for
;;; a record is the one that represents the "home" node in the record's
;;; "home" file.
(defun 1find-home-node-for-record0 (record)
  (let ((nodes (gethash record *zwei-nodes-for-record-table*)))
    (if (and nodes (null (cdr nodes)))
	;; If there's exactly one node, that's it.
	(first nodes)
	;; Rate each node on the basis of its superior.
	(let* ((record-file (doc-record-sab-file record))
	       (record-file-translated
		 (and record-file (send record-file :translated-pathname)))
	       (record-file-translated-newest
		 (and record-file-translated
		      (send record-file-translated :new-version :newest))))
	  (block winner
	    (flet ((compute-node-score (node)
		     (let* ((superior (zwei:node-superior node)))
		       (typecase superior
			 (zwei:file-markup-buffer
			   (let* ((buffer-file
				    (send superior :pathname))
				  (record-file-to-compare
				    (if (eql (send buffer-file :version)
					     :newest)
					record-file-translated-newest
					record-file-translated)))
			     (if (and record-file
				      (eql buffer-file record-file-to-compare))
				 ;; A file buffer whose pathname is the record's
				 ;; home sab file is an automatic winner.
				 ;; Short circuit the rest of the computation.
				 1(return-from winner node)
0				 ;; Even if the pathnames don't match, a file
				 ;; buffer is better than a non-file buffer.
				 2)))
			 (zwei:markup-buffer
			   ;; A non-file markup-buffer (perhaps just created) is OK.
			   1)
			 (otherwise
			   ;; Random buffers are right out, and probably can't happen.
			   0)))))
	      (let ((winner))
		(loop with high-score = 0
		      for node in nodes
		      for score = (compute-node-score node)
		      do
		  (when ( score high-score)
		    (setq winner node
			  high-score score)))
		;;--- A NIL answer is OK, but flag them for now for debugging
		(unless winner
		  (when *debugging-sage*
		    (cerror "Return NIL"
			    "Can't file a home node for record ~S (internal error)" record)))
		winner)))))))

(defun 1collapse-all-other-record-nodes0 (record-node)
  (let* ((markup-structure (zwei:markup-structure-node-markup-structure
			     record-node))
	 (nodes (gethash markup-structure *zwei-nodes-for-record-table*)))
    ;; Move selected node to the front of the list.
    (setq nodes (delete-if #'(lambda (node) (eq (send node :superior)
						(send record-node :superior)))
			   nodes))
    (setf (gethash markup-structure *zwei-nodes-for-record-table*)
	  (cons record-node nodes))
    (map nil #'zwei:collapse-record-node nodes)))

(defun 1move-boundary-bps-of-all-other-record-nodes0 (record-node)
;; Move all bps to beginning of node for all nodes except record-node.
  (let* ((markup-structure (zwei:markup-structure-node-markup-structure
			     record-node))
	 (nodes (gethash markup-structure *zwei-nodes-for-record-table*)))
    (setq nodes (delete-if #'(lambda (node) (eq (send node :superior)
						(send record-node :superior)))
			   nodes))
    (dolist (node nodes)
      (zwei:move-nonboundary-bps-of-node-to node (zwei:node-first-bp node)))))

;; This method shadows method sage-directive-inferiors-mixin
(defmethod 1(zwei:markup-structure-editor-node doc-record)0 (the-superior)
  (let ((node (zwei:get-markup-structure-editor-node self the-superior)))
    (let ((sage-subnodes (delete nil (record-fields-for-editing self))))
      (let ((zwei-inferiors
	      (zwei:zcollecting-into (zwei-inferiors)
		(dolist (inferior sage-subnodes)
		  (let ((n (zwei:markup-structure-editor-node inferior node)))
		    (when n (zwei:zcollect zwei-inferiors n))))
		zwei-inferiors)))
	(setf (zwei:node-inferiors node) zwei-inferiors)))
    (add-node-for-record self node)
    (collapse-all-other-record-nodes node)
    node))

(defmethod 1(zwei:markup-structure-editor-node killed-record)0 (the-superior)
  (let ((node (zwei:get-markup-structure-editor-node self the-superior)))
    node))

(defmacro-in-flavor (1construct-record-fields-for-editing0 doc-record) (&rest field-names)
  `(list ,@(mapcar (lambda (field-spec)
		      (etypecase field-spec
			((cons)
			 `(,(second field-spec) self))
			((symbol) `,field-spec)))
		    field-names)))

;; This hairy macro is just so we can keep all the definitions in sync
(defmacro 1define-record-fields-for-editing0 (zmacs-needs-a-symbol-here
					    &body flavors-names-and-accessors)
  (let ((function-parent-declaration
	  `(declare (sys:function-parent ,zmacs-needs-a-symbol-here
					 define-record-fields-for-editing))))
  `(progn
     ;; Returns a list of record-fields, except that some slots may be NIL
     (defgeneric 1record-fields-for-editing0 (doc-record)
       ,function-parent-declaration
       (:method-combination :nconc)
       ,@(mapcar (lambda (flavor-and-names-and-accessors)
		   (destructuring-bind (flavor &rest names-and-accessors)
		       flavor-and-names-and-accessors
		     `(:method (,flavor)
		       (construct-record-fields-for-editing ,@names-and-accessors))))
		 flavors-names-and-accessors))
     ;; Returns a list of record-field names, precisely corresponding to the above
     (defgeneric 1record-field-names-for-editing0 (doc-record)
       ,function-parent-declaration
       (:method-combination :append)
       ,@(mapcar (lambda (flavor-and-names-and-accessors)
		   (destructuring-bind (flavor &rest names-and-accessors)
		       flavor-and-names-and-accessors
		     `(:method (,flavor)
		       ',(mapcar (lambda (name-or-accessor)
				   (if (symbolp name-or-accessor)
				       name-or-accessor
				       (first name-or-accessor)))
				 names-and-accessors))))
		 flavors-names-and-accessors))
     ;; Returns, like record-field-names-for-editing, a list of record-field names,
     ;; but precisely those we want to offer in newly created records
     (defgeneric 1record-field-names-for-creation0 (doc-record)
       ,function-parent-declaration
       (:method-combination :append)
       ,@(mapcar (lambda (flavor-and-names-and-accessors)
		   (destructuring-bind (flavor &rest names-and-accessors)
		       flavor-and-names-and-accessors
		     `(:method (,flavor)
		       ',(delete nil
				 (mapcar (lambda (name-or-accessor)
					   (cond ((symbolp name-or-accessor)
						  name-or-accessor)
						 ((eq (third name-or-accessor)
						      :suppress-auto-creation)
						  nil)
						 (T (first name-or-accessor))))
					 names-and-accessors)))))
		 flavors-names-and-accessors))
     ;; Creates a new record field, of the given name
     (defun 1new-record-field-for-editing0 (doc-record field-name)
       ,function-parent-declaration
       (multiple-value-bind (accessor setter)
	   (ecase field-name
	     ,@(mapcan (lambda (flavor-and-names-and-accessors)
			 (destructuring-bind (flavor &rest names-and-accessors)
			     flavor-and-names-and-accessors
			   (ignore flavor)
			   (mapcar
			     (lambda (name-or-accessor)
			       (let* ((name (if (symbolp name-or-accessor)
						name-or-accessor
						(first name-or-accessor)))
				      (access (intern (string-append 'doc-record- name))))
				 `(,name (values #',access #'(setf ,access)))))
			     names-and-accessors)))
		       flavors-names-and-accessors))
	 ;; This used to complain if the field already exists.
	 (or (funcall accessor doc-record)
	     (let ((new-field (make-record-field doc-record :edited (list ""))))
	       (funcall setter doc-record new-field)
	       new-field)))))))
	 
(define-record-fields-for-editing 1define-record-fields-for-editing
0  ;; All doc records have these fields
  (doc-record
    (source-topic doc-record-source-topic :suppress-auto-creation)
    contents
    oneliner
    keywords
    (related doc-record-related :suppress-auto-creation)
    (notes doc-record-notes :suppress-auto-creation))
  ;; (2 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")Some 0Lisp records have an arglist
  (lisp-record
    (arglist doc-record-arglist :suppress-auto-creation))
  ;; So far, nothing extra for concept records
  (concept-record
    (source-title doc-record-source-title :suppress-auto-creation))
  )

(defmethod 1(zwei:markup-structure-editor-node sage-text-structure)0 (node-superior)
  (setf (zwei:node-superior interval) node-superior)
  (setf (zwei:markup-structure-node-total-indentation interval) nil)
  ;; the zwei interval was created at make-instance time
  interval)

(defmethod 1(zwei:markup-structure-editor-node sage-command)0 (the-superior)
  (let ((node (zwei:get-markup-structure-editor-node self the-superior)))
    node))

(defwhopper 1(zwei:markup-structure-editor-node editable-sage-command)0 (the-superior)
  (let ((node (continue-whopper the-superior))
	(set-expanded-view? t))
2    (ignore set-expanded-view?)			;for now
0    2#+ignore
0    (multiple-value-bind (min-pos max-pos non-pos pos keys any-keys list-of all)
	(sage-command-arglist-pattern self)
      (ignore min-pos max-pos non-pos)
      (when (and (not keys) (not any-keys) (not list-of) (not all)
		 (or (null pos)
		     (= (length pos) 1)))
	(setq set-expanded-view? nil)))
    ;; The folowing setf would set editable sage commands to be expanded too often.  This
    ;; method gets called a lot (e.g., when deleting editable sage commands).  The net
    ;; result was that if you changed all editable sage commands to :normal view and
    ;; deleted one, all the others would flip back to expanded view.
    2#+ignore
0    (when set-expanded-view?
      (setf (zwei:markup-structure-node-node-view node) ':expanded))
    node))

(defmethod 1(zwei:markup-structure-editor-node sage-macro-call)0 (the-superior)
  (zwei:get-markup-structure-editor-node self the-superior))

(defmethod 1(zwei:markup-structure-editor-node sage-reference)0 (the-superior)
  (let ((node (zwei:get-markup-structure-editor-node self the-superior)))
    ;; --- Give expandable references a dummy inferior that we can replace
    ;;  with the record node when we expand the reference.
    #+expand-references-in-line			;--- in-line expansion has been repudiated.
    (when (reference-is-expandable self)
      (let ((dummy-inferior (make-sage-zwei-interval)))
	(setf (zwei:node-superior dummy-inferior) node)
	(push dummy-inferior (zwei:node-inferiors node))))
    node))

;;; Return one of the supported reference views
;;; (This looks as if it ought to be related to canonicalize-view-and-field
;;; since they are sort of both doing the same kind of job.)
(defun 1decode-view-10 (view)
  (declare (values view new-view new-appearance))
  (labels ((alike (thing key) (or (eq thing key) (string-equal thing key)))
	   (decode-atom (atom)
	     (cond ((or (null atom) (alike atom 'expand)) 'include)
		   ((or (member atom '(crossref crossreference) :test #'alike))
		    'crossreference)
		   ((alike atom 'contents) 'contents)
		   ((alike atom 'topic) 
		    (values 'crossreference 'crossreference 'topic)
		    )
		   ((alike atom 'precis) 'precis)
		   (T 'complex))))
    (decode-atom view)))

(defmethod 1(sage-reference-decode-view sage-reference)0 ()
  "One of the supported reference views (see *reference-views*)"
  (labels ((decode-atom (thing)
	     (multiple-value-bind (decoded-view new-view new-appearance)
		 (decode-view-1 thing)
	       (when new-view (setq view new-view))
	       (when new-appearance
		 (setq appearance new-appearance)
		 (unless booleans
		   (setq booleans (crossreference-appearance-default-booleans appearance))))
	       decoded-view)))
    (cond ((null view)
	   (cond ((null field) 'include)
		 ((consp field)
		  (cond ((eql 1 (length field))
			 (decode-atom (first field)))
			(T 'complex)))
		 (T (decode-atom field))))
	  ((consp view)
	   ;; ---we could diagnose non-null field here but who would we report it to?
	   (cond ((eql 1 (length view))
		  (decode-atom (first view)))
		 (T 'complex)))
	  (T (decode-atom view)))))

(defmethod 1(reference-is-expandable sage-reference)0 ()
  (member (sage-reference-decode-view self) '(expand contents)))

(defmethod 1(zwei:markup-structure-editor-node sage-picture)0 (the-superior)
  (let ((node (zwei:get-markup-structure-editor-node self the-superior)))
    node))

;;; Duplicate of the one on sage-command, since there's no mixin between that and
;;; sage-directive (sage-picture would like it also).
(defmethod 1(zwei:markup-structure-editor-node example-record-marker)0 (the-superior)
  (let ((node (zwei:get-markup-structure-editor-node self the-superior)))
    node))

(defmethod 1(zwei:markup-structure-check-inferiors-recursively sage-directive-inferiors-mixin)
0	   ()
  ())

(defmethod 1(zwei:markup-debugging-describe doc-record)0 (stream)
  (brief-print-self self stream))
(defmethod 1(zwei:markup-debugging-describe sage-directive)0 (stream)
  (brief-print-self self stream))

;;;============================================================

;;;Perhaps this would better be done with a class variable. Fixed in CLOS.
(zwei:associate-structure-flavor-with-node-flavor sage-directive zwei:markup-structure-node)
;;(zwei:associate-structure-flavor-with-node-flavor sage-text zwei:markup-structure-text-node)
  
(zwei:associate-structure-flavor-with-node-flavor doc-record zwei:record-structure-node)
(zwei:associate-structure-flavor-with-node-flavor killed-record
						  zwei:killed-record-structure-node)
(zwei:associate-structure-flavor-with-node-flavor record-field
						  zwei:doc-record-field-structure-node)
(zwei:associate-structure-flavor-with-node-flavor sage-envr zwei:environment-structure-node)
(zwei:associate-structure-flavor-with-node-flavor sage-command zwei:command-structure-node)
(zwei:associate-structure-flavor-with-node-flavor sage-reference zwei:reference-structure-node)
(zwei:associate-structure-flavor-with-node-flavor sage-macro-call zwei:macro-call-structure-node)
(zwei:associate-structure-flavor-with-node-flavor sage-picture zwei:picture-structure-node)
(zwei:associate-structure-flavor-with-node-flavor example-record-marker
						  zwei:example-record-marker-structure-node)

(zwei:associate-structure-flavor-with-node-flavor sage-command-contents-field
						  zwei:sage-command-contents-field-structure-node)
(zwei:associate-structure-flavor-with-node-flavor sage-command-any-keys-field
						  zwei:sage-command-any-keys-field-structure-node)
(zwei:associate-structure-flavor-with-node-flavor sage-command-any-keys-contents-list-field
						  zwei:sage-command-any-keys-contents-list-field-structure-node)
(zwei:associate-structure-flavor-with-node-flavor editable-sage-command
						  zwei:editable-command-structure-node)

(zwei:associate-structure-flavor-with-node-flavor sage-command-arg-field
						  zwei:sage-command-arg-structure-node)

;;;============================================================

;;; Tree surgery

#|
====================
splice-node-at-point
!  splice-node-around-text						splice-sage-structure-around-text
!  !  markup-structure-node-markup-structure
!  !  split-node-tree-around-leaves					split-sage-structure-around-leaves
!  !  !  insert-node-in-node-tree					insert-structure-near-sibling
!  !  !  node-adjust-for-new-inferiors
!  !  !  !  markup-structure-node-markup-structure
!  !  !  !  markup-line-diagram-mixin-markup-structure
!  !  !  split-off-right-inferiors					sage-structure-split-off-right-inferiors
!  !  !  !  node-adjust-for-new-inferiors  
!  !  !  !  insert-node-in-node-tree  
!  !  !  !  markup-structure-node-markup-structure
!  !  !  !  (setf markup-structure-node-markup-structure)
!  !  !  !  make-markup-node
!  !  !  split-tree-up-to-node						split-sage-structure-up-to-node
!  !  !  !  split-off-right-inferiors  
!  !  !  !  split-off-left-inferiors					sage-structure-split-off-left-inferiors
!  !  !  !  !  node-adjust-for-new-inferiors  
!  !  !  !  !  insert-node-in-node-tree  
!  !  !  !  !  markup-structure-node-markup-structure
!  !  !  !  !  (setf markup-structure-node-markup-structure)
!  !  !  !  !  make-markup-node
!  !  node-tree-boundary-leaves					sage-structure-split-boundary-leaves
!  !  !  split-node							split-sage-structure
!  !  find-superior-of-type-enclosing-region
====================
     splice-node-at-point
         splice-node-around-text
             markup-structure-node-allowable-superiors
             find-superior-of-type-enclosing-region
             node-tree-boundary-leaves			sage-structure-split-boundary-leaves
	 split-node					split-sage-structure
             						   insert-structure-near-sibling  
	     split-node-tree-around-leaves		?
	 split-tree-up-to-node
	     split-off-left-inferiors
	     split-off-right-inferiors
	 split-off-right-inferiors
	     insert-node-in-node-tree
	     node-adjust-for-new-inferiors
	 node-adjust-for-new-inferiors
	 insert-node-in-node-tree			insert-structure-near-sibling
             splice-structure-in
             check-record-structure-against-node
             markup-structure-check-inferiors
|#

;; was split-node
(defgeneric 1split-sage-structure0 (sage-structure start-bp end-bp)
  (declare (values left-structure old-structure right-structure)))

;;---Maybe this is defun after all, except then we just have to type check the structure
(defmethod 1(split-sage-structure sage-text-structure)0 (start-bp end-bp)
  (let ((first-bp (zwei:interval-first-bp interval))
	(last-bp (zwei:interval-last-bp interval))
	structure-before structure-after)
    ;; --- Maybe we should flush all the BP checking and moving from this code
    ;; since our only caller, SAGE-STRUCTURE-SPLIT-BOUNDARY-LEAVES, takes care
    ;; of it.  That way we wouldn't have to duplicate all the kludges so often.
    ;; (e.g. the bp-= test in the end-bp clause below)
    ;; --- Further analysis shows that this code should never be called
    ;; with a bp that is at either end of a node, since the caller should
    ;; realize that this is a case that needs no splitting.  Thus, the real
    ;; bug was in the caller.  Still, this checking code seems worse than useless.
    (when start-bp
      (unless (zerop (zwei:bp-index start-bp))
	(error "start-bp not at line boundary ~s (internal error)" start-bp)))
    (when end-bp
      (cond ((zerop (zwei:bp-index end-bp)) nil)
	    ((= (zwei:bp-index end-bp) (zwei:line-length (zwei:bp-line end-bp)))
	     (unless (zwei:bp-= end-bp last-bp)	;don't advance across nodes
	       (zwei:ibp end-bp)))
	    (T (error "end-bp not at line boundary ~s (internal error)" end-bp)))
      ;;--- see --- comment above.  I don't even know what this check is
      ;; supposed to be doing for us, but it causes a blowout in a case
      ;; that ought to work, so I'm flushing it.
      #+ignore
      (when (and (> (zwei:bp-index end-bp) 0)
		 (null (zwei:line-next (zwei:bp-line end-bp))))
	(error "Last line in interval has no line-next (internal error)")))
    (flet ((make-it (front-bp back-bp)
	     (let* ((new-interval (zwei:make-markup-node front-bp back-bp
							 'zwei:markup-structure-text-node))
		    (new-structure
		      (make-instance 'sage-text-structure :interval new-interval))
		    (first-line (zwei:bp-line (zwei:node-first-bp new-interval)))
		    (last-line (zwei:bp-line (zwei:node-last-bp new-interval)))
		    (before-first (zwei:line-previous first-line))
		    (after-last (zwei:line-next last-line)))
	       ;; split line-next/previous relationships since they will be handled
	       ;; by the line-next-in-buffer protocol
	       (when before-first
		 (setf (zwei:line-next before-first) nil)
		 (setf (zwei:line-previous first-line) nil))
	       (when after-last
		 (setf (zwei:line-next last-line) nil)
		 (setf (zwei:line-previous after-last) nil))
	       (setf (zwei:markup-structure-node-markup-structure new-interval) new-structure)
	       new-structure)))
      ;; This forward-char business is trying to preserve the unmaintainable convention
      ;; that the end-bp of our little intervals point just past the last char of the
      ;; last included line, instead of the first char of the first (following) excluded line.
      (when start-bp
	(setq structure-before (make-it first-bp
					(if (zerop (zwei:bp-index start-bp))
					    (zwei:forward-char start-bp -1)
					    start-bp)))
	(zwei:move-bp first-bp start-bp)
	(insert-structure-near-sibling structure-before :before self)
	(zwei:insert-node-in-node-tree (sage-text-structure-interval structure-before)
				       :before interval))
      (when end-bp
	;; if this is one of the funny nodes whose last-bp was moved back one to be the
	;; last char of the last line in the node rather than the 0th char of the next line,
	;; the move it back forward
	(cl:assert (zerop (zwei:bp-index end-bp)))
	(zwei:with-bp (new-end (zwei:forward-char end-bp -1))
	  (setq structure-after (make-it end-bp last-bp))
	  (zwei:move-bp last-bp new-end))
	(when (zerop (zwei:bp-index last-bp))
						; what?? why insert a return when the bp is at index 0?? 
						;(zwei:insert last-bp #\return)
	  )
	(insert-structure-near-sibling structure-after :after self)
	(zwei:insert-node-in-node-tree (sage-text-structure-interval structure-after)
				       :after interval)))
    (values structure-before self structure-after)))

;; was insert-node-in-node-tree
(defun 1insert-structure-near-sibling0 (new-child how old-child)
  (when (typep old-child 'record-field)
    (zwei:barf "Text may not be added between the fields of a record."))
  (let ((superior (directive-superior old-child)))
    (setf (directive-superior new-child) superior)
    (insert-structure-near-sibling1 superior new-child how old-child)))

(defmethod 1(insert-structure-near-sibling1 sage-directive-inferiors-mixin)
0	   (new-child how old-child)
  ;;---position and nthcdr are fairly ridiculous operations on lists.
  ;;This probably deserves some list-specific bumming.
  (let ((old-child-pos (position old-child (directive-inferiors self))))
    (when (null old-child-pos)
      (error "Failed to find child ~s in children of ~s (internal error)" old-child self))
    (ecase how
      (:after (incf old-child-pos))
      (:before ))
    (if (zerop old-child-pos)
	(push new-child (directive-inferiors self))
	(push new-child (nthcdr old-child-pos (directive-inferiors self))))))

;; was node-tree-boundary-leaves
(defun 1sage-structure-split-boundary-leaves0 (start-bp end-bp)
  (let* ((start-same-as-end (zwei:bp-= start-bp end-bp))
	 (start-node (zwei:bp-node start-bp))
	 (end-node (zwei:bp-node end-bp)))
    ;;--- kludge alert.
    ;; When end-bp points at the 2first0 BP of its node, assume that the user
    ;; really meant to mark only up to the end of the previous node, so
    ;; back up and find that node.
    (when (and (not start-same-as-end)
	       (zwei:bp-= end-bp (zwei:interval-first-bp end-node)))
      (let* ((prev-line (zwei:line-previous-in-buffer (zwei:bp-line end-bp)))
	     (prev-node (zwei:line-node prev-line)))
	(unless (typep prev-node 'zwei:markup-structure-node)
	  (zwei:barf "Can't manipulate text outside a record."))
	(setq end-node prev-node
	      end-bp (zwei:interval-last-bp prev-node))))
    (let ((start-structure (zwei:markup-structure-node-markup-structure start-node))
	  (end-structure (zwei:markup-structure-node-markup-structure end-node))
	  (at-start-p (zwei:bp-= start-bp (zwei:interval-first-bp start-node)))
	  (at-end-p (zwei:bp-= end-bp (zwei:interval-last-bp end-node))))
      (cond (at-start-p nil)
	    ((not (zwei:beg-line-p start-bp))
	     ;; Not at either end of node, not at beginning of line
	     (if (zwei:end-line-p start-bp)
		 ;; If we are at the end of the line and not at the end of the node,
		 ;; the move over the return rather than inserting a new one.
		 (setq start-bp (zwei:forward-char start-bp))
		 (zwei:insert-moving start-bp #\return))))
      (if start-same-as-end
	  (setq end-bp start-bp)
	  (when (not (or (zwei:beg-line-p end-bp)
			 (zwei:end-line-p end-bp)))
	    (setq end-bp (zwei:insert end-bp #\return))))
      (cond ((neq start-node end-node)
	     ;; Be careful not to try to split non-text nodes.
	     ;; start- and end-bp should only point at the first or last bp
	     ;; of such a node.  There is no split-sage-structure method for non-text nodes.
	     (multiple-value-bind (nil left)
		 (if at-start-p
		     (values nil start-structure)
		     (split-sage-structure start-structure start-bp nil))
	       (multiple-value-bind (nil right)
		   (if at-end-p
		       (values nil end-structure)
		       (split-sage-structure end-structure nil end-bp))
		 (values left nil right :non-adjacent-different-nodes))))
	    (t
	     (let (left middle right mode)
	       (cond ((not (zwei:bp-= start-bp end-bp))
		      ;; Both bp's on same node, but not bp-=
		      ;; The node returned as middle is going to become the
		      ;; inferior of a newly created node.
		      (setq mode :non-adjacent-same-node)
		      ;; Split as little as possible.
		      (cond ((and at-start-p at-end-p)
			     (setq middle start-structure))
			    (at-start-p
			     (multiple-value-setq (nil middle right)
			       (split-sage-structure start-structure nil end-bp)))
			    (at-end-p
			     (multiple-value-setq (left middle nil)
			       (split-sage-structure start-structure start-bp nil)))
			    (t (multiple-value-setq (left middle right)
				 (split-sage-structure start-structure start-bp end-bp)))))
		     
		     ;; start-bp = end-bp for all clauses from here down
		     (at-start-p
		      ;; already at the beginning of a node, no split necessary
		      (setq right start-structure
			    mode :no-split))
		     (at-end-p
		      ;; ditto the end
		      (setq left start-structure
			    mode :no-split))
		     (t
		      ;; start-bp and end-bp are the same, but we aren't at the
		      ;; beginning or end of the node
		      (multiple-value-setq (left right nil)
			(split-sage-structure start-structure start-bp nil))
		      (setq mode :adjacent)))
	       (values left middle right mode)))))))

;;; Split the 2superior 0so its new left sib contains the current2 superior0's inferiors
;;; which lie to the left of 2inferior0.
;;; We do not have to split any sage-text-structures, that is, any intervals.  This
;;; only splits the superior, whose zwei node will get completely regenerated.
;; was split-off-left-inferiors
(defun 1sage-structure-split-off-left-inferiors0 (superior inferior)
  (let ((position (position inferior (directive-inferiors superior))))
    (unless position
      (error "Inferior not in superior inferiors (internal error)"))
    (unless (zerop position)
      (let* ((sup-sib (clone-self superior)))
	(insert-structure-near-sibling sup-sib :before superior)
	(setf (directive-inferiors sup-sib)
	      (subseq (directive-inferiors superior) 0 position))
	(dolist (inf (directive-inferiors sup-sib))
	  (setf (directive-superior inf) sup-sib))
	(setf (directive-inferiors superior)
	      (nthcdr position (directive-inferiors superior)))
	))))

(defun 1sage-structure-split-off-right-inferiors0 (superior inferior)
  (let ((position (position inferior (directive-inferiors superior))))
    (unless position
      (error "Inferior not in superior inferiors (internal error)"))
    (unless (= position (length (directive-inferiors superior)))
      (let* ((sup-sib (clone-self superior)))
	(insert-structure-near-sibling sup-sib :after superior)
	(setf (directive-inferiors sup-sib)
	      (nthcdr position (directive-inferiors superior)))
	(dolist (inf (directive-inferiors sup-sib))
	  (setf (directive-superior inf) sup-sib))
	(setf (directive-inferiors superior)
	      (subseq (directive-inferiors superior) 0 position))
	))))

(defmethod 1(clone-self sage-envr)0 ()
  (when (eq envr-name 'display)
    (break "Splitting display node ~s" self))
  (make-sage-envr envr-name envr-mods ()))

;;; These aren't zwei nodes, of course.
;;; was split-tree-up-to-node
(defun 1split-sage-structure-up-to-node0 (superior left-node right-node)
  (unless (or (eq superior left-node) (eq superior right-node))
    (loop doing
      (when left-node
	(let ((left-superior (directive-superior left-node)))
	  (when (eq left-superior superior)
	    (return))
	  (sage-structure-split-off-left-inferiors left-superior left-node)
	  (setq left-node left-superior)))
      (when right-node
	(let ((right-superior (directive-superior right-node)))
	  (when (eq right-superior superior)
	    (return))
	  (sage-structure-split-off-right-inferiors right-superior right-node)
	  (setq right-node right-superior)))))
  (values left-node right-node))
  
(defflavor 1untried-waters-error0 () (dbg:ferror))

;;; Given a left-hand and right-hand (inclusive) pair of inferior nodes, arrange for the
;;; part of superior that is between those two nodes to become the inferior of new-node
;;; instead.  Nodes along the way up can get split into as many as three different pieces
;;; similar to their original, but with different parentage, to accomplish this.
;; was split-node-tree-around-leaves
(defun 1split-sage-structure-around-leaves0 (superior new-node left-node right-node)
  (unless (eq (directive-superior left-node)
	      (directive-superior right-node))
    ;; Lots of the code below tries to make sense of situations where the nodes are
    ;; at different levels in the tree.  I currently claim that the only time it makes
    ;; sense to split is when both nodes are inferiors of the same superior.
    ;; This error is here to enforce that claim, but none of the code that tries to deal
    ;; with the complex cases has been removed, in case I'm wrong.
    (signal 'untried-waters-error :format-string "You can only split nodes that are siblings, not cousins or uncle/nephews"))
  ;; Find first place two subtrees intersect
  (let ((common-superior (loop for lnode = left-node then (directive-superior lnode)
			       when (loop for rnode = right-node then (directive-superior rnode)
					  until (null rnode)
					  thereis (eq rnode lnode))
				 return lnode
			       until (eq lnode superior))))
    (when (null common-superior)
      (error "The sage structures did not have a common superior. (internal error)"))
    ;; Split branches up to that point.
    (multiple-value-setq (left-node nil)
      (split-sage-structure-up-to-node common-superior left-node nil))
    (multiple-value-setq (nil right-node)
      (split-sage-structure-up-to-node common-superior nil right-node))
    (unless (eq common-superior superior)
      ;; Find node some of whose inferiors the new node will inherit.
      (setq common-superior (loop for node = common-superior then nsuperior
				  as nsuperior = (directive-superior node)
				  when (eq nsuperior superior)
				    ;; We have to go at least one level up, right?
				    return (if (eq node common-superior)
					       nsuperior node)
				  finally (error "Common superior not in tree to superior (internal error)"))))
    ;; Branch up to there.
    (multiple-value-setq (left-node right-node)
      (split-sage-structure-up-to-node common-superior left-node right-node))
    (move-some-inferiors-into-node common-superior left-node right-node new-node)))

;;; Move all the nodes from left to right (inclusive) down into the new-inferior,
;;; and replace them in the superior by the new inferior.
(defun 1move-some-inferiors-into-node0 (superior left-inferior right-inferior new-inferior)
  (let* ((inferiors (directive-inferiors superior))
	   (left-pos (position left-inferior inferiors))
	   (right-pos (position right-inferior inferiors)))
      (unless (and left-pos right-pos ( right-pos left-pos))
	(error "Inferiors not in correct superiors (internal error)"))
      (incf right-pos)
      (setf (directive-inferiors new-inferior) (subseq inferiors left-pos right-pos))
      (dolist (node (directive-inferiors new-inferior))
	(setf (directive-superior node) new-inferior))
      ;; Remove all the inferiors of superior that have become inferiors of
      ;; new node instead.  Then insert the new node in the same place in the inferiors
      ;; list that was just vacated by the nodes that are now its inferiors.
      (cond ((and (zerop left-pos) (= right-pos (length inferiors)))
	     ;; all inferiors being moved down into new inferior
	     (setf (directive-superior new-inferior) superior)
	     (setf (directive-inferiors superior) (list new-inferior)))
	    ((zerop left-pos)
	     ;; moved inferiors were at the front of the inferiors list
	     (setf (directive-inferiors superior) (nthcdr right-pos inferiors))
	     (insert-structure-near-sibling
	       new-inferior :before (elt (directive-inferiors superior) 0)))
	    ((> right-pos (length inferiors))
	     ;; moved inferiors extend from the middle of the inferiors list to the end
	     (setf (nthcdr left-pos inferiors) nil)	; side-effect inferiors list of superior
	     (insert-structure-near-sibling
	       new-inferior :after (elt (directive-inferiors superior) (1- left-pos))))
	    (t
	     ;; moved inferiors are in the middle of the inferiors list
	     (setf (directive-inferiors superior)
		   (append (subseq inferiors 0 left-pos)
			   (subseq inferiors right-pos)))
	     (insert-structure-near-sibling
	       new-inferior :after (elt (directive-inferiors superior) (1- left-pos)))))))

;;; Completely rewritten to always use the ZWEI superior chain, since the sage
;;; one is broken due to doc-record-field lossage.  When doc-record-fields are fully
;;; integrated into the sage structure, we won't have to be careful of this sort
;;; of thing anymore.
(defun 1find-superior-of-type-enclosing-region0 (type start-bp end-bp)
  (let* ((immediate-superior-zwei-node
	   (zwei:node-superior
	     (zwei:bp-node start-bp)))
	 (sage-structure
	   (block find-sage-node
	     (do-zwei-sage-superiors (ignore sage-node immediate-superior-zwei-node)
	       (when (and (typep sage-node type)
			  (block find-other-sage-node
			    (do-zwei-sage-superiors (ignore other-sage-node
							    (zwei:bp-node end-bp))
			      (when (eq other-sage-node sage-node)
				(return-from find-other-sage-node t)))))
		 (return-from find-sage-node sage-node))))))
    (let ((zwei-node (block find-zwei-node
		       (do-zwei-sage-superiors (zwei-node ignore (zwei:bp-node start-bp))
			 (when (eql (zwei:markup-structure-node-markup-structure zwei-node)
				    sage-structure)
			   (return-from find-zwei-node zwei-node))))))
      (values sage-structure zwei-node))))

;;; Previous version, which lost because 
;;; (directive-superior (markup-structure-node-markup-structure node))
;;; does not find the same sage structure as
;;; (markup-structure-node-markup-structure (node-superior node))
#+ignore
(3 0 (NIL 0) (NIL NIL :SMALL) "TVFONT")(defun find-superior-of-type-enclosing-region (type start-bp end-bp)
  (flet ((sage-structure-from-bp (bp)
	   (let ((node (zwei:bp-node bp)))
	     (if (typep node 'zwei:markup-structure-node)
		 (zwei:markup-structure-node-markup-structure node)
		 ;; could be on the attribute line or something
		 (return-from find-superior-of-type-enclosing-region
		   nil)))))
    (let* ((immediate-superior (directive-superior ; --- we really do want the superior here, right?
				 (sage-structure-from-bp start-bp)))
	   (sage-structure
	    (loop for node = immediate-superior
			   then (directive-superior node)
		  while node
		  when (and (typep node type)
			    (loop for enode = (sage-structure-from-bp end-bp)
					    then (directive-superior enode)
				  thereis (eq enode node)))
		    return node)))
      ;; one more rule in our expert system here.
      #+Franz ;rule retraction
      (when (typep sage-structure 'sage-text-structure)
	(setf sage-structure (directive-superior sage-structure)))
      (let ((zwei-node (loop for node = (zwei:bp-node start-bp)
				      then (zwei:node-superior node)
			     when (eql (zwei:markup-structure-node-markup-structure node)
				       sage-structure)
			       return node)))
	(values sage-structure zwei-node)))))

0(defmethod 1(sage-structure-allowable-superiors sage-directive)0 ()
  (values 'sage-directive "Any kind of markup structure"))

(defmethod 1(sage-structure-allowable-superiors doc-record)0 ()
  (values 'zwei:markup-buffer "A buffer for markup"))

#+Franz ;;---We have no items yet
(defmethod (sage-structure-allowable-superiors markup-item) ()
  (values '---any-itemized-structure "A list"))

#|| old version, very confused about protocol between itself and sage-structure-split-boundary-leaves

3;; was splice-node-around-text
(defun splice-sage-structure-around-text (start-bp end-bp sage-structure-type &rest init-options)
  (let ((new-structure (apply #'make-instance sage-structure-type init-options)))
    (multiple-value-bind (flavor description)
	(sage-structure-allowable-superiors new-structure)
      (multiple-value-bind (superior superiors-old-zwei-node)
	  (find-superior-of-type-enclosing-region flavor start-bp end-bp)
	(ignore superiors-old-zwei-node)	;---
	(unless superior
	  (zwei:barf "Could not find a suitable superior: ~A" description))
	(multiple-value-bind (left-structure right-structure)
	    (sage-structure-split-boundary-leaves start-bp end-bp)
	  (cond ((eq left-structure right-structure)
		 (let* ((old-structure left-structure)
			(old-superior (directive-superior old-structure)))
		   (setf (directive-superior new-structure) old-superior)
		   (setf (directive-inferiors new-structure)
			 (list old-structure))
		   (setf (directive-superior old-structure) new-structure)
		   (setf (directive-inferiors old-superior)
			 (nsubstitute new-structure old-structure
				      (directive-inferiors old-superior)))))
		(T
		 (split-sage-structure-around-leaves superior new-structure
						     left-structure right-structure))))
	(zwei:insert-record-structure-nodes superior :in-place-of-node superiors-old-zwei-node)))))
0||#

(defun 1splice-sage-structure-at-point0 (type &rest options)
  (zwei:assure-inside-record)
  (zwei:mung-bp-interval (zwei:point))
  (zwei:barf-on-errors (untried-waters-error)
    (if (zwei:window-mark-p zwei:*window*)
	(zwei:region (bp1 bp2 :empty-ok t)
	  (apply #'new-splice-sage-structure-around-text bp1 bp2 type t options))
	(zwei:temporarily-inserting-cr-if-necessary ((zwei:point))
	  (apply #'new-splice-sage-structure-around-text (zwei:point) (zwei:point)
		 type t options)))))

;; was splice-node-around-text
(defun 1new-splice-sage-structure-around-text0 (start-bp end-bp sage-structure-type unconnected-p
					      &rest init-options)
  (let ((new-structure (apply #'make-instance sage-structure-type init-options)))
    (when unconnected-p (setf (completely-unconnected new-structure) t))
    (multiple-value-bind (flavor description)
	(sage-structure-allowable-superiors new-structure)
      (multiple-value-bind (superior superiors-old-zwei-node)
	  (find-superior-of-type-enclosing-region flavor start-bp end-bp)
	(unless superior
	  (zwei:barf "Could not find a suitable superior: ~A (internal error)" description))
	;; We can only enclose stuff that is at the same level in the tree.
	;;--- We'd really like to do this search in the Sage datastructure, but
	;; the damned doc-record-field structures' inferiors have the record,
	;; not the record field, as their superior.
	(loop for start = (zwei:bp-node start-bp)
	      then (zwei:node-superior start)
	      for end = (zwei:bp-node end-bp)
	      then (zwei:node-superior end)
	      do
	  (when (eq start superiors-old-zwei-node)
	    (if (eq end superiors-old-zwei-node)
		(loop-finish)
		(zwei:barf "The region encloses unbalanced markup boundaries."))))
	(multiple-value-bind (left-structure middle-structure right-structure mode)
	    (sage-structure-split-boundary-leaves start-bp end-bp)
	  (ecase mode
	    (:no-split
	      ;; Was already at the edge of a node, so no splitting was done.
	      ;; The original node will be returned as either left-structure or
	      ;; right structure, depending on which edge point was on.  Insert the
	      ;; new node before or after, as appropriate.
	      (cond ((not (null left-structure))
		     (insert-structure-near-sibling new-structure :after left-structure))
		    ((not (null right-structure))
		     (insert-structure-near-sibling new-structure :before right-structure))))
	    (:adjacent
	      ;; One node was split down the middle.  The left-structure is the old node
	      ;; and the right-structure is the split off stuff.  Put the new node
	      ;; between them.
	      (insert-structure-near-sibling new-structure :after left-structure))
	    (:non-adjacent-same-node
	      ;; The original node was split into as many as three parts.
	      ;; The middle (or original) part is
	      ;; to become an inferior of the new node.  This is the only mode for
	      ;; which middle-structure has a value.
	      (move-some-inferiors-into-node superior middle-structure middle-structure new-structure))
	    (:non-adjacent-different-nodes
	      #+ignore
	      ;;--- all splitting has been done, don't call this complex thing
	      (split-sage-structure-around-leaves superior new-structure
						     left-structure right-structure)
	      (move-some-inferiors-into-node superior left-structure right-structure new-structure))))
	(multiple-value-prog1
	  (zwei:insert-markup-structure-nodes
	    superior
	    :in-place-of-node superiors-old-zwei-node)
	  (fix-up-connection-markers-for-adjacent-diagrams (zwei:forward-char end-bp -1)))))))

(defmethod 1(zwei:copy-interval-1 zwei:markup-buffer)0 (from-bp to-bp into-interval)
  (copy-sage-interval from-bp to-bp into-interval)
  (zwei:linemap ((zwei:interval-first-bp into-interval)
		 (zwei:interval-last-bp into-interval))
    (remf (zwei:line-plist (zwei:linemap-line)) :line-margin))
  into-interval)

(defmethod 1(zwei:copy-interval-into-string-or-interval-1 zwei:markup-buffer)
0	   (from-bp to-bp length width &rest options &key prepend append &allow-other-keys)
  ;; Decide whether we are dealing with text or sage structure
  (if (loop for line = (zwei:bp-line from-bp) then (zwei:line-next-in-buffer line :buffer self)
	    with end-line = (if (zerop (zwei:bp-index to-bp)) (zwei:bp-line to-bp)
				(zwei:line-next-in-buffer (zwei:bp-line to-bp) :buffer self))
	    until (eq line end-line)
	    never (or (zwei:line-sage-structure-representation line)
		      (zwei:line-diagram line)))
      (apply #'zwei:copy-interval-into-string-or-interval-2 from-bp to-bp length width options)
      (let ((into-interval (make-instance 'zwei:node)))
	(copy-sage-interval from-bp to-bp into-interval)
	(zwei:linemap ((zwei:interval-first-bp into-interval)
		       (zwei:interval-last-bp into-interval))
	  (remf (zwei:line-plist (zwei:linemap-line)) :line-margin))
	(cond (append
	       (zwei:insert-interval (zwei:interval-last-bp append) into-interval)
	       append)
	      (prepend
	       (zwei:insert-interval (zwei:interval-first-bp prepend) into-interval)
	       prepend)
	      (t into-interval)))))

(defun 1copy-sage-interval0 (from-bp to-bp into-interval)
  ;; Zwei expects us to fill in the interval's bps.
  (unless (and (location-boundp (locf (zwei:node-first-bp into-interval)))
	       (location-boundp (locf (zwei:node-last-bp into-interval))))
    (let ((line (zwei:create-line 'sys:art-string 0 into-interval)))
      (setf (zwei:interval-first-bp into-interval)
	    (zwei:create-bp line 0 ':normal into-interval))
      (setf (zwei:interval-last-bp into-interval)
	    (zwei:create-bp line 0 ':moves into-interval))))
  (let* ((from-zwei-node (zwei:bp-node from-bp))
	 (to-zwei-node (zwei:bp-node to-bp))
	 (from-sage-node)
	 (to-sage-node)
	 (extra-from-bp) (extra-to-bp))

    (check-for-unbalanced-language-forms from-bp to-bp)

    (etypecase from-zwei-node
      (zwei:markup-buffer
	(cond ((zwei:bps-connected-by-simply-connected-lines from-bp to-bp)
	       (zwei:insert-interval (zwei:interval-last-bp into-interval)
				     from-bp to-bp T)
	       (return-from copy-sage-interval into-interval))
	      (T (let ((line (zwei:last-simply-connected-line (zwei:bp-line from-bp))))
		   (zwei:insert-interval (zwei:interval-last-bp into-interval)
					 from-bp (zwei:create-bp line (zwei:line-length line)))
		   (let ((next-line (zwei:line-next-in-buffer line)))
		     (cond ((eq next-line (zwei:bp-line to-bp))
			    (zwei:insert (zwei:interval-last-bp into-interval) #\Return)
			    (return-from copy-sage-interval into-interval))
			   (T (setq from-bp (zwei:create-bp next-line 0)
				    from-zwei-node (zwei:bp-node from-bp)
				    from-sage-node (zwei:markup-structure-node-markup-structure
						     from-zwei-node)))))))))
      (zwei:markup-structure-node
	(setq from-sage-node (zwei:markup-structure-node-markup-structure from-zwei-node))))
    (etypecase to-zwei-node
      (zwei:markup-buffer
	(let ((line (zwei:first-simply-connected-line (zwei:bp-line to-bp))))
	  (setq extra-from-bp (zwei:create-bp line 0)
		extra-to-bp to-bp)
	  (let ((previous-line (zwei:line-previous-in-buffer line)))
	    (setq to-bp (zwei:create-bp previous-line 0)
		  to-zwei-node (zwei:bp-node to-bp)
		  to-sage-node (zwei:markup-structure-node-markup-structure
				 to-zwei-node)))))
      (zwei:markup-structure-node
	(setq to-sage-node (zwei:markup-structure-node-markup-structure to-zwei-node))))
    (if (eql from-sage-node to-sage-node)
	(let ((zwei-node from-zwei-node))
	  (cond ((zwei:bp-= from-bp to-bp)
		 ;; empty region, nothing to do
		 )
		((and (zwei:bp-= from-bp (zwei:interval-first-bp zwei-node))
		      (zwei:bp-= to-bp (zwei:interval-last-bp zwei-node)))
		 (copy-entire-sage-directive from-sage-node into-interval))
		(T
		 ;;---flavor method dispatch will verify this assertion soon enough
		 ;;---(assert (typep from-sage-node 'sage-text-structure))
		 (copy-partial-sage-directive from-sage-node from-bp to-bp into-interval))))
	(copy-partial-sage-directives from-bp to-bp into-interval
				      from-zwei-node to-zwei-node
				      from-sage-node to-sage-node))
    (when extra-from-bp
      (zwei:insert (zwei:interval-last-bp into-interval) #\Return)
      (zwei:insert-interval (zwei:interval-last-bp into-interval)
			    extra-from-bp extra-to-bp T)))
  into-interval)

(defun 1copy-partial-sage-directives0 (from-bp to-bp into-interval
				     from-zwei-node to-zwei-node
				     from-sage-node to-sage-node)
  ;; Verify they have a common Sage structure as superior
  (let ((common-sage-superior
	  (block found-it
	    (do-sage-superiors (lnode from-sage-node)
	      (do-sage-superiors (rnode to-sage-node)
		(when (eq rnode lnode) (return-from found-it lnode))))
	    ;; Try to make the error message a tad cleaner
	    (let ((r1 (zwei:find-containing-record (zwei:node-first-bp from-zwei-node)))
		  (r2 (zwei:find-containing-record (zwei:node-first-bp to-zwei-node))))
	      (cond ((and r1 (neq r1 r2))
		     (zwei:barf "You can not copy a region that spans multiple records."))
		    (t
		     ;; I don't know what could cause this, but at least the above
		     ;; error message is the more common one now.
		     (zwei:barf
		       "--- The sage structures did not have a common superior.")))))))
    ;; Note the partial nodes cut by start-bp and end-bp.  Walk line-by-line
    ;; (using line-next-in-buffer) checking line-node of each.  If it (the node)
    ;; isn't in the partial-node list, do copy-entire-sage-directive on it.
    (let ((partial-nodes (list common-sage-superior)))
      (do-zwei-sage-superiors (zwei-node sage-node from-zwei-node)
	(ignore zwei-node)
	(cond ((eql sage-node common-sage-superior)
	       (return nil))
	      ((eql sage-node from-sage-node)
	       ;; If the from-bp starts its node, that node isn't split
	       (unless (zwei:bp-= from-bp (zwei:interval-first-bp from-zwei-node))
		 (push sage-node partial-nodes)))
	      (T (push sage-node partial-nodes))))
      (do-zwei-sage-superiors (zwei-node sage-node to-zwei-node)
	(ignore zwei-node)
	(cond ((eql sage-node common-sage-superior)
	       (return nil))
	      ((eql sage-node to-sage-node) 
	       ;; if the to-bp ends its node, that node isn't split
	       (unless (zwei:bp-= to-bp (zwei:interval-last-bp to-zwei-node))
		 (push to-sage-node partial-nodes)) )
	      (T (push sage-node partial-nodes))))
      (let ((line (zwei:bp-line from-bp))
	    (from-bp-line (zwei:bp-line from-bp))
	    (to-bp-line (zwei:bp-line to-bp)))
	(loop do
	  (when (null line)
	    (error "Fell off end of nodes (internal error)"))
	  (let* ((line-zwei-node (zwei:line-node line))
		 (line-sage-node (zwei:markup-structure-node-markup-structure
				   line-zwei-node)))
	    (cond ((member line-sage-node partial-nodes)
		   ;;--- Please speed this up by having the partial nodes
		   ;;involve themselves instead of this going line-by-line from the outside
		   (cond ((eql to-bp-line line)
			  (cond ((zerop (zwei:bp-index to-bp))
				 (loop-finish))
				(T (insert-at-end-of-interval into-interval line
							      0 (zwei:bp-index to-bp))
				   (loop-finish))))
			 ((and (eql from-bp-line line)
			       (not (zerop (zwei:bp-index from-bp))))
			  (insert-at-end-of-interval into-interval line
						     (zwei:bp-index from-bp)
						     (zwei:line-length line))
			  (setq line (zwei:line-next-in-buffer line)))
			 (T (add-copy-of-line-to-end-of-interval line into-interval)
			    (setq line (zwei:line-next-in-buffer line)))))
		  ;; Line's node is not partial, so to-bp must point at either the first-
		  ;; or last-bp of the node.
		  ((eql line-sage-node to-sage-node)
		   ;; If to-bp points at first-bp of the node, exclude the node (don't copy it).
		   (unless (zwei:bp-= to-bp (zwei:node-first-bp line-zwei-node))
		     (copy-entire-sage-directive line-sage-node into-interval))
		   (loop-finish))
		  (T (copy-entire-sage-directive line-sage-node into-interval)
		     (setq line (zwei:markup-structure-node-last-unlinked-line
				  line-zwei-node :from-above))
		     (when (eq (zwei:line-node line) line-zwei-node)
		       (setq line (zwei:line-next-in-buffer line)))))))))))

(defun 1insert-at-end-of-interval0 (interval string &rest substring-args)
  (apply #'zwei:insert (zwei:node-last-bp interval) string substring-args))

(defun 1add-copy-of-line-to-end-of-interval0 (line into-interval)
  ;; bum for empty and diagram lines
  (when (> (zwei:line-length line) 0)
    (insert-at-end-of-interval into-interval line))
  (insert-at-end-of-interval into-interval #\return))

(defgeneric 1copy-partial-sage-directive0 (sage-text-structure from-bp to-bp into-interval)
  )

(defmethod 1(copy-partial-sage-directive sage-text-structure)0 (from-bp to-bp into-interval)
  ;; Do we have to prove that from-bp and to-bp point into interval
  (zwei:insert-interval (zwei:node-last-bp into-interval) from-bp to-bp nil))

(defgeneric 1copy-entire-sage-directive0 (sage-directive into-interval)
  )

(defmethod 1(copy-entire-sage-directive doc-record)0 (into-interval)
  (ignore into-interval)
  (zwei:barf "You can not kill a record this way.  Use m-X Kill Record or Remove Record from Buffer instead."))

(defmethod 1(copy-entire-sage-directive sage-text-structure)0 (into-interval)
  (if (zwei:bp-= (zwei:interval-first-bp interval)
		 (zwei:interval-last-bp interval))
      (zwei:insert (zwei:node-last-bp into-interval) #\cr)
      (zwei:insert-interval (zwei:node-last-bp into-interval) interval)))

(defun 1splice-new-line-into-end-of-interval0 (into-interval)
  ;; Make sure interval ends at line beginning, because we're going to splice
  ;; just before that last line
  (unless (zerop (zwei:bp-index (zwei:interval-last-bp into-interval)))
    (unless (zwei:bp-= (zwei:interval-first-bp into-interval)
		       (zwei:interval-last-bp into-interval))
      (insert-at-end-of-interval into-interval #\return)))
  (insert-at-end-of-interval into-interval #\return)
  (zwei:line-previous (zwei:bp-line (zwei:interval-last-bp into-interval))))

(defsubst 1zwei:line-sage-structure-representation0 (line)
  (getf (zwei:line-plist line) 'sage-structure-representation))

;; fields themselves don't get copied or anything
(defmethod 1(copy-entire-sage-directive record-field)0 (into-interval)
  (dolist (inf (directive-inferiors self))
    (copy-entire-sage-directive inf into-interval)))

(defmethod 1(copy-entire-sage-directive sage-envr)0 (into-interval)
  (let ((first-line (splice-new-line-into-end-of-interval into-interval)))
    (dolist (directive contents-list)
      (copy-entire-sage-directive directive into-interval))
    (let ((last-line (splice-new-line-into-end-of-interval into-interval)))
      (let ((representation (sage-structure-representation-for-zwei-interval self)))
	(setf (zwei:line-sage-structure-representation first-line)
	      (cons 'begin representation))
	(setf (zwei:line-sage-structure-representation last-line)
	      (cons 'end representation))))))

(defmethod 1(copy-entire-sage-directive sage-command)0 (into-interval)
  (splice-single-sage-structure-representation-line self 'make-sage-command into-interval))

(defmethod 1(copy-entire-sage-directive sage-macro-call)0 (into-interval)
  (splice-single-sage-structure-representation-line self 'make-sage-macro-call into-interval))

(defmethod 1(copy-entire-sage-directive sage-reference)0 (into-interval)
  (splice-single-sage-structure-representation-line self 'make-sage-reference into-interval))

(defmethod 1(copy-entire-sage-directive sage-picture)0 (into-interval)
  (splice-single-sage-structure-representation-line self
						    (lambda (&rest args)
						      (apply #'make-sage-picture args))
						    into-interval))

(defmethod 1(copy-entire-sage-directive example-record-marker)0 (into-interval)
  (splice-single-sage-structure-representation-line self
						    #'make-example-record-marker
						    into-interval))

(defun 1splice-single-sage-structure-representation-line0 (directive creator into-interval)
  (let ((first-line (splice-new-line-into-end-of-interval into-interval)))
    (setf (zwei:line-sage-structure-representation first-line)
	  (list 'atomic creator
		(sage-structure-representation-for-zwei-interval directive)))))

(defgeneric 1sage-structure-representation-for-zwei-interval0 (sage-directive)
  )

(defmethod 1(sage-structure-representation-for-zwei-interval sage-envr)0 ()
  (list 'regenerate-sage-envr envr-name (copy-tree envr-mods) directive-flags))

(defmethod 1(sage-structure-representation-for-zwei-interval sage-command)0 ()
  (list command-name (copy-tree parameter) directive-flags))

(defmethod 1(sage-structure-representation-for-zwei-interval sage-macro-call)0 ()
  (list macro-name (copy-tree macro-args)))

(defmethod 1(sage-structure-representation-for-zwei-interval sage-reference)0 ()
  (list record-group view field appearance booleans directive-flags))

(defmethod 1(sage-structure-representation-for-zwei-interval sage-picture)0 ()
  `(:type ,type
    :file-name ,file-name
    :name ,name
    :binary-encoding ,binary-encoding
    :drawing-function ,drawing-function))

(defmethod 1(sage-structure-representation-for-zwei-interval example-record-marker)0 ()
  `(:type ,type
    :encoding ,encoding))

(defun 1describe-copied-sage-interval0 (interval)
  (zwei:do-lines-in-interval (interval line start end)
    (cond ((zwei:line-sage-structure-representation line)
	   (unless (= end start)
	     (format T "~&The sage-structure-line ~s has non-zero length" line))
	   (format T "~&sage structure ~s" (zwei:line-sage-structure-representation line)))
	  (T (format T "~&~s" (substring line start end))))))

(defun 1balanced-markup-boundaries-p0 (start-bp end-bp)
  (unless (zwei:bp-< start-bp end-bp)
    (zwei:swap-bps start-bp end-bp))
  (loop as line = (zwei:bp-line start-bp)
		then (zwei:line-next-in-buffer line)
	as line-diagram = (zwei:line-diagram line)
	with count = 0
	while (and (not (eq line (zwei:bp-line end-bp)))
		   ( count 0))
	finally (return (zerop count))
	do
    (when (and line-diagram
	       (zwei:environment-header-line-p line-diagram (zwei:line-node line)))
      (if (zwei:environment-header-line-trailer-p line-diagram)
	  (decf count)
	  (incf count)))))

;; This returns a contents-list, not just a directive
(defun 1regenerate-copied-sage-interval0 (start-line end-line)
  (multiple-value-bind (contents-list line)
      (process-copied-sage-interval-lines start-line end-line nil)
    (unless (or (null line) (eq line end-line))
      (cerror "Throw it on the floor"
	      "INTERNAL ERROR---Failed to reach end of interval"))
    contents-list))

;; This returns a contents-list and a successor line
(defun 1process-copied-sage-interval-lines0 (line end-line matching-end)
  (zwei:zcollecting-into (contents-list-to-return)
    (let ((pending-text-first-line ())
	  (pending-text-last-line))
      (flet ((flush-pending-text ()
	       (when pending-text-first-line
		 (let* ((sage-text-structure (make-instance 'sage-text-structure))
			(interval (sage-text-structure-interval sage-text-structure)))
		   (zwei:copy-interval
		     (zwei:create-bp pending-text-first-line 0)
		     (zwei:create-bp pending-text-last-line
				     (zwei:line-length pending-text-last-line))
		     T interval)
		   ;; copy-interval sets bp-buffer of the first- and last-bps of
		   ;; the interval to be the interval itself.  This is inappropriate
		   ;; when we'll splice the interval into a real buffer.  NIL is
		   ;; the proper thing, so put it there.
		   (setf (zwei:bp-buffer-internal (zwei:interval-first-bp interval)) nil)
		   (setf (zwei:bp-buffer-internal (zwei:interval-last-bp interval)) nil)
		   (zwei:zcollect contents-list-to-return sage-text-structure))
		 (setq pending-text-first-line ()
		       pending-text-last-line ()))))
	(loop do
	  (let ((sage-structure-representation
		  (and line (zwei:line-sage-structure-representation line))))
	    (cond (sage-structure-representation
		   (assert (zerop (zwei:line-length line)))
		   (flush-pending-text)
		   (ecase (first sage-structure-representation)
		     ((begin)
		      (multiple-value-bind (contents-list new-line)
			  (process-copied-sage-interval-lines
			    (zwei:line-next line) end-line
			    (cdr sage-structure-representation))
			(destructuring-bind (maker . stuff)
			   (rest sage-structure-representation)
			  ;; The end line has been eaten
			  (zwei:zcollect contents-list-to-return
					 (apply maker contents-list stuff)))
			(setq line new-line)))
		     ((end)
		      (cond ((eql (cdr sage-structure-representation) matching-end)
			     (setq line (zwei:line-next line))
			     (loop-finish))
			    (T (error "Internal error: mismatch END structure.~@
					Got ~s, expected ~s"
				      (rest sage-structure-representation) matching-end))))
		     ((atomic)
		      (destructuring-bind (creator creation-args)
			 (rest sage-structure-representation)
			(zwei:zcollect contents-list-to-return
				       (apply creator creation-args)))
		      (setq line (zwei:line-next line)))))
		  ((or (null line) (eq line end-line))
		   (flush-pending-text)
		   (loop-finish))
		  (pending-text-first-line
		   (setq pending-text-last-line line)
		   (setq line (zwei:line-next line)))
		  (T (setq pending-text-first-line line
			   pending-text-last-line line
			   line (zwei:line-next line))))))))
    (labels ((set-superiors-in-list (contents-list superior)
	       (dolist (directive contents-list)
		 (setf (directive-superior directive) superior)
		 (typecase directive
		   (sage-directive-inferiors-mixin
		     (set-superiors-in-list (directive-inferiors directive) directive))
		   (otherwise )))))
      (set-superiors-in-list contents-list-to-return nil))
    (values contents-list-to-return line)))

(defmethod 1(zwei:insert-interval-1 zwei:markup-buffer)0 (at-bp from-bp to-bp in-order-p)
  (zwei:get-interval from-bp to-bp in-order-p)

  ;; Unconditionally copy
  ;; the "from-interval" because we can't figure out how to conditionally copy it.
  (let* ((interval (zwei:copy-interval from-bp to-bp t))
	 (from-bp (zwei:interval-first-bp interval))
	 (to-bp (zwei:interval-last-bp interval)))
    (zl:multiple-value (at-bp interval from-bp to-bp)
      (zwei::about-to-insert-thing (zwei:bp-node at-bp) at-bp interval from-bp to-bp))
    ;; Interval may be empty after call to zwei::about-to-insert-thing
    (if (zwei:bp-= (zwei:interval-first-bp interval)
		   (zwei:interval-last-bp interval))
	(return-from zwei:insert-interval-1 at-bp)
	(let ((start-line (zwei:bp-line from-bp))
	      (end-line (if (zerop (zwei:bp-index to-bp)) (zwei:bp-line to-bp)
			    (zwei:line-next (zwei:bp-line to-bp)))))
	  (if (loop for line = start-line then (zwei:line-next line)
		    until (or (eq line end-line) (null line))
		    never (zwei:line-sage-structure-representation line))
	      (if (or (typep (zwei:bp-node at-bp) 'zwei:markup-structure-text-node)
		      (not (zwei:line-diagram (zwei:bp-line at-bp))))
		  (zwei:insert-interval-2 at-bp from-bp to-bp in-order-p)
		  ;; We must be on a diagram line associated with markup.
		  ;; Diagram line code duplicated from zwei:insert-multiple-lines.
		  (let ((diagram-result (send (zwei:line-diagram (zwei:bp-line at-bp))
					      :editor-insert
					      (zwei:bp-line at-bp) (zwei:bp-index at-bp)
					      (zwei:bp-top-level-node from-bp) from-bp to-bp)))
		    (if (eq diagram-result :permit) nil diagram-result)))
	      (let ((contents-list (regenerate-copied-sage-interval start-line end-line)))
		(let ((following-bp (zwei:forward-char at-bp 1)))
		  (cond ((null following-bp)
			 (insert-sage-contents-list at-bp contents-list)
			 (zwei:copy-bp zwei:last-bp))
			(T (zwei:with-bp (following-bp following-bp :moves)
			     (insert-sage-contents-list at-bp contents-list)
			     (zwei:forward-char following-bp -1 T)))))))))))

(defun 1sage-contents-list-allowable-superiors0 (contents-list)
  (multiple-value-bind (allowed-type description)
      (sage-structure-allowable-superiors (first contents-list))
    (unless (every (lambda (directive)
		     (multiple-value-bind (this-type this-description)
			 (sage-structure-allowable-superiors directive)
		       (ignore this-description)
		       (eql this-type allowed-type)))
		   (rest contents-list))
      (zwei:barf "Suitable superiors were inconsistent: ~a" description))
    (values allowed-type description)))

(defun 1insert-contents-list-near-sibling0 (contents-list how sibling)
  (ecase how
    (:after
      (dolist (directive contents-list)
	(insert-structure-near-sibling directive :after sibling)
	(setq sibling directive)))
    (:before
      (dolist (directive contents-list)
	(insert-structure-near-sibling directive :before sibling)))))

(defmacro 1with-many-bps0 ((list-of-bps) &body body)
  `(with-many-bps-internal ,list-of-bps (named-lambda with-many-bps (,list-of-bps) ,@body)))

(defun 1with-many-bps-internal0 (list-of-bps continuation)
  (declare (sys:downward-funarg continuation))
  (let ((saved-bps (mapcar (lambda (bp) (zwei:copy-bp bp :normal)) list-of-bps)))
    (unwind-protect
	(funcall continuation saved-bps)
      (mapc #'zwei:flush-bp saved-bps))))

(defun 1fix-up-connection-markers-for-adjacent-diagrams0 (bp)
  ;; 1FIX0 1ME0 --- We should not just check for non-nil *interval* here.  Callers should bind
  ;; *interval* if they suspect it is nil.  (hint:  Edit System ends up calling
  ;; fix-up-connection-markers-for-adjacent-diagrams with *interval* nil)
  (when zwei:*interval*
    (let* ((bp-line (zwei:bp-line bp))
	   (previous-bp-line (zwei:line-previous-in-buffer bp-line))
	   (bp-diagram (zwei:line-diagram bp-line))
	   (previous-bp-diagram (when previous-bp-line
				  (zwei:line-diagram previous-bp-line))))
      (when (and bp-diagram previous-bp-diagram)
	(let ((structure
		(zwei:markup-line-diagram-mixin-markup-structure bp-diagram)))
	  (when (maintains-connection-flags-p structure)		 
	    (setf (connected-to-previous-line
		    structure
		    (zwei:mdl-trailer-p bp-diagram bp-line :for-previous))
		  t)
	    (zwei:diagram-lines-need-redisplay (zwei:line-node bp-line)
					       :run-in-markers-only t))))))
  bp)

(defun 1insert-sage-contents-list0 (at-bp contents-list)
  (zwei:mung-bp-interval (zwei:point))
  (zwei:prepare-to-insert at-bp nil)
  (multiple-value-bind (flavor description)
      (sage-contents-list-allowable-superiors contents-list)
    (multiple-value-bind (superior superiors-old-zwei-node)
	(find-superior-of-type-enclosing-region flavor at-bp at-bp)
      (ignore superiors-old-zwei-node)
      (unless superior
	(zwei:barf "Could not find a suitable superior: ~A" description))
      (let ((non-moving-bps-to-move nil)
	    (saved-places-to-move-them-to ()))
	(flet ((non-boundary-bp-p (bp)
		 (let ((node (zwei:bp-node bp)))
		   (and (neq bp (zwei:node-first-bp node))
			(neq bp (zwei:node-last-bp node))))))
	  ;; We have to move the bp's that aren't supposed to move in order for them
	  ;; to seem to stay in the right places.
	  (dolist (bp (zwei:line-bp-list (zwei:bp-line at-bp)))
	    (when (and (non-boundary-bp-p bp)
		       (zwei:bp-= bp at-bp))
	      (push bp non-moving-bps-to-move)
	      (push (zwei:forward-char bp (ecase (zwei:bp-status bp)
					    ((nil :normal)
					     -1)
					    (:moves
					      1)))
		    saved-places-to-move-them-to))))
	
	(with-many-bps (saved-places-to-move-them-to)
	  (multiple-value-bind (left-structure middle-structure right-structure mode)
	      (sage-structure-split-boundary-leaves at-bp at-bp)
	    (ignore middle-structure)
	    (flet ((insert-it (how sibling)
		     (assert (eql (directive-superior sibling) superior))
		     (insert-contents-list-near-sibling contents-list how sibling)))
	      (case mode
		(:no-split
		  ;; Was already at the edge of a node, so no splitting was done.
		  ;; The original node will be returned as either left-structure or
		  ;; right structure, depending on which edge point was on.  Insert the
		  ;; new node before or after, as appropriate.
		  (cond ((not (null left-structure))
			 (insert-it :after left-structure))
			((not (null right-structure))
			 (insert-it :before right-structure))
			(T (error "No splitting was done, but neither left- nor right-structure? (internal error)"))))
		(:adjacent
		  ;; One node was split down the middle.  The left-structure is the old node
		  ;; and the right-structure is the split off stuff.  Put the new node
		  ;; between them.
		  (insert-it :after left-structure)))))
	  ;; rely on merge-adjacent-text-inferiors to insert the new zwei nodes
	  (merge-adjacent-text-inferiors superior superiors-old-zwei-node
					 :force-node-regeneration t)
	  (fix-up-connection-markers-for-adjacent-diagrams at-bp)
	  (mapc (lambda (bp-to-move bp-to-move-it-to)
		  (zwei:move-bp bp-to-move
				(zwei:forward-char bp-to-move-it-to
						   (ecase (zwei:bp-status bp-to-move)
						     ((nil :normal)
						      1)
						     (:moves
						       -1)))))
		non-moving-bps-to-move
		saved-places-to-move-them-to))
	))))

;;; --- This probably should look to see if the actual text in the interval starts or ends
;;; with a return and delete the return instead of deleting the return implicit in the
;;; connection flag.
(defun 1about-to-delete-interval 0(from-bp to-bp)
  ;; --- If the thing at from-bp is a diagram line without a connection
  ;; to the next line (i.e., there is a real return after it), "delete"
  ;; the return by setting the connection flag and moving the bp up one.
  ;; We assume the bps are already in order
  (when (or (zwei:bp-= from-bp to-bp)
	    (not zwei:*using-connection-markers*))
    (return-from about-to-delete-interval (values from-bp to-bp)))
  ;; If user has marked an entire markup, don't try to just delete the outside returns.
  ;; We will assume the desire is to really delete the whole interval
  (let* ((from-bp-node (zwei:bp-node from-bp))
	 (to-bp-2 (zwei:forward-char to-bp -1))
	 (to-bp-node (zwei:bp-node to-bp-2))
	 (first (zwei:bp-= from-bp (zwei:node-first-bp from-bp-node)))
	 (last (zwei:bp-= to-bp-2 (zwei:node-last-bp to-bp-node))))
    (when (or (and (zwei:window-region-p) first last (eq from-bp-node to-bp-node))
	      ;; ---- Kludge Alert! ----
	      ;; This is perhaps the grossest kludge that exists in Concordia, but
	      ;; it can't be fixed without remodularizing Zwei.  Really.  We thought
	      ;; about it.
	      (eql zwei:*current-command* 'zwei:com-kill-line))
      (return-from about-to-delete-interval (values from-bp to-bp))))
  (flet ((check-for-connections (direction bp)
	   (unless (or (eql direction :from)
		       (eql direction :to))
	     (return-from check-for-connections bp))
	   (let* ((line (zwei:bp-line bp))
		  (diagram-line (zwei:line-diagram line)))
	     ;; this case can only happen when killing a blank line.
	     (when (eq (zwei:line-type line) ':blank)
	       (return-from about-to-delete-interval (values from-bp to-bp)))
	     (when diagram-line			;return quickly if not on a diagram line
	       (let* ((markup-structure 
			(zwei:markup-line-diagram-mixin-markup-structure diagram-line))
		      (d-l-header-p
			(eq line (zwei:bp-line (zwei:node-first-bp (zwei:line-node line)))))
		      (d-l-trailer-p (zwei::markup-diagram-line-trailer-p line))
		      ;; This probably should be changed to use mdl-trailer-p --- mcw
		      (trailer-p (if (eql direction :from)
				     d-l-trailer-p
				     (if d-l-header-p nil d-l-trailer-p))))
		 (when (and markup-structure
			    (maintains-connection-flags-p markup-structure)
			    (not
			      (if (eql direction :from)
				  (connected-to-next-line markup-structure trailer-p)
				  (connected-to-previous-line markup-structure trailer-p))))
		   (if (eql direction :from)
		       (setf (connected-to-next-line markup-structure trailer-p) t)
		       (setf (connected-to-previous-line markup-structure trailer-p) t))
		   (zwei:diagram-lines-need-redisplay (zwei:line-node line)
						      :run-in-markers-only t)
		   (setq bp (zwei:forward-char bp (if (eql direction :from) 1 -1)))))))
	   bp))
    (setq from-bp (check-for-connections :from from-bp))
    (when (zwei:bp-= from-bp to-bp)
      (zwei:back-out-of-kill-interval from-bp to-bp)
      (return-from about-to-delete-interval (values from-bp to-bp)))
    (setq to-bp (check-for-connections :to to-bp))
    (values from-bp to-bp)))

(defmethod 1(zwei:delete-interval-1 zwei:markup-buffer)0 (from-bp to-bp)
  (multiple-value-setq (from-bp to-bp)
    (about-to-delete-interval from-bp to-bp))
  (unless (balanced-markup-boundaries-p from-bp to-bp)
    ;; --- "Zwei is brain dead" alert ---
    ;; we'd like this to only run when zwei:*current-command-type* is 'zwei:kill
    ;; but, unfortunately, many zwei commands do not set *current-command-type* until
    ;; 2after0 doing their useful stuff!!
    (zwei:back-out-of-kill-interval from-bp to-bp t)
    (zwei:barf "Attempt to delete unbalanced markup boundaries"))
  (delete-sage-interval from-bp to-bp))

;; Deletes both text and the underlying structure
(defun 1delete-sage-interval0 (from-bp to-bp)
  ;; Munging either bp is adequate to hit the record since
  ;; the interval being deleted never crosses record boundaries
  (zwei:mung-bp-interval from-bp)
  (let* ((from-bp (zwei:copy-bp from-bp))	; guard against bp-movement code
	 (to-bp (zwei:copy-bp to-bp))
	 (from-zwei-node (zwei:bp-node from-bp))
	 (to-zwei-node (zwei:bp-node to-bp)))
    (check-for-unbalanced-language-forms from-bp to-bp)
    (multiple-value-prog1
      (cond ((typep from-zwei-node 'zwei:markup-buffer)
	     (if (zwei:bps-connected-by-simply-connected-lines from-bp to-bp)
		 (zwei:delete-interval-2 from-bp to-bp)
		 (let ((line (zwei:last-simply-connected-line (zwei:bp-line from-bp))))
		   (zwei:delete-interval-2 from-bp
					   (zwei:create-bp line (zwei:line-length line)))
		   (let ((next-line (zwei:line-next-in-buffer line)))
		     (if next-line
			 ;; This will kill any buffer-stuff left over after the last diagram
			 (delete-sage-interval (zwei:create-bp next-line 0) to-bp)
			 from-bp)))))
	    ((typep to-zwei-node 'zwei:markup-buffer)
	     (let ((line (zwei:first-simply-connected-line (zwei:bp-line to-bp))))
	       (let ((previous-line (zwei:line-previous-in-buffer line)))
		 (delete-sage-interval
		   from-bp (zwei:create-bp previous-line
					   (zwei:line-length previous-line))))
	       (zwei:delete-interval-2 (zwei:create-bp line 0) to-bp)))
	    (t (let ((from-sage-node (zwei:markup-structure-node-markup-structure
				       from-zwei-node))
		     (to-sage-node (zwei:markup-structure-node-markup-structure
				     to-zwei-node)))
		 (flet ((relocate-included-bps ()
			  (loop with to-line = (zwei:bp-line to-bp)
				for line = (zwei:bp-line from-bp)
					 then (zwei:line-next-in-buffer line)
				do (zwei:move-nonboundary-bps-of-line-to line to-bp)
				until (eq line to-line)
				when (null (zwei:line-next-in-buffer line))
				  do (error "null line-next-in-buffer of line (internal error)"))))
		   (cond ((eql from-sage-node to-sage-node)
			  ;; If the (single) node is a text node, let zwei do it.
			  ;; Else either the bps are equal (empty region), in which case we
			  ;; have nothing to do; or an entire node is being deleted.
			  (cond ((typep from-sage-node 'sage-text-structure)
				 (zwei:delete-interval-2 from-bp to-bp))
				((zwei:bp-= from-bp to-bp)
				 from-bp)
				(T
				 (relocate-included-bps)
				 (let ((new-bp (or (zwei:forward-char from-bp -1)
						   (zwei:forward-char from-bp 1 T))))
				   (delete-entire-sage-directive
				     from-sage-node from-zwei-node
				     new-bp)
				   (merge-adjacent-text-inferiors
				     (directive-superior from-sage-node)
				     (zwei:node-superior from-zwei-node)
				     :n-levels 1)
				   new-bp))))
			 (T (relocate-included-bps)
			    (delete-partial-sage-directives from-bp to-bp
							    from-zwei-node to-zwei-node
							    from-sage-node to-sage-node)
			    from-bp))))))
      (fix-up-connection-markers-for-adjacent-diagrams to-bp))))

(defun 1delete-partial-sage-directives0 (from-bp to-bp 
				       from-zwei-node to-zwei-node
				       from-sage-node to-sage-node
				       &aux retain-from-text-node)
  (assert (not (eql from-sage-node to-sage-node)))
  ;; Verify they have a common Sage structure as superior
  (multiple-value-bind (common-sage-superior common-zwei-superior)
      (block found-it
	(do-zwei-sage-superiors (l-zwei l-sage from-zwei-node)
	  (do-zwei-sage-superiors (ignore r-sage to-zwei-node)
	    (when (eq l-sage r-sage) (return-from found-it (values l-sage l-zwei)))))
	(zwei:barf "---The sage structures did not have a common superior."))
    (assert (neq from-sage-node to-sage-node))
    (assert (neq from-zwei-node to-zwei-node))
    ;; if either from-node or to-node is a text node (as opposed to
    ;; a structure node), delete the included part of its text.
    (when (typep from-sage-node 'sage-text-structure)
      (let ((node-last-bp (zwei:node-last-bp from-zwei-node))
	    (node-first-bp (zwei:node-first-bp from-zwei-node)))
	;; there's a wierdo case.  If we're at the beginning or end of
	;; a text node we have to make sure that the blank line ends up going
	;; away.
	(cond ((and (zerop (length (zwei:bp-line from-bp)))
		    ;; we don't need to check line-diagram -ness
		    ;; here because this is a sage-text-structure
		    (zwei:bp-= node-last-bp from-bp))
	       (cond ((zwei:bp-= (zwei:forward-char node-first-bp) node-last-bp)
		      ;; this is the screw case
		      (zwei:move-bp node-last-bp node-first-bp)
		      (setf (zwei:line-next (zwei:bp-line node-first-bp)) nil)
		      (setq from-bp (zwei:move-bp from-bp node-first-bp))
		      (setq retain-from-text-node t))
		     (t
		      (setq from-bp (zwei:delete-interval-2
				      (or 
					(zwei:forward-char from-bp -1 () from-zwei-node)
					node-first-bp)
				      from-bp)))))
	      (t (setq from-bp (zwei:delete-interval-2
				 from-bp (zwei:node-last-bp from-zwei-node)))))))
    (when (typep to-sage-node 'sage-text-structure)
      (setq to-bp (zwei:delete-interval-2 (zwei:node-first-bp to-zwei-node) to-bp)))
    ;; Note the partial nodes cut by start-bp and end-bp.  Walk line-by-line
    ;; (using line-next-in-buffer) checking line-node of each.  If it (the node)
    ;; isn't in the partial-node list, do delete-entire-sage-directive on it.
    (let ((partial-nodes (list common-sage-superior)))
      (do-zwei-sage-superiors (zwei-node sage-node from-zwei-node)
	(ignore zwei-node)
	(cond ((eql sage-node common-sage-superior)
	       (return nil))
	      ((eql sage-node from-sage-node)
	       ;; If the from-bp starts its node, that node isn't split
	       (when (or retain-from-text-node
			 (not (zwei:bp-= from-bp (zwei:interval-first-bp from-zwei-node))))
		 (push sage-node partial-nodes)))
	      (T (push sage-node partial-nodes))))
      (do-zwei-sage-superiors (zwei-node sage-node to-zwei-node)
	(ignore zwei-node)
	(cond ((eql sage-node common-sage-superior)
	       (return nil))
	      ((eql sage-node to-sage-node) 
	       ;; if the to-bp ends its node, that node isn't split
	       (unless (zwei:bp-= to-bp (zwei:interval-last-bp to-zwei-node))
		 (push to-sage-node partial-nodes)) )
	      (T (push sage-node partial-nodes))))
      (let ((to-line (zwei:bp-line to-bp))
	    (line (zwei:bp-line from-bp)))
	(loop do
	  (when (null line)
	    (error "Fell off end of nodes (internal error)"))
	  (let* ((line-zwei-node (zwei:line-node line))
		 (line-sage-node (zwei:markup-structure-node-markup-structure
				   line-zwei-node)))
	    (flet ((find-next-line (node)
		     (let ((next-line (zwei:markup-structure-node-last-unlinked-line
					node :from-above)))
		       (when (eq (zwei:line-node next-line) node)
			 (setq next-line (zwei:line-next-in-buffer next-line)))
		       next-line)))
	      (cond ((member line-sage-node partial-nodes)
		     ;;--- Please speed this up by having the partial nodes
		     ;; involve themselves instead of this going line-by-line
		     ;; from the outside
		     (cond ((eql line to-line)
			    (loop-finish))
			   (T (setq line (zwei:line-next-in-buffer line)))))
		    ;; Line's node is not partial, so to-bp must point at either the first-
		    ;; or last-bp of the node.
		    ((eql line-sage-node to-sage-node)
		     ;; If to-bp points at first-bp of the node, exclude the node (don't delete it).
		     (unless (zwei:bp-= to-bp (zwei:node-first-bp line-zwei-node))
		       (delete-entire-sage-directive
			 line-sage-node
			 line-zwei-node
			 (zwei:create-bp (find-next-line line-zwei-node) 0)))
		     (loop-finish))
		    (T (let ((next-line (find-next-line line-zwei-node)))
			 (delete-entire-sage-directive line-sage-node line-zwei-node
						       (zwei:create-bp next-line 0))
			 (setq line next-line)))))))))
    (merge-adjacent-text-inferiors common-sage-superior common-zwei-superior)))

(defgeneric 1delete-entire-sage-directive0 (sage-directive its-zwei-node replacement-bp)
  (:method (record-field)
   (ignore its-zwei-node replacement-bp)
   ;; (cerror "Ignore the attempt" "Record fields may not be deleted")
   ())
  (:method (sage-directive)
   (labels ((delete-inferiors (sage-directive its-zwei-node replacement-bp)
	      (dolist (zwei-inferior (zwei:node-inferiors its-zwei-node))
		(let ((sage-inferior (zwei:markup-structure-node-markup-structure
				       zwei-inferior)))
		  (assert (member sage-inferior (directive-inferiors sage-directive)))
		  (delete-inferiors sage-inferior zwei-inferior replacement-bp)))
	      (when (typep its-zwei-node 'zwei:markup-structure-text-node)
		(zwei:delete-interval-2 (zwei:interval-first-bp its-zwei-node)
					(zwei:interval-last-bp its-zwei-node)))
	      (let* ((first-bp (zwei:node-first-bp its-zwei-node))
		     (last-bp (zwei:node-last-bp its-zwei-node))
		     (first-line (zwei:bp-line first-bp))
		     (last-line (zwei:bp-line last-bp)))
		;; The inner lines (if any) have been taken care of by delete-interval-2.
		;; So we just have to do the first and last lines
		(zwei:move-nonboundary-bps-of-line-to first-line replacement-bp)
		(unless (eql last-line first-line)
		  (zwei:move-nonboundary-bps-of-line-to last-line replacement-bp)))))
     (delete-inferiors self its-zwei-node replacement-bp))
   ;; Clean up the Sage structure
   (assert (member self (directive-inferiors superior)))
   (setf (directive-inferiors superior)
	 (delete self (directive-inferiors superior)))
   (let ((superior-of-zwei-node (zwei:node-superior its-zwei-node)))
     (assert (eql (zwei:markup-structure-node-markup-structure superior-of-zwei-node)
		  superior))
     (assert (member its-zwei-node (zwei:node-inferiors superior-of-zwei-node)))
     (setf (zwei:node-inferiors superior-of-zwei-node)
	   (delete its-zwei-node (zwei:node-inferiors superior-of-zwei-node)))
     (zwei:redo-node-links superior-of-zwei-node))
   ()))

(defun 1splice-node-children-in-place-of-node0 (zwei-node its-sage-node)
  (assert (typep zwei-node '(and zwei:markup-structure-node
				 (not zwei:markup-structure-text-node))))
  (assert (typep its-sage-node '(and sage-directive (not sage-text-structure))))
  (zwei:mung-node zwei-node)
  (let* ((zwei-superior (zwei:node-superior zwei-node))
	 (superior (directive-superior its-sage-node))
	 (superior-inferiors (directive-inferiors superior))
	 (sage-inferiors (directive-inferiors its-sage-node))
	 (pos (or (position its-sage-node superior-inferiors)
		  (error "Cannot find structure ~s in inferiors of ~s (internal error)"
			 its-sage-node superior))))
    (assert (eq (zwei:markup-structure-node-markup-structure zwei-superior) superior))
    (dolist (inf sage-inferiors)
      (setf (directive-superior inf)
	    superior))
    (setf (directive-inferiors superior)
	  (nconc (subseq superior-inferiors 0 pos)
		 (copy-list sage-inferiors)
		 (subseq superior-inferiors (1+ pos))))
    ;; rely on merge-adjacent-text-inferiors to call zwei:insert-markup-structure-nodes
    (merge-adjacent-text-inferiors superior zwei-superior :force-node-regeneration t)))

;;; This is a little like merge-adjacent-text-list
;;; We have to call zwei:insert-markup-structure-nodes if we did any text node
;;; merging, but often our caller also did structure modifications that require
;;; node regeneration.  We don't want to regenerate ZWEI nodes more often than
;;; necessary, and we certainly don't want to regenerate them less often than
;;; necessary, so let the caller tell merge-adjacent-text-inferiors to regenerate
;;; whether any text structures were merged or not.
(defgeneric 1merge-adjacent-text-inferiors0 (sage-directive its-zwei-node
							  &key
							  n-levels
							  force-node-regeneration)
  )

(defgeneric 1merge-adjacent-text-inferiors-10 (sage-directive n-levels)
  (declare (values did-some-merging))
  )

(defmethod 1(merge-adjacent-text-inferiors sage-directive :default)0 (&rest ignore)
  nil)

(defmethod 1(merge-adjacent-text-inferiors-1 sage-directive :default)0 (n-levels)
  (ignore n-levels)
  nil)

(defmethod 1(merge-adjacent-text-inferiors doc-record)0 (its-zwei-node &key force-node-regeneration n-levels)
  (when (null n-levels) (setq n-levels 1e6))
  (let ((merged-something nil))
    (dolist (node (zwei:node-inferiors its-zwei-node))
      (when (merge-adjacent-text-inferiors-1 (zwei:markup-structure-node-markup-structure node)
					     (1- n-levels))
	(setq merged-something t)))
    (when (or merged-something force-node-regeneration)
      (zwei:insert-markup-structure-nodes self :in-place-of-node its-zwei-node))))

(defmethod 1(merge-adjacent-text-inferiors sage-directive-inferiors-mixin)
0	   (its-zwei-node &key force-node-regeneration n-levels)
  (when (null n-levels) (setq n-levels 1e6))
  (let ((merged-something nil))
    (setq merged-something (merge-adjacent-text-inferiors-1 self n-levels))
    (when (or merged-something force-node-regeneration)
      (zwei:insert-markup-structure-nodes self :in-place-of-node its-zwei-node))))

(defmethod 1(merge-adjacent-text-inferiors-1 sage-directive-inferiors-mixin)0 (n-levels)
  (let ((inferior-merged nil))
    (when (> n-levels 1)
      (dolist (inf (directive-inferiors self))
	(when (merge-adjacent-text-inferiors-1 inf (1- n-levels))
	  (setq inferior-merged t))))
    (let ((to-do (directive-inferiors self))
	  (to-flush ()))
      (loop while to-do do			;loop until we find a text node
	(let ((this (pop to-do)))
	  (when (typep this 'sage-text-structure)
	    (loop while to-do do		;loop while we have text nodes
	      (let ((that (pop to-do)))
		(cond ((typep that 'sage-text-structure)
		       (merge-adjacent-text-structures this that)
		       (push that to-flush))
		      (T (loop-finish))))))))
      (when (not (null to-flush))
	(setq to-flush (nreverse to-flush))
	;; Remove from the sage world
	(setf (directive-inferiors self)
	      (set-difference (directive-inferiors self) to-flush)))
      (or inferior-merged
	  (not (null to-flush))))))

(defun 1merge-adjacent-text-structures0 (this that)
  (let ((this-interval (sage-text-structure-interval this))
	(that-interval (sage-text-structure-interval that))
	(zwei:*enable-change-recording* nil))
    (zwei:with-bp (end-of-this (zwei:node-last-bp this-interval) :normal)
      ;; Adjacent text structures display as if there were a newline
      ;; between them, so put one there when we merge them.
      (zwei:insert-moving end-of-this #\return)
      (zwei:with-bp (relocate-to-bp end-of-this :normal)
	(zwei:insert-interval end-of-this that-interval)
	(zwei:delete-interval-2 (zwei:node-first-bp that-interval)
				(zwei:node-last-bp that-interval))
	(let ((first-of-that (zwei:node-first-bp that-interval))
	      (last-of-that (zwei:node-last-bp that-interval)))
	  (assert (eql (zwei:bp-line first-of-that)
		       (zwei:bp-line last-of-that)))
	  ;; Move all the BP's of THAT to the point of the original
	  ;; boundary between THIS and THAT.
	  (dolist (bp (zwei:line-bp-list (zwei:bp-line first-of-that)))
	    (unless (or (eql bp first-of-that) (eql bp last-of-that))
	      (zwei:move-bp bp relocate-to-bp))))))))

;;; Methods to display sage command diagrams in editor buffers
;;; This is in sage:: because otherwise it's too painful to type
;;; sage:: everywhere to access the datastructures

(define-sage-command-generic 1basic-command-editor-diagram-draw0 (stream)
  (format stream "~(~a~)" command-name))

;; This isn't supposed to get called because the @L commands get expanded in line
#+Ignore
(define-sage-command-method 1(basic-command-editor-diagram-draw L)0 (stream)
  (with-character-face ('lisp stream)
    (write-string (display-string-from-L-command self) stream)))

;; --- It would be nice to run the formatter here.
(defun 1simplistic-write-contents-list0 (contents-list stream preserve-newlines show-delimiters)
  (when show-delimiters (write-string "" stream))
  (when contents-list
    (write-string (filtered-string-from-contents-list contents-list preserve-newlines)
		  stream))
  (when show-delimiters (write-string "" stream)))

;; ---This is inadequate -- there should to be a way to get the contents into the buffer
;; for editing, as if the command were an environment.
(define-sage-command-method 1(basic-command-editor-diagram-draw
			      (appendixsection blocklabel caption Chapter Foot Index Index2
			       Majorpart Note OP OVP Section
			       Subsection SubSubSection))
0			    (stream)
  (format stream "~:(~a~): " command-name)
  (simplistic-write-contents-list (first parameter) stream T T))

(define-sage-command-method 1(basic-command-editor-diagram-draw pageheading)0 (stream)
  (write-head-foot stream "PageHeading" even odd immediate left center right line))

(define-sage-command-method 1(basic-command-editor-diagram-draw pagefooting)0 (stream)
  (write-head-foot stream "PageFooting" even odd immediate left center right line))

(defun 1write-head-foot0 (stream command-name even odd immediate left center right line)
  (princ command-name stream)
  (let ((did-something ()))
    (labels ((did-something () (setq did-something T))
	     (separate ()
	       (write-string (if did-something ", "  " ") stream))
	     (write-flag (value string)
	       (when value
		 (separate)
		 (write-string string stream)
		 (did-something)))
	     (write-contents-list (value string)
	       (when value
		 (separate)
		 (write-string string stream)
		 (write-string "=" stream)
		 (simplistic-write-contents-list value stream T T)
		 (did-something))))
      (write-flag even "Even")
      (write-flag odd "Odd")
      (write-flag immediate "Immediate")
      (write-contents-list left "Left")
      (write-contents-list center "Center")
      (write-contents-list right "Right")
      (write-contents-list line "Line"))))

(define-sage-command-method 1(basic-command-editor-diagram-draw blankspace)0 (stream)
  (format stream "BlankSpace ~a" distance))

(define-sage-command-method 1(basic-command-editor-diagram-draw blankpage)0 (stream)
  (write-string "BlankPage" stream)
  (when n (format stream " ~a" n)))

(define-sage-command-method 1(basic-command-editor-diagram-draw include)0 (stream)
  (format stream "Include ~a" filename))

(define-sage-command-method 1(basic-command-editor-diagram-draw (label pageref ref tag))
0			    (stream)
  (format stream "~:(~a~) ~a" command-name (first parameter)))

(define-sage-command-method 1(basic-command-editor-diagram-draw (tabs tabset tabstops))0 (stream)
  (format stream "~:(~a~) ~(~{~a~^, ~}~)" command-name parameter))

(define-sage-command-method 1(basic-command-editor-diagram-draw tabdivide)0 (stream)
  (format stream "TabDivide ~d" n))

(define-sage-command-method 1(basic-command-editor-diagram-draw make)0 (stream)
  (format stream "Make ~:(~a~)" type)
  (when form (format stream ", Form ~d" form)))

(define-sage-command-method 1(basic-command-editor-diagram-draw modify)0 (stream)
  (format stream "Modify ~a" environment))

(define-sage-command-method 1(basic-command-editor-diagram-draw newpage)0 (stream)
  (write-string "NewPage" stream)
  (when n (format stream " ~d" n)))

(define-sage-command-method 1(basic-command-editor-diagram-draw string)0 (stream)
  (write-string "String " stream)
  (let ((did-one ()))
    (dolist (string strings)
      (when did-one (write-string ", " stream))
      (princ (first string) stream)		;hide the contents
      (setq did-one T))))


(define-sage-command-method 1(basic-command-editor-diagram-draw cite)0 (stream)
  (let ((tag (citation-command-citation self)))
    (let ((item (gethash tag *bibliography-database*)))
      (if item
	  (format stream "Cite ~a (~a)"
		  tag (gethash (bibliography-entry-classification item)
			       (third *bibliography-parsing-database*)))
	  (format stream "Cite ~a" tag)))))

(define-sage-command-method 1(basic-command-editor-diagram-draw style)0 (stream)
  (write-string "Style " stream)
  (loop for first = T then nil
	for (kind) in parameter
	unless first do (write-string ", " stream)
	do (write kind
		  :stream stream
		  :escape nil
		  :case :downcase)))

(define-sage-command-method 1(basic-command-editor-diagram-draw use)0 (stream)
  (write-string "Use " stream)
  (loop for first = T then nil
	for (kind) in parameter
	unless first do (write-string ", " stream)
	do (write kind
		  :stream stream
		  :escape nil
		  :case :downcase)))

(define-sage-command-method 1(basic-command-editor-diagram-draw SimpleTableSpecs)0 (stream)
  (write-string "SimpleTableSpecs " stream)
  (loop for first = T then nil
	for (kind val) in parameter
	unless first do (write-string "; " stream)
	do (format stream "~:(~a~) ~a" kind val)))

(define-sage-command-method 1(basic-command-editor-diagram-draw indexprimary)0 (stream)
  (format stream "~:(~a~): " command-name)
  (simplistic-write-contents-list entry stream nil T))
(define-sage-command-method 1(basic-command-editor-diagram-draw indexsecondary)0 (stream)
  (format stream "~:(~a~): " command-name)
  (simplistic-write-contents-list (append primary '("|") secondary) stream nil T))

(define-sage-command-method 1(basic-command-editor-diagram-draw (rfstr rmstr))0 (stream)
  (let ((text (first parameter)))		;aaugh!
    (format stream "~:(~a~): " command-name)
    (simplistic-write-contents-list text stream nil T)))

;; Use this to cause new editor-draw definitions to take effect.
;; (zwei:invalidate-cached-title-strings)
