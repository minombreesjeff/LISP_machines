;;;-*- Syntax: Common-lisp; Mode: Lisp; Package: Nsage; Lowercase: T; Base: 10 -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;; Concordia, the high-end Writer Tools Activity

(dw:define-program-framework D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")Concordia
0  :pretty-name "Symbolics Concordia"
  :command-definer T
  :select-key #\W
  :top-level (concordia-top-level)
  :command-table (:inherit-from
		   '("colon full command" "standard arguments" "standard scrolling")
		   :kbd-accelerator-p 'nil)
  :state-variables ((force-redisplay nil)
		    (editor-window-changed-mode nil)
		    (current-editor-record nil)
		    )
  :panes ((title :title
		 :redisplay-function 'draw-concordia-title
		 :height-in-lines 1
		 :default-character-style '(:eurex :italic :huge)
		 :redisplay-after-commands nil)
	  (overall-menu :display
			:redisplay-function 'redisplay-overall-menu
			:redisplay-after-commands T
			)
	  (editor-menu :display
		       :redisplay-function 'redisplay-editor-menu
		       :redisplay-after-commands T
		       :incremental-redisplay T
		       :save-bits :delayed
		       :margin-components '((dw:margin-borders )
					    (dw:margin-scroll-bar :visibility :if-needed)
					    (dw:margin-white-borders :thickness 2))
		       :default-character-style '(:jess :roman :normal)		       
		       )
	  (references-pane-title :title
				 :redisplay-function 'draw-references-pane-title
				 :height-in-lines 1
				 :default-character-style '(:swiss :roman :small)
				 :redisplay-after-commands nil
				 :margin-components
				 '((dw::margin-asymmetrical-borders
				     :left-thickness 1
				     :top-thickness 1
				     :right-thickness 1
				     :bottom-thickness 0)
				   ))
	  (references-pane :display
			   :redisplay-function 'redisplay-references-pane
			   ;; the below is necessary even though it's always forced by Zmacs
			   :redisplay-after-commands T
			   :incremental-redisplay t
			   :more-p nil
			   :end-of-page-mode :truncate
			   :margin-components
			     '((dw::margin-asymmetrical-borders
				 :left-thickness 1
				 :top-thickness 0
				 :right-thickness 1
				 :bottom-thickness 1)
			       (dw:margin-scroll-bar  :visibility :if-needed)
			       (dw:margin-white-borders :thickness 2))
			   :default-character-style *screen-default-character-style*)
	  (zmacs-current-record-title
	    :display
	    :redisplay-after-commands T
	    :more-p nil
	    :end-of-page-mode :truncate
	    :margin-components '((dw::margin-asymmetrical-borders
				 :left-thickness 1
				 :top-thickness 1
				 :right-thickness 1
				 :bottom-thickness 0)
				 (dw:margin-whitespace :margin :bottom)
				 (dw:margin-pattern :margin :bottom :pattern :black)
				 (dw:margin-white-borders :thickness 2))
	    :default-character-style *screen-default-character-style*)
	  (zmacs :display
		 :flavor zmacs-frame-with-pane-mixin
		 :width 785
		 :margin-components ())
	  (graphic-editor-pane
	    :display
	    :flavor dw::program-frame-with-pane-mixin
	    :program 'graphic-editor:graphic-editor
	    :process nil
	    :margin-components ())
	  (page-previewer-pane
	    :display
	    :flavor dw::program-frame-with-pane-mixin
	    :program 'page-previewer
	    :process nil
	    :margin-components ())
	  (book-design-browser-pane
	    :display
	    :flavor dw::program-frame-with-pane-mixin
	    :program 'book-design-browser
	    :process nil
	    :margin-components ())
	  )
  :selected-pane zmacs				;see comment below
  :configurations
  '(;; Zmacs is the initial configuration.  If you change it,
    ;; you MUST change the :selected-pane option above
    (zmacs-editor
      (:layout
	(zmacs-editor :column title-row editor-and-menu)
	(title-row :row title overall-menu)
	(editor-and-menu :row zmacs-with-title editor-menu-column)
	(zmacs-with-title :column zmacs-current-record-title zmacs)
	(editor-menu-column :column editor-menu references-pane-constraint-frame-bug)
	(references-pane-constraint-frame-bug :row references-pane-group)
	(references-pane-group :column references-pane-title references-pane)
	)
      (:sizes
	(zmacs-editor (title-row 1 :lines title) :then (editor-and-menu :even))
	(title-row (title 785) :then (overall-menu :even))
	(editor-and-menu (zmacs-with-title 785) :then (editor-menu-column :even))
	(zmacs-with-title (zmacs-current-record-title 1 :lines) :then (zmacs :even))
	(editor-menu-column (references-pane-constraint-frame-bug .45)
			    :then (editor-menu :even))
	(references-pane-constraint-frame-bug (references-pane-group :even))
	(references-pane-group (references-pane-title 1 :lines)
			       :then (references-pane :even))))
    (page-previewer
      (:layout
	(page-previewer :column title-row page-previewer-pane)
	(title-row :row title overall-menu))
      (:sizes
	(page-previewer (title-row 1 :lines title) :then (page-previewer-pane :even))
	(title-row (title 785) :then (overall-menu :even))))
    (graphic-editor
      (:layout
	(graphic-editor :column title-row graphic-editor-pane)
	(title-row :row title overall-menu))
      (:sizes
	(graphic-editor (title-row 1 :lines title) :then (graphic-editor-pane :even))
	(title-row (title 785) :then (overall-menu :even))))
    (book-design-browser
      (:layout
	(book-design-browser :column title-row book-design-browser-pane)
	(title-row :row title overall-menu))
      (:sizes
	(book-design-browser (title-row 1 :lines title) :then (book-design-browser-pane :even))
	(title-row (title 785) :then (overall-menu :even))))
    ))

(defflavor 1zmacs-frame-with-pane-mixin0 ()
	   (dw:margin-mixin
	    tv:pane-mixin zwei:zmacs-frame)
  (:default-init-plist :number-of-mini-buffer-lines 3
		       :border-margin-width 0
		       :borders nil))

(defvar zwei:*ConEd-buffer-counter* 0)	; Used to generate new buffer names.

;; This horrible kludge is necessary to name the buffer *Concordia-1* 
(defwhopper 1(:init zmacs-frame-with-pane-mixin)0 (&rest args)
  (dynamic-flet (zwei:
		  (GENERATE-BUFFER-NAME ()
		    (LOOP AS COUNTER = (WITHOUT-INTERRUPTS (INCF *ConEd-BUFFER-COUNTER*))
			  DO (LET ((NAME (LET ((DEFAULT-CONS-AREA *ZMACS-BUFFER-AREA*))
					   (FORMAT NIL "*Concordia-~D*" COUNTER))))
			       (UNLESS (GETHASH NAME *ZMACS-BUFFER-NAME-TABLE*)
				 (RETURN NAME))))))
    (lexpr-continue-whopper args)))


;; This horrible kludge is necessary to get TV:PROCESS initialized at the right times.
(defmethod 1(:init zmacs-frame-with-pane-mixin :before)0 (ignore)
  (assert (typep tv:superior 'dw:program-frame))
  (assert (typep (send tv:superior :program) 'concordia))
  (let ((proc (make-process (send tv:superior :name))))
    (process-preset proc 'dw:program-frame-top-level tv:superior)
    (setq tv:process proc)
    (setf (symbol-value-in-instance tv:superior 'tv:process) proc)))

;; This horrible kludge is necesary to get the fonts read in before they're
;; actually called for, so the poor user doesn't have to wait for the file server
(defmethod 1(:init zmacs-frame-with-pane-mixin :after)0 (ignore)
  ;; For page previewer
  (send tv:screen :parse-font-descriptor 'fonts:tinier)
  ;; For editor mode
  (let ((char (symbol-for-editor-buffer 'tab-to-tab-stop)))
    (si:lookup-index-and-font char
			      (send self :display-device-type)
			      *screen-default-character-style*
			      nil)))

;; Usually it's program-top-level's command loop that takes care
;; of redisplaying the frame after Function-Refresh.  But, in the
;; screen configuration which includes the editor, probably it's
;; the editor command loop which is running, not program-top-level's.
;; This code gets the other frame panes refreshed.
(defmethod 1(:refresh zmacs-frame-with-pane-mixin :before)0 (&optional type)
  (when tv:*asynchronous-window-operation*
    (let ((program (send (send self :superior) :program)))
      ;; See fake-redisplay-all-windows in zmacs-editor-toplevel
      (setf (concordia-force-redisplay program) type))))

(compile-flavor-methods zmacs-frame-with-pane-mixin)

(defun 1enable-select-w-for-preview-program0 ()
  #+Ignore ;; restored to Concordia program definition
  (let ((name 'preview-program))
    (tv:add-select-key #\W
		       `(dw::find-program-window-for-select-key ',name nil)
		       (string-capitalize-words name))))

(defun 1draw-concordia-title0 (program pane)
  (ignore program)
  (let ((logo-width (dw:continuation-output-size #'draw-concordia-logo pane))
	(window-width (send pane :inside-width)))
    (let ((delta-x (round (- window-width logo-width) 2)))
      (send pane :clear-history)
      (send pane :set-cursorpos delta-x 0)
      (draw-concordia-logo pane))))

;; Draws wherever the cursor is
(defun 1draw-concordia-logo0 (&optional (stream *standard-output*))
  (with-character-style ('(:eurex :italic :huge) stream :bind-line-height T)
    (let* ((title "Symbolics Concordia")
	   (title-width (send stream :string-length title))
	   (baseline 18) (x-height 12)		;I looked at the font with FED
	   (extra-space-between 8)
	   (sides-width 150)
	   (slope 1/5))
      (multiple-value-bind (outer-x outer-y) (send stream :read-cursorpos)
	(flet ((sides (x)
		 (let* ((dy (truncate x-height 2))
			;; This has to be an integer so it can't round differently below
			(dx (round (* dy slope))))
		   (dotimes (j 3)
		     (let ((y (- (+ outer-y baseline) (* j dy))))
		       (let ((rx (+ outer-x (ceiling (+ x (* j dx))))))
			 (graphics:draw-rectangle rx (- y 2) (+ rx sides-width) y
						  :stream stream)))))))
	  (sides 0)
	  (graphics:draw-string title
				(+ outer-x sides-width extra-space-between) outer-y
				:attachment-y :top
				:stream stream)
	  (sides (+ sides-width (* 2 extra-space-between) title-width)))))))

#+Ignore
(defun 1test-concordia0 ()
  (fresh-line)
  (multiple-value-bind (ignore height)
      (dw:continuation-output-size #'draw-concordia-logo *standard-output*)
    (draw-concordia-logo)
    (send *standard-output* :increment-cursorpos 0 height)))

(defun 1allowed-configuration-names0 (frame)
  ;; This could depend on *debugging-sage*, for instance
  (send frame :configuration-names))

(define-presentation-type 1concordia-configuration0 ()
   :expander 't)

(define-concordia-command 1(com-change-configuration
0				  :menu-accelerator T
				  :menu-level overall-menu)
    ((new-configuration
       `((dw:member-sequence ,(allowed-configuration-names dw:*program-frame*)))
       :default (let ((names (allowed-configuration-names dw:*program-frame*))
		      (current (send dw:*program-frame* :configuration)))
		  (or (second (member current names))
		      (first names)))
			;;---Needs description
			;;---needs default being something else/better
			))
   ;; don't change the configuration here, let throwing cause the
   ;; unwind-protects to run properly and let the top-level command-loop
   ;; actually do the setting of the configuration
   (throw 'change-of-configuration new-configuration))

(defun 1redisplay-overall-menu0 (program stream)
  (multiple-value-bind (pane-width pane-height) (send stream :inside-size)
    ;; The viewport will have been rounded to an integral number of line heights,
    ;; which are meaningless in this graphics only window.
    (maxf (dw::box-bottom (send stream :cursor-viewport)) pane-height)
    (let* ((config-codes '((zmacs-editor #\A)
			   (page-previewer #\B)
			   (graphic-editor #\C)
			   (book-design-browser #\D)))
	   (font (send (send (dw:program-frame program) :screen)
		       :parse-font-descriptor 'fonts:concordia-glyphs))
	   (char-width-table (tv:font-char-width-table font))
	   (configurations (allowed-configuration-names (dw:program-frame program))))
      (flet ((width-of-char (code)
	       (if char-width-table
		   (aref char-width-table code)
		   (tv:font-char-width font)))
	     (code-for-config (config)
	       (char-code (or (second (assoc config config-codes)) #\@))))
	(let* ((total-glyph-width
		 (loop for config in configurations
		       sum (width-of-char (code-for-config config))))
	       (glyph-height (tv:font-char-height font))
	       (margin-at-glyph-sides (round (- pane-width total-glyph-width)
					     (* 2 (length configurations))))
	       (y (round (- pane-height glyph-height) 2))
	       (x margin-at-glyph-sides))
	  (dolist (config configurations)
	    (let ((code (code-for-config config)))
	      (dw:with-output-as-presentation (:stream stream
					       :object `(com-change-configuration ,config)
					       :type 'concordia-configuration)
		(graphics:draw-glyph code font x y :stream stream))
	      (incf x (+ (width-of-char code)
			 (* 2 margin-at-glyph-sides))))))))))

;; I guess I'd rather not define specific commands for each embedded program
;; and translators to those commands from the overall-menu.  This forces
;; them into compliance by bypassing them entirely.  Hmmm.
(define-presentation-action 1force-concordia-change-configuration
0   (concordia-configuration
     cp:command					;any old comtab will do
     :tester ((object) (and (consp object) (eql (first object) 'com-change-configuration)))
     :documentation ((object)
		     (string-append "Change Configuration "
				    (string-capitalize-words (second object))))
     :do-not-compose T
     )
   (object &key window)
  (program-force-concordia-change-configuration object window))

(define-presentation-action 1zmacs-force-concordia-change-configuration
0   (concordia-configuration
     zwei:presentation-command			;any old comtab will do
     :tester ((object) (and (consp object) (eql (first object) 'com-change-configuration)))
     :documentation ((object)
		     (string-append "Change Configuration "
				    (string-capitalize-words (second object))))
     :do-not-compose T
     )
   (object &key window)
  (program-force-concordia-change-configuration object window))

(defun 1program-force-concordia-change-configuration0 (command window)
  (let ((concordia-frame (loop for w = window then (tv:sheet-superior w)
			       do
			   (typecase w
			     ((dw:program-frame)
			      (when (typep (send w :program) 'concordia)
				(return w)))
			     ((tv:sheet) )
			     (otherwise (return nil))))))
    (when concordia-frame
      (let ((concordia-program (send concordia-frame :program)))
	(let ((dw:*program* concordia-program)
	      (dw:*program-frame* concordia-frame)
	      (cp:*command-table* (dw:program-command-table concordia-program)))
	  (apply (car command) (cdr command)))))))

(defun 1keyboard-force-concordia-change-configuration0 ()
  (let (next-char)
    (let ((frame
	    (loop repeat 10	;Don't search forever
		  for f = (sys:%stack-frame-pointer)
			then (sys:frame-previous-frame f)
		  when (let ((function (sys:frame-function f)))
			 (and (typep function 'sys:compiled-function)
			      (let ((fname (sys:function-name function)))
				(and (consp fname)
				     (eq (first fname) 'flavor:method)
				     (eq (third fname) 'tv:stream-mixin)))))
		    return f)))
      (let ((stream (dbg:frame-self-value frame)))
	(when (and (instancep stream)
		   (streamp stream))
	  (let ((tv:kbd-tyi-hook nil))
	    (setq next-char
		  (let ((si:*whostate-awaiting-user-input* "Concordia Select:"))
		    (make-char (send stream :tyi))))
	    (let* ((config-codes '((zmacs-editor #\E)
				   (page-previewer #\P)
				   (graphic-editor #\G)))
		   (the-config (and (characterp next-char)
				    (first (find (char-upcase next-char)
						 config-codes
						 :key #'second)))))
	      (when the-config
		(program-force-concordia-change-configuration
		  `(com-change-configuration ,the-config)
		  dw:*program-frame*)))))))
    ;; Returning something non-null means the s-Select should be ignored
    (unless (eql next-char #\Rubout)
      (beep))
    T))

(define-presentation-type 1references-pane-title0 ()
   :expander T)

(defun 1draw-references-pane-title0 (ignore stream)
  (dw:with-output-as-presentation (:stream stream
				   :object ""
				   :type 'references-pane-title)
    (write-string "   Collected Record Names   " stream)))

;;; patch-me??
(zwei:define-presentation-to-editor-command-translator 1resize-references-pane
0    (references-pane-title
      "Resize Collected Record Names pane"
      *wt-comtab*
      :gesture :select
      )
    (ignore &key window x y)
  `(resize-references-pane ,window ,x ,y))


;; --- It would be nice if Click <don't move the mouse> Click were to
;; leave the windows unchanged.  Introducing the y offsets: some other day.
(defun 1resize-references-pane0 (window click-x click-y)
  (assert (eq window (send (send window :superior) :get-pane 'references-pane-title)))
  (let ((new-top (find-new-references-pane-top window)))
    (if (null new-top)
	(zwei:typein-line " ... leaving it unchanged")
	(alter-references-pane-size window new-top)))
  ;; Unwarp the mouse, perhaps to the same place within a newly-positioned window
  (send window :set-mouse-position click-x click-y))

;;--- Some of the mouse parts might not work for multiple console
(defun 1find-new-references-pane-top0 (window)
  (let* ((frame (send window :superior))
	 (mouse (tv:sheet-mouse frame)))
    (multiple-value-bind (frame-dx frame-dy)
	(tv:sheet-mouse-offsets frame)
      (let ((ms (tv:mouse-sheet mouse)))
	(decf frame-dx (tv:sheet-inside-left ms))
	(decf frame-dy (tv:sheet-inside-top ms)))
      (tv:with-mouse-and-buttons-grabbed-on-sheet (frame)
	(setf (tv:who-line-mouse-grabbed-documentation mouse)
	      "Mouse-Left: place it here;  Middle, Right: abort")
	(tv:wait-for-mouse-button-up "Release mouse button" () mouse)
	(tv:initialize-multiple-move-blinker frame)
	(let ((rectangle-list (list (list 0 0 (send window :width) tv:edge-width))))
	  (tv:mouse-warp (+ (send window :position) frame-dx)
			 (tv:mouse-y mouse)	;don't change
			 mouse)
	  (without-interrupts
	    (tv:open-blinker tv:multiple-move-blinker)
	    (tv:mouse-set-blinker-definition
	      :multiple-rectangle 0 0 T
	      :set-rectangle-list rectangle-list))
	  (multiple-value-bind (button x y)
	      (tv:wait-for-mouse-button-down "Button" nil nil mouse)
	    ;; ---Perhaps there's a better way to eat the click,
	    ;; but I don't know it right now.
	    (send window :any-tyi-no-hang)
	    (when (logtest 1 button)
	      ;; Convert the x,y returned here from screen coordinates
	      (decf x frame-dx)
	      (decf y frame-dy)
	      y)))))))

(defun 1alter-references-pane-size0 (window new-top)
  (multiple-value-bind (left top right bottom) (send window :edges)
    (let* ((frame (send window :superior))
	   (menu-pane (send frame :get-pane 'editor-menu))
	   (references-pane (send frame :get-pane 'references-pane))
	   (references-pane-title window)
	   (min-height-of-menu-pane (* 3 (send menu-pane :line-height)))
	   (min-height-of-references-pane (* 2 (send references-pane :line-height)))
	   (height-of-references-pane-title (- bottom top)))
      (multiple-value-bind (mleft mtop mright mbottom)
	  (send menu-pane :edges)
	(ignore mbottom)
	(multiple-value-bind (rleft rtop rright rbottom)
	    (send references-pane :edges)
	  (ignore rtop)
	  (let* ((topmost-new-top (+ min-height-of-menu-pane mtop))
		 (bottommost-new-top
		   (- rbottom
		      min-height-of-references-pane
		      (- bottom top)))
		 (new-top (max topmost-new-top
			       (min bottommost-new-top new-top))))
	    (tv:delaying-screen-management
	      (send menu-pane :set-edges mleft mtop mright new-top)
	      (send references-pane-title :set-edges
		    left new-top right (+ new-top height-of-references-pane-title))
	      (send references-pane :set-edges
		    rleft (+ new-top height-of-references-pane-title) rright rbottom))))))))

(defun 1redisplay-ConEd-record-title-pane0 (&key (force-p nil) (error-p nil))
  ;; Make sure there is a record title pane to redisplay
  (multiple-value-bind (nil nil program-process)
      (find-containing-concordia)
    (when (not (eql program-process *current-process*))
	(when error-p
	    (cerror "return without redisplaying ConEd record title pane"
		    "Not within Concordia context"))
	(return-from redisplay-ConEd-record-title-pane nil)))
  (multiple-value-bind (record record-node)
      (record-at-point nil)
    ;; Don't try to update the display when it's the minibuffer or something.
    (when (typep (zwei:window-interval zwei:*window*) 'zwei:buffer)
      (when (or (not (eql record (concordia-current-editor-record dw:*program*)))
		force-p)
	(let ((pane (dw:get-program-pane 'zmacs-current-record-title :if-does-not-exist nil))
	      (buffer (zwei:window-interval zwei:*window*)))
	  (cond (record-node
		 (let* ((line-diagram
			  (zwei:line-diagram (zwei:bp-line (zwei:node-first-bp record-node))))
			(string (and line-diagram (zwei:cached-title-string line-diagram))))
		   (send pane :clear-history)
		   (write-string "  Cursor in: " pane)
		   (write-string string pane)))
		(T (send pane :clear-history)))
	  (when (typep buffer 'zwei:file-markup-buffer)
	    (cl:case (zwei:file-markup-buffer-disposition buffer)
	      (:disconnected
		(format pane " (disconnected)"))
	      (:locked
		(format pane " (locked)")))))))
    (setf (concordia-current-editor-record dw:*program*) record)))

;; These are initialized by a moby DEFINE-EDITOR-MENU-COMMANDS in editor-interface
(defvar 1*editor-menu-commands*0)
(defvar 1*editor-menu-debugging-commands*0)
(defvar 1*prepared-editor-menu-commands*0 ())

(defmethod 1(concordia-top-level concordia)0 (&rest options)
  (ignore options)
  (send (dw:get-program-pane 'editor-menu) :set-save-bits t)
  (setf (symbol-value-in-instance (dw:get-program-pane 'graphic-editor-pane) 'tv:process)
	(send dw:*program-frame* :process))
  (let ((tv:kbd-tyi-hook
	  (named-lambda tv:kbd-tyi-hook (char)
	    (when (eql char #\s-Select)
	      (keyboard-force-concordia-change-configuration))))
	(first-time t)
	(configuration (send dw:*program-frame* :configuration))
	(graphic-editor-pane (dw:get-program-pane 'graphic-editor-pane))
	(graphic-editor-drawing-to-edit ())
	(graphic-editor-sage-node-being-edited ()))
    (dynamic-flet ((1graphic-editor::locate-graphic-editor0 ()
		     (send graphic-editor-pane :program))
		   (1graphic-editor:edit-drawing-named0 (file-name name)
		     (setq graphic-editor-drawing-to-edit `(,file-name ,name))
		     (throw 'change-of-configuration 'graphic-editor))
		   (1zwei:edit-picture-of-node0 (picture-node)
		     (setq graphic-editor-sage-node-being-edited picture-node)
		     (continue picture-node))
		   (1graphic-editor::done-10 (graphic-editor)
		     (ignore graphic-editor)
		     ;; really should throw back to whereever you were.
		     (throw 'change-of-configuration 'zmacs-editor)))
      (dbg:with-default-bug-report-recipient-system ("Concordia")
	(loop
	  (multiple-value-setq (*terminal-io* *query-io* *standard-output* *standard-input*)
	    (send dw:*program-frame* :terminal-streams))
	  (unless (eq configuration (send dw:*program-frame* :configuration))
	    (send dw:*program-frame* :set-configuration configuration))
	  (when first-time
	    (send dw:*program-frame* :redisplay t)
	    (setq first-time nil))
	  (setq configuration
		(catch 'change-of-configuration
		  (ecase configuration
		    ((zmacs-editor)
		     (send dw:*program-frame* :select-pane (dw:get-program-pane 'zmacs))
		     (let ((node graphic-editor-sage-node-being-edited))
		       (setq graphic-editor-sage-node-being-edited ())
		       (zmacs-editor-toplevel (dw:get-program-pane 'zmacs)
					      :picture-node node))
		     )
		    ((graphic-editor)
		     (send dw:*program-frame* :select-pane graphic-editor-pane)
		     (when graphic-editor-drawing-to-edit
		       (send (send graphic-editor-pane :get-pane 'graphic-editor::drawing)
			     :force-kbd-input 
			     (dw::make-presentation-blip
			       :presentation-type
			       'graphic-editor::window-wakeup-synchronous-select-new-drawing
			       :object graphic-editor-drawing-to-edit))
		       (setq graphic-editor-drawing-to-edit nil))
		     (dw:program-frame-top-level
		       graphic-editor-pane
		       :initial-redisplay (neq (send graphic-editor-pane :save-bits) t)))
		    ((page-previewer)
		     (let ((pane (dw:get-program-pane 'page-previewer-pane)))
		       (send dw:*program-frame* :select-pane pane)
		       (dw:program-frame-top-level pane)))
		    ((book-design-browser)
		     (let ((pane (dw:get-program-pane 'book-design-browser-pane)))
		       (send dw:*program-frame* :select-pane pane)
		       (dw:program-frame-top-level pane)))))))))))

(defun 1preview-program-change-to-page-preview-configuration0 ()
  (error "This is supposed to be obsolete")
  (unless (eql (send dw:*program-frame* :configuration) 'page-preview)
    (send dw:*program-frame* :set-configuration 'page-preview)
    (multiple-value-setq (*terminal-io* *query-io* *standard-output* *standard-input*)
      (send dw:*program-frame* :terminal-streams))
    (send dw:*program-frame* :select-pane (dw:get-program-pane 'interactor))))

(defmacro 1with-concordia-for-bug-reports-within-zmacs0 (&body body)
  `(stack-let ((dbg:*function-bug-report-alist*
		 (cons '(zwei:zmacs-window-top-level "Concordia")
		       dbg:*function-bug-report-alist*)))
     ,@body))

(defun 1zmacs-editor-toplevel0 (editor-frame &key picture-node)
  (dynamic-flet ((zwei:redisplay-all-windows (&rest args)
		  (when picture-node
		    (let ((pnode picture-node))
		      (setq picture-node nil)	;asap
		      (zwei:must-redisplay
			zwei:*window*
			(zwei:recompile-picture-of-node pnode)))
		    (zwei:must-redisplay zwei:*window* zwei:dis-all))
		  (let ((frame-needs-redisplay nil))
		    (when (null *prepared-editor-menu-commands*)
		      (setq frame-needs-redisplay T))
		    (when (typep dw:*program* 'concordia)
		      (when (fboundp 'redisplay-ConEd-record-title-pane)
			(redisplay-ConEd-record-title-pane))
		      (let ((redisplay-mode (concordia-force-redisplay dw:*program*)))
			(when redisplay-mode
			  (when (neq redisplay-mode :use-old-bits)
			    (unless (concordia-editor-window-changed-mode dw:*program*)
			      (change-mode-of-editor-window-to-writer-tools)
			      (setf (concordia-editor-window-changed-mode dw:*program*)
				    T))
			    (setq frame-needs-redisplay T))
			  (setf (concordia-force-redisplay dw:*program*) nil)))
		      (when frame-needs-redisplay
			(send dw:*program-frame* :redisplay t))))
		  (lexpr-continue args)))
    (with-concordia-for-bug-reports-within-zmacs
      (zwei:zmacs-window-top-level editor-frame))))

(defun 1change-mode-of-editor-window-to-writer-tools0 ()
  (when ( (length zwei:*window-list*) 2)
    (let ((zwei-window (first zwei:*window-list*)))
      (let ((interval (zwei:window-interval zwei-window)))
	(when (and (eq interval zwei:*interval*)
		   (typep interval 'zwei:non-file-buffer)
		   (eq (send interval :major-mode)
		       (zwei:major-mode-from-keyword :fundamental)))
	  (let ((zwei:*set-attribute-updates-list* nil))
	    (zwei:com-concordia-mode))
	  (zwei:must-redisplay zwei:*window* zwei:dis-text))))))

#||
(2 0 (NIL 0) (NIL NIL :SMALL) "TVFONT");;; This is decommissioned because it's too hard to make it work right,
;;; even though it still seems like a good idea.  In the interest of
;;; closer coupling between Page Previewer and ConEd, this would let
;;; you type P-P commands at ConEd, the same way you can do m-X Execute
;;; CP Command without having to Select L first.
;;;
;;; The main bug with this is that when this runs, dw:*program* is Concordia
;;; and not Page-Previewer.

(zwei:defcom (3 0 (NIL 0) (NIL :BOLD :SMALL) "TVFONTCB")com-execute-wt-command2 "Execute WT command" ()
  (multiple-value-bind (program program-frame program-process)
      (find-containing-concordia)
    (ignore program-process)
    (when (null program) (zwei:barf "Not within Concordia context"))
    (let ((cmd
	    (let ((dw:*program* program)
		  (dw:*program-frame* program-frame))
	      (zwei:typein-line-accept `((cp:command :command-table page-previewer))
				       :prompt "Enter a WT command"))))
      (apply #'apply-in-concordia #'zwei:barf cmd)))
  zwei:dis-none)
0||#

(zwei:defcom 1com-wt-change-configuration0 "Change Select-W frame configuration" ()
  (apply-in-concordia #'zwei:barf 'com-change-configuration)
  zwei:dis-none)

zwei:
(define-presentation-to-editor-command-translator 1zmacs-concordia-command
0  (dw::command-menu-item "Concordia Command" *zmacs-comtab*
			 :gesture :select)
  (object &key presentation)
  (dw::with-presentation-type-arguments (dw::command-menu-item
					  (dw:presentation-type presentation))
    (and dw::command-table
	 (string-equal (cp::command-table-name dw::command-table) 'concordia)
	 `(apply-in-concordia
	    false
	    ,(named-lambda execute-command (cmd-name)
	       ;; This nonsense is because cp:execute-command
	       ;; does a fresh-line which sometimes needs
	       ;; a background window
	       (let ((cmd (cp:build-command cmd-name)))
		 (apply (car cmd) (cdr cmd))))
	    ,object))))

;; This is run in the context of the zmacs process, to find
;; the preview-program of the frame containing zmacs-frame
(defun 1find-containing-concordia0 ()
  (declare (values program program-frame program-process))
  (let* ((zmacs-frame (and (variable-boundp zwei:*window*)
			   zwei:*window*
			   (zwei:window-frame zwei:*window*)))
	 (program-frame (and zmacs-frame (send zmacs-frame :superior))))
    (and (typep program-frame 'dw:program-frame)
	 (let ((program (send program-frame :program)))
	   (and (typep program 'concordia)
		(values program program-frame (send program-frame :process)))))))

(defun 1apply-in-concordia0 (if-not-within-program function &rest args)
  (multiple-value-bind (program program-frame program-process)
      (find-containing-concordia)
    (ignore program program-frame)
    (if (eql program-process *current-process*)
	(apply function args)
	(if if-not-within-program
	    (funcall if-not-within-program "Not within Concordia context")
	    (cerror "return NIL"
		    "Not within Concordia context")))))

;; No doubt there already exists the right presentation type, but I
;; can't find any tool to tell me what it is.
(define-presentation-type 1editor-command0 ()
   :expander T
   :printer ((command stream)
	     (destructuring-bind (command-symbol numeric-arg) command
	       (when numeric-arg
		 (cond ((eq numeric-arg :control-u)
			(write-string "c-U " stream))
		       ((numberp numeric-arg)
			(format stream "c-~D " numeric-arg))))
	       (write-string (make-command-name command-symbol) stream))))

(zwei:define-presentation-to-editor-command-translator 1editor-command
0  (editor-command " " *wt-comtab*
		  :gesture :select
		  :DOCUMENTATION ((COMMAND)
				  (destructuring-bind (command-name ignore) command
				    (or (GET COMMAND-NAME 'zwei:DOCUMENTATION)
					(GET COMMAND-NAME 'zwei:COMMAND-NAME))))
		  :tester ((command-name)
			   (fdefinedp (first command-name)))
		  )
  (command)
  `(do-zwei-command ,command))

(zwei:define-presentation-to-editor-command-translator 1zmacs-wt-editor-command
0  (editor-command " " zwei:*zmacs-comtab*
		  :gesture :select
		  :documentation ((command)
				  (destructuring-bind (command-name ignore) command
				    (or (get command-name 'zwei:documentation)
					(get command-name 'zwei:command-name))))
		  :tester ((command) 
			   (destructuring-bind (command-name ignore) command
			     (and (fdefinedp command-name)
				  (or (zwei:key-for-command command-name)
				      (zwei:extended-command-p command-name)))))
		  )
  (command)
  `(do-zwei-command ,command))

(defun 1do-zwei-command0 (command)
  (destructuring-bind (command-name numeric-arg) command
    (flet ((do-it ()
	     (let-if (numberp numeric-arg)
		     ((zwei:*numeric-arg* numeric-arg)
		      (zwei:*numeric-arg-p* t))
	       (let-if (eq numeric-arg :control-u)
		       ((zwei:*numeric-arg* 4)
			(zwei:*numeric-arg-p* :control-u))
		 (funcall command-name)))))
      (multiple-value-call #'zwei:must-redisplay zwei:*window* (do-it)))))

(defun 1editor-accelerator-name-for-command0 (command-symbol &optional numeric-arg)
  (let ((string (and command-symbol
		     (or (zwei:key-for-command command-symbol *wt-comtab*)
			 (and (zwei:extended-command-p command-symbol *wt-comtab*)
			      ""))))
	(prefix-string (and numeric-arg
			    (cond ((eq numeric-arg :control-u) "c-U ")
				  ((numberp numeric-arg)
				   (format nil "c-~D " numeric-arg))
				  (t (error "Unknown numeric arg ~s" numeric-arg)))))
	(cruft '(("Control-V" "Scroll")
		 ("Meta-V" "m-Scroll")
		 ("Control" "c")
		 ("Meta" "m")
		 ("Super" "s")
		 ("Hyper" "h")
		 ("Shift" "sh")
		 ("Less-sign" "<")
		 ("Greater-sign" ">")
		 ("Open" "(")
		 ("Close" ")"))))
    (cond ((null string) nil)
	  (T
	   (sys:with-stack-array (temp (* 2 (length string))
				       :element-type 'character
				       :fill-pointer (length string))
	     (replace temp string)
	     (flet ((attempt-replacement (replacement)
		      (destructuring-bind (bad-form good-form) replacement
			;; Fixed in SNOBOL
			(let ((where (search bad-form temp :test #'char-equal)))
			  (when where
			    (let ((good-length (length good-form))
				  (bad-length (length bad-form)))
			      (when (> good-length bad-length)
				(incf (fill-pointer temp) (- good-length bad-length)))
			      (replace temp temp
				       :start1 (+ where good-length)
				       :start2 (+ where bad-length))
			      (replace temp good-form :start1 where)
			      (when (< good-length bad-length)
				(decf (fill-pointer temp)
				      (- bad-length good-length)))
			      T))))))
	       (loop while (some #'attempt-replacement cruft)))
	     (if prefix-string
		 (string-append prefix-string (copy-string temp))
		 (copy-string temp)))))))

(defun 1postponably-prepare-editor-menu-commands0 ()
  (if (zerop si:*inhibit-lengthy-background-updates*)
      (setq *prepared-editor-menu-commands* (prepare-editor-menu-commands))
      (setq *prepared-editor-menu-commands* nil)))

(defun 1prepare-editor-menu-commands-if-necessary0 ()
  (unless *prepared-editor-menu-commands*
    (setq *prepared-editor-menu-commands* (prepare-editor-menu-commands))))

(si:define-postponed-lengthy-background-update
  (prepare-editor-menu-commands-if-necessary))

(defun 1prepare-editor-menu-commands0 ()
  (flet ((cdr-coded-mapcar-noting-progress (note function list)
	   (let ((stuff ()))
	     (tv:dolist-noting-progress (item list note)
	       (push (funcall function item) stuff))
	     (replace (make-list (length stuff)) (nreverse stuff)))))
    (cdr-coded-mapcar-noting-progress
      "Preparing editor commands"
      (named-lambda by-group (stuff)
	(destructuring-bind (head &rest commands) stuff
	  (cons head
		(mapcar (named-lambda by-command (command)
			  (multiple-value-bind (string command-symbol numeric-arg)
			      (typecase command
				((cons)
				 (values (first command) (second command) (third command)))
				((symbol)
				 (values (make-command-name command) command nil))
				((string)
				 (values command nil nil)))
			    (let ((accelerator-string
				    (editor-accelerator-name-for-command
				      command-symbol numeric-arg)))
			      (list command-symbol string accelerator-string numeric-arg))))
			commands))))
      (append *editor-menu-commands*
	      (and *debugging-sage* *editor-menu-debugging-commands*)))))

(add-initialization "Prepare editor command menu"
		    '(setq *prepared-editor-menu-commands* (prepare-editor-menu-commands))
		    ()
		    '*nwt-initializations*)

(defun 1recompute-category-data0 ()
  (mapcar (lambda (x) (list (first x) nil))
	  *prepared-editor-menu-commands*))

(defvar 1*category-data*0 ())

(defvar 1*category-alteration-tick*0 0)

(define-presentation-type 1editor-menu-category-head0 ()
      :expander T)

(zwei:define-presentation-to-editor-command-translator 1operate-on-all-categories
0   (editor-menu-category-head "Operate on" *wt-comtab*
			      :gesture :select
			      :tester ((category) (eq category 'all-categories))
			      :documentation "Operate on all command categories (menu)")
   (category &key window)
  `(operate-on-all-categories ,window))

(defun 1operate-on-all-categories0 (window)
  (flet ((altered (&optional really-hard)
	   (incf *category-alteration-tick*)
	   (send dw:*program-frame* :redisplay-pane window really-hard)))
    (let ((which (dw:menu-choose
		   (macrolet ((preprocess (&rest list)
				`',(loop for (symbol documentation) in list
					 collect `(,(string-capitalize-words symbol)
						   :value ,symbol
						   :documentation ,documentation))))
		     (preprocess
		       (:hide-all "Hide commands in all categories")
		       (:show-all "Show commands in all categories")
		       (:reorder "Use menu to reorder categories in the menu")
		       (:reset-to-default "Reset menu contents to system default")
		       (:save-set
			 "Save menu layout on kill history, to yank into your init file")
		       (:redisplay "Redisplay the command menu (in case of display confusion)")
		       ))
		   :prompt "What to do to all command categories?")))
      (ecase which
	((nil) )
	(:hide-all
	  (dolist (pair *category-data*)
	    (setf (second pair) nil))
	  (altered T))
	(:show-all
	  (dolist (pair *category-data*)
	    (setf (second pair) T))
	  (altered T))
	(:reorder
	  (let ((new-order (reorder-sequence:reorder-sequence-via-menu
			     *category-data*
			     :printer (lambda (item stream)
					(write-string (first item) stream))
			     :prompt "Reorder categories")))
	    (setq *category-data* new-order)
	    (altered)))
	(:reset-to-default
	  (setq *category-data* (recompute-category-data))
	  (altered))
	(:save-set
	  (let ((interval (zwei:create-interval
			    nil nil (make-instance 'zwei:kill-ring-interval))))
	    (with-open-stream (out (zwei:interval-stream-into-bp
				     (zwei:interval-last-bp interval)))
	      (with-standard-io-environment 
		(let ((*print-pretty* T))
		  (format out "~s~%" `(setup-editor-menu ',*category-data*)))))
	    (send zwei:*kill-history* :push interval)))
	(:redisplay
	  (let ((frame (send window :superior)))
	    (if (typep frame 'dw:program-frame)
		(send frame :redisplay-pane window T)
		(zwei:barf "The window superior isn't a ~s (internal error)"
			   'dw:program-frame))))
	))))

(defun 1setup-editor-menu0 (data)
  (setq *category-data* data)
  (incf *category-alteration-tick*)
  ;; Attempt to cause the menu pane to be redisplayed
  (map-resource 'dw:program-frame
		(lambda (window &rest ignore)
		  (let ((program (send window :program)))
		    (when (eq (dw:program-name program) 'concordia)
		      ;; ---This doesn't make anything happen
		      (setf (concordia-force-redisplay program) T))))))

(zwei:define-presentation-to-editor-command-translator 1show/hide-command-category
0   (editor-menu-category-head "Show/Hide" *wt-comtab*
			      :gesture :select
			      :tester ((category) (neq category 'all-categories))
			      :documentation "Show/Hide this command category")
   (category &key window)
  `(show/hide-command-category ,category ,window))

(defun 1show/hide-command-category0 (category window)
  (let ((pair (assoc category *category-data* :test #'string=)))
    (cond ((null pair)
	   (cerror "Forget it"
		   "Failed to find command category ~s in ~s"
		   category '*category-data*))
	  (T (setf (second pair) (not (second pair)))
	     (incf *category-alteration-tick*))))
  (send dw:*program-frame* :redisplay-pane window))

(zwei:defcom com-insert-concordia-menu-choices
	     "Inserts a form into the editor buffer that, when evaluated will determine which menu catagories in the Concordia help menu are expanded"
	     ()
  (let ((max-category-length (loop for item in *category-data*
				   maximize (length (car item)))))
    (dw:accepting-values (t :own-window t
			    :label "Display Menu Categories")
      (loop for item in *category-data* do
	(setf (cadr item)
	      (accept 'boolean :default (cadr item)
		      :prompt (format nil "~V@A"
				      max-category-length
				      (car item)))))))
  (let ((point (zwei:point)))
    (zwei:with-undo-save-simple (point point)
      (zwei:insert-moving point
			  (format nil "(setq sage::*category-data*~%      '~A)"
				  *category-data*))))
  zwei:dis-text)

(zwei:define-presentation-to-editor-command-translator pop-up-category-menu
   (editor-menu-category-head "Menu" *wt-comtab*
			      :gesture :menu
			      :tester ((category) (neq category 'all-categories))
			      :documentation ((category)
					      (format nil "Menu of ~A commands" category)))
   (category)
  `(pop-up-category-menu ,category)) 

(defun pop-up-category-menu (category)
  (let ((command
	  (second
	    (dw:menu-choose-from-drawer
	      #'(lambda (stream &rest ignore)
		  (loop for (command-symbol command-string nil numeric-arg)
			    in (cdr (assoc category *prepared-editor-menu-commands*
					   :test #'string=))
			collect
			  (dw:with-output-as-presentation
			      (:stream stream
			       :object `(,command-symbol ,numeric-arg)
			       :type 'editor-command)
			    (write-string command-string stream))
			do
		    (send stream :tyo #\return)))
	      'zwei:presentation-command
	      :prompt (with-output-to-string (stream)
			(with-character-style ('(:jess :bold :large) stream)
			  (format stream "~A Command" category)))))))
    (when command
      (apply (car command) (cdr command))))) 

(defun 1redisplay-editor-menu0 (program stream)
  (ignore program)
  (when (null *prepared-editor-menu-commands*)
    (setq *prepared-editor-menu-commands* (prepare-editor-menu-commands)))
  (when (null *category-data*)
    (setq *category-data* (recompute-category-data)))
  (dw:with-redisplayable-output (:stream stream
				 :unique-id 'redisplay-editor-menu
				 :cache-value *category-alteration-tick*)
    (dw:with-redisplayable-output (:stream stream
				   :unique-id 'header :cache-value T)
      (with-character-style ('(nil :bold :large) stream :bind-line-height T)
	(dw:with-output-as-presentation (:stream stream
					 :object 'all-categories
					 :type 'editor-menu-category-head)
	  (write-string "Editor commands" stream))
	(terpri stream)))
    (let* ((pane-width (send stream :inside-width))
	   (char-width (send stream :char-width))
	   (item-indentation "   "))
      (labels ((heading (string stream)
		 (with-character-face (:bold stream)
		   (dw:with-output-as-presentation (:stream stream
						    :object string
						    :type 'editor-menu-category-head)
		     (write-char #\space stream)
		     (write-string string stream)))
		 (terpri stream))
	       (show-item (command stream)
		 (destructuring-bind (command-symbol command-string
						     accelerator-string numeric-arg)
		     command
		   (flet ((do-it (stream bogus)
			    ;; using write-string of spaces instead of increment-cursorpos
			    ;; makes the mouse target wider
			    (write-string item-indentation stream)
			    (write-string command-string stream)
			    (flet ((right-string (string stream)
				     (let* ((string-wid
					      (send stream :string-length string))
					    (x (send stream :read-cursorpos))
					    (pos (- pane-width string-wid))
					    (extra (max char-width (- pos x))))
				       (send stream :increment-cursorpos extra 0)
				       (write-string string stream))))
			      (cond (bogus
				     (with-character-style ('(:swiss :roman :very-small)
							    stream)
				       (right-string "nyi" stream)))
				    (accelerator-string
				     (right-string accelerator-string stream))))))
		     (if (null command-symbol)
			 (do-it stream :bogus)
			 (dw:with-output-as-presentation (:stream stream
							  :object `(,command-symbol
								    ,numeric-arg)
							  :type 'editor-command
							  :single-box T)
			   (do-it stream ())))
		     (terpri stream)))))
	(dolist (category-item *category-data*)
	  (destructuring-bind (head expanded) category-item
	    (dw:with-redisplayable-output (:stream stream
					   :cache-value expanded
					   :unique-id category-item)
	      (dw:with-redisplayable-output (:stream stream :cache-value T :unique-id head)
		(heading head stream))
	      (when expanded
		(let ((commands (assoc head *prepared-editor-menu-commands* :test #'string=)))
		  (dolist (command (rest commands))
		    (dw:with-redisplayable-output (:stream stream
						   :cache-value command)
		      (show-item command stream)))))))))))) 


;; If I were paranoid, I'd try to lock this against multiple processes
(defun 1collect-reference0 (record-group)
  (setf (collected-references-list *collected-references*)
	(nconc (delete record-group (collected-references-list *collected-references*))
	       (ncons record-group)))
  (incf (collected-references-tick *collected-references*))
  (setf (collected-references-recently-added *collected-references*)
	record-group))

(defun 1uncollect-reference0 (record-group)
  (setf (collected-references-list *collected-references*)
	(delete record-group (collected-references-list *collected-references*)))
  ;; Leave the recently-added alone, I suppose
  (incf (collected-references-tick *collected-references*)))

(defun 1clear-collected-references0 ()
  (setf (collected-references-list *collected-references*) ())
  (setf (collected-references-recently-added *collected-references*) ())
  (incf (collected-references-tick *collected-references*)))

(defun 1redisplay-references-pane0 (program pane)
  (ignore program)
  (when (null pane)				; Interface from Zmacs, to find it here
    (setq pane (send dw:*program-frame* :get-pane 'references-pane)))
  (let ((presentation-for-recently-added-reference (list nil))
	(recently-added-reference
	  (collected-references-recently-added *collected-references*))
	(stream pane))
    (dw:with-redisplayable-output (:stream stream
				   :unique-id *collected-references*
				   :cache-value (collected-references-tick
						  *collected-references*))
      (dw:formatting-table (stream)
	(dolist (record-group (collected-references-list *collected-references*))
	  (dw:with-redisplayable-output (:stream stream
					 :unique-id record-group
					 :cache-value (record-group-topic-completion record-group))
	    (dw:formatting-row (stream)
	      (dw:formatting-cell (stream)
		(let ((presentation (present record-group 'record-group :stream stream)))
		  (when (eql record-group recently-added-reference)
		    (setf (first presentation-for-recently-added-reference)
			  presentation)))))))))))

(defun 1cause-redisplay-of-references-pane0 ()
  (when (variable-boundp dw:*program*)
    ;; don't blow out if in a lisp listener or something
    (let ((pane (dw:get-program-pane 'references-pane :if-does-not-exist nil)))
      (cond ((null pane) nil)			;--- If someone changes the name of the
						; references pane this clause will
						; screw them.
	    ((null (collected-references-list *collected-references*))
	     (send pane :clear-history)
	     (send dw:*program-frame* :redisplay-pane pane))
	    (T (send dw:*program-frame* :redisplay-pane pane)
	       (let ((recently-added-reference
		       (collected-references-recently-added *collected-references*)))
		 ;; scroll the pane to make sure the recently-added-presentation is visible
		 (when recently-added-reference
		   (let* ((recently-added-presentation
			    (block found
			      (labels ((check-infs (displayed-presentation)
					 (if (eql (dw:presentation-object
						    displayed-presentation)
						  recently-added-reference)
					     (return-from found displayed-presentation)
					     (map () #'check-infs (dw:presentation-inferiors 
								    displayed-presentation)))))
				(map () #'check-infs (send pane :displayed-presentations)))))
			  (pres-box (and recently-added-presentation
					 (dw:presentation-displayed-box
					   recently-added-presentation)))
			  (viewport-box (send-if-handles pane :cursor-viewport)))
		     (cond ((null pres-box)	;just cleared?
			    )
			   ((null viewport-box )	;redisplay-helper-stream?
			    )
			   ((< (dw:box-top pres-box) (dw:box-top viewport-box))
			    ;; pres off the top
			    (send pane :set-viewport-position 0 (dw:box-top viewport-box)))
			   ((> (dw:box-bottom pres-box) (dw:box-bottom viewport-box))
			    ;; pres off the bottom?
			    (send pane :set-viewport-position
				  0 (- (dw::box-bottom pres-box)
				       (dw::box-height viewport-box)))))))))))))
