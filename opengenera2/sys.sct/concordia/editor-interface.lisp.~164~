;;; -*- Base: 10; Mode: LISP; Package: NSAGE; Syntax: Common-lisp; -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; This isn't the interface from NSage to Zwei, it is the Zwei-based
;;; writer's user interface.

(defmacroD,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB") zwei:with-typeout-window-state0 (&body body)
  `(let ((.typeout-window-exposed-p. (send zwei:*typeout-window* :exposed-p)))
     (multiple-value-prog1
       (progn ,@body)
       (unless (and .typeout-window-exposed-p.
		    (send zwei:*typeout-window* :exposed-p))
	 (zwei:prepare-window-for-redisplay zwei:*window*)))))

;;; Markup commands

(defun 1edge-of-paragraph0 (bp direction alternate-bp)
  (let ((node (zwei:bp-node bp)))
    (etypecase node
      (zwei:markup-structure-text-node
	(let ((new-bp (zwei:forward-paragraph bp direction t)))
	  (if (eql (zwei:bp-node new-bp) node)
	      new-bp
	      alternate-bp)))
      (zwei:delimited-markup-structure-node
	alternate-bp))))

(defun 1wt-beginning-of-paragraph0 (bp)
  (edge-of-paragraph bp -1 (zwei:node-first-bp (zwei:bp-node bp))))

(defun 1wt-end-of-paragraph0 (bp)
  (edge-of-paragraph bp 1 (zwei:node-last-bp (zwei:bp-node bp))))

(zwei:defcom 1com-wt-fill-paragraph
0	     "Fill the current paragraph (delimited by markup)"
	     ()
  (wt-fill-paragraph (zwei:point))
  zwei:dis-text)

(defun 1wt-fill-paragraph0 (bp)
  (unless (typep (zwei:bp-node bp) 'zwei:markup-structure-text-node)
    (zwei:barf "Can't fill across markup boundaries."))
  (let ((start-bp (wt-beginning-of-paragraph bp))
	(end-bp (wt-end-of-paragraph bp))
	(added-returns-needed-by-fill-interval nil))
    (unless (zerop (zwei:bp-index end-bp))
      (zwei:mung-bp-interval end-bp)
      (let ((zwei:*enable-change-recording* nil))
	;; Insert two returns in case end-bp is just before markup with run-in markers
	;; set.  If just one return is inserted, all that happens is run-in marker is
	;; removed and no real paragraph break is created for fill-interval.
	(zwei:insert-moving end-bp #.(scl:coerce '(#\return #\return) 'scl:string)))
      (setq added-returns-needed-by-fill-interval t))
    (zwei:fill-interval start-bp end-bp t)
    (when added-returns-needed-by-fill-interval
      (let ((zwei:*enable-change-recording* nil))
	(zwei:delete-interval (zwei:forward-char end-bp -1) (zwei:forward-char end-bp) t)))))

#+ignore
;;; This doesn't work, since it sometimes advances LINE past END-LINE while
;;; walking over nodes.  Also, it fills entire paragraphs, even if you only
;;; marked some of the lines.
(zwei:defcom 1com-wt-fill-region
0	     "Fill each paragraph in the region (delimited by markup)"
	     ()
  (zwei:region-lines (start-line end-line)
    (loop for line = start-line then (zwei:line-next-in-buffer line)
	  for line-node = (zwei:line-node line)
	  until (eql line end-line)
	  do
      (when (typep (zwei:line-node line) 'zwei:markup-structure-text-node)
	(wt-fill-paragraph (zwei:create-bp line 0)))
      (setq line (zwei:line-next-in-buffer (zwei:bp-line (zwei:node-last-bp line-node)))))
    #+ignore
    (loop for line = start-line then (zwei:line-next-in-buffer line)
	  with start-bp = (zwei:create-bp line 0)
	  until (eql line (zwei:bp-line (zwei:node-last-bp (zwei:line-node line))))
	  do (cond ((eql line (zwei:bp-line (zwei:node-first-bp (zwei:line-node line))))
		    (setq start-bp (zwei:node-first-bp (zwei:line-node line))))
		   ((eql line (zwei:bp-line (zwei:node-last-bp (zwei:line-node line))))
		    (when start-bp
		      (zwei:fill-interval start-bp (zwei:node-last-bp (zwei:line-node line)))
		      (setq start-bp nil))))
	  finally (when start-bp
		    (zwei:fill-interval start-bp (zwei:create-bp line 0))))
    )
  zwei:dis-text)

(zwei:defcom 1com-wt-forward-environment0 "Move forward over an environment" (zwei:km)
  (zwei:move-point (forward-environment (zwei:point) zwei:*numeric-arg*))
  zwei:dis-bps)

(zwei:defcom 1com-wt-backward-environment0 "Move backward over an environment" (zwei:km)
  (zwei:move-point (forward-environment (zwei:point) (- zwei:*numeric-arg*)))
  zwei:dis-bps)

(defun 1forward-environment0 (bp &optional (times 1))
  (cond ((> times 0)
	 (loop repeat times do
	   (let ((node (zwei:bp-node bp)))
	     (unless (typep node 'zwei:markup-structure-node) (zwei:barf))
	     (let ((node-last-bp (zwei:node-last-bp node)))
	       (setq bp (if (not (zwei:bp-= bp node-last-bp))
			    node-last-bp
			    (zwei:node-last-bp 
			      (or (zwei:node-next node)
				  (zwei:node-superior node)))))))))
	((< times 0)
	 (setq times (- times))
	 (loop repeat times do
	   (let ((node (zwei:bp-node bp)))
	     (unless (typep node 'zwei:markup-structure-node) (zwei:barf))
	     (let ((node-first-bp (zwei:node-first-bp node)))
	       (setq bp (if (not (zwei:bp-= bp node-first-bp))
			    node-first-bp
			    (zwei:node-first-bp
			      (or (zwei:node-previous node)
				  (zwei:node-superior node))))))))))
  bp)

(zwei:defcom 1com-wt-beginning-of-environment
0	     "Move to beginning of containing environment." (zwei:km)
  (move-out-environment #'zwei:node-first-bp))

(zwei:defcom 1com-wt-end-of-environment0 "Move to end of containing environment." (zwei:km)
  (move-out-environment #'zwei:node-last-bp))

(defun 1move-out-environment0 (get-end)
  (let* ((point (zwei:point))
	 (node (zwei:bp-node point))
	 (containing-node (and node (zwei:node-superior node))))
    (cond ((null node) (zwei:barf))
	  ((not (typep node 'zwei:markup-structure-node)) (zwei:barf))
	  ;;---Perhaps it shouldn't stop the first time at the beginning of
	  ;; a lowest-level text node
	  ((not (zwei:bp-= point (funcall get-end node)))
	   (zwei:move-point (funcall get-end node)))
	  ((not (typep containing-node 'zwei:markup-structure-node)) (zwei:barf))
	  (T
	   (zwei:move-point (funcall get-end containing-node)))))
  zwei:dis-bps)

(defvar 1*environment-name-aarray-cache*0 ())

(defun 1find-environment-name-aarray0 (&key internal-too)
  (unless (eql (first *environment-name-aarray-cache*)
	       *directive-definition-tick*)
    (setq *environment-name-aarray-cache*
	  (list *directive-definition-tick*
		(make-environment-name-aarray)
		(make-environment-name-aarray
		  :internal-too t))))
  (if internal-too
      (third *environment-name-aarray-cache*)
      (second *environment-name-aarray-cache*)))

(defun 1make-environment-name-aarray0 (&key internal-too)
  (using-resource (arr arrays-with-fill-pointer)
    (loop for entry being hash-elements of *formatter-directives*
	  for dd = (find-dd entry 'symanual)
	  when (eq (dd-parse-type dd) :environment)
	    do 
	      (let ((symbol (dd-symbol dd)))
		(when (or (eq (directive-internal-p symbol) internal-too)
			  (not (directive-internal-p symbol)))
		  (let ((pretty-name (directive-pretty-name symbol)))
		    (vector-push-extend (list pretty-name dd) arr)))))
    (let ((aarray (si:make-aarray (fill-pointer arr))))
      (loop for entry being the array-elements of arr do
	(si:aarray-insert aarray (first entry) (second entry)))
      ;; This is cheap now that the aarray is paged in.
      (si:sort-aarray aarray)
      aarray)))

(define-presentation-type 1sage-environment-name0 ((&key internal-too))
   :history t
   :parser ((stream &key type initially-display-possibilities)
	    (multiple-value-bind (ignore ignore result)
	      (dw::complete-input-from-aarray (find-environment-name-aarray
						:internal-too internal-too)
					      stream
					      :allow-any-input ()
					      :initially-display-possibilities
					        initially-display-possibilities
					      :compress-choices nil
					      :type type
					      :partial-completers '(#\Space))
	      result))
   :describer ((stream &key plural-count)
	       (dw::presentation-string-pluralize
		 (format nil "an environment name")
		 stream plural-count))
   :printer ((object stream)
	     (let ((symbol
		     (if (typep object 'directive-descriptor)
			 (dd-symbol object)
			 object)))
	       (write-string (directive-pretty-name symbol) stream)))
   )

(defvar 1*command-name-aarray-cache*0 ())

(defun 1find-command-name-aarray0 (&key internal-too)
  (unless (eql (first *command-name-aarray-cache*)
	   *directive-definition-tick*)
    (setq *command-name-aarray-cache*
	  (list *directive-definition-tick*
		(make-command-name-aarray)
		(make-command-name-aarray :internal-too t))))
  (if internal-too
      (third *command-name-aarray-cache*)
      (second *command-name-aarray-cache*)))

(defun 1make-command-name-aarray0 (&key internal-too)
  (let ((aarray (si:make-aarray (cl:hash-table-count *formatter-commands*))))
    (loop for dd being hash-elements of *formatter-commands* do 
      (let ((symbol (dd-definition dd)))
	(when (or (eq (directive-internal-p symbol) internal-too)
		  (not (directive-internal-p symbol)))
	  (let ((pretty-name (directive-pretty-name symbol)))
	    (si:aarray-insert aarray pretty-name dd)))))
    ;; This is cheap now that the aarray is all paged in.
    (si:sort-aarray aarray)
    aarray))

(define-presentation-type 1sage-command-name0 ((&key internal-too))
   :history t
   :parser ((stream &key type initially-display-possibilities)
	    (multiple-value-bind (ignore ignore result)
	      (dw::complete-input-from-aarray (find-command-name-aarray
						:internal-too internal-too)
					      stream
					      :allow-any-input ()
					      :initially-display-possibilities
					        initially-display-possibilities
					      :compress-choices nil
					      :type type
					      :partial-completers '(#\Space))
	      result))
   :describer ((stream &key plural-count)
	       (dw::presentation-string-pluralize
		 (format nil "a~@[n (internal)~] command name" internal-too)
		 stream plural-count))
   :printer ((object stream)
	     (let ((symbol (if (typep object 'directive-descriptor)
			       (dd-definition object)
			       object)))
	       (write-string (directive-pretty-name symbol) stream))))

;;; ((2 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")tick external internal-too0)
(defvar 1*markup-name-aarray-cache*0 ())

(defun 1find-markup-name-aarray0 (&key internal-too)
  (unless (eql (first *markup-name-aarray-cache*)
	   *directive-definition-tick*)
    (setq *markup-name-aarray-cache*
	  (list *directive-definition-tick*
		(make-markup-name-aarray)
		(make-markup-name-aarray :internal-too t))))
  (if internal-too (third *markup-name-aarray-cache*) (second *markup-name-aarray-cache*)))

(defun 1make-markup-name-aarray0 (&key internal-too)
  (using-resource (arr arrays-with-fill-pointer)
    (loop for entry being hash-elements of *formatter-directives*
	  for dd = (find-dd entry 'symanual)  ;; why does this hardwire SYMANUAL?
	  when (eq (dd-parse-type dd) :environment)
	    do 
	      (let ((symbol (dd-symbol dd)))
		(when (or (eq (directive-internal-p symbol) internal-too)
			  (not (directive-internal-p symbol)))
		  (let ((pretty-name (directive-pretty-name symbol)))
		    (vector-push-extend (list pretty-name dd) arr)))))
    (let ((aarray (si:make-aarray (+ (fill-pointer arr)
				     (cl:hash-table-count *formatter-commands*)))))
      (loop for entry being the array-elements of arr do
	(si:aarray-insert aarray (first entry) (second entry)))
      (loop for dd being hash-elements of *formatter-commands* do 
	(let ((symbol (dd-definition dd)))
	  (when (or (eq (directive-internal-p symbol) internal-too)
		    (not (directive-internal-p symbol)))
	    (let ((pretty-name (directive-pretty-name symbol)))
	      (si:aarray-insert aarray pretty-name dd)))))
      ;; This is cheap now that the aarray is paged in.
      (si:sort-aarray aarray)
      aarray)))

(define-presentation-type 1sage-markup0 ((&key internal-too))
   :history t
   :expander '((or sage-environment-name sage-command-name))
   :parser ((stream &key type initially-display-possibilities)
	    (multiple-value-bind (ignore ignore result)
	      (dw::complete-input-from-aarray (find-markup-name-aarray
						:internal-too internal-too)
					      stream
					      :allow-any-input ()
					      :initially-display-possibilities
					        initially-display-possibilities
					      :compress-choices nil
					      :type type
					      :partial-completers '(#\Space))
	      result))
   :describer ((stream &key plural-count)
	       (dw::presentation-string-pluralize
		 (format nil "a~@[n (internal)~] markup name" internal-too)
		 stream plural-count))
   :printer ((object stream)
	     (dw:with-output-as-presentation (:allow-sensitive-inferiors nil
					      :stream stream)
	       (let ((symbol
		       (if (typep object 'directive-descriptor)
			   ;; use dd-symbol unconditionally here, even though commands
			   ;; normally print with dd-definition
			   (dd-symbol object)
			   object)))
		 (write-string (directive-pretty-name symbol) stream))))
	     )

(define-presentation-type 1sage-markup-name0 ((&key internal-too))
   :history t
   :parser ((stream &key type initially-display-possibilities)
	    (multiple-value-bind (ignore ignore result)
	      (dw::complete-input-from-aarray (find-markup-name-aarray
						:internal-too internal-too)
					      stream
					      :allow-any-input ()
					      :initially-display-possibilities
					        initially-display-possibilities
					      :compress-choices nil
					      :type type
					      :partial-completers '(#\Space))
	      (dd-symbol result)))
   :describer ((stream &key plural-count)
	       (dw::presentation-string-pluralize
		 (format nil "a~@[n (internal)~] markup name" internal-too)
		 stream plural-count))
   :printer ((object stream)
	     (let ((symbol
		     (if (typep object 'directive-descriptor)
			 ;; use dd-symbol unconditionally here, even though commands
			 ;; normally print with dd-definition
			 (dd-symbol object)
			 object)))
	       (write-string (directive-pretty-name symbol) stream))))

(zwei:defcom 1com-wt-create-environment0 "Add a new environment here
Use the region if there is one." ()
  (zwei:assure-inside-record
    () "The cursor must be inside a record before an environment can be created.")
  (let* ((internal-too zwei:*numeric-arg-p*)
	 (envr-name (zwei:typein-line-accept
		      `((sage-environment-name :internal-too ,internal-too))
		      :prompt (format nil "~@[(Internal) ~]Environment name" internal-too))))
    (splice-environment-at-point-or-region envr-name :assure-inside-record nil))
  zwei:dis-text)

;; If the environment is one which the editor presents with character style,
;; it has to turn into a character style command:
;;   If there's a region, it acts like c-X c-J
;;   If there's no region, it acts like c-m-J.
(defun 1splice-environment-at-point-or-region0 (envr-dd &key (assure-inside-record t))
  (when assure-inside-record (zwei:assure-inside-record))
  (let ((envr-name (dd-symbol envr-dd)))
    (let ((attempted-face-code (second (assoc (if (eq envr-name 'LS) 'L envr-name)
					      *face-code-alist*))))
      (cond (attempted-face-code
	     (let ((new-style (si:intern-character-style nil attempted-face-code nil)))
	       (cond ((zwei:window-region-p)
		      (zwei:region (bp1 bp2 :empty-ok T)
			(zwei:change-style-interval bp1 bp2 T new-style)))
		     (T (setq zwei:*style* (si:style-index new-style t))
			(setf (zwei:buffer-typein-character-style zwei:*interval*) new-style)
			(zwei:update-style-name)
			(zwei:typein-line "Typein character style changed ")))))
	    (T (splice-sage-structure-at-point
		 'sage-envr :envr-name envr-name
		 ;; Because we're getting make-instance instead of
		 ;; make-sage-envr, these aren't yet filled in.
		 :envr-mods () :contents-list ())
	       (zwei:move-point (zwei:forward-char (zwei:point) -1)))))))

(zwei:defcom 1com-wt-create-command0 "Add a new formatter command here" ()
  (zwei:assure-inside-record
    () "The cursor must be inside a record before a command can be created.")
  (let* ((internal-too zwei:*numeric-arg-p*)
	 (command-name (zwei:typein-line-accept
			 `((sage-command-name :internal-too ,internal-too))
			 :prompt (format nil "~@[(Internal) ~]Command name" internal-too))))
    (splice-command-at-point-or-region command-name :assure-inside-record nil))
  zwei:dis-text)

(defun 1splice-command-at-point-or-region0 (command-dd &key (assure-inside-record t))
  (when assure-inside-record (zwei:assure-inside-record))
  (let ((command (make-sage-command (dd-definition command-dd)))
	(set-expanded-view? t))
    (setf (completely-unconnected command) t)
    (multiple-value-bind (min-pos max-pos non-pos pos keys any-keys list-of all)
	(sage-command-arglist-pattern command)
      (ignore min-pos max-pos non-pos)
      (cond ((and (not keys) (not any-keys) (not list-of) (not all)
		  (or (null pos)
		      (= (length pos) 1)))
	     (setq set-expanded-view? nil)
	     (unless (null pos)
	       ;; if there's only one pos arg, read it in the minibuffer
	       (setq set-expanded-view? nil)
	       (let ((pos-arg-stuff (first pos)))
		 (destructuring-bind (name type) pos-arg-stuff
		   (let ((arg-name (if (consp name) (first name) name))
			 (arg-default (when (consp name) (second name))))
		     (let ((value (zwei:typein-line-accept
				    (sage-typepresentation-type type)
				    :prompt (format nil "Value for ~:(~A~)"
						    arg-name)
				    :default arg-default)))
		       (setf (sage-command-parameter command) (ncons value))))))))
	    ((and all nil (eq (second all :contents-list))
		  (zwei:window-region-p zwei:*window*))
	     #+Ignore
	     (do-some-stuff)))
      ;; Get rid of the region
      (setf (zwei:window-mark-p zwei:*window*) nil)
      (let ((contents-list (enstyle-sage-command-text
			     command
			     () :edited t)))
	(cond ((every #'stringp contents-list)
	       (let ((point (zwei:point)))
		 (dolist (string contents-list)
		   (zwei:insert-moving point string))
		 (zwei:move-point point)))
	      (t
	       (zwei:temporarily-inserting-cr-if-necessary ((zwei:point))
		 (zwei:with-bp (past-point (zwei:forward-char (zwei:point) 1) :normal)
		   (let ((bps
			   (insert-sage-contents-list (zwei:point)
						      (upgrade-sage-contents-list-for-newthink
							contents-list :edited))))
		     (let ((node (zwei:bp-node (second bps))))	;gak!!
		       (when set-expanded-view?
			 (setf (zwei:markup-structure-node-node-view node) ':expanded))))
		   (zwei:move-point (zwei:forward-char past-point -1))))))))))

(zwei:defcom 1com-wt-create-markup0 "Add new formatter markup here" ()
  (zwei:assure-inside-record
    () "The cursor must be inside a record before markup can be inserted.")
  (let ((markup-dd (zwei:typein-line-accept
		     `((sage-markup :internal-too ,zwei:*numeric-arg-p*))
		     :prompt (format nil "~@[(Internal) ~]Markup name" zwei:*numeric-arg-p*))))
    (ecase (dd-parse-type markup-dd)
      (:environment
       (splice-environment-at-point-or-region markup-dd :assure-inside-record nil))
      (:command
       (splice-command-at-point-or-region markup-dd :assure-inside-record nil))))
  zwei:dis-text)

;;; A contents-only include reference (via the mouse-right menu)
(zwei:define-presentation-to-editor-command-translator 1create-internal-markup
0  (editor-command "Add new 2internal0 formatter markup here" *wt-comtab*
		  :gesture nil
		  :tester ((command) (eq (first command) 'com-wt-create-markup)))
  (ignore)
  (flet ((doit ()
	   (let ((zwei:*numeric-arg-p* ':control-u))
	     (com-wt-create-markup))))
    `(,#'doit)))

(define-presentation-type 1reference-type-or-all 0()	;Allows "All Views" as a view
   :abbreviation-for `((member ,@ (cons "All Views" *reference-views*))
		       :description "a view for a link or All Views"))

(defgeneric 1zwei:cached-title-p0 (thing)
  (:method (zwei:title-string-cached-title-mixin) t)
  (:method (zwei:editable-command-header-line) t)
  (:method (zwei:sage-command-arg-diagram-line) t)
  (:method (zwei:markup-line-diagram-mixin) nil))

;;; Generalized search function to find a thing of a given type.  We
;;; probably want to make this non-recursive some day.  In a simple
;;; test, I got it to run out of control stack, but only after over 750
;;; recursive calls to find1-0wt1-0buffer1-0thing.  That's a lot of s-S's.
;;; It's also more general than it has to be if the only command that
;;; uses the prompt-for-find-more option is find-markup-string.  We can
;;; simplify this once the final UI for the search commands is
;;; determined.

(defun 1find-wt-buffer-thing 0(thing type from-point forward-p &optional link-view
			     &key (including-point-line-p t) (display-typein-line-message t)
			     (prompt-for-find-more t))
  (unless (member type '(:string :link :markup))
    (zwei:barf "Illegal search type in find-wt-buffer-thing: ~a (Internal Error)" type))
  (loop with start-line = (zwei:bp-line from-point)
	for line = (if including-point-line-p
		       start-line
		       (if forward-p
			   (zwei:line-next-in-buffer start-line)
			   (zwei:line-previous-in-buffer start-line)))
		 then (if forward-p
			  (zwei:line-next-in-buffer line)
			  (zwei:line-previous-in-buffer line))
	with ld
	while line
	as line-node = (zwei:line-node line)
	as markup-structure = (when (typep line-node 'zwei:markup-structure-node)
				(markup-structure-node-markup-structure line-node))
	until (cond ((eql type :link)
		     (and markup-structure
			  (typep line-node 'zwei::reference-structure-node)
			  (eq (sage-reference-record-group markup-structure) thing)
			  (or (string-equal link-view "All Views")
			      (eql link-view (sage-reference-decode-view markup-structure)))))
		    ((eql type :markup)
		     (when (and markup-structure
				(typep line-node 'zwei:environment-structure-node))
		       (eql (dd-symbol thing) (send markup-structure :envr-name))))
		    (t
		     (and (setq ld (zwei:line-diagram line))
			  (zwei:cached-title-p ld)
			  (string-search thing (zwei:cached-title-string ld)))))
	finally (progn
		  (if (null line)
		      (cond ((eql type :link)
			     (zwei:typein-line "~:[~(~a~) ~;~*~]link to ~a was not found."
					       (string-equal link-view "All Views")
					       link-view thing (beep)))
			    ((eql type :markup)
			     (zwei:typein-line "~a markup environment was not found."
					       (string-capitalize (dd-symbol thing)) (beep)))
			    (t
			     (zwei:typein-line "~s was not found." thing (beep))))
		      (zwei:move-point line 0)
		      (zwei:must-redisplay zwei:*window* zwei:dis-bps)
		      (zwei:redisplay zwei:*window* :point))
		  (unless prompt-for-find-more
		    (return-from find-wt-buffer-thing nil))
		  (when display-typein-line-message
		    (zwei:typein-line "~&s-S: Search Forward, s-R: Search Backward, ~
                                       ” to exit~%"))
		  (multiple-value-bind (char nil)
		      (zwei:editor-input :scroll t :mouse :return
					 :any-tyi 'zwei:command)
		    (cond ((and (characterp char)
				(char-equal char #\s-s))
			   (find-wt-buffer-thing thing type (zwei:point) t link-view
						 :including-point-line-p nil
						 :display-typein-line-message nil))
			  ((and (characterp char)
				(char-equal char #\s-r))
			   (find-wt-buffer-thing thing type (zwei:point) nil link-view
						 :including-point-line-p nil
						 :display-typein-line-message nil))
			  (t (unless (and (characterp char)
					  (char-equal char #\end))
			       (setq zwei:*yanked-mini-buffer-command* char))
			     (zwei:typein-line "~3%")))))))

(zwei:defcom 1com-wt-find-link0 "Prompts for a record name and link view and searches for such a link.
With a positive numeric argument, searches forward starting on the line following point.
With a negative numeric argument, searches backward starting on the line preceding point." ()
  (let ((record (zwei:typein-line-accept-record-group
		  :default (collected-references-recently-added
			     *collected-references*)))
	(view (zwei:typein-line-accept 'reference-type-or-all :default "All Views"
				       :prompt "View")))
    (find-wt-buffer-thing record :link (zwei:point) (plusp zwei:*numeric-arg*) view
			  :including-point-line-p nil :prompt-for-find-more nil))
  zwei:dis-none)

(zwei:defcom 1com-wt-reverse0-1find-link0 "Prompts for a record name and link view and searches for such a link.
With a positive numeric argument, searches backward starting on the line preceding point.
With a negative numeric argument, searches forward starting on the line following point." ()
  (let ((record (zwei:typein-line-accept-record-group
		  :default (collected-references-recently-added
			     *collected-references*)))
	(view (zwei:typein-line-accept 'reference-type-or-all :default "All Views"
				       :prompt "View")))
    (find-wt-buffer-thing record :link (zwei:point) (minusp zwei:*numeric-arg*) view
			  :including-point-line-p nil :prompt-for-find-more nil))
  zwei:dis-none)

(zwei:defcom 1com-wt-find-markup 0"Prompts for a markup name and searches for a markup environment of that name.
With a positive numeric argument, searches forward starting on the line following point.
With a negative numeric argument, searches backward starting on the line preceding point." ()
  (let ((markup-dd (zwei:typein-line-accept 'sage-markup
					    :prompt "Markup name")))
    (find-wt-buffer-thing markup-dd :markup (zwei:point) (plusp zwei:*numeric-arg*) nil
			  :including-point-line-p nil :prompt-for-find-more nil))
  zwei:dis-none)

(zwei:defcom 1com-wt-reverse-find-markup 0"Prompts for a markup name and searches for a markup environment of that name.
With a positive numeric argument, searches backward starting on the line preceding point.
With a negative numeric argument, searches forward starting on the line following point." ()
  (let ((markup-dd (zwei:typein-line-accept 'sage-markup
					    :prompt "Markup name")))
    (find-wt-buffer-thing markup-dd :markup (zwei:point) (minusp zwei:*numeric-arg*) nil
			  :including-point-line-p nil :prompt-for-find-more nil))
  zwei:dis-none)

;;; This sets up a private history for strings searched for in ConEd buffers.
(define-presentation-type 1wt-string 0() :expander 'string :history t)

(zwei:defcom 1com-wt-find-markup-string 0"Searches for a string in structural markup and formatting markup.
If found, s-S continues search forward, s-R searches backward, ” exits search." ()
  (let ((search-for (zwei:typein-line-accept 'wt-string :prompt "Search for string: ")))
    (find-wt-buffer-thing search-for :string (zwei:point) t nil
			  :including-point-line-p t :prompt-for-find-more t))
  zwei:dis-none)

(zwei:defcom 1com-wt-reverse-find-markup-string0 "Searches backward for a string in structural markup and formatting markup.
If found, s-S searches forward, s-R continues search backward, ” exits search." ()
  (let ((search-for (zwei:typein-line-accept 'wt-string :prompt "Search for string: ")))
    (find-wt-buffer-thing search-for :string (zwei:point) nil nil
			  :including-point-line-p t :prompt-for-find-more t))
  zwei:dis-none)

(zwei:defcom 1com-wt-create-picture0 "Creates a picture and inserts it at the cursor.
Prompts for a picture-type, a source file, and a name for the picture."
	     ()
  (let ((picture-type (zwei:typein-line-accept `((member ,@*known-picture-types-registry*)
						 :description "a picture type")
					       :prompt "Picture type")))
    (multiple-value-bind (pathname picture-name)
	(read-pathname-and-picture-name-for-picture-type picture-type)
      (multiple-value-bind (binary-encoding drawing-function)
	  (zwei:barf-on-errors (dw:command-error)
	    (funcall (get picture-type 'binary-encoding) pathname picture-name))
	(splice-sage-structure-at-point 'sage-picture
					:type picture-type
					:name picture-name
					:file-name pathname
					:binary-encoding binary-encoding
					:drawing-function drawing-function))))
  zwei:dis-text)

(defun 1read-pathname-and-picture-name-for-picture-type0 (picture-type)
  (let ((reader (get picture-type 'pathname-and-picture-name-reader)))
    (cond (reader (funcall reader))
	  (t (let ((pathname (zwei:typein-line-accept 'pathname
						      :prompt "Picture source pathname"))
		   (name (zwei:typein-line-accept 'string :prompt "Picture name")))
	       (values pathname name))))))

;;; Shadow the system version of this function because it doesn't work with Concordia.
(zwei:defcom 1com-wt-insert-graphic-editor-drawing
0	     "Insert a drawing that is read into the graphic editor."
	     ()
  (let ((graphic-editor (graphic-editor::locate-graphic-editor)))
    (let ((picture (zwei:typein-line-accept
		     `((graphic-editor:drawing :editor ,graphic-editor))
		     :default (or (graphic-editor:graphic-editor-current-drawing
				    graphic-editor)
				  (dw:presentation-type-default `((graphic-editor:drawing
								    :editor ,graphic-editor))))
		     :prompt "Drawing to insert"))
	  (scale (zwei:typein-line-accept 'number :prompt "Scale" :default 1)))

      (let ((pathname (graphic-editor::drawing-file picture))
	    (name (graphic-editor::drawing-name picture)))
	(let ((binary-encoding
		(zwei:barf-on-errors (dw:command-error)
		  (funcall (get ':graphic-editor 'binary-encoding) pathname name))))
	  (cond ((= scale 1)
		 (splice-sage-structure-at-point 'sage-picture
						 :type :graphic-editor :name name
						 :file-name pathname
						 :binary-encoding binary-encoding))
		(t (let ((picture (make-sage-picture
				    :type :graphic-editor :name name
				    :file-name pathname
				    :binary-encoding binary-encoding)))
		     (splice-sage-structure-at-point 'sage-envr
						     :envr-name 'transparent
						     :envr-mods `((picturescale
								    (,scale absolute)))
						     :contents-list (ncons picture)))))))))
  zwei:dis-text)

(zwei:defcom 1com-wt-insert-tab-to-tab-stop0 "Insert tab-to-tab-stop command" (zwei:nm)
  (insert-symbol-for-editor-buffer-at-point 'tab-to-tab-stop))

(zwei:defcom 1com-wt-insert-collect-centering0 "Insert collect-centering command" (zwei:nm)
  (insert-symbol-for-editor-buffer-at-point 'collect-centering))

(zwei:defcom 1com-wt-insert-collect-right-flushing0 "Insert collect-right-flushing command"
	     (zwei:nm)
  (insert-symbol-for-editor-buffer-at-point 'collect-right-flushing))

(zwei:defcom 1com-wt-insert-em-dash0 "Insert em-dash command" (zwei:nm)
  (insert-symbol-for-editor-buffer-at-point 'em-dash))

(defun 1insert-symbol-for-editor-buffer-at-point0 (char-name)
  (let ((char (symbol-for-editor-buffer char-name))
	(point (zwei:point)))
    (zwei:with-node-write-locked ((zwei:bp-node-to-lock point))
      (dotimes (i zwei:*numeric-arg*)
	(zwei:insert-moving point char))
      (zwei:move-point point)
      (values zwei:dis-line (zwei:bp-line point)
	      (- (zwei:bp-index point) zwei:*numeric-arg*)))))

(zwei:defcom 1com-wt-make-active-text 0"Create an ActiveText markup for mouse sensitivity." ()
  (zwei:assure-inside-record
    () "The cursor must be inside a record.")
  (let ((markup-dd (sage::make-directive-descriptor
		     :symbol 'ActiveText :parse-type :environment
		     :document-type 'generic :device-type 'generic)))
    (destructuring-bind (&key pobject ptype presentable)
	(graphic-editor::accept-presentation-data nil)
      (ignore presentable)
      (splice-environment-at-point-or-region markup-dd :assure-inside-record nil)
      (let* ((envr-node (block found
			  (let ((point (zwei:point)))
			    (do-zwei-sage-superiors
			      (zwei-node its-sage-node
					 (zwei:bp-node point))
			      (ignore its-sage-node)
			      (when (typep zwei-node 'zwei:environment-structure-node)
				(return-from found zwei-node))))))
	     (markup-structure (markup-structure-node-markup-structure envr-node)))
      	(multiple-value-bind (object-generating-form type-generating-form)
	    (graphics::make-presentation-object-printable pobject ptype)
	  (zwei:mung-node envr-node)
	  (zwei:diagram-lines-need-redisplay envr-node)
	  (send markup-structure :set-envr-mods
		(list `(sage::presentationobject ,object-generating-form)
		      `(sage::presentationtype ',type-generating-form))))))
    zwei:dis-text))

(zwei:defcom 1com-wt-make-Language-form0 "Make the region into a Language form
If there is a region, use it, except trim the markers off the ends first.
Else if the cursor is within a pair of markers, use them.
Else use the Lisp expression preceding the cursor." ()
  (multiple-value-bind (left right)
      (pointy-hands-in-sage-symbol-face)
    (labels ((doit (bp1 bp2)
	       (zwei:with-undo-save ("add language form" bp1 bp2 t)
		 (let ((line (zwei:bp-line bp1)))
		   (unless (eq line (zwei:bp-line bp2))
		     (zwei:barf "A Language form must be entirely on one line"))
		   ;; Trim any existing @L markers off the end of the region
		   (let ((bp3-index (string-search-exact-char
				      left line
				      :start (zwei:bp-index bp1) :end (zwei:bp-index bp2)
				      :from-end T)))
		     (let ((bp3
			     (if bp3-index
				 (zwei:create-bp line (1+ bp3-index))
				 (zwei:copy-bp bp1))))
		       (let ((bp4-index (string-search-exact-char right line
								  :start (zwei:bp-index bp3)
								  :end (zwei:bp-index bp2))))
			 (let ((bp4 (if bp4-index
					(zwei:create-bp line bp4-index)
					(zwei:copy-bp bp2))))
			   (let* ((stuff (parse-L-string (zwei:string-interval bp3 bp4 T)))
				  ;; ---How can we verify that this is reasonable?  That it
				  ;; won't be rendered as user::foo?
				  (cmd (make-sage-command 'L (list stuff)))
				  (strings (enstyle-sage-command-text cmd () :edited)))
			     (let ((index (zwei:bp-index bp1))
				   (line (zwei:bp-line bp1)))
			       (let ((*check-for-unbalanced-language-forms* nil))
				 (zwei:delete-interval bp1 bp2))
			       (dolist (string strings)
				 (zwei:insert-moving bp1 string))
			       (zwei:move-point bp1)
			       (values zwei:dis-line line index)))))))))))
      (if (zwei:window-region-p)
	  (zwei:region (bp1 bp2)
	    (multiple-value-bind (left-pointy1 right-pointy1)
		(find-surrounding-pointy-hands bp1)
	      (multiple-value-bind (left-pointy2 right-pointy2)
		  (find-surrounding-pointy-hands bp2)
		(when (or left-pointy1 right-pointy1 left-pointy2 right-pointy2)
		  (zwei:barf "Can't make language form around or inside language form."))))
	    (doit bp1 bp2))
	  (multiple-value-bind (beg end)
	      (expression-containing-bp (zwei:point))
	    (if beg
		(doit beg end)
		(beep)
		zwei:dis-none))))))

(defun 1expression-containing-bp0 (bp)
  (multiple-value-bind (left-pointy right-pointy)
      (find-surrounding-pointy-hands bp)
    (cond (left-pointy (values left-pointy right-pointy))
	  (t 
	   (let* ((line (zwei:bp-line bp))
		  (end-of-line (zwei:create-bp line (zwei:line-length line)))
		  (beg-of-line (zwei:create-bp line 0)))
	     (flet ((forw (bp) (zwei:forward-sexp bp 1 t 0 end-of-line))
		    (backw (bp) (zwei:forward-sexp bp -1 t 0 beg-of-line)))
	       (let ((back-one (backw bp))
		     (for-one (forw bp)))
		 (multiple-value-bind (potential-left-pointy potential-right-pointy)
		     (find-surrounding-pointy-hands back-one)
		   (cond (potential-left-pointy (values potential-left-pointy
							potential-right-pointy))
			 (t 
			  (flet ((bp-values (one two)
				   (unless (zwei:bp-= one two)
				     (values one two))))
			    (let ((for-from-back (forw back-one))
				  (back-from-for (backw for-one)))
			      (cond ((and (zwei:bp-= for-from-back for-one)
					  (zwei:bp-= back-from-for back-one))
				     ;; normal, easy, case
				     (bp-values back-one for-one))
				    ((zwei:bp-= back-from-for bp)
				     ;; cursor at start of exp
				     (bp-values back-from-for for-one))
				    (t nil))))))))))))))

(defun 1find-surrounding-pointy-hands0 (bp)
  ;; This is so hairy because it has to deal with potential mismatches
  (multiple-value-bind (left right)
      (pointy-hands-in-sage-symbol-face)
    (let ((line (zwei:bp-line bp))
	  (index (zwei:bp-index bp)))
      ;; first, find previous open and following close, if any
      (let ((nearest-left (string-search-exact-char left line :start 0 :end index
						    :from-end t))
	    (nearest-right (string-search-exact-char right line :start index
						     :end (zwei:line-length line))))
	;; quick out
	(unless (or nearest-left nearest-right)
	  (return-from find-surrounding-pointy-hands nil))

	(when (and nearest-left
		   (string-search-exact-char right line :start nearest-left
					     :end index))
	  (setq nearest-left nil))

	(when (and nearest-right
		   (string-search-exact-char left line :start index
					     :end nearest-right
					     :from-end t))
	  (setq nearest-right nil))

	;; now, find the first right before the nearest left
	;; and the first left after the nearest right
	(let ((first-right (when nearest-left
			     (string-search-exact-char right line
						       :start 0 :end nearest-left
						       :from-end t)))
	      (first-left (when nearest-right
			    (string-search-exact-char left line :start nearest-right
						      :end (zwei:line-length line)))))
	  (unless first-right
	    (when nearest-left (setq first-right 0)))
	  (unless first-left
	    (when nearest-right (setq first-left (zwei:line-length line))))
	  ;; now, the surrounding pointy hands
	  ;; are the first left after the first right
	  ;; and the first right before the first left
	  ;; as long as these are on the appropriate side of index.
	  (let ((surrounding-left (when first-right
				    (string-search-exact-char left line :start first-right
							      :end index)))
		(surrounding-right (when first-left
				     (string-search-exact-char right line :start index
							       :end first-left
							       :from-end t))))
	    ;; apply the quick out again
	    (unless (or nearest-left nearest-right)
	      (return-from find-surrounding-pointy-hands nil))
	    (if surrounding-left
		(if (<= surrounding-left index)
		    (setq surrounding-left (zwei:create-bp line surrounding-left))
		    (setq surrounding-left nil))
		(let ((new-surrounding-left (zwei:forward-sexp bp -1)))
		  (if (eq (zwei:bp-line new-surrounding-left) line)
		      (setq surrounding-left new-surrounding-left)
		      (setq surrounding-left nil))))
	    (if surrounding-right
		(if (>= surrounding-right index)
		    (setq surrounding-right (zwei:create-bp line (1+ surrounding-right)))
		    (setq surrounding-right nil))
		(let ((new-surrounding-right (zwei:forward-sexp bp)))
		  (if (eq (zwei:bp-line new-surrounding-right) line)
		      (setq surrounding-right new-surrounding-right)
		      (setq surrounding-right (zwei:create-bp line (zwei:line-length line))))))
	    (values surrounding-left surrounding-right)))))))

(defun 1remove-pointy-hands0 (start-bp end-bp)
  (let ((line (zwei:bp-line start-bp))
	(start (zwei:bp-index start-bp))
	(end (zwei:bp-index end-bp)))
    (zwei:with-undo-save ("remove language form" start-bp end-bp t)
      (let ((*check-for-unbalanced-language-forms* nil))
	(multiple-value-bind (left right)
	    (pointy-hands-in-sage-symbol-face)
	  (let ((last-left (string-search-exact-char left line
						     :start start
						     :end end
						     :from-end t)))
	    (when last-left
	      (incf last-left)
	      (decf end (- last-left start))
	      (setq last-left (zwei:create-bp line last-left))
	      (zwei:delete-interval start-bp last-left t))

	    (let ((first-right (string-search-exact-char right line
							 :start start
							 :end end)))
	      (when first-right
		(setq first-right (zwei:create-bp line first-right))
		(setq end-bp (zwei:create-bp line end))
		(zwei:delete-interval first-right end-bp t))
	      (values zwei:dis-line line start))))))))

#||
(zwei:DEFINE-PRESENTATION-TO-EDITOR-COMMAND-TRANSLATOR test-searching
			     (zwei:BP
			      "test searching"
			      *wt-COMTAB*
			      :BLANK-AREA T
			      :GESTURE :hyper-right)
			     (BP &KEY X Y WINDOW)
  `(test-searching ,BP ,X ,Y ,(SEND WINDOW :ZWEI-WINDOW)))

(defun test-searching (BP LAST-X LAST-Y WINDOW)
  (setq bp (if bp (zwei:copy-bp bp)
	       (zwei:copy-bp (zwei:interval-first-bp (zwei:window-interval window)))))
  (LET ((LAST-LINE NIL)
	(LAST-CHAR-POS NIL))
    (LOOP DOING
      (MULTIPLE-VALUE-BIND (CHAR NIL NIL LINE CHAR-POS)
	  (IF (AND LAST-X LAST-Y)
	      (zwei:MOUSE-CHAR WINDOW NIL LAST-X LAST-Y)
	      (VALUES (zwei:BP-CHAR BP) NIL NIL (zwei:BP-LINE BP) (zwei:BP-INDEX BP)))
	(WHEN (AND CHAR (OR (NEQ LINE LAST-LINE) ( CHAR-POS LAST-CHAR-POS)))
	  (zwei:move-bp bp line char-pos)
	  (multiple-value-bind (at-left at-right)
	      ;;(search-line-for-pointy-hands bp)
	      (expression-containing-bp bp)
	    (zwei:MOVE-WINDOW-POINT WINDOW at-left)
	    (zwei:move-window-mark window at-right)
	    (SETF (zwei:WINDOW-MARK-P WINDOW) T)
	    (zwei:MUST-REDISPLAY WINDOW zwei:DIS-BPS)
	    (zwei:REDISPLAY WINDOW :POINT)
	    (SETQ LAST-LINE LINE LAST-CHAR-POS CHAR-POS))))
      (UNLESS (AND LAST-X LAST-Y (zwei:WAIT-FOR-MOUSE LAST-X LAST-Y))
	(RETURN NIL))
      (MULTIPLE-VALUE-setq (LAST-X LAST-Y)
	(zwei:MOUSE-POSITION)))))

||#

(defmethod 1(update-example-record-marker example-record-marker)0 (forms)
  (setq encoding (ecase type
		   (:typescript
		     (with-output-to-string (*standard-output*)
		       (map () #'eval forms)))
		   (:values
		     (let ((prologue (butlast forms))
			   (last (first (last forms))))
		       (map () #'eval prologue)
		       (let ((values
			       (multiple-value-list (eval last))))
			 (with-output-to-string (*standard-output*)
			   (map () #'print values)))))
		   (:picture
		     (graphics:binary-encode-graphics-to-array
		       #'(lambda (*standard-output*)
			   (map () #'eval forms))))
		   (:bitmap
		     (multiple-value-bind (raster left top right bottom)
			 (graphics:with-output-to-bitmap (*standard-output*)
			   (map () #'eval forms))
		       (graphics:binary-encode-graphics-to-array
			 #'(lambda (stream)
			     (graphics:draw-image raster left (- bottom)
						  :image-right (- right left)
						  :image-bottom (- bottom top)
						  :scale-y -1
						  :stream stream))))))))

(zwei:defcom 1com-wt-create-example-record-marker0 "Adds a record marker for this example record.
Prompts for record kind." ()
  (let* ((example (current-active-example))
	 (type (zwei:typein-line-accept '((member :typescript :picture :bitmap :values))
				       :prompt "Record type" :default :typescript)))
    (splice-sage-structure-at-point 'example-record-marker :type type)
    (when (y-or-n-p "Test the example now? ")
      (execute-example-contents (directive-inferiors example) :update-record t)))
  zwei:dis-text)

(zwei:defcom 1com-wt-test-example0 "Run the active example environment that the cursor is within.
Also updates any records associated with it."
	     ()
  (let* ((example (current-active-example)))
    (execute-example-contents (directive-inferiors example) :update-record t))
  zwei:dis-all)					;May have changed diagram lines.

(defun 1current-active-example0 ()
  (let ((example (loop for node = (zwei:bp-node (zwei:point)) then (zwei:node-superior node)
		       until (eq node zwei:*interval*) do
		   (when (typep node 'zwei:markup-structure-node)
		     (let ((markup (zwei:markup-structure-node-markup-structure node)))
		       (when (and (typep markup 'sage-envr)
				  (let* ((dd (with-document-and-device-types ()
					       (lookup-directive-descriptor
						 (send markup :envr-name))))
					 (defn (dd-definition dd))
					 (presentation-type
					   (second (find 'presentationtype defn :key #'car))))
				    (and (consp presentation-type)
					 (eq (first presentation-type) 'quote)
					 (eq (second presentation-type) 'active-example))))
			 (return markup)))))))
    (when (null example)
      (zwei:barf "Point is not within an active example"))
    example))

(zwei:defcom 1com-wt-change-environment0 "Change formatter environment specs" ()
  (let ((envr-node
	  (block found
	    (let ((point (zwei:point)))
	      (do-zwei-sage-superiors (zwei-node its-sage-node (zwei:bp-node point))
		(ignore its-sage-node)
		(when (typep zwei-node 'zwei:environment-structure-node)
		  (return-from found zwei-node)))))))
    (when (null envr-node)
      (zwei:barf "The cursor must be within an environment"))
    (edit-envr-for-node-using-avv-in-typeout-window envr-node)
    ;; redisplay level already taken care of
    zwei:dis-none))

(zwei:defcom 1com-wt-query-change-environments0 "Changes occurrences of one environment to another
Prompts for an environment name to change, and for one to replace it with.
When it finds an occurrence of the first environment, it stops and waits for 
you to confirm by typing a character.

Y or Space   Replaces the first environment and moves to its next occurrence.
N or Rubout  Skips this occurrence and moves to the next one.
c-L, Refresh Redisplay the screen
Abort        Terminate the command with prejudice.

Any other character causes this command to terminate (the character is then
read as input by the editor).

Sorry, this is not linked into the Undo facility because
its internal operation is not simply modeled with inserts 
and deletes." ()
  (let* ((envr-to-change
	   (dd-symbol (zwei:typein-line-accept
			'sage-environment-name
			:prompt "Environment name to change")))
	 (envr-to-change-to
	   (dd-symbol (zwei:typein-line-accept
			'sage-environment-name
			:prompt (format nil "Environment name to change ~a to"
					envr-to-change))))
	 (mode-line (format nil "Query Changing Envrs ~a => ~a"
			    envr-to-change envr-to-change-to)))
    (declare (special mode-line))
    (zwei:bind-mode-line (mode-line)
      (flet ((do-display (line)
	       (zwei:move-point (zwei:create-bp line 0))
	       (zwei:must-redisplay zwei:*window* zwei:dis-bps)
	       (zwei:redisplay zwei:*window* :point)
	       (zwei:redisplay-mode-line)	;I just copied it from query-replace-internal
	       )
	     (do-query ()
	       (loop
		 (let ((char (zwei:editor-input)))
		   (when (characterp char)
		     (setq char (char-upcase char))
		     (cond ((member char '(#\Y #\space))
			    (return T))
			   ((member char '(#\N #\rubout))
			    (return NIL))
			   ((char= char #\Help)
			    (zwei:print-doc ':full zwei:*current-command*)
			    (format t "~&Type any character to flush:")
			    (zwei:check-for-typeout-window-typeout)
			    (zwei:redisplay-all-windows))
			   ((member char tv:kbd-intercepted-characters :test #'char-equal)
			    (zwei:zwei-kbd-intercept-character char zwei:*typein-window*)
			    (send zwei:*typeout-window* ':make-complete)
			    (zwei:redisplay-all-windows))
			   ((member char '(#\Refresh #\c-L) :test #'char-equal)
			    (zwei:must-redisplay zwei:*window*
						 (if (char= char #\Refresh)
						     zwei:dis-all
						     (zwei:com-recenter-window)))
			    (zwei:redisplay zwei:*window* :point))
			   (T (beep)))))))
	     (do-replace (line)
	       (let ((node (zwei:line-node line)))
		 (let ((first-line (zwei:bp-line (zwei:node-first-bp node)))
		       (last-line (zwei:bp-line (zwei:node-last-bp node))))
		   (assert (or (eq line first-line)
			       (eq line last-line)))
		   (assert (neq first-line last-line))
		   (zwei:mung-node node)
		   (let ((envr (zwei:markup-structure-node-markup-structure node)))
		     (send envr :set-envr-name envr-to-change-to)
		     (send envr :set-envr-mods ()))
		   (zwei:diagram-lines-need-redisplay node)))))
	(loop for line = (zwei:bp-line (zwei:point)) then (zwei:line-next-in-buffer line)
	      do
	  (when (null line)
	    (zwei:typein-line "No more occurrences of ~a" envr-to-change)
	    (loop-finish))
	  (let* ((diagram (zwei:line-diagram line))
		 (zwei-node (and (typep diagram 'zwei:environment-header-line)
				 (zwei:line-node line)))
		 (sage-node (and (typep zwei-node 'zwei:environment-structure-node)
				 (zwei:markup-structure-node-markup-structure zwei-node)))
		 (envr-name (and sage-node (send sage-node :envr-name))))
	    (when (eql envr-name envr-to-change)
	      (do-display line)
	      (when (do-query)
		(do-replace line))))))))
  ;;  redisplay degree already taken care of
  zwei:dis-none)

(zwei:defcom 1com-wt-kill-environment0 "Kill formatter environment and its contents" ()
  (let ((point (zwei:point)))
    (do-zwei-sage-superiors (zwei-node its-sage-node (zwei:bp-node point))
      (when (typep zwei-node 'zwei:environment-structure-node)
	(return-from com-wt-kill-environment
	  (remove-markup-of-node zwei-node its-sage-node :kill)))))
  (zwei:barf "The cursor must be within an environment"))

(zwei:defcom 1com-wt-remove-markup0 "Remove formatter markup
but leave the contents" (zwei:nm)
  ;; What if there's a region?
  (let ((point (zwei:point)))
    ;; first see if there's any @l markup to remove
    (multiple-value-bind (left right)
	(find-surrounding-pointy-hands point)
      (cond ((and left right)
	     (return-from com-wt-remove-markup (remove-pointy-hands left right)))
	    (t
	     (do-zwei-sage-superiors (zwei-node its-sage-node (zwei:bp-node point))
	       (when (typep zwei-node 'zwei:environment-structure-node)
		 (return-from com-wt-remove-markup
		   (remove-markup-of-node zwei-node its-sage-node :remove))))))))
  (zwei:barf "The cursor must be within some kind of markup"))

(defun 1remove-markup-of-node0 (zwei-node its-sage-node remove-or-kill)
  (check-type remove-or-kill (member :remove :kill))
  (let ((point (zwei:point))
	(first-bp (zwei:node-first-bp zwei-node))
	(last-bp (zwei:node-last-bp zwei-node)))
    (if (zwei:bp-= (zwei:forward-char first-bp 1) last-bp)
	;; If there's nothing but markup, kill it.
	(progn
	  (zwei:kill-interval first-bp (zwei:forward-char last-bp) T)
	  zwei:dis-text)
	(let ((inside-from (zwei:forward-char first-bp 1))
	      (inside-to (zwei:forward-char last-bp -1))
	      (old-mark (zwei:copy-bp (zwei:mark)))
	      (old-point (zwei:copy-bp point)))
	  (ignore inside-from)
	  ;; If point is near the beginning, put point there and mark at the end;
	  ;; else put mark at the beginning and point at the end.
	  (multiple-value-bind (new-point new-mark)
	      (if (or (zwei:bp-= point first-bp)
		      (zwei:bp-= point inside-to))
		  (values first-bp last-bp)
		  (values last-bp first-bp))
	    (zwei:move-mark new-mark)
	    (zwei:move-point new-point)
	    (setf (zwei:window-mark-p zwei:*window*) T)
	    (zwei:must-redisplay zwei:*window* zwei:dis-bps)
	    (zwei:redisplay zwei:*window* :point () () T)
	    (cond ((and (eq remove-or-kill :remove)
			(y-or-n-p "Remove markup ~a? "
				  (send its-sage-node :envr-name)))
		   (zwei:move-nonboundary-bps-of-line-to (zwei:bp-line first-bp) inside-from)
		   (zwei:move-nonboundary-bps-of-line-to (zwei:bp-line last-bp) inside-to)
		   (splice-node-children-in-place-of-node zwei-node its-sage-node)
		   (setf (zwei:window-mark-p zwei:*window*) ())
		   zwei:dis-text)
		  ((and (eq remove-or-kill :kill)
			(y-or-n-p "Kill environment ~a? "
				  (send its-sage-node :envr-name)))
		   (zwei:kill-interval first-bp (zwei:forward-char last-bp) t)
		   zwei:dis-text)
		  (T ;; Abandon the attempt; restore point and mark.
		     (zwei:move-mark old-mark)
		     (zwei:move-point old-point)
		     (setf (zwei:window-mark-p zwei:*window*) ())
		     zwei:dis-bps)))))))

(zwei:defcom 1com-wt-parse-and-replace-region0 "Replace the region with its formatter parse
That is, turn the atsigns into markup and things." ()
  (zwei:region (bp1 bp2)
    (let ((stuff
	    (upgrade-sage-contents-list-for-newthink 
	      (with-open-stream (stream (zwei:open-interval-stream bp1 bp2 T))
		(with-document-and-device-types ()
		  (sage-parse stream)))
	      :edited)))
      (when (null stuff) (return-from com-wt-parse-and-replace-region zwei:dis-none))
      (insert-sage-contents-list bp2 stuff)
      (zwei:kill-interval bp1 bp2 T)))
  zwei:dis-text)

;; Remove this as soon as editing command contents lists works
(zwei:defcom 1com-wt-unparse-and-replace0 "Replace the command diagram at the cursor
with its unparse.  That is, turn it into atsigns and things." ()
  (let* ((point (zwei:point))
	 (node (zwei:bp-node point))
	 (command
	   (typecase node
	     (zwei:command-structure-node (zwei:markup-structure-node-markup-structure node))
	     (zwei:editable-command-structure-node
	       (clone-contents-internal (zwei:markup-structure-node-markup-structure node))))))
    (when (null command)
      (zwei:barf "The cursor must be on a command diagram"))
    (let ((last-bp (zwei:copy-bp (zwei:forward-char (zwei:interval-last-bp node) 1) :normal)))
      ;; we want to be able to insert at last-bp without having it move out from under us.
      (zwei:insert last-bp (string #\cr))
      (zwei:kill-interval (zwei:interval-first-bp node) last-bp t)
      (zwei:insert (zwei:point)
		   (with-output-to-string (stream)
		     (mss-command command stream)))
      )
    zwei:dis-text))

(zwei:defcom 1com-wt-mark-whole-word0 "Mark the word containing the cursor" (zwei:sm)
  (let* ((point (zwei:point))
	 (char (zwei:bp-char point)))
    (multiple-value-bind (before after)
	(selector (zwei:word-syntax char) =
	  ((zwei:WORD-ALPHABETIC)
	    (let ((after (zwei:forward-word point 1 T)))
	      (values (zwei:forward-word after -1 T) after)))
	  ((zwei:WORD-DELIMITER)
	    ;; We are between words.  Search one char at a time,
	    ;; backwards and forwards, until we find an alphabetic char.  Bleagh.
	    (loop for back-bp = point
			      then (and back-bp (zwei:forward-char back-bp -1))
		  for forw-bp = point
			      then (and forw-bp (zwei:forward-char forw-bp 1))
		  do
	      (cond ((and back-bp
			  (= (zwei:word-syntax (zwei:bp-char back-bp))
			     zwei:WORD-ALPHABETIC))
		     (let ((before-word (zwei:forward-word (zwei:forward-char back-bp 1)
							   -1 T)))
		       (return (values before-word (zwei:forward-word before-word 1)))))
		    ((and forw-bp
			  (= (zwei:word-syntax (zwei:bp-char forw-bp))
			     zwei:WORD-ALPHABETIC))
		     (let ((after-word (zwei:forward-word forw-bp 1 T)))
		       (return (values (zwei:forward-word after-word -1)
				       after-word))))
		    ((or back-bp forw-bp))
		    (T (zwei:barf))))))
      (zwei:move-mark before)
      (zwei:move-point after)))
  zwei:dis-bps)

(defmacro 1with-sentence-bps0 ((first-bp last-bp) &body body)
  `(with-sentence-bps-1 (named-lambda with-sentence-bps (,first-bp ,last-bp)
			     (declare (sys:downward-function))
			     ,@body)))

(defun 1with-sentence-bps-10 (continuation)
  ;; this behaves weirdly when point is at start or end of the sentence.
  ;; really needs to take intersection of backwardforward and forwardbackward.
  (let ((last-bp (zwei:forward-sentence (zwei:point)))
	(first-bp (zwei:forward-sentence (zwei:point) -1)))
    (unless (and first-bp last-bp)
      (zwei:barf "Can't determine the boundaries of the sentence containing the cursor."))
    (funcall continuation first-bp last-bp)))

(zwei:defcom 1com-wt-kill-whole-sentence0 "Kill the sentence containing the cursor." ()
  (with-sentence-bps (first last)
    (zwei:with-node-write-locked ((zwei:bp-node-to-lock (zwei:point)))
      (zwei:kill-interval first last t)))
  (setq zwei:*current-command-type* 'zwei:kill)
  zwei:dis-text)

(zwei:defcom 1com-wt-mark-whole-sentence0 "Mark the sentence containing the cursor." (zwei:sm)
  (with-sentence-bps (first last)
    (zwei:move-mark first)
    (zwei:move-point last))
  zwei:dis-bps)


(zwei:defcom 1com-wt-show-help0 "Show the Zmacs commands specific to Writer Tools mode" ()
  (let ((comtab *wt-comtab*))
    (let ((key-commands ())
	  (mouse-commands ())
	  (m-x-commands (sort (remove-duplicates 
				(coerce (zwei:comtab-extended-commands comtab) 'list)
				:test #'equal)
			      #'string-lessp :key #'car))
	  (closures ())
	  (presentation-commands ()))
      (flet ((command-p (command)
	       (and command (neq command ':undefined))))
	(let ((keyboard-array (zwei:comtab-keyboard-array comtab)))
	  (let ((nchars (array-dimension keyboard-array 0))
		(nbucky (array-dimension keyboard-array 1)))
	    (dotimes (ch nchars)
	      (dotimes (bucky nbucky)
		(let ((cmd (aref keyboard-array ch bucky)))
		  (when (command-p cmd)
		    (let ((char (make-character (code-char ch) :bits bucky)))
		      (cond ((zl:closurep cmd)
			     (push (list char cmd) closures))
			    (T (push (list char cmd) key-commands))))))))))
	(let ((mouse-array (zwei:comtab-mouse-array comtab)))
	  (let ((nbuttons (array-dimension mouse-array 0))
		(nbucky (array-dimension mouse-array 1)))
	    (dotimes (bucky nbucky)
	      (dotimes (button nbuttons)
		(let ((cmd (aref mouse-array button bucky)))
		  (when (command-p cmd)
		    (let ((mouse-char (si:make-mouse-char button bucky)))
		      (if (zwei:menu-command-p cmd)
			  (push (list mouse-char "(Menu)") mouse-commands)
			  (push (list mouse-char cmd) mouse-commands)))))))))
	(setq key-commands (nreverse key-commands)
	      mouse-commands (nreverse mouse-commands)
	      closures (nreverse closures))
	(flet ((heading (string)
		 (format T "~2&~'b~a~~%" string)))
	  (heading "Keyboard commands:")
	  (loop with prefixes = ()		;---has to do with closures
		for (ch cmd) in key-commands
		unless (eq cmd 'zwei:com-standard)
		  do (fresh-line)
		     (write-string "  ")
		     (dw:with-output-as-presentation
			 (:object (list cmd nil) :type 'editor-command)
		       (format T "~{~c ~^~}~8a ~a"
			       prefixes
			       (let ((c (char-code (make-character ch :bits 0))))
				 (if (and (< c #o200) ( c (char-code #\space)))
				     (format () "~c" ch)
				     (let ((str (format () "~c" ch)))
				       (string-append (substring str 0
								 (1- (string-length str)))
						      (format () "~:c" (code-char c))))))
			       (or (let ((string (get cmd 'zwei:command-name)))
				     (if (string-equal "Wt " string :end2 3)
					 (substring string 3)
					 string))
				   cmd))))
	  (when closures
	    ;;---there aren't any, anyway - used for c-X, for instance.
	    (format-item-list closures))
	  (when mouse-commands
	    (heading "Mouse commands")
	    (write-string "  ")
	    (formatting-table ()
	      (dolist (pair mouse-commands)
		(formatting-row ()
		  (formatting-cell () (format T "~c" (first pair)))
		  (formatting-cell () (princ (second pair)))))))
	  (heading "m-X commands")
	  (write-string "  ")
	  (formatting-item-list (() :n-rows si:*optimal-number-of-rows*
				 :inter-column-spacing (* 2 (send *standard-output* :char-width))
				 :row-wise nil)
	    (loop for (string . command) in m-x-commands do
	      (formatting-cell ()
		(dw:with-output-as-presentation (:object (list command nil)
						 :type 'editor-command)
		  (write-string string)))))
	  (when presentation-commands
	    (heading "Presentation commands")
	    (format T "can't print those yet"))
	  ))))
  zwei:dis-none)

;; Too bad this is so useless.
;; (a) too repetitious (RWK's fault)
;; (b) too hard to extract any meaning from its screenful of crap
;; (c) doesn't show useful things like c-m-Right and s-sh-Middle
;; (d) it speaks of the translator names, not the documentation strings
(defun 1show-presentation-to-wt-comtab-translators0 ()
  (let ((useful-ones ()))
    (tv:dolist-noting-progress (hte dw::*presentation-mouse-handlers*
				    "checking mouse handlers")
      (when (eq (dw::presentation-mouse-handler-context-presentation-type hte)
		'zwei:presentation-command)
	(let ((hf (dw::presentation-mouse-handler-handler-functions hte)))
	  (when (catch 'comtab-test
		  (dynamic-flet ((zwei:presentation-command-comtab-p (ignore comtab)
				  (throw 'comtab-test (eq comtab *wt-comtab*))))
		    (ignore-errors
		      (funcall (dw::presentation-mouse-handler-functions-tester-function hf)
			       nil))))
	    (push hte useful-ones)))))
    (let ((translator-last-time ())
	  (gesture-last-time 99.2))
      (dolist (hte useful-ones)
	(let ((name (dw::presentation-mouse-handler-functions-name
		      (dw::presentation-mouse-handler-handler-functions hte)))
	      (gesture (dw::presentation-mouse-handler-gesture hte))
	      (displayed-p-t (dw::presentation-mouse-handler-displayed-presentation-type hte)))
	  (cond ((eq name translator-last-time)
		 (format T ", or~%  "))
		(T (format T "~&Translator ~(~a~) runs when you click~%   " name)
		   (setq gesture-last-time 99.2)))
	  (unless (eq gesture gesture-last-time)
	    (cond ((null gesture) (format T "in the menu"))
		  (T (let ((mouse-char (dw:mouse-char-for-gesture gesture)))
		       (if (not (si:mouse-char-p mouse-char))
			   (format T "~c" mouse-char)
			   (format:format-mouse-character
			     *standard-output* mouse-char nil T nil nil)))
		     (format T " (~(~s~))" gesture))))
	  (format T " on ")
	  (flet ((d-p-t (p-t)
		   (if (eql p-t 'sys:expression)
		       "an expression"
		       (let ((string (with-output-to-string (s)
				       (dw::describe-presentation-type p-t s))))
			 (let* ((loser "the Lisp representation of ")
				(loser-length (length loser)))
			   (when (eql loser-length (mismatch loser string :test #'char-equal))
			     (setq string (substring string loser-length))))
			 string))))
	    (format T "~a presentation"
		    (d-p-t displayed-p-t))
	    (setq translator-last-time name
		  gesture-last-time gesture)))))))

(zwei:defcom 1com-wt-insert-multilevel-index-entry0 "Insert multilevel index command
Prompts for an index entry, and inserts an appropriate formatter command.
For an ordinary index entry, just type the text.
For a multilevel (i.e., two level) entry, type primary|secondary.
For a primary entry (pageless), just type primary|

Your text cannot include the `|' character, nor can it include formatter
markup (bold or em-dash or anything).  However, a workaround is to
use m-X Unparse, edit the @-junk, then m-X Parse And Replace.
"
	     ()
  (let ((string (zwei:typein-line-accept 'string :prompt "Entry, or primary|secondary: ")))
    (if (> (length string) 0)			;works for NIL, too, heh, heh.
	(let ((contents-list
		(making-sage-directives ()
		  (let ((vbar-loc (position #\| string)))
		    (if vbar-loc
			(let ((primary (substring string 0 vbar-loc))
			      (secondary (substring string (1+ vbar-loc))))
			  (if (= 0 (length secondary))
			      (sage-command () 'indexprimary `((,primary)))
			      (sage-command () 'indexsecondary
					    `((primary (,primary))
					      (secondary (,secondary))))))
			(sage-command () 'index `((,string))))))))
	  (insert-sage-contents-list (zwei:point)
				     (upgrade-sage-contents-list-for-newthink
				       contents-list :edited))
	  zwei:dis-text)
	zwei:dis-none)))

(zwei:defcom 1com-wt-insert-whole-index0 "Insert the whole index for a formatted document.
Only works in ConEd within the Concordia activity.  Prompts for a topic you've
formatted in the Page Previewer.  Recomputes that document's index, and inserts
the index directives right into your buffer." ()
  (insert-whole-index-or-toc "index" 'index-database 'index-database #'directives-for-index
			     (named-lambda entries-counter (database)
			       (length (index-database-entries database)))))

(zwei:defcom 1com-wt-insert-whole-TOC0 "Insert the whole Table of Contents for a formatted document.
Only works in ConEd within the Concordia activity.  Prompts for a topic you've
formatted in the Page Previewer.  Recomputes that document's Table of Contents, and inserts
the ToC directives right into your buffer." ()
  (insert-whole-index-or-toc "ToC" 'table-of-contents-stream 'stream
			     #'sage-directive-stream-finalize-directives
			     (named-lambda entries-counter (database)
			       (ignore database)
			       "all these")))

(defun 1insert-whole-index-or-toc0 (what ambient-value-name ambient-value-type
				  directives-getter entries-counter)
  (let ((concordia (find-containing-concordia)))
    (when (null concordia)
      (zwei:barf "This command only works when you're using Concordia"))
    (multiple-value-bind (ignore concordia-frame ignore) (find-containing-concordia)
      (let* ((page-previewer-frame (send concordia-frame :get-pane 'page-previewer-pane))
	     (page-previewer-program (send page-previewer-frame :program))
	     (table (page-previewer-formatted-pages-hash-table page-previewer-program))
	     )
	(when (null table)
	  (zwei:barf "Cannot find formatted-topic table"))
	(let* ((record-group
		 (zwei:typein-line-accept
		   `((formatted-record-group :hash-table ,table))
		   :default (page-previewer-current-record-group page-previewer-program)))
	       (formatted-pages (gethash record-group table))
	       (final-ambient-values (formatted-pages-final-ambient-values formatted-pages))
	       (database
		 (multiple-value-bind (database type)
		     (let ((*ambient-counters* final-ambient-values))
		       (lookup-ambient-value ambient-value-name :error-p nil))
		   (unless (and (eq type ambient-value-type) database)
		     (zwei:barf "Cannot find ~a database for ~a" what record-group))
		   database)))
	  (if (yes-or-no-p "Are you sure you want to insert directives for ~d entries? "
			   (funcall entries-counter database))
	      (let ((directives
		      (upgrade-sage-contents-list-for-newthink
			(pre-render-counter-value-gboxes
			  (delete-presentation-directives
			    (with-document-and-device-types 
			      ;;---
			        ((document-type-for-record-group record-group))
			      (list*
				(making-sage-directives ()
				  (in-environment (() commentary)
				    (format T "Here is the ~a, done ~\\datime\\, for ~a"
					    what record-group))
				  (sage-contents-list
				    () (funcall directives-getter database)))))))
			:edited)))
		(insert-sage-contents-list (zwei:point) directives)
		zwei:dis-text)
	      zwei:dis-none))))))

(defgeneric 1delete-presentation-directives0 (contents-list)
  (:function
    (typecase contents-list
      (cons
	;; Finally, for the first time in my life, I actually want
	;; the value returned by mapc!
	(mapc #'delete-presentation-directives
	      (delete-if (lambda (x)
			   (and (typep x 'sage-command)
				(eql (send x :command-name) 'presentation)))
			 contents-list)))
      (instance (funcall (flavor:generic delete-presentation-directives) contents-list))
      (otherwise contents-list)))
  (:method (sage-directive-inferiors-mixin)
   (setf (directive-inferiors self)
	 (delete-presentation-directives (directive-inferiors self))))
  (:method (sage-directive :default)
   self))

(defgeneric 1pre-render-counter-value-gboxes0 (contents-list)
  (:function
    (typecase contents-list
      (cons
	(map-into contents-list #'pre-render-counter-value-gboxes contents-list))
      (instance (funcall (flavor:generic pre-render-counter-value-gboxes) contents-list))
      (null "")
      (otherwise contents-list)))
  (:method (sage-directive :default) self)
  (:method (phony-function-spec) self)
  (:method (sage-directive-inferiors-mixin)
   (setf (directive-inferiors self)
	 (pre-render-counter-value-gboxes (directive-inferiors self)))
   self)
  (:method (sage-command)
   (cond ((member command-name '(counter-value-as-number counter-value-as-reference))
	  (let ((counter (first parameter)))
	    (let ((contents-list (counter-value-contents-list
				   counter
				   (ecase command-name
				     (counter-value-as-number :number)
				     (counter-value-as-reference :reference)))))
	      (cond ((null contents-list) "")
		    ((= 1 (length contents-list))
		     (first contents-list))
		    (T
		     ;; ---This loses character styles, @S, and probably more.
		     (filtered-string-from-contents-list contents-list))))))
	 (T (when parameter
	      (setq parameter (pre-render-counter-value-gboxes parameter)))
	    self))))


(defvar 1*last-choose-menu-command-item*0 nil)

(defun 1choose-menu-command0 (item-list)
  (multiple-value-bind (choice item mouse-char)
      (dw:menu-choose item-list
		      :prompt '(:string " Choose a command:"
				:style (:jess :roman :normal))
		      :default *last-choose-menu-command-item*)
    (when choice
      (setq *last-choose-menu-command-item* item))
    (values choice item mouse-char)))

(zwei:defcom com-wt-list-changed-records "Displays the names of records in all Concordia buffers that have changed.
It makes an internal list of the changed records and offers to let you edit them.
Use c-. (Next Possibility) to move to subsequent records.
Arg = 1 means list records changed since the file was last read (this is the default).
Arg = 2 means list records changed since the file was last saved." ()
  (zwei:list-changed-records-internal nil)
  zwei:dis-none)

(zwei:defcom com-wt-list-changed-records-of-buffer "Displays the names of records in the buffer that have changed.
It makes an internal list of the changed records and offers to let you edit them.  
Use c-. (Next Possibility) to move to subsequent records.
Arg = 1 means list records changed since the file was last read (this is the default).
Arg = 2 means list records changed since the file was last saved." ()
  (zwei:list-changed-records-internal t)
  zwei:dis-none)

(zwei:defcom com-wt-add-patch-changed-records-of-buffer "Adds all changed, unpatched records in the current buffer to the current patch.
It queries about each changed record before adding it the patch." ()
  (zwei:add-patch-changed-records-internal zwei:*interval*)
  (zwei:typein-line "Done.")
  zwei:dis-none)

(zwei:defcom com-wt-add-patch-changed-records "Adds all changed, unpatched records in all Concordia buffers to the current patch.
It queries about each changed record before adding it the patch." ()
  (dolist (buffer zwei:*zmacs-buffer-list*)
    (when (typep buffer 'zwei:markup-buffer)
      (zwei:add-patch-changed-records-internal buffer)))
  (zwei:typein-line "Done.")
  zwei:dis-none)

(zwei:defcom com-wt-set-buffer-disposition "Queries the user for the disposition of a Concordia buffer.
This command allows the user to lock the file associated with this buffer for exclusive use
or to disconnect the buffer from the file." ()
  (zwei:make-file-markup-buffer-modifiable zwei:*interval* :explicit-request t)
  (redisplay-ConEd-record-title-pane :force-p t)
  zwei:dis-none)

(zwei:defcom com-wt-break-file-lock "Forcibly break a write lock on a file.
This should be used with caution only after determining that the user or host that holds the lock is not planning on saving a modified buffer to the file." ()
  (zwei:break-sab-file-lock zwei:*interval*)
  zwei:dis-none)

(zwei:defcom com-wt-remove-run-in-markers "Adds carriage returns where necessary to remove any run-in marks in the region,
or if no region is specified, the entire buffer." ()
  (let ((from-bp (if (zwei:window-region-p)
		     (zwei:mark)
		     (zwei:interval-first-bp zwei:*interval*)))
	(to-bp (if (zwei:window-region-p)
		   (zwei:point)
		   (zwei:interval-last-bp zwei:*interval*))))
    (zwei:remove-run-in-markers from-bp to-bp)
    zwei:dis-none))
