;;; -*- Mode: LISP; Syntax: Zetalisp; Package: ZWEI; Base: 10; Lowercase: T -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

#||
Protocols:

markup-structure (i.e., Sage's data) needs:
  markup-structure-editor-node

individual structure pointed to by nodes and/or diagrams needs to
  be able to draw itself
environment-type-name
draw-item-number

||#

;;; This is to ensure that the echoed command lines look nice
(scl:define-presentation-type D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")markup-structure-node0 ()
   :no-deftype t
   :printer ((node stream &key acceptably)
	     (print-markup-structure-node node stream :acceptably acceptably)))

(defgeneric 1print-markup-structure-node0 (node stream &key acceptably) )

(defmethod 1(print-markup-structure-node markup-structure-node :default)0 (stream
									  &key acceptably)
  (ignore acceptably)
  (scl:present markup-structure (cl:type-of markup-structure) :stream stream))


(cl:pushnew '(:sage-binary . :concordia) fs:*file-type-mode-alist* :key #'first :replace t)


(defflavor 1markup-buffer0 () ()
  (:required-flavors buffer))

(defmethod 1(:sectionize-buffer markup-buffer)0 (stream)
  (ignore stream)
  ())

(defmethod 1(:check-interval-sections markup-buffer)0 (start-bp end-bp)
  (ignore start-bp end-bp)
  ())

(defmethod 1(buffer-sections markup-buffer)0 ()
  ())

;; The node to lock in a Concordia buffer is the record node which contains
;; the passed-in node.  The effect of this is to lock the entire record, but the
;; coarse granularity seems acceptable, since the cost of a finer granularity is
;; to use a complex (and more bug-prone) hierarchical locking strategy.
(defmethod 1(node-to-lock markup-buffer)0 (node)
  (if (typep node 'markup-buffer)
      node
    (loop for node = node then next-node
	  as next-node = (node-superior node)
	  until (or (null next-node)
		    (typep next-node 'markup-buffer))
	  finally (return node))))

(defflavor 1non-file-markup-buffer0 () (markup-buffer non-file-buffer))
(defflavor1 file-markup-buffer
0	((user-read-only-p nil)
	 (disposition nil))
	(markup-buffer file-buffer)
  :writable-instance-variables)

(defmethod 1(:make-non-file markup-buffer)0 ()
  (transform-buffer self 'non-file-markup-buffer :name name))

;;;---Needed to make Write File work.  Write File will still die if you try to write
;;;to anything other than a sab file.
(defmethod 1(:set-pathname-for-write markup-buffer)0 (pathname)
  (transform-buffer self 'file-markup-buffer :pathname pathname :read-tick *tick*))

(defwhopper 1(:set-pathname-for-write file0-1markup-buffer)0 (new-pathname)
  (when (eql disposition :locked)
    (unlock-sab-file pathname))
  (continue-whopper new-pathname))

(defprop *comtab* T mode-settable-p)

(defmajor 1com-concordia-mode0 concordia-mode "Concordia"
          "Enter Concordia mode." ()
  (setq *comtab* nsage::*wt-comtab*)
  ;; copied from 1(:mode-forms text-mode-mixin)
0  (SET-CHAR-SYNTAX WORD-ALPHABETIC *MODE-WORD-SYNTAX-TABLE* #/_)
  (SET-CHAR-SYNTAX WORD-ALPHABETIC *MODE-WORD-SYNTAX-TABLE* #/')
  (SET-CHAR-SYNTAX WORD-DELIMITER *MODE-WORD-SYNTAX-TABLE* #/.)
  ;; (SET-COMTAB *MODE-COMTAB* '(#\TAB COM-TAB-TO-TAB-STOP))
  ;; make these typeable in the minibuffer...
  (set-comtab *mini-buffer-comtab*
	      '(#\s-Tab sage::com-wt-insert-tab-to-tab-stop
		#\s-_ sage::com-wt-insert-em-dash 
		#\s-= sage::com-wt-insert-collect-centering	;@=
		#\s-> sage::com-wt-insert-collect-right-flushing	;@>
		))
  (progn
    (cl:typecase *interval*
      (markup-buffer )
      (non-file-buffer
	(transform-buffer *interval* 'non-file-markup-buffer
			  :name (send *interval* :name)))
      (file-buffer
	(transform-buffer *interval* 'file-markup-buffer
			  :pathname (send *interval* :pathname)
			  :read-tick (send *interval* :tick)))
      (otherwise
	(barf "Cannot change ~s to Concordia Mode" (cl:type-of *interval*))))))

(defmethod 1(:default-character-style concordia-mode)0 ()
  (si:parse-character-style nsage::*screen-default-character-style*))

(defmethod 1(:additional-attributes concordia-mode)0 ()
  '((:base "Base" "~D") (:package "Package" "~A") (:syntax "Syntax" "~:(~A~)")))

;; Like (delete-interval self), except it doesn't lose it with unlinked lines
(defmethod 1(delete-markup-buffer-all markup-buffer)0 ()
  ;;---Some diagrams intervals don't have their last-bp set up at all.
  ;;Take out this kludge when that's fixed.
  (let ((old-flush-bp #'flush-bp))
    (flet ((new-flush-bp (bp)
	     (and bp (funcall old-flush-bp bp))))
      (letf ((#'flush-bp #'new-flush-bp))
	(delete-interval-and-flush-inferiors-1 self))))
  ;;--- now that delete-interval is generic, this should work
  (delete-interval self)
  #+ignore
  (dolist (inf (node-inferiors self))
    (delete-interval inf))
  (setf (node-inferiors self) ()))

(defmacro 1temporarily-inserting-cr-if-necessary 0((bp) &body body)
  ;; Insert a return if we are trying to create something with the point on the trailer
  ;; diagram of a record.  Run the body.  Delete the return.  This bit of nastiness allows
  ;; a user to, for instance, create markup with the cursor on the trailer line of the
  ;; record instead of getting the message, "Text may not be added between the fields of a
  ;; record."  Yuck, I know.
  `(let ((contents-field (get-record-field (find-containing-record ,bp) 'sage::contents))
	 (cr-inserted-p nil)
	 point-cache)
    (when (and contents-field
	       (zwei:bp-= (point)
			  (send contents-field :last-bp)))
		   (setq point-cache (insert-moving (point) #\cr))
		   (setq cr-inserted-p t))
    ,@body
    (when cr-inserted-p
      (delete-interval point-cache (end-line point-cache 1)))))

;;; Sigh.  We need this variable so we can suppress calling note-record-modified when the
;;; excess returns are being deleted from the buffer.  Of course, the right thing to do is
;;; not put them there in the first place.  i.e., excise-phantom-newlines should be part
;;; of creating the buffer contents as the sab file is being read in.
(defvar *excising-phantom-newlines* nil)

;;; Note: Changes in this routine should be also made in
;;; excise-phantom-newlines-for-srccom.  Unfortunately, these two routines do not yet
;;; share common code.
(defmethod 1(excise-phantom-newlines file-markup-buffer)0 ()
  (let ((*interval* self)
	(*excising-phantom-newlines* t))	;prevents munging during delete-interval 
    (loop for record in (send self :inferiors)
	  as field = (get-record-field record 'sage::contents)
	  do
      (when (and field 
		 (line-next-in-buffer (bp-line (send field :first-bp)) :buffer self))
	;;skip the diagram line starting the field
	(loop for previous-line = (bp-line (forward-char (send field :first-bp)))
				then line
	      for line = (line-next-in-buffer previous-line :buffer self)
		       then (line-next-in-buffer line :buffer self)
	      with last-line = (bp-line (send field :last-bp))
	      with skip = nil
	      ;; previous-line could eq last-line if contents field is empty
	      until (or (eq previous-line last-line)
			(eq line last-line)
			(null line)		;these should never happen
			(null previous-line))
	      do
	  (if skip
	      (setq skip nil)
	      (let* ((diagram-for-line (line-diagram line))
		     (markup
		       (when diagram-for-line
			 (markup-line-diagram-mixin-markup-structure diagram-for-line)))
		     (first-line-p (eq line (bp-line (node-first-bp (line-node line)))))
		     (last-line-p (eq line (bp-line (node-last-bp (line-node line)))))
		     (trailer-p (when diagram-for-line
				  (mdl-trailer-p diagram-for-line line :for-previous))))
		(when (and markup
			   (sage::maintains-connection-flags-p markup))
		  (if (and (eql (line-type previous-line) :blank)
			   diagram-for-line
			   (sage::connected-to-previous-line markup trailer-p))
		      (progn (cl:assert (or first-line-p last-line-p) ()
					"Not header or trailer!")
			     (let ((zwei:*using-connection-markers* nil))
			       (delete-interval (beg-of-line previous-line)
						(beg-of-line line)))
			     (let* ((new-previous-line (line-previous-in-buffer line))
				    (new-previous-line-diagram
				      (line-diagram new-previous-line)))
			       (if new-previous-line-diagram
				   (setf (sage::connected-to-previous-line
					   markup trailer-p)
					 t)
				   (setf (sage::connected-to-previous-line
					   markup trailer-p)
					 nil))))
		      (when markup
			(setf (sage::connected-to-previous-line markup trailer-p)
			      t)))))
	      (let* ((diagram-for-previous-line (line-diagram previous-line))
		     (markup (when diagram-for-previous-line
			       (markup-line-diagram-mixin-markup-structure
				 diagram-for-previous-line)))
		     (trailer-p (when diagram-for-previous-line
				  (mdl-trailer-p diagram-for-previous-line previous-line
						 :for-next))))
		(when (and markup
			   (sage::maintains-connection-flags-p markup))
		  (if (and (eql (line-type line) :blank)
			   diagram-for-previous-line
			   (sage::connected-to-next-line markup trailer-p))
		      (progn (let ((zwei:*using-connection-markers* nil)
				   (from (beg-of-line line))
				   (to (forward-char (beg-of-line line))))
			       (delete-interval from to))
			     (setq skip t)	;skip the next line
			     (setf (sage::connected-to-next-line markup trailer-p) nil))
		      (when markup
			(setf (sage::connected-to-next-line markup trailer-p) t)))))))))))

(defmethod 1(revert-file-markup-buffer file-markup-buffer)0 ()
  (typein-line "Reading ~a ..." pathname)
  (let ((nphases 4)				;--- Must keep up-to-date
	(current-phase 0))
    (flet ((note-progress (&key numerator (denominator 1) next-phase)
	     (when next-phase
	       (incf current-phase))
	     (when numerator
	       (tv:note-progress-in-phases numerator denominator current-phase nphases))))
      (tv:noting-progress ("Reading SAB records")
	(multiple-value-bind (list-of-record-info sab-attribute-alist closed-stream)
	    (sage::get-record-info-from-file pathname
					     :progress-note-continuation #'note-progress)
	  (let ((attribute-string
		  (or (second (cl:assoc :file-attribute-string sab-attribute-alist)) "")))
	    (let* ((major-mode (send self :major-mode))
		   (package
		     (or (pkg-find-package (major-mode-default-package major-mode) :find)
			 (if (boundp '*default-package*)
			     (symeval '*default-package*)
			     (get '*default-package* 'variable-init))
			 zwei:package)))
	      (with-input-from-string (attribute-stream attribute-string)
		(reparse-attribute-list-internal self attribute-stream)))
	    (if (eq self *interval*) (set-attribute-state-from-buffer self))
	    (let* ((cl:*package* (cl:getf (send self :property-list) :package))
		   (list-of-records (sage::install-record-info-for-editing
				      list-of-record-info
				      sab-attribute-alist
				      (sage::sab-logical-pathname-from-stream
					closed-stream)
				      #'note-progress)))
	      ;;---Sectionization?  Preserve-buffer-point?  Ticks?
	      (let ((first-record-bp (initialize-markup-buffer self)))
		(unless (string-equal attribute-string "")
		  (insert (interval-first-bp self) attribute-string))
		(let ((*interval* self))
		  (note-progress :next-phase t)
		  (loop for record in list-of-records
			with denominator = (length list-of-records)
			for count from 1
			do
		    (sage::note-record-reverted record)
		    (setq first-record-bp
			  (forward-char
			    (node-last-bp
			      (insert-record-structure-nodes record
							     :at-bp first-record-bp
							     :defer-redo-node-links T))
			    1 T))
		    (note-progress :numerator count :denominator denominator))
		  (redo-node-links *interval*)))
	      (send self :set-file-info (send closed-stream :info))
	      (when *using-connection-markers*
		(excise-phantom-newlines self))
	      (typein-line-more " ~d record~:p read" (length list-of-records)))
	    ;; return the attribute string so the external guy doesn't have to figure it out.
	    attribute-string))))))

(defun 1initialize-markup-buffer0 (buffer)
  ;; Drive an oaken stake through the heart of the undead buffers
  (dolist (node (node-inferiors buffer))
    (if (not sage::*debugging-sage*)
	(IGNORE-ERRORS
	  (sage::remove-node-for-record node))
	(sage::remove-node-for-record node)))
  (flush-bps-for-buffer buffer)
  ;; The above causes the buffer to become read-only
  (send buffer :set-read-write)
  (delete-markup-buffer-all buffer)
  ;;---Sectionization?  Preserve-buffer-point?  Ticks?
  ;; insert-record-structure-nodes needs at least two lines in the buffer.
  (let ((start-bp (copy-bp (interval-first-bp buffer))))
  (insert-moving start-bp
		 #.(scl:coerce '(#\return) 'scl:string))))

(defun-in-flavor 1(flush-record-nodes-from-registry markup-buffer)0 (&optional
								    flush-edited-records)
  ;; Remove the buffer's record nodes from the registry so that s-. won't
  ;; find the killed buffer or a node that doesn't exist.
  (dolist (node (node-inferiors self))
    (when (typep node 'record-structure-node)
      (sage::remove-node-for-record node)
      (let ((record (markup-structure-node-markup-structure node)))
	(when (and flush-edited-records
		   ;; only remove this edited record when there are
		   ;; no editor nodes associated with it.
		   (null (sage::markup-structure-node-for-record record)))
	  (sage::remove-edited-record record))))))

(defwhopper 1(:kill file-markup-buffer)0 (&optional save-p)
  (when (continue-whopper save-p)		(2 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI"); did the kill really happen?
0    (flush-record-nodes-from-registry (not (eq save-p :dont-flush-edited-records))))
  (when (eql disposition :locked)
    (unlock-sab-file pathname)))


;;; Careful reverting of file-markup-buffers.
;;; The basic idea here is to revert 2another0 buffer, then copy its contents
;;; into us.  This enables successful aborting at almost all times.
;;; Unfortunately, the editor doesn't support multiple buffers with the same name,
;;; so we must transform our buffer into a non-file-buffer and then transform it back.
;;; Oh well.  We must also be careful not to be within a method for the flavor
;;; while the transformation is happening.  This is what 1defmethod-continuation0 is for.

;;; Just shorthand.  Yecch.
(defmacro 1defmethod-continuation0 ((generic-function flavor &rest options) arglist &body body)
  (let ((continuation-name (sys:fintern "~S-INTERNAL" generic-function)))
    `(progn (defmethod (,generic-function ,flavor ,@options) ,arglist
	      (,continuation-name self ,@arglist))
	    (defun ,continuation-name ,(cons 'self arglist) ,@body))))
  
(defvar 1*debugging-sab-reverting*0 nil)		;(setq *debugging-sab-reverting* t)

(defmacro 1with-temp-file-markup-buffer-standin0 ((temp-buffer-var buffer)
						(&key when-buffer-is-standin)
						(&key when-its-come-back))
  (declare (indentation 0 3 1 2))
  `(with-temp-file-markup-buffer-standin-1
     ,buffer
     (dw:named-continuation with-temp-file-markup-buffer-standin-a (,temp-buffer-var)
       ,when-buffer-is-standin)
     (dw:named-continuation with-temp-file-markup-buffer-standin-b (,temp-buffer-var)
       ,when-its-come-back)))

(defun 1with-temp-file-markup-buffer-standin-10 (old-buffer
					       first-continuation second-continuation)
  (cl:assert (typep old-buffer 'file-markup-buffer))
  (flet ((debug-format (format-control &rest format-args)
	   (when *debugging-sab-reverting*
	     (cl:apply #'format t format-control format-args))))
    (let ((old-pathname (send old-buffer :pathname))
	  (old-name (send old-buffer :name))
	  (old-file-info (send old-buffer :file-info))
	  (temp-buffer)
	  (success))
      (unwind-protect-case ()
	  (progn
	    (debug-format "~&Transforming buffer into copy.")
	    (transform-buffer old-buffer 'non-file-markup-buffer
			      :name (format nil "Orig copy of ~A" old-name))
	    (unwind-protect
		(progn
		  (debug-format "~&Making temp buffer")
		  (setq temp-buffer (make-buffer 'file-markup-buffer :pathname old-pathname
						 :activate-p nil))
		  (debug-format "~&Funcalling 1st continuation")
		  (funcall first-continuation temp-buffer)
		  (setq success t))
	      (when temp-buffer
		(when success
		  (setq old-pathname (send temp-buffer :pathname)
			old-name (send temp-buffer :name)
			old-file-info (send temp-buffer :file-info)))
		(debug-format "~&Transforming temp buffer")
		(transform-buffer temp-buffer 'non-file-markup-buffer
				  :name
				  (format nil
					  "temp copy ~A" old-pathname)))))
	(:always
	  (debug-format "~&Transforming buffer back")
	  (transform-buffer old-buffer 'file-markup-buffer
			    :pathname old-pathname
			    :name old-name)
	  (send old-buffer :set-file-info old-file-info))
	(:normal
	  (when temp-buffer
	    (when success
	      (debug-format "~&Funcalling 2nd continuation")
	      (funcall second-continuation temp-buffer))
	    (debug-format "~&Killing temp buffer")
	    (kill-buffer temp-buffer :dont-flush-edited-records)))
	(:abort
	  (when temp-buffer
	    (debug-format "~&Killing temp buffer")
	    (kill-buffer temp-buffer t)))))))

(defmethod 1(copy-state-from-temp-buffer file-markup-buffer)0 (from-buffer attribute-string)
  (letf ((disposition nil)
	 (tick nil))

    (sys:without-aborts ("The buffer is being operated on.  If you abort now you may lose your work.")
      (let ((new-inferiors (node-inferiors from-buffer)))
	(dolist (inf inferiors)
	  (when (typep inf 'record-structure-node)
	    ;; could this be 1doc-record-modified0?
	    (unless (cl:member (markup-structure-node-markup-structure inf) new-inferiors
			       :key #'markup-structure-node-markup-structure)
	      (sage::remove-edited-record (markup-structure-node-markup-structure inf)))))
	(delete-markup-buffer-all self)
	(setq inferiors new-inferiors)
	(dolist (inf inferiors)
	  (setf (node-superior inf) self))
	(unless (string-equal attribute-string "")
	  (insert (interval-first-bp self) attribute-string))
	(reparse-attribute-list-internal self (open-interval-stream self))
	(flush-bps-for-buffer self)
	;; The above causes the buffer to become read-only
	(send self :set-read-write)
	(fix-confused-bps-in-buffer self)
	(when (eq self *interval*) (set-attribute-state-from-buffer self))
	))))

(defmethod 1(restore-ticks file-markup-buffer)0 (old-read-tick
						old-save-tick
						&optional (old-tick nil old-tick-p))
  (setq read-tick old-read-tick
	save-tick old-save-tick)
  (when old-tick-p
    (setq tick old-tick)))

(defmethod-continuation 1(careful-revert file-markup-buffer)0 (keep-modification-style?
							      old-disposition)
  (let ((old-read-tick (send self :read-tick))
	(old-save-tick (send self :save-tick))
	(old-tick (send self :tick))
	(attribute-string ()))
    (unwind-protect-case ()
	(progn
	  (with-temp-file-markup-buffer-standin (temp-buffer self)
	     (:when-buffer-is-standin (setq attribute-string
					    (revert-file-markup-buffer temp-buffer)))
	     (:when-its-come-back
	       (copy-state-from-temp-buffer self temp-buffer attribute-string))))
      (:normal
	(restore-ticks self (tick) *tick*))
      (:abort
	(setq keep-modification-style? t)
	(restore-ticks self old-read-tick old-save-tick old-tick))
      (:always
	;; these shouldn't be copied here, but they are.
	(update-modification-style self keep-modification-style? old-disposition)))))

(defmethod 1(:revert file-markup-buffer)0 ()
  (let ((keep-modification-style? nil)
	(old-disposition disposition))
    (if (> read-tick 0)				;locked or disconnected
	(unless (or (eql tick ':read-only) user-read-only-p)
	  (setq keep-modification-style?
		(typein-line-y-or-n-p "Keep the modification style for buffer ~a? "self)))
	;; must be unmodified, keeping disposition of NIL
	(setq keep-modification-style? t))
    (let ((query-io terminal-io))		;Ask questions in the typeout window
      (cond ((node-inferiors self)
	     ;; if there are inferiors, must do this real careful-like
	     (careful-revert self keep-modification-style? old-disposition))
	    (t 
	     (letf ((tick nil)
		    (disposition nil))
	       ;; Adding nodes to buffer mungs the buffer.  Set tick to nil so user
	       ;; does not get prompted for locking input.
	       (condition-case (.error.)
		    (error-restart ((error) "Retry reading of ~A from ~A" name pathname)
		      (unwind-protect-case ()
			  (revert-file-markup-buffer self)
			(:abort
			  (delete-markup-buffer-all self))))
		  (fs:file-not-found
		    (if *revert-file-not-found-is-an-error*
			(if (stringp *revert-file-not-found-is-an-error*)
			    (barf "~A~%~3T~~A~" *revert-file-not-found-is-an-error* .error.)
			    (barf "Error: ~A" .error.)))
		    (typein-line "(New File)")
		    (initialize-markup-buffer self)
		    (send self :set-file-info ':never-read)
		    (let ((generic-pathname (send pathname :generic-pathname)))
		      (send generic-pathname :set-property-list nil)	;forget junk from old loads
						;of this file.
		      (let ((error-output #'si:null-stream)
			    ;; Ignore global state
			    (ibase 10.)
			    (readtable si:*common-lisp-readtable*))
			(fs:file-attribute-bindings generic-pathname))
		      (dolist (attr '(:base :syntax))
			(let ((val (send generic-pathname :get attr)))
			  (when val
			    (send self :putprop val attr))))
		      (let ((*interval* self))
			(update-attribute-list-internal self)
			(move-bp (send self :saved-point)
				 (node-last-bp self)))
		      ))
		  (fs:file-operation-failure
		    (barf "Error: ~A" .error.)))
	       (setq read-tick (tick))
	       (setq save-tick *tick*))
	     (update-modification-style self keep-modification-style? old-disposition))))))

(defmethod 1(update-modification-style file-markup-buffer)0 (keep-modification-style?
							    old-disposition)
  (cond (keep-modification-style?
	 (setq disposition old-disposition)
	 (unless disposition
	   (setq tick ':read-only user-read-only-p nil)))
	(t ;; not keeping modification style.  Make sure buffer is unlocked
	 (when (eql old-disposition :locked)
	   (unlock-sab-file pathname))
	 (setq disposition nil)
	 (setq tick ':read-only user-read-only-p nil)))
  (sage::redisplay-ConEd-record-title-pane :force-p t))

(defmethod 1(:save file-markup-buffer)0 ()
  (flet ((try-to-lock-file (control-string pathname)
	   (if (typein-line-y-or-n-p control-string pathname)
	       (if (lock-sab-file-for-modification pathname)
		   (typein-line-more "  File locked.")
		   (typein-line-more "  Cannot lock file.")
		   (return-from :save nil))
	       (return-from :save nil))))
    (when (eq disposition :disconnected)
      (try-to-lock-file
	"Disconnected buffers cannot be saved.~%Attempt to lock file ~a? " pathname))
    (unless (file-locked-p self)
      (if (eql disposition :locked)	       ;Well, we think we have it locked, but we don't
	  ;; First, try to relock the file if the buffer is up to date.
	  (progn
	    (typein-line "You have lost the lock on file ~a." pathname)
	    (if (buffer-up-to-date self)
		(progn
		  (typein-line "Attempting to relock the file ... ")
		  (if (lock-sab-file-for-modification pathname)
		      (typein-line-more "File locked.")
		      (typein-line-more "Cannot lock file.")
		      (typein-line "Aborting save and disconnecting buffer.")
		      (setq disposition :disconnected)
		      (sage::redisplay-ConEd-record-title-pane :force-p t)
		      (return-from :save nil)))
		(setq disposition :disconnected)
		(sage::redisplay-ConEd-record-title-pane :force-p t)
		(barf "Aborting save and disconnecting buffer")))
	  (try-to-lock-file "Attempt to lock file ~a? " pathname))))
  (let ((user (non-daemon-user-id)))
    (error-restart ((error) "Retry saving ~A into ~A" name pathname)
      (multiple-value-bind (bin-file-truename closed-stream)
	  (nsage::write-list-of-records-to-sab-file
	    (loop for rec in (node-inferiors self)
		  when (typep rec 'record-structure-node)
		    collect (markup-structure-node-markup-structure rec))
	    pathname self)
	(unless (string-equal user user-id)
	  (condition-case (error)
	       (fs:change-file-properties bin-file-truename () :author user)
	     (fs:file-error (typein-line "Warning: ~A~%" error))))
	(send self :set-file-info (send closed-stream :info))
	(setq save-tick (tick))
	(unlock-sab-file pathname)
	(setq disposition nil)
	(sage::redisplay-ConEd-record-title-pane :force-p t)
	(setq tick :read-only)
	;; Move point out of any killed records since they are no longer in buffer
	(loop while (cl:typep (line-node (bp-line (point))) 'killed-record-structure-node)
	      do
	  (move-point (beg-line (forward-char (point) -1))))
	(typein-line "Written: ~A" bin-file-truename)))))

;;Called by find-file-new-buffer
(defun 1find-wt-buffer0 (pathname &optional fstream)
  (ignore fstream)
  (cond ((eql (cdr (scl:assoc (send (fs:parse-pathname pathname) :canonical-type)
			      fs:*file-type-mode-alist*))
	      :concordia)
	 (let ((buffer (make-buffer 'file-markup-buffer
				    :pathname pathname :activate-p nil)))
	   (condition-case ()
		(send buffer :revert)
	      (sage::invalid-compressed-sab-file-operation
		(barf "You cannot edit compressed SAB files")))
	   buffer))
	(T nil))) 

;; Engage a hook in FIND-FILE-NEW-BUFFER
(setq 1*find-wt-file-function*0 'find-wt-buffer)

(defmethod 1(:bp-presentation-node markup-buffer)0 (bp)
  (multiple-value-bind (at-left at-right)
      (nsage::pointy-hands-in-sage-symbol-face)
    (let* ((line (bp-line bp))
	   (index (bp-index bp))
	   (line-length (line-length line)))
      (let* ((before (and (< index line-length)
			  (scl:string-search-exact-char
			    at-left line :end (1+ index) :from-end t)))
	     (after-start (and before (1+ before)))
	     (after (and before
			 (< after-start line-length)
			 (scl:string-search-exact-char at-right line :start after-start))))
	(when (and before after ( before index after))
	  (condition-case ()
	       (add-presentation-node
		 (read-from-string line nil (1+ before) after)
		 'sys:expression
		 (create-bp line (1+ before)) (create-bp line after) nil)
	     (sys:read-error ())))))))

;;; All the actual associations between sage structure flavors and editor node flavors
;;; are in ed-glue
(defmacro 1associate-structure-flavor-with-node-flavor0 (structure-flavor node-flavor)
  `(progn
     (defmethod (markup-structure-editor-node-flavor ,structure-flavor) ()
       ',node-flavor)
     #+Ignore
     (defmethod (markup-structure-node-markup-structure-flavor ,node-flavor) ()
       ',structure-flavor)))

;;; defflavor lives in sys:nsage;sage-defs
(defmethod 1(splice-structure-in markup-structure-text-node)0 (line-before line-after)
  (declare (values first-line last-line))
;;  (check-line-continuity "before")
  (let* ((first-line (bp-line first-bp))
	 (last-line (if (or (bp-= first-bp last-bp)
			    (not (zerop (bp-index last-bp))))
			(bp-line last-bp)
			;; Half the line links are broken, so have to go forward.
			(loop for line = first-line then next
			      with limit = (bp-line last-bp)
			      as next = (line-next line)
			      when (eq next limit)
				return line
			      when (or (null next) (eq line limit))
				do (scl:break "Lost on line-next")))))
    (setf (line-next line-before) first-line)
    (setf (line-previous first-line) line-before)
    (setf (line-next last-line) line-after)
    (setf (line-previous line-after) last-line)
    (move-bp last-bp last-line (line-length last-line)); line-after 0)
    (loop for line = first-line then (line-next line)
	  do (setf (line-node line) self)
	  until (eq line last-line))
;;    (check-line-continuity "after")
    (values first-line last-line)))



(defflavor 1markup-line-diagram-mixin
0	(markup-structure)
	(line-diagram-mixin)
  :initable-instance-variables
  :writable-instance-variables)

(defgeneric 1about-to-insert-thing 0(node bp thing &optional (start 0) end)
  (:method (node :default)
   (values bp thing start end))
  (:method (markup-structure-node)
   (flet ((starts-with-cr (thing)
	    (scl:typecase thing
	      (scl:character (char-equal thing #\cr))
	      (scl:string (char-equal (aref thing start) #\cr))
	      (interval (and (char-equal (bp-char (interval-first-bp thing)) #\cr)
			     ;; suppose this came from the kill ring?
			     (not (line-sage-structure-representation
				    (bp-line (interval-first-bp thing))))))))
	  (ends-with-cr (thing)
	      (scl:typecase thing
		(scl:character (char-equal thing #\cr))
		(scl:string (char-equal (aref thing (1- (or end (string-length thing)))) #\cr))
		(interval (and (char-equal (bp-char-before (interval-last-bp thing)) #\cr)
			       ;; suppose this came from the kill ring?
			       (not (line-sage-structure-representation
				      (bp-line (interval-last-bp thing))))))))
	  (is-a-cr (thing)
	    (scl:typecase thing
	      (scl:character (char-equal thing #\cr))
	      (scl:string (let* ((real-string (substring thing start end))
				 (length (cl:length real-string)))
			    (and (= length 1)
				 (char-equal (aref real-string 0) #\CR))))
	      (interval (and (char-equal (bp-char-before (interval-last-bp thing)) #\cr)
			     ;; suppose this came from the kill ring?
			     (not (line-sage-structure-representation
				    (bp-line (interval-last-bp thing))))
			     (bp-= (interval-last-bp thing)
				   (forward-char (interval-first-bp thing)))))))

	  (shave-left (thing)
	    (scl:typecase thing
	      (scl:character nil)
	      (scl:string (incf start)
			  (substring thing start end))
	      (interval (let* ((from (interval-first-bp thing))
			      (to (forward-char from 1)))
			  (delete-interval from to)
			  thing))))
	  (shave-right (thing)
	    (scl:typecase thing
	      (scl:character nil)
	      (scl:string 
		(let ((end (or end (string-length thing))))
		  (decf end)
		  (substring thing start end)))
	      (interval (let* ((to (interval-last-bp thing))
			      (from (forward-char to -1)))
			  (delete-interval from to)
			  thing))))
	  (non-empty (thing)
	    (scl:typecase thing
	      (scl:character t)
	      (scl:string (plusp (string-length thing)))
	      (interval (not (bp-= (interval-first-bp thing)
				   (interval-last-bp thing)))))))
     (unless (and (non-empty thing)
		  *using-connection-markers*)
       (return-from about-to-insert-thing (values bp thing start end)))
     (when (or (eql :record-header-only record-view)
	       (eql :outline record-view))
       (barf "To insert text, use m-x Change Record View to change view to all fields or ~
              contents text."))
     (let* ((current-line (bp-line bp))
	    (current-line-diagram (line-diagram current-line))
	    (previous-line (line-previous-in-buffer current-line))
	    (previous-line-diagram (line-diagram previous-line)))

       ;; If the previous line is a diagram line which is run-in conected to the next line
       ;; and thing starts with a CR, shave off the CR and remove the run-in marker.
       (when (and previous-line-diagram
		  (zerop (bp-index bp))
		  (starts-with-cr thing))
	 (let ((markup-structure (markup-line-diagram-mixin-markup-structure
				   previous-line-diagram))
	       (previous-line-trailer-p
		 (mdl-trailer-p previous-line-diagram previous-line :for-next)))
	   (when (and (sage::maintains-connection-flags-p markup-structure)
		      (sage::connected-to-next-line markup-structure previous-line-trailer-p))
	     (setf (sage::connected-to-next-line markup-structure previous-line-trailer-p) nil)
	     (diagram-lines-need-redisplay (line-node previous-line) :run-in-markers-only t)
	     ;; just in case, redisplay this line as well
	     (diagram-lines-need-redisplay (line-node current-line) :run-in-markers-only t)
	     (setq thing (shave-left thing)))))
       (when (and (not current-line-diagram)
		  (= (bp-index bp) (line-length (bp-line bp))))
	 (setq current-line (line-next-in-buffer current-line)
	       current-line-diagram (line-diagram current-line)))

       ;; if the current line is a diagram line which is run-in connected to the previous
       ;; line, which is a diagram line itself, and we're only inserting a CR, we remove 
       ;; the run-in marker 2and0 insert the CR.

       (when (and current-line-diagram
		  previous-line-diagram
		  (is-a-cr thing))
	 (let ((markup-structure (markup-line-diagram-mixin-markup-structure
				   current-line-diagram))
	       (trailer-p
		 (mdl-trailer-p current-line-diagram current-line :for-previous)))
	   (when (and (sage::maintains-connection-flags-p markup-structure)
		      (sage::connected-to-previous-line markup-structure trailer-p))
	     (setf (sage::connected-to-previous-line markup-structure trailer-p) nil)
	     (diagram-lines-need-redisplay (line-node current-line) :run-in-markers-only t)
	     (return-from about-to-insert-thing (values bp thing start end)))))

       ;; If the current line is a diagram line which is run-in conected to the previous line
       ;; and thing ends with a CR, shave off the CR and remove the run-in marker.
       (when (and (non-empty thing)
		  current-line-diagram
		  (ends-with-cr thing))
	 (let* ((markup-structure (markup-line-diagram-mixin-markup-structure
				   current-line-diagram))
	       (trailer-p
		 (mdl-trailer-p current-line-diagram current-line :for-previous)))
	   (when (and (sage::maintains-connection-flags-p markup-structure)
		      (sage::connected-to-previous-line markup-structure trailer-p))
	     (setf (sage::connected-to-previous-line markup-structure trailer-p) nil)
	     (diagram-lines-need-redisplay (line-node current-line) :run-in-markers-only t)
	     (setq thing (shave-right thing)))))
       (values bp thing start end)))))

(defmethod 1(insert-1 markup-buffer)0 (bp string &optional (string-start 0) string-length)
  (when (and string (bp-node bp))
    (multiple-value (bp string string-start string-length)
      (about-to-insert-thing (bp-node bp) bp string string-start string-length)))
  (if string
      (insert-2 bp string string-start string-length)
      bp))
				    
;;; Copy of default method on line-diagram-mixin, changed to do the insertion
;;; at the end of the last line in the previous text node.
;;; This may cause any BP's that pointed to the diagram line to move in non-standard
;;; ways, but maybe they are the right ways.
(defmethod 1(:editor-insert markup-line-diagram-mixin)0 (line index thing from to)
  ;; 2thing,from,to0 are 2string,index,index0 or 2interval,bp,bp
0  ;; Only insert at the start of the diagram line (although I don't know how we could
  ;; be told to insert anywhere else).  If the previous line is in a text node,
  ;; actually insert at the end of it (first inserting a cr if the new stuff doesn't
  ;; start with one).  If the previous line isn't in a text node, barf.
  (ignore index)
  #+Franz ;;This conflicts with having Bill's searchable text "in" the diagram line
  (unless (zerop index)
    (barf "Cannot insert into a diagram line."))
  (let* ((node (line-node line))
	 (prev-line (line-previous-in-buffer line))
	 (prev-line-node (line-node prev-line)))
    (scl:etypecase prev-line-node
      (markup-structure-text-node
	(let ((bp (create-bp prev-line (line-length prev-line))))
	  ;; Need to insert a cr unless what's being inserted starts with one
	  (unless (scl:typecase thing
		    (scl:character (char-equal thing #\cr))
		    (scl:string (char-equal (aref thing from) #\cr))
		    (interval (char-equal (bp-char from) #\cr)))
	    (setq bp (insert-moving bp #\cr))
	    (must-redisplay *window* dis-text))
	  (insert bp thing from to)))
      (markup-structure-node
	;;--- assume that THING can always be "substringed"
	;; (don't know how to assert that, since characters and intervals can be)
	(create-new-text-node line node prev-line-node thing from to))
      (markup-buffer
	;; POINT is on first diagram in buffer, so previous line's node is the
	;; buffer.  Insert the THING into the random text lines at the beginning
	;; of the buffer.
	(let ((last-bp-of-random-text (forward-char (node-first-bp node) -1)))
	  (insert last-bp-of-random-text thing from to))))))

(defun 1create-new-text-node0 (current-line current-line-node previous-line-node thing from to)
  (when (or (eql thing #\return)
	    (cl:equalp thing #.(scl:coerce '(#\return) 'scl:string)))
    ;; This code effectively creates a blank line already
    (setq thing "" from 0 to 0))
  ;; create an empty text node
  ;;--- there must be some generic way to do this
  (flet ((make-text-structure (superior-structure &key check-superior-structure-type-p)
	   (when (and check-superior-structure-type-p
		      (typep superior-structure 'sage::record-field))
	     (zwei:barf "Text may not be added between the fields of a record."))
	   (let* ((text-struc (nsage::make-sage-text-structure-from-string
				"" superior-structure))
		  (interval (nsage::sage-text-structure-interval text-struc)))
	     (move-nonboundary-bps-of-line-to current-line (node-first-bp interval))
	     ;; Note insertion of that blank line
	     (mung-bp-interval (node-last-bp interval))
	     (prepare-to-insert (node-last-bp interval) t)
	     ;; Undo effect on change-record-last-bp of move-nonboundary-bps-of-line-to
	     (let* ((bp (create-bp current-line 0))
		    (buffer (bp-change-recording-buffer bp))
		    (change (and buffer (first (buffer-change-history buffer)))))
	       (when (and change (bp-= (change-record-last-bp change) (node-last-bp interval)))
		 (move-bp (change-record-last-bp change) bp)))
	     (insert (interval-last-bp interval) thing from to)
	     text-struc)))
    (let ((superior-node nil)
	  (new-text-structure))
      (cond ((eq previous-line-node current-line-node)
	     ;; between the diagram lines of an empty node
	     (let ((markup-structure
		     (markup-structure-node-markup-structure previous-line-node)))
	       (setq new-text-structure (make-text-structure markup-structure))
	       (cl:assert (null (nsage::directive-inferiors markup-structure)))
	       (setf (nsage::directive-inferiors markup-structure)
		     (list new-text-structure)))
	     (setq superior-node (node-superior current-line-node)))
	    ((eq previous-line-node (node-superior current-line-node))
	     (let ((markup-structure
		     (markup-structure-node-markup-structure current-line-node)))
	       (setq new-text-structure
		     (make-text-structure markup-structure :check-superior-structure-type-p t))
	       (nsage::insert-structure-near-sibling
		 new-text-structure :before markup-structure))
	     (setq superior-node previous-line-node))
	    ((eq current-line-node (node-superior previous-line-node))
	     (let ((markup-structure
		     (markup-structure-node-markup-structure previous-line-node)))
	       (setq new-text-structure
		     (make-text-structure markup-structure :check-superior-structure-type-p t))
	       (nsage::insert-structure-near-sibling
		 new-text-structure :after markup-structure))
	     (setq superior-node current-line-node))
	    (t					; between same-level nodes
	     (unless (typep (node-superior current-line-node)
			    'markup-structure-node)
	       (if (typep current-line-node 'record-structure-node)
		   (zwei:barf "You may only add text within records, not between.")
		   (zwei:barf "Can't insert text between non-markup diagrams.")))
	     (let ((markup-structure
		     (markup-structure-node-markup-structure current-line-node)))
	       (setq new-text-structure
		     (make-text-structure markup-structure :check-superior-structure-type-p t))
	       (nsage::insert-structure-near-sibling
		 new-text-structure :before markup-structure))
	     (setq superior-node (node-superior current-line-node))))
      (let ((new-text-node (nsage::sage-text-structure-interval new-text-structure)))
	(insert-markup-structure-nodes
	  (markup-structure-node-markup-structure superior-node)
	  :in-place-of-node superior-node)
	(node-last-bp new-text-node)))))

#|| ;; old parts
(3 0 (NIL 0) (NIL NIL :SMALL) "TVFONT")  (if (and (zerop index)			;inserting at beginning of diagram line
	   (scl:typecase thing
	     (scl:character (char-equal thing #\cr))	;inserting a newline
	     (scl:string
	       (or (= from to)			;inserting nothing
		   (char-equal (aref thing (1- to)) #\cr)))	;insertion ends with cr
	     (interval (bp-= from to))))
      (let ((prev-line (line-previous-in-buffer line)))
	(if (not (typep (line-node prev-line) 'markup-structure-text-node))
	    ;; handle case where we have to create a new sage-text-structure and text node
	    ;; between diagram lines later
	    (progn
	      (cl:assert (characterp thing))
	      (barf "Don't know how to create new text between diagrams yet"))
	    (insert (create-bp prev-line (line-length prev-line))
		    thing from to)))
      (barf "Cannot insert into a diagram line."))
0||#

;;; When copying an interval containing diagrams, the diagrams
;;; just go away.
(defmethod 1(:editor-copy markup-line-diagram-mixin)0 ()
  nil)

;;; markup-structure-node is defined in sys:nsage;defs-directives
(defmethod 1(markup-margin-indentation markup-structure-node)0 () 0)

(defmethod 1(markup-header-diagram markup-structure-node)0 () nil)
(defmethod 1(markup-trailer-diagram markup-structure-node)0 () nil)

;;; This is the place to do LBE type incremental things, if any.
(defmethod 1(check-line-node-structure markup-structure-node)0 (ignore) )


(defflavor 1delimited-markup-structure-node0 (header-line trailer-line) (markup-structure-node))

(defmethod 1(make-instance delimited-markup-structure-node :after)0 (&rest ignore)
  (multiple-value-bind (top-diagram bottom-diagram)
      (markup-structure-both-diagrams self)
    (setq header-line (and top-diagram (make-diagram-line top-diagram))
	  trailer-line (and bottom-diagram (make-diagram-line bottom-diagram)))
    (setq first-bp nil last-bp nil)
    (when header-line
      (setf (line-node header-line) self)
      (setq first-bp (create-bp header-line 0 :normal)))
    (when trailer-line
      (setf (line-node trailer-line) self)
      (setq last-bp (create-bp trailer-line 0 :moves)))
    (cond (first-bp
	   (when (null last-bp)
	     (setq last-bp (copy-bp first-bp :moves))))
	  (last-bp
	   (setq first-bp (copy-bp last-bp :normal)))
	  (T
	   (when sage::*debugging-sage*
	     (scl:cerror "Make up an empty line"
			 "No first- or last-bp?"))
	   (let ((line (create-line 'art-string 0 self)))
	     (setq first-bp (create-bp line 0 :normal)
		   last-bp (create-bp line 0 :moves)))))))

(defgeneric 1diagram-lines-need-redisplay0 (node &key run-in-markers-only) )

(defmethod 1(diagram-lines-need-redisplay markup-structure-node :default)
0	   (&key run-in-markers-only)
  ;; do nothing.
  (ignore run-in-markers-only))

(defmethod 1(diagram-lines-need-redisplay delimited-markup-structure-node)
0	   (&key run-in-markers-only)
  ;; Don't invalidate-cached-title-string if we're redrawing the run-in markers only
  (when header-line
    (mung-line header-line)
    (unless run-in-markers-only
      (invalidate-cached-title-string (line-diagram header-line))))
  (when trailer-line
    (mung-line trailer-line)
    (unless run-in-markers-only
      (invalidate-cached-title-string (line-diagram trailer-line))))
  (zwei:must-redisplay *window* dis-text))
;;; ================================================================
;;; zwei node structure and diagram lines for Sage record

(defflavor 1record-structure-node
0	((total-indentation 0)
	 (patch-tick nil))
	(delimited-markup-structure-node)
  (:writable-instance-variables patch-tick))

;--- Zmacs bug
(defmethod 1(:function-spec record-structure-node)0 () )
(defmethod 1(:definition-type record-structure-node)0 () )

(defmethod 1(get-record-field record-structure-node)0 (field-name)
  (cl:find field-name inferiors
	   :key #'(lambda (field)
		    (let ((m-s (markup-structure-node-markup-structure field)))
		      (send m-s :envr-name)))))

(defmethod 1(:mung record-structure-node :after)0 (&rest ignore)
  (let ((home-buffer-node (nsage::find-home-node-for-record markup-structure)))
    ;; nsage::find-home-node-for-record already errors if it can't find the right node
    (when home-buffer-node
      (send (node-superior home-buffer-node) :mung nil)))
  (unless *excising-phantom-newlines*
    (nsage::note-record-modified markup-structure)))

(defflavor 1killed-record-structure-node
0	()
	(delimited-markup-structure-node))

;;; Why?
(defmethod 1(markup-margin-total-indentation killed-record-structure-node)0 ()
  0)

;;; Methods common to record-structure-node and killed-record-structure-node
(defmethod 1(:record-unpatched-p record-structure-node)0 (read-tick)
  (let ((node-tick (node-tick self)))
    (when (> node-tick read-tick)
      (let ((patch-tick (record-structure-node-patch-tick self)))
	(or (null patch-tick)
	    (> node-tick patch-tick))))))

(defmethod 1(:record-unpatched-p killed-record-structure-node)0 (read-tick)
  (ignore read-tick)
  (let ((rec markup-structure))
    (and (not (sage::killed-record-patched-p rec))
	 (sage::record-group-published-record
	   (sage::killed-record-dead-record-group rec)))))

(defvar 1*patched-record-hash-table*0 (cl:make-hash-table))
(defvar 1*patch&renamed-record-table*0 (cl:make-hash-table :test 'cl:equal))

(defmethod 1(:set-patched-p record-structure-node)0 ()
  (setf (gethash (sage::doc-record-record-group markup-structure)
		 *patched-record-hash-table*)
	*current-patch*)
  (setf (record-structure-node-patch-tick self)
	(node-tick self)))

(defmethod 1(:set-patched-p killed-record-structure-node)0 ()
  (setf (sage::killed-record-patched-p markup-structure) t)
  (diagram-lines-need-redisplay self))

(defgeneric 1record-node-p0 (node)
  (:method (record-structure-node) t)
  (:method (killed-record-structure-node) t)
  (:method (node) nil))

(defgeneric 1record-node-record-group0 (node)
  (:method (record-structure-node)
   (let* ((record markup-structure)
	  (record-group (sage::doc-record-record-group record)))
     record-group))
  (:method (killed-record-structure-node)
   (sage::killed-record-dead-record-group zwei:markup-structure)))

(defvar 1*cached-title-string-tick*0 0)

;; Use this to invalidate everything, like if it's too much trouble
;; to find everything with some caching
(defun 1invalidate-cached-title-strings0 ()
  (incf *cached-title-string-tick*))

(defgeneric 1recompute-cached-title-10 (title-string-cached-title-mixin)
  (:method-combination :case))

(defstruct 1(title-cache :list :conc-name)
0  tick type string)

(defflavor 1title-string-cached-title-mixin0 ((cached-title))
	   ()
  (:required-methods recompute-cached-title-1)
  )

;; Use this to invalidate one thing, like if its view has changed
(defgeneric 1invalidate-cached-title-string0 (title-string-cached-title-mixin)
  (:method-combination :progn))

(defmethod 1(invalidate-cached-title-string markup-line-diagram-mixin :default)0 ()
  ())

(defmethod 1(invalidate-cached-title-string title-string-cached-title-mixin)0 ()
  (setq cached-title nil))

(defmethod 1(invalidate-cached-title-string delimited-markup-structure-node)0 ()
  (let ((first-line (bp-line first-bp))
	(last-line (bp-line last-bp)))
    (let ((first-line-diagram (line-diagram first-line)))
      (when first-line-diagram
	(invalidate-cached-title-string first-line-diagram)
	(mung-line first-line)))
    (unless (eq last-line first-line)
      (let ((last-line-diagram (line-diagram last-line)))
	(when last-line-diagram
	  (invalidate-cached-title-string last-line-diagram)
	  (mung-line last-line))))))

(defmethod 1(recompute-cached-title title-string-cached-title-mixin)0 (&key type)
  (let ((string (recompute-cached-title-1 self type)))
    (setq cached-title (make-title-cache tick *cached-title-string-tick*
					 type type
					 string string))
    string))

(defmethod 1(make-instance title-string-cached-title-mixin :after)0 (&rest ignore)
  ;;---ignore-errors?  After all, it's just trying to compute it while everything
  ;;is already paged in
  (recompute-cached-title self))

;; This is the method that things call when they want a title string
(defmethod 1(cached-title-string title-string-cached-title-mixin)0 (&key type)
  (cond ((atom cached-title)			;nil, or string (the latter for compatibility)
	 (recompute-cached-title self :type type))
	((and (eql (title-cache-tick cached-title) *cached-title-string-tick*)
	      (eql (title-cache-type cached-title) type))
	 (or (title-cache-string cached-title)
	     (recompute-cached-title self :type type)))
	(T (recompute-cached-title self :type type))))

(defflavor 1record-header-line
0	((view :header))
	(;structural-line-diagram-mixin
	 mouse-sensitive-diagram-mixin
	 title-string-cached-title-mixin
	 markup-line-diagram-mixin)
  )

(defconst 1*extra-record-header-line-headroom*0 16)

(defmethod 1(:editor-height record-header-line)0 (window ignore)
  (+ 8 *extra-record-header-line-headroom*
     (scl:with-character-style ('(:dutch :roman :large) window :bind-line-height t)
       (send window :line-height))
     (scl:ecase view
       (:header 0)
       ;;---more coming
       )))

(defconst 1*record-header-line-width*0 400.)

(defun trailer-p-1 (line direction)
  (let ((line-node (line-node line)))
    (cl:assert line-node () "Line does not hase an associated line node ~a" line)
    ;; We can use trailer-p for connected-to-previous-line purposes
    ;; if it's either the first or the last line but not both.  Otherwise
    ;; the line is a header.
    (let ((first-line (eq line (bp-line (node-first-bp line-node))))
	  (last-line (eq line (bp-line (node-last-bp line-node)))))
      (if (and (eql direction :for-previous)
	       first-line last-line)
	  nil
	  last-line))))

(defvar 1*show-invisible-connection-markers*0 nil)

(defmethod 1(draw-continuation-markers markup-line-diagram-mixin)0 (window line x y)
  (let ((x-left (- x 6))
	(x-middle (- x 4))
	(x-right (- x 2))
	(y-upper-top (+ y 3))
	(y-upper-bottom (+ y 5))
	(y-lower-top (+ y 8))
	(y-lower-bottom (+ y 10)))

    ;; draw ^
    (when (and (sage::maintains-connection-flags-p markup-structure)
	       (sage::connected-to-previous-line markup-structure
						 (mdl-trailer-p self line :for-previous))
	       ;; yecch.  Slow this down to a crawl
	       (let* ((previous-line (line-previous-in-buffer line))
		      (previous-line-diagram (when previous-line
					       (line-diagram previous-line))))
		 (if (cl:getf (line-plist line) :suppress-connection-to-previous-line nil)
		     nil
		     (or (null previous-line-diagram )
			 *show-invisible-connection-markers*
			 (let* ((previous-markup
				  (markup-line-diagram-mixin-markup-structure
				    previous-line-diagram))
				(trailer-p (mdl-trailer-p previous-line-diagram
							  previous-line :for-next)))
			   (sage::connected-to-next-line previous-markup trailer-p))))))
						   
      (send window :draw-line x-left y-upper-bottom x-middle y-upper-top)
      (send window :draw-line x-middle y-upper-top x-right y-upper-bottom))

    ;; draw v
    (when (and (sage::maintains-connection-flags-p markup-structure)
	       (sage::connected-to-next-line markup-structure
					     (mdl-trailer-p self line :for-next)))
      (send window :draw-line x-left y-lower-top x-middle y-lower-bottom)
      (send window :draw-line x-middle y-lower-bottom x-right y-lower-top))))

(defwhopper 1(:editor-draw markup-line-diagram-mixin)0 (line window x y)
  (when (sage::maintains-connection-flags-p markup-structure)
    (draw-continuation-markers self window line x y))
  (continue-whopper line window x y))


(defmethod 1(:editor-draw record-header-line)0 (line window x y)
  (scl:ecase view
    (:header (record-header-line-editor-draw
	       self line window x (+ y *extra-record-header-line-headroom*)))
    ;;---More coming:
    ;; nearly nothing;
    ;; showing record fields (keywords, oneliner,...)
    ))

(defmethod 1(recompute-cached-title-1 record-header-line :otherwise)0 (ignore)
  (record-description markup-structure nil))

(defmethod 1(record-header-line-editor-draw record-header-line)0 (line window x y)
  (incf x 1) (incf y 1)
  (scl:with-character-style ('(:dutch :roman :large) window :bind-line-height t)
    (let ((line-height (send window :line-height)))
      (send window :draw-rectangle 2 line-height x (1+ y))
      (send window :draw-rectangle *record-header-line-width* 2  x y)
      (send window :set-cursorpos (+ x 4) (+ y 2))
      (dw:with-output-as-presentation (:stream window :object (line-node line)
					       :type (typep (line-node line)))
	(scl:write-string (cached-title-string self) window)))))

(defmethod 1(record-structure-topic-name-and-type nsage::doc-record)0 ()
  nsage::
  (values (appropriate-title-rendering record-group 'no-formatting self)
	  (string-capitalize-words source-type)))

(defflavor 1record-trailer-line
0	((cached-title))
	(mouse-sensitive-diagram-mixin
	 title-string-cached-title-mixin
	 markup-line-diagram-mixin)
  )

(defmethod 1(recompute-cached-title-1 record-trailer-line :otherwise)0 (ignore)
  (multiple-value-bind (title ignore)
      (record-structure-topic-name-and-type markup-structure)
    (format nil "End of ~S record" title)))

(defmethod 1(:editor-draw record-trailer-line)0 (line window x y)
  (incf x 1)
  (scl:with-character-style ('(:dutch :roman :normal) window :bind-line-height t)
    (send window :draw-rectangle 2 (send window :line-height) x y)
    (let ((name (cached-title-string self)))
      (let ((width (1+ *record-header-line-width*)))
	(send window :draw-rectangle width 2 x (+ y (send window :line-height) -2))
	(send window :set-cursorpos (+ x 4) y))
      (dw:with-output-as-presentation (:stream window :object (line-node line)
					       :type (typep (line-node line)))
	(cl:write-string name window)))))

(defmethod 1(markup-header-diagram record-structure-node)0 ()
  (make-instance 'record-header-line :markup-structure markup-structure))

(defmethod 1(markup-trailer-diagram record-structure-node)0 ()
  (make-instance 'record-trailer-line :markup-structure markup-structure))

;;; === Killed records
(defflavor 1killed-record-diagram-line0 ()
	   (markup-line-diagram-mixin
	    title-string-cached-title-mixin
	    mouse-sensitive-diagram-mixin)
  )

(defmethod 1(recompute-cached-title-1 killed-record-diagram-line :otherwise)0 (ignore)
  (let ((dead-rg (sage::killed-record-dead-record-group markup-structure)))
    (with-output-to-string (cl:*standard-output*)
      (cl:write-string "Undocumented ")
      (format t "~:(~A~) " (sage:record-group-type dead-rg))
      (cl:write-char #/")
      (scl:present dead-rg 'sage:record-group)
      (cl:write-char #/"))))

(defmethod 1(:editor-height killed-record-diagram-line)0 (window ignore)
  (+ 8
     *extra-record-header-line-headroom*
     (max
       (let ((font (send tv:main-screen :parse-font-descriptor 'fonts:concordia-glyphs)))
	 (zl:font-char-height font))
       (scl:with-character-style ('(:dutch :roman :large) window :bind-line-height t)
	 (send window :line-height)))))

(defmethod 1(:editor-draw killed-record-diagram-line)0 (line window x y)
  (ignore line)
  (incf x 1) (incf y 1)
  (incf y *extra-record-header-line-headroom*)
  (dw:with-output-as-presentation (:stream window
				   :object (line-node line)
				   :type (cl:type-of (line-node line)))
  (let ((font (send tv:main-screen :parse-font-descriptor 'fonts:concordia-glyphs)))
    (flet ((draw-it (stream)
	     (graphics:draw-glyph (char-code #\K) font (+ x 5) (+ y 5) :stream stream)))
      (let ((glyph-width (dw:continuation-output-size #'draw-it window)))
	(draw-it window)
	(scl:with-character-style ('(:dutch :roman :large) window :bind-line-height t)
	  (let* ((line-height (max (zl:font-char-height font) (send window :line-height)))
		 (min-right (+ x 1))
		 (max-right (+ x 1 *record-header-line-width*))
		 (min-top (+ y 1))
		 (max-bottom (+ y line-height 5)))
	    (with-stack-list (points 
			       max-right max-bottom
			       min-right max-bottom
			       min-right min-top
			       max-right min-top)
	      (graphics:draw-lines points :thickness 2 :stream window))
	    (send window :set-cursorpos (+ x 4 glyph-width) (+ y 6))
	    (cl:write-string (cached-title-string self) window)
	    (unless (sage::killed-record-patched-p markup-structure)
	      (cl:write-string " (Unpatched)" window)))))))))

(defmethod 1(markup-header-diagram killed-record-structure-node)0 ()
  (make-instance 'killed-record-diagram-line :markup-structure markup-structure))
;;; ================================================================
(defflavor 1doc-record-field-structure-node0 () (delimited-markup-structure-node))

(defmethod 1(markup-header-diagram doc-record-field-structure-node)0 ()
  (make-instance 'environment-header-line :markup-structure markup-structure))

(defmethod 1(markup-trailer-diagram doc-record-field-structure-node)0 ()
  (make-instance 'environment-header-line
		 :markup-structure markup-structure
		 :trailer-p t))

(defmethod 1(make-instance doc-record-field-structure-node :after)0 (&rest ignore)
  ;; --- We need a sub-zwei:insert way of putting text in this diagram line's
  ;; line string.  Is this it?
  ;;--- we can't deal with text in diagram lines 'cause it confuses things
  ;; line control-D at the beginning of the line.
  #+ignore
  (progn
    (array-push-portion-extend
      header-line
      (string (nsage::record-field-field-name markup-structure)))
    (array-push-portion-extend
      trailer-line
      (string (nsage::record-field-field-name markup-structure)))))

(defmethod 1(markup-margin-indentation doc-record-field-structure-node)0 () 30)


;;; ================================================================
;;; zwei node structure and diagram lines for Sage environment structure

(defflavor 1environment-structure-node0 () (delimited-markup-structure-node))

(defmethod 1(make-instance environment-structure-node :after)0 (&rest ignore)
  ;; --- We need a sub-zwei:insert way of putting text in this diagram line's
  ;; line string.  Is this it?
  ;; --- should we do trailer lines as well?
  #+ignore
  ;;--- Non-zero length diagram lines aren't considered for mouse sensitivity.
  ;; Take out the "hidden text" until we fix the underlying ZWEI bug.
  (array-push-portion-extend
    header-line
    (string (send markup-structure :envr-name))))

(defmethod 1(print-markup-structure-node environment-structure-node)0 (stream &key acceptably)
  (ignore acceptably)
  (let* ((envr-name (send markup-structure :envr-name))
	 (pretty-name (sage::directive-pretty-name envr-name)))
    (format stream "~A environment" pretty-name)))

(defflavor 1environment-header-line
0	((trailer-p nil))
	(;structural-line-diagram-mixin
	 mouse-sensitive-diagram-mixin
	 title-string-cached-title-mixin
	 markup-line-diagram-mixin)
  (:readable-instance-variables trailer-p)
  :initable-instance-variables)

(defgeneric 1environment-header-line-p0 (diagram node)
  (:method (markup-line-diagram-mixin :default) (ignore node) nil)
  (:method (environment-header-line) (ignore node) t))


(defmethod 1(:editor-height environment-header-line)0 (window ignore)
  (+ 4
     (scl:with-character-style ('(:dutch :roman :very-small) window :bind-line-height t)
       (send window :line-height))))

(defmethod 1(recompute-cached-title-1 environment-header-line :otherwise)0 (ignore)
  (let* ((mods (send-if-handles markup-structure :envr-mods))
	 (name (send markup-structure :envr-name))
	 (pretty-name (sage::directive-pretty-name name)))
    (sys:with-stack-array (name (+ (scl:length pretty-name) (if mods 4 0)) ;4 = (length " ...")
				:element-type (scl:array-element-type pretty-name)
				:fill-pointer (scl:length pretty-name))
      (cl:replace name pretty-name)
      (when mods (string-nconc name " ..."))
      (scl:copy-seq name))))

(defmethod 1(:editor-draw environment-header-line)0 (line window x y)
  (scl:with-character-style ('(:dutch :roman :very-small) window :bind-line-height t)
    (send window :draw-rectangle 1 (send window :line-height) x (1+ y))
    (let ((name (cached-title-string self)))
      (let ((width (+ (send window :string-length name) 4)))
	(cond (trailer-p
	       (send window :draw-rectangle width 1 x (+ y (send window :line-height)))
	       (send window :set-cursorpos (+ x 2) y))
	      (t
	       (send window :draw-rectangle width 1 x y)
	       (send window :set-cursorpos (+ x 2) (+ y 2)))))
      (dw:with-output-as-presentation (:stream window
				       :object (line-node line)
				       :type (typep (line-node line)))
	(send window :string-out name)))))

(defmethod 1(markup-header-diagram environment-structure-node)0 ()
  (make-instance 'environment-header-line :markup-structure markup-structure))

(defmethod 1(markup-trailer-diagram environment-structure-node)0 ()
  (make-instance 'environment-header-line :markup-structure markup-structure :trailer-p t))

(defmethod 1(markup-margin-indentation environment-structure-node)0 () 30)

;;; ================================================================
;;; zwei node structure and diagram lines for Sage command structure

(defflavor 1command-structure-node0 () (delimited-markup-structure-node))

(defmethod 1(markup-header-diagram command-structure-node)0 ()
  (make-instance 'command-diagram-line
		 :markup-structure markup-structure))

(defmethod 1(print-markup-structure-node command-structure-node)0 (stream &key acceptably)
  (ignore acceptably)
  (let* ((command-name (send markup-structure :command-name))
	 (pretty-name (sage::directive-pretty-name command-name)))
    (format stream "~A command" pretty-name)))

(defflavor 1command-diagram-line0 ()
	   (markup-line-diagram-mixin
	    title-string-cached-title-mixin
	    mouse-sensitive-diagram-mixin))

(defmethod 1(recompute-cached-title-1 command-diagram-line :otherwise)0 (ignore)
  (with-output-to-string (stream)
    (sage::basic-command-editor-diagram-draw markup-structure stream)))

(defmethod 1(:editor-draw command-diagram-line)0 (line window x y)
  (send window :set-cursorpos (1+ x) (1+ y))
  (cl:write-char #\arrow:right-hand window)  ;perhaps belongs in line margin
  (dw:with-output-as-presentation (:stream window
				   :object (line-node line)
				   :type (typep (line-node line)))
    (scl:write-string (cached-title-string self) window)))

;;; ================================================================
;;; zwei node structure and diagram lines for "editable" Sage command structure

(defflavor 1editable-command-structure-node0 () (delimited-markup-structure-node))

(defmethod 1(markup-header-diagram editable-command-structure-node)0 ()
  (make-instance 'editable-command-header-line :markup-structure markup-structure))

(defmethod 1(markup-trailer-diagram editable-command-structure-node)0 ()
  (make-instance 'environment-header-line
		 :markup-structure markup-structure
		 :trailer-p t))

(defmethod 1(markup-margin-indentation editable-command-structure-node)0 () 30)

(defmethod 1(print-markup-structure-node editable-command-structure-node)0 (stream
									   &key acceptably)
  (ignore acceptably)
  (let* ((command-name (send markup-structure :command-name))
	 (pretty-name (sage::directive-pretty-name command-name)))
    (format stream "~A command" pretty-name)))

(defflavor 1editable-command-header-line0 ((cache-of-title))
	   (mouse-sensitive-diagram-mixin 
	    markup-line-diagram-mixin)
  :initable-instance-variables)

(defmethod 1(cached-title-string editable-command-header-line)0 (&rest ignored)
  (or cache-of-title
      (string (sage::editable-sage-command-command-name markup-structure))))

(defmethod 1(environment-header-line-p editable-command-header-line)0 (node)
  (eq (markup-structure-node-node-view node) ':expanded))

(defmethod 1(environment-header-line-trailer-p editable-command-header-line)0 ()
  nil)

(defmethod 1(:editor-draw editable-command-header-line)0 (line window x y)
  (let ((view (or (and (line-node line)
		       ;; if no node, don't blow up
		       (markup-structure-node-node-view (line-node line)))
		  ':normal)))
    (cl:ecase view
      (:normal
	(send window :set-cursorpos (1+ x) (1+ y))
	(dw:with-output-as-presentation (:stream window
					 :object (line-node line)
					 :type (cl:type-of (line-node line))
					 :dont-snapshot-variables (cache-of-title))
	  (cl:write-char #\arrow:right-hand window)	;perhaps belongs in line margin
	  (let ((string
		  (with-output-to-string (window)
		    (sage::format-sage-command-for-title markup-structure window)
		    )))
	    (setq cache-of-title string)
	    (cl:write-string string window))))
      (:expanded
	(scl:with-character-style ('(:dutch :roman :very-small) window :bind-line-height t)
	  (send window :draw-rectangle 1 (send window :line-height) x (1+ y))
	  (let* ((envr-name (send markup-structure :envr-name))
		 (pretty-name (sage::directive-pretty-name envr-name)))
	    (setq cache-of-title (cl:copy-seq pretty-name))
	    (let ((width (+ (send window :string-length pretty-name) 4)))
	      (send window :draw-rectangle width 1 x y)
	      (send window :set-cursorpos (+ x 2) (+ y 2)))
	    (dw:with-output-as-presentation (:stream window
					     :object (line-node line)
					     :type (cl:type-of (line-node line)))
	      (send window :string-out pretty-name))))))))

(defmethod 1(:editor-height editable-command-header-line)0 (window line)
  (let ((view (let ((line-node (line-node line)))
		(if line-node
		    (markup-structure-node-node-view (line-node line))
		    :normal))))
    (cl:ecase view
      (:normal (send window :line-height))
      (:expanded
	(+ 4
	   (scl:with-character-style ('(:dutch :roman :very-small) window :bind-line-height t)
	     (send window :line-height)))))))

(defflavor 1sage-command-contents-field-structure-node0 ()
	   (delimited-markup-structure-node))

(defmethod 1(markup-header-diagram sage-command-contents-field-structure-node)0 ()
  (make-instance 'environment-header-line :markup-structure markup-structure))

(defmethod 1(markup-trailer-diagram sage-command-contents-field-structure-node)0 ()
  (make-instance 'environment-header-line
		 :markup-structure markup-structure
		 :trailer-p t))

(defmethod 1(markup-margin-indentation sage-command-contents-field-structure-node)0 ()
  30)

(defflavor 1sage-command-any-keys-field-structure-node0 ()
	   (delimited-markup-structure-node))

(defmethod 1(markup-header-diagram sage-command-any-keys-field-structure-node)0 ()
  (make-instance 'sage-command-arg-diagram-line :markup-structure markup-structure))

(defflavor 1sage-command-any-keys-contents-list-field-structure-node0 ()
	   (sage-command-contents-field-structure-node))

(defflavor 1sage-command-arg-structure-node0 () (delimited-markup-structure-node))

(defmethod 1(markup-header-diagram sage-command-arg-structure-node)0 ()
  (make-instance 'sage-command-arg-diagram-line :markup-structure markup-structure))

(defflavor 1sage-command-arg-diagram-line0 ((cache-of-title))
	   (markup-line-diagram-mixin
	    mouse-sensitive-diagram-mixin))

(defmethod 1(cached-title-string sage-command-arg-diagram-line)0 (&rest ignored)
  (or cache-of-title
      (setq cache-of-title
	    (with-output-to-string (stream)
	      (sage::present-sage-command-arg-field markup-structure stream 'ignored)))))

(defmethod 1(:editor-draw sage-command-arg-diagram-line)0 (line window x y)
  (send window :set-cursorpos (1+ x) (1+ y))
  (setq cache-of-title
	(with-output-to-string (cl:*standard-output*)
	  (sage::present-sage-command-arg-field markup-structure cl:*standard-output*
						(line-node line))))
  (sage::present-sage-command-arg-field markup-structure window (line-node line)))

;;; ================================================================
;;; zwei node structure and diagram lines for Sage reference structure

(defflavor 1reference-structure-node
0	((expanded-in-line nil))
	(title-string-cached-title-mixin
	 delimited-markup-structure-node)
  :settable-instance-variables)

(defmethod 1(recompute-cached-title-1 reference-structure-node :otherwise)0 (ignore)
  ())

(defmethod 1(recompute-cached-title-1 reference-structure-node generated)0 ()
  (cl:cerror "Proceed without any special action"
	  "This was not called as of 28 Jul 88 and needs to be upgraded. -- (Internal error)")
  #+Ignore
  (let* ((record-group 
	   (nsage::sage-reference-record-group markup-structure))
	 (title (nsage::appropriate-title-rendering	;---would like to run formatter
		  record-group 'nsage::no-formatting))
	 (generated-prologue
	   (nsage::filtered-string-from-contents-list
	     (nsage::crossref-prologue-contents-list-for-record-group record-group)))
	 (generated-epilogue
	   (nsage::filtered-string-from-contents-list
	     (nsage::crossref-epilogue-contents-list-for-record-group record-group))))
    (format nil "~A~A~A" generated-prologue title generated-epilogue)))

(defmethod 1(recompute-cached-title-1 reference-structure-node expandable)0 ()
  (let* ((record-group (nsage::sage-reference-record-group markup-structure))
	 (title (nsage::appropriate-title-rendering	;---would like to run formatter
		  record-group 'nsage::no-formatting))
	 (type (sage::record-group-type record-group)))
    (format nil "~a (~(~a~))"
	    title
	    (if (sage::document-p record-group)
		"document"
		(let ((record-for-lookup (sage::find-record-for-lookup record-group)))
		  (or (and record-for-lookup
			   (sage::doc-record-source-type record-for-lookup))
		      type))))))

(defmethod 1(recompute-cached-title-1 reference-structure-node general)0 ()
  (let* ((record-group (nsage::sage-reference-record-group markup-structure))
	 (title (nsage::appropriate-title-rendering	;---would like to run formatter
		  record-group 'nsage::no-formatting)))
    title))

(defmethod 1(reference-structure-node-expanded-in-line reference-structure-node)0 ()
  expanded-in-line)

(defmethod 1(format-generated-crossref-string reference-structure-node)0 (stream)
  (format stream "~A" (cached-title-string self :type 'generated)))

(defmethod 1(format-expandable-reference-title reference-structure-node)0 (stream)
  #+expand-references-in-line			;--- in-line expansion has been repudiated.
  (format stream "Includ~:[able~;ed~] link to ~S"
	  expanded-in-line (cached-title-string self :type 'expandable))
  #-expand-references-in-line
  (format stream "Include link to ~S" (cached-title-string self :type 'expandable)))

(defmethod 1(format-general-reference-title reference-structure-node)0 (stream decoded-view)
  (format stream "Link to ~S (view=~(~a~))"
	  (cached-title-string self :type 'general)
	  decoded-view))

(defmethod 1(print-self-as-record-group reference-structure-node)0 (stream)
  (if (and (variable-boundp zwei:markup-structure) zwei:markup-structure)
      (let ((record-group (sage:sage-reference-record-group zwei:markup-structure)))
	(scl:present record-group (cl:type-of record-group)
		     :stream stream))
    (sys:print-self stream nil nil)))

(scl:define-presentation-type 1reference-structure-node0 (() &key (format :as-reference))
   :no-deftype t
   :printer ((node stream)
	     (cl:ecase format
	       (:as-reference (sys:print-self node stream nil nil))
	       (:as-expression (sys:print-self node stream nil t))
	       (:as-record (print-self-as-record-group node stream)))))

(defflavor 1reference-diagram-line0 (node)
	   (mouse-sensitive-diagram-mixin
	    markup-line-diagram-mixin
	    title-string-cached-title-mixin)
  :initable-instance-variables)

(defmethod 1(recompute-cached-title-1 reference-diagram-line :otherwise)0 (ignore)
  (let ((decoded-view (nsage::sage-reference-decode-view markup-structure))
	(appearance (sage::sage-reference-appearance markup-structure))
	(booleans (sage::sage-reference-booleans markup-structure))
	(linked-record (cached-title-string node :type 'expandable))
	(linked-record-group (sage::sage-reference-record-group markup-structure)))
    (with-output-to-string (cl:*standard-output*)
      (scl:case decoded-view
	((sage::include)
	 (format t "~c Include link: ~a" #\arrow:right-fat-arrow linked-record))
	((sage::crossreference)
	 (format t "~c ~A"
		 #\arrow:eye
		 (sage::expand-crossreference-appearance
		   linked-record-group
		   appearance booleans
		   :type 'sage::editor)))
	((sage::contents)
	 (format t "~c Contents link: ~a" #\arrow:right-fat-arrow linked-record))
	((sage::precis)
	 (format t "~c Precis link: ~a" #\arrow:eye linked-record))
	((sage::topic)
	 (format t "~c Topic link: ~a" #\arrow:right-fat-arrow linked-record))
	(otherwise
	  (format t "~c Link: ~a" #\arrow:eye linked-record))))))

(defmethod 1(:editor-draw reference-diagram-line)0 (ignore window x y)
  (dw:with-output-as-presentation (:stream window
				   :object node
				   :type 'reference-structure-node)
    (send window :set-cursorpos (1+ x) (1- y))
    (format window "~a" (cached-title-string self))))

#+expand-references-in-line			;--- in-line expansion has been repudiated.
(defflavor reference-diagram-trailer-line (node)
	   (markup-line-diagram-mixin)
  :initable-instance-variables)

#+expand-references-in-line			;--- in-line expansion has been repudiated.
(defmethod (:editor-draw reference-diagram-trailer-line) (ignore window x y)
  (send window :draw-rectangle 1 (send window :line-height) x (1+ y))
  (let ((name (if (reference-structure-node-expanded-in-line node)
		  (string-append "End of link to "
				 ;;---Needs to use (cached-title-string self ...)
				 (nsage::appropriate-title-rendering
				   (nsage::sage-reference-record-group markup-structure)
				   'nsage::no-formatting))
		  "(not expanded)")))
    (let ((width (+ (send window :string-length name) 4)))
      (send window :draw-rectangle width 1 x (+ y (send window :line-height) -1))
      (send window :set-cursorpos (+ x 2) y)
      (send window :string-out name))))

(defmethod 1(markup-header-diagram reference-structure-node)0 ()
  (make-instance 'reference-diagram-line
		 :markup-structure markup-structure
		 :node self))

(defmethod 1(markup-trailer-diagram reference-structure-node)0 ()
  ;; only include a trailer line if we can expand the reference
  #+expand-references-in-line			;--- in-line expansion has been repudiated.
  (when (nsage::reference-is-expandable markup-structure)
    (make-instance 'reference-diagram-trailer-line
		   :markup-structure markup-structure
		   :node self)))

#+expand-references-in-line			;--- in-line expansion has been repudiated.
(defmethod (expand-or-contract-reference reference-structure-node) ()
  (if expanded-in-line
      ;; contracting, so replace the record node with a dummy text node
      (let ((doomed-record-node (first inferiors))
	    (dummy-inferior (nsage::make-sage-zwei-interval)))
	(nsage::remove-node-for-record doomed-record-node)
	(setf (node-superior dummy-inferior) self)
	(setf (node-inferiors self) (list dummy-inferior)))
      (let* ((record-group (nsage::sage-reference-record-group markup-structure)))
	(nsage::ensure-record-in-editor record-group)
	;; --- which record do we insert?
	(let ((record (first (nsage::record-group-edited-records record-group))))
	  (insert-markup-structure-nodes
	    record
	    :in-place-of-node (first inferiors)))))
  (redo-node-links self)
  (setq expanded-in-line (not expanded-in-line))
  (must-redisplay *window* dis-text))

;;; ================================================================
;;; zwei node structure and diagram lines for Sage picture structure

(defflavor 1picture-structure-node0 () (delimited-markup-structure-node))

(defmethod 1(print-markup-structure-node picture-structure-node)0 (stream &key acceptably)
  (ignore acceptably)
  (princ (sage::sage-picture-name markup-structure) stream))

(defflavor 1picture-diagram-line0 ((line-cache))
	   (graphics-line-diagram
	    markup-line-diagram-mixin
	    mouse-sensitive-diagram-mixin)
  :readable-instance-variables
  :writable-instance-variables
  :initable-instance-variables
  )

(defmethod 1(markup-header-diagram picture-structure-node)0 ()
  (make-instance 'picture-diagram-line
		 :markup-structure markup-structure))

(defmethod 1(cache-drawing-function-if-necessary picture-diagram-line)0 ()
  (unless drawing-function
    (setq drawing-function (sage::sage-picture-drawing-function markup-structure))))

(defmethod 1(reset-drawing-function picture-diagram-line)0 ()
  (setq drawing-function nil))

(defmethod 1(picture-diagram-line-markup-structure picture-diagram-line)0 ()
  markup-structure)

(defwhopper 1(:output-height picture-diagram-line)0 (stream)
  (let ((view (let ((line-node (when line-cache
				 (line-node line-cache))))
		(or (and line-node (markup-structure-node-node-view line-node))
		    ':normal))))
    (cl:ecase view
      (:picture
	(cache-drawing-function-if-necessary self)
	(continue-whopper stream))
      (:normal
	;; This is a kludge so that the lower level zwei
	;; substrate won't barf because there's no drawing function
	;; yet.
	(sys:letf-if (null drawing-function)
		     ((drawing-function t))
	  (continue-whopper stream))))))

(defmethod 1(:editor-draw picture-diagram-line :before)0 (line &rest ignored)
  (setq line-cache line))

(defwhopper 1(:draw-self picture-diagram-line)0 (stream)
  (dw:with-output-as-presentation (:stream stream
				   :object (and line-cache (line-node line-cache))
				   :type (and line-cache (cl:type-of (line-node line-cache))))
    (let ((view (let ((line-node (when line-cache
				   (line-node line-cache))))
		  (or (and line-node (markup-structure-node-node-view line-node))
		      ':normal))))
      (cl:ecase view
	(:picture
	  (cache-drawing-function-if-necessary self)
	  (continue-whopper stream))
	(:normal
	  (let* ((sage-picture-name (sage::sage-picture-name markup-structure) )
		 (name (format nil "~C Picture~:[~*~; /"~A/"~]~
                                    ~:@[ (not associated with any file)~; from file ~A~]"
			       #\arrow:right-hand
			       (and sage-picture-name
				    (not (string-equal "" sage-picture-name)))
			       (sage::sage-picture-name markup-structure)
			       (sage::sage-picture-file-name markup-structure))))
	    (graphics:draw-string name 0 0 :stream stream)))))))

;; --- So that the bottom of the picture doesn't get clipped.  This is a kludge.
(defwhopper 1(:editor-height picture-diagram-line)0 (stream line)
  (let ((height (continue-whopper stream line)))
    (+ height 5)))

(defflavor 1example-record-marker-structure-node0 () (delimited-markup-structure-node))

(defflavor 1example-record-marker-diagram-line0 () (picture-diagram-line))

(defmethod 1(markup-header-diagram example-record-marker-structure-node)0 ()
  (make-instance 'example-record-marker-diagram-line
		 :markup-structure markup-structure))

(defwhopper 1(:draw-self example-record-marker-diagram-line)0 (stream)
  (dw:with-output-as-presentation (:stream stream
				   :object (and line-cache (line-node line-cache))
				   :type (and line-cache (cl:type-of (line-node line-cache))))
    (let ((view (let ((line-node (when line-cache
				   (line-node line-cache))))
		  (or (and line-node (markup-structure-node-node-view line-node))
		      ':normal))))
      (when (eq view :picture)
	(cache-drawing-function-if-necessary self))
      (if (and (eq view :picture) drawing-function)
	  (continue-whopper stream)
	  (let ((name (format nil "~C Example record ~(~A~)~:[ (Not tested)~]"
			      #\arrow:circle-plus
			      (sage::example-record-marker-type markup-structure)
			      (sage::example-record-marker-encoding markup-structure))))
	    (graphics:draw-string name 0 0 :stream stream))))))

;;; ================================================================
;;; zwei node structure and diagram lines for Sage macro-call structure

(defflavor 1macro-call-structure-node0 () (delimited-markup-structure-node))

(defflavor 1macro-call-diagram-line0 () (markup-line-diagram-mixin))

(defmethod 1(:editor-draw macro-call-diagram-line)0 (ignore window x y)
  (send window :set-cursorpos (1+ x) (1+ y))
  (cl:write-char #\arrow:right-hand window)
  (format window "macro call"))

(defmethod 1(markup-header-diagram macro-call-structure-node )0 ()
  (make-instance 'macro-call-diagram-line
		 :markup-structure markup-structure))

;;; line margin stuff for semi-wysiwyg indentation for environments in the buffer

(defflavor 1markup-line-margin0 () (line-margin))

(defmethod 1(line-margin-size markup-line-margin)0 (window line)
  (ignore window)
  (values (markup-margin-total-indentation (line-node line))
	  0 0 0))

(defmethod 1(line-margin-draw markup-line-margin)0 (window line x y width height baseline vsp)
  (ignore x)
  (loop for node = (line-node line) then superior
	as superior = (node-superior node)
	with top = (window-interval (send window :zwei-window))
	until (eq superior top)
	do
    (when (eq line (bp-line (interval-first-bp node)))
      (markup-margin-draw node window (+ x (markup-margin-total-indentation superior))
			  y width height baseline vsp))))

;;; Only need one for whole world, since real information stored elsewhere.
(defvar 1*markup-line-margin-property*0 (list :character-style-function
					      'wt-character-style-function
					    :line-margin (make-instance 'markup-line-margin)))

(defmethod 1(markup-margin-draw markup-structure-node)0 (&rest ignore))

(defmethod 1(markup-margin-total-indentation markup-structure-node)0 ()
  (or total-indentation
      (setq total-indentation (+ (markup-margin-indentation superior)
				 (markup-margin-total-indentation superior)))))
(defmethod 1(:check-line-redisplay-parameters markup-structure-node)0 (line)
  (when (null (line-line-margin line))
    (setf (line-plist line) (nconc (line-plist line) *markup-line-margin-property*)))
  (loop for node = self then (node-superior node)
	while (typep node 'markup-structure-node)
	do (check-line-node-structure self line)))

;;; for environments that are made up of items (not used yet)
(defflavor 1markup-itemized-node0 () (environment-structure-node))

;;; we don't yet have the parallel Sage structure
(defflavor 1markup-item-node0 () (delimited-markup-structure-node))

(defflavor 1item-trailer-line0 () (;structural-line-diagram-mixin
				 markup-line-diagram-mixin))

(defmethod 1(:editor-draw item-trailer-line)0 (ignore window x y)
  (send window :draw-rectangle 10 1 x (+ y (floor (tv:sheet-line-height window) 2))))

(defmethod 1(markup-trailer-diagram markup-item-node)0 ()
  (make-instance 'item-trailer-line :markup-structure markup-structure))

;;; ---no sage items yet
(defmethod 1(markup-margin-draw markup-item-node)0 (stream x y ignore ignore baseline ignore)
  (ignore stream x y baseline)
  (error "NYI")
  #+Franz
  (draw-item-number (nsage::directive-superior markup-structure)
		    stream (nsage::item-structure-item-index markup-structure)
		    x y baseline))
; when we add itemized-structure mixin and itemize and enumerate environments
;(defmethod (draw-item-number enumerate-structure) (stream index x y baseline)
;  (sys:with-stack-array (string 10 :type 'art-string :fill-pointer 0)
;    (format string "~D." (1+ index))
;    (graphics:draw-string string x (+ y (floor baseline 2))
;			  :attachment-y :center
;			  :character-style '(:dutch :bold :small)
;			  :stream stream)))
;
;(defmethod (draw-item-number itemize-structure) (stream ignore x y baseline)
;  (graphics:draw-circle (+ x (floor baseline 2)) (+ y (floor baseline 2))
;			(floor baseline 3) :stream stream))

(defflavor 1markup-structure-drawing-node0 () (delimited-markup-structure-node))

;;; diagram that contains arbitrary graphic drawn by drawing function
(defflavor 1markup-drawing-line0 (drawing-function)
	   (mouse-sensitive-diagram-mixin markup-line-diagram-mixin
	    graphics-line-diagram))

(defmethod 1(:editor-draw markup-drawing-line)0 (ignore window x y)
  (dw:with-output-as-presentation (:stream window :single-box t
				   :object markup-structure
				   :type (cl:type-of markup-structure))
    (graphics:with-graphics-transform (window (list scale 0 0 (- scale)
						    x (+ y (* height scale))))
      (funcall drawing-function window))))

;;; ---no sage counterpart structure yet
;;; --- since there's no structure, I'm commenting this out for now -- doughty
;;;                                                                    4 Aug 88
;; (defmethod 1(markup-header-diagram markup-structure-drawing-node)0 ()
;;   (make-instance 'markup-drawing-line :markup-structure markup-structure
;; 		 :drawing-function
;; 		 (markup-structure-drawing-function markup-structure)))

;;;; Tree surgery
;;; (the old zwei-node surgery has been moved out to markup-diagrams-old-stuff.lisp
;;; and replaced with sage structure surgery code in ed-glue)

;;; These things will of course need without-aborts.

(defun 1markup-structure-both-diagrams0 (node)
  (values (markup-header-diagram node)
	  (markup-trailer-diagram node)))

(defmethod 1(splice-structure-in markup-structure-node)0 (line-before line-after)
  (if (and (variable-boundp first-bp) (variable-boundp last-bp))
      (let ((interval-first-line (bp-line first-bp))
	    (interval-last-line (line-previous (bp-line last-bp))))
	(setf (line-next line-before) interval-first-line)
	(setf (line-previous interval-first-line) line-before)
	(setf (line-next interval-last-line) line-after)
	(setf (line-previous line-after) interval-last-line)
	(setq line-before interval-first-line
	      line-after interval-last-line))
      (multiple-value-bind (top-diagram bottom-diagram)
	  (markup-structure-both-diagrams self)
	(when top-diagram
	  (let ((line (make-diagram-line top-diagram)))
	    (setf (line-node line) self)
	    (setf (line-next line-before) line)
	    (setf (line-previous line) line-before)
	    (setq line-before line)))
	(when bottom-diagram
	  (let ((line (make-diagram-line bottom-diagram)))
	    (setf (line-node line) self)
	    (setf (line-next line) line-after)
	    (setf (line-previous line-after) line)
	    (setq line-after line)))
	(if (not (null inferiors))
	    (let ((previous nil)
		  (first-inferior-begin-line nil)
		  (previous-end-line nil))
	      (dolist (inferior inferiors)
		(multiple-value-bind (inferior-begin inferior-end)
		    (splice-structure-in inferior (or previous-end-line line-before)
					 line-after)
		  (unless first-inferior-begin-line
		    (setq first-inferior-begin-line inferior-begin))
		  (setq previous-end-line inferior-end))
		(setf (node-previous inferior) previous)
		(when previous
		  (setf (node-next previous) inferior))
		(setq previous inferior))
	      (when previous
		(setf (node-next previous) nil))
	      (unless top-diagram
		(setq line-before first-inferior-begin-line))
	      (unless bottom-diagram
		(setq line-after previous-end-line)))
	    (when (and (null top-diagram) (null bottom-diagram))
	      ;; Must have at least one line to call our own.
	      (let ((line (create-line 'art-string 0 self)))
		(setf (line-next line-before) line)
		(setf (line-previous line) line-before)
		(setq line-before line)))
	    (setf (line-next line-before) line-after)
	    (setf (line-previous line-after) line-before)
	    (when (null bottom-diagram)
	      (setq line-after line-before)))
	(setq first-bp (create-bp line-before 0 :normal *interval*))
	(setq last-bp (create-bp (line-next line-after) 0 :moves *interval*))))
  (values line-before line-after))

;;; This function used to serve two different purposes.  Since it was mostly
;;; composed of disjoint cond clauses, it has been split into two functions.
;;; This one now only knows how to insert a record's ZWEI nodes at a given BP.
(defun 1insert-record-structure-nodes0 (record &key at-bp
				      (in-place-of-node nil in-place-of-node-supplied)
				      defer-redo-node-links)
  (declare (arglist record &key at-bp))
  (ignore in-place-of-node)
  ;; "incompatibility" check
  (when in-place-of-node-supplied
    (cl:error "Internal error: Insert-record-structure-nodes no longer supports the :in-place-of-node option.
It probably should have been insert-markup-structure-nodes."))
  (cl:assert (or (cl:typep record 'sage:doc-record) (cl:typep record 'sage::killed-record)) ()
	     "~S is not a record." record)
  (mung-bp-interval at-bp)
  (let* ((superior *interval*)
	 (structure-node (markup-structure-editor-node record superior))
	 (sibling (loop for node = (bp-node at-bp) then node-superior
			as node-superior = (node-superior node)
			while node-superior
			when (eq node-superior superior)
			  return node)))
    (cond ((null sibling)
	   ;; bp wasn't in any node, append the record to the end of the buffer.
	   ;; Things won't find it, however, if the first and last lines of
	   ;; the buffer are simply connected.  So, if they are, sever them.
	   (sever-first-and-last-lines superior)
	   (cond ((null (node-inferiors superior))
		  (setf (node-inferiors superior)
			(list structure-node)))
		 ;; Before the first record
		 ((bp-< at-bp (node-first-bp (first (node-inferiors superior))))
		  (setf (node-inferiors superior)
			(append (list structure-node) (node-inferiors superior))))
		 ;; After the last record
		 ((bp-< (node-last-bp (first (last (node-inferiors superior)))) at-bp)
		  (setf (node-inferiors superior)
			(append (node-inferiors superior) (list structure-node))))
		 (t
		  ;;--- inferiors not null, but we can't figure out where the bp is
		  ;; relative to them, so just put the new record somewhere instead of
		  ;; generating an annoying error.
		  (setf (node-inferiors superior)
			(append (node-inferiors superior) (list structure-node))))))
	  (t (let ((pos (cl:position sibling (node-inferiors superior))))
	       (cond ((null pos)
		      ;; Multiple insertions of the same record in the same buffer
		      ;; can result in the sibling disappearing from the superiors' inferiors.
		      (unless (scl:member structure-node (node-inferiors superior))
			(setf (node-inferiors superior)
			      (append (node-inferiors superior) (list structure-node)))))
		     ((bp-= at-bp (node-first-bp sibling))
		      ;; Special case insertion at the beginning of a node -- insert before it.
		      ;; That's how some users position the cursor "between" nodes
		      ;;--- The PUSH form below expands into code that is broken for pos=0
		      ;; as of 369.145.
		      (if (= pos 0)
			  (setf (node-inferiors superior)
				(cons structure-node (node-inferiors superior)))
			  (push structure-node
				(nthcdr pos (node-inferiors superior)))))
		     (T (push structure-node
			      (cdr (nthcdr pos (node-inferiors superior)))))))))
    (unless defer-redo-node-links (redo-node-links superior))
    structure-node))

;;; The whole line-next-in-buffer protocol won't work if the first and last
;;; lines in the buffer are connected by simple line-next/previous links.
;;; --- maybe this should be done on buffer creation or initialization rather
;;; than on first record node insertion.
(defun 1sever-first-and-last-lines0 (buffer)
  (when (bps-connected-by-simply-connected-lines
	  (node-first-bp buffer) (node-last-bp buffer))
    (let* ((last-line (bp-line (node-last-bp buffer)))
	   (next-to-last-line (line-previous last-line)))
      (when next-to-last-line
	(setf (line-next next-to-last-line) nil)
	(setf (line-previous last-line) nil)))))

(defvar 1*markup-structureeditor-node-table*0 ())

(defun 1clear-markup-structureeditor-node-table0 ()
  (clrhash *markup-structureeditor-node-table*))

(defun 1fill-markup-structureeditor-node-table0 (top-level-node)
  (clear-markup-structureeditor-node-table)
  (labels ((hash-thing (node)
	     (setf (gethash (markup-structure-node-markup-structure node)
			    *markup-structureeditor-node-table*)
		   node)
	     (dolist (inf (node-inferiors node))
	       (hash-thing inf))))
    (hash-thing top-level-node)))

(defmacro 1with-markup-structureeditor-node-table0 (node &body body)
  `(with-markup-structureeditor-node-table-1
     ,node
     (dw:named-continuation 1with-markup-structureeditor-node-table0 ()
       ,@body)))

(defun 1with-markup-structureeditor-node-table-10 (node continuation)
  (sys:with-data-stack
    (let ((*markup-structureeditor-node-table*
	    (cl:make-hash-table :area :stack)))
      (fill-markup-structureeditor-node-table node)
      (funcall continuation))))

(defun 1get-markup-structure-editor-node0 (structure superior)
  (let ((existing-node
	  (and *markup-structureeditor-node-table*
	       (gethash structure *markup-structureeditor-node-table*))))
    (cond (existing-node
	   (setf (node-superior existing-node) superior)
	   existing-node)
	  (t
	   (make-instance (markup-structure-editor-node-flavor structure)
			  :markup-structure structure
			  :superior superior)))))

;;; This function knows how to replace an existing ZWEI node with a new
;;; one generated from Sage structure.
;;; It has to take care of generating the new nodes and splicing them
;;; in to the existing node structure.  It also has to relocate any BP's
;;; in the nodes that are about to be flushed to reasonable places in
;;; the new node hierarchy.
(defun 1insert-markup-structure-nodes0 (structure &key in-place-of-node)
  (mung-node in-place-of-node)
  (with-markup-structureeditor-node-table in-place-of-node
    ;; Collect info about old bp's.
    (let ((relocation-data (find-relocatable-bps in-place-of-node)))
      (let* ((superior (node-superior in-place-of-node))
	     (structure-node (markup-structure-editor-node structure superior)))
	(setf (markup-structure-node-node-view structure-node)
	      (markup-structure-node-node-view in-place-of-node))
	(setf (node-inferiors superior)
	      (nsubst structure-node in-place-of-node
		      (node-inferiors superior)))
	;; forget the indentation of the inferiors of this node
	(labels ((doit (node &optional first-time)
		   (unless first-time
		     (setf (markup-structure-node-total-indentation node) nil))
		   (dolist (n (node-inferiors node))
		     (doit n))))
	  (doit structure-node t))

	(redo-node-links superior)
	;; Find new homes for old bp's.
	(relocate-old-bps structure-node relocation-data)))))

;;; This function is called on the superior node of any newly inserted
;;; node.  It takes care of restoring the node-superior/inferior and
;;; node-next/previous links.
(defun 1redo-node-links0 (node)
  (labels ((redo (node depth)
	     (let ((prev nil))
	       (dolist (inferior (node-inferiors node))
		 ;;(format t "~&Depth ~D, Linking in ~S" depth inferior)
		 (setf (node-superior inferior) node)
		 (redo inferior (1+ depth))
		 (when prev
		   (setf (node-next prev) inferior))
		 (setf (node-previous inferior) prev)
		 (setq prev inferior))
	       (when prev
		 (setf (node-next prev) nil)))))
    (redo node 1)))

;;; Search the node hierarchy for any BP's that aren't just the boundary
;;; BP's of a node.  For each one, collect the BP, the Sage structure represented
;;; by the node (since the node is about to be flushed) and whether the bp was
;;; at the beginning, end or somewhere in the middle of the node.
(defun 1find-relocatable-bps0 (root-node)
  (let ((candidates nil))
    (labels ((non-boundary-bp-p (bp)
	       (let ((node (bp-node bp)))
		 (and (neq bp (node-first-bp node))
		      (neq bp (node-last-bp node))))))
      ;; Map over all the lines within the node.
      (loop with first-line = (bp-line (node-first-bp root-node))
	    with last-line = (bp-line (node-last-bp root-node))
	    for line = first-line then (line-next-in-buffer line)
	    for line-node = (line-node line)
	    for structure = (markup-structure-node-markup-structure line-node)
	    ;; Map over all the BP's in the line, checking for interesting ones.
	    ;; (text intervals take care of their own BP's)
	    unless (typep structure 'sage::sage-text-structure)
	      do (loop for bp in (line-bp-list line)
		       do (when (non-boundary-bp-p bp)
			    ;; Record info about the BP.
			    (push
			      (list
				structure
				bp
				(cond ((not (typep line-node 'markup-structure-text-node))
				       ;; For environment nodes diagrams, a BP anywhere on
				       ;; the line is considered to be at index 0.
				       (cond ((eq line (bp-line (node-first-bp line-node)))
					      'first)
					     ((eq line (bp-line (node-last-bp line-node)))
					      'last)
					     (t (cl:error "Internal error: How did the BP get to be in the middle of a non-text node?"))))
				      ;; For text nodes, compare against real first/last-bp
				      ((bp-= bp (node-first-bp line-node))
				       'first)
				      ((bp-= bp (node-last-bp line-node))
				       'last)
				      (t 'middle)))
			      candidates)))
	    until (eq line last-line)))
    ;; Caller doesn't do anything with this info except pass it to the next funciton
    candidates))

;;;--- take this out before delivery
(defvar 1*count-of-inexact-bp-relocations*0 0)

;;; This function tries to find new homes for the BP's rescued from old nodes.
(defun 1relocate-old-bps0 (new-root bp-data)
  (labels ((find-corresponding-node (structure node)
	     ;; Recursively search the node hierarchy for a node that has
	     ;; the same Sage structure as the deceased node.
	     (if (eq structure
		     (markup-structure-node-markup-structure node))
		 node
		 (loop for inferior-node in (node-inferiors node)
		       for result = (find-corresponding-node structure inferior-node)
		       when result
			 return result)))
	   (find-live-ancestor (structure)
	     (loop for structure = structure then (sage:directive-superior structure)
		   for node = (find-corresponding-node structure new-root)
		   when node
		     return node)))
    (loop for (markup-structure bp where) in bp-data
	  for node = (find-corresponding-node markup-structure new-root)
	  do
      (cond ((null node)
	     (incf *count-of-inexact-bp-relocations*)
	     (let ((second-best-node (find-live-ancestor markup-structure)))
	       (if (null second-best-node)
		   ;;--- take this out before delivery
		   (format t "Couldn't relocate BP ~S, at ~S of ~A"
			   bp where markup-structure)
		   (move-bp bp (node-first-bp second-best-node)))))
	    (t
	     (cl:ecase where
	       (first (move-bp bp (node-first-bp node)))
	       (last (move-bp bp (node-last-bp node)))
	       ;; --- where do we put MIDDLE BP's?
	       (middle (incf *count-of-inexact-bp-relocations*)
		       (move-bp bp (node-first-bp node)))))))))

(defun 1flush-bps-for-buffer0 (buffer)
  (point-pdl-purge buffer)
  (dolist (reg *reg-list*)
    (let ((bp (first (get reg 'point))))
      (and bp (eq (bp-buffer bp) buffer)
	   (si:nremprop reg 'point))))
  (let ((first-bp (node-first-bp buffer)))
    (move-bp (buffer-saved-point buffer) first-bp)
    (move-bp (buffer-saved-mark buffer) first-bp)
    (move-bp (buffer-saved-window-start-bp buffer) first-bp)
    ;; Any other windows lying around should not have pointers to this window.
    ;; This buffer could have been in lots of other windows history lists, so check
    ;; all windows, not just the current one.
    (dolist (window *window-list*)			;look at each of the extant windows
      (when (eq (window-interval window) buffer)	;did window "show" killed buffer?
	(move-bp-to-bp-and-buffer (window-point window) first-bp)
	(move-bp-to-bp-and-buffer (window-mark window) first-bp)
	(move-bp-to-bp-and-buffer (window-start-bp window) first-bp)))))

(defun 1fix-confused-bps-in-buffer0 (buffer)
  ;; why do the bps even have buffers in them??
  (labels ((fix-confused-bps (node)
	     (do-lines ((line ignore ignore) (node))
	       (dolist (bp (zwei:line-bp-list line))
		 (let ((bp-buffer (zwei:bp-buffer-internal bp)))
		   (when (and bp-buffer (not (eql bp-buffer buffer)))
		     (setf (zwei:bp-buffer-internal bp) buffer)))))))
    (scl:map () #'fix-confused-bps (node-inferiors buffer))))

(defun 1move-nonboundary-bps-of-line-to0 (line to-bp)
  (let ((node (line-node line)))
    (let ((first-bp (node-first-bp node))
	  (last-bp (node-last-bp node)))
      (dolist (bp (line-bp-list line))
	(unless (or (eq bp first-bp) (eq bp last-bp))
	  (move-bp bp to-bp))))))

;;; Use this when deleting (or removing from view) a node.
(defun 1move-nonboundary-bps-of-node-to0 (node to-bp)
  ;; all our nodes start and end at the beginning of lines
  (do-lines-in-interval (node line ignore ignore)
    (move-nonboundary-bps-of-line-to line to-bp)))


#||
3;;; various failed attempts at relocating bps from old nodes to new

(defun relocate-bps (old-root-node new-root-node)
  (labels ((find-corresponding-node (old-node new-node)
	     (if (eq (markup-structure-node-markup-structure old-node)
		     (markup-structure-node-markup-structure new-node))
		 new-node
		 (loop for node in (node-inferiors new-node)
		       for result = (find-corresponding-node old-node node)
		       when result
			 return result)))
	   (non-boundary-bp-p (bp)
	     (let ((node (bp-node bp)))
	       (and (neq bp (node-first-bp node))
		    (neq bp (node-last-bp node)))))
	   (relocate-boundary-line-bps (node)
	     (let ((new-node (find-corresponding-node node new-root-node)))
	       (when new-node
		 (format t "~&Old node = ~S, new node = ~S" node new-node)
		 (let ((first-line (bp-line (node-first-bp node)))
		       (last-line (bp-line (node-last-bp node))))
		   (relocate-line-bps first-line (node-first-bp new-node))
		   (relocate-line-bps last-line (node-last-bp new-node))))))
	   (relocate-line-bps (line new-bp)
	     (dolist (bp (line-bp-list line))
	       (when (non-boundary-bp-p bp)
		 (move-bp bp new-bp))))
	   (relocate-node-bps (node)
	     (relocate-boundary-line-bps node)
	     (dolist (inferior (node-inferiors node))
	       (relocate-node-bps inferior)))
	   )
    (relocate-node-bps old-root-node)
    #+ignore
    ;; can't loop over lines 'cause line-next-in-buffer protocol is broken
    ;; for old nodes.
    (loop with first-line = (bp-line (node-first-bp old-root-node))
	  with last-line = (bp-line (node-last-bp old-root-node))
	  for line = first-line then (line-next-in-buffer line)
	  do
      (loop for bp in (line-bp-list line)
	    for bp-node = (bp-node bp)
	    do (when (non-boundary-bp-p bp)
		 (let ((new-node (find-corresponding-node bp-node new-root-node)))
		   (format t "~&Old node = ~S, new node = ~S" bp-node new-node)))
	    until (eq line last-line)))
    ))
	  

;;;--- the comment below appears to be wrong
;;; This code doesn't have to deal with non-isomorphic new and old node trees
;;; because delete-sage-interval has already moved BP's out of deleted stuff.
;;; Therefore, we should be able to find a new node for each old one.
(defun reset-important-bps ()
  (labels ((node-is-live (node)
	     (loop for node = node then (node-superior node)
		   for superior = (node-superior node)
		   while superior
		   do
	       (unless (member node (node-inferiors superior))
		 (return-from node-is-live nil)))
	     t)
	   (find-live-superior (node)
	     (loop for node = node then (node-superior node)
		   until (null node)
		   when (node-is-live node)
		     return (values node dead-list)
		   collect node into dead-list))
	   (reset-bp (bp &rest importance)
	     (when (scl:typep (bp-node bp) '(and markup-structure-node
						 ;; If it's a text node, we have nothing to do
						 ;; because the text nodes are preserved.
						 ;; ---What about changing views?
						 (not markup-structure-text-node)))
	       (let* ((node (bp-node bp))
		      (offset (cond ((bp-= bp (node-first-bp node)) :first)
				    ((bp-= bp (node-last-bp node)) :last)
				    (T (when *debugging-sage*
					 (scl:cerror "Use node's first-bp"
						     "Internal error: The bp ~s wasn't a boundary of its node ~s"
						     bp node))
				       :first)))
		      (structure (markup-structure-node-markup-structure node)))
		 (multiple-value-bind (live-superior dead-ancestors)
		     (find-live-superior node)
		   (cond ((null live-superior)
			  (error "Internal error: Couldn't find a live superior"))
			 ((eq live-superior node)
			  nil)
			 ;; regeneration of same nodes
			 (t
			  (setq dead-ancestors (nreverse dead-ancestors))
			  ;; hunt back down the tree for the corresponding new nodes
			  (loop for node in dead-ancestors
				with superior = live-superior
				do
			    ;; find the new node with the same structure
			    (let ((new-node
				    (cl:find 
				      (markup-structure-node-markup-structure node)
				      (node-inferiors superior)
				      :key #'markup-structure-node-markup-structure)))
			      (cond ((null new-node)
				     (cl:cerror "Skip moving this bp"
						"Internal error: Couldn't find a corresponding live node for ~
						  dead node ~S, for reason ~a"
						node importance)
				     (return-from reset-bp (values)))
				    ((eq (markup-structure-node-markup-structure new-node)
					 structure)
				     ;; found it
				     (let ((to-bp (scl:ecase offset
						    (:first (node-first-bp new-node))
						    (:last (node-last-bp new-node)))))
				       #+Franz
				       (when (eql bp (point))
					 (dbg:when-mode-lock
					   (scl:break "Moving point ~s to ~s (offset ~d from ~s)"
						      (point) to-bp offset new-node)))
				       (move-bp bp to-bp)
				       (return-from reset-bp (values))))
				    (t (setq superior new-node))))))))))))
      (dolist (window *window-list*)
	(reset-bp (window-point window) 'point window)
	(reset-bp (window-mark window) 'mark window)
	(reset-bp (window-start-bp window) 'window-start-bp window)
	(SETF (WINDOW-POINT-PDL WINDOW)
	      (DEL-if-not (lambda (bp&c) (node-is-live (bp-node (first bp&c))))
		   (WINDOW-POINT-PDL WINDOW))))))

(defun important-bp-p (candidate-bp)
  (flet ((check-bp (bp)
	   (when (eq candidate-bp bp)
	     (return-from important-bp-p t))))
    (dolist (window *window-list*)
	(check-bp (window-point window))
	(check-bp (window-mark window))
	(check-bp (window-start-bp window)))))
0||#


(defun 1some-reversed0 (predicate sequence)
  (sys:with-stack-array (reversed (scl:length sequence) :initial-contents sequence)
    (setq reversed (scl:nreverse reversed))
    (scl:some predicate reversed)))

(defmethod 1(node-linked-next-line node)0 ()
  (or (and next
	   (markup-structure-node-first-unlinked-line next :from-above))
      (markup-structure-node-last-unlinked-line superior :from-above)))

(defmethod 1(node-linked-previous-line node)0 ()
  (or (and previous
	   (markup-structure-node-last-unlinked-line previous :from-below))
      (markup-structure-node-first-unlinked-line superior :from-below)))

(defun 1first-unlinked-line-from-above0 (node)
  (markup-structure-node-first-unlinked-line node :from-above))

(defun 1last-unlinked-line-from-below0 (node)
  (markup-structure-node-last-unlinked-line node :from-below))

(defun 1bps-connected-by-simply-connected-lines0 (first-bp last-bp)
  (let ((first-line (bp-line first-bp))
	(last-line (bp-line last-bp)))
    ;; This could perhaps be sped up by following forward from first-line,
    ;; and backward from last-line, until one falls off or they meet.
    (loop for line = first-line then (line-next line)
	  do
      (when (null line)
	(return ()))
      (when (eql line last-line) (return T)))))

(defun 1lines-simply-connected0 (line1 line2)
  (loop for line = line1 then (line-next line)
	do
    (cond ((null line)
	   (return ()))
	  ((eql line line2)
	   (return T)))))

(defun 1last-simply-connected-line0 (line)
  (loop for line = line then next-line
	for next-line = (line-next line) then (line-next next-line)
	when (null next-line) return line))

(defun 1first-simply-connected-line0 (line)
  (loop for line = line then prev-line
	for prev-line = (line-previous line) then (line-previous prev-line)
	when (null prev-line) return line))

;;;====================
(defmethod 1(buffer-next-unlinked-line markup-buffer)0 (line)
  (markup-structure-node-next-unlinked-line (line-node line) line))

(defmethod 1(buffer-previous-unlinked-line markup-buffer)0 (line)
  ;; Zwei redisplay, when recentering point, can sometimes ask line-previous
  ;; of a line that isn't even in this buffer.  Don't blow out asking
  ;; the buffer-header-node.
  (values
    (ignore-errors
      (markup-structure-node-previous-unlinked-line (line-node line) line))))
    
(defmethod 1(markup-structure-node-next-unlinked-line markup-buffer)0 (line)
  (cond ((lines-simply-connected (bp-line first-bp) line)
	 (if inferiors
	     (markup-structure-node-first-unlinked-line (first inferiors) :from-above)
	     (first-simply-connected-line (bp-line last-bp))))
	(T nil)))

(defmethod 1(markup-structure-node-previous-unlinked-line markup-buffer)0 (line)
  (cond ((lines-simply-connected line (bp-line last-bp))
	 (if inferiors
	     (markup-structure-node-last-unlinked-line (first (last inferiors)) :from-below)
	     (last-simply-connected-line (bp-line first-bp))))
	(T nil)))

(defmethod 1(markup-structure-node-first-unlinked-line markup-buffer)0 (from)
  (scl:ecase from
    (:from-below
      ;; I assume that this doesn't need the check in -last-unlinked-line below
      ;; This doesn't really want the first line in the buffer; it wants the
      ;; last line of any lines at the beginning of the buffer.
      (last-simply-connected-line (bp-line first-bp)))
    (:from-above (bp-line first-bp))))

(defmethod 1(markup-structure-node-last-unlinked-line markup-buffer)0 (from)
  (scl:ecase from
    (:from-above
      (let ((line (bp-line last-bp)))
	(unless (eq line (bp-line first-bp))
	  ;; This doesn't really want the last line in the buffer; it wants the
	  ;; first line of any lines at the end of the buffer.
	  (first-simply-connected-line line))))
    (:from-below (bp-line last-bp))))

;;; node-superior links upwards, but line-next doesn't, so stop here
(defmethod 1(node-top-level-line-linked-node markup-structure-node)0 ()
  self)

;;; This gets called, but there is nothing interesting for it to do
(defmethod 1(buffer-change-point-top-level-node markup-buffer)0 (new-node)
  (ignore new-node)
  nil)

;;; Check for jumping to a line that has been spliced out of the visible text
;;; ---This is generic on the wrong buffer!  It wants to make sure the bp points
;;; to an accessible line of its buffer, not the buffer the caller happened to
;;; have in hand.
(defmethod 1(move-bp-to-valid-position-in-buffer markup-buffer)0 (bp line index)
  (unless index
    (setq index (bp-index line) line (bp-line line)))
  (let ((node (line-top-level-line-linked-node line)))
    ;; line's top-level-node may be some other non-markup buffer
    (unless (and (typep node 'buffer)
		 (not (typep node 'markup-buffer)))
      (loop for node = node then (node-superior node)
	    until (eq node self)
	    while (typep node 'markup-structure-node)
	    do
	(unless (eq (markup-structure-node-record-view node) ':all)
	  (let ((first (markup-structure-node-first-unlinked-line node :from-below))
		(last (markup-structure-node-last-unlinked-line node :from-below)))
	    (unless (loop for ln = first then (line-next-in-buffer ln :buffer self)
			  thereis (eq ln line)
			  until (eq ln last))
	      ;; Moving point to a place that has been spliced out of the buffer
	      (setq line first index 0)))))))
  (move-bp bp line index))

;;;====================

(defun 1dont-know-where0 ()
  (ferror "Don't know where this line came from (internal error)"))

(defmethod 1(markup-structure-node-next-unlinked-line record-structure-node)
0	   (line)
  (cond ((eq line header-line)
	 ;; The line after the header line is the first of the inferiors,
	 ;; except in view=header-only, in which case it's the trailer
	 (or (scl:ecase record-view
	       ((:record-header-only) trailer-line)
	       ((:outline :contents :all)
		(scl:some #'first-unlinked-line-from-above inferiors)))
	     trailer-line))
	((eql line trailer-line)
	 ;; The line after the trailer is that of the "next" node
	 (node-linked-next-line self))
	(T (dont-know-where))))


(defmethod 1(markup-structure-node-previous-unlinked-line record-structure-node)
0	   (line)
  (cond ((eq line trailer-line)
	 ;; The line before the trailer is the last of the inferiors
	 (or (scl:ecase record-view
	       ((:record-header-only) header-line)
	       ((:outline :contents :all)
		(some-reversed #'last-unlinked-line-from-below inferiors)))
	     header-line))
	((eq line header-line)
	 ;; The line before the header is the last line of the "previous" node
	 (node-linked-previous-line self))
	(t (dont-know-where))))

(defmethod 1(markup-structure-node-first-unlinked-line record-structure-node)0 (from)
  (scl:ecase from
    ((:from-below :from-above)
     (scl:ecase record-view
       ;; The header line is always visible,
       ;;---at least until we have embedded record expansions looking prettier
       ((:record-header-only :outline :contents :all) header-line)))))

(defmethod 1(markup-structure-node-last-unlinked-line record-structure-node)0 (from)
  (scl:ecase from
    ((:from-above :from-below)
     ;; The trailer line is always visible,
     ;;---at least until we have embedded record expansions looking prettier
     (scl:ecase record-view
       ((:record-header-only :outline :contents :all) trailer-line)))))

;;;====================

(defmethod 1(markup-structure-node-next-unlinked-line doc-record-field-structure-node)
0	   (line)
  (cond ((eq line header-line)
	 (scl:ecase record-view
	   ((:record-header-only) ())
	   ((:outline :all)
	    (or (scl:some #'first-unlinked-line-from-above inferiors)
		trailer-line))
	   ((:contents)
	    (or (scl:some #'first-unlinked-line-from-above inferiors)
		(node-linked-next-line self)))))
	((eql line trailer-line)
	 ;; The line after the trailer is that of the "next" node
	 (node-linked-next-line self))
	(T (dont-know-where))))

(defmethod 1(markup-structure-node-previous-unlinked-line doc-record-field-structure-node)
0	   (line)
  (cond ((eq line trailer-line)
	 (scl:ecase record-view
	   ((:record-header-only) ())
	   ((:outline :all)
	    (or (some-reversed #'last-unlinked-line-from-below inferiors)
		header-line))
	   ((:contents)
	    (or (some-reversed #'last-unlinked-line-from-below inferiors)
		(node-linked-previous-line self)))))
	((eq line header-line)
	 ;; The line before the header is the last line of the "previous" node
	 (node-linked-previous-line self))
	(t (dont-know-where))))


(defmethod 1(markup-structure-node-first-unlinked-line doc-record-field-structure-node)0 (from)
  ;; The caller will deal with it when we return NIL to mean this is not to be displayed
  (scl:ecase record-view
    ((:record-header-only)
     ;; Never see fields when header-only
     ())
    ((:outline) header-line)
    ((:contents)
     ;; Don't show header-line or trailer-line, just inferiors
     (scl:ecase from
       (:from-above
	 (and (nsage::doc-record-field-contents-field? markup-structure)
	      (scl:some #'first-unlinked-line-from-above inferiors)))
       (:from-below
	 (markup-structure-node-first-unlinked-line superior :from-below))))
    ((:all)
     header-line)))

(defmethod 1(markup-structure-node-last-unlinked-line doc-record-field-structure-node)0 (from)
  (scl:ecase record-view
    ((:record-header-only)
     ;; Never see fields when header-only
     ())
    ((:outline) trailer-line)
    ((:contents)
     (scl:ecase from
       (:from-below
	 (and (nsage::doc-record-field-contents-field? markup-structure)
	      (some-reversed #'last-unlinked-line-from-below inferiors)))
       (:from-above
	 (markup-structure-node-last-unlinked-line superior :from-above))))
    ((:all) trailer-line)))

;;;====================

(defmethod 1(markup-structure-node-next-unlinked-line delimited-markup-structure-node)
0	   (line)
  (cond ((eq line header-line)
	 (scl:ecase record-view
	   ((:record-header-only ()))
	   ((:outline :contents :all)
	    (or (scl:some #'first-unlinked-line-from-above inferiors)
		trailer-line
		(node-linked-next-line self)))))
	((eq line trailer-line)
	 (node-linked-next-line self))
	(t (dont-know-where))))

(defmethod 1(markup-structure-node-previous-unlinked-line delimited-markup-structure-node)
0	   (line)
  (cond ((eq line trailer-line)
	 (scl:ecase record-view
	   ((:record-header-only) ())
	   ((:outline :contents :all)
	    (or (some-reversed #'last-unlinked-line-from-below inferiors)
		header-line
		(node-linked-previous-line self)))))
	((eq line header-line)
	 (node-linked-previous-line self))
	(t (dont-know-where))))


(defmethod 1(markup-structure-node-first-unlinked-line delimited-markup-structure-node)0 (from)
  (or header-line
      (scl:ecase record-view
	((:record-header-only)
	 ;; Never see contents when header-only
	 ())
	((:outline :contents :all)
	 (scl:ecase from
	   (:from-above
	     (or (scl:some #'first-unlinked-line-from-above inferiors)
		 trailer-line
		 (node-linked-next-line self)))
	   (:from-below
	     (node-linked-previous-line self)))))))

(defmethod 1(markup-structure-node-last-unlinked-line delimited-markup-structure-node)0 (from)
  (or trailer-line
      (scl:ecase record-view
	((:record-header-only)
	 ;; Never see contents when header-only
	 ())
	((:outline :contents :all)
	 (scl:ecase from
	   (:from-below
	     (or (some-reversed #'last-unlinked-line-from-below inferiors)
		 header-line
		 (node-linked-previous-line self)))
	   (:from-above
	     (node-linked-next-line self)))))))

;;; ====================
;;; Only textual pieces are simply linked.

(defmethod 1(markup-structure-node-next-unlinked-line markup-structure-text-node)
0	   (line)
  (cond ((eq line (bp-line last-bp))
	 (node-linked-next-line self))
	(t (dont-know-where))))


(defmethod 1(markup-structure-node-previous-unlinked-line markup-structure-text-node)
0	   (line)
  (cond ((eq line (bp-line first-bp))
	 (node-linked-previous-line self))
	(t (dont-know-where))))


(defmethod 1(markup-structure-node-first-unlinked-line markup-structure-text-node)0 (from)
  (scl:ecase record-view
    ((:record-header-only :outline)
     (scl:ecase from
       (:from-above
	 (node-linked-next-line self))
       (:from-below
	 (node-linked-previous-line self))))
    ((:contents :all)
     (bp-line first-bp))))


(defmethod 1(markup-structure-node-last-unlinked-line markup-structure-text-node)0 (from)
  (scl:ecase record-view
    ((:record-header-only :outline)
     (scl:ecase from
       (:from-below
	 (node-linked-previous-line self))
       (:from-above
	 (node-linked-next-line self))))
    ((:contents :all)
     (bp-line last-bp))))

;================
(defmethod 1(markup-structure-node-next-unlinked-line editable-command-structure-node)
0	   (line)
  (cond ((eq line header-line)
	 (scl:ecase record-view
	   ((:record-header-only ()))
	   ((:outline :contents :all)
	    (or (and (eq node-view ':expanded)
		     (scl:some #'first-unlinked-line-from-above inferiors))
		(and (eq node-view ':expanded)
		     trailer-line)
		(node-linked-next-line self)))))
	((eq line trailer-line)
	 (node-linked-next-line self))
	(t (dont-know-where))))

(defmethod 1(markup-structure-node-previous-unlinked-line editable-command-structure-node)
0	   (line)
  (cond ((eq line trailer-line)
	 (scl:ecase record-view
	   ((:record-header-only) ())
	   ((:outline :contents :all)
	    (or
	      (and (eq node-view ':expanded)
		   (some-reversed #'last-unlinked-line-from-below inferiors))
	      header-line
	      (node-linked-previous-line self)))))
	((eq line header-line)
	 (node-linked-previous-line self))
	(t (dont-know-where))))


(defmethod 1(markup-structure-node-first-unlinked-line editable-command-structure-node)0 (from)
  (or header-line
      (scl:ecase record-view
	((:record-header-only)
	 ;; Never see contents when header-only
	 ())
	((:outline :contents :all)
	 (scl:ecase from
	   (:from-above
	     (or (and (eq node-view ':expanded)
		      (scl:some #'first-unlinked-line-from-above inferiors))
		 (and (eq node-view ':expanded)
		      trailer-line)
		 (node-linked-next-line self)))
	   (:from-below
	     (node-linked-previous-line self)))))))

(defmethod 1(markup-structure-node-last-unlinked-line editable-command-structure-node)0 (from)
  (or (and (eq node-view ':expanded) trailer-line)
      (scl:ecase record-view
	((:record-header-only)
	 ;; Never see contents when header-only
	 ())
	((:outline :contents :all)
	 (scl:ecase from
	   (:from-below
	     (or (and (eq node-view ':expanded)
		      (some-reversed #'last-unlinked-line-from-below inferiors))
		 header-line
		 (node-linked-previous-line self)))
	   (:from-above
	     (node-linked-next-line self)))))))


(defun 1make-markup-node0 (first-bp last-bp flavor)
  (create-interval (copy-bp first-bp :normal) (copy-bp last-bp :moves) flavor))

(defun 1make-text-node0 (first-bp last-bp)
  (let ((node (make-markup-node first-bp last-bp 'markup-structure-text-node)))
    (setf (markup-structure-node-markup-structure node)
	  (make-instance 'text-structure :interval node))
    node))

(defun 1insert-node-in-node-tree0 (node how relative-to &optional (set-line-nodes t))
  (let ((superior (node-superior relative-to)))
    (setf (node-superior node) superior)
    (cl:ecase how
      (:before
	(let ((prev (node-previous relative-to)))
	  (setf (node-previous node) prev)
	  (when prev
	    (setf (node-next prev) node)))
	(setf (node-previous relative-to) node)
	(setf (node-next node) relative-to))
      (:after
	(let ((next (node-next relative-to)))
	  (setf (node-next node) next)
	  (when next
	    (setf (node-previous next) node)))
	(setf (node-next relative-to) node)
	(setf (node-previous node) relative-to)))
    (let ((pos (cl:position relative-to (node-inferiors superior))))
      (when (eq how :after)
	(incf pos))
      (if (zerop pos)
	  (push node (node-inferiors superior))
	  ;--- You'd think just this would be enough, but setf seems broken.
	  (push node (nthcdr pos (node-inferiors superior))))))
  (when set-line-nodes
    ;;--- We are losing here because interval-lines tries to do line-next-in-buffer if
    ;; the indicies of the first and last bp aren't 0.  The line-next-in-buffer fails
    ;; because the line's nodes are all wrong (this code is trying to fix them!)
    ;; Should we roll our own interval mapper?
    ;(interval-lines ((interval-first-bp node) (interval-last-bp node)) (start-line stop-line)
    ;; attempt at rolling our own
    (let ((start-line (bp-line (interval-first-bp node)))
	  (stop-line (bp-line (interval-last-bp node))))
      (loop for line = start-line then (line-next line) ;--- until (eq line stop-line)
	    do
	(let ((diagram (line-diagram line)))
	  (when (and diagram (typep diagram 'markup-line-diagram-mixin)
		     (eq (markup-line-diagram-mixin-markup-structure diagram)
			 (markup-structure-node-markup-structure relative-to)))
	    (setf (markup-line-diagram-mixin-markup-structure diagram)
		  (markup-structure-node-markup-structure node))))
	(when (eq (line-node line) relative-to)
	  (setf (line-node line) node))
	(when (eq line stop-line) (return)))))
  node)

;;; Utilities

(defun 1find-containing-record0 (&optional (bp (point)))
  (loop for node = (bp-node bp) then (node-superior node)
	while (not (null node))
	when (record-node-p node)
	  return node))

(defun 1assure-inside-record0 (&optional bp
			     barf-string &rest barf-args)
  (unless bp (setq bp (point)))
  (unless (find-containing-record bp)
    (if barf-string
	(cl:apply #'barf barf-string barf-args)
	(barf "The cursor must be within a record."))))

(defun 1record-interval0 (&optional (bp (point)))
  (let ((record-node (find-containing-record bp)))
    (when record-node
      (values (node-first-bp record-node)
	      ;; last-bp points at the trailer diagram line,
	      ;; so advance it to the beginning of the next line.
	      (forward-char (node-last-bp record-node))))))

(defun 1move-to-beginning-of-record0 (&optional (bp (point)))
  (loop do
    (multiple-value-bind (first-bp ignore)
	(record-interval bp)
      (when first-bp
	;; If already at beginning of record, move to beginning of
	;; the one on the previous line
	(if (bp-= first-bp bp)
	    (multiple-value-bind (previous-first-bp ignore)
		(let ((back-one (forward-char first-bp -1)))
		  (and back-one (record-interval back-one)))
	      (when previous-first-bp
		(move-point previous-first-bp)))
	    (move-point first-bp))
	(return (point))))
    (unless (setq bp (forward-line bp -1))
      (barf))))

(defun 1move-to-end-of-record0 (&optional (bp (point)))
  (loop do
    (multiple-value-bind (ignore last-bp)
	(record-interval bp)
      (when last-bp
	(move-point last-bp)
	(return (point))))
    (unless (setq bp (forward-line bp))
      (barf))))

(DEFUN 1FORWARD-OVER-char=0 (LIST BP)
  (CHARMAP (BP (NODE-LAST-BP (BP-LIMIT-AGAINST-*INTERVAL* BP)) (CHARMAP-BP-BEFORE))
    (IF (NOT (MEM #'CHAR= (CHARMAP-CHAR) LIST))
	(CHARMAP-RETURN (CHARMAP-BP-BEFORE)))))

(DEFUN 1BACKWARD-OVER-char=0 (LIST BP)
  (RCHARMAP (BP (NODE-FIRST-BP (BP-LIMIT-AGAINST-*INTERVAL* BP)) (RCHARMAP-BP-AFTER))
    (IF (NOT (MEM #'CHAR= (RCHARMAP-CHAR) LIST))
	(RCHARMAP-RETURN (RCHARMAP-BP-AFTER)))))

(defcom 1com-make-test-buffer0 "Make a new buffer for testing" ()
  (let ((old-test-buffer (find-buffer-named "Markup-Test")))
    (when old-test-buffer
      (kill-buffer old-test-buffer)))
  (let ((buffer (make-buffer 'non-file-markup-buffer :name "Markup-Test")))
    (SEND buffer :PUTPROP (si:parse-character-style '(nsage::sans-serif-body :roman :normal))
	  :DEFAULT-CHARACTER-STYLE)
    (make-buffer-current buffer))
  dis-text)

(define-presentation-to-editor-command-translator 1change-record-view
0						  (record-structure-node "Change view"
						   *standard-comtab*
						   :gesture :edit-viewspecs)
						  (record)
  `(change-record-view ,record))

(defun 1change-record-view0 (record-node)
  (let ((new-view (menu-choose-record-view)))
    (when new-view
      (change-record-view-to record-node new-view)))
  nil)

(defun 1menu-choose-record-view0 ()
  (dw:menu-choose '(("All fields" . :all)
		    ("Contents text" . :contents)
		    ("Outline" . :outline)
		    ("Record header only" . :record-header-only))))

(defun 1change-record-view-to0 (record-node new-view)
  (sage::move-boundary-bps-of-all-other-record-nodes record-node)
  ;; ensure that the node has its contents before we change the view
  (when (null (node-inferiors record-node))	;Node was collapsed by another buffer
    (let ((new-record-node (reexpand-record-node record-node)))
      (move-nonboundary-bps-of-node-to record-node (node-first-bp new-record-node))
      (setq record-node new-record-node)))
  ;; Move any BP's from lines that are about to disappear onto
  ;; lines that will still be visible in the new view.
  (cl:ecase new-view
    (:all nil)
    (:contents
	(dolist (field-node (node-inferiors record-node))
	  	  (unless (or (and (nsage::doc-record-field-contents-field?
				     (markup-structure-node-markup-structure field-node))
				   ;; If we are changing from :outline to :contents, move
				   ;; bps out of contents field
				   (not (eql (markup-structure-node-record-view field-node)
					     :outline)))
		      (eql :contents (markup-structure-node-record-view field-node))
		      (eql :record-header-only (markup-structure-node-record-view field-node)))
	    (move-nonboundary-bps-of-node-to field-node (node-last-bp record-node)))))
    (:outline
      ;; move the bp's of text nodes to their superior's
      (labels ((maybe-move-bps (node)
		 (cl:etypecase node
		   (markup-structure-text-node
		     (move-nonboundary-bps-of-node-to
		       node (node-first-bp (node-superior node))))
		   (markup-structure-node
		     (cl:map nil #'maybe-move-bps (node-inferiors node))))))
	(maybe-move-bps record-node)))
    (:record-header-only
      (move-nonboundary-bps-of-node-to record-node (node-first-bp record-node))))
  (labels ((change-view (node)
	     (setf (markup-structure-node-record-view node) new-view)
	     (dolist (inferior (node-inferiors node))
	       (change-view inferior))))
    (change-view record-node))
  (must-redisplay *window* dis-text))

(defcom 1com-change-record-view0 "Change view of record at point" ()
  (multiple-value-bind (nil record-node) (sage::record-at-point)
    (let ((new-view (menu-choose-record-view)))
      (when new-view
	(change-record-view-to record-node new-view))))
  dis-text)

(defcom 1com-change-all-record-views0 "Change view of all records in buffer" ()
  (let ((new-view (menu-choose-record-view)))
    (when new-view
      (dolist (node (node-inferiors *interval*))
	(when (typep node 'record-structure-node)
	  (change-record-view-to node new-view))))
  (move-point (node-first-bp *interval*))
  dis-text))

;;; Call this when a record is expanded somewhere else
(defun 1collapse-record-node0 (record-node)
  (setf (markup-structure-node-record-view record-node) :record-header-only)
  (setf (node-inferiors record-node) nil))

;;; resurrect the contents of a previously-collapsed node
(defun 1reexpand-record-node0 (record-node)
  (when (null (node-inferiors record-node))
    (let* ((superior-node (node-superior record-node))
	   (record (markup-structure-node-markup-structure record-node))
	   (new-record-node (markup-structure-editor-node
			      record superior-node)))
      (nsubst new-record-node record-node (node-inferiors superior-node))
      (redo-node-links superior-node)
      new-record-node)))

(defun 1show-line-links0 (first-line)
  (loop for line = first-line then (line-next-in-buffer line :buffer *interval*) while line do
    (let ((node (line-node line)))
      (format t "~&~S ~@[~S ~] ~S~%" line (line-diagram line) node))))

(defun 1show-line-previous-links0 (last-line)
  (loop for line = last-line then (line-previous-in-buffer line :buffer *interval*)
	while line do
    (let ((node (line-node line)))
      (format t "~&~S ~@[~S ~] ~S~%" line (line-diagram line) node))))

;;; Views
(defmethod 1(change-markup-structure-node-view-to0 1markup-structure-node)0 
	   (new-view)
  (setq node-view new-view)
  (diagram-lines-need-redisplay self)
  (must-redisplay *window* dis-text))

(defmethod 1(markup-structure-node-views markup-structure-node :default)0 ()
  '(("The normal view" . :normal)))

(define-presentation-to-editor-command-translator 1change-markup-structure-node-view
0						  (markup-structure-node
						    "Change view"
						    *standard-comtab*
						    :gesture :1edit-0viewspecs
						    :documentation "Change view"
						    :tester 
						    ((node)
						     (> (length
							  (markup-structure-node-views
							    node))
							1)))
						  (node)
  `(change-markup-structure-node-view ,node))

(defmethod 1(change-markup-structure-node-view markup-structure-node)0 ()
  (let ((possible-views (markup-structure-node-views self)))
    ;; possibly figure out that there's a simple toggle involved
    (let ((new-view (choose-markup-structure-view possible-views
						  :current-view node-view)))
      (when new-view (change-markup-structure-node-view-to self new-view)))))

(defun 1choose-markup-structure-view0 (possible-views &key current-view force-menu)
  (cond ((and current-view (null force-menu))
	 (let ((position (cl:position current-view possible-views :key #'cdr)))
	   (setq position (mod (1+ position) (cl:length possible-views)))
	   (cdr (cl:elt possible-views position))))
	(t
	 (dw:menu-choose possible-views :prompt "Choose view"))))


;;; Pictures

(define-presentation-to-editor-command-translator 1edit-picture
0  (picture-structure-node "Edit Picture" *standard-comtab*
			:gesture :edit-1function0)
  (picture-structure-node)
  `(edit-picture-of-node ,picture-structure-node))

(defun 1edit-picture-of-node0 (picture-node)
  (let* ((picture (markup-structure-node-markup-structure picture-node))
	 (picture-type (sage::sage-picture-type picture))
	 (editor (get picture-type 'sage::edit-drawing))
	 (picture-file-name (sage::sage-picture-file-name picture))
	 (picture-name (sage::sage-picture-name picture)))
    (if editor
	(funcall editor picture-file-name picture-name)
	(barf "I don't know how to edit pictures of type ~A" picture-type))
    ;; now we let the new picture be
    (recompile-picture-of-node picture-node)))

(defun 1recompile-picture-of-node0 (picture-node)
  (let* ((picture (markup-structure-node-markup-structure picture-node))
	 (picture-diagram (line-diagram (sys:symeval-in-instance picture-node
								 'header-line)))
	 (picture-type (sage::sage-picture-type picture))
	 (sage-picture-file-name (sage::sage-picture-file-name picture))
	 (picture-file-name (and sage-picture-file-name
				 (cl:pathname sage-picture-file-name)))
	 (picture-name (sage::sage-picture-name picture))
	 (re-encoder (get picture-type 'sage::binary-encoding)))
    ;; Standalone pictures have no re-encoding.  Do not simply barf here,
    ;; because that would abort Recompile Pictures Of Buffer.  So so nothing.
    (when re-encoder
      (mung-node picture-node)
      (if (string-equal "" picture-name)
	  (zwei:typein-line "~&Encoding picture in file ~A~%" picture-file-name)
	  (zwei:typein-line "~&Encoding ~A~%" picture-name))
      (let ((new-binary-encoding
	      (funcall re-encoder picture-file-name picture-name)))
	(setf (sage::sage-picture-binary-encoding picture) new-binary-encoding)
	(reset-drawing-function picture-diagram)
	(send picture-diagram :clear-height-cache))))
  dis-text)
      
(defmethod 1(markup-structure-node-views picture-structure-node)0 ()
  '(("Show the picture" . :picture)
    ("Just a description of the picture" . :normal)))

(defmethod 1(change-markup-structure-node-view-to picture-structure-node :after)0 (new-view)
  (ignore new-view)
  (let ((picture-diagram (line-diagram header-line)))
    (send picture-diagram :clear-height-cache)
    (must-redisplay *window* dis-all)))

(define-presentation-to-editor-command-translator 1recompile-picture
0      (picture-structure-node "Recompile Picture" *standard-comtab* :gesture ())
    (picture-structure-node)
  `(recompile-picture-of-node ,picture-structure-node))

(defcom 1sage::com-wt-recompile-all-pictures-of-buffer
0	"Regenerate the picture encoding from the version in the (graphic) editor.
If there is a region, use it, otherwise the whole buffer."
	()
  (multiple-value-bind (start-bp end-bp)
      (if (window-mark-p *window*)
	  (values (point) (mark))
	  (values (interval-first-bp *interval*) (interval-last-bp *interval*)))
    (do-lines ((line ignore ignore) (start-bp end-bp))
      (let ((node (line-node line)))
	(when (typep node 'picture-structure-node)
	  (recompile-picture-of-node node)))))
  dis-none)

(sage:define-picture-type 1:lisp
0  :binary-encoding binary-encoding-for-static-lisp-picture
  :edit-drawing edit-lisp-picture
  :argument-reader select-lisp-picture)

(sage:define-picture-type 1:dynamic-lisp
0  :binary-encoding binary-encoding-for-dynamic-lisp-picture
  :edit-drawing edit-lisp-picture
  :argument-reader select-lisp-picture)

(defun 1binary-encoding-for-static-lisp-picture0 (file name)
  (binary-encoding-for-lisp-picture file name nil))

(defun 1binary-encoding-for-dynamic-lisp-picture0 (file name)
  (binary-encoding-for-lisp-picture file name t))

(defun 1binary-encoding-for-lisp-picture0 (file name dynamic-p)
  (let ((name (scl:with-standard-io-environment (cl:read-from-string name))))
    (unless (fdefinedp name)
      (load file))
    (if dynamic-p
	(values nil name)
	(graphics:binary-encode-graphics-to-array name))))

(defun 1edit-lisp-picture0 (file name)
  (send zwei:*zmacs-command-loop*
	:find-file (send (fs:merge-pathnames file) :new-pathname :type :lisp :version :newest))
  (ed (scl:with-standard-io-environment (cl:read-from-string name))))

(defun 1select-lisp-picture0 ()
  (let ((function (zwei:typein-line-accept 'sys:function-spec
					   :prompt "Function to draw with")))
    (values (si:get-source-file-name function 'defun)
	    (scl:with-standard-io-environment (cl:write-to-string function)))))

(defun 1test-lisp-picture0 (function)
  (graphics:with-room-for-graphics ()
    (funcall function standard-output)))

;;; Tab stop stuff
(defun 1set-tab-stops-for-table0 (start-bp &optional end-bp in-order-p (extra-spaces 2))
  (get-interval start-bp end-bp in-order-p)
  (sys:with-stack-array (tabs 10 :fill-pointer 0)
    (interval-lines (start-bp end-bp) (start-line stop-line)
      (loop for line = start-line then (line-next line) until (eq line stop-line) do
	(let ((x 0)
	      (index 0)
	      (tab-no 0))
	  (loop do
	    (let* ((next-index (string-search-char #\tab line index))
		   (new-x (line-displayed-size (window-sheet *window*) line index next-index
					       x 99999))
		   (col-width (- new-x x)))
	      (if ( tab-no (fill-pointer tabs))
		  (array-push-extend tabs col-width)
		  (dw::maxf (aref tabs tab-no) col-width))
	      (when (null next-index)
		(return))
	      (setq index (1+ next-index)
		    x new-x
		    tab-no (1+ tab-no))))))
      (let ((extra (* extra-spaces (font-space-width)))
	    (running-x 0))
	(dotimes (i (fill-pointer tabs))
	  (setq running-x (+ (aref tabs i) running-x extra))
	  (setf (aref tabs i) running-x)))
      (let ((tab-function (let ((tabs (cl:copy-seq tabs)))
			    #'(lambda (sheet line index x)
				(max (+ x (tv:sheet-char-width sheet))
				     (let ((tab-no (cl:count #\tab line
							     :test #'char-equal
							     :end index)))
				       (if (< tab-no (array-active-length tabs))
					   (aref tabs tab-no)
					   0)))))))
	(loop for line = start-line then (line-next line) until (eq line stop-line) do
	  (setf (line-tab-function line) tab-function)
	  ;;(mung-line line)
	  )))))

(defcom 1com-align-table-tabs0 "" ()
  (region (bp1 bp2)
    (set-tab-stops-for-table bp1 bp2))
  dis-all)

(set-comtab *zmacs-comtab*
  ()
  (make-command-alist '(com-align-table-tabs)))

(defun 1wt-character-style-function0 (line stream)
  (ignore stream)
  (loop for node = (line-node line) then (node-superior node) while node
	do
    (cond ((typep node 'environment-structure-node)
	   (let ((sage-thing (markup-structure-node-markup-structure node)))
	     (return (lookup-character-style-cache sage-thing))))
	  ((typep node 'doc-record-field-structure-node)
	   (let* ((sage-thing (markup-structure-node-markup-structure node))
		  (sage-superior (sage::directive-superior sage-thing)))
	     (when (and (typep sage-superior 'sage::lisp-record)
			(eq (sage::doc-record-arglist sage-superior) sage-thing))
	       (return '#,(si:parse-character-style '(nil :italic nil)))))))))

(defvar 1*sage-envr-character-style-cache*0	;(clrhash *sage-envr-character-style-cache*)
	(cl:make-hash-table :test #'cl:equal))

(defmacro 1with-sage-envr-character-style-cache-key0 ((sage-envr key-var) &body body)
  `(with-sage-envr-character-style-cache-key-1
     ,sage-envr
     (dw:named-continuation with-sage-envr-character-style-cache-key
			    (,key-var)
       ,@body)))

(defmethod 1(with-sage-envr-character-style-cache-key-1 sage::sage-envr)0 (continuation)
  (declare (sys:downward-funarg continuation))
  (stack-let ((key (cons sage::envr-name sage::envr-mods)))
    ;; This might want to simply construct its key
    ;; from the envr-name and the facecode envr-mod.
    (funcall continuation key)))

(defmethod 1(clear-character-style-cache sage::sage-envr)0 ()
  (with-sage-envr-character-style-cache-key (self key)
    (remhash key *sage-envr-character-style-cache*)))

(defmethod 1(lookup-character-style-cache sage::sage-envr)0 ()
  (with-sage-envr-character-style-cache-key (self key)
    (multiple-value-bind (character-style found-p)
	(gethash key *sage-envr-character-style-cache*)
      (if found-p character-style
	  (setf (gethash (cl:copy-list key) *sage-envr-character-style-cache*)
		(compute-character-style self))))))

(defmethod 1(compute-character-style sage::sage-envr)0 ()
  (let ((facecode (second (assoc 'sage::facecode sage::envr-mods))))
    (flet ((facecodecharacter-style (facecode)
	     (cond ((member facecode '(sage::t))
		    (return-from compute-character-style
		      '#,(si:parse-character-style '(nil sage::typewriter nil))))
		   ((not (null facecode)) (return-from compute-character-style nil)))))
      (or (facecodecharacter-style facecode)
	  (block found-it
	    (sage::with-document-and-device-types ()
	      ;; --- shouldn't this be a subroutine somewhere?
	      (labels ((recurse (environment-name)
			 (let* ((dd (sage::lookup-directive-descriptor environment-name))
				(dd-definition (sage::dd-definition dd)))
			   (dolist (thing dd-definition)
			     (destructuring-bind (key value) thing
			       (cond ((eq key 'sage::facecode)
				      (return-from found-it (facecodecharacter-style value)))
				     ((member key '(sage::use sage::copy))
				      (recurse value))))))))
		(recurse sage::envr-name))))))))



;; Some things that perhaps belong in Zmacs
(defun 1change-face-of-interval0 (face)
  (definition-region (bp1 bp2)
    (change-style-interval bp1 bp2 t
			   (si:intern-character-style nil face nil))
    (loop with start-line = (bp-line bp1)
	  with end-line = (bp-line bp2)
	  with window = *window*
	  for line = (bp-line bp1) then (line-next-in-buffer line)
	  when line
	    do (must-redisplay window dis-line line (if (eql line start-line)
							(bp-index bp1)
							0))
	  until (or (null line) (eql line end-line)))
    )
  dis-text)

(defcom 1com-change-region-to-italic0 "Change character style of the region to italic" ()
  (change-face-of-interval :italic))

(defcom 1com-change-region-to-bold0 "Change character style of the region to bold" ()
 (change-face-of-interval :bold))

(defcom 1com-change-region-to-regular0 "Change character style of the region to regular
That is, nil.nil.nil" ()
  (change-face-of-interval nil))

(defmethod (sage::describe-citation command-structure-node) ()
  (sage::describe-citation markup-structure))

(define-presentation-to-editor-command-translator 1describe-citation-zwei-diagram
0  (command-structure-node
    "Show Cited Entry" sage:*wt-comtab*
    :gesture :meta-middle			;---
    :tester ((node)
	     (eql (send-if-handles (markup-structure-node-markup-structure node) :command-name)
		  'cite)))
  (object)
  `(sage::describe-citation ,(markup-structure-node-markup-structure object)))

;;; The "trailer-p" stuff.
(defgeneric 1mdl-trailer-p 0(diagram line direction)
  (:method (environment-header-line)
   (ignore line direction)
   trailer-p)
  (:method (editable-command-header-line)
   (let ((line-node (and (array-has-leader-p line)
			 (line-node line))))
     (if line-node
	 (if (eql (markup-structure-node-node-view line-node) :normal)
	     (not (eql direction :for-previous))
	     (trailer-p-1 line direction))
	 ;; Assume node view is :normal
	 (eql direction :for-next))))
  (:method (markup-line-diagram-mixin :default)
   (if (and (array-has-leader-p line)
	    (line-node line))
       (trailer-p-1 line direction)
       (eql direction :for-next))))

(defun markup-diagram-line-trailer-p (line)
  (let ((diagram-line (line-diagram line)))
    (when diagram-line
      (let ((markup-structure (markup-line-diagram-mixin-markup-structure diagram-line))
	    (line-node (line-node line)))
	(or (eq line (bp-line (node-last-bp line-node)))
	    (and (typep markup-structure 'sage::editable-sage-command)
		 (eql (markup-structure-node-node-view line-node) :normal)
		 (eq line (bp-line (node-first-bp line-node)))))))))





;;; Debugging code moved to sys:nsage;debug-markup-diagrams.lisp
