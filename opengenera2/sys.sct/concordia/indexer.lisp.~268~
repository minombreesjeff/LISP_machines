;;; -*- Mode: LISP; Package: NSAGE; Base: 10; Lowercase: T; Syntax: Common-lisp -*-
;;;
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
;;;


;;;contains the routines involved in creating an index of the names of the records
;;;in a sage record file.  This file calls the parser as parse-sage-records.

(defflavor D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")sab-record-sink
0	(stream (index-data) index-filepos (closed ()))
	()
  (:initable-instance-variables stream index-filepos)
  (:readable-instance-variables index-data)
  )

(defmacro 1with-sab-record-sink0 ((record-sink destination-pathname input-source) &body body)
  (declare (values bin-truename closed-stream))
  `(with-sab-record-sink-internal
     ,destination-pathname ,input-source
     (sys:named-lambda with-sab-record-sink (,record-sink)
       (declare (sys:downward-function))
       ,@body)))

(defun 1with-sab-record-sink-internal0 (destination-pathname input-source continuation)
  (declare (values bin-truename closed-stream))
  (let ((closed-stream))
    (with-open-file (stream (fs:merge-pathnames destination-pathname
						(fs:default-pathname () ()
						  :sage-binary :newest))
			    :direction :output
			    :direct t
			    :element-type '(unsigned-byte 8))
      (multiple-value-bind (attribute-string vars vals)
	  (file-attribute-string-and-bindings input-source)
	(progv vars vals
	       (let ((index-filepos (initialize-sage-compiled-file
				      stream input-source attribute-string)))
		 (let ((sink (make-instance 'sab-record-sink
					    :stream stream
					    :index-filepos index-filepos)))
		   (let ((*ask-user* T))	;allows user to correct bad packages found
		     (funcall continuation sink))	;adds to index-filepos and to stream
		   (close-sab-record-sink sink)
		   (setq closed-stream stream)	;well, it'll be closed soon enough
		   )))))
    (values (send closed-stream :truename) closed-stream)))

(defmethod 1(close-sab-record-sink sab-record-sink)0 ()
  (unless closed
    (dump-index-info stream index-filepos (nreverse index-data))
    (close stream)
    (setq closed T)))

(defmethod 1(add-sab-record-to-sink sab-record-sink)0 (record)
  (multiple-value-bind (p-start p-end)
      (write-sab-record record stream)
    (warn-on-duplicates record index-data)
    ;;The only reason to collect this info here rather than making
    ;;another pass over the records to collect the index info is to
    ;;be able to warn-on-duplicates.  Also, for the callees, I guess.
    (push (list record (indexable-data record p-start p-end))
	  index-data)))

(defun 1file-attribute-string-and-bindings0 (input-source)
  (declare (values string progv-vars progv-vals))
  (let* ((string
	   (kludge-mode-in-string
	     (string-thin
	       (typecase input-source
		 (zwei:buffer (zwei:buffer-attribute-string input-source))
		 (pathname
		  (with-open-file (stream input-source)
		    (file-attribute-string-from-stream stream)))
		 (string
		  (if (string-search "-*-" input-source)
		      input-source
		      (with-open-file (stream input-source)
			(file-attribute-string-from-stream stream))))
		 (otherwise
		   (send input-source :set-pointer 0)
		   (file-attribute-string-from-stream input-source)))
	       :remove-bits t :error-if :fat)))
	 (attributes (fs:parse-attribute-list string)))
    (multiple-value-bind (vars vals)
	(fs:file-attribute-bindings nil :additional-attributes attributes)
      (values string vars vals))))

;;; Simple version, here because fs:read-attribute-list throws it away
(defun 1file-attribute-string-from-stream0 (stream)
  (loop with line and eof
	with result = ""
	do (multiple-value-setq (line eof) (send stream :line-in))
	until (or eof
		  (and (string-search "-*-" line)
		       (setq result line))
		  (string-search-not-set '(#\sp #\tab) line))
	finally (send stream :set-pointer 0)
		(return result)))
    
;;;Tell the user when losing by having two records in a file that
;;;have the same topic and type.
(defun 1warn-on-duplicates0 (record list)
  (when (find record list :key #'first)
    (beep)
    (let ((record-group (doc-record-record-group record)))
      (format *error-output* "~&Warning: ~A ~A appears twice in this file"
	      (namespace-type-string record-group)
	      (appropriate-title-rendering record-group 'no-formatting)))
    (values)))

;;; Don't clone here unless absolutely necessary.  Improves performance of
;;; writing sab files enormously.
;;; Note that this will probably screw up when editing multiple versions of the
;;; same record, but we don't presently handle that very well anyway.
(defun 1write-list-of-records-to-sab-file0 (list-of-records destination-pathn input-source)
  (declare (values bin-truename closed-stream))
  (with-sab-record-sink (sink destination-pathn input-source)
    (tv:dolist-noting-progress (record list-of-records "Writing SAB records")
      (when record
	(let ((record-group (doc-record-record-group record)))
	  (setq record
		(cond ((and (doc-record-modified record)
			    (not (doc-record-installed record)))
		       ;; If it's modified and not installed, install it.
		       (install-edited-record-in-record-group record))
		      ((doc-record-installed record)
		       ;; If it's installed, why install it again?
		       ;; (If it's installed, it can't have been edited since
		       ;; it got installed, because 1note-record-modified0 makes 
		       ;; sure of that.)
		       (cond ((member record (record-group-edited-records record-group))
			      ;; if this record is one of the edited records, then
			      ;; use the installed record
			      (record-group-installed-record record-group))
			     (t 
			      ;; if this record is not one of the edited records
			      ;; it must be one of the temp records used by
			      ;; finish-patching-records.  We'd better use it instead.
			      record)))
		      ((let ((published-record (record-group-published-record record-group))
			     (installed-record (record-group-installed-record record-group)))
			 (and (not (doc-record-modified record))
			      (not (null published-record))
			      ;; make sure we've already read the contents from disk!!
			      (doc-record-filled published-record)
			      (null installed-record)
			      (= (doc-record-version-number record)
				 (doc-record-version-number published-record))))
		       ;; If it's unmodified, uninstalled, but the same version as
		       ;; the published record, just use the published record.
		       (record-group-published-record record-group))
		      ;; Otherwise, we must install it.
		      (t (install-edited-record-in-record-group record)))))
	(add-sab-record-to-sink sink record)))))

(defun 1indexable-data0 (record start-byte end-byte)
  (nconc `((file-attribute-string ,(doc-record-file-attribute-string record))
	   (unique-id ,(record-group-unique-id (doc-record-record-group record)))
	   (version-number ,(doc-record-version-number record))
	   (location (,start-byte ,end-byte))
	   (tokens ,(compute-doc-record-tokens record))
	   (callee-list ,(compute-doc-record-callees record))
	   )
	 (let ((patched-from (doc-record-patched-from record)))
	   (and patched-from `((patched-from ,patched-from))))
	 (and *use-record-group-index-as-unique-id*
	      (let ((index (compressed-record-group-index (doc-record-record-group record))))
		(and index `((unique-index ,index)))))
	 (doc-record-indexable-fields record)))

(defgeneric 1doc-record-indexable-fields0 (doc-record)
  (:method-combination :nconc))

(defmethod 1(doc-record-indexable-fields doc-record)0 ()
  (make-non-white-field-alist 'oneliner (record-field-contents oneliner)
			      'source-topic (record-field-contents
					      (doc-record-source-topic self))))

(defmethod 1(doc-record-indexable-fields concept-record)0 ()
  (make-non-white-field-alist ))


;;;In every file: (this is required, independent of version)
;;; 4 bytes empty
;;; 1 byte version number
;;; file attribute alist
;;; the doc records
;;; the index info

(defun 1initialize-sage-compiled-file0 (output-stream input-source attribute-string)
  (declare (values index-filepos))
  (write-32-bit-number output-stream *sage-id-pattern*)	;leave 4 spare bytes at front
  (write-8-bit-number output-stream *compiled-data-format-version*)	;overall version
  (flet ((logical-pathname-string-with-version (stream-or-name)
	   (string
	     (multiple-value-bind (path truename)
		 (typecase stream-or-name
		   (fs:pathname
		     (values stream-or-name
			     (or (send stream-or-name :truename)
				 stream-or-name)))
		   (otherwise
		     (values (send stream-or-name :pathname)
			     (send stream-or-name :truename))))
	       (if (eq (send truename :version) ':unspecific)	;UNIX encephalopathy
		   (send path :new-version :newest)
		   (send path :new-version (send truename :version)))))))
    (write-sab-file-attribute-alist
      output-stream
      :compilation-user-id (string zl:user-id)
      :compilation-machine si:local-pretty-host-name
      :compilation-time (time:print-universal-time (time:get-universal-time) ())
      :compilation-system-version (multiple-value-bind (major minor)
				      (sct:get-system-version)
				    (list major minor))
      :compilation-sage-version (multiple-value-bind (major minor)
				    (sct:get-system-version "NSAGE")
				  (list major minor))
      :logical-source-pathname (let ((pathname
				       (typecase input-source
					 (zwei:buffer
					   (guess-pathname-from-buffer input-source))
					 (pathname input-source))))
				 (if pathname
				     (logical-pathname-string-with-version pathname)
				     ""))
      :file-attribute-string attribute-string
      :logical-pathname (let ((pathname
				(if (typep input-source 'zwei:buffer)
				    (guess-pathname-from-buffer input-source t)
				    output-stream)))
			  (if pathname
			      (logical-pathname-string-with-version pathname)
			      ""))
      :truename (princ-to-string (send output-stream :truename))
;      :truename-narrative (format () "~a  ~a"	;Never do fs:parse-pathname on this!
;				  (send output-stream :truename)
;				  (send input-stream-name :truename))
      ))
  (let ((now (send output-stream :read-pointer)))
    (write-32-bit-number output-stream		;this is where the PS info is going to start
			 (+ now 8))
    (write-32-bit-number output-stream 0)	;where index info is, we'll write here later
    (+ now 4)					;where index info will go
    ))

;;; Should be abstracted from zwei:insert-patch-section-prologue
(defun 1guess-pathname-from-buffer0 (buffer &optional increment-version-if-modified
				   (allow-physical-pathname t))
  (let ((pathname (or (zwei:buffer-logical-pathname buffer)
		      (and allow-physical-pathname
			   (zwei:zmacs-buffer-p buffer)
			   (zwei:file-buffer-p buffer)
			   (send buffer :pathname))))
	(file-info (send-if-handles buffer :file-info)))
    (when pathname
      (let ((vc-p (and (listp file-info) (pathnamep (car file-info))
		       (send (car file-info) :vc-version)))
	    (version (and file-info
			  (if (eq file-info ':never-read) 0	;+1 later
			      (and (listp file-info)
				   (pathnamep (car file-info))
				   (or (send (car file-info) :vc-version)
				       (send (car file-info) :version)))))))
	(if (numberp version)
	    (send pathname (if vc-p :new-vc-version :new-version)
		  (cond ((and increment-version-if-modified (send buffer :modified-p))
			 (1+ version))
			((zerop version)
			 1)
			(t version)))
	    pathname)))))

;;;Version 1.
;;; no of records
;;; compacting codes: no of compacting codes, { code symbol }*
;;; index record: topic, type-code, info
;;;  where info is the components from *auxiliary-data* (in the order of defn)
;;;  component count
;;;  components, dumped according to the relevant dumper function
(defun 1dump-index-info0 (stream index-filepos data)
  (let ((now (send stream :read-pointer)))
    (send stream :set-pointer index-filepos)	;tell file where the index info starts
    (write-32-bit-number stream now)
    (send stream :set-pointer now))
  (write-sab-index-data data stream))


;;;Parses a document source file in "record" form into its parsed representation
;;;Stores the parsed form in a file with type SAB; along with a number of indexes
;;; (where each record starts in a file, caller info, source topic, etc.).
;;;The second argument is because make-system insists on calling it with two arguments,
;;;where the second one is for the "output file" name
;;;Actually you need the second arg in order to put the results in a differnet place from
;;;the source.  The destination arg should be a pathname; it is parsed against the first
;;;argument pathname.
(defun PARSE-AND-SAVE (source-pathname &optional destination-pathname)
  (declare (values binary source-truename binary-truename))
  (setq source-pathname (fs:merge-pathnames
			  source-pathname (fs:default-pathname () () :sage-record)))
  (let ((destination-default
	  (send source-pathname :new-pathname :canonical-type :sage-binary :version :newest)))
    (setq destination-pathname
	  (fs:merge-pathnames (or destination-pathname
				  (prompt-and-read
				    `(:pathname-or-nil :default ,destination-default)
				    "~&Parse File Destination: (default ~A) "
				    destination-default))
			      destination-default))
    (with-open-file (input-stream source-pathname)
      (multiple-value-bind (list-of-records list-of-comments)
	  (parse-records-from-file-stream input-stream)
	(let ((bin-truename (write-list-of-records-to-sab-file
			      list-of-records destination-pathname input-stream)))
	  (let ((source-truename (send input-stream :truename)))
	    (process-comments-from-source-file
	      list-of-comments source-pathname source-truename)
	    (values bin-truename source-truename bin-truename)))))))

(defun PROCESS-COMMENTS-FROM-SOURCE-FILE (list-of-comments source-pathname
					  &optional source-truename)
  (unless (null list-of-comments)
    (let ((string (filtered-string-from-contents-list
		    (send (first list-of-comments) :contents-list) t)))
      ;; Don't bother with attribute lists
      (when (and (string-search "-*-" string)
		 (not (string-search-char #\return string)))
	(setq list-of-comments (cdr list-of-comments))))
    (unless (null list-of-comments)
      (let ((comment-pathname
	      (send source-pathname :new-pathname
		    :name (string-append (send source-pathname :name) "-COMMENTS")
		    :canonical-type :text
		    :version (if (eql (send source-pathname :version) :unspecific)
				 :unspecific
				 :newest))))
	(let ((closed-stream
		(with-open-file (stream comment-pathname :direction :output
					:element-type 'character)
		  (format stream "Comments found outside records while parsing file ~A:~%"
			  (or source-truename (send source-pathname :truename)))
		  (dolist (comment list-of-comments)
		    (format stream "~%---- Begin Comment ----~%~A~%---- End Comment ----~%"
			    (filtered-string-from-contents-list
			      (send comment :contents-list) t)))
		  stream)))
	  (format *standard-output* "~&Written: ~A"
		  (send comment-pathname :new-version
			(send (send closed-stream :truename) :version))))))))

(defun PARSE-AND-INSTALL-RECORDS (source-pathname)
  (setq source-pathname (fs:merge-pathnames
			  source-pathname (fs:default-pathname () () :sage-record)))
  (with-open-file (input-stream source-pathname)
    (let ((index-data ()))
      (dolist (record (parse-records-from-file-stream input-stream))
	(let ((topic (doc-record-topic record))
	      (type (doc-record-source-type record)))
	  (push (list topic type (indexable-data record nil nil))
		index-data)))
      (let* ((truename (send input-stream :truename))
	     (source-path-to-install
	       (string
		 (if (eql (send truename :version) ':unspecific)	;UNIX encephalopathy
		     (send source-pathname :new-version :newest)
		     (send source-pathname :new-version (send truename :version))))))
	(setq index-data (nreverse index-data))
	(let ((add-word-hash-table (make-hash-table))	;test #'eql -- tokens are unique
	      (remove-word-hash-table (make-hash-table)))
	  (unwind-protect
	      ;;--- If we ever allow pointy hands, etc., in sab files, need to
	      ;; get the attribute string out of the sab-attribute-alist and
	      ;; do file-attribute-bindings here.  Also would need to
	      ;; canonicalize-record-contents later.
	      (progn
		(install-index-info
		  index-data *topic-aarray* add-word-hash-table remove-word-hash-table
		  source-path-to-install nil)
		(dolist (item index-data)
		  (destructuring-bind (topic type fields) item
		    (let* ((unique-id (second (assoc 'unique-id fields)))
			   (version-number (second (assoc 'version-number fields)))
			   (record (find-record-for-topic-and-type
				     topic type :published :unique-id unique-id
				     :version-number version-number :create-p nil)))
		      (if record
			  (setf (doc-record-disk-location record) nil)
			  (cerror "Skip setting disk-location to NIL"
				  "While trying to set disk-location to NIL, couldn't find ~
                                   an installed record for ~A ~S."
				  (string-capitalize-words type) topic))))))
	    (finish-installing-sage-records add-word-hash-table remove-word-hash-table)))
	(sys:set-file-stream-loaded-id input-stream si:pkg-user-package)
	(values source-pathname truename)))))

(defun PARSE-RECORDS-FROM-FILE-STREAM (stream)
  (declare (values list-of-records list-of-commentary-environments))
  (with-document-and-device-types ()		;bind document and device types around parser
    (let ((generic-input-pathname (send (send stream :pathname) :generic-pathname)))
      (fs:read-attribute-list generic-input-pathname stream)
      (multiple-value-bind (fvars fvals)
	  (fs:file-attribute-bindings generic-input-pathname)
	(progv fvars fvals
	       (multiple-value-bind (records comments)
		   (parse-sage-records stream)
		 (values records comments)))))))

;; This makes sar files read in in fundamental mode.
;; Without this, you can't even get file attribute bindings 
;; for a .sar file in order to compile it!  
(zwei:add-major-mode 'zwei:fundamental-mode :sage)

#||
(2 0 (NIL 0) (NIL NIL :SMALLER) "EINY7");;;People can't remember the compile/load and memory/disk and source/binary distinctions
;;;so package everything up in order to try to help.
(defun PARSE-SAVE-LOAD (source &optional destination)
  (let ((where (parse-and-save source destination)))
    (load-index-info where)))

;;;Get at parse-and-save using the name that make-system knows for it.
;;; This wants to be 'parse-and-save, not #'parse-and-save, to get the most recent version.
(deff zl-user::sage-parse-and-save 'parse-and-save)
(deff cl-user::sage-parse-and-save 'parse-and-save)
0||#
2
0#||
2;;;Call it like this: (environment-equal "foo" "bar@begin[foo]" ':begin)
;;;If this envr contains the beginning of a foo envr, it returns the char position
;;; where the @ is, otherwise nil.  Second value is where name of envr starts if long form.
;;;The symbols for longform are :begin and :end.  You have to say which you are expecting to
;;;match.  Obviously the short form @foo can never match for ':end.
(defun ENVIRONMENT-EQUAL (envr str begin-or-end &optional (from 0))
  (loop	with long-form-p
	with found
	for where = (string-search-flag-char *flag-char* str from)	;where's next real @
	while where				;any more @ to check?
	do
	(setq from (1+ where))
	(multiple-value-setq (found long-form-p)
	   (environment-equal-anchored envr str begin-or-end where))
	(when found
	  (return (values where long-form-p)))))

;;;Just like environment-equal, but looks at a specified position (default 0)
;;;Returns T if envr begins (or with long form, ends) at that position of the string,
;;;and returns non-nil as second value if it was a long-form begin or end (actually
;;;returns what long-form-environment-p returns -- position of name of envr in str)
;;;A lot of the groping around with string-search in here is being done to avoid
;;;consing substrings.
(defun ENVIRONMENT-EQUAL-ANCHORED (envr str begin-or-end &optional (pos 0))
  (if (string-equal "" str)
      (values nil nil)
      (let ((where (long-form-environment-p str pos)))
	(values
	  (if where
	      (progn				;long-form environment found
;	    (setq str (string-trim *white-space* str))	;paranoia - screws up value of where
		(let* ((open-pos (string-search-set *open-delims* str :end where :from-end t))
		       (close-pos (string-search-set *arg-break-set* str :start where))
		       (end (1+ (string-search-not-char #\space str :end close-pos :from-end t))))
		  (and (string-equal str (string begin-or-end)	;we got the right long form
				     :start1 (1+ pos)
				     :start2 0 :end1 open-pos)	;begin/end [rejects @begin [foo] due to sp]
		       (string-equal str envr :start1 where :start2 0 :end1 end))))	;we got the name we wanted
	      (unless (eq begin-or-end ':end)	;@foo can never be the end of an envr!!
		(multiple-value-bind (ignore name-start)
		    (flag-char-p *flag-char* str pos)
		  (and name-start
		       (when (> (string-length str) (string-length envr))
			 (string-equal str envr
				       :start1 name-start :start2 0 :end1 (+ name-start (string-length envr))))))))
	  where))))

;;;returns position following delimiter if the string starts with @begin or @end,
;;; followed by delimiter.  So you have index for where the name of envr starts in string
;;;Tried to be impervious to minor syntactic variation in the form of extra white space
;;;like in @begin( foo,...)
;;;This manages to survive "... @begin foo" with no delimiter, correctly returning NIL
;;;but it could well be fragile.
(defun LONG-FORM-ENVIRONMENT-P (str &optional (from 0))
  (unless (string-equal "" str)			;don't do anything if str is null string
    (multiple-value-bind (maybe from)
	(flag-char-p *flag-char* str from)
      (when maybe
	(let* ((open-pos (string-search-set *open-delims* str :start from))
	       (where (1+ (string-search-not-char	;bound the perhaps "begin"
			    #\space str :end open-pos :from-end t))))
	  (if (or (string-equal str "begin" :start1 from :start2 0 :end1 where)
		  (string-equal str "end" :start1 from :start2 0 :end1 where))
	      (string-search-not-char #\space str :start (1+ open-pos))))))))	;start of envr name

;;;for creating a short form environment that doesn't blow the delimiters due to text
;;;delimiters in the contents
(defun CREATE-ENVIRONMENT (envr contents)
  (multiple-value-bind (open close)
      (choose-safe-delim contents)
    (format nil "@~A~C~A~C" (string-capitalize-words envr)
	    open contents close)))
0||#



;;; Alternative version of compressed database.

;;;; Record field encoding.

;; Before doing any encoding, run 1prepare-to-encode-record-fields
0;; which looks at all the records in the world, collecting things.
;; It takes about five minutes.
;; It returns an instance of the flavor record-field-encoding.
;; I'll call it RFE here.  The RFE has a :fasd-form method.
;;
;; To encode a record field: call 1encode-record-field 0with
;; the RFE and the record-field.  It returns a vector of (unsigned-byte 8).
;;
;; To decode a record field: call 1decode-encoded-field-contents 0with
;; the RFE and the vector of (unsigned-byte 8).  It returns a contents list.
;; I didn't write anything to get that put into a record-field instance.
;;
;; ---The copy-seq at the end of encode-record-field might
;; want some area other than the default.

;; ---This might want a different definition.
(defun 1map-over-the-record-groups0 (function progress-note)
  (tv:maphash-noting-progress
    (lambda (ignore record-group)
      (funcall function record-group))
    *unique-idrecord-group-registry*
    progress-note))

(defgeneric 1map-over-markup0 (sage-directive function)
  (:function
    (etypecase sage-directive
      (list
	(dolist (x sage-directive)
	  (map-over-markup x function)))
      ((or string symbol number) )
      (instance (funcall (flavor:generic map-over-markup) sage-directive function))))
  (:method (sage-envr)
   (funcall function 'sage-envr envr-name envr-mods)
   (map-over-markup contents-list function))
  (:method (sage-command)
   ;; This doesn't by itself hack nested contents in parameter, although the caller
   ;; certainly has to think about it.  As of 11/11/87, this encounters no commands 
   ;; other than @L.
   (funcall function 'sage-command command-name parameter))
  (:method (sage-text-structure)
   (when (zwei:interval-fat-p interval)		;when there are any fat chars in interval
     (let ((contents-list
	     (dynamic-flet ((make-sage-text-structure-from-string (string superior)
								  (ignore superior) string))
	       (destyle-text-list (list self)))))
       (map-over-markup contents-list function))))
  (:method (sage-reference)
   (map-over-markup (encodable-contents-list self) function))
  )

;; special case field=topic
(defmethod 1(encodable-contents-list sage-reference)0 ()

  (if (and (null view) (equal field '(topic)))
      (let ((type (record-group-type record-group)))
	(cond ((lisp-object-type-p type)
	       (list (make-sage-command 'L (list (list (record-group-topic record-group))))))
	      ((concept-type-p type)
	       (let ((title-contents-list
		       (appropriate-title-rendering record-group 'formatting)))
		 (making-sage-directives ()
		   (if (document-p record-group)
		       (in-environment (() I)
			 (sage-contents-list () title-contents-list))
		       (in-environment (() R)
			 "\""
			 (sage-contents-list () title-contents-list)
			 "\"")))))
	      (T (error "Don't know what kind of records are in ~s" record-group))))
      (prog1
	nil
	(cerror "Ignore the reference"
		"References in oneliners are not currently supported.~@
		 The reference is ~S" self))))

(defun 1prepare-to-encode-record-fields0 ()
  (declare (values record-field-encoding))
  (let ((all-envrs ())
	(all-commands ())
	;; The table sizes are good ones as of 11/11/87
	(all-L-command-args (make-hash-table :size 900))
	(all-other-things-table (make-hash-table :test #'equal :size 10)))
    (flet ((add-to-count (entry master-list)
	     (let ((there (assoc entry master-list)))
	       (if there
		   (incf (second there))
		   (push (list entry 1) master-list)))
	     master-list)
	   (add-to-table (thing table)
	     (unless (gethash thing table)
	       (setf (gethash thing table)
		     ;; I can never remember the generic function for this message
		     (send table :filled-elements)))))
      (map-over-the-record-groups
	(named-lambda map-over-the-record-groups (record-group)
	  (let ((record (find-record-for-lookup record-group)))
	    (when record
	      (labels ((doit (type name stuff)
			 (ecase type
			   (sage-envr
			     (when (null stuff)
			       ;; when there's hairy stuff, it's handled separately
			       (setq all-envrs (add-to-count name all-envrs))))
			   (sage-command
			     (cond ((eq name 'L)
				    (if (sage-L-command-can-be-simply-encoded stuff)
					(add-to-table (first (first stuff))
						      all-L-command-args)
					(add-to-table stuff all-other-things-table)))
				   ((null stuff)
				    (setq all-commands
					  (add-to-count name all-commands))))))))
		(doc-record-map-over-interesting-fields
		  record
		  (lambda (thing)
		    (map-over-markup thing #'doit)))))))
	"Preparing record field encodings"))
    (make-record-field-encoding
      (map 'vector #'first (sort all-envrs #'> :key #'second))
      (map 'vector #'first (sort all-commands #'> :key #'second))
      ;; Perhaps there's a way to sort this by packages to reduce paging or something
      all-L-command-args
      all-other-things-table)))


(defgeneric 1doc-record-map-over-interesting-fields0 (doc-record function)
  (:method-combination :progn)
  (:method (doc-record)
   (funcall function (if (typep oneliner 'record-field)
			 (record-field-contents ONELINER)
			 oneliner))
   (funcall function (if (typep source-topic 'record-field)
			 (record-field-contents SOURCE-TOPIC)
			 source-topic)))
  (:method (concept-record)
   (funcall function (if (typep source-title 'record-field)
			 (record-field-contents SOURCE-TITLE)
			 source-title))))

(defun 1sage-L-command-can-be-simply-encoded0 (L-command-arg)
  (and (= 1 (length L-command-arg))
       (= 1 (length (first L-command-arg)))
       (symbolp (first (first L-command-arg)))))

(defun 1encode-record-field0 (encoding-tables record-field-contents)
  (let ((envr-vector (record-field-encoding-envr-vector encoding-tables))
	(command-vector (record-field-encoding-command-vector encoding-tables))
	(L-command-arg-table (record-field-encoding-L-command-arg-table encoding-tables))
	(thing-table (record-field-encoding-thing-table encoding-tables)))
    (stack-let ((temp-encoding (make-array 500
					   :element-type '(unsigned-byte 8)
					   :fill-pointer 0)))
      (labels ((find-envr-name-index (envr-name)
		 (or (position envr-name envr-vector)
		     (error "Failed to find envr-name ~s in ~s"
			    envr-name encoding-tables)))
	       (find-command-name-index (command-name)
		 (or (position command-name command-vector)
		     (error "Failed to find command-name ~s in ~s"
			    command-name encoding-tables)))
	       (find-L-command-arg-index (arg)
		 (or (gethash arg L-command-arg-table)
		     (error "Failed to find L-command-arg ~s in ~s" arg encoding-tables)))
	       (find-thing-index (thing)
		 (or (gethash thing thing-table)
		     (error "failed to find thing ~s in ~s" thing encoding-tables)))
	       (encoding-byte (byte)
		 (assert (typep byte '(unsigned-byte 8)))
		 (vector-push-extend byte temp-encoding))
	       (encoding-2-bytes (number)
		 (assert (typep number '(unsigned-byte 16)))
		 (vector-push-extend (ldb (byte 8 0) number) temp-encoding)
		 (vector-push-extend (ldb (byte 8 8) number) temp-encoding))
	       (encode-string (string)
		 (let ((length-of-string (length string)))
		   (encoding-byte =field-contents-encoding-string=)
		   (encoding-2-bytes length-of-string)
		   (sys:with-data-stack
		     (if (eq (array-element-type string) 'string-char)
			 (let ((pseudo (sys:make-stack-array length-of-string
							     :element-type '(unsigned-byte 8)
							     :displaced-to string)))
			   (vector-push-portion-extend temp-encoding pseudo))
			 (let ((thin8 (sys:make-stack-array length-of-string
							    :element-type '(unsigned-byte 8)))
			       (string string))
			   (declare (sys:array-register thin8 string))
			   (dotimes (j (length string))
			     (setf (aref thin8 j)
				   ;; RWK, don't feel too bad about this char-code.
				   ;; We already proved all chars are string-char-p.
				   (char-code (aref string j))))
			   (vector-push-portion-extend temp-encoding thin8))))))
	       (encode-thing (thing)
		 (encoding-byte =field-contents-encoding-extension=)
		 (encoding-2-bytes (find-thing-index thing)))
	       (encode-contents-list (contents-list)
		 (dolist (directive contents-list)
		   ;; It would be nice for the per-type clauses here to be methods,
		   ;; except that then they don't share the nice Pascal lexical
		   ;; environment here.  Fixed in CLOS, maybe.
		   (etypecase directive
		     (string
		       (if (notevery #'string-char-p directive)
			   (let ((contents-list (contents-list-from-fat-string directive)))
			     (encode-contents-list contents-list))
			   (encode-string directive)))
		     (sage-envr
		       (let ((envr-name (send directive :envr-name))
			     (envr-mods (send directive :envr-mods))
			     (contents-list (send directive :contents-list)))
			 (if envr-mods
			     (encode-thing directive)
			     (let ((envr-name-index (find-envr-name-index envr-name)))
			       (encoding-byte =field-contents-encoding-envr=)
			       (encoding-byte envr-name-index)
			       (encode-contents-list contents-list)
			       (encoding-byte =field-contents-encoding-end-of-envr=)))))
		     (sage-command
		       (let ((command-name (send directive :command-name))
			     (parameter (send directive :parameter)))
			 (cond ((eq command-name 'L)
				(if (sage-L-command-can-be-simply-encoded parameter)
				    (let ((index (find-L-command-arg-index
						   (first (first parameter)))))
				      (encoding-byte =field-contents-encoding-L-command=)
				      (encoding-2-bytes index))
				    (let ((index (find-thing-index parameter)))
				      (encoding-byte
					=field-contents-encoding-extended-L-command=)
				      (encoding-2-bytes index))))
			       ((null parameter)
				(encoding-byte =field-contents-encoding-command=)
				(encoding-byte (find-command-name-index command-name)))
			       (T (encode-thing directive)))))
		     (sage-text-structure
		       (encode-contents-list
			 (dynamic-flet ((make-sage-text-structure-from-string (string superior)
									      (ignore superior) string))
			   (destyle-text-list (list directive)))))
		     (sage-reference
		       (encode-contents-list
			 (encodable-contents-list directive)))
		     ))))
	(etypecase record-field-contents
	  (list (encode-contents-list record-field-contents))
	  (string
	    ;;unfattened record-field contents
	    (encode-string record-field-contents))
	  (record-field
	    (encode-contents-list (record-field-contents record-field-contents))))
	(copy-seq temp-encoding)))))

#+Ignore
;; This maps over all record-groups in the running world,
;; looking at their oneliner,source-topic,source-title fields.
;; It encodes each, decodes that, and compares the mss-contents-list
;; of both.  It passes the test, 11/11/87
(3 0 (NIL 0) (NIL NIL :SMALL) "TVFONT")(defun (4 0 (NIL 0) (NIL :BOLD :SMALL) "TVFONTCB")encode-all-interesting-record-fields3 (encoding-tables)
  (let ((longest-encoding ()))
    (map-over-the-record-groups
      (named-lambda map-over-the-record-groups (record-group)
	(let ((record (find-record-for-lookup record-group)))
	  (when record
	    (doc-record-map-over-interesting-fields
	      record
	      (named-lambda interesting-fields (contents)
		(flet ((mss-it (thing)
			 (with-output-to-string (stream)
			   (mss-contents-list stream (if (consp thing) thing (list thing))))))
		  (let* ((encoding (encode-record-field encoding-tables contents))
			 (decoding (decode-encoded-field-contents encoding-tables encoding))
			 (mss-original (mss-it contents))
			 (mss-codec (mss-it decoding)))
		    (when (> (length encoding) (length longest-encoding))
		      (setq longest-encoding encoding))
		    (unless (string= mss-original mss-codec)
		      (break "There's a difference between~%  ~a~%and~%  ~a~%"
			     mss-original mss-codec)))))))))
      "Encoding all record-fields")
    longest-encoding))
0
(defun compress-record-group (record-group)
  (let ((doc-record (record-group-published-record record-group))
	(word-1 0)
	(word-2 0)
	(field-flags 0)
	(fields nil))
    (let ((type (record-group-type record-group)))
      (setf (sys:%logldb %%compressed-record-group-1-type word-1)
	    (position type *compressed-record-group-types*)))
    (when doc-record
      (let ((disk-location (first (doc-record-disk-location doc-record))))
	(when disk-location
	  (destructuring-bind (file start-location end-location)
	      disk-location
	    (assert
	      (and (< start-location
		      (ash 1 (byte-size %%compressed-record-group-2-disk-location-position)))
		   (< (- end-location start-location)
		      (ash 1 (byte-size %%compressed-record-group-1-disk-location-length)))))
	    (setf (sys:%logldb %%compressed-record-group-1-disk-location-length word-1)
		  (- end-location start-location))
	    (setf (sys:%logldb %%compressed-record-group-2-disk-location-file word-2)
		  (1+ (position file *compressed-disk-location-files*)))
	    (setf (sys:%logldb %%compressed-record-group-2-disk-location-position word-2)
		  start-location)))))
    (let ((callers (record-group-callers record-group)))
      (when callers
	(setf (sys:%logldb %%compressed-record-group-field-callers field-flags) 1)
	(push (compress-caller-alist callers) fields)))
    (when doc-record
      (let ((callees (doc-record-callees doc-record)))
	(when callees
	  (setf (sys:%logldb %%compressed-record-group-field-callees field-flags) 1)
	  (push (compress-caller-alist callees) fields)))
      (let ((keyword-tokens (rest (doc-record-tokens doc-record))))
	(when keyword-tokens
	  (setf (sys:%logldb %%compressed-record-group-field-keyword-tokens-other-than-topic
			     field-flags) 1)
	  (push (compress-keyword-token-list keyword-tokens) fields)))
      (let ((oneliner (doc-record-oneliner doc-record)))
	(when oneliner
	  (let ((contents (record-field-contents oneliner)))
	    (when contents
	      (setf (sys:%logldb %%compressed-record-group-field-oneliner field-flags) 1)
	      (push (compress-record-field-contents contents) fields)))))
      (when (stringp (record-group-topic record-group))
	(let ((source-topic (doc-record-source-topic doc-record)))
	  (when source-topic
	    (unless (string= (labels ((to-string (contents-list)
					(etypecase contents-list
					  (string contents-list)
					  (cons
					    (with-output-to-string (stream)
					      (mss-contents-list stream contents-list)))
					  (record-field
					    (to-string
					      (record-field-contents contents-list))))))
			       (to-string source-topic))
			     (record-group-topic record-group))
		(setf (sys:%logldb %%compressed-record-group-field-source-topic-with-markup
				   field-flags) 1)
		(push (compress-record-field-contents source-topic) fields))))))
    (make-compressed-record-group-internal-2 (record-group-topic record-group)
					     word-1 word-2
					     field-flags (reverse fields))))

(defun compress-caller-alist (caller-alist)
  (stack-let ((result (make-array 10 :fill-pointer 0)))
    (loop for (how . records) in caller-alist do
      (vector-push-extend how result)
      (loop for (first second) on records by 'cddr do
	(flet ((index (record)
		 (1+ (compressed-record-group-index
		       (if (typep record 'doc-record)
			   (doc-record-record-group record)
			   record)))))
	  (let ((word (index first)))
	    (when second
	      (setf (sys:%logldb (byte 16 16) word) (index second)))
	    (vector-push-extend word result)))))
    (coerce result 'list)))

(defun compress-keyword-token-list (keyword-tokens)
  (stack-let ((result (make-array 10 :fill-pointer 0))
	      (word 0)
	      (first t))
    (dolist (set keyword-tokens)
      (loop for (token . rest) on set do
	(let ((halfword (1+ (search-sorted-keyword-tokens token
							  *sorted-keyword-token-indices*
							  *keyword-token-characters*))))
	  (when (null rest)
	    (setf (sys:%logldb (byte 1 15) halfword) 1))
	  (if first
	      (setq word halfword
		    first nil)
	     (setf (sys:%logldb (byte 16 16) word) halfword)
	     (vector-push-extend word result)
	     (setq first t
		   word 0)))))
    (unless first
      (vector-push-extend word result))
    (coerce result 'list)))

(defun compress-record-field-contents (contents-list)
  (encode-record-field *compressed-record-group-field-encoding*
		       (etypecase contents-list
			 (list contents-list)
			 (record-field (record-field-contents contents-list)))))


(defun compile-doc-database (&key (system-name "DOC") (copy-files t))
  ;; By now, SCT has loaded all of the SAB files, etc.
  (setq *doc-system-version* (sct:get-system-version system-name))
  ;; Generate the in-core compressed version, generating warnings as you go.
  (make-compressed-record-group-tables)
  ;; Rewrite all files to have compressed unique ids and caller information
  (when copy-files
    (dotimes (index (length *compressed-disk-location-files*))
      (let* ((source-file (aref *compressed-disk-location-files* index))
	     (compressed-file (compressed-database-file source-file :system-name system-name)))
	(when (condition-case ()
		   (open compressed-file :direction :probe-directory)
		 ((fs:file-not-found fs:directory-not-found) t)
		 (:no-error nil))
	  (fs:create-directories-recursively compressed-file))
	(copy-installed-sab-file source-file compressed-file)
	(setf (aref *compressed-disk-location-files* index) compressed-file))))

  (let* ((records *compressed-record-groups*)
	 (n-records (length records)))
    (tv:dotimes-noting-progress (i n-records "Compressing record groups")
      (setf (aref records i) (compress-record-group (aref records i)))))

  ;; Write the compressed file for use by readers.
  (let ((pathname (compressed-database-file "COMPRESSED-INDEX-A.BIN.NEWEST"
					    :system-name system-name)))
    (setq pathname (write-compressed-doc-database pathname :system-name system-name))
    (format t "~&Wrote ~A.~%" pathname))

  ;; Write the uid file for use by writers.
  (let ((pathname (compressed-database-file "COMPRESSED-INDEX-AW.BIN.NEWEST"
					    :system-name system-name)))
    (setq pathname (write-compressed-uid-file pathname))
    (format t "~&Wrote ~A.~%" pathname))

  )

(defun make-compressed-record-group-tables ()
  (let ((n-records 0))
    (let ((types nil)
	  (files nil)
	  (bad-uids nil)
	  (topic-phonies nil))
      (maphash #'(lambda (unique-id record-group)
		   (let ((record-unique-id (record-group-unique-id record-group))
			 (doc-record (record-group-published-record record-group)))
		     (cond ((neq unique-id record-unique-id)
			    (warn "~Q"
			      (lambda ()
				(format t "The unique id ~A points to " unique-id)
				(present record-group 'record-group)
				(format t ",~% but the unique id for that record is ~A."
					record-unique-id)))
			    (push unique-id bad-uids))
			   (t
			    (when (null doc-record)
			      (warn "~Q"
				(lambda ()
				  (format t "No record loaded for ")
				  (present record-group 'record-group)
				  (let ((references (record-group-callers record-group)))
				    (when references
				      (format t ",~%  referenced by ")
				      (format-textual-list
					(loop for list in references append (cdr list))
					#'(lambda (rec stream)
					    (present (doc-record-record-group rec)
						     'record-group :stream stream))
					:after-line-break "    " :filled t))))))
			    (when (typep (record-group-topic record-group)
					 'phony-function-spec)
			      (pushnew (record-group-topic record-group) topic-phonies)
			      (warn "~Q"
			        (lambda ()
				  (format t "Phony function spec for ")
				  (present record-group 'record-group)
				  (format t "."))))
			    (incf n-records)
			    (pushnew (record-group-type record-group) types)
			    (when doc-record
			      (let ((file (disk-location-pathname doc-record)))
				(when file
				  (pushnew file files))))))))
	       *unique-idrecord-group-registry*)
      (dolist (unique-id bad-uids)
	(remhash unique-id *unique-idrecord-group-registry*))
      ;; I don't think this ever prints much, since if they're not topics, they're
      ;; contents and hence not loaded yet.  The sab file copier below could check I guess.
      (let ((other-phonies nil))
	(maphash #'(lambda (ignore fspec)
		     (unless (member fspec topic-phonies)
		       (pushnew fspec other-phonies)))
		 *phony-function-spec-hash-table*)
	(when other-phonies
	  (setq other-phonies (sort other-phonies #'string-lessp))
	  (warn "~Q"
            (lambda ()
	      (format t "Other phony function specs not used as topics: ")
	      (format-textual-list other-phonies #'prin1 :filled t :after-line-break "  ")))))
      (assert (and (< (length types)
		      (ash 1 (byte-size %%compressed-record-group-1-type)))
		   (< (length files)
		      (ash 1 (byte-size %%compressed-record-group-2-disk-location-file)))))
      (let ((*default-cons-area* *sage-record-area*))
	(setq *compressed-record-group-types* (coerce types 'vector)
	      *compressed-disk-location-files* (coerce files 'vector)))
      (sort *compressed-record-group-types* #'string-lessp)
      (sort *compressed-disk-location-files* #'fs:pathname-lessp))
    (assert (< n-records (1- 1_16)))
    (let ((record-groups (make-array n-records :area *sage-record-area*)))
      (let ((index 0))
	(maphash #'(lambda (unique-id record-group)
		     (ignore unique-id)
		     (setf (aref record-groups index) record-group)
		     (incf index))
		 *unique-idrecord-group-registry*)
	(assert (= index n-records)))
      (sort record-groups #'string-lessp :key #'record-group-topic-completion)
      (setq *compressed-record-groups* record-groups)
      (generate-topic-aarray))
    (let* ((ntokens (send *unsorted-keyword-token-record-groups* :filled-elements))
	   (token-indices (make-array ntokens :area *sage-completion-area*))
	   (ncharacters 1)
	   (index 0))
      (maphash #'(lambda (token record-groups)
		   (ignore record-groups)
		   (let ((length (string-length token)))
		     (assert (< length (ash 1 (byte-size %%keyword-token-length))))
		     (incf ncharacters (1+ length)))
		   (setf (aref token-indices index) token)
		   (incf index))
	       *unsorted-keyword-token-record-groups*)
      (sort token-indices #'string-lessp)
      (assert (< ncharacters (ash 1 (byte-size %%keyword-token-position))))
      (let ((token-characters (make-keyword-token-string :length ncharacters))
	    (token-record-groups (make-array ntokens :area *sage-completion-area*))
	    (char-index 0)
	    (record-positions (make-hash-table :size n-records)))
	(loop for record-group being the array-elements of *compressed-record-groups*
			       using (index index) do
	  (setf (gethash record-group record-positions) index))
	(setf (aref token-characters char-index) #\null)
	(incf char-index)
	(dotimes (index ntokens)
	  (let* ((token (aref token-indices index))
		 (length (string-length token)))
	    (setf (aref token-indices index)
		  (sys:%logdpb length %%keyword-token-length char-index))
	    (copy-array-portion token 0 length
				token-characters char-index (incf char-index length))
	    (setf (aref token-characters char-index) #\null)
	    (incf char-index)
	    (setf (aref token-record-groups index)
		  (let* ((record-groups (gethash token *unsorted-keyword-token-record-groups*))
			 (length (length record-groups)))
		    (stack-let ((record-keys (make-array length
							 :element-type '(unsigned-byte 16))))
		      (loop for index below length
			    for record-group in record-groups do
			(setf (aref record-keys index)
			      (1+ (gethash record-group record-positions))))
		      (sort record-keys #'<)
		      (flet ((encode-halves (index)
			       (let ((word 0))
				 (setf (ldb (byte 16 0) word) (aref record-keys index))
				 (when (< (1+ index) length)
				   (setf (sys:%logldb (byte 16 16) word)
					 (aref record-keys (1+ index))))
				 word)))
			(cond ((zerop length) nil)	;?
			      ((< length 2)
			       (encode-halves 0))
			      (t
			       (let ((result (make-list (ceiling length 2)
							:area *sage-completion-area*)))
				 (loop for list on result
				       for index from 0 by 2
				       do (setf (car list) (encode-halves index)))
				 result)))))))))
	(assert (= char-index ncharacters))
	(setf (fill-pointer token-characters) ncharacters)
	(nstring-downcase token-characters)
	(setq *keyword-token-characters* token-characters
	      *sorted-keyword-token-indices* token-indices
	      *sorted-keyword-token-record-groups* token-record-groups)))
    (make-compressed-unique-id-table)
    (setq *compressed-record-group-field-encoding* (prepare-to-encode-record-fields))
    n-records))

(defun make-compressed-unique-id-table ()
  (let ((hash-table (make-hash-table :test #'string=
				     :size (length *compressed-record-groups*))))
    (dotimes (index (length *compressed-record-groups*))
      (setf (gethash (record-group-unique-id (aref *compressed-record-groups* index))
		     hash-table)
	    index))
    (setq *unique-idcompressed-record-group-index-registry* hash-table)))


(defun copy-installed-sab-file (source-file compressed-file)
  (error-restart (error "Retry copying ~A to ~A." source-file compressed-file)
    (format t "~&Reading ~A ..." source-file)
    (let ((*use-record-group-index-as-unique-id* t))
      (multiple-value-bind (index-info sab-attribute-alist)
	  (read-index-info source-file)
	(let ((attribute-string
		(or (second (cl:assoc :file-attribute-string sab-attribute-alist)) "")))
	  (let ((list-of-records
		  (multiple-value-bind (vars vals)
		      (fs:file-attribute-bindings
			nil :additional-attributes (fs:parse-attribute-list attribute-string))
		    (progv vars vals
		      (read-list-of-editable-records-from-sab-file
			index-info sab-attribute-alist source-file)))))
	    (with-sab-record-sink (sink compressed-file attribute-string)
	      (tv:dolist-noting-progress (record list-of-records "Copying SAB records")
		(add-sab-record-to-sink sink record))
	      (loop for (record fields) in (sab-record-sink-index-data sink) do
		;; 1with-index-field0 destructively modifies 1fields0.
		;; (It is a poorly chosen name.)  Note that this means
		;; that it is impossible to edit compressed sab files, which
		;; is fine by us because they have no copyright information in
		;; them.
		(with-index-field (location location fields)
		  (let ((record-group (doc-record-record-group record)))
		    (setf (record-group-edited-records record-group) nil)	;For GC
		    (setf (doc-record-disk-location (record-group-published-record
						      record-group))
			  (list (list* compressed-file location))))))))))))
  (format t " wrote ~A.~%" compressed-file)
  compressed-file)

(defun write-compressed-doc-database (file &key system-name)
  (let ((loaded-ids nil))
    (labels ((map-over-files-in-system (system-name continuation)
	       (let ((system (sct:find-system-named system-name)))
		 (loop for module in (sct:system-modules system)
		       do (map-over-files-in-module system module continuation))))
	     (map-over-files-in-module (system module continuation)
	       (if (typep module 'sct:system-module)
		   (loop for (component) in (sct:module-inputs module)
			 do (map-over-files-in-system component continuation))
		 (loop with pkg = (sct:package-for-module module system)
		       for (pathname) in (sct:module-inputs module)
		       do (funcall continuation pathname pkg))))
	     (produce-id (pathname pkg)
	       ;; Only collect ids for the .SAB files
	       (when (eq (send pathname :canonical-type) :sage-binary)
		 (setq pathname (send pathname :generic-pathname))
		 (when (null pkg)
		   (setq pkg si:pkg-user-package))	;?
		 (multiple-value-bind (loaded-id pkg)
		     (sys:get-file-loaded-id pathname pkg)
		   (destructuring-bind (truename . id) loaded-id
		     (when truename
		       (push (list truename pkg id) loaded-ids)))))))
      (when system-name
	(map-over-files-in-system system-name #'produce-id)))
    (let* ((setqs (loop for var in '(*doc-system-version*
				     *compressed-record-group-types*
				     *compressed-disk-location-files*
				     *compressed-record-group-field-encoding*
				     *compressed-record-groups*
				     *keyword-token-characters*
				     *sorted-keyword-token-indices*
				     *sorted-keyword-token-record-groups*)
			collect `(setq ,var ',(symbol-value var))))
	   (set-ids (loop for (truename pkg id) in loaded-ids
			  collect `(si:set-file-loaded-id ,truename ,(package-name pkg) ,id))))
      (sys:dump-forms-to-file file
			      (append setqs set-ids)
			      '(:package :sage)))))

(defun write-compressed-uid-file (file)
  (let ((uid-table (make-array (length *compressed-record-groups*))))
    (maphash #'(lambda (uid index) (setf (aref uid-table index) uid))
	     *unique-idcompressed-record-group-index-registry*)
    (sys:dump-forms-to-file file
			    `((setq *compressed-record-group-unique-ids* ',uid-table))
			    '(:package :sage))))

(defun load-doc-database-for-writer (&key (system-name "DOC")
					  (major-version *doc-system-version*))
  ;assume already done:  (load-doc-database-for-reader)
  (let ((*compressed-record-group-unique-ids*))
    (declare (special *compressed-record-group-unique-ids*))
    (load
      (compressed-database-file "COMPRESSED-INDEX-AW.BIN.NEWEST"
				:system-name system-name :major-version major-version)
      :verbose t)
    (dotimes (i (length *compressed-record-group-unique-ids*))
      (expand-compressed-record-group (aref *compressed-record-groups* i)
				      :unique-id
				      (aref *compressed-record-group-unique-ids* i))))
  (make-compressed-unique-id-table)
  ;; Make s-c-. find in the parent directory
  (let ((key (format () "INSTALLED-~D" major-version)))
    (loop for record-group being the array-elements of *compressed-record-groups* do
      (let ((doc-record (record-group-published-record record-group)))
	(when doc-record
	  (setf (doc-record-source-file doc-record)
		(let ((pathname (disk-location-pathname doc-record :allow-patch-file nil)))
		  (when pathname
		    (let ((directory (send pathname :directory)))
		      (when (string-equal (second directory) key)
			(setq pathname (send pathname :new-directory
					     (cons (first directory)
						   (cddr directory))))))
		    pathname)))))))
  )

;;; --- exports, should be moved to pkgdcl
(export '(load-doc-database-for-writer))
