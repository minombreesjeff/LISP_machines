;;;-*- Syntax: Common-lisp; Mode: Lisp; Package: Nsage; Lowercase: T; Base: 10 -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>


(defvar D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")*debugging-page-previewer*0 nil)		;(setq *debugging-page-previewer* t)
(defvar 1*do-toc-when-formatting-pages* 0t)
(defvar 1*do-index-when-formatting-pages* 0t)
(export '(*do-toc-when-formatting-pages* *do-index-when-formatting-pages*))

(defmacro 1time-taken0 (what &body body)
  `(time-taken-1 ,what
		 (zl:named-lambda time-taken ()
		   (declare (sys:downward-function))
		   ,@body)))

(defun 1time-taken-10 (what continuation)
  (declare (sys:downward-funarg continuation))
  (cond ((null *debugging-page-previewer*)
	 (funcall continuation))
	(t
	 (let ((.start. (sys:%microsecond-clock)))
	   (multiple-value-prog1
	     (funcall continuation)
	     (process-run-function "show time taken"
	       'show-time-taken
	       what
	       (time-difference (sys:%microsecond-clock) .start.)))))))

(defun 1show-time-taken0 (what microseconds)
  (tv:noting-progress ((format nil "~a took ~$" what (/ microseconds 1e6)))
    (sleep 4)))

(dw:define-program-framework 1page-previewer
0  :command-definer T
  :selectable NIL ;;---By product definition, this is a Concordia frame configuration,
		  ;; not a standalone activity, although technically it could be.
  :command-table (:inherit-from
		   '("colon full command" "standard arguments" "standard scrolling")
		   :kbd-accelerator-p 'nil)
		    
  :top-level (page-previewer-top-level)

  :state-variables ((formatted-pages-hash-table (make-hash-table))
		    (current-record-group)
		    (current-pages)
		    (current-page)
		    (current-page-number)
		    (page-formatting-configuration 'two-page)	;two-page, single
		    )
  :panes ((display :display
		   :automatically-remove-typeout-window T
		   :typeout-window T
		   :margin-components '((dw:margin-borders)))
	  (interactor :interactor :height-in-lines 4
		      :default-character-style *screen-default-character-style*
		      :end-of-page-mode :scroll))
  :configurations
  '((page-preview
      (:layout
	(page-preview :column display interactor))
      (:sizes
	(page-preview (interactor 4 :lines)
		      :then (display :even))))))

(defmethod 1(page-previewer-top-level page-previewer)0 (&rest args)
  (loop doing
    (catch 'abort-page-previewer-command
      (apply #'dw:default-command-top-level self args))))

(defun 1abort-page-previewer-command0 ()
  (throw 'abort-page-previewer-command nil))

(defun 1page-previewer-barf0 (format-string &rest format-args)
  (beep)
  (apply #'format (dw:get-program-pane 'interactor) format-string format-args)
  (abort-page-previewer-command))

(zl:defstruct (1formatted-pages0 :conc-name
			       :named-array-leader
			       (:constructor
				 make-formatted-pages-internal))
  final-ambient-values
  final-heading-state
  improperly-referenced-tags)

(defun 1make-formatted-pages0 (pages &key final-ambient-values final-heading-state)
  (let ((fp (make-formatted-pages-internal
	      :make-array (:length (length pages))
	      final-ambient-values final-ambient-values
	      final-heading-state final-heading-state)))
    (replace fp pages)
    fp))

(defun fix-up-old-formatted-pages (hash-table)
  (flet ((fix-fp (key fp)
	   (ignore key)
	   (let ((new-fp (make-formatted-pages
			   fp
			   :final-ambient-values (formatted-pages-final-ambient-values fp)
			   :final-heading-state (formatted-pages-final-heading-state fp))))
	     (setf (formatted-pages-improperly-referenced-tags new-fp)
		   '("These pages were formatted before that information was permanently maintained."))
	     (structure-forward fp new-fp))))
    (maphash #'fix-fp hash-table)))


(define-presentation-type 1formatted-record-group0 ((&key hash-table))
   :history t
   :parser ((stream &key type initially-display-possibilities)
	    (dw:completing-from-suggestions (stream :type type
						    :partial-completers '(#\Space)
						    :initially-display-possibilities
						     initially-display-possibilities)
	      (maphash (lambda (record-group pages)
			 (ignore pages)
			 (dw:suggest (present-to-string record-group 'record-group)
				     record-group))
		       hash-table)))
   :printer ((rg stream)
	     (present rg 'record-group :stream stream)))

(defun-in-flavor 1(set-current-record-group-and-pages page-previewer)0 (rg pages)
  (setf (gethash rg formatted-pages-hash-table) pages)
  (setq current-record-group rg
	current-pages pages))

(defmethod 1(set-page-number page-previewer)0 (page-number &optional direction)
  (when (and (eq page-formatting-configuration 'two-page)
	     (not (zerop page-number))
	     (evenp page-number))
    (decf page-number))
  (let ((interactor (dw:get-program-pane 'interactor))
	(number-of-pages (length current-pages))
	(x-offset 25)				;how far from left margin
	(x-separation 15)			;how much dist between facing pages
	(y-offset 5))				;how far down from top
    (when (and current-page-number (= current-page-number page-number))
      (when (and direction (neq direction ':force))
	(beep)
	(case direction
	  (:next (format interactor "You are already at the end."))
	  (:previous (format interactor "You are already at the beginning."))))
      (when (neq direction ':force)
	(return-from set-page-number nil)))
    (if (array-in-bounds-p current-pages page-number)
	(setq current-page-number page-number
	      current-page (aref current-pages current-page-number))
	(format interactor "~&There are only ~d pages" number-of-pages))
    (let ((pane (dw:get-program-pane 'display)))
      (flet ((show-page-number (number wid hei &optional (offset 0))
	       (setq wid (floor (abs wid) 2)
		     hei (floor (abs hei)))
	       (let* ((drawer (zl:named-lambda show-page-num (stream)
				(format stream "Page ~D/~D" (1+ number) number-of-pages)))
		      (width (dw:continuation-output-size drawer pane)))
		 (setq wid (- wid (floor width 2)))
		 (incf wid offset)
		 (send pane :set-cursorpos wid (+ hei 2))
		 ;; this should really be something interesting, but for now
		 ;; let's just make it a number.
		 (dw:with-output-as-presentation (:type 'integer
						  :object number
						  :stream pane)
		   (funcall drawer pane)))))
	(send pane :clear-history)		;---too strong?
	(dw:remove-window-typeout-window pane :prompt-p nil)
	(cond ((and (eq page-formatting-configuration 'two-page)
		    (zerop page-number))
	       ;; this is a special case where you want the display
	       ;; to have a single page on the right hand side...
	       (multiple-value-bind (wid hei)
		   (display-formatted-page self current-page pane x-offset y-offset
					   :for-size-only t)
		 (send pane :set-cursorpos 0 0)
		 (display-formatted-page self current-page pane
					 (+ x-offset x-separation (floor wid))
					 y-offset
					 :draw-handles
					 (when (box-next current-page) :right))
		 (show-page-number page-number wid hei (+ (floor wid) x-offset x-separation))))
	      (t
	       (multiple-value-bind (wid hei)
		   (display-formatted-page self current-page pane x-offset y-offset
					   :draw-handles
					   (if (eq page-formatting-configuration 'two-page)
					       (if (zerop current-page-number) nil :left)
					       :both))
		 (ignore hei)
		 (show-page-number page-number wid hei)
		 (when (and (eq page-formatting-configuration 'two-page)
			    (box-next current-page))
		   (send pane :set-cursorpos 0 0)
		   (display-formatted-page
		     self (box-next current-page) pane
		     (+ x-offset (floor wid) x-separation) y-offset
		     :draw-handles :right)
		   (show-page-number (1+ page-number) wid hei
				     (+ (floor wid) x-offset x-separation))
		   ))))))))

(defmethod 1(display-formatted-page page-previewer)0 (page-box stream x-offset y-offset
							     &key (draw-handles :both)
							     (for-size-only nil))
  (let ((*record-contents-are-sensitive* t)
	(*displayer-x-offset* x-offset)
	(tiny-character-style (si:character-style-for-device-font
				'fonts:tinier si:*b&w-screen*)))
    (condition-bind ((si:no-character-style-mapping
		       (lambda (condition)
			 (dbg:proceed condition :use-undefined-style))))
      (graphics:with-graphics-translation (stream x-offset y-offset)
	(with-character-style (tiny-character-style stream :bind-line-height t)
	  (let ((*default-character-style-for-pictures* tiny-character-style))
	    (time-taken "preview-page"
	      (multiple-value-bind (wid hei)
		  (preview-page page-box stream (- (send stream :inside-height)
						   (send stream :line-height)
						   13)
				:draw-handles draw-handles
				:for-size-only for-size-only)
		(setq wid (abs wid) hei (abs hei))
		(values wid (+ y-offset hei))))))))))

(define-presentation-to-command-translator page-previewer-edit-record-group
   (record-group
     :gesture :edit-1function0)
   (record-group)
  `(com-edit-record ,record-group))

(define-presentation-to-command-translator page-previewer-edit-record-group-for-record
   (doc-record
     :gesture :edit-1function0)
   (record)
  (let ((rg (doc-record-record-group record)))
    `(com-edit-record ,rg)))

(define-presentation-to-command-translator page-previewer-edit-record-group-for-index-database-entry
   (index-database-entry
     :gesture :edit-1function0)
   (entry)
  (let ((record (index-database-entry-record entry)))
    (unless (null record)
      (let ((rg (doc-record-record-group record)))
	`(com-edit-record ,rg)))))


(define-page-previewer-command 1(com-edit-record)
0    ((topic 'record-group))
   (send *terminal-io* :force-kbd-input
	 `(:execute (lambda () (edit-record ,topic))))
   (program-force-concordia-change-configuration
     '(com-change-configuration zmacs-editor)
     *terminal-io*))

#||
(define-page-previewer-command 1(com-show-page-containing)
0    ((topic 'record-group :prompt "topic" :confirm t))
   (let ((*ambient-counters*
	   (formatted-pages-final-ambient-values
	     (gethash current-record-group formatted-pages-hash-table))))
     (let* ((index-database (lookup-ambient-value 'index-database))
	    (index-entry (find-index-entry-for-record-group index-database topic)))
       (unless index-entry
	 (error "Can't find ~A in the index" topic))
       (let* ((page-counter (sys:eval-in-instance index-entry 'page-counter))
	      (page (send page-counter :value)))
	 (set-page-number self (1- page))))))
||#

(define-presentation-to-command-translator 1set-page-from-index-entry
0   (index-database-entry)
   (entry)
  (let ((page-counter (sys:eval-in-instance entry 'page-counter)))
    (unless (null page-counter)
      (let ((page (filtered-string-from-contents-list
		    (counter-value-contents-list page-counter :reference))))
	`(com-set-page ,page)))))

(define-presentation-to-command-translator 1set-page-from-page-number
0   (page-number)
   (fpn)
  `(com-set-page ,fpn))

(define-page-previewer-command 1(com-format-pages )
0				((topic 'record-group :prompt "topic" :confirm t)
				 &key
				 (printer 'sys:printer
					  :default nil
					  :mentioned-default hardcopy:*default-text-printer*
					  :prompt "on printer"
					  :documentation "Hardcopy output destination")
				 (index 'boolean :default  *do-index-when-formatting-pages*
					:mentioned-default t
					:documentation "Generate an Index")
				 (toc 'boolean :default *do-toc-when-formatting-pages*
				      :mentioned-default t
				      :documentation "Generate a Table of Contents")
				 (query '((member all none unassigned)) :default 'none
					:documentation "Query for case commands")
				 )
   (incf *formatter-timestamp*)
   (setq *unassigned-case-selectors* nil)	;reset unassigned Case selector list
   (clear-format-pages-case-bindings)		;clear case selector bindings from prev runs
   ;;---(page-previewer-change-to-page-preview-configuration)
   (let* ((old-terminal-io *terminal-io*)
	  (something-written-to-terminal-io nil)
	  (*query-case-variables* (unless (eql query 'none) query))
	  (*terminal-io*
	    (named-lambda fake-terminal-io (&rest stuff)
	      (setq *terminal-io* old-terminal-io)
	      (setq something-written-to-terminal-io t)
	      (when *debugging-page-previewer*
		(unless (eq (let* ((frame (sys:%stack-frame-pointer))
				   (previous-frame (sys:frame-previous-frame frame)))
			      (sys:function-name (sys:frame-function previous-frame)))
			    ;; Don't want to use the debugger to herald
			    ;; the advent of the debugger.
			    'dbg:debugger-top-level)
		  (break "Who used ~s for ~s" *terminal-io* stuff))))))
     (multiple-value-bind (formatted-pages final-heading-state final-ambient-values)
	 (format-pages topic
		       (let ((previous-formatted-pages
			       (gethash topic formatted-pages-hash-table)))
			 (and (typep previous-formatted-pages 'formatted-pages)
			      (formatted-pages-final-ambient-values
				previous-formatted-pages)))
		       :do-index index
		       :do-toc toc)
       (annotate-pages-leftover-presentations formatted-pages)
       (set-current-record-group-and-pages
	 topic
	 (make-formatted-pages formatted-pages
			       :final-ambient-values final-ambient-values
			       :final-heading-state final-heading-state)))
     (when something-written-to-terminal-io
       (let ((display-pane (dw:get-program-pane 'display)))
	 (send display-pane :clear-history)
	 (dw:remove-window-typeout-window display-pane)))
     (set-page-number self 0 :force)
     (format (dw:get-program-pane 'interactor) "~&~d page~:p" (length current-pages)))
   (check-for-bogus-tag-values current-pages
			       (formatted-pages-final-ambient-values current-pages))
   (check-for-unassigned-case-selectors)
   (clear-format-pages-case-bindings)		;clear case selector bindings from prev runs
   (when printer
     (hardcopy-pages current-pages 0 (length current-pages) printer
		     :title (format nil "~A (~D page~:p)"
				    (present-to-string topic 'record-group)
				    (length current-pages))))
  ;;---(throw 'change-of-configuration 'page-preview)
  )

;; This is probably just for debugging purposes, unless it
;; starts to take advantage of the index/keyword tools.
(define-page-previewer-command 1(com-reformat-end-pages )
0				((topic 'record-group :prompt "topic")
				 )
  (let* ((old-terminal-io *terminal-io*)
	 (something-written-to-terminal-io nil)
	 (*terminal-io*
	   (named-lambda fake-terminal-io (&rest stuff)
	     (setq *terminal-io* old-terminal-io)
	     (setq something-written-to-terminal-io t)
	     (when *debugging-page-previewer*
	       (unless (eq (let* ((frame (sys:%stack-frame-pointer))
				  (previous-frame (sys:frame-previous-frame frame)))
			     (sys:function-name (sys:frame-function previous-frame)))
			   ;; Don't want to use the debugger to herald
			   ;; the advent of the debugger.
			   'dbg:debugger-top-level)
		 (break "Who used ~s for ~s" *terminal-io* stuff))))))
    (multiple-value-bind (formatted-pages final-heading-state final-ambient-values)
	(format-end-pages topic (let ((previous-formatted-pages
					(gethash topic formatted-pages-hash-table)))
				  (and (typep previous-formatted-pages 'formatted-pages)
				       (formatted-pages-final-ambient-values
					 previous-formatted-pages))))
      (annotate-pages-leftover-presentations formatted-pages)
      (set-current-record-group-and-pages
	(format nil "End Pages for ~a" (appropriate-title-rendering topic 'no-formatting))
	(make-formatted-pages formatted-pages
			      :final-ambient-values final-ambient-values
			      :final-heading-state final-heading-state)))
    (when something-written-to-terminal-io
      (dw:remove-window-typeout-window (dw:get-program-pane 'display)))
    (set-page-number self 0 :force)
    (format (dw:get-program-pane 'interactor) "~&~d page~:p" (length current-pages)))
  ;;---(throw 'change-of-configuration 'page-preview)
  )

(defun 1annotate-pages-leftover-presentations0 (pages)
  (tv:noting-progress ("Collecting page presentations")
    (using-resource (stream leftover-presentations-collector)
      (loop for (page next-page) on pages
	    for count from 1
	    with length = (length pages)
	    as leftover-presentations = (annotate-leftover-presentations page stream)
	    when (and *debugging-sage* (null next-page))
	      do
		(print leftover-presentations)
	    when next-page
	      do
		(tv:note-progress count length)
		(setf (page-box-presentation-stack-leftover-presentations next-page)
		      leftover-presentations)))))

(defflavor 1leftover-presentations-collector
0	((presentations (make-array 10 :fill-pointer 0)))
	()
  :writable-instance-variables)

(defmethod 1(initialize leftover-presentations-collector)0 ()
  (setf (fill-pointer presentations) 0))

(defmethod 1(push-presentation leftover-presentations-collector)0 (&rest stuff)
  (vector-push-extend (copy-list stuff) presentations))

(defmethod 1(pop-presentation leftover-presentations-collector)0 ()
  (vector-pop presentations))

(defmethod 1(top-presentation leftover-presentations-collector)0 ()
  (elt presentations (1- (fill-pointer presentations))))

(defmethod 1(leftover-presentations leftover-presentations-collector)0 ()
  (coerce presentations 'list))

(defresource 1leftover-presentations-collector0 ()
  :constructor (make-instance 'leftover-presentations-collector)
  :initializer (initialize object))

(defgeneric 1annotate-leftover-presentations0 (thing stream))

(defmethod 1(annotate-leftover-presentations page-box)0 (stream)
  (loop for column in list-of-columns
	do
    (do-lines-in-column (line column)
      (annotate-leftover-presentations line stream)))
  (leftover-presentations stream))

(defmethod 1(annotate-leftover-presentations line-hbox)0 (stream)
  (do-line-gboxes (gbox first-gbox newline-gbox)
    (annotate-leftover-presentations gbox stream)))

(defmethod 1(annotate-leftover-presentations basic-gbox)0 (stream)
  (ignore stream))

(defmethod 1(annotate-leftover-presentations presentation-entry-gbox)0 (stream)
  (apply #'push-presentation
	 stream
	 :object presentation-object
	 :type presentation-type
	 presentation-options))

(defmethod 1(annotate-leftover-presentations presentation-exit-gbox)0 (stream)
  (pop-presentation stream))

(defmethod 1(annotate-leftover-presentations record-entry-gbox)0 (stream)
  (push-presentation stream
		     :object record
		     :type (type-of record)
		     :single-box t))

(defmethod 1(annotate-leftover-presentations record-exit-gbox)0 (stream)
  (let ((presentation-info (top-presentation stream)))
    (destructuring-bind (&key object type &allow-other-keys) presentation-info
      (let ((record (send entry-gbox :record)))
	(when (and (eq type (type-of record))	;maximally conservative
		   (eq object record))
	  ;; --- Only pop when we pushed in the entry-case.
	  ;; This is here to mask a bug in expanding a reference in the
	  ;; view=contents case.
	  (pop-presentation stream))))))

#||
(defun test ()
  (let ((pages (coerce (page-previewer-current-pages dw:*program*) 'list)))
    (loop for page in pages
	  do
      (test-page page))))

(defmethod (test-page page-box) ()
  (loop for column in list-of-columns
	do
    (do-lines-in-column (line column)
      (terpri)
      (let* ((newline-gbox (send line :newline-gbox))
	     (newline (loop for box = newline-gbox then (box-prev box)
			    when (typep box 'newline-gbox)
			      return box)))
	(loop for box = newline then (box-next box)
	      do
	  (format t "~A" box)
	  (when (eq box newline-gbox) (loop-finish))))))
  (format t "~%End of page"))

(defun verify-pages-foo (pages)
  (loop for page in pages
	do
    (verify-page-foo page)))

(defmethod (verify-page-foo page-box) ()
  (loop for column in list-of-columns
	do
    (do-lines-in-column (line column)
      (let ((newline-gbox (send line :newline-gbox))
	    (next-line (box-next line)))
	(unless (or (null next-line)
		    (eq (box-next newline-gbox)
			(send next-line :first-gbox)))
	  (break "Next line's first-gbox is not box-next of this line's newline-gbox"))))))
||#

#+Franz ;;debugging only
(define-page-previewer-command 1(com-format-experimental-record )
0    ()
   (let* ((old-terminal-io *terminal-io*)
	  (*terminal-io*
	    (named-lambda fake-terminal-io (&rest stuff)
	      (setq *terminal-io* old-terminal-io)
	      (if (ignore-errors
		    (let* ((caller-frame (sys:frame-previous-frame
					   (sys:%stack-frame-pointer)))
			   (caller-frame-function-name
			     (sys:function-name (sys:frame-function caller-frame))))
		      (eql caller-frame-function-name 'dbg:debugger-top-level)))
		  ()				;---print some additional warning?
		  (break "Who used ~s for ~s" *terminal-io* stuff)))))
     (set-current-record-group-and-pages
       *experimental-record*
       (coerce (format-pages *experimental-record*) 'vector))
     (set-page-number self 0)
     (format (dw:get-program-pane 'interactor) "~&~d pages" (length current-pages))))

(defmethod 1(next-page-number page-previewer)0 ()
  (min (1- (length current-pages))
       (+ current-page-number (if (eq page-formatting-configuration 'two-page) 2 1))))

(defmethod 1(previous-page-number page-previewer)0 ()
  (max 0 (- current-page-number (if (eq page-formatting-configuration 'two-page) 2 1))))

(define-page-previewer-command 1(com-next-page )0 ()
   (when current-pages
     (set-page-number self (next-page-number self) :next)))

(define-page-previewer-command 1(com-previous-page )0 ()
   (when current-pages
     (set-page-number self (previous-page-number self) :previous)))

(define-page-previewer-command 1(com-set-page)
0    ((page-number `((page-number :pages ,current-pages)
		    :description "a page number")
		  :default nil
		  :confirm t))
   (set-formatted-page self page-number))

(defmethod 1(find-formatted-page-index page-previewer)0 (page-number starting-page-index)
  (macrolet ((map-over-pages ((from to) (page idx) &body body)
	       `(map-over-pages-1 ,from ,to
				  (dw:named-continuation map-over-pages (,page ,idx)
				    ,@body))))

    (flet ((map-over-pages-1 (from to continuation)
	     (loop for idx from from to to
		   do
	       (funcall continuation (aref current-pages idx) idx)))
	   (find-and-return-page-idx (page idx)
	     (let ((page-page-number (page-box-page-number page)))
	       (when (string-equal page-number (car page-page-number))
		 (return-from find-formatted-page-index idx)))))

      (let ((npages (1- (length current-pages))))
	(unless (= starting-page-index npages)
	  (map-over-pages (starting-page-index npages)
			  (page idx)
			  (find-and-return-page-idx page idx)))
	(map-over-pages (0 starting-page-index)
			(page idx)
			(find-and-return-page-idx page idx))))))

(defmethod 1(set-formatted-page page-previewer)0 (page-number)
  (let ((idx (find-formatted-page-index self page-number (next-page-number self))))
    (set-page-number self idx)))

(define-page-previewer-command 1(com-set-widow-action)
0    ((action '((alist-member :alist (("Force" :value force
				    :documentation
				    "Put widows and orphans with the rest of the paragraph.")
				   ("ForceWarn" :value forcewarn
				    :documentation "Like Force, but warns you.")
				   ("Ignore" :value ignore
				    :documentation "Don't handle widows or orphans specially.")
				   ("Warn" :value warn
				    :documentation "Like Ignore, but warns you."))))
	   :default *widow-action*
	   :prompt "new action"))
    (setq *widow-action* action))

(define-page-previewer-command 1(com-change-layout)
0    ((layout '((member single-page two-page))
	     :default (if (eq page-formatting-configuration 'two-page)
			  'single-page 'two-page)))
   (unless (eq layout page-formatting-configuration)
     (setq page-formatting-configuration layout)
     (when current-page-number
       (set-page-number self current-page-number :force))))

(define-presentation-to-command-translator 1next-or-previous-page
0   (page-box-border
     :gesture :select
     :documentation
       ((object)
	(ecase (second object)
	  (:left "Previous page")
	  (:right "Next page"))))
   (object)
  (ecase (second object)
    (:left
      (list 'com-previous-page))
    (:right
      (list 'com-next-page))))

;; ---Debugging only
(define-page-previewer-command 1(com-describe-page )
0    ((page-number `((integer 1 ,(length current-pages)) :description "page number")
		  :default current-page-number))
   (let ((page (aref current-pages (1- page-number))))
     (describe page)
     ;; (describe-environment (page-box-page-environment page))
     ))

(define-page-previewer-command 1(com-show-formatted-pages)
0    ((record-group `((formatted-record-group :hash-table ,formatted-pages-hash-table))
		   :default current-record-group)
     &key
     (printer 'sys:printer
	      :default nil
	      :mentioned-default hardcopy:*default-text-printer*
	      :prompt "on printer"))
   (setq current-record-group record-group
	 current-pages (gethash record-group formatted-pages-hash-table))
   (set-page-number self 0 :force)
   (when printer
     (hardcopy-pages current-pages 0 (length current-pages) printer
		     :title (format nil "~A (~D page~:p)"
				    (present-to-string current-record-group 'record-group)
				    (length current-pages)))))

(define-page-previewer-command 1(com-hardcopy-pages )
0    ((record-group `((formatted-record-group :hash-table ,formatted-pages-hash-table))
		   :default current-record-group)
     (from `((page-number :pages ,(gethash record-group formatted-pages-hash-table)))
	   :prompt "from"
	   :default (let ((pages (gethash record-group formatted-pages-hash-table)))
		      (unless (zerop (length pages))
			(car (page-box-page-number (elt pages 0))))))
     (to `((token-or-type (:all)
			  ((page-number
			     :pages ,(gethash record-group formatted-pages-hash-table)))))
	 :prompt "to"
	 :default ':all)
     (printer 'sys:printer :default hardcopy:*default-text-printer* :prompt "on printer")
     &key
     (to-file `((pathname) :default-type ,(let ((type (send printer :get :type)))
					    (if (eq type :lgp3) :lgp2 type))))
     (background 'boolean :default T)
     )
   (when to-file
     (let* ((printer-type (send printer :get :type))
	    ;; ---there's a better way - see hci:define-hardcopy-format and -device
	    ;; (canonical-type printer-type)
	    )
       (when (eq printer-type :lgp3)
	 (setf printer-type :lgp2))
       (setq printer (hardcopy:get-hardcopy-device
		       `(:file ,to-file ,printer-type)))))
   (let* ((pages-to-hardcopy (gethash record-group formatted-pages-hash-table))
	  (starting-page (find-formatted-page-index self from 0))
	  (ending-page (unless (eq to ':all)
			 (find-formatted-page-index self to starting-page))))
     (unless (or (eq to ':all) ( ending-page starting-page))
       (rotatef ending-page starting-page)
       (rotatef to from))
     (unless ending-page
       (setq ending-page (1- (length pages-to-hardcopy))))
     (let* ((rg-name (present-to-string record-group 'record-group))
	    (process-name (format nil "ConcH pp.~d:~(~d~): ~a" from (if (eq to ':all) "end" to)
				  rg-name)))
       (labels ((construct-title ()
		  (format nil "~A (page~P ~A~:[ - ~A~:[~; [~D page~:p]~]~;~])"
			  rg-name (- ending-page starting-page -1)
			  from (= ending-page starting-page)
			  (if (eq to ':all) "end" to)
			  (> (- ending-page starting-page) 4)
			  (- ending-page starting-page -1)))
		(do-pages ()
		  (hardcopy-pages
		    pages-to-hardcopy starting-page (1+ (- ending-page starting-page))
		    printer :title (construct-title))))
	 (cond (background
		(process-run-function `(:name ,process-name) #'do-pages)
		(format (dw:get-program-pane 'interactor)
			"Using background process ~a" process-name))
	       (T (do-pages)))))))

(defvar 1*counter-dump-table*0)

(define-page-previewer-command 1(com-save-tags )
0    ((record-group `((formatted-record-group :hash-table ,formatted-pages-hash-table))
		   :default current-record-group)
     (file `((pathname) :default-type "CTAGS")))
   (let* ((formatted-pages (gethash record-group formatted-pages-hash-table))
	  (final-ambient-values (formatted-pages-final-ambient-values formatted-pages))
	  (tag-values (ambient-counters-lookup-ambient-value final-ambient-values 'tag-values))
	  (citation-values (ambient-counters-lookup-ambient-value final-ambient-values 'citation-values)))
     (let ((counter-dump-table (make-hash-table)))
       (collect-counters-in-tag-values tag-values counter-dump-table)
       ;;--- what about citation-values?
       (let ((*counter-dump-table* counter-dump-table))
	 (sys:dump-forms-to-file
	   file
	   `((set-counter-dump-vector ,(hash-table-count *counter-dump-table*))
	     ;; The progn makes debugging easier
	     (progn ,@(make-counter-dump-vector-forms))
	     (restore-tag-values
	       :record-group ',`(,(record-group-topic record-group)
				 ,(record-group-type record-group)
				 ,(record-group-unique-id record-group))
	       :tag-values ',tag-values
	       :citation-values ',citation-values))
	   '(:package :sage))))))

;; dump time
(defun 1collect-counters-in-tag-values0 (tag-values table)
  (loop for (name pair) on tag-values by #'cddr
	do
    (assert (symbolp name))
    (labels ((do-counter (counter)
	       (when counter
		 (unless (gethash counter table)	;this should stop infinite recursion
		   (let ((n (hash-table-count table)))
		     (setf (gethash counter table) n))
		   (let ((children (counter-child-counters counter)))
		     (when (listp children)
		       (mapc #'do-counter children)))
		   (do-counter (send counter :aliased-counter))
		   (do-counter (send counter :parent-counter))))))
      (tag-data-funcall-on-value-and-page pair #'do-counter))))

;; dump time
(defun 1make-counter-dump-vector-form0s ()
  (let ((list ()))
    (maphash (lambda (counter index)
	       (ignore index)
	       (push (reconstitution-form counter) list))
	     *counter-dump-table*)
    list))

;; load time
(defun 1set-counter-dump-vector0 (n)
  (unless (and (variable-boundp *counter-dump-table*)
	       (null *counter-dump-table*))
    (error "The file was improperly dumped"))
  (let ((vector (make-array n)))
    (dotimes (j (length vector)) (setf (aref vector j) (get-new-counter)))
    (setq *counter-dump-table* vector)))

;; load time
(defun 1dumped-counter0 (j)
  (unless (and (variable-boundp *counter-dump-table*)
	       (vectorp *counter-dump-table*))
    (error "The file was incorrectly dumped"))
  (aref *counter-dump-table* j))

;; dump time
(defun 1dumped-counter-index0 (counter)
  (or (gethash counter *counter-dump-table*)
      (error "Counter ~s not in dump table (internal error)" counter)))

;; load time
(defun 1list-of-dumped-counters0 (&rest list)
  (mapcar #'dumped-counter list))

;; dump time
(defmethod 1(:fasd-form counter)0 ()
  `(dumped-counter ,(dumped-counter-index self)))

;; dump time
(defmethod 1(reconstitution-form counter)0 ()
  (assert (eql (type-of self) 'counter))
  (let* ((fl (sys:%instance-flavor self))
	 (vars (flavor:flavor-all-instance-variables fl)))
    (sys:with-stack-array (inits (* 2 (length vars)) :fill-pointer 0)
      (dolist (var (flavor:flavor-all-instance-variables fl))
	;; All vars are initialized, don't have to worry about unbound.
	(let ((val (symbol-value-in-instance self var)))
	  (vector-push var inits)
	  (vector-push
	    (if (eql var 'child-counters)
		(if (listp val)
		    ;; special case to break circularity
		    ;; Um, this form appears under a quote anyway.  See "paper over bug" below.
		    ;; Perhaps a better way to fix this would be to define 
		    ;; reconstitute-counter-1 which would take a &rest arg to receive the 
		    ;; inits, except then that all the other args would need to be
		    ;; quoted individually.
		    `(list-of-dumped-counters ,@(mapcar #'dumped-counter-index val))
		    val)
		val)
	    inits)))
      `(reconstitute-counter ',(type-of self)
			     ',(dumped-counter-index self)
			     ',(coerce inits 'list)))))

;; load time
(defun 1reconstitute-counter0 (flavor-name index inits)
  (assert (eql flavor-name 'counter))
  (let ((counter (dumped-counter index)))
    (loop for (var val) on inits by #'cddr
	  do (setf (symbol-value-in-instance counter var)
		   ;; Paper over bug
		   (if (and (consp val) (eq (first val) 'list-of-dumped-counters))
		       (apply #'list-of-dumped-counters (rest val))
		       val)))
    counter))

(defvar 1*restore-tag-values*0 ())

;; This gets called in the null lexical context when
;; loading a CTAGS file.  The continuation hair here is
;; to get things into the context of a page-previewer
;; command.
(defun 1restore-tag-values0 (&rest args)
  (if *restore-tag-values*
      (apply *restore-tag-values* args)
      (error "Attempting to restore tag values from wrong context~%~@
		Use the ~\\cp:command\\ Concordia command to load them."
	     'com-restore-tags)))

(defmacro 1restoring-tag-values0 (arglist load-form &body body)
  `(restoring-tag-values-1
     (named-lambda restoring-tag-values-load-form () ,load-form)
     (named-lambda restoring-tag-values-body ,arglist ,@body)))

(defun 1restoring-tag-values-10 (load-continuation body-continuation)
  (declare (sys:downward-funarg load-continuation body-continuation))
  (let ((*restore-tag-values* body-continuation))
    (funcall load-continuation)))

(define-page-previewer-command 1(com-restore-tags )
0    ((file `((pathname) :default-type "CTAGS")))
   (restoring-tag-values (&key record-group tag-values citation-values)
			 (let ((*counter-dump-table* nil))
			   (si:bin-load-file file "SAGE" T))
     (let ((real-record-group (apply #'find-record-group-for-topic-and-type record-group)))
       (let ((formatted-pages (gethash real-record-group formatted-pages-hash-table)))
	 (when (null formatted-pages)
	   (let ((ambient-values (make-instance 'ambient-counters)))
	     (setq formatted-pages (make-formatted-pages
				     () :final-ambient-values ambient-values))
	     (setf (gethash real-record-group formatted-pages-hash-table) formatted-pages)))
	 (let ((*ambient-counters* (formatted-pages-final-ambient-values formatted-pages)))
	   (when tag-values
	     (setq tag-values (maybe-convert-old-format-tag-values tag-values))
	     (set-ambient-value 'tag-values tag-values 'tag-values))
	   (when citation-values
	     (set-ambient-value 'citation-values citation-values 'citation-values)))))))

(cp:install-commands 'page-previewer '(com-set-sage-variable
					com-clear-sage-variable
					com-list-sage-variables))


(define-page-previewer-command 1(com-show-tags )
0    ((thing `((cp::cased-subtype
		("File" ((pathname) :default-type "CTAGS")
		 :prompt "file")
		("Topic" ((formatted-record-group :hash-table ,formatted-pages-hash-table))
		 :default ,current-record-group))
	      :keyword-description "Topic or File")
	    :prompt "Topic or File"))
   (flet ((show-tags (tags)
	    ;; ---I suppose we could sort these by type, too.
	    (cond ((null tags)
		   (format T "~&There are no tag values."))
		  (T
		   (format T "~&~16d ~5d ~a~%" "value  " "page" "Tag")
		   (flet ((val (counter)
			    (etypecase counter
			      (null "--")
			      (counter (send counter :value)))))
		     (loop for (tag (counter page)) on tags by #'cddr
			   do
		       (format T "~16<~(~a~) ~d~> ~5d ~a~%"
			       (if counter (send counter :name) "")
			       (val counter)
			       (val page)
			       tag))))))
	  (show-citations (citations)
	    (cond ((null citations)
		   (format T "~&There are no citation values."))
		  (T
		   (format T "~&Here's a poor job showing citation values:~%~s"
			   citations)))))
     (etypecase thing
       (pathname
	 (let ((pathname thing))
	   (restoring-tag-values (&key record-group tag-values citation-values)
				 (let ((*counter-dump-table* nil))
				   (si:bin-load-file pathname "SAGE" T))
	     (let ((real-record-group (apply #'find-record-group-for-topic-and-type
					     record-group)))
	       (format T "~&Saved tag values in ~a are for topic ~\\presentation\\."
		       pathname real-record-group)
	       (show-tags tag-values)
	       (show-citations citation-values)))))
       (record-group
	 (let ((record-group thing))
	   (format T "~&Tag values for topic ~\\presentation\\"
		   record-group)
	 (let* ((formatted-pages (gethash record-group formatted-pages-hash-table))
		(final-ambient-values (formatted-pages-final-ambient-values formatted-pages))
		(tag-values (ambient-counters-lookup-ambient-value final-ambient-values
								   'tag-values))
		(citation-values (ambient-counters-lookup-ambient-value final-ambient-values
									'citation-values)))
	   (show-tags tag-values)
	   (show-citations citation-values)))))))
   
(defun 1check-for-bogus-tag-values0 (pages &optional ambient-counters )
  (let ((tag-values (or
		      (ambient-counters-lookup-ambient-value ambient-counters 'tag-values)
		      (lookup-ambient-value 'tag-values :error-p nil))))
    (when tag-values
      (tv:noting-progress ("Checking tags")
	(let ((denominator (length tag-values))
	      (stuff ()))
	  (loop for (tag-name tag-data) on tag-values by #'cddr
		for numerator from 0 by 2
		do
	    (tv:note-progress numerator denominator)
	    (when (eq (tag-data-referenced tag-data) ':error)
	      (push tag-name stuff)))
	  (when stuff
	    (setf (formatted-pages-improperly-referenced-tags pages) stuff)
	    (display-bogus-tags stuff)))))))

(define-presentation-type 1bogus-tags0 ()
   :expander t
   :printer ((thing stream) (ignore thing stream)))

(defun 1display-bogus-tags0 (bogus-tags &optional (threshold 5))
  ;; tags needs to be reversed
  (let ((length (length bogus-tags)))
    (cond ((< length threshold)
	   (format t "~&There ~:[were~;was~] ~D improperly referenced tag~:P:  "
		   (= length 1) length)
	   (format-textual-list (reverse bogus-tags) #'princ :filled t :conjunction "and"))
	  (t 
	   (dw:with-output-as-presentation (:stream *standard-output*
					    :type 'bogus-tags
					    :object bogus-tags)
	     (format t "~&There were ~D improperly referenced tags." length))))
    (format t "~&You will have to run the formatter again.")))

(define-page-previewer-command 1(com-show-improperly-referenced-tags)
0    ()
   (unless current-pages
     (page-previewer-barf "No current pages."))
   (let ((bogus-tags (formatted-pages-improperly-referenced-tags current-pages)))
     (cond ((null bogus-tags)
	    (format t "~&There were no improperly referenced tags."))
	   (t
	    (format t "~&Improperly referenced tags for ~A:  " current-record-group)
	    (format-textual-list (reverse bogus-tags) #'princ :filled t :conjunction "and")))))

(define-presentation-to-command-translator 1show-bogus-tags
0   (bogus-tags
     :documentation "Show the improperly referenced tags")
   (ignore)
  `(com-show-improperly-referenced-tags))

#||
(define-page-previewer-command (1com-check-for-bogus-tags0)
    ((record-group `((formatted-record-group :hash-table ,formatted-pages-hash-table))
		   :default current-record-group))
   (let* ((formatted-pages (gethash record-group formatted-pages-hash-table))
	  (ambient-values (formatted-pages-final-ambient-values formatted-pages))
	  (values (sys:eval-in-instance ambient-values 'values))
	  (tag-values (second (find 'tag-values values :key #'car))))
     (check-for-bogus-tag-values tag-values)))

(define-page-previewer-command 1(com-discard-ambient-values)
0    ((record-group `((formatted-record-group :hash-table ,formatted-pages-hash-table))
		   :default current-record-group))
   (let* ((formatted-pages (gethash record-group formatted-pages-hash-table)))
     (setf (formatted-pages-final-ambient-values formatted-pages) nil)))
||#

(define-presentation-type 1unassigned-case-selectors 0()
   :expander t
   :printer ((thing stream) (ignore thing stream)))

(defun 1format-unassigned-case-selectors 0()
  (loop for (selector record-group unassigned-clause)
	    in (reverse *unassigned-case-selectors*)
	do
    (format t "~&~a in ~a ~:[ (no Unassigned clause provided)~;~]"
	    selector record-group unassigned-clause)))

(define-page-previewer-command 1(com-show-unassigned-case-selectors)
0    ()
   (if (null *unassigned-case-selectors*)
       (format t "~&There were no unassigned Case selectors.")
       (format t "~&Unassigned Case selectors for ~A:  " current-record-group)
       (format-unassigned-case-selectors)))

(define-presentation-to-command-translator 1show-unassigned-case-selectors
0   (unassigned-case-selectors
     :documentation "Show unassigned Case selectors")
   (ignore)
  `(com-show-unassigned-case-selectors))

(defun 1check-for-unassigned-case-selectors 0(&optional (threshold 5))
  (let ((length (length *unassigned-case-selectors*)))
    (cond ((zerop length))			;none
	  ((< length threshold)
	   (format t "~2&There ~:[were~;was~] ~D unassigned Case selector~:P:"
		   (= length 1) length)
	   (format-unassigned-case-selectors))
	  (t 
	   (dw:with-output-as-presentation (:stream *standard-output*
					    :type 'unassigned-case-selectors
					    :object (reverse *unassigned-case-selectors*))
	     (format t "~&There were ~D unassigned Case selectors.  Click here to see them."
		     length))))))

(defun 1import-commands-into-page-previewer0 (commands)
  (dolist (thing commands)
    (multiple-value-bind (command-name pretty-name)
       (if (consp thing)
	   (values (first thing) (second thing))
	   (values thing nil))
      (if pretty-name
	  (cp:install-command 'page-previewer command-name pretty-name)
	  (cp:install-command 'page-previewer command-name)))))

(import-commands-into-page-previewer
  '((ddex::com-show-documentation-overview "Show Overview")
    com-show-documentation
    print::show-printer-status
    print::delete-printer-request
    print::restart-printer-request
    ;; print::halt-printer print::start-printer print::reset-printer
    ))

