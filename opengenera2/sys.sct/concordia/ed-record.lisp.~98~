;;; -*- Base: 10; Mode: LISP; Package: NSAGE; Syntax: Common-lisp; -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; This file contains the parts of the Zwei-based Concordia
;;; writer's user interface having to do with editing records
;;; and references.

(defmethod D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")(note-record-reverted doc-record)0 ()
  (setf (doc-record-modified self) nil)
  (setf (doc-record-installed self) nil)
  (setf (doc-record-published self) nil)
  (setf (doc-record-checkpointed self) nil))

;;---This fails miserably to deal with callers, callees, match-cache, and all the
;; other good things that index-loading does.
(defun 1read-list-of-editable-records-from-sab-file0 (index-info sab-attribute-alist
						    sab-logical-pathname)
  (declare (values list-of-records))
  (zwei:zcollecting-into (list-of-records)
    (keeping-sage-files
      (dolist (item index-info)
	(destructuring-bind (topic type fields) item
	  (setq fields (copy-list fields))
	  (let ((unique-id) (version-number))
	    (with-index-field (uid unique-id fields)
	      (setq unique-id uid))
	    (with-index-field (version version-number fields)
	      (setq version-number version))
	    (let ((record (find-record-for-topic-and-type
			    topic type :edited :unique-id unique-id
			    :version-number version-number :create-p t
			    :supersede-topic-if-different T))
		  (source-pathname
		    (second (assoc :logical-source-pathname sab-attribute-alist))))
	      (install-index-info-1
		record topic type fields source-pathname sab-logical-pathname :edited)
	      (force-fill-doc-record-contents-from-disk record :edited)
	      (zwei:zcollect list-of-records record)
	      ())))))
    list-of-records))

;;; It would be nice to do attribute bindings, create hash tables, and finish
;;; installing at a higher level.  But find-record-for-lookup calls this on
;;; individual records.
;;; NOTE:  Nothing can call find-record-for-lookup within the dynamic extent
;;; of this function, or we can get infinite recursion in "writer" lookup
;;; mode.  In particular, calls to appropriate-title-rendering and namespace-type-string
;;; must pass a record as the last argument.
(defun 1install-edited-record-in-record-group0 (edited-record)
  ;; clone-record-contents depends on correct bindings for @L parsing
  (with-file-attributes-from-home-buffer (edited-record)
    (let* ((record-group (doc-record-record-group edited-record))
	   (old-installed-record (record-group-installed-record record-group))
	   (old-callees (and old-installed-record
			     (doc-record-callees old-installed-record)))
	   (old-tokens (and old-installed-record
			    (doc-record-tokens old-installed-record))))
      (compute-doc-record-callees edited-record)
      (compute-doc-record-tokens edited-record)
      ;;---Redefinition warnings?
      (verify-record-capitalization edited-record t)
      (let ((installed-record (clone-record-contents edited-record)))
	(canonicalize-tokens (doc-record-tokens installed-record))
	(sys:without-aborts
	  ("Documentation index information for ~A ~A is being installed.~@
            Aborting now could leave documentation data structures in an~@
            inconsistent state and cause problems in using the Document Examiner."
	   (namespace-type-string record-group installed-record)
	   (appropriate-title-rendering record-group 'no-formatting installed-record))
	  (setf (record-group-installed-record record-group) installed-record)
	  (let ((add-word-hash-table (make-hash-table))
		(remove-word-hash-table (make-hash-table)))
	    (establish-record-in-neighborhood
	      installed-record *topic-aarray* add-word-hash-table remove-word-hash-table
	      old-tokens old-callees old-installed-record)
	    (finish-installing-sage-records add-word-hash-table remove-word-hash-table))
	  (setf (doc-record-installed edited-record) t)
	  (setf (doc-record-installed installed-record) t)
	  installed-record)))))

;;; Creating Records

;;; Create Record creates a new empty one or a new one with contents
;;; extracted from a region in an existing record.
(zwei:defcom 1com-wt-create-record
0	     "Creates a new record, using region as the contents.
It prompts for a record name and a record type and creates
a new record following the current one.

When a region is specified, it uses the region as the
contents field for the new record, taking the text out of
the region and replacing it with a link to the newly
created record.  It prompts for a view for the link.

With no region specified, it creates a new empty record
and then selects it so you can start editing it." ()
  (let* ((topic-name (zwei:typein-line-accept-record-title :prompt "Record title"))
	 (type (zwei:typein-line-accept `((dw:member-sequence ,*all-object-types*)
					  :description "a record type")
					:prompt "Record type"
					:default 'section)))
    (if zwei:(window-mark-p *window*)
	(wt-extract-record-internal topic-name type t)
	(wt-create-record-internal topic-name type)))
  zwei:dis-text)

;;; Make a new empty record
(defun 1wt-create-record-internal0 (topic-name type)
  (let ((record
	  (create-record-internal topic-name type zwei:*interval* :if-exists :query)))
    (let ((record-node (zwei:insert-record-structure-nodes record :at-bp (zwei:point))))
      ;; Just get point into the new record anywhere because updating the arglist
      ;;  requires that point be in the record to be modified
      (zwei:move-point (zwei:forward-line (zwei:node-first-bp
					    (first (zwei:node-inferiors record-node)))))
      (when (record-allows-arglist-field record)
	(com-wt-update-arglist-field))
      ;; Now put the cursor where the writer is most likely to want it
      (add-or-move-to-record-field record record-node 'contents () T)
      (zwei:recenter-window zwei:*window* :start (zwei:node-first-bp record-node)))
    (remove-killed-record-group-marker-if-necessary (doc-record-record-group record))
    ))

;;; Make a new record with contents extracted from the region in an existing record.
(defun 1wt-extract-record-internal0 (topic-name type &optional move-point?)
  (zwei:region (bp1 bp2) 
    (flet ((containing-record-field-node (bp)
	     (loop for node = (zwei:bp-node bp) then (zwei:node-superior node)
		   while node
		   when (typep node 'zwei:doc-record-field-structure-node)
		     return node)))
      (let ((node1 (containing-record-field-node bp1)))
	(unless (and node1
		     (eq node1 (containing-record-field-node bp2))
		     (let ((record-field (zwei:markup-structure-node-markup-structure node1)))
		       (eq record-field (doc-record-contents
					  (directive-superior record-field)))))
	  (zwei:barf "The region must be entirely within the contents field ~
			of a single record."))))
    (let ((view (zwei:typein-line-accept 'reference-type :default 'include
					 :prompt (format nil "View for new link to ~:(~A~) ~A"
							 type topic-name)))
	  (contents (zwei:copy-interval bp1 bp2 T))
	  (record (create-record-internal topic-name type zwei:*interval* :if-exists :query)))
      (let* ((record-node (zwei:insert-record-structure-nodes record :at-bp (zwei:point)))
	     (contents-field-node
	       (or (find (doc-record-contents record)
			 (zwei:node-inferiors record-node)
			 :key #'zwei:markup-structure-node-markup-structure)
		   (error "Failed to find contents-field node (internal error)"))))
	;; Put the contents of the region into the new record
	(zwei:insert (zwei:forward-line (zwei:node-first-bp contents-field-node)) contents)
	;; New record could need an argument list, which requires moving point into the record
	(when (record-allows-arglist-field record)
	  (zwei:with-bp (where-am-I (zwei:point))
	    (zwei:move-point (zwei:forward-line (zwei:node-first-bp
						  (first (zwei:node-inferiors record-node)))))
	    (unwind-protect 
		(com-wt-update-arglist-field)
	      (zwei:move-point where-am-I))))	;Carefully put point back where it was
	(remove-killed-record-group-marker-if-necessary (doc-record-record-group record))
	;; Don't use kill-interval because the contents are already saved in the new record
	(zwei:delete-interval bp1 bp2)
	(zwei:move-point bp1)
	(zwei:move-mark  bp1)
	(insert-reference-at-point :record-group (doc-record-record-group record)
				   :view view)
	(when move-point?
	  (zwei:move-point (zwei:node-first-bp
			     (first (zwei:node-inferiors contents-field-node))))
	  (zwei:move-mark  (zwei:node-first-bp
			     (first (zwei:node-inferiors contents-field-node)))))))))

;;; Create Record creates a new empty one or a new one with contents
;;; extracted from a region in an existing record.
(zwei:defcom 1com-wt-create-link-and-record
0	     "Creates a new documentation record, and inserts a link to it
Prompts for the name and record type, and for a view for the link.

When a region is specified, it uses the region as the
contents field for the new record, taking the text out of
the region and replacing it with a link to the newly
created record." ()
  (let* ((topic-name (zwei:typein-line-accept-record-title :prompt "Record title"))
	 (type (zwei:typein-line-accept `((dw:member-sequence ,*all-object-types*)
					  :description "a record type")
					:prompt "Record type"
					:default 'section)))
    (if zwei:(window-mark-p *window*)
	(wt-extract-record-internal topic-name type)
	(wt-create-link-and-record-internal topic-name type)
	))
  zwei:dis-text)

(defun 1wt-create-link-and-record-internal0 (topic-name type)
  (let* ((record (create-record-internal topic-name type zwei:*interval* :if-exists :query))
	 (record-group (doc-record-record-group record)))
    (zwei:insert-record-structure-nodes record :at-bp (zwei:point))
    (remove-killed-record-group-marker-if-necessary (doc-record-record-group record))
    (insert-reference-at-point :record-group record-group)))

(zwei:defcom 1com-wt-copy-record0 "Copies a documentation record into a newly created record.
Asks for the record from which to copy, and then prompts 
for the name and record type for the new record.  Only copies 
the record contents, not the other record fields."
	     ()
  (multiple-value-bind (record-group-at-point record-at-point record-node-at-point)
      (record-group-at-point nil)
    (ignore record-node-at-point)
    (let* ((record-group-to-copy
	     (zwei:typein-line-accept-record-group
	       :default record-group-at-point
	       :prompt "Record to copy"))
	   (record-to-copy (or (first (record-group-edited-records record-group-to-copy))
			       ;;--- We don't really have a way to accept a particular
			       ;; record version.
			       (find-record-for-lookup record-group-to-copy)))
	   (topic-name (zwei:typein-line-accept-record-title
			 :use-prefix nil :use-suffix nil
			 :prompt "Title for new record"
			 :default (and record-group-at-point
				       (appropriate-title-rendering
					 record-group-at-point
					 'no-formatting
					 record-at-point))))
	   (type (let ((old-type (and record-group-at-point
				      (record-group-type record-group-at-point))))
		   (zwei:typein-line-accept
		     `((dw:member-sequence ,*all-object-types*)
		       :description "a record type")
		     :prompt "Record type"
		     :default old-type))))
      (multiple-value-bind (new-record record-already-exists)
	  (create-record-internal topic-name type zwei:*interval*
				  :if-exists nil)
	(when record-already-exists
	  (unless (yes-or-no-p "The target record already exists.  Attempt to replace its contents?")
	    (zwei:barf)))
	(macrolet ((copy-field (field)
		     `(setf (,field new-record)
			    (clone-record-field (,field record-to-copy) new-record))))
	  (copy-field doc-record-contents)
	  (copy-field doc-record-oneliner)
	  (copy-field doc-record-keywords)
	  ;;--- Other fields to copy?
	  )
	(let ((record-node (zwei:insert-record-structure-nodes
			     new-record :at-bp (zwei:point))))
	  (labels ((find-contents-field-node ()
		     (loop for node in (zwei:node-inferiors record-node)
			   as record-field = (zwei:markup-structure-node-markup-structure node)
			   when (eq (record-field-field-name record-field) 'contents)
			     do (return-from find-contents-field-node node))
		     (first (zwei:node-inferiors record-node)))
		   (move-point-into-contents-field ()
		     ;; Move the cursor inside the first record-field
		     (zwei:move-point
		       (zwei:forward-line
			 (zwei:node-first-bp
			   (find-contents-field-node))))))
	    (move-point-into-contents-field)
	    (when (record-allows-arglist-field new-record)
	      (com-wt-update-arglist-field))
	    (move-point-into-contents-field)
	    (remove-killed-record-group-marker-if-necessary (doc-record-record-group
							      new-record))
	    )))))
  zwei:dis-text)

;;; :HEURISTIC means apply normal capitalization rules to all words that
;;; don't have weird capitalization patterns.  I.e.
;;; "the FEP debugger"  "The FEP Debugger"
;;; :EXPLICIT means take exactly what the writer typed.  I.e.
;;; "the FEP debugger"  "the FEP Debugger"
;;; :CAPITALIZE means apply normal capitalization rules to every word.  I.e.
;;; "the FEP debugger"  "The Fep Debugger"
(defvar 1*title-capitalization-mode*0 :heuristic "One of :HEURISTIC, :EXPLICIT, :CAPITALIZE")

(defgeneric 1capitalize-title-string0 (record title) )
(defmethod 1(capitalize-title-string doc-record :default)0 (title)
  title)

(defmethod 1(capitalize-title-string concept-record)0 (title)
  (capitalize-title-string-1 title))

(defun 1capitalize-title-string-10 (title)
  (ecase *title-capitalization-mode*
    (:explicit nil)
    (:heuristic (capitalize-string-as-title title))
    (:capitalize (string-capitalize-words title))))

(defun 1create-record-internal0 (topic-string type buffer &key (if-exists :error))
  (declare (values record there-was-existing-record-group))
  (let ((topic (validate-topic (list topic-string) type)))
    (let ((existing-record-group (find-record-group-for-topic-and-type topic type nil nil)))
      (when existing-record-group
	;; if there is an existing record group, the writer is probably making a mistake
	(ecase if-exists
	  (:error
	    (zwei:barf "A record of that name and type already exists."))
	  ((nil :ignore) nil)
	  (:query
	    (query-case ("A record of that name and type already exists.  If you create a new one you may make the old one inaccessible.  Do you wish to create a new record? ")
			(:beep t
			 :help-function
			  (lambda (s)
			    (format s "~&Yes: go ahead.  No: don't.  Edit: Don't go ahead, but edit the existing record.")))
	      ((Yes #\Y) nil)
	      ((No #\N) (zwei:abort-current-command))
	      ((Edit #\E)
	       (edit-record existing-record-group)
	       (zwei:force-return-from-zwei-command zwei:dis-all))))))
      ;; canonicalize the topic string if necessary
      (when (concept-type-p type)
	(setq topic (capitalize-title-string-1 topic)))
      (let ((record (find-record-for-topic-and-type topic type :edited
						    :create-p :valid)))
	(assure-record-group-unique-id-valid (doc-record-record-group record))
	(when (null (doc-record-disk-location record))
	  (setf (doc-record-disk-location record)
		(list (list (send-if-handles buffer :pathname)
			    '|Undetermined SAB location|
			    '|Undetermined SAB location|))))
	(dolist (field-name (record-field-names-for-creation record))
	  (new-record-field-for-editing record field-name))
	
	(collect-reference (doc-record-record-group record))
	(apply-in-concordia #'ignore #'cause-redisplay-of-references-pane)
	(setf (doc-record-filled record) T)
	(values record (not (null existing-record-group)))))))

(defmethod 1(verify-record-capitalization doc-record :default)0 (&optional (install-new-title t))
  (ignore install-new-title)
  ())

;;; this should not be called except by install-edited-record-in-record-group
;;; as it side-effects the record-group
(defmethod 1(verify-record-capitalization concept-record)0 (&optional (install-new-title t))
  (let* ((current-record-group-title (record-group-topic-completion record-group))
	 (current-capitalization
	   (appropriate-title-rendering record-group 'no-formatting self))
	 (possible-proper-capitalization
	   (capitalize-string-as-title current-capitalization)))
    (unless (string= current-capitalization possible-proper-capitalization)
      (unless (string= current-capitalization current-record-group-title)
	(warn "Capitalizing mismatch:

  Standard:  ~A
  Custom:    ~A"
	      possible-proper-capitalization current-capitalization)))
    (unless (string= current-record-group-title current-capitalization)
      (si:aarray-delete-by-name *topic-aarray* current-record-group-title)
      (setf (record-group-topic record-group) current-capitalization)
      (setq name current-capitalization)
      (update-display-for-changed-record-name)
      (when install-new-title
	(si:aarray-insert *topic-aarray* current-capitalization record-group)))))

(defun 1update-display-for-changed-record-name0 ()
  (zwei:invalidate-cached-title-strings)
  (when (variable-boundp zwei:*window*)
    (zwei:must-redisplay zwei:*window* zwei:dis-all))
  (incf (collected-references-tick *collected-references*))
  (cause-redisplay-of-references-pane))

(defmacro 1when-record-group-unpatched0 ((record-group) format-body &body body)
  `(when-record-group-unpatched-1
     ,record-group
     (dw:named-continuation format-body
			    ,@format-body)
     (dw:named-continuation when-record-group-unpatched-body () ,@body)))

(defun 1when-record-group-unpatched-10 (record-group format-continuation body-continuation)
  (let ((patch (gethash record-group zwei:*patched-record-hash-table*)))
    (when (and patch (member patch zwei:*active-patch-states*))
      (let ((desc (zwei:patch-state-description patch)))
	(let ((desc-comma (string-search-char #\, desc)))
	  (when desc-comma (setq desc (substring desc 0 desc-comma))))
	(let ((description-string
		(format nil "~A: ~A, in ~\\presentation\\~@[, declared system ~A~]~:[~; (current patch)~]"
			(zwei:patch-state-state patch) desc (zwei:patch-state-buffer patch)
			(and (zwei:private-patch-p patch)
			     (zwei:private-patch-state-for-system-name patch))
			(eq zwei:*current-patch* patch))))
	  (funcall format-continuation description-string)
	  (funcall body-continuation))))))

(zwei:defcom 1com-wt-rename-record0 "Renames the record containing point.  
Prompts for a new name in the minibuffer." ()
  (multiple-value-bind (record-group-at-point record-at-point record-node)
      (record-group-at-point)
    (let ((patch-description))
      (when-record-group-unpatched
	(record-group-at-point)
	((description)
	 (setq patch-description description))
	(let ((go-ahead
		(y-or-n-p
		  "This record is included in a patch which you have not yet finished.
\(~A)
Do you really want to rename it? " patch-description)))
	  (cond (go-ahead
		 (setf (gethash `(,record-group-at-point
				  ,(gethash record-group-at-point
					    zwei:*patched-record-hash-table*))
				zwei:*patch&renamed-record-table*)
		       t))
		(t (return-from com-wt-rename-record zwei:dis-none))))))

    (let ((old-title (appropriate-title-rendering record-group-at-point
						  'no-formatting record-at-point)))
      (let ((new-title
	      (zwei:typein-line-accept
		'string
		:prompt "New title for record"
		:default old-title)))
	(cond ((string-equal new-title old-title)
	       (beep)
	       (zwei:typein-line "The new title is the same as the old title.")
	       zwei:dis-none)
	      (t
	       (condition-case (e)
		    (assure-new-name-unique new-title
					    (record-group-type record-group-at-point))
		  (error (zwei:barf e)))
	       (rename-record-group-and-record
		 record-group-at-point record-at-point record-node new-title)
	       zwei:dis-none))))))

(defun 1assure-new-name-unique0 (new-name type)
  (let ((type (coerce-record-type type 'property)))
    (when (topic-record-group new-name type)
      (error "A record by that name and type already exists."))))

#||
(defun find-bogus-ones ()
  (tv:noting-progress ("Finding them")
    (let ((denominator (length *topic-aarray*)))
      (loop for elt being the array-elements of sage::*topic-aarray* 
	    for count from 0
	    as (name . stuff) = elt
	    do
	(let ((alist ()))
	  (flet ((add-thing (name object)
		   (if (assoc name alist :test #'string-equal)
		       (push object (cdr (assoc name alist :test #'string-equal)))
		       (push `(,name ,object) alist))))
	    (loop for thing in stuff
		  as name = (format nil "~s" (record-group-topic thing))
		  do
	      (add-thing name thing)))
	  (loop for set in alist
		as (name . objects) = set
		when (let ((types (cl:map 'cl:list #'sage::record-group-type objects)))
		       (neq (scl:remove-duplicates types) types))
		  do (print name)))
	(tv:note-progress count denominator)))))
||#

(defmethod 1(rename-record-group-and-record record-group)0 (record node new-title)
  (zwei:mung-node node)
  (let ((current-name (record-group-topic-completion self))
	(new-topic (validate-topic (list new-title) type)))
    (setq new-title (capitalize-title-string record new-title))
    (si:aarray-delete-by-name *topic-aarray* current-name)
    (setq topic new-topic)
    (si:aarray-insert *topic-aarray* new-title self)
    (update-display-for-changed-record-name)
    (flet ((do-it (record status)
	     (setf (doc-record-name record) new-topic)
	     (let ((source-topic (doc-record-source-topic record)))
	       (when (and source-topic (eq status :edited))
		 (let ((source-topic-node
			 (block find-it
			   (loop for zwei-node in (zwei:node-inferiors node)
				 as record-field =
				    (zwei:markup-structure-node-markup-structure zwei-node)
				 when (eq record-field source-topic)
				   do (return-from find-it zwei-node)))))
		   (setf (zwei:node-inferiors node) (delete source-topic-node
							    (zwei:node-inferiors node)))
		   (setf (doc-record-source-topic record) nil)
		   (add-or-move-to-record-field record node 'source-topic () t)
		   )))))
      (when installed-record (do-it installed-record :installed))
      (loop for edited-record in edited-records do (do-it edited-record :edited)))
    (zwei:redo-node-links node)))


;;; Change record type

(zwei:defcom 1com-wt-change-record-type0 "Changes the type of the record containing point.
Prompts for a new type in the minibuffer." ()
  (multiple-value-bind (record-group-at-point record-at-point)
      (record-group-at-point)
    (let* ((old-type (record-group-type record-group-at-point))
	   (new-type (zwei:typein-line-accept `((dw:member-sequence ,*all-object-types*)
						:description "a record type")
					      :prompt "Record type"
					      :default old-type)))
      (cond ((eq new-type old-type)
	     (beep)
	     (zwei:typein-line "The new type is the same as the old type.")
	     zwei:dis-none)
	    (t
	     (condition-case (e)
		  (assure-new-name-unique (appropriate-title-rendering record-group-at-point
								       'no-formatting
								       record-at-point)
					  new-type)
		(error (zwei:barf e)))
	     (zwei:mung-node (zwei:bp-node (zwei:point)))
	     (change-record-group-type-and-editor-nodes
	       record-group-at-point new-type :mode ':explicit)
	     (when (record-allows-arglist-field record-at-point)
	       (com-wt-update-arglist-field))
	     zwei:dis-none)))))

(defmethod 1(change-record-group-type-and-editor-nodes record-group)
0	   (new-type &key (mode ':explicit) guilty-record)
  (change-record-group-type self new-type :mode mode :guilty-record guilty-record)
  (flet ((do-it (record)
	   (when (and record
		      (not (eql (doc-record-source-type record) new-type)))
	     (let ((editor-nodes (gethash record *zwei-nodes-for-record-table*)))
	       (when editor-nodes
		 (let ((proper-fields (record-field-names-for-editing record)))
		   ;; since record-field-names-for-editing is sooo stupid!
		   (unless (record-allows-arglist-field record)
		     (setq proper-fields (remove 'arglist proper-fields)))
		   (flet ((fix-node (node)
			    (let ((exposed-fields (zwei:node-inferiors node)))
			      (let ((new-fields
				      (loop for field in exposed-fields
					    as record-field = (zwei:markup-structure-node-markup-structure field)
					    as valid-p = (member
							   (record-field-field-name
							     record-field) proper-fields)
					    when valid-p
					      collect field
					    unless valid-p
					      do
						(zwei:move-nonboundary-bps-of-node-to
						  field (zwei:node-first-bp node)))))
				(setf (zwei:node-inferiors node) new-fields)))
			    (zwei:mung-node node)
			    (zwei:redo-node-links node)))
		     (map () #'fix-node editor-nodes))))))))
    (case mode
      (:published (do-it published-record))
      ((:explicit :edited)
       (loop for edited-record in edited-records do (do-it edited-record))))
    (do-it installed-record))
  (update-display-for-changed-record-name))


;;; Edit Record

;;; External interface
(defun 1zwei:edit-sage-definition-internal0 (record-group-or-topic &optional type)
  (let (record-group)
    (cond (type
	   (setq record-group (find-record-group-for-topic-and-type
				record-group-or-topic
				type)))
	  (t (setq record-group record-group-or-topic)))
    (edit-record record-group)))

(cp:define-command (1com-edit-documentation0 :command-table "Editing"
					   :provide-output-destination-keyword nil)
    ((record-group 'record-group
		   :prompt "for topic"
		   :confirm t
		   :default (default-record-group-for-command)
		   :documentation "Documentation topic to edit"))
   (flet ((doit (&optional command-loop)
	    (if command-loop
		;; if there's a command loop, we have to use the internal interface.  yecch.
		(zwei:zed `(zwei:edit-sage-definition ,record-group) command-loop)
		;; otherwise, use the external one
		(ed `(zwei:edit-sage-definition ,record-group)))))
     (if zwei:*inside-zmacs*
	 (doit)
	 (let* ((concordia-frame (dw:find-program-window 'concordia))
		(zmacs-pane (send concordia-frame :get-pane 'zmacs))
		(config (send concordia-frame :configuration))
		(command-loop (when (eq config 'zmacs-editor)
				(send zmacs-pane :command-loop))))
	   (doit command-loop)))))

(define-record-group-to-command-translator com-edit-documentation
					   "Edit Documentation" "Edit Documentation"
					   :gesture :edit-function
					   :priority 1)

(cp:install-commands "doc-ex"
		     '(com-edit-documentation))

(defun edit-wt-files (pathnames)
  (if zwei:*inside-zmacs*
      (ed pathnames)
      (let* ((concordia-frame (dw:find-program-window 'concordia))
	     (zmacs-pane (send concordia-frame :get-pane 'zmacs))
	     (config (send concordia-frame :configuration))
	     (command-loop (when (eq config 'zmacs-editor)
			     (send zmacs-pane :command-loop))))
	(if command-loop
	    (zwei:zed pathnames command-loop)
	    (ed pathnames)))))

(si:define-file-editor edit-wt-files
    :pretty-name "Concordia"
    :after "Zmacs"	    ;Choose this by default only if Zmacs doesn't suffice.
    :file-filter
       #'(lambda (x)
	   (or (si:text-file-p x)
	       (eq (send (cl:pathname x) :canonical-type) :sage-binary)))
    :file-filter-description "text or sab file"
    :context-filter #'(lambda () (not (sys:remote-terminal-p)))
    :context-filter-description "on the main screen"
    :permit-multiple t
    :source-filter
       #'(lambda (x)
	   (if (eq (send (cl:pathname x) :canonical-type) :sage-binary)
	       x
	       (si:text-or-source x))))


;;; Editor stuff

(zwei:defcom 1com-wt-edit-record0 "Prompts for a documentation topic and edits that record." ()
  (let ((record-group (zwei:typein-line-accept-record-group)))
    (edit-record record-group))
  zwei:dis-text)

(zwei:defcom 1com-wt-edit-installed-record0 "Prompts for a documentation topic and edits the currently installed version." ()
  (let ((record-group (zwei:typein-line-accept-record-group)))
    (edit-record record-group :installed t))
  zwei:dis-text)

(defun 1edit-record0 (record-group &key installed)
  (let ((buffer (ensure-record-in-editor record-group :installed installed :warn t)))
    (unless (eq buffer :cant-locate-source-file)
      (let* ((record (first (record-group-edited-records record-group)))	; --- which record is which?
	     (node (markup-structure-node-for-record record buffer))
	     (start-bp (and node (zwei:node-first-bp node))))
	(when (null node)
	  (zwei:barf "Can't locate editor node for the record (internal error)"))
	(zwei:point-pdl-push (zwei:point) zwei:*window* t)
	(zwei:make-buffer-current buffer)
	(zwei:recenter-window zwei:*window* ':start start-bp)
	(zwei:move-point start-bp)))))

(defun 1ensure-record-in-editor0 (record-group &key installed warn)
  (declare (values buffer))
  (let* ((edited-records (record-group-edited-records record-group))
	 ;; --- which edited record??
	 (the-edited-record (and edited-records (first edited-records)))
	 (node-for-the-edited-record (and the-edited-record
					  (find-home-node-for-record the-edited-record))))
    ;; If there was an abortive attempt to read the record earlier, we might
    ;; have an edited record structure but not have gotten far enough to generate
    ;; a zwei node for it.
    (cond (node-for-the-edited-record
	   ;;--- which record?
	   (zwei:interval-buffer node-for-the-edited-record))
	  ;; No existing node, so read the record's file into the editor.
	  (t 
	   (let* ((record (or (record-group-published-record record-group)
			      (record-group-installed-record record-group)))
		  (file (and record
			     (doc-record-sab-file
			       record :installed installed))))
	     (cond (file
		    (multiple-value-bind (nil buffer)
			;; Has to call this when finding a file outside Zmacs
			(zwei:load-file-into-zmacs file nil)
		      buffer))
		   (t (when warn
			(beep)
			(format t "Cannot determine the source file for ~A.~&
It is impossible to reconstruct exactly how this state came about,
but "
				record-group)
			(cond ((record-group-callers-after-installing-edited-records-if-necessary record-group)
			       (format t
				       "since there are links to this record, you may have
simply loaded a file that contains the records containing the links
but have not yet loaded the file containing the record. You can use
Show Links to Record to examine those links."))
			      (t (format t "it is possible that you loaded a record (or records)
that contained a link to ~A 
and then edited that record to no longer contain the link without ever
having loaded the file containing ~:*~A." record-group)))
			(format t "~&It is also possible that you used m-X Remove Record from Buffer on this record."))
		      :cant-locate-source-file)))))))


;;;--- Can return NIL.
(defmethod 1(doc-record-sab-file doc-record)0 (&key installed)
  (let ((pathname
	  (or (and (pathnamep source-file)
		   (eq (send source-file :canonical-type) :sage-binary)
		   source-file)
	      (disk-location-pathname self :allow-patch-file nil))))
    (if installed
	pathname
	(when pathname (send pathname :new-pathname :version :newest)))))

(defun 1record-node-at-point0 (&optional (barf-if-none T))
  (let ((record-node (zwei:find-containing-record (zwei:point))))
    (cond (record-node record-node)
	  (barf-if-none (zwei:barf "The cursor is not inside a record"))
	  (T ()))))

(defun 1record-at-point0 (&optional (barf-if-none T))
  (declare (values record record-node))
  (let ((record-node (zwei:find-containing-record (zwei:point))))
    (cond (record-node
	   (values (zwei:markup-structure-node-markup-structure record-node)
		   record-node))
	  (barf-if-none
	   (zwei:barf "The cursor is not inside a record"))
	  (T (values () ())))))

(defun 1record-group-at-point0 (&optional (barf-if-none T))
  (declare (values record-group record record-node))
  (multiple-value-bind (record record-node) (record-at-point barf-if-none)
    (unless (typep record 'killed-record)
      (values (and record (doc-record-record-group record)) record record-node))))

;;; Preview Record

(zwei:defcom 1com-wt-preview-record0 "Preview the record at point" ()
  (let ((record (record-at-point)))
    (stack-let ((records (list record)))
      (preview-records
	records
	(if zwei:*numeric-arg-p* (zwei:read-sage-output-device) :screen))))
  zwei:dis-none)

(defun 1preview-records0 (records device)
  (dolist (record records)
    (install-edited-record-in-record-group record))
  (when device
    ;;--- If you're trying to preview a record and there is an edited record with a
    ;; higher version number, this will use the record with the higher version number.
    ;; The modularity isn't quite right; we'd like to tell the formatter to use a
    ;; particular record, not pass it the record group and make it guess which one
    ;; to use.
    (let ((*record-lookup-mode* ':normal))
      (dolist (record records)
	(sage-displayer device (appropriate-title-rendering (doc-record-record-group record)
							    'no-formatting)
			#'formatted-sage-record-line-source
			(doc-record-record-group record))))))

(defun 1map-over-record-nodes-in-region0 (function)
  "function is called with record-node and record"
  (flet ((do-between-nodes (first-node last-node)
	   (loop for node = first-node then (zwei:node-next node)
		    do
		(unless (typep node 'zwei:record-structure-node)
		  (loop-finish))
		(funcall function node (zwei:markup-structure-node-markup-structure node))
		(when (eq node last-node) (loop-finish)))))
    (zwei:region (bp1 bp2)
      (let ((record-node1 (zwei:find-containing-record bp1))
	    (record-node2 (zwei:find-containing-record bp2)))
	(cond ((and record-node1 record-node2)
	       (do-between-nodes record-node1 record-node2))
	      ((null record-node1)
	       ;; either the bp is at the beginning of the buffer, or it's at the end
	       (when (zwei:bps-connected-by-simply-connected-lines
		       (zwei:node-first-bp zwei:*interval*) bp1)
		 (if (null record-node2)
		     (if (zwei:bps-connected-by-simply-connected-lines
			   (zwei:node-last-bp zwei:*interval*) bp2)
			 (do-between-nodes
			   (first (zwei:node-inferiors zwei:*interval*))
			   (first (last (zwei:node-inferiors zwei:*interval*))))
			 ())
		     (do-between-nodes (first (zwei:node-inferiors zwei:*interval*))
				       record-node2))))
	      ((null record-node2)
	       (do-between-nodes record-node1
				 (first (last (zwei:node-inferiors zwei:*interval*))))))))))

(zwei:defcom 1com-wt-install-record0 "Install the record at point, or in the region" ()
  (let ((nrecs 0))
    (flet ((fiddle-record (record)
	     (install-edited-record-in-record-group record)
	     (incf nrecs)))
      (if (zwei:window-region-p)
	  (let ((records-to-do 0)
		(records-done 0))
	    (map-over-record-nodes-in-region
	      (named-lambda count-records (&rest ignore) (incf records-to-do)))
	    (tv:noting-progress ("Installing records")
	      (map-over-record-nodes-in-region
		(named-lambda map-over-record-nodes-in-region (node record)
		  (ignore node)
		  (tv:note-progress (incf records-done) records-to-do)
		  (fiddle-record record)))))
	  (fiddle-record (record-at-point))))
    (zwei:typein-line "Installed ~d record~:p" nrecs))
  zwei:dis-none)

#||
(zwei:defcom 1com-wt-bogus-super-control-c0 "Don't actually install records but don't beep."
	     ()
  (zwei:typein-line "You don't need to do s-C any more.")
  zwei:dis-none)
||#

(zwei:defcom 1com-wt-check-spelling-of-record
0	     "Corrects the spelling of the contents of the record.
If there is a region, checks the spelling of all records in the region."
	     ()
  (flet ((check-spelling-of-record (node record)
	   (ignore record)
	   (zwei:spelling-correct-interval
	     (zwei:node-first-bp node) (zwei:node-last-bp node) "record")))
    (if (zwei:window-region-p)
	(map-over-record-nodes-in-region #'check-spelling-of-record)
	(multiple-value-bind (record node) (record-at-point)
	  (check-spelling-of-record node record))))
  zwei:dis-text)

(zwei:defcom 1com-wt-set-lookup-mode0 "Changes the lookup mode."
	     ()
  (let ((new-lookup-mode
	  (zwei:typein-line-accept
	    '(alist-member :alist
			   (("Normal" :value :normal
			     :documentation "Use newest edited records, else published.")
			    ("Use Published Record"
			     :value :use-published-record
			     :documentation "Use published records exclusively.")
			    ("Edit Newest Record"
			     :value :edit-newest-record
			     :documentation "Cause the newest version of the sab file containing
this record to be read into the editor.")))
	    :default *record-lookup-mode*)))
    (setq *record-lookup-mode* new-lookup-mode)
    zwei:dis-none))

(defvar 1*last-removed-record-group*0 nil)

;;; Kill Record
(zwei:defcom 1com-wt-remove-record-from-buffer0 "Removes the record at point from this buffer.
It does not update the document database; you may want to Kill Record.
You may reinsert the removed record (somewhere else, if need be) with Insert Record." ()
  (multiple-value-bind (record victim)
      (record-at-point)
    (zwei:mung-node victim)
    (sys:without-aborts ("Record ~A is being removed, an operation that must be atomic"
			 record)
      (let ((char-before (zwei:forward-char (zwei:node-first-bp victim) -1)))
	(zwei:move-point char-before)
	(remove-node-for-record victim)
	(zwei:move-nonboundary-bps-of-node-to victim char-before))
      (let ((superior (zwei:node-superior victim)))
	(setf (zwei:node-inferiors superior)
	      (delete victim (zwei:node-inferiors superior)))
	(setf (zwei:node-superior victim) nil)
	(zwei:redo-node-links superior))
      (setq *last-removed-record-group* (doc-record-record-group record)))
    (zwei:typein-line-durable "~A removed.  It may be reinserted with Insert Record."
			      record)
    zwei:dis-text))

;;; Insert Record
(zwei:defcom 1com-wt-insert-record0 "Insert an existing record" ()
  (let* ((record-group (zwei:typein-line-accept-record-group
			 :default *last-removed-record-group*))
	 (record (first (record-group-edited-records record-group)))	; --- which record is which?
	 (record-node (zwei:insert-record-structure-nodes record :at-bp (zwei:point))))
    ;;---Collapse competing nodes?
    (zwei:move-point (zwei:node-first-bp record-node)))
  zwei:dis-text)

(zwei:defcom 1com-wt-exchange-records0 "Exchange records in the buffer
Point must be between two records." ()
  ;;---Does this want to do all the hair of c-T et al for dragging the record around?
  (let ((record-node (record-node-at-point))
	(point (zwei:point)))
    (flet ((retch () (zwei:barf "The cursor must be between records."))
	   (swap-them (first second)
	     (let ((superior (zwei:node-superior first)))
	       (assert (eql superior (zwei:node-superior second)))
	       (let ((tail (member first (zwei:node-inferiors superior))))
		 (assert (eql second (second tail)))
		 (rotatef (first tail) (second tail))
		 (zwei:redo-node-links superior)))))
      (cond ((zwei:bp-= point (zwei:node-first-bp record-node))
	     (let ((previous-record-node (zwei:node-previous record-node)))
	       (unless (typep previous-record-node 'zwei:record-structure-node)
		 (retch))
	       (swap-them previous-record-node record-node)
	       (zwei:move-point (zwei:node-last-bp record-node))))
	    ((zwei:bp-= point (zwei:node-last-bp record-node))
	     (let ((next-record-node (zwei:node-next record-node)))
	       (unless (typep next-record-node 'zwei:record-structure-node)
		 (retch))
	       (swap-them record-node next-record-node)
	       (zwei:move-point (zwei:node-first-bp record-node))))
	    (T (retch)))))
  zwei:dis-text)

;;; Expand Reference

#+expand-references-in-line			;--- in-line expansion has been repudiated.
(zwei:define-presentation-to-editor-command-translator 1expand-reference0 
   (zwei:reference-structure-node "Expand reference"
				  zwei:*standard-comtab*
				  :gesture :edit-viewspecs)
						       (reference)
  `(zwei:expand-or-contract-reference ,reference))

;;; List Records

(zwei:defcom 1com-wt-show-records-in-buffer0 "List all the records in the buffer" ()
  (unless (typep zwei:*interval* 'zwei:markup-buffer)
    (zwei:barf "This isn't a Concordia buffer."))
  (if (zwei:node-inferiors zwei:*interval*)
      (dolist (node (zwei:node-inferiors zwei:*interval*))
	(when (typep node 'zwei:record-structure-node)
	  (multiple-value-bind (title type)
	      (zwei:record-structure-topic-name-and-type
		(markup-structure-node-markup-structure node))
	    (fresh-line)
	    (dw:with-output-as-presentation (:object (zwei:node-first-bp node)
					     :type 'zwei:bp)
	      ;; presented as a bp so click left moves to that particular record.
	      (let ((record-group (doc-record-record-group
				    (markup-structure-node-markup-structure node))))
		(dw:with-output-as-presentation
		    (:object record-group
		     :type (type-of record-group))
		  (format t "~A ~S" type title)))))))
      (format t "~%No records in buffer~%"))
  zwei:dis-none)

;;; Count records in buffer
(zwei:defcom 1com-wt-count-records-in-buffer0 "Counts the records in the buffer" ()
  (unless (typep zwei:*interval* 'zwei:markup-buffer)
    (zwei:barf "This isn't a Concordia buffer."))
  (zwei:typein-line "~[No~:;~:*~d~] record~:P in buffer"
		    (length (zwei:node-inferiors zwei:*interval*)))
  zwei:dis-none)

;;; Record motion commands

(zwei:defcom 1com-wt-what-record-am-I0 "Show name of the current record." ()
  (let ((record-group (record-group-at-point ())))
    (if record-group
	(zwei:typein-line "Current definition is ~:(~a~): ~\\presentation\\"
			  (record-group-type record-group) record-group)
	(zwei:typein-line "The cursor is not currently within a record")))
  zwei:dis-none)

(zwei:defcom 1com-wt-beginning-of-record
0	     "Move to the beginning of the current record." (zwei:km)
  (zwei:move-to-beginning-of-record)
  zwei:dis-bps)

(zwei:defcom 1com-wt-end-of-record0 "Move to the end of the current record." (zwei:km)
  (zwei:move-to-end-of-record)
  zwei:dis-bps)

(zwei:defcom 1com-wt-mark-record0 "Mark the current record." ()
  (zwei:assure-inside-record)
  (multiple-value-bind (first-bp last-bp)
      (zwei:record-interval)
    (zwei:mark-definition-internal
      (zwei:create-interval first-bp last-bp)))
  zwei:dis-bps)

(define-presentation-type 1record-field-name0 ((un-upgraded-fields))
   :history t
   :parser ((stream &key original-type initially-display-possibilities)
	    (values
	      (dw:complete-from-sequence un-upgraded-fields stream
					 :type original-type
					 :initially-display-possibilities
					 initially-display-possibilities
					 :name-key #'(lambda (x)
						       (string-capitalize
							 (upgrade-record-field-name x))))))
   :printer ((thing stream)
	     (format stream "~:(~A~)" (upgrade-record-field-name thing))))

;;; I (RLB) made this have the functionality of something better named Find Record Field.
;;; If it enforced Add Record Field, the field names offered could be pruned, like,
;;; don't offer Contents because there's always one there.
(zwei:defcom 1com-wt-add-record-field0 "Add (or move to) a field of the current record" ()
  (multiple-value-bind (record record-node) (record-at-point)
    (let* ((field-names (record-field-names-for-editing record))
	   (desired-field-name (zwei:typein-line-accept
				 `((record-field-name ,field-names)
				   :description "a field name"))))
      (add-or-move-to-record-field record record-node desired-field-name field-names ()))))

(defun 1add-or-move-to-record-field0 (record record-node desired-field-name field-names auto)
  (when (null field-names) (setq field-names (record-field-names-for-editing record)))
  (let* ((all-field-nodes (zwei:node-inferiors record-node))
	 (record-fields (record-fields-for-editing record))
	 (existing-record-field
	   (block found
	     (map () (lambda (field-name field)
		       (when (eq field-name desired-field-name)
			 (return-from found field)))
		  field-names record-fields))))
    (flet ((move-point-into-field-node (field-node)
	     (zwei:move-point (zwei:forward-line (zwei:node-first-bp field-node)))))
      (cond (existing-record-field
	     ;; Here's where to just zwei:barf if you want to enforce Add Field only
	     (cond ((do-sage-superiors (s (zwei:markup-structure-node-markup-structure
					    (zwei:bp-node (zwei:point))))
		      (when (eq s existing-record-field)
			(return T)))
		    ;; point is already inside the field, do nothing at all
		    (unless auto
		      (zwei:typein-line "The cursor is already inside the ~a field."
					desired-field-name))
		    zwei:dis-none)
		   (T (let ((record-field-node
			      (find existing-record-field
				    all-field-nodes
				    :key #'zwei:markup-structure-node-markup-structure)))
			(cond ((null record-field-node)
			       (zwei:barf "Failed to find editor node for ~s ~
						(internal error)"
					  existing-record-field))
			      (T
			       ;; Position the cursor inside the field
			       (move-point-into-field-node record-field-node)
			       zwei:dis-bps))))))
	    (T
	     (zwei:mung-node record-node)
	     ;; --- There probably wants to be a modular way to do this
	     ;; but I don't really understand DEFINE-RECORD-FIELDS-FOR-EDITING.
	     (when (eq desired-field-name 'source-topic)
	       (unless (doc-record-source-topic record)
		 (setf (doc-record-source-topic record)
		       (record-group-topic-completion (doc-record-record-group record)))))
	     (let* ((new-record-field (new-record-field-for-editing
					record desired-field-name))
		    (new-record-field-node
		      (zwei:markup-structure-editor-node new-record-field
							 record-node)))
	       ;; Insert the new node in the right place in the record-node's inferiors
	       ;; Can't just use POSITION because some of them don't exist.
	       (let ((previous-field ()))
		 (loop for field-name in field-names
		       for field in record-fields
		       do (cond ((eq field-name desired-field-name)
				 (loop-finish))
				(field (setq previous-field field))))
		 (let ((previous-field-node
			 (find previous-field all-field-nodes
			       :key #'zwei:markup-structure-node-markup-structure)))
		   (if (null previous-field-node)
		       (setf (zwei:node-inferiors record-node)
			     (cons new-record-field-node all-field-nodes))
		       (push new-record-field-node
			     (rest (member previous-field-node all-field-nodes))))))
	       (zwei:redo-node-links record-node)
	       (move-point-into-field-node new-record-field-node)
	       zwei:dis-text))))))

(zwei:defcom 1com-wt-update-arglist-field0 "Replaces the argument list field for the current definition."
	     ()
  (multiple-value-bind (record record-node) (record-at-point)
    (unless (typep record 'lisp-record)
      (zwei:barf "In order to update an argument list, the cursor must be in a Lisp record"))
    (unless (record-allows-arglist-field record)
      (zwei:barf "This is a ~'i~(~A~)~ record, which doesn't take an arglist field."
		 (doc-record-source-type record)))
    (multiple-value-bind (arglist valid)
	(arglist-for-function-record record)
      (add-or-move-to-record-field record record-node 'arglist () T)
      (multiple-value-bind (arglist-node arglist-record-field)
	  (do-zwei-sage-superiors (zwei-node sage-node (zwei:bp-node (zwei:point)))
	    (when (typep zwei-node 'zwei:doc-record-field-structure-node)
	      (return (values zwei-node sage-node))))
	(assert (eq arglist-record-field
		    (doc-record-arglist (directive-superior arglist-record-field))))
	(cond (valid
	       (let ((arglist-contents-list
		       (upgrade-sage-contents-list-for-newthink
			 (make-lambda-list-contents-list arglist)
			 :edited arglist-record-field)))
		 ;; delete old arglist field contents, but leave the field itself. Good luck.
		 (cond ('|---Deletion will cause Point outside interval being displayed|
			(unless (record-field-completely-white arglist-node)
			  ;; Interval has something not whitespace, say so.
			  ;; This is actually a bug but a good message makes it
			  ;; sound like a feature.  Maybe it could be a feature.
			  (zwei:typein-line "The updated arglist is the top one.  You can~@
			  		     compare them before deleting the old one.")))
		       (T (zwei:kill-interval
			    (zwei:forward-char (zwei:node-first-bp arglist-node))
			    (zwei:node-last-bp arglist-node))))
		 (insert-sage-contents-list
		   (zwei:forward-line (zwei:node-first-bp arglist-node))
		   arglist-contents-list))
	       zwei:dis-text)
	      (T ;;Since this correctly does nothing, there's no error here; don't BARF
		 (beep)
		 (zwei:typein-line "~S is not currently defined as a function,~@
	                     so no argument list is available"
		     (doc-record-topic record))
		 zwei:dis-bps))))))

(defun 1record-field-completely-white0 (record-field-node)
  (let ((bp1 record-field-node) (bp2) (in-order-p))
    (zwei:get-interval bp1 bp2 in-order-p)
    (setq bp1 (zwei:end-line bp1))
    (stack-let ((blanks (cons #\return zwei:*blanks*)))
      (zwei:charmap (bp1 bp2 t)
	(unless (member (zwei:charmap-char) blanks :test #'char-equal)
	  (zwei:charmap-return nil))))))

(zwei:defcom 1com-wt-reorder-records0 "Reorder records in the buffer" ()
  (let ((nodes (zwei:node-inferiors zwei:*interval*)))
    (let ((new-order
	    (sys:with-stack-array (new-order (length nodes) :initial-contents nodes)
	      (reorder-sequence:reorder-sequence-via-menu
		new-order :prompt "Reorder records"
		:printer (named-lambda printer (node stream)
			   (multiple-value-bind (title type)
			       (zwei:record-structure-topic-name-and-type
				 (zwei:markup-structure-node-markup-structure node))
			     (dw:with-output-as-presentation
				 (:stream stream :type (type-of node))
			       (format stream "~a (~:(~a~))" title type))))))))
      (if (loop for n1 in nodes			;is new-order same as old order?
		for n2 being the array-elements of new-order
		do
	    (when (not (eq n1 n2))
	      (return nil))
		finally (return t))
	  zwei:dis-none
	  (zwei:mung-node zwei:*interval*)
	  (setf (zwei:node-inferiors zwei:*interval*) (coerce new-order 'list))
	  (zwei:redo-node-links zwei:*interval*)
	  zwei:dis-text))))

(zwei:defcom 1com-wt-move-records-among-buffers0 "Move records among buffers" ()
  (let ((victim-buffers (remove 'zwei:file-markup-buffer
				zwei:*zmacs-buffer-list*
				:test-not (lambda (x y) (typep y x)))))
    (let ((results (reorder-sequence:alter-sequences-via-menu
		     victim-buffers
		     :sequence-key #'zwei:node-inferiors
		     :sequence-printer
		       (sys:named-lambda seq-printer (item stream)
			 (princ item stream))
		     :sequence-column-label "Buffers"
		     :prompt "Move records among buffers"
		     :element-printer
			(named-lambda elt-printer (node stream)
			  (multiple-value-bind (title type)
			      (zwei:record-structure-topic-name-and-type
				(zwei:markup-structure-node-markup-structure node))
			    (dw:with-output-as-presentation
			      (:stream stream :type (type-of node))
			      (filling-output (stream :fill-on-spaces t)
				(format stream "~a (~:(~a~))" title type))))
			  (send stream :increment-cursorpos
				0 (round (send stream :line-height) 2)))
		     ;; Starting the menu at the left of the screen helps
		     ;; widen it when necessary
		     :near-mode '(:point 0 2000)
		     :width :full
		     )))
      ;; Mung all the buffers first in case some want to complain
      (map nil (lambda (buffer new-order)
		 (when (typep new-order 'sequence)
		   (zwei:mung-node buffer)))
	   victim-buffers results)
      ;;--- should do all of this with all the buffers locked
      (flet ((fix-confused-bps (node new-buffer)
	       (zwei:do-lines ((line ignore ignore) (node))
		 (dolist (bp (zwei:line-bp-list line))
		   (let ((bp-buffer (zwei:bp-buffer-internal bp)))
		     (when (and bp-buffer (not (eql bp-buffer new-buffer)))
		       (setf (zwei:bp-buffer-internal bp) new-buffer)))))))
	(map nil
	     (lambda (buffer new-order)
	       (when (typep new-order 'sequence)
		 ;; When moving into an empty buffer we have to "sever" the first
		 ;; and last lines (so that they aren't simply connected by line-next/previous
		 ;; links) in order for redisplay to work.
		 (zwei:sever-first-and-last-lines buffer)
		 (let ((list-of-nodes (coerce new-order 'list)))
		   (dolist (node list-of-nodes)
		     ;; First we have to move any BPs out of nodes that have been moved
		     ;; to new buffers.
		     (let ((old-buffer (zwei:node-superior node)))
		       (unless (eql buffer old-buffer)
			 (zwei:move-nonboundary-bps-of-node-to
			   node (zwei:node-first-bp old-buffer))))
		     ;; Move node into new buffer
		     (setf (zwei:node-superior node) buffer)
		     ;; Reset the buffer of any remaining bps
		     (fix-confused-bps node buffer)
		     ;; Fix the sage record structure
		     (let ((record (markup-structure-node-markup-structure node)))
		       (when (typep record 'doc-record)
			 ;; Bash file-related fields to "just created" state
			 ;; Assume that this gets filled in on write?
			 (setf (doc-record-source-file record) nil)
			 (setf (doc-record-disk-location record)
			       (list (list (send-if-handles buffer :pathname)
					   '|Undetermined SAB location|
					   '|Undetermined SAB location|))))))
		   ;; Update the buffer's node list
		   (setf (zwei:node-inferiors buffer) list-of-nodes))
		 (zwei:redo-node-links buffer)))
	     victim-buffers results))))
  zwei:dis-all)

;;; Reference commands

(define-presentation-type reference-type ()
   :abbreviation-for `((member ,@*reference-views*)
		       :description "a view for a link"))

;;; Everyone who wants to insert a reference should use this.
;;; If you don't pass in a record-group or reference type, the user will be
;;; prompted for them.
(defun 1insert-reference-at-point0 (&key record-group view)
  (zwei:assure-inside-record
    () "The cursor must be inside a record before a link can be inserted.")
  (when (null record-group)
    (setq record-group (zwei:typein-line-accept-record-group
			 :default (collected-references-recently-added
				    *collected-references*))))
  (when (null view)
    (setq view (zwei:typein-line-accept 'reference-type :default 'include :prompt "View")))
  (multiple-value-bind (new-view new-field)
      (canonicalize-view-and-field view)

    (let ((crossreference-appearance nil))
      (when (eq new-view 'crossreference)
	(setq crossreference-appearance
	      (zwei:typein-line-accept 'crossreference-appearance-template
				       :prompt "Appearance for this crossreference"
				       :default 'see)))
      (splice-sage-structure-at-point
	'sage-reference
	:record-group record-group
	:view new-view
	:appearance crossreference-appearance
	:booleans (when crossreference-appearance
		    (crossreference-appearance-default-booleans crossreference-appearance))
	:field new-field)))

  ;; Install this record so that callees immediately know that the link has been added.
  (let* ((containing-record-node (zwei:find-containing-record))
	 (containing-record (zwei:markup-structure-node-markup-structure
			      containing-record-node)))
    (install-edited-record-if-necessary (doc-record-record-group containing-record)))

  ;;--- Why do I have to do this explicitly?
  (zwei:must-redisplay zwei:*window* zwei:dis-text)
  zwei:dis-text)

;;; Try to unravel the mess about what goes in the view slot and what
;;; goes in the field slot. (York)
;;; (JW 8/87) Use the global variable the "knows" what the views are
;;; so that it can be extended more easily.  [I wonder what the second
;;; returned value is supposed to be for?]
(defun 1canonicalize-view-and-field0 (view)
;;; The following would be the right approach but topic & contents are still
;;; being treated elsewhere as fields rather than as views in their own right.
;;;  (cond
;;;    ((member view *reference-views*)
;;;     (values view nil))
  (when (view-is-crossreference-p view) (setq view 'crossreference))
    ;;This arm of the cond is for handling special cases, synonyms, etc.
  (ecase view
    ;; Have to say view=nil when you mean view=include
    ;;--- someone should change the formatter to understand view=include
    ((include expand nil) (values nil nil))
    ((crossref crossreference) (values 'crossreference nil))
    (precis (values 'precis nil))
    ;;--- add other special cases here
    ((contents) (values nil '(contents)))
    (topic (values nil '(topic)))
    ))

;;; Essentially a dummy command, since mouse clicks will end-around it.
(zwei:defcom 1com-wt-create-link0 "Add a link to another record at point." (zwei:nm)
  (insert-reference-at-point))

;;; Four translators to create references of the common types:

;;; An include reference (via mouse-left)
(zwei:define-presentation-to-editor-command-translator create-include-reference
  (editor-command "Add an include link to another record at point." *wt-comtab*
		  :gesture :left
		  :priority 2			;win over standard click-left
		  :tester ((command) (eq command 'com-wt-create-link)))
  (ignore)
  '(insert-reference-at-point :view include))

;;; A contents-only include reference (via the mouse-right menu)
(zwei:define-presentation-to-editor-command-translator create-contents-only-include-reference
  (editor-command "Add a contents-only include link to another record at point." *wt-comtab*
		  :gesture nil
		  :tester ((command) (eq (first command) 'com-wt-create-link)))
  (ignore)
  '(insert-reference-at-point :view contents))

;;; A cross-reference (via mouse-middle)
(zwei:define-presentation-to-editor-command-translator create-cross-reference
  (editor-command "Add a cross-reference link to another record at point." *wt-comtab*
		  ;; This looks OK in the mouse doc line, combined with mouse-left
		  :documentation "A cross-reference"
		  :gesture :middle
		  :tester ((command) (eq (first command) 'com-wt-create-link)))
  (ignore)
  '(insert-reference-at-point :view crossreference))

;;; A title-only cross-reference (via the menu)
(zwei:define-presentation-to-editor-command-translator create-title-only-cross-reference
  (editor-command "Add a title-only cross-reference link to another record at point." *wt-comtab*
		  :gesture nil
		  :tester ((command) (eq (first command) 'com-wt-create-link)))
  (ignore)
  '(insert-reference-at-point :view topic))

;;; Replace the standard mouse-right menu on the Create Reference menu item
(zwei:define-presentation-to-editor-command-translator reference-menu
  (editor-command "Add a link to another record at point." *wt-comtab*
		  :gesture :right
		  :priority 2			;win over standard click-left
		  :documentation "Menu of link views"
		  :do-not-compose t
		  :tester ((command) (eq (first command) 'com-wt-create-link)))
						       (ignore)
  (let ((ref-type (dw:menu-choose *reference-views* :prompt "Select link view")))
    (when ref-type
      `(insert-reference-at-point :view ,ref-type))))

;;; Edit the attributes of a reference.
(defun 1edit-sage-reference-node0 (node)
  (let ((reference (zwei:markup-structure-node-markup-structure node)))
    (let ((record-group (sage-reference-record-group reference))
	  (decoded-view (sage-reference-decode-view reference))
	  (appearance (sage-reference-appearance reference))
	  (booleans (sage-reference-booleans reference))
	  (previous-appearance (sage-reference-appearance reference))
	  new-record-group new-view new-appearance new-booleans)
      (zwei:with-typeout-window-state
	(let ((stream *standard-output*))
	  (fresh-line stream)
	  (with-character-style ('(:swiss :italic nil) stream :bind-line-height t)
	    (with-underlining (stream) (format stream "Attributes for this link:"))
	    (fresh-line stream))
	  (with-character-style ('(:fix :roman :normal) stream :bind-line-height t)
	  (dw:accepting-values (stream :resynchronize-every-pass t)
	    (setq new-view (accept 'reference-type
				   :stream stream
				   :default decoded-view))
	    (when (eq new-view 'crossreference)
	      (unless appearance (setq appearance 'See))
	      (setq new-appearance
		    (accept 'crossreference-appearance-template
			    :stream stream :default appearance))
	      (when (neq new-appearance previous-appearance)
		(setq previous-appearance new-appearance)
		(setq booleans (crossreference-appearance-default-booleans new-appearance)))
	      (when (crossreference-appearance-booleans-for-accept new-appearance)	;cache?
		(setq new-booleans
		      (accept `((dw::alist-subset :alist
						  ,(crossreference-appearance-booleans-for-accept
						     new-appearance)))
			      :stream stream :default booleans
			      :prompt "Options"))))
	    (setq new-record-group
		  (accept 'record-group
			  :stream stream
			  :default record-group
			  :prompt "Topic"))))))
      (unless (and (eq new-record-group record-group)
		   (eq new-view decoded-view)
		   (eq new-appearance appearance)
		   (equal new-booleans booleans))
)
	(zwei:mung-node node)
	(unless (eq new-view decoded-view)
	  (multiple-value-bind (new-view new-field)
	      (canonicalize-view-and-field new-view)
	    (setf (sage-reference-view reference) new-view)
	    (setf (sage-reference-field reference) new-field)))
	(setf (sage-reference-record-group reference) new-record-group)
	(setf (sage-reference-appearance reference) new-appearance)
	(if (and (eq new-view 'crossreference)
		 (crossreference-appearance-booleans-for-accept new-appearance))
	    (setf (sage-reference-booleans reference) new-booleans)
	    (setf (sage-reference-booleans reference) nil))
	(zwei:invalidate-cached-title-string node)
	(zwei:diagram-lines-need-redisplay node))))

(zwei:define-presentation-to-editor-command-translator 1edit-sage-reference
0  (((zwei:reference-structure-node) :format :as-record) "Edit link to record" *wt-comtab*
				 :gesture :modify)
  (node)
  `(edit-sage-reference-node ,node))

(zwei:defcom 1com-wt-edit-link0 "Edit the attributes of a link." ()
  (let* ((point (zwei:point))
	 (node (zwei:bp-node point)))
    (unless (typep node 'zwei:reference-structure-node)
      (zwei:barf "The cursor must be on the link to be edited"))
    (edit-sage-reference-node node))
  zwei:dis-text)

(zwei:defcom 1com-wt-show-links-from-record0 "Shows the record links from this record to others.
It lists all the links from this record to any others,
grouping them by the different types of links." ()
  (let* ((record-group (zwei:typein-line-accept-record-group
			 :default (record-group-at-point ())))
	 (record (or (first (record-group-edited-records record-group))
		     ;; ---Needs to warn if the callee sets differ
		     (find-record-for-lookup record-group))))
    (if (null record)
	(format T "~&Can't find record somehow, for ~\\presentation\\---" record-group)
	(show-record-outward-pointers record)))
  zwei:dis-none)

(defmethod 1(fix-up-bogus-crossref-callees doc-record)0 ()
  (let ((crossref-callees (assoc 'crossref callees :test #'string-equal)))
    (when crossref-callees
      (loop for callee-rg in (rest crossref-callees)
	    do
	(remove-record-as-caller callee-rg self (first crossref-callees))
	(add-record-as-caller callee-rg self 'crossreference))
      (setq callees (delete crossref-callees callees)))))

(defun 1show-record-outward-pointers0 (record &optional recursion)
  (fix-up-bogus-crossref-callees record)
  (let ((callees (doc-record-callees record)))
    (cond ((null callees)
	   (if recursion
	       (format T "~&No links from \"~\\presentation\\\" to any other records."
		       recursion)
	       (let* ((record-group (doc-record-record-group record))
		      (installed-record (find-record-for-lookup record-group))
		      (edited-record (first (record-group-edited-records record-group))))
		 (cond ((eql record installed-record)
			(show-record-outward-pointers edited-record record))
		       ((eql record edited-record)
			(show-record-outward-pointers installed-record record))
		       (T (format T "~&No links from \"~\\presentation\\\" to any other records."
				  record))))))
	  (T
	   (format T "~&~D link~:p from  \"~\\presentation\\\" to other records:"
		   (loop for (nil . callees) in callees
			 sum (length callees))
		   record)
	   (loop for (call-type . callee-record-groups) in callees
		 do
	     (format T "~&~:(~a~)~:[ link~;~]~P to:"
		     (decode-view-1 call-type)
		     (view-is-crossreference-p call-type) (length callee-record-groups))
	     (dolist (callee-record-group callee-record-groups)
	       (format T "~&    ~\\presentation\\" callee-record-group)))))))

(defmacro 1map-over-runs-of-records0 (list-of-records (iteration-variable) &body body)
  `(map-over-runs-of-records-1 ,list-of-records
			       (dw:named-continuation map-over-runs-of-records
						      (,iteration-variable)
				 ,@body)))

(defun 1map-over-runs-of-records0-1 (list-of-records continuation &aux run)
  (declare (sys:downward-funarg continuation))
  (loop until (null list-of-records)
	do
    (multiple-value-setq (run list-of-records)
      (find-record-run list-of-records))
    (when run (funcall continuation run))))

(defun 1find-record-run0 (list-of-records)
  (declare (values run rest))
  (cond ((null (cdr list-of-records))
	 (values list-of-records nil))
	(t
	 (loop with first-rg = (doc-record-record-group (first list-of-records))
	       for rest on (rest list-of-records)
	       when (neq (doc-record-record-group (first rest)) first-rg)
		 return (values (cons (first list-of-records) rgs) rest)
	       collect (first rest) into rgs
	       finally (return list-of-records)))))

(zwei:defcom 1com-wt-show-links-to-record0 "Shows which other records have links to this record." ()
  (show-record-group-inward-pointers
    (zwei:typein-line-accept-record-group
      :prompt "Record"
      :default (record-group-at-point ())))
  zwei:dis-none)

(defmethod 1(record-group-callers-after-installing-edited-records-if-necessary record-group)0 ()
  (sys:with-data-stack
    (let ((already-done (make-hash-table :area :stack)))
      (macrolet ((already-done? (rg)
		   `(gethash ,rg already-done)))
	(loop for (nil . caller-records) in callers
	      do
	  (loop for caller-record in caller-records
		do
	    (let ((rg (doc-record-record-group caller-record)))
	      (unless (already-done? rg)
		(install-edited-record-if-necessary rg)
		(setf (already-done? rg) t))))))))
  (verify-record-group-callers self)
  (fix-up-bogus-crossref-callers self)
  callers)

(defmethod 1(verify-record-group-callers record-group)0 ()
  (flet ((record-is-caller-p (record)
	   (let ((rg (doc-record-record-group record)))
	     (and (record-group-contains-record-p rg record)	;; how can it not?
		  ;; if the record group is killed we only want to show this record
		  ;; if it happens to be the published record.
		  (or (not (record-group-killed rg))
		      (doc-record-published record))
		  (loop for (nil . callee-rgs) in (doc-record-callees record)
			thereis (member self callee-rgs)))))
	 (db-format (format-string &rest format-args)
	   (when *debugging-sage*
	     (apply #'format t format-string format-args))))
    (loop for (call-type . caller-records) in callers
	  do
      (dolist (record caller-records)
	(unless (record-is-caller-p record)
	  (db-format "~&Removing bogus ~A link to ~A (~A)." call-type self record)
	  (remove-record-as-caller self record call-type))))))

(defmethod 1(fix-up-bogus-crossref-callers record-group)0 ()
  (let ((crossref-callers (assoc 'crossref callers :test #'string-equal)))
    (when crossref-callers
      (loop for caller-record in (rest crossref-callers)
	    do
	(remove-record-as-caller self caller-record (first crossref-callers))
	(add-record-as-caller self caller-record 'crossreference))
      (setq callers (delete crossref-callers callers)))))

(defun 1show-record-group-inward-pointers0 (record-group)
  ;; callers are records, not record-groups
  (let ((callers (record-group-callers-after-installing-edited-records-if-necessary
		   record-group)))
    (cond ((null callers)
	   (format T "~&No links to \"~\\presentation\\\" from other records."
		   record-group))
	  (T
	   (let ((count
		   (loop for (call-type . caller-records) in callers
			 sum (let ((x 0))
			       (map-over-runs-of-records caller-records (ignore) (incf x))
			       x))))
	     (format T "~&~D link~:p to \"~\\presentation\\\" from other records:"
		     count
		     record-group))
	   ;;; --- should kludge topic links into the crossreference list
	   (loop for (call-type . caller-records) in callers
		 do
	     ;; first, sort callers alphabetically
	     (setq caller-records (sort caller-records #'string-lessp
					:key (lambda (r)
					       (record-group-topic-completion
						 (doc-record-record-group r)))))
	     (format T "~&As ~:(~a~):" (decode-view-1 call-type))
	     (map-over-runs-of-records caller-records (set)
	       (terpri)
	       (present-set-of-record-links (doc-record-record-group (first set)) set)))))))

(defmethod 1(present-set-of-record-links record-group)0 (set
							&key
							(stream *standard-output*)
							(indentation 5))
  ;; cases:
  ;; a) all records, edited or otherwise, point inward to this guy.
  ;;    If that's true, just print the name
  ;; b) one or more edited records contain link but published doesn't
  ;; c) published does, edited doesn't
  ;; d) published does, some edited do, some edited don't.
  (present-linked-record (first set) :stream stream :indentation indentation)
  (cond ((inferiors-completely-accounted-for self set)
	 nil)
	((and published-record
	      (member published-record set))
	 (when installed-record
	   (unless (member installed-record set)
	     (format stream " (published version only)"))))
	(t (format stream " (edited versions only)"))))

(defmethod 1(inferiors-completely-accounted-for record-group)0 (set)
  (and (or (null published-record) (member published-record set))
       (or (null edited-records)
	   (loop for record in edited-records
		 always (member record set)))))

(defmethod 1(present-linked-record doc-record)0 (&key (stream *standard-output*) (indentation 5))
  (format stream "~V@T~\\presentation\\" indentation record-group))

;;; Recursive graph of structural callees.
(zwei:defcom 1com-wt-graph-links-from-record0 "Graphs the table of contents starting from a particular record.
Currently this shows only the structural links from a record.
It does not show any of the other kinds of link views, like
crossreferences or other views.

This is a limitation of the current implementation." ()
  (let* ((record-group (zwei:typein-line-accept-record-group
			 :prompt "Record name"))
	 (record (or (2 0 (NIL 0) (NIL NIL :SMALL) "TVFONT");0(first (record-group-edited-records record-group))
		     ;; ---Needs to warn if the callee sets differ
		     (find-record-for-lookup record-group))))
    (if (null record)
	(format t "~&Can't find record somehow, for ~\\presentation\\---" record-group)
	(graph-record-outward-pointers record)))
  zwei:dis-none)

;;; This function, which is unreferenced and apparently only a prototype, causes
;;; compiler and linker warnings, so I'm commenting it out for now.  -- DLA 10/05/88 17:13:33
;;; see next definition
#+ignore
(defun 1broken-graph-record-outward-pointers0 (record &optional recursion)
  (cond ((null (doc-record-callees record))
	 (if recursion
	     (format T "~&No links from \"~\\presentation\\\" to other records."
		     recursion)
	     (let* ((record-group (doc-record-record-group record))
		    (installed-record (find-record-for-lookup record-group))
		    (edited-record (first (record-group-edited-records record-group))))
	       (cond ((eql record installed-record)
		      (graph-record-outward-pointers edited-record record))
		     ((eql record edited-record)
		      (graph-record-outward-pointers installed-record record))
		     (T (format T "~&No links from  \"~\\presentation\\\" to other records."
				record))))))
	  (T
	   (flet ((record-from-thing (rec-thing)
		   ;; rec-thing can be a record or a cons of a record and call type
		    (let ((record rec-thing)
			  (call-type 'expand))
		      (when (consp rec-thing)
			(setq record (car rec-thing)
			      call-type (cdr rec-thing)))
		      (values record call-type))))
	   (with-character-style ('(:swiss :roman :small))
	     (format-graph-from-root
	       record
	       #'(named-lambda record-node-printer (rec-thing stream)
		   (multiple-value-bind (record call-type)
		       (record-from-thing rec-thing)
		     (when record
		       (let ((record-group (doc-record-record-group record)))
			 (case call-type
			   (expand 
			     (surrounding-output-with-border (stream)
			       (present record-group (type-of record-group)
					:stream stream)))
			   (crossref
			     (present record-group (type-of record-group)
				      :stream stream)))))))
	       #'(named-lambda record-node-inferiors-producer (rec-thing)
		   (multiple-value-bind (record call-type)
		       (record-from-thing rec-thing)
		     (when record
		       ;; only return callees of an expand reference
		       (when (eq call-type 'expand)
			 ;; returns a list of ((record1 . call-type1) (record2 . call-type2)...)
			 (let* ((callees (doc-record-callees record))
				(result (apply #'append
					       (loop for (call-type . callee-record-groups) in callees
						     collect
						       (loop for callee in callee-record-groups
							     ;; ---which record?
							     collect
							       (cons (find-record-for-lookup callee)
								     call-type))))))
			   (print result)
			   result)))))
	       :orientation :horizontal
	       :balance-evenly nil
	       :border nil))))))

;;; temporary simplified version.
(defun 1graph-record-outward-pointers0 (record)
  (fresh-line)
  (let ((callees (doc-record-callees record)))
    (cond ((null (find 'expand callees :key 'car))
	   (format T "~&No links from \"~\\presentation\\\" to other records."
		   (doc-record-record-group record)))
	  (t
	   (with-character-style ('(:swiss :roman :very-small))
	     (format-graph-from-root
	       record
	       #'(named-lambda record-node-printer (rec-thing stream)
		   (when rec-thing
		     (let ((record-group (doc-record-record-group rec-thing)))
		       (present record-group (type-of record-group)
				:stream stream))))
	       #'(named-lambda record-node-inferiors-producer (rec-thing)
		   (when rec-thing
		     (let* ((callees (doc-record-callees rec-thing))
			    (result (find 'expand callees :key 'car)))
		       ;; which record to use?
		       (map 'list #'find-record-for-lookup
			    (rest result)))))
	       :orientation :horizontal
	       :balance-evenly nil
	       :border nil
	       :within-column-spacing 3))))))

(zwei:defcom 1com-wt-collect-record-name0 "Collect record's name as target for links
Add to the Collected Record Names window pane, in which it will be easy to point to." ()
  (let ((record-group (zwei:typein-line-accept-record-group
			;;---This disallows refs to records that haven't been created yet.
			;; Perhaps that's ok?
			:prompt "Topic"
			:default (record-group-at-point ()))))
    (collect-reference-and-redisplay record-group))
  zwei:dis-none)

(zwei:defcom 1com-wt-collect-all-record-names0 "Collect all record names in the current buffer
and adds them to the Collected Record Names window pane, in which they will be easy to point to." ()
  (map-over-rgs-in-buffer zwei:*interval* #'(lambda (rg) (collect-reference rg)))
  (apply-in-concordia #'zwei:barf #'cause-redisplay-of-references-pane)
  zwei:dis-none)

(defun 1collect-reference-and-redisplay0 (record-group)
  (collect-reference record-group)
  (apply-in-concordia #'zwei:barf #'cause-redisplay-of-references-pane))

(zwei:define-presentation-to-editor-command-translator 1remove-collected-record-name
0  (record-group
    "Remove collected record name"
    *wt-comtab*
    :gesture :shift-middle
    :tester ((ignore &key window)
	     ;; This translator only applies when you click on a
	     ;; record group appearing in the references pane
	     (let ((sup (send window :superior)))
	       (and (typep sup 'dw:program-frame)
		    (eq (send sup :pane-name window) 'references-pane)))))
  (record-group)
  `(remove-collected-record-name ,record-group))

(defun 1remove-collected-record-name0 (record-group)
  (uncollect-reference record-group)
  (cause-redisplay-of-references-pane))

(zwei:defcom 1com-wt-clear-record-name-collection0 "Clear the Collected Record Names pane" ()
  (clear-collected-references)
  (apply-in-concordia #'zwei:barf #'cause-redisplay-of-references-pane)
  zwei:dis-none)

(3 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");; This command is obsolete.  Users should use Show Table of Contents (mcw 11/88)
0(zwei:defcom 1com-wt-show-outline0 "Show outline of a topic" ()
  (let ((record-group (zwei:typein-line-accept-record-group
			:default (record-group-at-point ()))))
    (let ((toc-list				;the whole callee tree, with self at top
	    (list `(,record-group expand ,(table-of-contents record-group)))))
      (let ((crossrefs-too-p ())
	    (source-file-too-p ()))
	(toc-really-internal toc-list crossrefs-too-p source-file-too-p
			     (and zwei:*numeric-arg-p* zwei:*numeric-arg*)))))
  zwei:dis-none)

#|| 
2;;; Code for finding references to record-groups with bogus unique-ids.
;;; ---This should not be shipped as part of the product ---
;;; It is just for SCRC writers during the transition to new Writer Tools.

(defun find-next-bogus-reference (bp)
  (loop for line = (zwei:bp-line bp) then (zwei:line-next-in-buffer line)
	while line
	do
    (let ((node (zwei:line-node line)))
      (when (typep node 'zwei:reference-structure-node)
	(let* ((reference (zwei:markup-structure-node-markup-structure node))
	       (record-group (sage-reference-record-group reference))
	       (uid (record-group-unique-id record-group)))
	  (when (eql (aref uid 0) #\?)
	    (zwei:typein-line "Found link to bogus record group \"~A\"" record-group)
	    (zwei:move-point (zwei:node-first-bp node))
	    (return-from find-next-bogus-reference reference))))))
  nil)

(zwei:defcom com-find-next-bogus-link
	     "Move point to the next bogus link in the buffer
Finds next link to a record-group with a bogus unique-id, which
would cause problems when writing out the sab file.
---This will not be shipped as part of the product; it is just for 
SCRC writers during the transition to new Writer Tools" 
	     ()
  (let ((found-one (find-next-bogus-reference (zwei:point))))
    (cond (found-one
	   (zwei:must-redisplay zwei:*window* zwei:dis-bps)
	   (zwei:redisplay zwei:*window* :point nil nil T)
	   (when (y-or-n-p "Convert it into a comment? ")
	     (zwei:com-delete-forward)
	     (insert-sage-contents-list
	       (zwei:point)
	       (upgrade-sage-contents-list-for-newthink
		 (making-sage-directives ()
		   (in-environment (() commentary)
		     (let ((record-group (sage-reference-record-group found-one)))
		       (format T "Link to ~(~a~) \"~a\", view=~a, field=~a"
			       (record-group-type record-group)
			       (record-group-topic record-group)
			       (sage-reference-view found-one)
			       (sage-reference-field found-one)))))
		 :edited (directive-superior found-one)))
	     (com-wt-forward-environment)
	     (zwei:com-forward))
	   zwei:dis-text)
	  (T (zwei:typein-line "All links look ok")
	     zwei:dis-none))))

(zwei:set-comtab *wt-comtab* nil (zwei:make-command-alist '(com-find-next-bogus-link)))
0||#

(zwei:defcom 1com-wt-sort-links-in-record0 "Sort the links in the current record" ()
  (multiple-value-bind (record-group record record-node)
      (record-group-at-point)
    (macrolet ((do-link-lines-in-record ((line-var) &body body)
		 `(zwei:do-lines-in-interval (record-node ,line-var ignore ignore)
		    (when (typep (zwei:line-diagram ,line-var) 'zwei:reference-diagram-line)
		      ,@body))))
      (stack-let ((links-before-sorting (make-array 256 :fill-pointer 0)))
	(do-link-lines-in-record (line)
	  (let* ((reference-node (zwei:line-node line))
		 (sage-reference
		   (zwei:markup-structure-node-markup-structure reference-node))
		 (link-target (sage-reference-record-group sage-reference))
		 (key (record-group-link-sort-key link-target)))
	    (vector-push-extend (list key sage-reference) links-before-sorting)))
	(let ((record-contents (record-field-contents (doc-record-contents record))))
	  (let ((index 0))
	    (walk-sage-data-replacing
	      record-contents
	      (named-lambda walk-1 (reference)
		(unless (eql reference (second (aref links-before-sorting index)))
		  (zwei:barf "Record too complicated to find all links reliably"))
		(incf index)
		(values)))
	    (unless (= index (length links-before-sorting))
	      (zwei:barf "Record too complicated - failed to find all links")))
	  (stack-let ((links (make-array (length links-before-sorting)
					 :initial-contents links-before-sorting)))
	    (setq links (sort-link-key-sequence links #'first))
	    (cond ((every #'eq links links-before-sorting)
		   (zwei:typein-line "The links are already in order")
		   zwei:dis-none)
		  ((yes-or-no-p "Please confirm sorting links in ~a~@
			     This operation cannot be undone, except by reverting the buffer."
				record-group)
		   (do-link-lines-in-record (line)
		     (zwei:mung-line line)
		     (zwei:mung-node (zwei:line-node line)))
		   (let ((index 0))
		     (walk-sage-data-replacing
		       record-contents
		       (named-lambda walk-2 (reference)
			 (assert (eq reference (second (aref links-before-sorting index))))
			 (values (prog1 (second (aref links index)) (incf index)) T)))
		     (assert (= index (length links))))
		   (let ((index 0))
		     (do-link-lines-in-record (line)
		       (let* ((reference-node (zwei:line-node line))
			      (sage-reference
				(zwei:markup-structure-node-markup-structure
				  reference-node)))
			 (assert (eql (second (aref links-before-sorting index))
				      sage-reference))
			 (setf (zwei:markup-structure-node-markup-structure reference-node)
			       (second (aref links index))))
					      (incf index))
		     (zwei:invalidate-cached-title-strings)
		     (assert (= index (length links))))
		     zwei:dis-all)
		  (t zwei:dis-none))))))))

#|
Concept records sort with just (appropriate-title-rendering xx 'no-formatting).
Lisp symbols sort on pname; consider package when pnames are equal.
Methods and related things sort first on message name, then on flavor, then on packages.
|#

(defmethod 1(record-group-link-sort-key record-group)0 ()
  (cond ((concept-type-p type)
	 (string-append (appropriate-title-rendering self 'no-formatting)
			" " (coerce-record-type type 'print-name)))
	((lisp-object-type-p type)
	 (lisp-topic-link-sort-key topic))
	(T (error "Unrecognized record-group type ~s" type))))

;; This is abstracted so we can adjust to move post-letter chars to sort first
(defun 1sort-link-key-sequence0 (sequence key)
  (setq sequence (sort sequence #'link-sort-key-lessp :key key))
  (let ((first-a-pos nil)
	(past-z-pos nil)
	(length (length sequence)))
    (block scan
      (let ((i 0))
	(domap nil ((elt sequence))
	  (let* ((elt-key (funcall key elt))
		 (ch (char elt-key 0)))
	    (cond ((char-lessp ch #\A)
		   ;; precedes the letters
		   )
		  ((char-greaterp ch #\Z)
		   ;; after the letters
		   (setq past-z-pos i)
		   (return-from scan))
		  (T
		   ;;it's a letter
		   (when (null first-a-pos)
		     (setq first-a-pos i))))
	    (incf i)))))
    (when (and first-a-pos past-z-pos)
      ;; If there are no letters, the pre-letter and post-letters are already in order.
      ;; If there are no post-letters, don't have to shuffle them.
      (let ((tail-length (- length past-z-pos)))
	(stack-let ((tails (make-array tail-length)))
	  ;; save the tail away
	  (replace tails sequence :start2 past-z-pos)
	  ;; shuffle the letter part of sequence toward the end by tail-length
	  (replace sequence sequence
		   :start1 (+ first-a-pos tail-length)
		   :start2 first-a-pos :end2 past-z-pos)
	  ;; move the tail to precede the letters
	  (replace sequence tails :start1 first-a-pos))))
    sequence))

#||
(defun 1test-sort-link-key-sequence0 ()
  (let ((pre-letter '("$$$" "" "&&&"))
	(letter '("B" "aaa" "BBB"))
	(post-letter '("___" "" "\\\\\\")))
    (dolist (do-post-letter '(nil t))
      (dolist (do-letter '(nil t))
	(dolist (do-pre-letter '(nil t))
	  (let ((stuff (append (and do-pre-letter pre-letter)
			       (and do-letter letter)
			       (and do-post-letter post-letter)
			       ;; The () is critical to not trash the compiled code constant.
			       ())))
	    (terpri)
	    (princ stuff)
	    (terpri)
	    (princ (sort-link-key-sequence stuff #'identity))
	    (terpri)))))))
||#

;; This is easy since all the hair was moved into constructing the key
(defun 1link-sort-key-lessp0 (key1 key2) (string-lessp key1 key2))

(defun 1walk-sage-data-replacing0 (contents-list function)
  (declare (values new-list actually-changed))
  (let ((changed? ()))
    (mapl (lambda (tail)
	    (etypecase (first tail)
	      (sage-directive
		(multiple-value-bind (replacement do-replacement)
		    (walk-sage-data-replacing-1 (first tail) function)
		  (when do-replacement
		    (setq changed? T)
		    (setf (first tail) replacement))))
	      ((or string number symbol) )))
	  contents-list)
    (values contents-list changed?)))

(defgeneric 1walk-sage-data-replacing-10 (sage-directive function)
  (:method (sage-reference)
   (funcall function self))
  (:method (sage-envr)
   (multiple-value-bind (new changed?) (walk-sage-data-replacing contents-list function)
     (when changed? (setq contents-list new))
     (values self changed?)))
  (:method (sage-directive :default)
   (ignore function)
   (values self nil)))

(zwei:defcom 1com-wt-sort-records0 "Sort records in the buffer" ()
  (let* ((nodes (zwei:node-inferiors zwei:*interval*))
	 (number-of-nodes (length nodes)))
    (stack-let ((to-sort (make-array number-of-nodes :fill-pointer 0))
		(not-to-sort (make-array number-of-nodes)))
      (dolist (node nodes)
	(let* ((record (zwei:markup-structure-node-markup-structure node))
	       (record-group (doc-record-record-group record))
	       (key (record-group-link-sort-key record-group)))
	  (vector-push-extend (list key node) to-sort)))
      (replace not-to-sort to-sort)
      (setq to-sort (sort-link-key-sequence to-sort #'first))
      (cond ((every #'eq to-sort not-to-sort)
	     (zwei:typein-line "The records in the buffer are already in order")
	     zwei:dis-none)
	    (T
	     (zwei:mung-node zwei:*interval*)
	     (setf (zwei:node-inferiors zwei:*interval*) (map 'list #'second to-sort))
	     (zwei:redo-node-links zwei:*interval*)
	     zwei:dis-text)))))

(zwei:defcom 1com-wt-show-modification-history
0	     "Show who modified the current record and when"
	     ()
  (let ((record (record-at-point)))
    (let ((mod-history (doc-record-modification-history record)))
      (format T "~&Modification history of ~a in ~a~%"
	      (doc-record-record-group record)
	      zwei:*interval*)
      (formatting-table ()
	(dolist (stuff mod-history)
	  (destructuring-bind (version-number name date) stuff
	    (formatting-row ()
	      (formatting-cell () (princ version-number))
	      (formatting-cell () (princ name))
	      (formatting-cell () (time:print-universal-time date))))))))
  zwei:dis-none)

(defflavor 1index-entry-collection
0	((records))
	(index-database)
  :writable-instance-variables)

(zwei:defcom 1com-wt-collect-index-entries-of-topic0 "Collect index entries for a doc topic
Accepts topic name.  Examines the topic and all its expanded records, recursively,
collecting all index entries.  Index entries come from record titles, keywords
fields, and explicit indexing commands.  Puts the generated index into a buffer named
*Index-Entries*, and sets up split screen mode with *Index-3n0* in the top window, and the
previous buffer in the bottom window.

See also Collect Index Entries of {Buffer, Tag Table}.
" ()
  (let ((record-group (zwei:typein-line-accept-record-group
			:default (record-group-at-point ()))))
    (let ((index-entry-collection (make-instance 'index-entry-collection)))
      (with-ambient-counters
	(set-ambient-value 'index-database index-entry-collection 'index-database)
	(do-style-command-args '((indexstyle multilevel)) nil)
	(find-page-counter)
	(tv:noting-progress ("Scanning records in topic")
	  (labels ((doit (record-group)
		     (let ((record (find-record-for-lookup record-group)))
		       (unless (member record (index-entry-collection-records index-entry-collection))
			 (collect-index-entries-for-record record)
			 (push record (index-entry-collection-records index-entry-collection))
			 (dolist (alist (doc-record-callees record))
			   (case (first alist)
			     ((crossref crossreference topic)
			      )
			     ((expand contents)
			      (mapc #'doit (rest alist)))
			     (otherwise
			       (if (member (first alist) '("crossref")
					   :test #'string-equal)
				   ()
				   (error "What call type is ~s" (first alist))))
			     ))))))
	    (doit record-group))))
      (setup-and-display-index-buffer index-entry-collection))))


(zwei:defcom 1com-wt-collect-index-entries-of-buffer
0	     "Collect index entries for all doc records in the buffer.
Examines all records in the buffer, collecting all index entries.  Index entries 
come from record titles, keywords fields, and explicit indexing commands.  Puts 
the generated index into a buffer named *Index-Entries*, and sets up split screen mode 
with *Index-Entries* in the top window, and the previous buffer in the bottom window.

See also Collect Index Entries of {Tag Table, Topic}.
" ()
  (let ((collection (make-instance 'index-entry-collection)))
    (collect-index-entries-of-buffer collection zwei:*interval*)
    (setup-and-display-index-buffer collection)))

(zwei:defcom 1com-wt-collect-index-entries-of-tag-table
0	     "Collect index entries for all doc records in the tag table.
Examines all records in all .sab files in the tag table, collecting all 
index entries.  Index entries come from record titles, keywords fields, 
and explicit indexing commands.  Puts the generated index into a buffer named
*Index-Entries*, and sets up split screen mode with *Index-Entries* in the top window, 
and the previous buffer in the bottom window.

See also Collect Index Entries of {Buffer, Topic}.
" ()
  (let ((collection (make-instance 'index-entry-collection)))
    (catch 'zwei:zwei-command-loop
      (let ((tag-buffer (zwei:select-tag-table nil)))
	(send tag-buffer :restart)
	(loop for f = (send tag-buffer :next-file nil nil)
	      do
	  (etypecase f
	    (null (loop-finish))
	    (zwei:file-markup-buffer
	      (collect-index-entries-of-buffer collection f))
	    (zwei:file-buffer )
	    ))))
    (setup-and-display-index-buffer collection)))

(defun 1collect-index-entries-of-buffer0 (index-entry-collection buffer)
  (assert (typep buffer 'zwei:file-markup-buffer))
  (with-ambient-counters
    (set-ambient-value 'index-database index-entry-collection 'index-database)
    (do-style-command-args '((indexstyle multilevel)) nil)
    (find-page-counter)
    (dolist (inf (zwei:node-inferiors buffer))
      (when (typep inf 'zwei:record-structure-node)
	(let ((record (zwei:markup-structure-node-markup-structure inf)))
	  (unless (member record (index-entry-collection-records index-entry-collection))
	    (collect-index-entries-for-record record)
	    (push record (index-entry-collection-records index-entry-collection))))))))

(defun 1make-record-entry-exit-gboxes0 (record)
  (declare (values entry-gbox exit-gbox))
  (let ((entry-gbox (make-record-entry-gbox nil record nil))
	(exit-gbox (make-record-exit-gbox nil)))
    (send entry-gbox :set-exit-gbox exit-gbox)
    (send exit-gbox :set-entry-gbox entry-gbox)
    (values entry-gbox exit-gbox)))

(defun 1collect-index-entries-for-record0 (record)
  (let ((gboxes
	  (let ((directives
		  (nconc
		    (index-commands-from-title record)
		    (index-commands-from-keyword-entries record)
		    (nreverse
		      (collect-index-commands-in-contents-list
			(record-field-contents
			  (doc-record-contents record))
			())))))
	    (with-temp-list-head (head)
	      (let ((predecessor head))
		(multiple-value-bind (entry-gbox exit-gbox)
		    (make-record-entry-exit-gboxes record)
		  (setq predecessor (splice-boxes-after predecessor entry-gbox))
		  (setq predecessor (splice-contents-list predecessor nil directives))
		  (setq predecessor (splice-boxes-after predecessor exit-gbox))
		  ))))))
    (do-box-successors (gbox gboxes)
      (render-for-index gbox))))

(defgeneric 1collect-index-commands-in-contents-list0 (sage-directive list-so-far)
  (:function
    (etypecase sage-directive
      (cons
	(dolist (x sage-directive)
	  (setq list-so-far (collect-index-commands-in-contents-list x list-so-far)))
	list-so-far)
      (null list-so-far)
      (sage-directive
	(funcall (flavor:generic collect-index-commands-in-contents-list)
		 sage-directive list-so-far))))
  (:method (sage-directive :default)
   (ignore self)
   list-so-far)
  (:method (sage-envr)
   (collect-index-commands-in-contents-list contents-list list-so-far))
  (:method (sage-command)
   (if (member command-name '(index indexprimary indexsecondary indexentry))
       (cons self list-so-far)
       list-so-far))
  (:method (editable-sage-command)
   (if (member command-name '(index indexprimary indexsecondary indexentry))
       (let ((sage-command (clone-contents-internal self)))	;editor world  sage world
	 (cons sage-command list-so-far))
       list-so-far)))

(defun 1setup-and-display-index-buffer0 (index-entry-collection)
  (let ((index-buffer (zwei:find-buffer-named "*Index-Entries*" T)))
    (zwei:delete-interval index-buffer)
    (zwei:setup-compiler-warnings-windows
      index-buffer
      (zwei:node-first-bp index-buffer)
      (zwei:node-first-bp index-buffer))
    (let* ((index-window (find index-buffer zwei:*window-list* :key #'zwei:window-interval))
	   (other-window (find-if (lambda (window)
				    (and (neq window zwei:*mini-buffer-window*)
					 (neq window index-window)))
				  zwei:*window-list*)))
      (let ((directives
	      (dynamic-flet ((symbol-for-editor-buffer (name &key (error-p T))
			      (if (eq name 'literal-space)
				  #\space
				  (continue name :error-p error-p))))
		(upgrade-sage-contents-list-for-newthink 
		  (strip-out-page-counters
		    (directives-for-index index-entry-collection))
		  :edited))))
	(assert (and (consp directives)
		     (= 1 (length directives))
		     (typep (first directives) 'sage-envr)))
	(setq directives (send (first directives) :contents-list))
	(insert-index-entries-into-buffer directives index-window)
	(zwei:move-window-point index-window (zwei:node-first-bp index-buffer)))
      (zwei:make-window-current other-window)
      zwei:dis-all)))

(defun 1insert-index-entries-into-buffer0 (directives index-window)
  (let (p-start-bp p-type p-object p-options)
    (tv:dolist-noting-progress (dir directives "Inserting index entries")
      (typecase dir
	(sage-text-structure
	  (zwei:insert-interval-moving (zwei:window-point index-window)
				       (sage-text-structure-interval dir)))
	(string
	  (zwei:insert-moving (zwei:window-point index-window) dir))
	(sage-command
	  (case (send dir :command-name)
	    (presentation
	      (with-sage-command-args (presentation dir)
		(ecase kind
		  (start
		    (setq p-start-bp
			    (zwei:copy-bp (zwei:window-point index-window))
			  p-type presentation-type
			  p-object presentation-object
			  p-options presentation-options))
		  (end
		    (let* ((p-end-bp
			     (let ((ebp (zwei:copy-bp (zwei:window-point index-window))))
			       (let ((start-line (zwei:bp-line p-start-bp)))
				 (if (eq (zwei:bp-line ebp) start-line)
				     ebp
				     (zwei:create-bp start-line
						     (zwei:line-length start-line))))))
			   (p-node (apply
				     #'make-instance
				     'zwei:presentation-node
				     :start-bp p-start-bp
				     :end-bp p-end-bp
				     :superior nil
				     :object p-object
				     :type p-type
				     :allow-other-keys t
				     p-options)))
		      (push (list (zwei:bp-index p-start-bp)
				  (zwei:bp-index p-end-bp)
				  p-node)
			    (zwei:line-presentation-nodes
			      (zwei:bp-line p-end-bp))))))))
	    (otherwise )))
      (otherwise )))))

(defgeneric 1strip-out-page-counters0 (sage-directive)
  (:function
    (typecase sage-directive
      (cons (delete-if
	      (lambda (e)
		(and (typep e 'sage-command)
		     (member (send e :command-name)
			     '(collect-right-flushing counter-value-as-number))))
	      (mapc #'strip-out-page-counters sage-directive)))
      (sage-directive (funcall (flavor:generic strip-out-page-counters) sage-directive))
      (otherwise sage-directive)))
  (:method (sage-directive :default)
   self)
  (:method (sage-envr)
   (setq contents-list (strip-out-page-counters contents-list))
   self))


;;; Orphans
;;; 2 Tools needed.
;;;  1) Find records that no one points to
;;;  2) Find "empty" records that are pointed to.
;;;  3) Find record groups that have no published record.

(defmethod 1(record-contents-empty-p doc-record)0 ()
  (and (doc-record-filled self)
       (if (null contents)
	   t
	   (null (record-field-contents contents)))))

;;; Format is (description . list)
(define-presentation-type 1record-group-list0 ()
   :printer ((ignore stream) (format stream "List of Records")))

(zwei:define-presentation-to-editor-command-translator 1show-record-group-list
0						       (record-group-list "Show"
									  zwei:*standard-comtab*
									  :gesture :left)
						       (list)
  (flet ((doit (list)
	   (destructuring-bind (description . list) list
	     (format t "~&~A" description)
	     (indenting-output (*standard-output* 2)
	       (dolist (rg list)
		 (format t "~&~A" rg))))))
    `(,#'doit ,list)))

(defun 1find-orphan-records0 (mapping-continuation)
  (labels ((orphanp (rg)
	     (null (record-group-callers-after-installing-edited-records-if-necessary rg)))
	   (pseudo-orphanp (rg)
	     (let ((callers
		     (record-group-callers-after-installing-edited-records-if-necessary rg)))
	       (and callers
		    (loop for (link-type . nil) in callers
		   never (member link-type '(sage::expand sage::contents))))))
	   (no-recordp (rg)
	     (and (null (record-group-published-record rg))
		  (null (record-group-edited-records rg))))
	   (emptyp (rg)
	     (let ((record (find-record-for-lookup rg)))
	       (or (null record)		;??
		   (record-contents-empty-p record))))
	   (rg-lessp (rg1 rg2)
	     (string-lessp (record-group-topic-completion rg1)
			   (record-group-topic-completion rg2)))
	   (format-header (count format-string format-args)
	     (let ((many-p ( count 1)))
	       (format t "There ~:[is~;are~] ~D record~:P that ~:[is~;are~] ~?" 
		       many-p
		       count many-p format-string
		       (cons many-p format-args))))
	   (format-rgs (list format-string format-args)
	     (fresh-line)
	     (cond ((< (length list) 10)
		    (format-header (length list) format-string format-args)
		    (write-char #\:)
		    (indenting-output (*standard-output* 2)
		      (loop for rg in list
			    do
			(terpri)
			(format t "~A" rg))))
		   (t (dw:with-output-as-presentation
			  (:object (cons
				     (format nil "Records that are ~?"
					     format-string
					     (cons t
						   format-args))
				     list)
			   :type 'record-group-list)
			(format-header (length list) format-string format-args)
			(format t ".  (Click here to see them)"))))))
    (let ((orphan-rgs ())
	  (pseudo-orphan-rgs ())
	  (no-rgs ())
	  (empty-orphan-rgs ())
	  (empty-pseudo-orphan-rgs ())
	  (empty-rgs ()))
      (funcall mapping-continuation 
	       (lambda (rg)
		 (let* ((orphanp (orphanp rg))
			(pseudo-orphanp (pseudo-orphanp rg))
			(no-recordp (no-recordp rg))
			(emptyp (unless no-recordp (emptyp rg))))
		   (cond (no-recordp (push rg no-rgs))
			 ((and orphanp emptyp)
			  (push rg empty-orphan-rgs))
			 ((and pseudo-orphanp emptyp)
			  (push rg empty-pseudo-orphan-rgs))
			 (pseudo-orphanp
			  (push rg pseudo-orphan-rgs))
			 (orphanp 
			  (unless (document-p rg)	;toplevel documents are ok...
			    (push rg orphan-rgs)))
			 (emptyp (push rg empty-rgs))))))
      (setq no-rgs (sort no-rgs #'rg-lessp))
      (setq empty-orphan-rgs (sort empty-orphan-rgs #'rg-lessp))
      (setq pseudo-orphan-rgs (sort pseudo-orphan-rgs #'rg-lessp))
      (setq empty-pseudo-orphan-rgs (sort empty-pseudo-orphan-rgs #'rg-lessp))
      (setq orphan-rgs (sort orphan-rgs #'rg-lessp))
      (setq empty-rgs (sort empty-rgs #'rg-lessp))
      (macrolet ((format-records (variable format-string &rest format-args)
		   `(when ,variable
		      (format-rgs ,variable ,format-string ,format-args))))
	(format-records no-rgs "linked to but ~:[has~;have~] no record at all (i.e. ~
                                ~:*~:[is~;are~] \"bogus\")")
	(format-records empty-orphan-rgs "empty and ~:[is~;are~] not linked to")
	(format-records orphan-rgs "not linked to but ~:[has~;have~] contents")
	(format-records empty-rgs "linked to but ~:[has~;have~] no contents")
	(format-records pseudo-orphan-rgs "linked to only by Crossreference or Precis links~%~
                                           and ~:[has~;have~] contents")
	(format-records empty-pseudo-orphan-rgs
			"linked to only by Crossreference or Precis links~%~
                         and ~:[has~;have~] no contents")))))

;;; How many such functions are there??
(defun 1map-over-rgs-in-buffer0 (buffer continuation &optional progress-note)
  (tv:noting-progress-if progress-note (progress-note)
    (let ((count 0)
	  (denominator (length (zwei:node-inferiors buffer))))
      (dolist (n (zwei:node-inferiors buffer))
	(incf count)
	(when (zwei:record-node-p n)
	  (let ((rg (zwei:record-node-record-group n)))
	    (unless (record-group-killed rg)
	      (funcall continuation rg))))
	(when progress-note (tv:note-progress count denominator))))))

(zwei:defcom 1com-wt-find-orphan-records-in-buffer0 "Finds all orphan records in the buffer."
	     ()
  (find-orphan-records #'(lambda (continuation)
			   (map-over-rgs-in-buffer zwei:*interval* continuation
						   "Finding orphans in buffer")))
  zwei:dis-none)

(defmacro 1do-doc-buffers-in-tag-buffer0 ((tag-buffer progress-note buffer)
				      &body body)
  `(do-doc-buffers-in-tag-buffer-1 ,tag-buffer ,progress-note
				 (dw:named-continuation do-doc-buffers-files-in-tag-buffer
							(,buffer)
				   ,@body)))

;;; This might some day be made to read the record info from the
;;; sab file with read-index-info.  If the record groups do not
;;; exis in the world, the file would then be loaded.  This has got
;;; to work faster than reading in all the stupid files into ConEd.
(defun 1do-doc-buffers-in-tag-buffer-10 (tag-buffer progress-note continuation)
  (tv:noting-progress (progress-note)
    (send tag-buffer :restart)
    (catch 'zwei:zwei-command-loop
      (loop for next-node = (send tag-buffer :next-node t)	;peek at the node
	    while next-node
	    as pathname = (send next-node :pathname)
	    for numerator from 0
	    with denominator = (1- (length (zwei:node-inferiors tag-buffer)))
	    do
	(tv:note-progress numerator denominator)
	(if (eq (send pathname :canonical-type) :sage-binary)
	    (funcall continuation (send tag-buffer :next-file nil nil nil))
	    (send tag-buffer :next-node))))))	;advance to the next node

(zwei:defcom 1com-wt-find-orphan-records-in-tag-table0 "Finds all orphan records for buffers in the current tag table."
	     ()
  (let ((tag-table (zwei:select-tag-table nil)))
    (find-orphan-records
      (lambda (continuation)
	(do-doc-buffers-in-tag-buffer (tag-table "Finding orphans in tag table" buffer)
	  (map-over-rgs-in-buffer buffer continuation)))))
  zwei:dis-none)

(zwei:defcom 1com-wt-find-orphan-records0 "Finds all records that either have no links to them or have no contents."
	     ()
  (find-orphan-records
    (lambda (continuation)
      (map-over-the-record-groups continuation "Finding all orphans")))
  zwei:dis-none)
