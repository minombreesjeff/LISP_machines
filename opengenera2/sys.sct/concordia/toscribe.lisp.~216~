;;; -*- Mode: LISP; Package: NSAGE; Base: 10.; Lowercase: T; Syntax: Common-lisp -*- 
;;;
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
;;;

;;;For converting from Sage source files to source files for Scribe.

(defvar D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")*default-toscribe-pathname*0 nil)

(defvar 1*default-toscribe-document-type*0 '(symanual 3))

(defvar 1*error-if-unconvertable-object*0 nil)

(cp:define-command (1com-convert-topic-to-scribe0 :command-table "user")
    ((topic 'record-group)
     (destination '((token-or-type (:screen)
				   ((pathname) :default-type :mss)))
		  :default (or *default-toscribe-pathname*
			       (setq *default-toscribe-pathname*
				     (send (fs:default-pathname) :new-pathname
					   :canonical-type :mss
					   :version :newest)))
		  :prompt "a pathname, or Screen"
		  )
     &key
     (process-unconvertables 'boolean :default t
	   :documentation "Whether to convert unconvertable Concordia constructs into simple strings or signal an error.")) 
   #+Franz
   (format T "Convert ~\\presentation\\ to ~a"
	   topic destination)
   (let ((*error-if-unconvertable-object* (not process-unconvertables)))
     (or
       (catch 'no-valid-type
	 (if (eql destination :screen)
	     (convert-topic-to-scribe *standard-output* topic)
	     (with-open-file (scribe-output destination ':direction ':output)
	       (setq *default-toscribe-pathname* destination)
	       (convert-topic-to-scribe scribe-output topic)))
	 T)
       (format *error-output* "~&Topic needed a valid type, which wasn't supplied.~%"))))

(defun 1convert-topic-to-scribe0 (stream record-group)
  ;;---Caution: The following form CAN set the type back to NIL in the following case:
  ;;You are trying to convert a fragment record at top level.  It gets classified as
  ;;type 'sage:chapter by com-show-converted-definition and when you try to find it
  ;;here as a chapter, it returns nil, making resolve-type result be nil and so on.
  ;;I'm leaving this broken because it gives the right result this way and presumably
  ;;we'll fix it all differently when we do a correct type system.
  #+Ignore ;;---the above seems to be inoperative in the face of record groups, right?
  (setq type (resolve-type (get-sage-property spec
					      (when type (intern type *sage-package*))
					      'source-type)))
  ;; Lookup the document type as a property of the document, and use the default if the
  ;; type is not explicitly specified.
  (keeping-sage-files
    (let* ((record (find-record-for-lookup record-group))
	   (doc-type (doc-record-document-type record)))
      ;; Can be a symbol representing the doc type, or a list of a doc type symbol and
      ;; a form number for that doc type.
      (typecase doc-type
	(null (setq doc-type *default-toscribe-document-type*))
	(symbol (setq doc-type (list doc-type))))
      (zl:destructuring-bind (*document-type* default-form)
	  doc-type
	(let ((root-document			;needed for purposes of page crossreferencing
		(or (registered-book-for-record-group record-group)
		    (in-which-book record-group)
		    record-group)))
	  ;; emit the @Make(...)
	  (format stream "@Make(~a~@[, Form=~a~])~%"
		  *document-type* default-form)
	  (when *scribe-device*
	    (format stream "@Device(~A)~%" *scribe-device*))
	  (mss-record stream record 'mss-everything root-document)
	  (terpri)
	  t)))))


;;; Write Scribe expansion of a record and all its callees.
;;; doc-record is a doc record, not a record-group.
;;; view-template-name - lets you specify how to show the record
(defun 1mss-record0 (stream doc-record &optional view-template-name top-level)
  (assert (typep doc-record 'doc-record) ()
	  "An internal consistency check failed.~@
	   The doc-record argument ~s is not a doc-record."
	  doc-record)
  (find-doc-record-contents doc-record :installed)
  (when (doc-record-contents-bogus doc-record)
    ;; It's pretty hard to figure out after the fact why it was bogus.
    ;; Look at find-doc-record-contents and the callers (and methods)
    ;; of fill-doc-record-bogus-contents.
    (format *error-output*
	    "~&***** Only bogus contents were accessible for the record ~\\presentation\\~%"
	    doc-record))
  (flet ((doit ()
	   (mss-view-under-template doc-record stream view-template-name)))
    (cond (top-level
	   (let ((record-group (doc-record-record-group doc-record)))
	     (rooting-record-expansion (record-group top-level)
	       (doit)))
	   (format stream "~&@indfinalpage()~%@Unnumbered[Index]~%"))
	  (T (doit)))))

;;;========================================
;;; VIEW TEMPLATES
;;;========================================

;;A view-template-name is either a message name, or a list of the message name and
;;any additional args the view method would need.
(defmethod 1(mss-view-under-template doc-record)0 (stream view-template-name)
  (multiple-value-bind (view-function view-args)
      (typecase view-template-name
	(null (values 'mss-everything ()))
	(cons (values (first view-template-name) (rest view-template-name)))
	(otherwise (values view-template-name ())))
    (unless (operation-handled-p self view-function)
      (break "The view template name ~s appears to be unhandled" view-template-name)
      (setq view-function 'mss-everything
	    view-args nil))
    (apply view-function self stream view-args)))

(defmethod 1(mss-everything lisp-record)0 (stream)
  (let* ((topic (record-group-topic record-group))
	 (type (coerce-record-type source-type 'print-name))
	 (source-topic-cl (appropriate-title-rendering record-group 'formatting self))
	 (topic-cl source-topic-cl)
	 (noise (case type (method "of") (|INIT OPTION| "for") (otherwise ())))
	 (fname))
    (using-resource (type-string string-temp)
      (string-nconc type-string type)
      (nstring-capitalize-words type-string)
      (using-resource (args-string string-temp)
	(with-output-to-string (stream args-string)
	  (mss-contents-list stream (record-field-contents arglist) t))
	(nsubstitute #\space #\return args-string :test #'char-equal)
	(when (member type '(method |INIT OPTION|))	;the topic function spec is list
	  (zl:destructuring-bind (sym flavor-name message-name)
	      ;; --- Kludge alert: This is here to make old method specs work.
	      ;; Remove when new record type system is installed.
	      (if (and (symbolp topic)
		       (eq (symbol-package topic) zwei:*utility-package*))
		  (read-from-string (symbol-name topic))
		  topic)
	    (when (eq sym 'flavor:method) (rotatef flavor-name message-name))
	    (with-standard-sage-io-environment
	      (setq fname (format nil "~(~S~)" flavor-name)
		    topic-cl (list (format nil "~(~S~)" message-name))))))
	(using-resource (topic-string string-temp)
	  (with-output-to-string (stream topic-string)
	    (mss-contents-list stream topic-cl))
	  (let ((topic-str (double-chars-in-string '(#\@) topic-string)))
	    (when fname (setq fname (double-chars-in-string '(#\@) fname)))
	    (write-string (case type
			    (method "@DefMethodX")
			    (|INIT OPTION| "@DefInitOptionsX")
			    (otherwise "@DefThingX"))
			  stream)
	    (format stream
		    "<~@[fname={~A},~]spec={~A},~@[noise={~A},~]args=~\\{}\\,type={~A}>~%"
		    fname topic-str noise
		    args-string
		    type-string)
	    (format-lisp-object-index-command stream topic-str type-string noise fname))
	  (fresh-line stream)
	  (format-label
	    stream source-topic-cl
	    (first (get (coerce-record-type type 'property) 'external-symbols)))
	  (fresh-line stream))
	(write-string "@begin[DefText]" stream)
	(terpri stream))))
  (mss-record-field self 'keywords&contents stream)
  (fresh-line stream)
  (format stream "@end[DefText]~%"))

(defmethod 1(mss-everything concept-record)0 (stream)
  ;;throw away topic for top-level books; let Scribe take care of the titles for them
  (let ((type (record-group-type record-group))) ;;---Should this be source-type?
    (unless (and (document-p record-group) (= (length *sage-expansion-history*) 1))
      (format-short-form stream
			 (case type
			   (fragment 'subheading)	;---these are kludges until doc hierarchies
			   (appendix 'appendix)	;are designed correctly
			   (appendixsection 'appendixsection)
			   (otherwise (appropriate-section-level)))
			 (appropriate-title-rendering record-group
						      'formatting-using-title-field
						      self))
      (fresh-line stream)
      (let ((source-topic-cl (appropriate-title-rendering record-group 'formatting self)))
	(format-short-form stream "Index" source-topic-cl)
	(fresh-line stream)
	(format-label stream source-topic-cl
		      (first (get (coerce-record-type type 'property) 'external-symbols)))
	(terpri stream)))
    (mss-record-field self 'keywords&contents stream)
    (fresh-line stream)))

;;;========================================
;;; IMPLEMENTATION OF FIELDS
;;;========================================

(defmethod 1(mss-record-field-list doc-record)0 (stream &rest field-names)
  (dolist (field-name field-names)
    (mss-record-field self field-name stream)))

(defgeneric 1mss-record-field0 (doc-record field-name stream)
  (:method-combination :case))

(defmethod 1(mss-record-field lisp-record arglist)0 (stream)
  (when arglist
    (mss-within-environment stream 'I arglist)))

(defmethod 1(mss-record-field doc-record oneliner)0 (stream)
  (when oneliner
    (mss-within-environment stream 'R oneliner)))

;;;We are going to the trouble of not emitting an empty @Index{} because doing
;;;so appears to blow Scribe out of the water.
(defmethod 1(mss-record-field doc-record keywords)0 (stream)
  (let ((kw (record-field-contents keywords)))
    (when (and kw				;something in keywords to look at
	       (notevery #'just-white-space kw))
      (format-keywords stream kw))))

(defmethod 1(mss-record-field doc-record contents)0 (stream)
  (when contents
    (mss-contents-list stream (record-field-contents contents))))

(defmethod 1(mss-record-field doc-record keywords&contents)0 (stream)
  (mss-record-field self 'keywords stream)
  (fresh-line stream)
  (mss-record-field self 'contents stream))

(defmethod 1(mss-record-field concept-record fragment-contents)0 (stream)
  ;;why is it putting the title of the fragment in the index? (most writers want it)
  (format-short-form stream "Index"
		     (appropriate-title-rendering record-group 'formatting self))
  (mss-record-field self 'keywords stream)
  (mss-record-field self 'contents stream))

(defmethod 1(mss-record-field doc-record related)0 (stream)
  (let ((related (doc-record-related self)))
    (when related
      (mss-within-environment stream 'DISPLAY related))))

(defmethod 1(mss-record-field doc-record releasenumber)0 (stream)
  (let ((release-number (doc-record-releasenumber self)))
    (when release-number
      (mss-within-environment stream 'R release-number))))

(defmethod 1(mss-record-field lisp-record topic)0 (stream)
  (mss-within-environment
    stream 'L (appropriate-title-rendering record-group 'formatting self)))

(defmethod 1(mss-record-field concept-record topic)0 (stream)
  (let ((contents-list
	  (appropriate-title-rendering record-group 'formatting self))
	(document-p (document-p record-group)))
    (mss-within-environment
      stream
      (if document-p 'I 'R)
      (if document-p
	  contents-list
	  `("\"" ,@contents-list "\"")))))

(defmethod 1(mss-record-field doc-record type)0 (stream)
  (mss-things-within-environment stream 'r (string (record-group-type record-group))))

#+Franz ;; How to get abbrev?
(defmethod 1(mss-record-field concept-record abbrev)0 (stream)
  (when abbrev
    (mss-things-within-environment stream 'r (string abbrev))))

(defmethod 1(mss-record-field doc-record notes)0 (stream)
  (let ((notes (doc-record-notes self)))
    (when notes
      (mss-within-environment stream 'r notes))))

;;;========================================
;;; CONTENTS LISTS AND INTRODUCING ENVIRONMENTS
;;;========================================

(defmacro 1recasing-stream0 ((stream how) &body body)
  (multiple-value-bind (downcase once-only)
      (ecase how
	(:lower (values T ()))
	(:upper (values () ()))
	(:initial (values ':capitalize-each T)))
    `(let ((format:*DOWNCASE-FLAG* ',downcase)
	   (format:*ONCE-ONLY-FLAG* ',once-only)
	   (format:*OLD-STREAM* ,stream)
	   (,stream 'format:upcase-stream))
       (declare format:(SPECIAL *DOWNCASE-FLAG* *ONCE-ONLY-FLAG* *OLD-STREAM*))
       ,@body)))

;;;Displays a contents list, which is a list of elements which are either strings or 
;;;environment directives.
(defun 1mss-contents-list0 (stream contents-list &optional trim-whitespace)
  (when (typep contents-list 'symbol)		;---kludge because topics are done wrong
    (setq contents-list (list (capitalize-as-title contents-list 'formatting))))
  (dolist (elt
	    (if trim-whitespace
		(trim-whitespace-from-ends-of-contents-list contents-list)
		contents-list))
    (etypecase elt
      (null ())					;this seems to happen occasionally
      (string (write-string elt stream))
      (sage-directive (mss-directive elt stream)))))

(defun 1mss-things-within-environment0 (stream new-environment &rest contents-list)
  (mss-within-environment stream new-environment contents-list))

(defun 1mss-within-environment0 (stream envr-name&mods contents-list)
  (multiple-value-bind (envr-name envr-mods)
      (if (consp envr-name&mods)
	  (values (first envr-name&mods) (second envr-name&mods))
	  (values envr-name&mods ()))
    (mss-within-new-environment stream envr-name envr-mods contents-list)))

(defmethod 1(mss-directive sage-envr)0 (stream)
  (unless (eql envr-name 'commentary)
    (mss-within-new-environment
      stream envr-name
      (remove (assoc 'mouse-sensitivity envr-mods) envr-mods)
      contents-list)))

(defmethod 1(mss-directive sage-picture)0 (stream)
  (when *error-if-unconvertable-object*
    (cerror "Continue converting the topic, ignoring future errors"
	    "Attempting to convert a picture to Scribe.  This is not supported.")
    (setq *error-if-unconvertable-object* nil))
  (format stream "[[Picture ~:[unnamed~;~:*~A~]~@[ from file ~A~]]]"
	  name file-name))

(defmethod 1(mss-directive sage-text-structure)0 (stream) 
  (mss-contents-list stream (contents-list-from-sage-text-structure self)))

(defun 1mss-within-new-environment0 (stream envr-name mods contents-list)
  (labels ((maybe-convert-contents-list (cl)
	     (let (new-cl collect-em)
	       (labels ((do-some (cl)
			  (loop for ele in cl
				for ele-count from 0
				do
			    (typecase ele
			      (string
				(let ((string (double-chars-in-string
						'(#\@)
						(if (eq envr-name 'LS)
						    (si:string-downcase-if-necessary ele)
						    ele))))
				  (unless (eq string ele)
				    (setq ele string)
				    (unless collect-em
				      (setq collect-em t)
				      (loop repeat ele-count
					    for thing in cl
					    do (push thing new-cl))))
				  (when collect-em
				    (push ele new-cl))))
			      (sage-text-structure
				(do-some
				  (contents-list-from-sage-text-structure ele)))
			      (otherwise
				(when collect-em
				  (push ele new-cl)))))))
		 (do-some cl))
	       (if new-cl (nreverse new-cl) cl)))
	   (foo (begin)
	     (declare (sys:downward-function))
	     (write-char #\@ stream)
	     (write-string begin stream)
	     (write-char #\[ stream)
	     (format-initial-caps stream envr-name))
	   (long-form ()
	     (declare (sys:downward-function))
	     (foo "begin")
	     (loop for mod in mods
		   do (write-char #\, stream)
		   do (format-attribute stream mod))
	     (write-char #\] stream)
	     (mss-contents-list stream (maybe-convert-contents-list contents-list))
	     (foo "end")
	     (write-char #\] stream)))
    (cond ((and contents-list
		(null (rest contents-list))
		(null mods)
		(typecase (first contents-list)
		  (string (and (< (string-length (first contents-list)) 100.)
			       (not (string-search-char #\newline (first contents-list)))))
		  (sage-text-structure
		    (let ((int (sage-text-structure-interval (first contents-list))))
		      (and (not (zwei:interval-fat-p int))
			   (< (zwei:count-chars int) 100)
			   ( (zwei:count-lines int) 1))))
		  (otherwise nil)))
	   (let ((string
		   (etypecase (first contents-list)
		     (string (first contents-list))
		     (sage-text-structure
		       (string-thin
			 ;; ---I suppose we could reduce string consing here...
			 (zwei:string-interval
			   (sage-text-structure-interval (first contents-list)))
			 :remove-bits t :error-if :fat)))))
	     (multiple-value-bind (open close) (choose-safe-delim string)
	       (cond ((and open close)
		      (write-char #\@ stream)
		      (format-initial-caps stream envr-name)
		      (write-char open stream)
		      (write-string (first (maybe-convert-contents-list (list string)))
				    stream)
		      (write-char close stream))
		   (T (long-form))))))
	  (T (long-form)))))

(defun 1mss-lisp-object-title0 (stream spec real-spec-p device)
  (cond ((or real-spec-p (symbolp spec))	;catch symbols & method specs
	 ;;function specs are tricky
	 (write-string (string-for-lisp-object-title spec) stream))
	((eq device ':paper)			;---should be :mss.  Spec s/b a contents list.
	 (recasing-stream (stream :lower)
	   (mss-contents-list stream spec)))	;---bug, doesn't do package binding
	(T (princ spec stream))))

;;;========================================
;;; COMMANDS, MACROS, AND THEIR ARGUMENTS
;;;========================================

(defmethod 1(mss-directive sage-command)0 (stream)
  (mss-command self stream))

(define-sage-command-generic 1mss-command0 (stream)
  (if (null parameter)
      (let ((dd (lookup-command-descriptor command-name)))
	(let ((sym (string (dd-symbol dd))))
	  (write-char #\@ stream)
	  (cond ((and (= 1 (string-length sym))
		      (not (alpha-char-p (aref sym 0))))
		 (princ sym stream))
		(T (format-initial-caps stream command-name)
		   (write-string "()" stream)))))
      (unparse-command stream command-name parameter)))

(define-sage-command-method 1(mss-command L)0 (stream)
  (mss-within-new-environment
    stream 'L ()
    (list (mss-string-from-L-command self))))

(defun 1mss-string-from-L-command0 (command)
  (display-string-from-L-command command))

(define-sage-command-method 1(mss-command lisp)0 (stream)
  (read-eval-format stream parameter))

(define-sage-command-method 1(mss-command counter)0 (stream)
  (unparse-counter-command stream parameter))

(defmethod 1(mss-directive sage-macro-call)0 (stream)
  (case macro-name
    ((reference expand)			;---expand is supposed to be obsolete.
     ;;---This is a kludge: @reference is now a sage-reference, not a macro call
     (mss-reference-from-macro stream macro-args))
    (otherwise
      (let* ((dd (lookup-directive-descriptor macro-name))
	     (@-expression (expand-sage-macro-into-expression dd macro-name macro-args))
	     (contents-list 
	       (convert-@-to-directives @-expression T)))
	(mss-contents-list stream contents-list)))))

(defmethod 1(mss-directive sage-reference)0 (stream)
  (mss-reference stream record-group
		 :view view
		 :field field
		 ;; :level level
		 ))

(defun 1unparse-command0 (output-stream command-name arglist)
  (using-resource (contents-string string-temp)
    (with-output-to-string (stream contents-string)
      (let ((dd (lookup-command-descriptor command-name))
	    (first? T))
	(flet ((comma ()
		 (declare (sys:downward-function))
		 (unless first? (write-string ", " stream))
		 (setq first? ())))
	  ;;Do positional args
	  (let ((max (dd-max-pos-args dd)))
	    (loop repeat (if (eq max :) 999999999. max)
		  for (nil param-type) in (dd-positional-args dd) 
		  while arglist
		  do (comma)
		     (unparse-argument-value stream param-type (pop arglist) :delimit)))
	  ;;Do &KEY args, if any
	  (let ((key-params (dd-key-args dd)))
	    (when key-params
	      #+Franz
	      (loop for (param-name param-type) in key-params
		    while arglist
		    for arg = (assq param-name arglist)
		    when arg
		      do (comma)
			 (unparse-command-key stream param-type arg)
			 (setq arglist (delq arg arglist)))
	      (loop while arglist		;No &ANY-KEY or &ALL or &LIST-OF can follow.
		    for arg = (pop arglist)
		    for (arg-name nil) = arg
		    for (nil param-type) = (assoc arg-name key-params)
		    when (null param-type)
		      do (error "Arg ~s is not in param-list ~s" arg key-params)
		    do (comma)
		       (unparse-command-key stream param-type arg))))
	  ;;Do &ANY-KEY arg
	  (let ((any-keys-param (dd-any-keys dd)))
	    (when any-keys-param
	      (comma)
	      (destructuring-bind (ignore param-type) any-keys-param
		(unparse-command-any-keys stream param-type arglist)
		(setq arglist ()))))
	  ;;Do &ALL arg
	  (let ((all-param (dd-all dd)))
	    (when all-param
	      (comma)
	      (destructuring-bind (ignore param-type) all-param
		(unparse-argument-value stream param-type (pop arglist) :nodelimit))))
	  ;;Do &LIST-OF arg
	  (let ((list-of-param (dd-list-of dd)))
	    (when list-of-param
	      (comma)
	      (destructuring-bind (ignore param-type) list-of-param
		(unparse-command-list-of stream param-type arglist))
	      (setq arglist ())))
	  ;;Make sure we did 'em all.
	  (unless (null arglist)
	    (error "Failed to process entire arglist (internal error) ~s" arglist)))))
    (format-short-form output-stream command-name (list contents-string))))

;;; this turns a selectq clause of the form (key action) into ((sage:key :key) action)
;;; and one of the form ((key1 key2) action) into ((sage:key1 :key1 sage:key2 :key2) action)
;;; all in the name of dealing with types that are sometimes specified as keywords and
;;; sometimes as symbols in the SAGE package
(defmacro 1selectq-with-package-fix0 (value . clauses)
  `(zl:selectq ,value
     ,.(loop for clause in clauses
	     as (keys . action) = clause
	     collect (if (if (consp keys)
			     (not (some #'symbolp keys))
			     (or (member keys '(otherwise t nil))
				 (not (symbolp keys))))
			 clause
			 (si:coerce-to-list keys
			   `(,(si:eliminate-duplicates
				(loop for key in keys
				      when (symbolp key)
					nconc (list (intern (string key) *sage-package*)
						    (intern (string key) sys:pkg-keyword-package))
				      else collect key))
			     . ,action))))))

;;; This used to be called UNPARSE-COMMAND-POSITIONAL, but unparsing the command arguments
;;; turns out to be just the same as unparsing the attribute arguments.  The assumption being
;;; made is that the set of argument types for attributes is the same as the set for commands.
;;; If a conflict arises and something needs to be processed differently in the two cases, the
;;; simplist solution is to come up with unique names for the two cases.
(defun 1unparse-argument-value0 (stream param-type arg delimit)
  ;;--- gack.  commands use keyword forms of these types, attributes use symbols
  ;;--- selectq-with-package-fix is a temporary write-around for this.  The real
  ;;--- answer is to decide which package is right and change all the definitions
  (selectq-with-package-fix param-type
    ((:horizontal-distance :vertical-distance
      :horizontal-distance-relative :vertical-distance-relative)
     (cond ((member (first arg) '(+ -))
	    (princ (pop arg) stream))
	   ((null (first arg)) (pop arg)))
     (format stream "~d" (pop arg))
     (when arg (format-initial-caps stream (first arg))))
    ((:number :integer :positive-integer :nonnegative-integer)
     (format stream "~d" arg))
    (:none )					;Do I care to verify that the arg is NIL?
    (:boolean
     (princ (if arg "Yes" "No") stream))
    ((:cmd-or-envr-name :symbol :device-name :document-type :counter-name :variable)
     (format-initial-caps stream arg))
    (:contents-list
     (ecase delimit
       (:delimit (format-safe-delims stream arg))
       (:nodelimit (mss-contents-list stream arg))))
    (:text (write-string arg stream))
    (:string-for-lisp-reading
      (format stream "~A"
	      (double-chars-in-string
		'(#\@)
		(mss-string-from-L-command arg))))
    (:template 
     (using-resource (string string-temp)
       (with-output-to-string (str string)
	 (mss-counter-template str arg))
       (format-safe-delims stream string)))
    (:list-of-fields
     (error ":list-of-fields in command (internal error)"))
    (counter (princ arg stream))		;counter name
    ((T) (princ arg stream))			;any old thing
    (otherwise
     (if (consp param-type)			;an enumeration
	 (format-initial-caps stream arg)
	 (error "Bad param-type ~s (internal error)" param-type)))))

(defun 1unparse-command-key0 (stream param-type arg)
  (destructuring-bind (key-name key-val) arg
    (format-initial-caps stream key-name)
    (unless (eq param-type :none)
      (write-char #\= stream)
      (unparse-argument-value stream param-type key-val :delimit))))

(defun 1unparse-command-any-keys0 (stream param-type args)
  (loop for first? = T then ()
	for arg in args
	unless first? do (write-string ", " stream)
	do (unparse-command-key stream param-type arg)))

(defun 1unparse-command-list-of0 (stream param-type args)
  (loop for first? = T then ()
	for arg in args
	unless first? do (write-string ", " stream)
	do (unparse-argument-value stream param-type arg :delimit)))

(defun 1mss-counter-template0 (stream arg)
  (loop for first = T then ()
	for element in arg
	unless first do (write-string "@," stream)
	do (loop for code in element
		 do (if (consp code)
			(selector (first code) char-equal
			  ((#\: #\;) (format stream "@~c~c" (first code) (second code)))
			  (otherwise		;else it's a contents list
			   (mss-contents-list stream code)))
			(format stream "@~c" code)))))

(defun 1unparse-counter-command0 (output-stream arglist)
  (using-resource (contents-string string-temp)
    (with-output-to-string (stream contents-string)
      (princ (pop arglist) stream)		;name
      (loop for (argname val) in arglist
	    for dd = (lookup-counter-attribute-descriptor argname)
	    when (null dd) do (error "No lookup-counter-attribute-descriptor ~s" argname)
	    for param-type = (second (first (dd-arglist dd)))
	    do (write-string ", " stream)
	       (format-initial-caps stream argname)
	       (write-char #\= stream)
	       (unparse-argument-value stream param-type val :delimit)))
    (format-short-form output-stream 'counter (list contents-string))))

;;;========================================
;;; ENVR SHORT FORM, LONG FORM; KEYWORDS FIELD
;;;========================================

(defun 1format-short-form0 (stream name contents)
  (format-name-safe-delims stream name contents)
  (when (or (string-equal name "multiple") (string-equal name "description"))
    (write-char #\newline stream)))

(defun 1format-name-safe-delims0 (stream name contents)
  (write-char #\@ stream)
  (format-initial-caps stream name)
  (format-safe-delims stream contents)
  (when (string-equal name "index")		;---required for safety, due to randomness
    (write-string "@~" stream)))			;of newlines inserted by converter

(defun 1format-initial-caps0 (stream string)
  (recasing-stream (stream :initial)
    (princ string stream)))

(defun 1format-lowercase0 (stream string)
  (recasing-stream (stream :lower)
    (princ string stream)))

(defun 1format-safe-delims0 (stream contents-list)
  (using-resource (string string-temp)
    (with-output-to-string (stream string)
      (mss-contents-list stream contents-list))
    (multiple-value-bind (open close) (choose-safe-delim string)
      (write-char open stream)
      (write-string string stream)
      (write-char close stream))))

(defun 1format-keywords0 (format-dest keywords)
  (let ((keyword-contents-lists (convert-contents-list-to-keywords-list keywords)))
    (dolist (contents-list keyword-contents-lists)
      (flet ((wrap-index-contents-list ()
	       (format-short-form format-dest "Index" contents-list)))
	(when contents-list
	  (format format-dest "~&")
	  (typecase (first contents-list)
	    (string (wrap-index-contents-list))
	    (sage-directive
	      (cond ((typep (first contents-list) 'sage-command)
		     ;;if it's index, ship it out, else wrap @index() around it
		     (if (eq (send (first contents-list) :command-name) 'index)
			 (mss-contents-list format-dest contents-list)
			 (wrap-index-contents-list)))
		    ((typep (first contents-list) 'sage-macro-call)
		     ;;---expand is obsolete, as always
		     (if (member (send (first contents-list) :macro-name) '(reference expand))
			 (if (not (= 1 (length contents-list)))
			     (error "Stuff on line following reference ~s" contents-list)
			     (let* ((interim (send (first contents-list) :macro-args))
				    (type (extract-parse-and-return-type interim))
				    (topic (extract-parse-and-return-topic interim)))
			       (multiple-value-bind (open close) (choose-safe-delim topic)
				 (format format-dest "@Index~c@L~c~(~a~)~c ~(~a~)~c"
					 open open topic close type close))))
			 (wrap-index-contents-list)))
		    (T (wrap-index-contents-list))))
	    (otherwise (error "Unrecognized data type for first of ~s" contents-list))))))))

;; This really wants topic-string and type, not a record-group or something.
;; Its caller has already taken care of that.
(defun 1format-lisp-object-index-command0 (format-dest topic-string type noise fname)
  (let (index-open index-close
	topic-open topic-close
	fname-open fname-close)
    (using-resource (inner-closes string-temp)
      (multiple-value-setq (topic-open topic-close)
	(choose-safe-delim topic-string))
      (vector-push-extend topic-close inner-closes)
      (when fname
	(multiple-value-setq (fname-open fname-close)
	  (choose-safe-delim fname))
	(vector-push-extend fname-close inner-closes))
      (multiple-value-setq (index-open index-close)
	(choose-safe-delim inner-closes))
      (format format-dest "@Index~C" index-open)
      (format format-dest "@L~C~A~C ~(~a~)" topic-open topic-string topic-close type)
      (when noise (format format-dest " ~A" noise))
      (when fname (format format-dest " @L~C~A~C" fname-open fname fname-close))
      (format format-dest "~C" index-close)
      (format format-dest "@~C" #\~))))

;;; our callers better really pass us a stream, not a string
(defun 1format-attribute0 (stream attribute)
  (destructuring-bind (attribute-name value) attribute
    (format-initial-caps stream attribute-name)
    (let ((dd (lookup-attribute-descriptor attribute-name)))
      (unless (eq (dd-parse-type dd) :attribute)
	(error "~s is not a known attribute." dd))
      ;; this only deals with the first positional arg, are there cases with
      ;; more than one?
      (destructuring-bind ((ignore arg-type) &rest ignore) (dd-positional-args dd)
	(unless (eq arg-type :none)
	  (write-char #\space stream)
	  (unparse-argument-value stream arg-type value :delimit))))))

;;;Takes a contents list and treats it as Lisp code.  It is probably true that such a list
;;; ought to consist of just one string.  Hard to say I guess.  Depends on whether someone
;;; embeds some kind of non-lisp garbage in the @lisp environment source.
;;;---Issues: "print" doesn't do it.  We probably want to control printing based on
;;;the type of the result.  Also have to figure out how to control spacing and carriage
;;;return stuff from here.  Modularity problem?
;;; Here we are assuming that the writer assumes responsibility for how anything is
;;; going to look on the screen.  Basically, this means that @lisp takes care of read and
;;; eval and the writer gets to/has to specify "print".  We'll see how this works out in
;;; practice.  Any other thing is probably going to be wrong and won't leave the writer
;;; with any hooks to get around it.
(defun 1read-eval-format0 (format-dest contents-list)
  (when (> (length contents-list) 1)
    (error "Didn't expect the contents-list to have more than one element:~&~S"
	    contents-list))
  (let ((result (eval (read-from-string (car contents-list)))))
    (format format-dest "~A" result)))

;;;Routine to turn topic names into unique (we hope) labels.  The trick is not
;;;to include any of the characters that Scribe won't eat in labels.
(defun 1format-label0 (stream topic-cl type-string)
  ;;We know we can use [] as delims because we're already translating everything else.
  (write-string "@Label[" stream)
  (format-label-string stream topic-cl type-string)
  (write-char #\] stream))

;; Caller can use [] as delims because we're already translating everything else.
(defun 1format-label-string0 (stream topic-cl type-string)
  (labels ((translate (op &optional arg1 &rest rest)
	     (declare (sys:downward-function))
	     (case op
	       (:tyo
		(let ((replacement
			(selector arg1 char-equal
			  ;; this list contains most of the interesting punctuation
			  ;; Probably it containts things that would be OK if found
			  ;; in labels.  Hopefully it doesn't leave any dangerous
			  ;; ones out.
			  ((#\SP #\-) #\-)
			  (#\_ "*underscore*")
			  (#\/ "*slash*")
			  (#\+ "*plus*")
			  (#\= "*equal*")
			  (#\@ "*atsign*")
			  (#\, "*comma*")
			  (#\; "*semicolon*")
			  (#\{ "*leftbrace*")
			  (#\} "*rightbrace*")
			  (#\[ "*leftbracket*")
			  (#\] "*rightbracket*")
			  (#\< "*lessthan*")
			  (#\> "*greaterthan*")
			  (#\( "*leftparen*")
			  (#\) "*rightparen*")
			  (#\" "*stringquote*")
			  (#\' "*apostrophe*")
			  (#\` "*backquote*")
			  (otherwise arg1))))
		  (send stream (if (stringp replacement) :string-out :tyo) replacement)))
	       (:which-operations
		'(:tyo))
	       (otherwise
		(sys:stream-default-handler #'translate op arg1 rest)))))
    (mss-contents-list #'translate topic-cl)
    (write-char #\- stream)
    (translate :string-out type-string)))

;;;========================================
;;; SAGE REFERENCES
;;;========================================

;;;parm-list is list of parm/value pairs
;;;assumption: topic and type were checked at parse time and should be valid symbols here.
;;;The values of most parms other than topic and type are either NIL or a string.  BUT
;;;the field parm can be either a string or a symbol naming the field.
;;;This implements "prinlevel" style of expansion.  The source @Expand says how many
;;;prior expansions are permitted before it switches to just using a cross-ref.
;;;Current theory of the source format:
;;;Obsolete syntax: @Expand(Topic=<foo>,type=<Function>,Never)
;;;@Reference(Topic=<foo>,type=<Function>,View=<CrossRef>,Field=<operation>,Level=<5>)
;;;View={CrossRef,Expand},Field=names of fields, default is all,Level=All or a number
;;;---Lurking problem with the very fuzzy understanding of what "type" means.  There
;;;is the external type (what the user called it, which is pretty random), the corresponding
;;;internal type, the type that we are going to pretend that it is for purposes of the
;;;document hierarchy, and so on.  These are all confused in here.
(defun 1mss-reference0 (stream record-group &key view field)
  (let ((level *expansion-level-override*)	;things we might find in parms
	view-template dont-increment-level crossref-p)
    (unless (listp view) (setq view (list view)))
    (setq crossref-p
	  (cond ((null view) ())
		((member (first view) '(crossref crossreference) :test #'string-equal) T)
		((string-equal (first view) "expand") ())
		(T (format *error-output* "~&Unrecognized VIEW ~s~%" view)
		   T)))
    (when field
      ;; we want to avoid incrementing the level when a Field is supplied.
      (setq dont-increment-level t)
      ;;---bug: ignores legitimate fields like "Related" 
      (when (consp field) (setq field (first field)))
      (let ((appropriate-template (if (symbolp field) field 'contents)))
	(setq view-template
	      `(mss-record-field-list
		 ,(if (eq appropriate-template 'contents)
		      (if (eq (record-group-type record-group) 'fragment)
			  'fragment-contents
			  'keywords&contents)
		      appropriate-template)))))
    ;;---Removed "support" for level=... in the reference
    ;; (LEVEL (unless level (setq level (read-from-string (first contents)))))

    (cond ((and (not crossref-p)
		(member record-group *sage-expansion-history*))	;already expanded?
	   (setq crossref-p t))			;keep from vicious circles
	  ((and (not crossref-p)		;not yet expanded
		(and level (neq level ':all)	;see if we're beyond limit yet (NIL=no limit)
		     (> (length *sage-expansion-history*) level)))	;(':all= no limit)
	   (setq crossref-p t)))		;if deep enough, inhibit
    (if crossref-p
	(announce-cross-reference stream record-group)
	(let ((record (find-record-for-lookup record-group)))
	  (cond (record
		 (nesting-record-expansion (record-group)
		   (mss-record stream record view-template nil)))
		(T (format *error-output*
			   "~&***** The record-group ~\\presentation\\ ~
				appears to be undefined~%"
			   record-group)
		   (format stream " ***** [Attempt to include undefined record ~a] *****"
			   (appropriate-title-rendering record-group 'no-formatting))))))))

(defun 1mss-reference-from-macro0 (stream macro-args)
  (let (topic type field view)
    (loop for (parm contents) in macro-args	;these could be in any order
	  do
      (ecase parm
	(TOPIC (setq topic contents))
	(TYPE (setq type contents))
	(FIELD (setq field contents))
	(VIEW (setq view contents))
	;;(LEVEL (setq level contents))
	))
    (cerror "Attempt to recover"
	    "Obsolete code (or obsolete sab files) have called for a reference as a macro.~@
	      topic ~s~@
	      type ~s~@
	      view ~s~@
	      field ~s"
	    topic type field view)
    (let ((record-group (find-record-group-for-topic-and-type topic type () T)))
      (mss-reference stream record-group :view view :field field))))

;;;This makes a sentence but does not make the mistake of believing that it knows
;;;what context the sentence appears in.  this is so that people can enclose it in
;;;parens or quotes or whatever.
(defun 1announce-cross-reference0 (stream record-group)
  (mss-contents-list
    stream
    (make-scribe-crossref-contents-list record-group)))	;include page number or document name

;;; For references to things contained in the same book.  Since books are SCRIBEd as units,
;;; it is possible to include the actual page number of the reference.
;;; This function is a modified copy of make-crossref-contents-list with pageref stuff added
;;; and mouse sensitive stuff removed, and should be updated as appropriate.
(defun 1make-scribe-crossref-contents-list0 (record-group)
  (let* ((type (record-group-type record-group))
	 (title (appropriate-title-rendering record-group 'formatting))
	 (same-book (in-this-book-p *root-document* record-group))
	 (ref-type (if (concept-type-p type)
		       (if (document-p record-group) 'book 'section)
		       'lisp))
	 (doc-record (find-record-for-lookup record-group)))
    `("See the "
      ,(case ref-type
	 (book "document ")
	 (section "section \"")			;quotes around section name only
	 (lisp (string-append
		 (string-downcase (or (doc-record-source-type doc-record) type))
		 " ")))
      ,(make-sage-envr (case ref-type
			 (book 'I)
			 (section 'R)
			 (lisp 'LS))
		       nil
		       title)
      ,(if (eq ref-type 'section)
	   "\""
	   "")
      ,@(if same-book				; assumes a book is not "in" iteself
	   `(", page "
	     ,(make-sage-command
		'pageref
		(list
		  (with-output-to-string (s)
		    ;; format-label-string was split out of format-label
		    ;; --- Using constant type here for all references makes @Reference
		    ;; calls with Type=Chapter or Type=Constant work.  The other callers of
		    ;; format-label, (:METHOD CONCEPT-DOC-RECORD :MSS-EVERYTHING) and
		    ;; (:METHOD LISP-DOC-RECORD :MSS-EVERYTHING), also use a constant.
		    (format-label-string
		      s title
		      (first (get (coerce-record-type type 'property) 'external-symbols)))))))
	   ;; else clause: (not same-book)
	   ;;Remove this else clause to suppress references to things in other documents.
	   ;;This might be useful when the document structure is expected to change between
	   ;;the printing of the first document and the last, since ensures that a given
	   ;;book only refers to things defined in that book, leaving other books free to
	   ;;be changed (i.e. renamed, sections moved between books, etc.)
	   (if (eq ref-type 'book)
		'("")
		(let ((containing-book (first (zwei:find-topic-documents record-group))))
		  (if (null containing-book)
		      ;; The reference belongs in no book.  This probably indicates a bug in
		      ;; something, but avoid a blowout into the debugger anyway.
		      '("")
		      `(" in "
			,(make-sage-envr 'I	; we know it's a book
					 nil
					 (appropriate-title-rendering containing-book 'formatting)))))))
      ".")))
